<!DOCTYPE html>
<html lang="es">

<head>
  <meta charset="UTF-8">
  <title>GraphDB - RBAC + Security (WebAuthn Example - Corregido vFINAL)</title>
  <style>
    body { font-family: sans-serif; margin: 20px; background-color: #f9f9f9; }
    .container { max-width: 700px; margin: auto; background-color: #fff; padding: 20px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }
    button { padding: 8px 12px; margin: 5px 5px 5px 0; cursor: pointer; background-color: #007bff; color: white; border: none; border-radius: 4px; transition: background-color 0.2s; }
    button:hover { background-color: #0056b3; }
    button:disabled { background-color: #ccc; cursor: not-allowed; color: #666;}
    input[type="text"], input[type="password"] { padding: 8px; margin-right: 5px; border: 1px solid #ddd; border-radius: 4px; box-sizing: border-box; }
    .section { margin-bottom: 20px; padding: 15px; border: 1px solid #eee; border-radius: 5px; background-color: #fff; }
    .section h2 { margin-top: 0; color: #333; border-bottom: 1px solid #eee; padding-bottom: 5px; }
    .section p, .section hr { margin-top: 10px; margin-bottom: 10px; }
    pre { background-color: #f0f0f0; padding: 10px; font-size: 0.9em; max-height: 150px; overflow-y: auto; border-radius: 4px; border: 1px solid #ddd; white-space: pre-wrap; word-break: break-all; }
    textarea { width: calc(100% - 22px); min-height: 60px; margin-top:5px; padding: 10px; border: 1px solid #ddd; border-radius: 4px; box-sizing: border-box;}
    .button-group button { margin-right: 10px; }
    .info-box { background-color: #e7f3fe; border-left: 6px solid #2196F3; padding: 10px; margin-bottom:15px; }
  </style>
</head>
<body>
  <div class="container">
    <h1>GraphDB - RBAC + Security (WebAuthn Example - Corregido vFINAL)</h1>
    <p>Consola del navegador para logs. Usa WebAuthn (biometría/llave) para seguridad.</p>
    <p class="info-box"><em>Importante: WebAuthn requiere HTTPS o localhost/127.0.0.1.</em></p>

    <div class="section">
      <h2>1. Gestión de Identidad (WebAuthn)</h2>
      <p><strong>Paso 1: Crear Nueva Identidad Ethereum (si no tienes)</strong></p>
      <button id="createNewIdentityBtn">A. Generar Nueva Identidad ETH</button>
      <p>Mnemónica Generada (¡GUARDAR ANTES DEL PASO B!): <pre id="newMnemonicDisplay">N/A (Se mostrará después de generar)</pre></p>
      
      <p><strong>Paso 2: Proteger Identidad con WebAuthn (Huella/Llave)</strong><br><em>(Opcional. Habilitado si hay una identidad activa no protegida por WebAuthn).</em></p>
      <button id="protectCurrentIdentityWithWebAuthnBtn" disabled>B. Proteger Identidad Actual con WebAuthn</button>
      <hr>
      <p><strong>Iniciar Sesión (si ya tienes identidad protegida con WebAuthn en este navegador)</strong></p>
      <button id="loginWebAuthnBtn">C. Iniciar Sesión con WebAuthn</button>
      <hr>
      <p><strong>Iniciar Sesión / Recuperación (usando tu frase mnemónica guardada)</strong></p>
      <input type="text" id="mnemonicLoginInput" placeholder="Ingresa tu frase mnemónica" style="width:calc(100% - 250px); margin-bottom:5px;">
      <button id="loginOrRecoverWithMnemonicBtn">D. Iniciar Sesión / Recuperar con Mnemónica</button>
      <hr>
      <button id="logoutBtn" disabled>E. Cerrar Sesión</button>
      <p>Estado Global: <strong id="statusGlobal">Inicializando...</strong></p>
    </div>

    <div class="section" id="userInfoSection" style="display:none;">
       <h2>2. Información del Usuario Activo</h2>
       <p>Dirección ETH Activa: <strong id="ethAddressActive">N/A</strong></p>
       <p>Rol en GDB: <strong id="userRoleActive">N/A</strong></p>
       <p>Sesión Protegida por WebAuthn: <strong id="webAuthnProtectionStatus">Desconocido</strong></p>
       <p><button id="showMnemonicCurrentSessionBtn" disabled>Mostrar Mnemónica (Sesión Actual)</button></p>
    </div>

    <div class="section">
      <h2>3. Escribir/Actualizar Datos (Nodo)</h2>
      <input type="text" id="dataNodeIdWrite" placeholder="ID del Nodo" value="test_data_webauthn_v_final">
      <input type="text" id="dataNodeValueWrite" placeholder='Valor JSON' value='{"message":"Dato vFinal con WebAuthn"}'>
      <button id="putDataBtn" disabled>Guardar/Actualizar Dato</button>
    </div>

     <div class="section">
      <h2>4. Leer Datos (Nodo)</h2>
      <input type="text" id="dataNodeIdRead" placeholder="ID del Nodo a Leer" value="test_data_webauthn_v_final">
      <button id="getDataBtn" disabled>Leer Dato</button>
      <div class="result-area">
        Resultado Lectura: <pre id="getDataResult">N/A</pre>
      </div>
    </div>

    <div class="section">
      <h2>5. Cifrado/Descifrado para Usuario Actual</h2>
      <textarea id="dataToEncryptInput" placeholder='Dato JSON a cifrar, ej: {"secret":"mi mensaje secreto"}'></textarea>
      <div class="button-group">
        <button id="encryptSelfBtn" disabled>Cifrar Dato para Mí</button>
        <button id="decryptSelfBtn" disabled>Descifrar Dato para Mí</button>
      </div>
      <p>Dato Cifrado (Resultado): <pre id="encryptedDataDisplay">N/A</pre></p>
    </div>

    <div class="section">
      <h2>6. Administración de Roles</h2>
      <input type="text" id="targetEthForRole" placeholder="0xTargetEthParaRol" value=""> 
      <input type="text" id="roleToAssign" placeholder="Rol (ej: manager)" value="manager">
      <button id="assignRoleBtn" disabled>Asignar Rol</button>
    </div>

    <div class="section">
      <h2>7. Simulación Recepción P2P</h2>
      <button id="simulateReceiveBtn" disabled>Simular 'put' P2P (Firma Inválida)</button>
    </div>

    <p>Logs de Acciones Recientes: <pre id="actionLog">---</pre></p>
  </div>

  <script type="module">
    import { GraphDB } from "../dist/index.js"; // Ajusta ruta
    import * as rbac from '../dist/rbac.min.js'; // Ajusta ruta // ¡CAMBIO IMPORTANTE!

    const SUPERADMIN_ETH_ADDRESSES = [];
    
    let db;
    let uiLog = "";
    let unsubscribeUserRoleListener = null;
    let currentVolatileIdentity = null; 

    const createNewIdentityBtn = document.getElementById('createNewIdentityBtn');
    const newMnemonicDisplayEl = document.getElementById('newMnemonicDisplay');
    const protectCurrentIdentityWithWebAuthnBtn = document.getElementById('protectCurrentIdentityWithWebAuthnBtn');
    const loginWebAuthnBtn = document.getElementById('loginWebAuthnBtn');
    const mnemonicLoginInputEl = document.getElementById('mnemonicLoginInput');
    const loginOrRecoverWithMnemonicBtn = document.getElementById('loginOrRecoverWithMnemonicBtn');
    const logoutBtn = document.getElementById('logoutBtn');
    const statusGlobalEl = document.getElementById('statusGlobal');
    const userInfoSectionEl = document.getElementById('userInfoSection');
    const ethAddressActiveEl = document.getElementById('ethAddressActive');
    const userRoleActiveEl = document.getElementById('userRoleActive');
    const webAuthnProtectionStatusEl = document.getElementById('webAuthnProtectionStatus');
    const showMnemonicCurrentSessionBtn = document.getElementById('showMnemonicCurrentSessionBtn');
    const dataNodeIdWriteInput = document.getElementById('dataNodeIdWrite');
    const dataNodeValueWriteInput = document.getElementById('dataNodeValueWrite');
    const putDataBtnEl = document.getElementById('putDataBtn');
    const dataNodeIdReadInput = document.getElementById('dataNodeIdRead');
    const getDataBtnEl = document.getElementById('getDataBtn');
    const getDataResultEl = document.getElementById('getDataResult');
    const dataToEncryptInput = document.getElementById('dataToEncryptInput');
    const encryptSelfBtn = document.getElementById('encryptSelfBtn');
    const encryptedDataDisplay = document.getElementById('encryptedDataDisplay');
    const decryptSelfBtn = document.getElementById('decryptSelfBtn');
    const assignRoleBtnEl = document.getElementById('assignRoleBtn');
    const targetEthForRoleInput = document.getElementById('targetEthForRole');
    const roleToAssignInput = document.getElementById('roleToAssign');
    const simulateReceiveBtnEl = document.getElementById('simulateReceiveBtn');
    const actionLogEl = document.getElementById('actionLog');

    function logAction(message) {
        const timestamp = new Date().toLocaleTimeString();
        const logMessage = `[${timestamp}] ${message}`;
        console.log("APP_LOG:", logMessage);
        uiLog = logMessage + "\n" + uiLog; 
        const maxLogLines = 50;
        const lines = uiLog.split('\n');
        if (lines.length > maxLogLines) { uiLog = lines.slice(0, maxLogLines).join('\n'); }
        actionLogEl.textContent = uiLog;
    }

    function updateUserRoleInUI(userNodeData) {
        const currentEth = rbac.getActiveEthAddress();
        if (!currentEth) { userRoleActiveEl.textContent = 'N/A'; return; }
        if (userNodeData && userNodeData.value && userNodeData.value.role) {
            let roleText = userNodeData.value.role;
            if (userNodeData.value.expiresAt && new Date(userNodeData.value.expiresAt) < new Date()) {
                roleText += " (Expirado)";
            }
            userRoleActiveEl.textContent = roleText;
        } else if (userNodeData === null) { 
             userRoleActiveEl.textContent = 'No asignado (o nodo eliminado)';
        } else {
             userRoleActiveEl.textContent = 'Cargando...'; 
        }
    }

    async function displayUserInfoAndSetupListener() {
        const currentEth = rbac.getActiveEthAddress();
        if (unsubscribeUserRoleListener) { unsubscribeUserRoleListener(); unsubscribeUserRoleListener = null; }
        if (!currentEth || !db) {
            userInfoSectionEl.style.display = 'none';
            return;
        }
        ethAddressActiveEl.textContent = currentEth;
        webAuthnProtectionStatusEl.textContent = rbac.isCurrentSessionProtectedByWebAuthn() ? "Sí" : "No";
        userInfoSectionEl.style.display = 'block';
        userRoleActiveEl.textContent = 'Cargando rol...';
        try {
            await db.ready; 
            const userNodeKey = `user:${currentEth}`;
            const { result, unsubscribe } = await db.get(userNodeKey, updateUserRoleInUI);
            unsubscribeUserRoleListener = unsubscribe;
            updateUserRoleInUI(result); 
        } catch (error) {
            logAction(`Error obteniendo rol/listener para ${currentEth}: ${error.message}`);
            userRoleActiveEl.textContent = 'Error al cargar rol';
        }
    }
    
    createNewIdentityBtn.addEventListener('click', async () => {
      try {
        logAction("Identidad: Iniciando generación...");
        updateUIState(true, "Generando identidad ETH...");
        currentVolatileIdentity = await rbac.startNewUserRegistration();
        if (currentVolatileIdentity) {
          newMnemonicDisplayEl.textContent = `Dirección ETH: ${currentVolatileIdentity.address}\n\n¡GUARDA ESTA FRASE MNEMÓNICA AHORA MISMO EN UN LUGAR SEGURO Y OFFLINE!\n\n${currentVolatileIdentity.mnemonic}\n\nUna vez guardada, puedes opcionalmente protegerla con WebAuthn (Botón B) o iniciar sesión con ella (Botón D).`;
          logAction(`Identidad: ETH generada para ${currentVolatileIdentity.address}. Mnemónica mostrada.`);
        } else {
          newMnemonicDisplayEl.textContent = "Error generando identidad.";
          logAction("Identidad: Error en startNewUserRegistration.");
        }
      } catch (error) {
        logAction(`Identidad: Error generando: ${error.message}`);
        alert(`Error: ${error.message}`);
        newMnemonicDisplayEl.textContent = "Error.";
      } finally {
        updateUIState(false); 
      }
    });

    protectCurrentIdentityWithWebAuthnBtn.addEventListener('click', async () => {
      if (!currentVolatileIdentity || !currentVolatileIdentity.privateKey) {
        alert("Primero genera (Botón A) o recupera (Botón D) una identidad ETH para proteger.");
        return;
      }
      try {
        logAction("Identidad: Iniciando protección con WebAuthn para la identidad actual...");
        updateUIState(true, "Registrando WebAuthn... Sigue las instrucciones de tu navegador/SO.");
        const activeAddress = await rbac.protectCurrentIdentityWithWebAuthn(currentVolatileIdentity.privateKey);
        if (activeAddress) {
          logAction(`Identidad: Protegida con WebAuthn y sesión iniciada para ${activeAddress}.`);
          newMnemonicDisplayEl.textContent = "¡Identidad protegida con WebAuthn y sesión iniciada!";
          currentVolatileIdentity = null; 
        } else {
          logAction("Identidad: Falló la protección con WebAuthn. Revisa la consola.");
          newMnemonicDisplayEl.textContent = "Falló el registro WebAuthn. Revisa la consola del navegador para más detalles. Asegúrate de estar en HTTPS o localhost.";
           alert("Falló la protección con WebAuthn. Revisa la consola.");
        }
      } catch (error) {
        logAction(`Identidad: Error protegiendo con WebAuthn: ${error.message}`);
        alert(`Error en WebAuthn: ${error.message || error}`);
      } finally {
        updateUIState(false);
      }
    });

    loginWebAuthnBtn.addEventListener('click', async () => {
      try {
        logAction("Identidad: Intentando iniciar sesión con WebAuthn...");
        updateUIState(true, "Autenticando con WebAuthn... Sigue las instrucciones.");
        const address = await rbac.loginCurrentUserWithWebAuthn();
        if (address) {
          logAction(`Identidad: Sesión iniciada con WebAuthn para ${address}.`);
          newMnemonicDisplayEl.textContent = "Sesión iniciada con WebAuthn.";
          currentVolatileIdentity = null;
        } else {
          logAction("Identidad: Falló el inicio de sesión con WebAuthn.");
          newMnemonicDisplayEl.textContent = "Falló el inicio de sesión WebAuthn. ¿Registraste un autenticador?";
          alert("Falló el inicio de sesión WebAuthn. Asegúrate de haber registrado un autenticador para este sitio y que lo estés usando correctamente.");
        }
      } catch (error) {
        logAction(`Identidad: Error iniciando sesión con WebAuthn: ${error.message}`);
        alert(`Error en WebAuthn: ${error.message || error}`);
      } finally {
        updateUIState(false);
      }
    });

    loginOrRecoverWithMnemonicBtn.addEventListener('click', async () => {
      const mnemonic = mnemonicLoginInputEl.value.trim();
      if (!mnemonic) { alert("Ingresa tu frase mnemónica."); return; }
      try {
        logAction("Identidad: Intentando inicio de sesión/recuperación con mnemónica...");
        updateUIState(true, "Cargando identidad desde mnemónica...");
        const identityData = await rbac.loginOrRecoverUserWithMnemonic(mnemonic); 
        if (identityData && rbac.isSecurityActive()) {
          currentVolatileIdentity = identityData; 
          newMnemonicDisplayEl.textContent = `Sesión iniciada con mnemónica para ${identityData.address}.\nFrase (temporalmente en memoria): ${identityData.mnemonic}\n\nPuedes opcionalmente proteger esta sesión con WebAuthn (Botón B).`;
          mnemonicLoginInputEl.value = "";
          logAction(`Identidad: Sesión iniciada para ${identityData.address} usando mnemónica.`);
        } else {
          logAction("Identidad: Falló el inicio de sesión/recuperación con mnemónica.");
          newMnemonicDisplayEl.textContent = "Falló. Verifica tu mnemónica.";
          alert("Error al iniciar sesión/recuperar con mnemónica. ¿Es correcta?");
          currentVolatileIdentity = null;
        }
      } catch (error) {
        logAction(`Identidad: Error con mnemónica: ${error.message}`);
        alert(`Error: ${error.message}`);
        currentVolatileIdentity = null;
      } finally {
        updateUIState(false);
      }
    });
    
    logoutBtn.addEventListener('click', async () => {
      logAction("Identidad: Cerrando sesión...");
      updateUIState(true, "Cerrando sesión...");
      if (unsubscribeUserRoleListener) { unsubscribeUserRoleListener(); unsubscribeUserRoleListener = null; }
      await rbac.clearSecurity();
      newMnemonicDisplayEl.textContent = 'N/A (Crea o inicia sesión)';
      currentVolatileIdentity = null;
      logAction("Identidad: Sesión cerrada.");
      updateUIState(false);
    });

    showMnemonicCurrentSessionBtn.addEventListener('click', () => {
        const mnemonicToShow = currentVolatileIdentity?.mnemonic || rbac.getMnemonicForDisplayAfterRegistrationOrRecovery();
        if (mnemonicToShow) {
            const confirmation = confirm("ADVERTENCIA: Estás a punto de mostrar tu frase mnemónica secreta. Asegúrate de que nadie más esté viendo tu pantalla.\n\n¿Deseas continuar?");
            if (confirmation) {
                alert(`Tu frase mnemónica (de la identidad actual en memoria) es:\n\n${mnemonicToShow}\n\n¡NO la compartas!`);
                logAction("Identidad: Mnemónica de sesión actual mostrada.");
            } else { logAction("Identidad: Usuario canceló mostrar mnemónica."); }
        } else {
            alert("No hay una mnemónica \"fresca\" para mostrar. Genera una nueva identidad o recupérala si necesitas verla.");
            logAction("Identidad: Intento de mostrar mnemónica, pero no disponible.");
        }
    });

    putDataBtnEl.addEventListener('click', async () => {
        const nodeId = dataNodeIdWriteInput.value.trim() || undefined;
        let nodeValue;
        try { nodeValue = JSON.parse(dataNodeValueWriteInput.value.trim()); }
        catch (e) { logAction("Escritura: Valor no es JSON válido."); alert("Valor no es JSON."); return; }
        if (!rbac.isSecurityActive()) { logAction("Escritura: Usuario no conectado."); alert("Conéctate primero."); return; }
        try {
            logAction(`Escritura: Iniciando para ID '${nodeId || "nuevo"}'.`);
            updateUIState(true, "Firmando y guardando...");
            await rbac.executeWithPermission(db, 'write', async (userAddr) => {
                const idResultado = await db.put(nodeValue, nodeId);
                logAction(`Escritura: ¡Operación completada para ID '${idResultado}'!`);
                alert(`¡Dato guardado/actualizado! ID: ${idResultado}`);
            });
        } catch (error) { logAction(`Escritura: Error: ${error.message}`); alert(`Error: ${error.message}`); }
        finally { updateUIState(false); }
    });
    getDataBtnEl.addEventListener('click', async () => {
        const nodeId = dataNodeIdReadInput.value.trim();
        if (!nodeId) { logAction("Lectura: ID requerido."); getDataResultEl.textContent = "N/A - Ingresa ID."; return; }
        if (!db) { logAction("Lectura: GDB no lista."); getDataResultEl.textContent = "N/A - GDB no lista."; return; }
        logAction(`Lectura: db.get('${nodeId}')...`);
        getDataResultEl.textContent = "Cargando...";
        updateUIState(true, "Leyendo dato...");
        try {
            const { result } = await db.get(nodeId);
            if (result) { getDataResultEl.textContent = JSON.stringify(result, null, 2); }
            else { getDataResultEl.textContent = "Nodo no encontrado."; }
            logAction(`Lectura: Finalizada para '${nodeId}'.`);
        } catch (error) { logAction(`Lectura: Error: ${error.message}`); getDataResultEl.textContent = `Error: ${error.message}`; }
        finally { updateUIState(false); }
    });
    encryptSelfBtn.addEventListener('click', async () => {
        if (!rbac.isSecurityActive()) { alert("Inicia sesión primero."); return; }
        let dataToEncrypt;
        try { const inputText = dataToEncryptInput.value.trim(); if (!inputText) { alert("Ingresa JSON."); return; } dataToEncrypt = JSON.parse(inputText); }
        catch(e) { alert("No es JSON válido."); return; }
        try {
            logAction("Cifrado: Cifrando..."); updateUIState(true, "Cifrando...");
            const encrypted = await rbac.encryptDataForCurrentUser(dataToEncrypt);
            encryptedDataDisplay.textContent = encrypted; logAction("Cifrado: Éxito.");
        } catch(error) { logAction(`Cifrado: Error: ${error.message}`); alert(`Error: ${error.message || error}`);}
        finally { updateUIState(false); }
    });
    decryptSelfBtn.addEventListener('click', async () => {
        if (!rbac.isSecurityActive()) { alert("Inicia sesión primero."); return; }
        const encryptedString = encryptedDataDisplay.textContent;
        if (!encryptedString || encryptedString === 'N/A') { alert("No hay dato cifrado."); return; }
        try {
            logAction("Descifrado: Descifrando..."); updateUIState(true, "Descifrando...");
            const decrypted = await rbac.decryptDataForCurrentUser(encryptedString);
            alert("Dato Descifrado:\n\n" + JSON.stringify(decrypted, null, 2)); logAction("Descifrado: Éxito.");
        } catch(error) { logAction(`Descifrado: Error: ${error.message}`); alert(`Error: ${error.message || error}`);}
        finally { updateUIState(false); }
    });
    assignRoleBtnEl.addEventListener('click', async () => {
        const targetEth = targetEthForRoleInput.value.trim(); const role = roleToAssignInput.value.trim();
        if (!targetEth || !role) { alert("Ingresa ETH y rol."); return; }
        if (!rbac.isSecurityActive()) { alert("Conéctate primero."); return; }
        try {
            logAction(`Rol: Asignando '${role}' a '${targetEth}'.`); updateUIState(true, "Asignando rol...");
            await rbac.executeWithPermission(db, 'assignRole', async (userAddr) => {
                await rbac.assignRole(db, targetEth, role);
                logAction(`Rol: Asignación completada.`);
            });
            alert("Solicitud de asignación de rol enviada.");
        } catch (error) { logAction(`Rol: Error: ${error.message}`); alert(`Error: ${error.message}`); }
        finally { updateUIState(false); }
    });
    simulateReceiveBtnEl.addEventListener('click', async () => {
        logAction(">>> P2P Sim: INICIO.");
        if (!db || !db.securityManager) { logAction("P2P Sim: No db/SM."); return; }
        const op = { type: 'put', id: 'p2p_sim_' + Date.now(), value: {msg:"sim"}, timestamp: Date.now(), originUser:"0x123", originEthAddress:"0x123", signature:"0xbad"};
        logAction(`P2P Sim: Verificando op...`); updateUIState(true, "Simulando P2P...");
        try {
            const { validatedOperations } = await db.securityManager.verifyIncomingOperations([op]);
            if (validatedOperations && validatedOperations.length > 0) { logAction("P2P Sim: ¡VALIDADA! (Error en SM)."); }
            else { logAction(`P2P Sim: NO validada (esperado).`); }
        } catch (e) { logAction(`P2P Sim: ERROR: ${e.message}`); }
        finally { updateUIState(false); logAction("<<< P2P Sim: FIN.");}
    });

    function updateUIState(isLoading = false, statusText = null) {
      const securityIsActive = rbac.isSecurityActive();
      const webAuthnLocallyRegistered = rbac.hasExistingWebAuthnRegistration();
      const identityReadyForWebAuthnProtection = !!currentVolatileIdentity; 
      const currentSessionIsWebAuthnProtectedByRbac = rbac.isCurrentSessionProtectedByWebAuthn();

      // Gestión de Identidad
      createNewIdentityBtn.disabled = isLoading || securityIsActive || identityReadyForWebAuthnProtection;
      
      const canProtect = identityReadyForWebAuthnProtection && !currentSessionIsWebAuthnProtectedByRbac;
      protectCurrentIdentityWithWebAuthnBtn.disabled = isLoading || !canProtect;
      
      loginWebAuthnBtn.disabled = isLoading || securityIsActive || !webAuthnLocallyRegistered;
      mnemonicLoginInputEl.disabled = isLoading || securityIsActive || identityReadyForWebAuthnProtection;
      loginOrRecoverWithMnemonicBtn.disabled = isLoading || securityIsActive || identityReadyForWebAuthnProtection;
      logoutBtn.disabled = isLoading || !securityIsActive;
      
      showMnemonicCurrentSessionBtn.disabled = isLoading || !identityReadyForWebAuthnProtection;


      // Operaciones GDB
      const gdbOpsDisabled = !securityIsActive || isLoading;
      putDataBtnEl.disabled = gdbOpsDisabled;
      getDataBtnEl.disabled = !db || isLoading; 
      encryptSelfBtn.disabled = gdbOpsDisabled;
      decryptSelfBtn.disabled = gdbOpsDisabled || encryptedDataDisplay.textContent === 'N/A';
      assignRoleBtnEl.disabled = gdbOpsDisabled;
      simulateReceiveBtnEl.disabled = gdbOpsDisabled || !db?.securityManager;


      if (isLoading) {
        statusGlobalEl.textContent = statusText || "Procesando...";
      } else {
        if (securityIsActive) {
            const protectionType = currentSessionIsWebAuthnProtectedByRbac ? 'WebAuthn' : 'Mnemónica';
            statusGlobalEl.textContent = `Seguridad Activa (${protectionType})`;
        } else if (identityReadyForWebAuthnProtection) {
            statusGlobalEl.textContent = "Identidad ETH en memoria. Guarda mnemónica y/o protege con WebAuthn (Botón B).";
        } else if (webAuthnLocallyRegistered) {
            statusGlobalEl.textContent = "Seguridad Inactiva. Inicia sesión con WebAuthn (Botón C) o recupera.";
        } else {
            statusGlobalEl.textContent = "Seguridad Inactiva. Crea una identidad (Botón A) o recupera.";
        }
      }

      if (securityIsActive) {
        displayUserInfoAndSetupListener();
      } else {
        userInfoSectionEl.style.display = 'none';
        if (unsubscribeUserRoleListener) { unsubscribeUserRoleListener(); unsubscribeUserRoleListener = null; }
      }
    }

    async function initializeApp() {
      logAction("App: Iniciada. Creando instancia GDB...");
      db = new GraphDB("gdbWebAuthn_vFINAL_HTML"); 
      try {
        await db.ready;
        logAction("App: GDB lista.");
      } catch (e) {
        logAction("App: Error GDB: " + e.message); alert("Error GDB. Revisa consola.");
        statusGlobalEl.textContent = "Error GDB."; return;
      }
      
      rbac.setSecurityStateChangeCallback((securityState) => {
        logAction(`App: Callback RBAC - Activo: ${securityState.isActive}, ETH: ${securityState.activeAddress}`);
        if (!securityState.isActive) { currentVolatileIdentity = null; } 
        updateUIState();
      });
      
      await rbac.createSecurityContext(db, SUPERADMIN_ETH_ADDRESSES);
      logAction("App: Contexto de seguridad RBAC establecido.");
      
      updateUIState(); 
    }

    initializeApp();
  </script>
</body>
</html>