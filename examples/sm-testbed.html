<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Security Manager (SM Testbed) - Best Practices</title>
  <style>
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      margin: 0;
      padding: 20px;
      background-color: #f4f7f9;
      color: #333;
      font-size: 14px;
    }

    .container {
      max-width: 900px;
      margin: auto;
      background-color: #fff;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
    }

    h1,
    h2,
    h3 {
      color: #2c3e50;
      border-bottom: 1px solid #eee;
      padding-bottom: 5px;
    }

    .section {
      margin-bottom: 25px;
      padding-bottom: 15px;
      border-bottom: 1px dashed #ddd;
    }

    .section:last-child {
      border-bottom: none;
      padding-bottom: 0;
    }

    button {
      background-color: #3498db;
      color: white;
      border: none;
      padding: 8px 12px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
      margin: 5px 2px;
      transition: background-color 0.2s, opacity 0.2s;
    }

    button:hover {
      background-color: #2980b9;
    }

    button:disabled {
      background-color: #bdc3c7;
      cursor: not-allowed;
    }

    input[type="text"],
    input[type="password"],
    textarea {
      width: 100%;
      padding: 8px;
      margin-bottom: 10px;
      border: 1px solid #ccc;
      border-radius: 4px;
      font-size: 14px;
      box-sizing: border-box;
    }

    textarea {
      min-height: 60px;
      resize: none;
      /* BEST PRACTICE: Non-resizable textarea for clean UI */
    }

    .info-box {
      background-color: #e9f7ef;
      border: 1px solid #a7d7c5;
      padding: 10px;
      border-radius: 4px;
      margin-bottom: 10px;
      font-family: monospace;
      word-break: break-all;
    }

    pre {
      background-color: #f0f0f0;
      padding: 10px;
      font-size: 0.9em;
      max-height: 150px;
      overflow-y: auto;
      border-radius: 4px;
      border: 1px solid #ddd;
      white-space: pre-wrap;
      word-break: break-all;
    }

    .log-console {
      background-color: #2c3e50;
      color: #ecf0f1;
      padding: 15px;
      border-radius: 4px;
      height: 250px;
      overflow-y: auto;
      font-family: 'Consolas', 'Courier New', monospace;
      font-size: 12px;
      white-space: pre-wrap;
    }

    .log-console .log-error {
      color: #e74c3c;
    }

    .log-console .log-warn {
      color: #f39c12;
    }

    .log-console .log-info {
      color: #3498db;
    }

    .log-console .log-success {
      color: #2ecc71;
    }

    .flex-group {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: flex-end;
    }

    .flex-group>div {
      flex-grow: 1;
      min-width: 200px;
    }

    .hidden {
      display: none !important;
    }

    fieldset {
      border: 1px solid #ddd;
      border-radius: 6px;
      padding: 15px;
      margin-bottom: 20px;
      background-color: #fdfdfd;
    }

    legend {
      font-size: 1.1em;
      font-weight: bold;
      color: #2c3e50;
      padding: 0 10px;
    }

    details {
      margin-top: 15px;
      border: 1px solid #eee;
      border-radius: 4px;
    }

    summary {
      padding: 10px;
      font-weight: bold;
      cursor: pointer;
      background-color: #f9f9f9;
    }
  </style>
</head>

<body>
  <div class="container">
    <h1>Security Manager (SM Testbed) - Best Practices Applied</h1>
    <p>A comprehensive testbed for GDB identity, RBAC, encryption, and P2P security, state-driven architecture.</p>
    <p><strong>Important:</strong> All actions are logged to the integrated console at the bottom.</p>

    <!-- DB Initialization -->
    <fieldset class="section">
      <legend>1. Database Initialization</legend>
      <div class="flex-group">
        <div>
          <label for="dbNameInput">DB Name (changing this creates a new P2P network):</label>
          <input type="text" id="dbNameInput" value="gdb-robust-test-network">
        </div>
        <div>
          <label for="superAdminInput">Super Admin ETH Address (comma-separated):</label>
          <input type="text" id="superAdminInput" value="0xE5639DfE345F8ab845bEBE63a1C7322F9c6fF5c7"
            placeholder="0xYourAddress1,...">
        </div>
      </div>
      <button id="btnInitializeDB">Initialize DB & RBAC</button>
      <button id="btnHardReset" style="background-color: #e74c3c;"
        title="Deletes all local configuration and reloads the page.">Hard Reset Testbed</button>
      <span id="initStatus" style="margin-left: 10px; font-style: italic;"></span>
    </fieldset>

    <!-- Login/Registration View -->
    <fieldset id="loginView" class="section">
      <legend>2. Identity Management & Status</legend>
      <div class="flex-group">
        <div>
          <!-- BEST PRACTICE: Single textarea for input and output -->
          <label for="mnemonicInput">Mnemonic Phrase (Input for Login / Output for New ID):</label>
          <textarea id="mnemonicInput" rows="3"
            placeholder="Enter 12-word phrase to log in, or click 'Generate New Identity' below."></textarea>
        </div>
      </div>
      <div class="flex-group">
        <!-- BEST PRACTICE: Buttons are shown/hidden based on state -->
        <button id="btnRegisterNewUser">Generate New Identity</button>
        <button id="btnLoginMnemonic">Login with Mnemonic</button>
        <button id="btnLoginWebAuthn" class="hidden">Login with Passkey</button>
        <button id="btnCopyMnemonic" class="hidden">Copy Phrase</button>
        <button id="btnProtectWebAuthn" class="hidden">Protect Account with Passkey & Login</button>
      </div>
      <div id="newIdentityInfo" class="info-box hidden" style="margin-top: 15px;">
        <strong>New ETH Address Generated:</strong> <code id="newEthAddress"></code><br>
        <strong style="color: #c0392b;">IMPORTANT:</strong> Your new mnemonic phrase is in the text area above. Save
        it securely before proceeding!
      </div>
    </fieldset>


    <!-- Logged-In View -->
    <fieldset id="loggedInView" class="section hidden">
      <legend>2. Session Status & Actions</legend>
      <button id="btnLogout">Logout Current User</button>
      <button id="btnShowMnemonic" class="hidden">Show Current Session Mnemonic</button>
      <details open>
        <summary>Session Status Details</summary>
        <div id="securityStatusBox" class="info-box" style="margin-top: 10px; border-top: 1px solid #ddd; padding-top:10px;">
          <p><strong>RBAC Active:</strong> <span id="statusRbacActive">false</span></p>
          <p><strong>Active ETH Address:</strong> <span id="statusActiveAddress">N/A</span></p>
          <p><strong>Current Role (Reactive):</strong> <span id="statusCurrentRole">N/A</span></p>
          <p><strong>Session WebAuthn Protected:</strong> <span id="statusWebAuthnProtected">false</span></p>
          <p><strong>WebAuthn Hardware Registered:</strong> <span id="statusWebAuthnRegistered">false</span></p>
          <p><strong>Volatile Identity in Memory:</strong> <span id="statusVolatileIdentity">false</span></p>
        </div>
      </details>
    </fieldset>


    <!-- Secure Data Storage (Implicit Encryption) -->
    <fieldset class="section">
      <legend>3. Secure Data Storage (Implicit Encryption)</legend>
      <p>Uses <code>db.sm.put()</code> for automatic encryption and <code>db.sm.get()</code> for automatic
        decryption.</p>
      <div class="flex-group">
        <div>
          <label for="secureNoteIdInput">Note ID (leave blank to generate new):</label>
          <input type="text" id="secureNoteIdInput" placeholder="e.g., mySecretNote123">
        </div>
        <div>
          <label for="secureNoteContentInput">Note Content:</label>
          <textarea id="secureNoteContentInput" rows="2">This is a super secret note!</textarea>
        </div>
        <button id="btnSaveSecureNote" disabled>Save Secure Note (db.sm.put)</button>
      </div>
      <hr>
      <div class="flex-group">
        <div>
          <label for="loadSecureNoteIdInput">Note ID to Load:</label>
          <input type="text" id="loadSecureNoteIdInput" placeholder="Enter ID of saved note">
        </div>
        <button id="btnLoadSecureNote" disabled>Load & Decrypt Note (db.sm.get)</button>
      </div>
      <div class="info-box">
        <strong>Loaded Note Content:</strong>
        <pre id="loadedSecureNoteContent" style="white-space: pre-wrap;"></pre>
      </div>
    </fieldset>

    <!-- RBAC & P2P Tests -->
    <fieldset class="section">
      <legend>4. RBAC & P2P Security Tests</legend>
      <div class="flex-group">
        <div>
          <label for="targetEthForRole">Target ETH Address for Role:</label>
          <input type="text" id="targetEthForRole" placeholder="0xTargetAddress">
        </div>
        <div>
          <label for="roleToAssign">Role (e.g., manager):</label>
          <input type="text" id="roleToAssign" value="manager">
        </div>
        <button id="assignRoleBtn" disabled>Assign Role (needs 'assignRole' perm)</button>
      </div>
      <hr>
      <h3>Real-time P2P Security</h3>
      <p><strong>Test Node:</strong> <code>realtime_security_test_node</code>. Changes to this node from any peer will
        appear in the log below if the signature and permissions are valid.</p>
      <div class="flex-group">
        <div>
          <label for="realtimeNodeValueForTest">Value to Write to Test Node:</label>
          <input type="text" id="realtimeNodeValueForTest" value='{"live_test": true, "ts": 0}'>
        </div>
        <div>
          <button id="putLegitP2PBtn" disabled title="Signed write with current session. Should propagate to other tabs if your role allows 'write'.">A. Send LEGITIMATE 'put'</button>
          <button id="putFakeSigP2PBtn" disabled title="Black-box: logout first so there is no signer, then click to attempt a write. Expected: stays local and peers don't receive (SM signature gate on sender).">B. Attempt Unsigned Put (black-box)</button>
          <button id="putNoPermissionP2PBtn" disabled title="Sends a signed write without local permission check. Expected: receivers reject by RBAC if the sender lacks 'write'.">C. Write Without Permission (RBAC on receiver)</button>
        </div>
      </div>
      <div class="info-box" style="margin-top:10px">
        <strong>Test instructions (open two browser tabs pointing to the same DB):</strong>
        <ul style="margin:8px 0 0 18px">
          <li>
            <strong>A. Legitimate put:</strong> Login in Tab A. Click A. Expected: Tab B receives the update in real-time (SM signature check passes and SM RBAC allows 'write').
          </li>
          <li>
            <strong>B. Signature gate (black-box):</strong> In Tab A, <em>logout</em> so there is no active signer, then click <strong>B. Attempt Unsigned Put</strong>. Expected: Tab B does <em>not</em> receive anything. This proves the SM <em>signature gate</em> on the sender: without a signer, the operation is not sent to the network.
          </li>
          <li>
            <strong>C. Without permission:</strong> Login in Tab A with a user that lacks the <code>write</code> permission. Click C. Expected: Tab B does <em>not</em> update. This proves the SM <em>RBAC gate</em> on the receiver: even with a valid signature, the operation is rejected if the role lacks 'write'.
          </li>
        </ul>
      </div>
      <p>Real-time Subscription Log:</p>
      <pre id="realtimeNodeLogDisplay">Waiting for GDB initialization...</pre>
    </fieldset>

    <!-- Console Log -->
    <fieldset class="section">
      <legend>Testbed Console</legend>
  <div id="logConsole" class="log-console"></div>
    </fieldset>
  </div>

  <script type="module">
    // Import libraries (adjust paths if necessary)
    import { gdb } from "../dist/index.js";


    // --- DOM Element Selectors ---
    const dbNameInput = document.getElementById('dbNameInput');
    const superAdminInput = document.getElementById('superAdminInput');
    const btnInitializeDB = document.getElementById('btnInitializeDB');
    const initStatus = document.getElementById('initStatus');
    const btnHardReset = document.getElementById('btnHardReset');

    const loginView = document.getElementById('loginView');
    const loggedInView = document.getElementById('loggedInView');

    const btnRegisterNewUser = document.getElementById('btnRegisterNewUser');
    const newIdentityInfo = document.getElementById('newIdentityInfo');
    const newEthAddressElem = document.getElementById('newEthAddress');
    const btnCopyMnemonic = document.getElementById('btnCopyMnemonic');
    const btnProtectWebAuthn = document.getElementById('btnProtectWebAuthn');
    const btnLoginWebAuthn = document.getElementById('btnLoginWebAuthn');
    const mnemonicInput = document.getElementById('mnemonicInput'); // REFACTORED
    const btnLoginMnemonic = document.getElementById('btnLoginMnemonic');
    const btnLogout = document.getElementById('btnLogout');
    const btnShowMnemonic = document.getElementById('btnShowMnemonic');

    const statusRbacActive = document.getElementById('statusRbacActive');
    const statusActiveAddress = document.getElementById('statusActiveAddress');
    const statusCurrentRole = document.getElementById('statusCurrentRole');
    const statusWebAuthnProtected = document.getElementById('statusWebAuthnProtected');
    const statusVolatileIdentity = document.getElementById('statusVolatileIdentity');
    const statusWebAuthnRegistered = document.getElementById('statusWebAuthnRegistered');

    const secureNoteIdInput = document.getElementById('secureNoteIdInput');
    const secureNoteContentInput = document.getElementById('secureNoteContentInput');
    const btnSaveSecureNote = document.getElementById('btnSaveSecureNote');
    const loadSecureNoteIdInput = document.getElementById('loadSecureNoteIdInput');
    const btnLoadSecureNote = document.getElementById('btnLoadSecureNote');
    const loadedSecureNoteContent = document.getElementById('loadedSecureNoteContent');

    const targetEthForRole = document.getElementById('targetEthForRole');
    const roleToAssign = document.getElementById('roleToAssign');
    const assignRoleBtn = document.getElementById('assignRoleBtn');

    const realtimeNodeValueForTest = document.getElementById('realtimeNodeValueForTest');
    const putLegitP2PBtn = document.getElementById('putLegitP2PBtn');
    const putFakeSigP2PBtn = document.getElementById('putFakeSigP2PBtn');
    const putNoPermissionP2PBtn = document.getElementById('putNoPermissionP2PBtn');
    const realtimeNodeLogDisplay = document.getElementById('realtimeNodeLogDisplay');

    const logConsole = document.getElementById('logConsole');

    // --- Application State ---
    let db = null;
    let volatileIdentityCache = null;
    let roleListenerUnsubscribe = null;
    let realtimeTestNodeUnsubscribe = null;

    const REALTIME_TEST_NODE_ID = 'realtime_security_test_node';

    // --- Logging Utilities ---
    function logToUI(message, type = 'log') {
      const entry = document.createElement('div');
      entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
      const typeToClass = { error: 'log-error', warn: 'log-warn', info: 'log-info', success: 'log-success' };
      if (typeToClass[type]) entry.classList.add(typeToClass[type]);
      if (logConsole) {
        logConsole.appendChild(entry);
        logConsole.scrollTop = logConsole.scrollHeight;
      }
      console[type] ? console[type](message) : console.log(message);
    }

    function logToRealtimeDisplay(message) {
      const timestamp = new Date().toLocaleTimeString();
      realtimeNodeLogDisplay.textContent += `\n[${timestamp}] ${message}`;
      realtimeNodeLogDisplay.scrollTop = realtimeNodeLogDisplay.scrollHeight;
    }

    // --- Central State Handler (The Core of the Refactor) ---
    async function handleSecurityStateChange(securityState) {
      logToUI(`Security State Change: Active=${securityState.isActive}, Volatile=${securityState.hasVolatileIdentity}, HW=${securityState.hasWebAuthnHardwareRegistration}`, 'info');

      // Update status display
      statusRbacActive.textContent = securityState.isActive;
      statusActiveAddress.textContent = securityState.activeAddress || 'N/A';
      statusWebAuthnProtected.textContent = securityState.isWebAuthnProtected;
      statusVolatileIdentity.textContent = securityState.hasVolatileIdentity;
      statusWebAuthnRegistered.textContent = securityState.hasWebAuthnHardwareRegistration;

      const isGdbReady = !!db;
      const isLoggedIn = securityState.isActive;
      const hasVolatile = securityState.hasVolatileIdentity;
      const hasHardware = securityState.hasWebAuthnHardwareRegistration;

      // BEST PRACTICE: Toggle entire views based on login state
      loginView.classList.toggle('hidden', isLoggedIn);
      loggedInView.classList.toggle('hidden', !isLoggedIn);

      // BEST PRACTICE: Control all UI elements based on the state object
      // --- Login View Controls ---
  btnRegisterNewUser.classList.toggle('hidden', !isGdbReady || isLoggedIn || hasVolatile);
  // Keep Login with Mnemonic visible even when a volatile identity exists
  btnLoginMnemonic.classList.toggle('hidden', !isGdbReady || isLoggedIn);
      btnLoginWebAuthn.classList.toggle('hidden', !isGdbReady || isLoggedIn || !hasHardware || hasVolatile);

      btnCopyMnemonic.classList.toggle('hidden', !hasVolatile);
      btnProtectWebAuthn.classList.toggle('hidden', !hasVolatile);
      newIdentityInfo.classList.toggle('hidden', !hasVolatile);
      if (hasVolatile && volatileIdentityCache) {
        newEthAddressElem.textContent = volatileIdentityCache.address;
        mnemonicInput.value = volatileIdentityCache.mnemonic;
        
      }

      mnemonicInput.readOnly = hasVolatile;
      if (!isLoggedIn && !hasVolatile) {
        mnemonicInput.value = ''; // Clear on logout or initial state
      }

      // --- Logged In View Controls & Main Action Buttons ---
      const canPerformActions = isGdbReady && isLoggedIn;
      btnShowMnemonic.classList.toggle('hidden', !canPerformActions || !db.sm.getMnemonicForDisplayAfterRegistrationOrRecovery());

  btnSaveSecureNote.disabled = !canPerformActions;
  btnLoadSecureNote.disabled = !canPerformActions;
  assignRoleBtn.disabled = !canPerformActions;
  // A: requires signer
  putLegitP2PBtn.disabled = !isGdbReady || !isLoggedIn;
  // B: unsigned put only when logged OUT
  putFakeSigP2PBtn.disabled = !isGdbReady || isLoggedIn;
  // C: requires signer (receivers will reject by RBAC if not allowed)
  putNoPermissionP2PBtn.disabled = !isGdbReady || !isLoggedIn;

      // Handle reactive role subscription
      if (roleListenerUnsubscribe) {
        roleListenerUnsubscribe();
        roleListenerUnsubscribe = null;
      }
      if (canPerformActions && securityState.activeAddress) {
        const userNodeKey = `user:${securityState.activeAddress}`;
        try {
          const { unsubscribe } = await db.get(userNodeKey, (userNode) => {
            const currentEth = db.sm.getActiveEthAddress();
            const superAdmins = superAdminInput.value.split(',').map(s => s.trim().toLowerCase()).filter(Boolean);

            if (currentEth && superAdmins.includes(currentEth.toLowerCase())) {
              statusCurrentRole.textContent = 'superadmin (from config)';
              return;
            }

            let role = 'guest';
            if (userNode && userNode.value && userNode.value.role) {
              role = userNode.value.role;
            }
            statusCurrentRole.textContent = role;
          });
          roleListenerUnsubscribe = unsubscribe;
        } catch (e) {
          statusCurrentRole.textContent = 'Error subscribing';
          logToUI(`Error setting up role subscription: ${e.message}`, 'error');
        }
      } else {
        statusCurrentRole.textContent = 'N/A';
      }
    }


    // --- Initialization ---
    async function initializeApp() {
      if (db) { logToUI("DB already initialized.", "warn"); return; }
      const dbName = dbNameInput.value.trim();
      if (!dbName) { logToUI("DB Name is required.", "error"); return; }
      const superAdmins = superAdminInput.value.split(',').map(s => s.trim()).filter(Boolean);
      if (superAdmins.length === 0) {
        logToUI("At least one Super Admin ETH Address is mandatory.", "error");
        return;
      }

      initStatus.textContent = "Initializing...";
      logToUI(`Initializing GDB '${dbName}'...`);

      try {
        // REFACTORED: Correct, single initialization call
        db = await gdb(dbName, {
          rtc: true,
          sm: {
            superAdmins: superAdmins,
          }
        });

        logToUI("GDB instance ready.", "success");
        db.sm.setSecurityStateChangeCallback(handleSecurityStateChange);
        await setupAutomaticRealtimeSubscription();

        localStorage.setItem('gdb_testbed_v2_last_db_name', dbName);
        btnInitializeDB.disabled = true;
        dbNameInput.disabled = true;
        superAdminInput.disabled = true;
        initStatus.textContent = `Initialized: ${dbName}`;

      } catch (e) {
        logToUI(`GDB setup error: ${e.message}`, "error");
        initStatus.textContent = "GDB Initialization failed.";
        db = null;
        return;
      }
    }

    async function autoInitialize() {
      const persistedDBName = localStorage.getItem('gdb_testbed_v2_last_db_name');
      if (persistedDBName) {
        dbNameInput.value = persistedDBName;
        logToUI(`Attempting auto-initialization with persisted DB name: ${persistedDBName}`, 'info');
        await initializeApp();
      } else {
        initStatus.textContent = "Ready to initialize.";
        // Set initial UI state for a non-initialized app
        handleSecurityStateChange({
          isActive: false,
          activeAddress: null,
          isWebAuthnProtected: false,
          hasVolatileIdentity: false,
          hasWebAuthnHardwareRegistration: false
        });
      }
    }

    // --- Event Listeners (Refactored to only call APIs) ---
    btnInitializeDB.addEventListener('click', initializeApp);

    btnHardReset.addEventListener('click', () => {
      if (confirm('This will erase all local configuration (DB name) and reload the page. Are you sure?')) {
        logToUI("Performing hard reset...", "warn");
        localStorage.clear();
        // Also clear session storage for good measure
        sessionStorage.clear();
        location.reload();
      }
    });

    btnCopyMnemonic.addEventListener('click', async () => {
      const mnemonicText = mnemonicInput.value;
      if (!mnemonicText) return;
      try {
        await navigator.clipboard.writeText(mnemonicText);
        logToUI("Mnemonic copied to clipboard.", "success");
      } catch (err) {
        logToUI("Failed to copy mnemonic to clipboard.", "error");
      }
    });

    btnRegisterNewUser.addEventListener('click', async () => {
      logToUI("Generating new volatile identity...", "info");
      try {
        const identity = await db.sm.startNewUserRegistration();
        if (identity) {
          volatileIdentityCache = identity;

          mnemonicInput.value = identity.mnemonic          // The state change callback will handle all UI updates.
          logToUI(`New volatile ID created for ${identity.address.substring(0, 10)}... SAVE MNEMONIC!`, "success");
        } else {
          logToUI("Failed to generate identity.", "warn");
        }
      } catch (e) {
        logToUI(`Registration error: ${e.message}`, "error");
      }
    });

    btnProtectWebAuthn.addEventListener('click', async () => {
      if (!volatileIdentityCache) { logToUI("No volatile identity to protect.", "error"); return; }
      logToUI("Protecting with WebAuthn / Passkey...", "info");
      try {
        const address = await db.sm.protectCurrentIdentityWithWebAuthn(volatileIdentityCache.privateKey);
        if (address) {
          logToUI(`Identity protected with Passkey & logged in.`, "success");
          volatileIdentityCache = null;
        } else { logToUI("Passkey protection cancelled or failed.", "warn"); }
      } catch (e) { logToUI(`Passkey protection error: ${e.message}`, "error"); }
    });

    btnLoginWebAuthn.addEventListener('click', async () => {
      logToUI("Attempting Passkey login...", "info");
      try {
        const address = await db.sm.loginCurrentUserWithWebAuthn();
        if (address) logToUI(`Logged in with Passkey.`, "success");
        else logToUI("Passkey login failed or cancelled.", "warn");
      } catch (e) { logToUI(`Passkey login error: ${e.message}`, "error"); }
    });

    btnLoginMnemonic.addEventListener('click', async () => {
      const mnemonic = mnemonicInput.value.trim();
      if (!mnemonic) { logToUI("Mnemonic is required.", "error"); return; }
      logToUI("Attempting mnemonic login...", "info");
      try {
        const identity = await db.sm.loginOrRecoverUserWithMnemonic(mnemonic);
        if (identity) {
          // The state callback will hide the login view.
          logToUI(`Logged in with mnemonic for ${identity.address}`, "success");
        } else logToUI("Mnemonic login failed (invalid phrase?).", "error");
      } catch (e) { logToUI(`Mnemonic login error: ${e.message}`, "error"); }
    });

    btnLogout.addEventListener('click', async () => {
      logToUI("Logging out...", "info");
      if (roleListenerUnsubscribe) roleListenerUnsubscribe();
      if (realtimeTestNodeUnsubscribe) {
        realtimeTestNodeUnsubscribe();
        realtimeTestNodeUnsubscribe = null;
      }
      volatileIdentityCache = null; // Clear any leftover volatile data
      await db.sm.clearSecurity();
      loadedSecureNoteContent.textContent = ''; // Clear decrypted note
      logToUI("Logged out successfully.", "success");
      await setupAutomaticRealtimeSubscription(); // Re-subscribe as anonymous user
    });

    btnShowMnemonic.addEventListener('click', () => {
      const mnemonic = db.sm.getMnemonicForDisplayAfterRegistrationOrRecovery();
      if (mnemonic) {
        if (confirm("WARNING: Displaying secret mnemonic phrase. Continue?")) {
          alert(`Your current session mnemonic is:\n\n${mnemonic}`);
          logToUI("Mnemonic displayed.", "warn");
        }
      } else { logToUI("No fresh mnemonic available to display for this session.", "warn"); }
    });


    // --- Data and RBAC functions (Unchanged, they were already well-structured) ---

    btnSaveSecureNote.addEventListener('click', async () => {
      const content = secureNoteContentInput.value;
      let noteId = secureNoteIdInput.value.trim();
      if (!content) { logToUI("Note content cannot be empty.", "warn"); return; }
      logToUI(`Saving secure note (ID: ${noteId || 'new'})...`, "info");
      try {
        const savedNodeId = await db.sm.put({ note_content: content, savedAt: new Date().toISOString() }, noteId || undefined);
        logToUI(`Secure note saved. Node ID: ${savedNodeId}`, "success");
        if (!noteId) secureNoteIdInput.value = savedNodeId;
        loadSecureNoteIdInput.value = savedNodeId;
      } catch (error) {
        logToUI(`Failed to save secure note: ${error.message}`, "error");
      }
    });

    btnLoadSecureNote.addEventListener('click', async () => {
      const noteIdToLoad = loadSecureNoteIdInput.value.trim();
      if (!noteIdToLoad) { logToUI("Enter Note ID to load.", "warn"); return; }
      logToUI(`Loading secure note ID: ${noteIdToLoad}...`, "info");
      loadedSecureNoteContent.textContent = 'Loading...';
      try {
        const { result: node } = await db.sm.get(noteIdToLoad);
        if (node) {
          if (node.decrypted) {
            logToUI(`Secure note '${noteIdToLoad}' loaded and decrypted.`, "success");
            loadedSecureNoteContent.textContent = JSON.stringify(node.value, null, 2);
          } else {
            logToUI(`Failed to decrypt note '${noteIdToLoad}'. You may not be the owner.`, "error");
            loadedSecureNoteContent.textContent = `DECRYPTION FAILED. Raw (encrypted) value:\n${JSON.stringify(node.value, null, 2)}`;
          }
        } else {
          logToUI(`Secure note ID '${noteIdToLoad}' not found.`, "warn");
          loadedSecureNoteContent.textContent = 'Note not found.';
        }
      } catch (error) {
        logToUI(`Failed to load secure note '${noteIdToLoad}': ${error.message}`, "error");
        loadedSecureNoteContent.textContent = `Error: ${error.message}`;
      }
    });

    assignRoleBtn.addEventListener('click', async () => {
      const target = targetEthForRole.value.trim();
      const role = roleToAssign.value.trim();
      if (!target || !role) { logToUI("Target ETH and Role are required.", "error"); return; }
      logToUI(`Attempting to assign role '${role}'...`, "info");
      try {
        await db.sm.executeWithPermission('assignRole');
        logToUI("Permission 'assignRole' granted. Sending request...", "info");
        await db.sm.assignRole(target, role);
        logToUI("Role assignment request sent to GDB.", "success");
      } catch (e) { logToUI(`Assign role error: ${e.message}`, "error"); }
    });

    async function setupAutomaticRealtimeSubscription() {
      if (realtimeTestNodeUnsubscribe) realtimeTestNodeUnsubscribe();
      if (!db) { return; }
      logToRealtimeDisplay(`Subscribing to P2P test node: ${REALTIME_TEST_NODE_ID}...`);
      try {
        const { unsubscribe } = await db.get(REALTIME_TEST_NODE_ID, (nodeData) => {
          const message = nodeData ? `State update: ${JSON.stringify(nodeData.value)}` : "State update: Node not found or deleted.";
          logToRealtimeDisplay(message);
        });
        realtimeTestNodeUnsubscribe = unsubscribe;
        logToRealtimeDisplay("Subscription is now ACTIVE.");
      } catch (e) { logToRealtimeDisplay(`Subscription error: ${e.message}`); }
    }

    putLegitP2PBtn.addEventListener('click', async () => {
      try {
        let value = JSON.parse(realtimeNodeValueForTest.value);
        value.ts = Date.now();
        realtimeNodeValueForTest.value = JSON.stringify(value);
        logToUI("Sending LEGITIMATE 'put'. Verifying 'write' permission...", "info");
        await db.sm.executeWithPermission('write');
        logToUI("'write' permission granted. Proceeding with db.put().", "info");
        await db.put(value, REALTIME_TEST_NODE_ID);
        logToUI("Legit 'put' sent. Check other browser tabs.", "success");
      } catch (e) {
        logToUI(`Legit P2P error: ${e.message}`, "error");
      }
    });

    putFakeSigP2PBtn.addEventListener('click', async () => {
      try {
        if (db.sm.isSecurityActive()) {
          logToUI("This black-box test is available only when logged out (no signer). Please logout first.", "warn");
          return;
        }

        let value = JSON.parse(realtimeNodeValueForTest.value);
        value.ts = Date.now();
        realtimeNodeValueForTest.value = JSON.stringify(value);

        logToUI("Attempting UNSIGNED 'put' (logged out). Expected: no propagation to other tabs.", "info");
        await db.put(value, REALTIME_TEST_NODE_ID);
        logToUI("Unsigned put completed locally. Check other tabs: they should NOT receive this update (SM signature gate on sender).", "success");
      } catch (e) {
        logToUI(`Fake sig (black-box) error: ${e.message}`, "error");
      }
    });

    putNoPermissionP2PBtn.addEventListener('click', async () => {
      try {
        let value = JSON.parse(realtimeNodeValueForTest.value);
        value.ts = Date.now();
        realtimeNodeValueForTest.value = JSON.stringify(value);
        logToUI("Sending 'put' with VALID signature but (potentially) NO PERMISSION...", "info");
        await db.put(value, REALTIME_TEST_NODE_ID);
        logToUI("'put' sent. The receiving node's RBAC rules will determine if it's accepted.", "success");
      } catch (e) {
        logToUI(`No-permission P2P error (local check failed): ${e.message}`, "error");
      }
    });

    // --- Initial Load ---
    logToUI("Testbed loaded. Ready for initialization.");
    autoInitialize();

  </script>
</body>

</html>