<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Real-Time Cursors with GDB & GenosRTC</title>
  <style>
    body,
    html {
      width: 100%;
      height: 100%;
      margin: 0;
      overflow: hidden;
      background-color: #1e1e1e;
      cursor: none;
      /* Hide system cursor */
    }

    .cursor {
      width: 25px;
      height: 25px;
      border-radius: 50%;
      position: absolute;
      pointer-events: none;
      transform: translate(-50%, -50%);
      transition: transform 0.05s ease-out;
      /* Movimiento súper suave */
      z-index: 1000;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 10px;
      color: white;
      font-family: monospace;
    }
  </style>
</head>

<body>
  <!-- Container for other participants' cursors -->
  <div id="remote-cursors-container"></div>

  <!-- Your own cursor, managed separately -->
  <div class="cursor" id="local-cursor" style="background-color: rgba(255, 255, 255, 0.5);"></div>

  <script type="module">
    // Import GDB library
    import { gdb } from "../dist/index.js";

    // Object to keep track of other participants' cursors
    const remoteCursors = {};

    // --- MAIN ASYNC FUNCTION ---
    // Wrap everything in an async function for initialization
    async function main() {
      try {
        // 1. INITIALIZATION
        // Use async factory for GDB
        const db = await gdb('cursormove', { rtc: true });

        // 2. CHANNEL API
        // Get the channel object, use db.room for the app
        const cursorChannel = db.room.channel("cursor");

        // --- PARTICIPANT AND CURSOR MANAGEMENT ---

        // When a new participant joins
        db.room.on('peer:join', peerId => {
          console.log(`✅ Peer joined: ${peerId.slice(0, 8)}...`);

          // Create a new div for their cursor
          const newCursor = document.createElement('div');
          newCursor.className = 'cursor';
          newCursor.style.backgroundColor = getRandomColor();
          newCursor.textContent = peerId.slice(0, 4); // Show part of their ID
          document.getElementById('remote-cursors-container').appendChild(newCursor);

          // Save reference to this peer's cursor
          remoteCursors[peerId] = newCursor;
        });

        // When a participant leaves
        db.room.on('peer:leave', peerId => {
          console.log(`❌ Peer left: ${peerId.slice(0, 8)}...`);

          // Remove their cursor from DOM and our registry
          if (remoteCursors[peerId]) {
            remoteCursors[peerId].remove();
            delete remoteCursors[peerId];
          }
        });

        // --- APP LOGIC ---

        const localCursor = document.getElementById('local-cursor');

        // Move your own cursor and send position to others
        window.addEventListener('mousemove', e => {
          localCursor.style.left = `${e.clientX}px`;
          localCursor.style.top = `${e.clientY}px`;

          // Use .send() method of channel object
          cursorChannel.send({ x: e.clientX, y: e.clientY });
        });

        // Receive data from channel and move the correct participant's cursor
        cursorChannel.on('message', (data, fromPeerId) => {
          const peerCursor = remoteCursors[fromPeerId];

          // If that peer's cursor exists, update its position
          if (peerCursor) {
            peerCursor.style.left = `${data.x}px`;
            peerCursor.style.top = `${data.y}px`;
          }
        });

      } catch (error) {
        console.error("Fatal error initializing the app:", error);
      }
    }

    // --- HELPER FUNCTIONS ---
    function getRandomColor() {
      const h = Math.floor(Math.random() * 360);
      return `hsla(${h}, 90%, 70%, 0.8)`;
    }

    // Start the app
    main();
  </script>
</body>

</html>