<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Real-Time Cursors with GDB & GenosRTC</title>
  <style>
    body, html {
      width: 100%;
      height: 100%;
      margin: 0;
      overflow: hidden;
      background-color: #1e1e1e;
      cursor: none; /* Ocultamos el cursor del sistema */
    }

    .cursor {
      width: 25px;
      height: 25px;
      border-radius: 50%;
      position: absolute;
      pointer-events: none;
      transform: translate(-50%, -50%);
      transition: transform 0.05s ease-out; /* Movimiento súper suave */
      z-index: 1000;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 10px;
      color: white;
      font-family: monospace;
    }
  </style>
</head>

<body>
  <!-- Contenedor para los cursores de otros participantes -->
  <div id="remote-cursors-container"></div>
  
  <!-- Tu propio cursor, que gestionamos por separado -->
  <div class="cursor" id="local-cursor" style="background-color: rgba(255, 255, 255, 0.5);"></div>

  <script type="module">
    // Importa tu librería GDB
    import { GDB } from "../dist/index.js";

    // Un objeto para llevar un registro de los cursores de los demás
    const remoteCursors = {};

    // --- FUNCIÓN PRINCIPAL ASÍNCRONA ---
    // Envolvemos todo en una función async para manejar la inicialización
    async function main() {
      try {
        // 1. INICIALIZACIÓN
        // GDB realiza operaciones asíncronas, así que lo tratamos como tal.
        const db = new GDB('cursormove');

        console.log("GDB y GenosRTC inicializados. ¡Listo para la acción!");

        // 2. CORRECCIÓN DE LA API `channel`
        // Obtenemos el objeto del canal, no desestructuramos un array.
        // Usamos el `db.room` público para la aplicación.
        const cursorChannel = db.room.channel("cursor");
        
        // --- GESTIÓN DE PARTICIPANTES Y CURSORES ---

        // Cuando un nuevo participante se une
        db.room.on('peer:join', peerId => {
          console.log(`✅ Peer se ha unido: ${peerId.slice(0, 8)}...`);
          
          // Creamos un nuevo div para su cursor
          const newCursor = document.createElement('div');
          newCursor.className = 'cursor';
          newCursor.style.backgroundColor = getRandomColor();
          newCursor.textContent = peerId.slice(0, 4); // Mostramos parte de su ID
          document.getElementById('remote-cursors-container').appendChild(newCursor);
          
          // Guardamos la referencia al cursor de este peer
          remoteCursors[peerId] = newCursor;
        });

        // Cuando un participante se va
        db.room.on('peer:leave', peerId => {
          console.log(`❌ Peer se ha ido: ${peerId.slice(0, 8)}...`);
          
          // Buscamos su cursor, lo eliminamos del DOM y de nuestro registro
          if (remoteCursors[peerId]) {
            remoteCursors[peerId].remove();
            delete remoteCursors[peerId];
          }
        });
        
        // --- LÓGICA DE LA APLICACIÓN ---

        const localCursor = document.getElementById('local-cursor');

        // Mueve tu propio cursor y envía la posición a los demás
        window.addEventListener('mousemove', e => {
          localCursor.style.left = e.clientX + 'px';
          localCursor.style.top = e.clientY + 'px';

          // Usamos el método .send() del objeto del canal
          cursorChannel.send({ x: e.clientX, y: e.clientY });
        });

        // Recibe datos del canal y mueve el cursor del participante CORRECTO
        cursorChannel.on('message', (data, fromPeerId) => {
          const peerCursor = remoteCursors[fromPeerId];
          
          // Si el cursor de ese peer existe, actualiza su posición
          if (peerCursor) {
            peerCursor.style.left = data.x + 'px';
            peerCursor.style.top = data.y + 'px';
          }
        });

      } catch (error) {
        console.error("Error fatal al inicializar la aplicación:", error);
      }
    }

    // --- FUNCIONES AUXILIARES ---
    function getRandomColor() {
      const h = Math.floor(Math.random() * 360);
      return `hsla(${h}, 90%, 70%, 0.8)`;
    }

    // Inicia la aplicación
    main();
  </script>
</body>

</html>