<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GDB con MetaMask RBAC y Seguridad P2P</title>
    <style>
        body { font-family: sans-serif; margin: 20px; background-color: #f4f4f4; color: #333; }
        .container { background-color: #fff; padding: 20px; border-radius: 8px; box-shadow: 0 0 10px rgba(0, 0,0, 0.1); }
        button { padding: 10px 15px; margin: 5px; background-color: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer; }
        button:hover { background-color: #0056b3; }
        button:disabled { background-color: #ccc; cursor: not-allowed; }
        input[type="text"] { padding: 8px; margin: 5px; border: 1px solid #ddd; border-radius: 4px; }
        pre { background-color: #eee; padding: 10px; border-radius: 4px; white-space: pre-wrap; word-wrap: break-word; max-height: 200px; overflow-y: auto; font-size: 0.8em; }
        .section { margin-bottom: 20px; padding-bottom: 10px; border-bottom: 1px solid #eee; }
        h2, h3 { color: #0056b3; }
    </style>
</head>
<body>
    <div class="container">
        <h1>GDB con MetaMask RBAC y Seguridad P2P (Demo)</h1>
        <p>Abre la consola del navegador para ver los logs detallados. Necesitas MetaMask.</p>

        <div class="section">
            <h2>1. Conexión con MetaMask y Configuración de Seguridad</h2>
            <button id="connectMetaMaskBtn">Conectar con MetaMask y Activar Seguridad</button>
            <button id="disconnectBtn" disabled>Desconectar y Desactivar Seguridad</button>
            <p>Estado: <strong id="status">Desconectado. Seguridad P2P Inactiva.</strong></p>
            <p>Tu Dirección Ethereum: <strong id="ethAddressDisplay">N/A</strong></p>
            <p>
                Modo Estricto del SecurityManager (local): <strong id="strictModeStatus">N/A</strong>
                <button id="toggleStrictModeBtn" disabled>Cambiar Modo Estricto</button>
            </p>
        </div>

        <div class="section">
            <h2>2. Operaciones con GDB</h2>
            <h3>Escribir Dato (requiere permiso RBAC 'write' para tu rol en GDB)</h3>
            <label for="dataId">ID del Dato (opcional, ej. `data_item1`):</label>
            <input type="text" id="dataId" placeholder="Ej: nodo1">
            <label for="dataValue">Valor (JSON):</label>
            <input type="text" id="dataValue" value='{"message":"Hola GDB con MetaMask!"}'>
            <button id="putDataBtn" disabled>Guardar Dato (db.put)</button>

            <h3>Leer Dato</h3>
            <label for="getDataId">ID del Dato a Leer:</label>
            <input type="text" id="getDataId" value="nodo1">
            <button id="getDataBtn">Leer Dato (db.get)</button>
            <p>Resultado Get: <pre id="getResult">N/A</pre></p>

            <h3>Asignar Rol (requiere que tu dirección ETH esté en SUPERADMIN_ETHEREUM_ADDRESSES_CONFIG)</h3>
            <label for="targetEthAddress">Dirección ETH Destino:</label>
            <input type="text" id="targetEthAddress" placeholder="0x...">
            <label for="newRole">Nuevo Rol:</label>
            <input type="text" id="newRole" value="manager">
            <button id="assignRoleBtn" disabled>Asignar Rol</button>
        </div>

        <div class="section">
            <h2>3. Simulación de Recepción P2P (desde "otro peer ETH")</h2>
            <p><i>La verificación de firma (Ethereum) es real. Para "ÉXITO", el emisor simulado debe tener una firma válida y, para `assignRole`, su dirección ETH debe estar en `SUPERADMIN_ETHEREUM_ADDRESSES_CONFIG`. Esta simulación actual enviará una firma inválida.</i></p>
            <button id="simulateAssignRoleP2PBtn" disabled>Simular Recepción de `assignRole` (firma inválida)</button>
            <button id="simulatePutP2PBtn" disabled>Simular Recepción de `put` (firma inválida)</button>
        </div>
    </div>

    <script type="module">
        // NO se importa 'ethers' aquí directamente para la lógica de la aplicación.
        // Esa responsabilidad recae en rbac.js y SecurityManager.js.

        import { GraphDB } from "../dist/index.js"; // Ajusta la ruta
        import {
            initializeCompleteSecurity,
            deactivateSecurity, // Asegúrate que rbac.min.js exporta esto
            executeWithPermission,
            assignRole as rbacAssignRole
        } from '../dist/rbac.min.js'; // Ajusta la ruta

        // --- CONFIGURACIÓN DE LA APLICACIÓN: DIRECCIONES ETH DE SUPERADMIN ---
        const SUPERADMIN_ETHEREUM_ADDRESSES_CONFIG = [
            // ¡¡¡REEMPLAZA ESTO CON DIRECCIONES ETH REALES DE TUS SUPERADMINS!!!
            "0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266", // Dirección #0 de Hardhat (ejemplo)
            "0xC9f9b6d99d605880C8dD85DBCbBE94E83af738A5"  // Placeholder, reemplaza o elimina
        ];
        // --------------------------------------------------------------------

        let db;
        let currentRawEthAddress = null; // Almacenará la dirección cruda de MetaMask
        let currentDisplayEthAddress = "N/A"; // Para mostrar en la UI (puede ser cruda o normalizada por rbac.js)
        let appSecurityManagerInstance = null;

        // --- Elementos UI ---
        const connectMetaMaskBtn = document.getElementById('connectMetaMaskBtn');
        const disconnectBtn = document.getElementById('disconnectBtn');
        const statusEl = document.getElementById('status');
        const ethAddressDisplayEl = document.getElementById('ethAddressDisplay');
        const strictModeStatusEl = document.getElementById('strictModeStatus');
        const toggleStrictModeBtn = document.getElementById('toggleStrictModeBtn');
        const putDataBtn = document.getElementById('putDataBtn');
        const dataIdInputEl = document.getElementById('dataId');
        const dataValueInputEl = document.getElementById('dataValue');
        const getDataBtn = document.getElementById('getDataBtn');
        const getDataIdInputEl = document.getElementById('getDataId');
        const getResultEl = document.getElementById('getResult');
        const assignRoleBtn = document.getElementById('assignRoleBtn');
        const targetEthAddressInputEl = document.getElementById('targetEthAddress');
        const newRoleInputEl = document.getElementById('newRole');
        const simulateAssignRoleP2PBtn = document.getElementById('simulateAssignRoleP2PBtn');
        const simulatePutP2PBtn = document.getElementById('simulatePutP2PBtn');

        async function initGDB() {
            const dbName = 'gdbMetaMaskDemo_v2'; // Cambia para DB fresca
            console.log(`APP: Inicializando GDB: ${dbName}`);
            db = new GraphDB(dbName);
            await db.ready;
            console.log("APP: GDB Lista.");
            updateUIState();
        }

        connectMetaMaskBtn.addEventListener('click', async () => {
            if (!window.ethereum) {
                alert("MetaMask no detectado. Por favor, instálalo.");
                return;
            }
            try {
                connectMetaMaskBtn.disabled = true;
                disconnectBtn.disabled = true;
                statusEl.textContent = "Solicitando conexión a MetaMask...";

                const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
                if (!accounts || accounts.length === 0) {
                    alert("No se seleccionó ninguna cuenta en MetaMask o se canceló la conexión.");
                    statusEl.textContent = "Conexión fallida.";
                    updateUIState(); // Restaura estado de botones
                    return;
                }
                
                currentRawEthAddress = accounts[0]; // Guardar la dirección cruda obtenida
                currentDisplayEthAddress = currentRawEthAddress; // Mostrar cruda inicialmente
                ethAddressDisplayEl.textContent = currentDisplayEthAddress;
                statusEl.textContent = `Conectado como: ${currentDisplayEthAddress}. Configurando seguridad...`;

                // Pasamos la dirección CRUDA a initializeCompleteSecurity.
                // rbac.js se encargará de normalizarla internamente.
                // Si initializeCompleteSecurity devuelve la dirección normalizada, podríamos actualizar currentDisplayEthAddress.
                const normalizedAddressReturned = await initializeCompleteSecurity(db, currentRawEthAddress, SUPERADMIN_ETHEREUM_ADDRESSES_CONFIG);
                
                if (normalizedAddressReturned) { // Asumiendo que rbac.js devuelve la dirección normalizada
                    currentDisplayEthAddress = normalizedAddressReturned;
                    ethAddressDisplayEl.textContent = currentDisplayEthAddress; // Actualizar UI con la normalizada
                     // currentRawEthAddress sigue siendo la que MetaMask dio, para pasar a executeWithPermission si es necesario,
                     // pero rbac.js también debería trabajar con la normalizada que tiene internamente (currentActiveEthAddress).
                     // Por consistencia, usaremos la normalizada que nos devuelve rbac.js para futuras llamadas.
                    currentRawEthAddress = normalizedAddressReturned;
                }


                appSecurityManagerInstance = db.securityManager;

                if (appSecurityManagerInstance) {
                    strictModeStatusEl.textContent = appSecurityManagerInstance.isStrictMode() ? "Activado" : "Desactivado";
                }
                console.log("APP: Seguridad completa (MetaMask) inicializada.");
                statusEl.textContent = `Conectado como: ${currentDisplayEthAddress}. Seguridad P2P Activa.`;

            } catch (error) {
                console.error("APP: Error durante conexión a MetaMask o inicialización de seguridad:", error);
                statusEl.textContent = `Error: ${error.message}`;
                currentRawEthAddress = null;
                currentDisplayEthAddress = "N/A";
                ethAddressDisplayEl.textContent = currentDisplayEthAddress;
                if (db && typeof deactivateSecurity === 'function') {
                     await deactivateSecurity();
                } else if (db) {
                    if (db._originalSendDataByRBAC) { // Fallback manual si deactivateSecurity no se importó
                        db.sendData = db._originalSendDataByRBAC;
                        delete db._originalSendDataByRBAC;
                    }
                    db.securityManager = null;
                }
                appSecurityManagerInstance = null;
            }
            updateUIState();
        });

        disconnectBtn.addEventListener('click', async () => {
            console.log("APP: Desconectando...");
            if (db && typeof deactivateSecurity === 'function') {
                await deactivateSecurity();
            } else if (db) { // Fallback manual
                 if (db._originalSendDataByRBAC) {
                    db.sendData = db._originalSendDataByRBAC;
                    delete db._originalSendDataByRBAC;
                }
                db.securityManager = null;
                console.warn("APP: deactivateSecurity no importada o no funcional, realizando desactivación manual parcial.");
            }
            currentRawEthAddress = null;
            currentDisplayEthAddress = "N/A";
            appSecurityManagerInstance = null;
            statusEl.textContent = "Desconectado. Seguridad P2P Inactiva.";
            ethAddressDisplayEl.textContent = currentDisplayEthAddress;
            strictModeStatusEl.textContent = "N/A";
            updateUIState();
        });

        toggleStrictModeBtn.addEventListener('click', () => {
            if (appSecurityManagerInstance) {
                appSecurityManagerInstance.setStrictMode(!appSecurityManagerInstance.isStrictMode());
                strictModeStatusEl.textContent = appSecurityManagerInstance.isStrictMode() ? "Activado" : "Desactivado";
            }
        });

        putDataBtn.addEventListener('click', async () => {
            if (!currentRawEthAddress) { alert("Debes estar conectado con MetaMask."); return; }
            const dataId = dataIdInputEl.value.trim() || undefined;
            let dataValue;
            try { dataValue = JSON.parse(dataValueInputEl.value); } catch (e) { alert("Valor no es JSON válido."); return; }

            try {
                await executeWithPermission(db, currentRawEthAddress, 'write', async (userEthAddr) => {
                    const id = await db.put(dataValue, dataId);
                    alert(`Dato guardado. ID: ${id}. Revisa MetaMask para la solicitud de firma.`);
                });
            } catch (error) { alert(`Error guardando dato: ${error.message}`); }
        });

        getDataBtn.addEventListener('click', async () => {
            const dataId = getDataIdInputEl.value.trim();
            if (!dataId) { alert("Ingresa un ID para leer."); return; }
            const nodeQuery = await db.get(dataId, (nodeData) => {
                getResultEl.textContent = nodeData ? JSON.stringify(nodeData, null, 2) : "Nodo no encontrado (reactivo).";
            });
            getResultEl.textContent = nodeQuery.result ? JSON.stringify(nodeQuery.result, null, 2) : "Nodo no encontrado.";
        });

        assignRoleBtn.addEventListener('click', async () => {
            if (!currentRawEthAddress) { alert("Debes estar conectado con MetaMask."); return; }
            const targetEthAddress = targetEthAddressInputEl.value.trim();
            const newRole = newRoleInputEl.value.trim();
            if (!targetEthAddress || !newRole) { alert("Completa dirección ETH destino y nuevo rol."); return; }
            // La validación de si targetEthAddress es una dirección ETH válida la hará rbac.js o SecurityManager
            
            try {
                await executeWithPermission(db, currentRawEthAddress, 'assignRole', async (userEthAddr) => {
                    await rbacAssignRole(db, targetEthAddress, newRole);
                    alert(`Solicitud para asignar rol '${newRole}' a '${targetEthAddress}' enviada. Revisa MetaMask.`);
                });
            } catch (error) { alert(`Error asignando rol: ${error.message}`); }
        });

        // --- Simulación de Recepción P2P (Simplificada) ---
        async function createP2POperationStructure(originEthAddress, type, id, value) {
            // ESTO CREA LA ESTRUCTURA, PERO LA FIRMA SERÁ INVÁLIDA.
            return {
                type: type,
                id: id,
                value: value,
                timestamp: db.hybridClock.now(),
                originUser: originEthAddress, // SecurityManager espera esto para la canonicalización
                originEthAddress: originEthAddress, // Y también esto para la verificación
                signature: "0xINVALID_SIMULATED_SIGNATURE_" + Date.now() 
            };
        }

        async function handleSimulatedP2P(operation) {
            if (!db) { alert("GDB no inicializado."); return; }
            if (!db.securityManager) {
                db.receiveChanges([operation]); // Procesar sin SM
                alert("Simulación P2P: Operación procesada por GDB sin SecurityManager (solo LWW).");
                return;
            }
            const { validatedOperations, unverifiedOperations } = await db.securityManager.verifyIncomingOperations([operation]);
            if (validatedOperations.length > 0) {
                db.receiveChanges(validatedOperations);
                alert("Simulación P2P: Operación VALIDADA por SecurityManager y procesada.");
            } else if (unverifiedOperations.length > 0) {
                alert("Simulación P2P: Operación NO VERIFICADA por SecurityManager (probablemente por firma inválida).");
                if (!db.securityManager.isStrictMode()) {
                     const opData = {...unverifiedOperations[0]}; // clonar
                     delete opData.signature; delete opData.originEthAddress; delete opData.originUser;
                     db.receiveChanges([opData]); // Modo no estricto
                     console.log("Modo no estricto: aplicando operación no verificada.");
                }
            }
        }

        simulateAssignRoleP2PBtn.addEventListener('click', async () => {
            if (!currentRawEthAddress) { alert("Conéctate primero."); return; }
            const simulatedOrigin = SUPERADMIN_ETHEREUM_ADDRESSES_CONFIG[0] || currentRawEthAddress; // Simular desde un superadmin
            const op = await createP2POperationStructure(
                simulatedOrigin,
                'put',
                `user:0xSIMULATEDTARGETETH${Date.now().toString().slice(-5)}`, // ID de nodo de usuario
                { role: 'admin', ethAddress: `0xSIMULATEDTARGETETH${Date.now().toString().slice(-5)}` } // Contenido del nodo
            );
            await handleSimulatedP2P(op);
        });

        simulatePutP2PBtn.addEventListener('click', async () => {
            if (!currentRawEthAddress) { alert("Conéctate primero."); return; }
            const op = await createP2POperationStructure(
                currentRawEthAddress, // Simular desde el usuario actual
                'put',
                `dataSimulated${Date.now().toString().slice(-5)}`,
                { message: "Dato simulado desde P2P" }
            );
            await handleSimulatedP2P(op);
        });


        function updateUIState() {
            const connected = !!currentRawEthAddress;
            connectMetaMaskBtn.disabled = connected;
            disconnectBtn.disabled = !connected;
            putDataBtn.disabled = !connected;
            assignRoleBtn.disabled = !connected;
            getDataBtn.disabled = !db;
            toggleStrictModeBtn.disabled = !appSecurityManagerInstance;
            simulateAssignRoleP2PBtn.disabled = !connected;
            simulatePutP2PBtn.disabled = !connected;

            ethAddressDisplayEl.textContent = currentDisplayEthAddress;
            statusEl.textContent = connected ? `Conectado como: ${currentDisplayEthAddress}. Seguridad P2P Activa.` : "Desconectado. Seguridad P2P Inactiva.";
            strictModeStatusEl.textContent = appSecurityManagerInstance ? (appSecurityManagerInstance.isStrictMode() ? "Activado" : "Desactivado") : "N/A";
        }
        initGDB();
    </script>
</body>
</html>