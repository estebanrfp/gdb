<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GDB con MetaMask y RBAC</title>
    <script src="https://cdn.ethers.io/lib/ethers-5.6.umd.min.js" type="application/javascript"></script> <!-- Incluir Ethers.js -->
    <style>
        body { font-family: sans-serif; margin: 20px; background-color: #f4f4f4; color: #333; }
        .container { background-color: #fff; padding: 20px; border-radius: 8px; box-shadow: 0 0 10px rgba(0,0,0,0.1); }
        button { padding: 10px 15px; margin: 5px; background-color: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer; }
        button:hover { background-color: #0056b3; }
        button:disabled { background-color: #ccc; cursor: not-allowed; }
        input[type="text"] { padding: 8px; margin: 5px; border: 1px solid #ddd; border-radius: 4px; }
        pre { background-color: #eee; padding: 10px; border-radius: 4px; white-space: pre-wrap; word-wrap: break-word; max-height: 100px; overflow-y: auto; font-size: 0.8em; }
        .section { margin-bottom: 20px; padding-bottom: 10px; border-bottom: 1px solid #eee; }
        h2, h3 { color: #0056b3; }
    </style>
</head>

<body>
    <div class="container">
        <h1>GDB con Seguridad MetaMask y RBAC (Demo)</h1>
        <p>Abre la consola del navegador para ver los logs detallados.</p>

        <div class="section">
            <h2>1. Conexión MetaMask y Configuración de Seguridad</h2>
            <button id="connectMetaMaskBtn">Conectar MetaMask y Activar Seguridad</button>
            <button id="disconnectBtn" disabled>Desconectar y Desactivar Seguridad</button>
            <p>Estado: <strong id="status">No conectado. Seguridad P2P Inactiva.</strong></p>
            <p>Tu Dirección Ethereum: <strong id="ethAddressDisplay">N/A</strong></p>
            <p>
                Modo Estricto del SecurityManager (local): <strong id="strictModeStatus">N/A</strong>
                <button id="toggleStrictModeBtn" disabled>Cambiar Modo Estricto</button>
            </p>
        </div>

        <div class="section">
            <h2>2. Operaciones con GDB</h2>
            <h3>Escribir Dato (acción local RBAC por rol, ej: 'write')</h3>
            <label for="dataId">ID del Dato (opcional, ej: nodoMetaMask):</label>
            <input type="text" id="dataId" placeholder="Ej: dato1">
            <label for="dataValue">Valor (JSON):</label>
            <input type="text" id="dataValue" value='{"message":"Hola GDB con MetaMask!"}'>
            <button id="putDataBtn" disabled>Guardar Dato (db.put)</button>

            <h3>Leer Dato</h3>
            <label for="getDataId">ID del Dato a Leer:</label>
            <input type="text" id="getDataId" value="dato1">
            <button id="getDataBtn">Leer Dato (db.get)</button>
            <p>Resultado Get: <pre id="getResult">N/A</pre></p>

            <h3>Asignar Rol (acción local requiere ser SuperAdmin ETH por config)</h3>
            <label for="targetUserIdentifier">Identificador Usuario Destino (ETH Addr o Handle):</label>
            <input type="text" id="targetUserIdentifier" value="0xOtraDireccionETH">
            <label for="newRole">Nuevo Rol:</label>
            <input type="text" id="newRole" value="manager">
            <button id="assignRoleBtn" disabled>Asignar Rol</button>
        </div>

        <div class="section">
            <h2>3. Simulación de Recepción P2P (desde "otro peer")</h2>
            <p><i>La verificación de firma ETH es real. Para "ÉXITO", el emisor simulado debe tener su dirección ETH en `SUPERADMIN_ETHEREUM_ADDRESSES_CONFIG` para `assignRole`, o el rol adecuado en GDB para otras acciones.</i></p>
            <button id="simulateValidSuperAdminActionBtn" disabled>Simular `assignRole` VÁLIDO por SuperAdmin ETH</button>
            <button id="simulateValidUserWriteBtn" disabled>Simular `put` VÁLIDO por Usuario ETH (rol 'user')</button>
            <button id="simulateBadSigP2PReceiveBtn" disabled>Simular `put` con FIRMA ETH INVÁLIDA</button>
            <button id="simulateNoPermP2PReceiveBtn" disabled>Simular `put` SIN PERMISO RBAC (firma válida, rol GDB inadecuado)</button>
            <button id="simulateNotSuperAdminAssignRoleBtn" disabled>Simular `assignRole` por NO SuperAdmin ETH (firma válida)</button>
        </div>
    </div>

    <script type="module">
        import { GraphDB } from "../dist/index.js"; // Ajusta la ruta
        import { SecurityManager } from '../dist/SecurityManager.min.js'; // Ajusta la ruta
        import {
            initializeMetaMaskSecurity,
            executeWithPermission,
            assignRole as rbacAssignRole,
            // setCustomRoles // Descomenta si necesitas roles personalizados
        } from '../dist/rbac.min.js'; // Ajusta la ruta

        // --- CONFIGURACIÓN DE LA APLICACIÓN: DIRECCIONES ETH DE SUPERADMIN ---
        // ¡¡¡REEMPLAZA ESTO CON LAS DIRECCIONES REALES DE TUS SUPERADMINS!!!
        const SUPERADMIN_ETHEREUM_ADDRESSES_CONFIG = [
            "0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266", // Dirección de Hardhat 0 (ejemplo)
            "0xAddressSuperAdminReal" // Reemplazar o añadir más
        ].map(addr => addr.toLowerCase()); // Normalizar a minúsculas

        if (SUPERADMIN_ETHEREUM_ADDRESSES_CONFIG.length === 0 || SUPERADMIN_ETHEREUM_ADDRESSES_CONFIG[0] === "0xaddresssuperadminreal") {
            console.warn("APP: ADVERTENCIA - No hay direcciones ETH de superadmin configuradas o son de ejemplo. Las operaciones 'assignRole' P2P (y otras de superadmin ETH) podrían fallar la verificación de 'superadmin por configuración ETH'.");
        }
        // --------------------------------------------------------------------

        let db;
        let currentEthAddress = null;
        let appSecurityManager = null; // Instancia del SecurityManager
        let ethersProvider = null;

        // --- Elementos UI ---
        const connectMetaMaskBtn = document.getElementById('connectMetaMaskBtn');
        const disconnectBtn = document.getElementById('disconnectBtn');
        const statusEl = document.getElementById('status');
        const ethAddressDisplayEl = document.getElementById('ethAddressDisplay');
        const strictModeStatusEl = document.getElementById('strictModeStatus');
        const toggleStrictModeBtn = document.getElementById('toggleStrictModeBtn');
        // ... (otros elementos UI como antes)
        const putDataBtn = document.getElementById('putDataBtn');
        const dataIdInputEl = document.getElementById('dataId');
        const dataValueInputEl = document.getElementById('dataValue');
        const getDataBtn = document.getElementById('getDataBtn');
        const getDataIdInputEl = document.getElementById('getDataId');
        const getResultEl = document.getElementById('getResult');
        const assignRoleBtn = document.getElementById('assignRoleBtn');
        const targetUserInputEl = document.getElementById('targetUserIdentifier');
        const newRoleInputEl = document.getElementById('newRole');

        const simulateValidSuperAdminActionBtn = document.getElementById('simulateValidSuperAdminActionBtn');
        const simulateValidUserWriteBtn = document.getElementById('simulateValidUserWriteBtn');
        const simulateBadSigP2PReceiveBtn = document.getElementById('simulateBadSigP2PReceiveBtn');
        const simulateNoPermP2PReceiveBtn = document.getElementById('simulateNoPermP2PReceiveBtn');
        const simulateNotSuperAdminAssignRoleBtn = document.getElementById('simulateNotSuperAdminAssignRoleBtn');


        // --- Inicialización de GDB ---
        async function initGDB() {
            const dbName = 'gdbConMetaMaskDemo1'; // Cambia para DB fresca
            console.log(`APP: Inicializando GDB: ${dbName}`);
            db = new GraphDB(dbName); // SecurityManager se inyectará después
            await db.ready;
            console.log("APP: GDB Lista.");
            if (window.ethereum) {
                ethersProvider = new ethers.providers.Web3Provider(window.ethereum);
            }
            updateUIState();
        }

        // --- Lógica de Conexión MetaMask y Seguridad ---
        connectMetaMaskBtn.addEventListener('click', async () => {
            if (!window.ethereum) {
                alert("MetaMask no está instalado. Por favor, instálalo para continuar.");
                return;
            }
            try {
                connectMetaMaskBtn.disabled = true;
                disconnectBtn.disabled = true;
                statusEl.textContent = "Conectando a MetaMask y configurando seguridad...";

                const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
                if (accounts.length === 0) {
                    alert("No se seleccionó ninguna cuenta en MetaMask.");
                    statusEl.textContent = "Conexión a MetaMask fallida.";
                    updateUIState();
                    return;
                }
                currentEthAddress = accounts[0].toLowerCase();
                ethAddressDisplayEl.textContent = currentEthAddress;
                statusEl.textContent = `Conectado como: ${currentEthAddress}. Configurando seguridad...`;

                // Crear e inyectar SecurityManager
                appSecurityManager = new SecurityManager(
                    currentEthAddress,
                    db,
                    { can: rbac.can, mapChangeTypeToRbacAction: rbac.mapChangeTypeToRbacAction }, // Usar rbac global o importar explícitamente
                    SUPERADMIN_ETHEREUM_ADDRESSES_CONFIG
                );
                // La inicialización de RBAC ahora toma el SM creado por la app
                await initializeMetaMaskSecurity(db, currentEthAddress, SUPERADMIN_ETHEREUM_ADDRESSES_CONFIG, appSecurityManager);

                strictModeStatusEl.textContent = appSecurityManager.isStrictMode() ? "Activado" : "Desactivado";
                console.log("APP: Seguridad con MetaMask inicializada.");
                statusEl.textContent = `Conectado como: ${currentEthAddress}. Seguridad P2P Activa.`;

            } catch (error) {
                console.error("APP: Error durante conexión/inicialización de seguridad con MetaMask:", error);
                statusEl.textContent = `Error: ${error.message}`;
                currentEthAddress = null;
                if (db && appSecurityManager) { // Desactivar seguridad si falló
                    db.securityManager = null;
                }
                appSecurityManager = null;
            }
            updateUIState();
        });

        disconnectBtn.addEventListener('click', async () => {
            console.log("APP: Desconectando...");
            currentEthAddress = null;
            if (db) db.securityManager = null; // Quitar SM de GDB
            appSecurityManager = null;
            statusEl.textContent = "No conectado. Seguridad P2P Inactiva.";
            ethAddressDisplayEl.textContent = "N/A";
            strictModeStatusEl.textContent = "N/A";
            updateUIState();
        });

        toggleStrictModeBtn.addEventListener('click', () => {
            if (appSecurityManager) {
                appSecurityManager.setStrictMode(!appSecurityManager.isStrictMode());
                strictModeStatusEl.textContent = appSecurityManager.isStrictMode() ? "Activado" : "Desactivado";
            }
        });

        // --- Lógica de Operaciones GDB ---
        putDataBtn.addEventListener('click', async () => {
            if (!currentEthAddress) { alert("Debes estar conectado con MetaMask."); return; }
            const dataIdInput = dataIdInputEl.value.trim();
            const dataId = dataIdInput ? dataIdInput : undefined;
            let dataValue;
            try { dataValue = JSON.parse(dataValueInputEl.value); } catch (e) { alert("Valor no es JSON válido."); return; }

            try {
                // Para 'put', la acción RBAC es 'write', verificada contra el rol del currentEthAddress en GDB
                await executeWithPermission(db, currentEthAddress, 'write', async (ethAddr) => {
                    const id = await db.put(dataValue, dataId); // db.put usará el SM para firmar
                    alert(`Dato guardado/actualizado con MetaMask. ID: ${id}`);
                    console.log(`APP: Dato guardado por ${ethAddr}. ID: ${id}`);
                });
            } catch (error) { alert(`Error en db.put: ${error.message}`); console.error("APP: Error en db.put:", error); }
        });

        getDataBtn.addEventListener('click', async () => { /* Sin cambios, no requiere firma */
            const dataId = getDataIdInputEl.value.trim();
            if (!dataId) { alert("Ingresa un ID para leer."); return; }
            try {
                const nodeQuery = await db.get(dataId, (nodeData) => {
                    getResultEl.textContent = nodeData ? JSON.stringify(nodeData, null, 2) : "Nodo no encontrado o eliminado (reactivo).";
                });
                getResultEl.textContent = nodeQuery.result ? JSON.stringify(nodeQuery.result, null, 2) : "Nodo no encontrado.";
            } catch (error) { alert(`Error en db.get: ${error.message}`); console.error("APP: Error en db.get:", error); }
        });

        assignRoleBtn.addEventListener('click', async () => {
            if (!currentEthAddress) { alert("Debes estar conectado con MetaMask."); return; }
            const targetUser = targetUserInputEl.value.trim();
            const newRole = newRoleInputEl.value.trim();
            if (!targetUser || !newRole) { alert("Completa identificador destino y nuevo rol."); return; }

            try {
                // Para 'assignRole', executeWithPermission verifica si currentEthAddress está en SUPERADMIN_ETHEREUM_ADDRESSES_CONFIG
                await executeWithPermission(db, currentEthAddress, 'assignRole', async (ethAddr) => {
                    await rbacAssignRole(db, targetUser, newRole); // rbac.js -> db.put
                    alert(`Solicitud para asignar rol '${newRole}' a '${targetUser}' enviada (firmada con MetaMask).`);
                    console.log(`APP: Solicitud de asignación de rol por ${ethAddr} enviada.`);
                });
            } catch (error) { alert(`Error en assignRole: ${error.message}`); console.error("APP: Error en assignRole:", error); }
        });

        // --- Simulación de Recepción P2P (Adaptar para firmas ETH) ---
        // Esta parte es más compleja de simular AUTÉNTICAMENTE porque necesitarías
        // la firma real de MetaMask de otro 'address' para las pruebas.
        // Por ahora, crearemos la estructura que el SecurityManager esperaría.

        async function createPseudoEthSignedOp(originEthAddress, operationType, dataId, dataValue, isValidSignature = true) {
            const opDataToSign = {
                type: operationType,
                id: dataId,
                value: dataValue,
                timestamp: db.hybridClock.now(),
                // originUser: podría ser un alias o el mismo originEthAddress
            };

            let signature;
            if (isValidSignature && ethersProvider && originEthAddress === currentEthAddress) {
                // Si queremos simular una firma VÁLIDA del usuario actual conectado
                try {
                    const message = JSON.stringify(opDataToSign);
                    const hexMessage = ethers.utils.hexlify(ethers.utils.toUtf8Bytes(message));
                    signature = await window.ethereum.request({
                        method: 'personal_sign',
                        params: [hexMessage, originEthAddress],
                    });
                } catch (e) {
                    console.warn("APP Sim: No se pudo firmar con MetaMask para simulación válida:", e);
                    signature = "0xinvalid_simulated_signature_due_to_signing_error"; // Firma basura
                }
            } else if (isValidSignature) {
                // Simular una firma válida de OTRO address es difícil sin su clave privada.
                // Para la demo, podrías pre-firmar un mensaje conocido y pegarlo aquí.
                // O simplemente enviar una firma "válida" placeholder que tu verifyEthereumSignature
                // no podrá validar contra un originEthAddress diferente al actual.
                signature = "0xplaceholder_valid_looking_signature_for_another_address";
                 // Para que una prueba de SUPERADMIN ETH funcione, este 'originEthAddress' debe estar en la config,
                 // y la firma debe ser realmente de él.
            } else {
                signature = "0xinvalid_simulated_signature_intentional"; // Firma basura
            }

            return {
                ...opDataToSign,
                originEthAddress: originEthAddress,
                signature: signature
            };
        }

        async function simulateIncomingP2PData(operations) {
            // ... (similar a antes, pero llama a db.securityManager.verifyIncomingOperations)
             if (!db) { alert("GDB no inicializado."); return; }
            if (!db.securityManager) { // Debería ser appSecurityManager
                console.warn("APP (Sim P2P): SecurityManager no activo. Procesando sin verificación P2P.");
                const opsSinFirma = operations.map(op => { // Quitar campos de firma ETH
                    const { signature, originEthAddress, ...data } = op;
                    return data;
                });
                db.receiveChanges(opsSinFirma);
                alert("Simulación P2P: Operaciones procesadas por GDB sin SecurityManager.");
                return;
            }
            console.log("APP (Sim P2P): Enviando operaciones simuladas al SM local:", operations);
            try {
                const { validatedOperations, unverifiedOperations } = await db.securityManager.verifyIncomingOperations(operations);
                let message = "Simulación P2P Completada:\n";
                if (validatedOperations && validatedOperations.length > 0) {
                    message += `${validatedOperations.length} operaciones validadas y pasadas a GDB.\n`;
                    db.receiveChanges(validatedOperations);
                } else { message += "0 operaciones validadas.\n"}

                if (unverifiedOperations && unverifiedOperations.length > 0) {
                    message += `${unverifiedOperations.length} operaciones no verificadas/rechazadas.\n`;
                    if (!db.securityManager.isStrictMode()) {
                         // Decidir si las no verificadas se procesan o no
                    }
                } else { message += "0 operaciones no verificadas.\n" }

                alert(message);
            } catch (e) {
                alert("Error en simulación P2P: " + e.message);
                console.error("Error en simulación P2P con SM:", e);
            }
        }

        simulateValidSuperAdminActionBtn.addEventListener('click', async () => {
            if (!currentEthAddress) { alert("Conéctate con MetaMask primero."); return; }
            // Para que esto sea REALMENTE válido, currentEthAddress debe estar en SUPERADMIN_ETHEREUM_ADDRESSES_CONFIG
            // Y la firma generada debe ser verificable.
            const targetUserEth = SUPERADMIN_ETHEREUM_ADDRESSES_CONFIG[1] || "0x0000000000000000000000000000000000000002"; // Un dummy
            const op = await createPseudoEthSignedOp(
                currentEthAddress, // Firmado por el superadmin actual
                'put',
                `user:${targetUserEth.toLowerCase()}`,
                { role: 'admin', assignedByEthAddress: currentEthAddress },
                true // Intentar firma válida
            );
            if (op.signature.startsWith("0xinvalid") || op.signature.startsWith("0xplaceholder")) {
                alert("Simulación: No se pudo generar firma válida con MetaMask para el usuario actual, o es una firma placeholder. La verificación P2P podría fallar si el receptor no puede validar la firma o si el originador no es el mismo.");
            }
            await simulateIncomingP2PData([op]);
        });

        // ... (Adaptar los otros botones de simulación de forma similar)
        // Para simulateBadSigP2PReceiveBtn, pasar isValidSignature = false a createPseudoEthSignedOp.
        // Para simulateNoPermP2PReceiveBtn, necesitarías un usuario con firma válida pero cuyo ROL EN GDB
        // no permita 'write'.
        // Para simulateNotSuperAdminAssignRoleBtn, usar un originEthAddress que NO esté en la config.

        // --- UI State ---
        function updateUIState() {
            const connected = !!currentEthAddress;
            connectMetaMaskBtn.disabled = connected;
            disconnectBtn.disabled = !connected;

            putDataBtn.disabled = !connected;
            assignRoleBtn.disabled = !connected;
            toggleStrictModeBtn.disabled = !appSecurityManager;

            simulateValidSuperAdminActionBtn.disabled = !connected;
            // ... Habilitar/deshabilitar otros botones de simulación
            simulateValidUserWriteBtn.disabled = !connected;
            simulateBadSigP2PReceiveBtn.disabled = !connected;
            simulateNoPermP2PReceiveBtn.disabled = !connected;
            simulateNotSuperAdminAssignRoleBtn.disabled = !connected;


            if (appSecurityManager) {
                strictModeStatusEl.textContent = appSecurityManager.isStrictMode() ? "Activado" : "Desactivado";
            } else {
                strictModeStatusEl.textContent = "N/A";
            }
        }

        // Iniciar la aplicación
        initGDB();
    </script>
</body>
</html>