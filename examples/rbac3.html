<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GDB con MetaMask RBAC y Seguridad P2P</title>
    <style> /* (Estilos iguales a antes) */
        body { font-family: sans-serif; margin: 20px; background-color: #f4f4f4; color: #333; }
        .container { background-color: #fff; padding: 20px; border-radius: 8px; box-shadow: 0 0 10px rgba(0, 0, 0, 0.1); }
        button { padding: 10px 15px; margin: 5px; background-color: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer; }
        button:hover { background-color: #0056b3; }
        button:disabled { background-color: #ccc; cursor: not-allowed; }
        input[type="text"] { padding: 8px; margin: 5px; border: 1px solid #ddd; border-radius: 4px; }
        pre { background-color: #eee; padding: 10px; border-radius: 4px; white-space: pre-wrap; word-wrap: break-word; max-height: 200px; overflow-y: auto; font-size: 0.8em; }
        .section { margin-bottom: 20px; padding-bottom: 10px; border-bottom: 1px solid #eee; }
        h2, h3 { color: #0056b3; }
    </style>
</head>
<body>
    <div class="container">
        <h1>GDB con MetaMask RBAC y Seguridad P2P (Demo)</h1>
        <p>Abre la consola del navegador para ver los logs detallados. Necesitas MetaMask.</p>

        <div class="section">
            <h2>1. Conexión con MetaMask y Configuración de Seguridad</h2>
            <button id="connectMetaMaskBtn">Conectar con MetaMask y Activar Seguridad</button>
            <button id="disconnectBtn" disabled>Desconectar y Desactivar Seguridad</button>
            <p>Estado: <strong id="status">Desconectado. Seguridad P2P Inactiva.</strong></p>
            <p>Tu Dirección Ethereum: <strong id="ethAddressDisplay">N/A</strong></p>
            <p>
                Modo Estricto del SecurityManager (local): <strong id="strictModeStatus">N/A</strong>
                <button id="toggleStrictModeBtn" disabled>Cambiar Modo Estricto</button>
            </p>
        </div>

        <div class="section">
            <h2>2. Operaciones con GDB</h2>
            <h3>Escribir Dato (requiere permiso RBAC 'write' para tu rol en GDB)</h3>
            <label for="dataId">ID del Dato (opcional, ej. `data:<eth_addr>_item1`):</label>
            <input type="text" id="dataId" placeholder="Ej: nodo1">
            <label for="dataValue">Valor (JSON):</label>
            <input type="text" id="dataValue" value='{"message":"Hola GDB con MetaMask!"}'>
            <button id="putDataBtn" disabled>Guardar Dato (db.put)</button>

            <h3>Leer Dato</h3>
            <label for="getDataId">ID del Dato a Leer:</label>
            <input type="text" id="getDataId" value="nodo1">
            <button id="getDataBtn">Leer Dato (db.get)</button>
            <p>Resultado Get: <pre id="getResult">N/A</pre></p>

            <h3>Asignar Rol (requiere que tu dirección ETH esté en SUPERADMIN_ETHEREUM_ADDRESSES_CONFIG)</h3>
            <label for="targetEthAddress">Dirección ETH Destino:</label>
            <input type="text" id="targetEthAddress" placeholder="0x...">
            <label for="newRole">Nuevo Rol:</label>
            <input type="text" id="newRole" value="manager">
            <button id="assignRoleBtn" disabled>Asignar Rol</button>
        </div>

        <div class="section">
            <h2>3. Simulación de Recepción P2P (desde "otro peer ETH")</h2>
            <p><i>La verificación de firma (Ethereum) es real. Para "ÉXITO", el emisor simulado debe tener una firma válida y, para `assignRole`, su dirección ETH debe estar en `SUPERADMIN_ETHEREUM_ADDRESSES_CONFIG`.</i></p>
            <button id="simulateValidSuperAdminAssignRoleBtn" disabled>Simular `assignRole` VÁLIDO por SuperAdmin ETH</button>
            <button id="simulateValidUserWriteBtn" disabled>Simular `put` VÁLIDO por Usuario ETH</button>
            <button id="simulateBadEthSigP2PReceiveBtn" disabled>Simular `put` con FIRMA ETH INVÁLIDA</button>
            <button id="simulateNoPermP2PReceiveBtn" disabled>Simular `put` SIN PERMISO RBAC (firma ETH válida, rol en GDB no permite)</button>
            <button id="simulateNotSuperAdminEthAssignRoleBtn" disabled>Simular `assignRole` por NO SuperAdmin ETH (firma válida)</button>
        </div>
    </div>

    <script type="module">
        // Asegúrate de que ethers está disponible. Si usas un CDN, ya estaría global o importable.
        // Si es un proyecto npm, `import { ethers } from "ethers";` ya está en los módulos JS.
        // Para esta demo HTML, si SecurityManager y rbac importan ethers desde un path, está bien.
        // Si no, y necesitas ethers aquí, impórtalo:
        // import { ethers } from "https://cdn.ethers.io/lib/ethers-5.7.esm.min.js";

        import { GraphDB } from "../dist/index.js"; // Ajusta la ruta a tu GDB compilado
        import {
            initializeCompleteSecurity,
            deactivateSecurity,
            executeWithPermission,
            assignRole as rbacAssignRole,
            // setCustomRoles // Descomenta si necesitas roles personalizados
        } from '../dist/rbac.min.js'; // Ajusta la ruta a tu RBAC compilado

        // --- CONFIGURACIÓN DE LA APLICACIÓN: DIRECCIONES ETH DE SUPERADMIN ---
        const SUPERADMIN_ETHEREUM_ADDRESSES_CONFIG = [
            // ¡¡¡REEMPLAZA ESTO CON DIRECCIONES ETH REALES DE TUS SUPERADMINS!!!
            // Ejemplo: "0x70997970C51812dc3A010C7d01b50e0d17dc79C8" (dirección de Hardhat #0)
            "0x________________________________________", // Reemplaza con una dirección real
            "0x________________________________________"  // Reemplaza con otra si tienes más
        ];
        if (SUPERADMIN_ETHEREUM_ADDRESSES_CONFIG.find(a => a.startsWith("0x_"))) {
            console.warn("APP: ADVERTENCIA - Una o más direcciones de superadmin son placeholders. Las operaciones 'assignRole' P2P (y otras de superadmin) fallarán la verificación de 'superadmin por configuración' si la dirección del remitente no es una real de esta lista.");
        }
        // --------------------------------------------------------------------

        let db;
        let currentConnectedEthAddress = null;
        let appSecurityManagerInstance = null;

        const connectMetaMaskBtn = document.getElementById('connectMetaMaskBtn');
        const disconnectBtn = document.getElementById('disconnectBtn');
        const statusEl = document.getElementById('status');
        const ethAddressDisplayEl = document.getElementById('ethAddressDisplay');
        const strictModeStatusEl = document.getElementById('strictModeStatus');
        const toggleStrictModeBtn = document.getElementById('toggleStrictModeBtn');
        // ... (otros elementos UI como antes)
        const putDataBtn = document.getElementById('putDataBtn');
        const dataIdInputEl = document.getElementById('dataId');
        const dataValueInputEl = document.getElementById('dataValue');
        const getDataBtn = document.getElementById('getDataBtn');
        const getDataIdInputEl = document.getElementById('getDataId');
        const getResultEl = document.getElementById('getResult');
        const assignRoleBtn = document.getElementById('assignRoleBtn');
        const targetEthAddressInputEl = document.getElementById('targetEthAddress'); // Cambiado
        const newRoleInputEl = document.getElementById('newRole');

        const simulateValidSuperAdminAssignRoleBtn = document.getElementById('simulateValidSuperAdminAssignRoleBtn');
        const simulateValidUserWriteBtn = document.getElementById('simulateValidUserWriteBtn');
        const simulateBadEthSigP2PReceiveBtn = document.getElementById('simulateBadEthSigP2PReceiveBtn');
        const simulateNoPermP2PReceiveBtn = document.getElementById('simulateNoPermP2PReceiveBtn');
        const simulateNotSuperAdminEthAssignRoleBtn = document.getElementById('simulateNotSuperAdminEthAssignRoleBtn');


        async function initGDB() {
            const dbName = 'miAppGDB_MetaMask_Demo1'; // Cambia para DB fresca
            console.log(`APP: Inicializando GDB: ${dbName}`);
            db = new GraphDB(dbName);
            await db.ready;
            console.log("APP: GDB Lista.");
            updateUIState();
        }

        connectMetaMaskBtn.addEventListener('click', async () => {
            if (!window.ethereum) {
                alert("MetaMask no detectado. Por favor, instálalo.");
                return;
            }
            try {
                connectMetaMaskBtn.disabled = true;
                disconnectBtn.disabled = true;
                statusEl.textContent = "Solicitando conexión a MetaMask...";

                const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
                if (accounts.length === 0) {
                    alert("No se seleccionó ninguna cuenta en MetaMask.");
                    statusEl.textContent = "Conexión fallida.";
                    updateUIState();
                    return;
                }
                currentConnectedEthAddress = ethers.utils.getAddress(accounts[0]); // Normalizar y usar la primera cuenta
                ethAddressDisplayEl.textContent = currentConnectedEthAddress;
                statusEl.textContent = `Conectado como: ${currentConnectedEthAddress}. Configurando seguridad...`;

                await initializeCompleteSecurity(db, currentConnectedEthAddress, SUPERADMIN_ETHEREUM_ADDRESSES_CONFIG);
                appSecurityManagerInstance = db.securityManager; // SecurityManager inyectado por rbac.js

                if (appSecurityManagerInstance) {
                    strictModeStatusEl.textContent = appSecurityManagerInstance.isStrictMode() ? "Activado" : "Desactivado";
                }
                console.log("APP: Seguridad completa (MetaMask) inicializada.");
                statusEl.textContent = `Conectado como: ${currentConnectedEthAddress}. Seguridad P2P Activa.`;

            } catch (error) {
                console.error("APP: Error durante conexión a MetaMask o inicialización de seguridad:", error);
                statusEl.textContent = `Error: ${error.message}`;
                currentConnectedEthAddress = null;
                if (db) await deactivateSecurity(); // Desactivar seguridad
                appSecurityManagerInstance = null;
            }
            updateUIState();
        });

        disconnectBtn.addEventListener('click', async () => {
            console.log("APP: Desconectando...");
            currentConnectedEthAddress = null;
            if (db) await deactivateSecurity(); // Llama a la función de rbac.js
            appSecurityManagerInstance = null;
            statusEl.textContent = "Desconectado. Seguridad P2P Inactiva.";
            ethAddressDisplayEl.textContent = "N/A";
            strictModeStatusEl.textContent = "N/A";
            updateUIState();
        });

        toggleStrictModeBtn.addEventListener('click', () => {
            if (appSecurityManagerInstance) {
                const currentMode = appSecurityManagerInstance.isStrictMode();
                appSecurityManagerInstance.setStrictMode(!currentMode);
                strictModeStatusEl.textContent = appSecurityManagerInstance.isStrictMode() ? "Activado" : "Desactivado";
                alert(`Modo estricto del SecurityManager cambiado a: ${appSecurityManagerInstance.isStrictMode()}`);
            }
        });

        putDataBtn.addEventListener('click', async () => {
            if (!currentConnectedEthAddress) { alert("Debes estar conectado con MetaMask."); return; }
            const dataIdInput = dataIdInputEl.value.trim();
            const dataId = dataIdInput ? dataIdInput : undefined;
            let dataValue;
            try { dataValue = JSON.parse(dataValueInputEl.value); } catch (e) { alert("Valor no es JSON válido."); return; }

            try {
                // executeWithPermission ahora usa la dirección ETH
                await executeWithPermission(db, currentConnectedEthAddress, 'write', async (userEthAddr) => {
                    const id = await db.put(dataValue, dataId); // db.put será firmado por MetaMask vía SecurityManager
                    alert(`Dato guardado/actualizado. ID: ${id}`);
                    console.log(`APP: Dato guardado por ${userEthAddr}. ID: ${id}. Operación enviada para firma.`);
                });
            } catch (error) { alert(`Error en db.put: ${error.message}`); console.error("APP: Error en db.put:", error); }
        });

        getDataBtn.addEventListener('click', async () => {
            // (Sin cambios, la lectura no suele requerir firma)
            const dataId = getDataIdInputEl.value.trim();
            if (!dataId) { alert("Ingresa un ID para leer."); return; }
            try {
                const nodeQuery = await db.get(dataId, (nodeData) => {
                    console.log("APP: Actualización reactiva para db.get:", nodeData);
                    getResultEl.textContent = nodeData ? JSON.stringify(nodeData, null, 2) : "Nodo no encontrado o eliminado (reactivo).";
                });
                getResultEl.textContent = nodeQuery.result ? JSON.stringify(nodeQuery.result, null, 2) : "Nodo no encontrado.";
            } catch (error) { alert(`Error en db.get: ${error.message}`); console.error("APP: Error en db.get:", error); }
        });

        assignRoleBtn.addEventListener('click', async () => {
            if (!currentConnectedEthAddress) { alert("Debes estar conectado con MetaMask."); return; }
            const targetEthAddress = targetEthAddressInputEl.value.trim();
            const newRole = newRoleInputEl.value.trim();
            if (!targetEthAddress || !newRole) { alert("Completa dirección ETH destino y nuevo rol."); return; }
            if (!ethers.utils.isAddress(targetEthAddress)) { alert("Dirección ETH destino no es válida."); return;}

            try {
                await executeWithPermission(db, currentConnectedEthAddress, 'assignRole', async (userEthAddr) => {
                    await rbacAssignRole(db, targetEthAddress, newRole);
                    alert(`Solicitud para asignar rol '${newRole}' a '${targetEthAddress}' enviada para firma y propagación.`);
                    console.log(`APP: Solicitud de asignación de rol por ${userEthAddr} a ${targetEthAddress} enviada.`);
                });
            } catch (error) { alert(`Error en assignRole: ${error.message}`); console.error("APP: Error en assignRole:", error); }
        });


        // --- Simulación de Recepción P2P ---
        // Esta sección necesita una adaptación mayor porque simular una firma de MetaMask es más complejo.
        // Para una prueba real, necesitarías otro navegador/instancia con MetaMask para enviar.
        // Por ahora, podemos simular la ESTRUCTURA del objeto firmado.
        // Para que SecurityManager.verifyIncomingOperations lo procese, necesitaría una firma ETH válida.
        // Generar una firma ETH válida aquí sin MetaMask es complejo.
        // Alternativa: Podríamos tener un input para pegar una operación firmada desde otro lado.
        // O, para la demo, nos enfocamos en las operaciones locales y confiamos en que la verificación P2P del SM funciona.

        async function createOperationForP2PSimulation(originEthAddress, type, id, value) {
            // ESTO NO INCLUIRÁ UNA FIRMA VÁLIDA. ES SOLO LA ESTRUCTURA.
            // EL SecurityManager RECEPTOR RECHAZARÁ ESTO POR FIRMA INVÁLIDA.
            // Para una prueba real de SM, la operación debe venir firmada por MetaMask desde otro peer/instancia.
            const opData = { // Esto es lo que se firmaría
                type: type,
                id: id,
                value: value,
                timestamp: db.hybridClock.now(),
                originUser: originEthAddress // El SM lo usa para construir el mensaje a verificar
            };
            return { // Esto es lo que se enviaría por la red
                ...opData, // type, id, value, timestamp, originUser
                originEthAddress: originEthAddress, // Redundante pero el SM lo espera
                signature: "0xSIMULATED_BAD_SIGNATURE" + Date.now() // Firma inválida
            };
        }

        simulateValidSuperAdminAssignRoleBtn.addEventListener('click', async () => {
            alert("Simulación P2P con MetaMask: Esta demo no puede generar firmas ETH válidas sin una instancia real de MetaMask emisora. Esta simulación enviará una operación con estructura correcta pero firma inválida. Para probar la lógica de superadmin, la firma debe ser válida y la dirección ETH del remitente estar en la config.");
            if (!currentConnectedEthAddress) { alert("Conéctate primero."); return; }
             // Asumimos que currentConnectedEthAddress ES un superadmin por config para esta simulación de INTENTO
            const op = await createOperationForP2PSimulation(
                currentConnectedEthAddress, // El superadmin simulado
                'put',
                `user:0xTARGETUSERETHADDRESSSIMULATED${Date.now()}`,
                { role: 'admin', ethAddress: `0xTARGETUSERETHADDRESSSIMULATED${Date.now()}` }
            );
            await simulateIncomingP2PData([op]);
        });
        // ... otras simulaciones también necesitarían adaptación o se marcarían como no funcionales sin un emisor real.

        async function simulateIncomingP2PData(operations) {
            // (La lógica de simulateIncomingP2PData es similar a antes,
            // llama a db.securityManager.verifyIncomingOperations si existe)
             if (!db) { alert("GDB no inicializado."); return; }
            if (!db.securityManager) {
                console.warn("APP (Sim P2P): SecurityManager no activo en este peer. Procesando sin verificación P2P.");
                const opsSinFirmaInfo = operations.map(op => { // Quitar info de firma ETH
                    const { signature, originEthAddress, ...data } = op;
                    return data;
                });
                db.receiveChanges(opsSinFirmaInfo);
                alert("Simulación P2P: Operaciones procesadas por GDB sin SecurityManager (solo LWW).");
                return;
            }
            console.log("APP (Sim P2P): Enviando operaciones simuladas al SecurityManager local para verificación:", operations);
            try {
                const { validatedOperations, unverifiedOperations } = await db.securityManager.verifyIncomingOperations(operations);
                let message = "Simulación P2P (MetaMask) Completada:\n";
                if (validatedOperations && validatedOperations.length > 0) {
                    message += `${validatedOperations.length} operaciones validadas y pasadas a GDB.\n`;
                    db.receiveChanges(validatedOperations);
                }
                if (unverifiedOperations && unverifiedOperations.length > 0) {
                    message += `${unverifiedOperations.length} operaciones no verificadas (probablemente por firma inválida en esta simulación).\n`;
                    if (!db.securityManager.isStrictMode()) {
                        message += "Modo no estricto: Pasando no verificadas a GDB.\n";
                        db.receiveChanges(unverifiedOperations.map(op => { const { signature, originEthAddress, ...data } = op; return data; }));
                    } else {
                        message += "Modo estricto: Descartando no verificadas.\n";
                    }
                }
                // ... (resto del mensaje)
                alert(message);
                console.log("APP (Sim P2P): " + message.replace(/\n/g, ' '));
            } catch (e) { /* ... */ }
        }
        // ... (botones de simulación adaptados o con advertencias)
        simulateValidUserWriteBtn.onclick = () => alert("Simulación P2P de escritura válida necesitaría firma ETH real.");
        simulateBadEthSigP2PReceiveBtn.onclick = async () => {
            if(!currentConnectedEthAddress) {alert("Conéctate primero"); return;}
            const op = await createOperationForP2PSimulation(currentConnectedEthAddress, 'put', 'testNodeBadSig', {data: 'test'});
            await simulateIncomingP2PData([op]);
        };
        simulateNoPermP2PReceiveBtn.onclick = () => alert("Simulación P2P sin permiso RBAC necesitaría firma ETH real y un rol GDB que no permita la acción.");
        simulateNotSuperAdminEthAssignRoleBtn.onclick = () => alert("Simulación P2P de assignRole por no superadmin necesitaría firma ETH real de un no superadmin.");


        function updateUIState() {
            const connected = !!currentConnectedEthAddress;
            connectMetaMaskBtn.disabled = connected;
            disconnectBtn.disabled = !connected;
            // userHandleInputEl.disabled = connected; // Ya no hay userHandle input

            putDataBtn.disabled = !connected;
            assignRoleBtn.disabled = !connected;
            getDataBtn.disabled = !db; // Habilitado si GDB está listo

            toggleStrictModeBtn.disabled = !appSecurityManagerInstance;
            // Deshabilitar botones de simulación P2P que requieren firmas reales por ahora
            simulateValidSuperAdminAssignRoleBtn.disabled = !connected; // Se puede intentar, pero fallará por firma
            simulateValidUserWriteBtn.disabled = true; // O adaptar como el de arriba
            simulateBadEthSigP2PReceiveBtn.disabled = !connected;
            simulateNoPermP2PReceiveBtn.disabled = true;
            simulateNotSuperAdminEthAssignRoleBtn.disabled = true;

            if (appSecurityManagerInstance) {
                strictModeStatusEl.textContent = appSecurityManagerInstance.isStrictMode() ? "Activado" : "Desactivado";
            } else {
                strictModeStatusEl.textContent = "N/A";
            }
        }
        initGDB();
    </script>
</body>
</html>