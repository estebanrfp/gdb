<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>GDB RBAC + Security Testbed (v2 Final - Corrected)</title>
  <style>
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      margin: 0;
      padding: 20px;
      background-color: #f4f7f9;
      color: #333;
      font-size: 14px;
    }

    .container {
      max-width: 900px;
      margin: auto;
      background-color: #fff;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
    }

    h1,
    h2,
    h3 {
      color: #2c3e50;
      border-bottom: 1px solid #eee;
      padding-bottom: 5px;
    }

    .section {
      margin-bottom: 25px;
      padding-bottom: 15px;
      border-bottom: 1px dashed #ddd;
    }

    .section:last-child {
      border-bottom: none;
      padding-bottom: 0;
    }

    button {
      background-color: #3498db;
      color: white;
      border: none;
      padding: 8px 12px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
      margin: 5px 2px;
      transition: background-color 0.2s;
    }

    button:hover {
      background-color: #2980b9;
    }

    button:disabled {
      background-color: #bdc3c7;
      cursor: not-allowed;
    }

    input[type="text"],
    input[type="password"],
    textarea {
      width: 100%;
      padding: 8px;
      margin-bottom: 10px;
      border: 1px solid #ccc;
      border-radius: 4px;
      font-size: 14px;
      box-sizing: border-box;
    }

    textarea {
      min-height: 60px;
      resize: vertical;
    }

    .info-box {
      background-color: #e9f7ef;
      border: 1px solid #a7d7c5;
      padding: 10px;
      border-radius: 4px;
      margin-bottom: 10px;
      font-family: monospace;
      word-break: break-all;
    }

    pre {
      background-color: #f0f0f0;
      padding: 10px;
      font-size: 0.9em;
      } catch (e) {
        logToUI('No-permission P2P error (local check failed): ' + e.message, 'error');
      overflow-y: auto;
      border-radius: 4px;
      border: 1px solid #ddd;
      white-space: pre-wrap;
      word-break: break-all;
    }

    .log-console {
      background-color: #2c3e50;
      color: #ecf0f1;
      padding: 15px;
      border-radius: 4px;
      height: 250px;
      overflow-y: auto;
      font-family: 'Consolas', 'Courier New', monospace;
      font-size: 12px;
      white-space: pre-wrap;
    }

    .log-console .log-error {
      color: #e74c3c;
    }

    .log-console .log-warn {
      color: #f39c12;
    }

    .log-console .log-info {
      color: #3498db;
    }

    .log-console .log-success {
      color: #2ecc71;
    }

    .flex-group {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: flex-end;
    }

    .flex-group>div {
      flex-grow: 1;
      min-width: 200px;
    }

    .hidden {
      display: none;
    }
  </style>
</head>

<body>
  <div class="container">
    <h1>GDB RBAC + Security Testbed (v2 Final - Corrected)</h1>
    <p>A comprehensive testbed for GDB identity, RBAC, encryption, and P2P security, refactored with a maintainable,
      state-driven architecture.</p>
    <p><strong>Important:</strong> All actions are logged to the integrated console at the bottom.</p>

    <!-- DB Initialization -->
    <div class="section">
      <h2>1. Database Initialization</h2>
      <div class="flex-group">
        <div>
          <label for="dbNameInput">DB Name (changing this creates a new P2P network):</label>
          <input type="text" id="dbNameInput" value="gdb-robust-test-network">
        </div>
        <div>
          <label for="superAdminInput">Super Admin ETH Address (comma-separated):</label>
          <input type="text" id="superAdminInput" value="0xE5639DfE345F8ab845bEBE63a1C7322F9c6fF5c7"
            placeholder="0xYourAddress1,...">
        </div>
      </div>
      <button id="btnInitializeDB">Initialize DB & RBAC</button>
      <span id="initStatus" style="margin-left: 10px; font-style: italic;"></span>
    </div>

    <!-- Identity & Status -->
    <div class="section">
      <h2>2. Identity Management & Status</h2>
      <div class="flex-group">
        <div style="flex-basis: 100%;">
          <button id="btnRegisterNewUser">A. New Volatile ID (Mnemonic)</button>
          <button id="btnProtectWebAuthn" disabled>B. Protect Volatile ID with WebAuthn & Login</button>
        </div>
        <div id="newIdentityInfo" class="info-box hidden" style="flex-basis: 100%;">
          <p><strong>New ETH Address:</strong> <code id="newEthAddress"></code></p>
          <p><strong>Mnemonic (SAVE THIS!):</strong>
          <pre id="newMnemonic"></pre>
          </p>
        </div>
      </div>
      <hr>
      <div class="flex-group">
        <div>
          <label for="mnemonicLoginInput">Login / Recover with Mnemonic:</label>
          <textarea id="mnemonicLoginInput" rows="2" placeholder="Enter 12-word phrase..."></textarea>
        </div>
        <button id="btnLoginMnemonic">D. Login with Mnemonic</button>
        <button id="btnLoginWebAuthn" disabled>C. Login with WebAuthn</button>
      </div>
      <hr>
      <button id="btnLogout" disabled>E. Logout Current User</button>
      <button id="btnShowMnemonic" disabled>Show Current Session Mnemonic</button>
      <div id="securityStatusBox" class="info-box" style="margin-top: 20px;">
        <p><strong>RBAC Active:</strong> <span id="statusRbacActive">false</span></p>
        <p><strong>Active ETH Address:</strong> <span id="statusActiveAddress">N/A</span></p>
        <p><strong>Current Role (Reactive):</strong> <span id="statusCurrentRole">N/A</span></p>
        <p><strong>Session WebAuthn Protected:</strong> <span id="statusWebAuthnProtected">false</span></p>
        <p><strong>WebAuthn Hardware Registered:</strong> <span id="statusWebAuthnRegistered">false</span></p>
        <p><strong>Volatile Identity in Memory:</strong> <span id="statusVolatileIdentity">false</span></p>
      </div>
    </div>

    <!-- Secure Data Storage (Implicit Encryption) - SECTION REPLACED FROM AUDIT.HTML -->
    <div class="section">
      <h2>3. Secure Data Storage (Implicit Encryption)</h2>
      <p>Uses <code>rbac.put()</code> for automatic encryption and <code>rbac.get()</code> for automatic
        decryption.</p>
      <div class="flex-group">
        <div>
          <label for="secureNoteIdInput">Note ID (leave blank to generate new):</label>
          <input type="text" id="secureNoteIdInput" placeholder="e.g., mySecretNote123">
        </div>
        <div>
          <label for="secureNoteContentInput">Note Content:</label>
          <textarea id="secureNoteContentInput" rows="2">This is a super secret note!</textarea>
        </div>
        <button id="btnSaveSecureNote" disabled>Save Secure Note (rbac.put)</button>
      </div>
      <hr>
      <div class="flex-group">
        <div>
          <label for="loadSecureNoteIdInput">Note ID to Load:</label>
          <input type="text" id="loadSecureNoteIdInput" placeholder="Enter ID of saved note">
        </div>
        <button id="btnLoadSecureNote" disabled>Load & Decrypt Note (rbac.get)</button>
      </div>
      <div class="info-box">
        <strong>Loaded Note Content:</strong>
        <pre id="loadedSecureNoteContent" style="white-space: pre-wrap;"></pre>
      </div>
    </div>

    <!-- RBAC & P2P Tests -->
    <div class="section">
      <h2>4. RBAC & P2P Security Tests</h2>
      <div class="flex-group">
        <div>
          <label for="targetEthForRole">Target ETH Address for Role:</label>
          <input type="text" id="targetEthForRole" placeholder="0xTargetAddress">
        </div>
        <div>
          <label for="roleToAssign">Role (e.g., manager):</label>
          <input type="text" id="roleToAssign" value="manager">
        </div>
        <button id="assignRoleBtn" disabled>Assign Role (needs 'assignRole' perm)</button>
      </div>
      <hr>
      <h3>Real-time P2P Security</h3>
      <p><strong>Test Node:</strong> <code>realtime_security_test_node</code>. Changes to this node from any peer will
        appear in the log below if the signature and permissions are valid.</p>
      <div class="flex-group">
        <div>
          <label for="realtimeNodeValueForTest">Value to Write to Test Node:</label>
          <input type="text" id="realtimeNodeValueForTest" value='{"live_test": true, "ts": 0}'>
        </div>
        <div>
          <button id="putLegitP2PBtn" disabled>A. Send LEGITIMATE 'put'</button>
          <button id="putFakeSigP2PBtn" disabled>B. Send 'put' with FAKE SIGNATURE</button>
          <button id="putNoPermissionP2PBtn" disabled>C. Send 'put' WITHOUT PERMISSION</button>
        </div>
      </div>
      <p>Real-time Subscription Log:</p>
      <pre id="realtimeNodeLogDisplay">Waiting for GDB initialization...</pre>
    </div>

    <!-- Console Log -->
    <div class="section">
      <h2>Testbed Console</h2>
      <div id="logConsole" class="log-console"></div>
    </div>
  </div>

  <script type="module">
    // Import libraries (adjust paths if necessary)
  import { gdb } from "../dist/index.js";

    // --- DOM Element Selectors ---
    const dbNameInput = document.getElementById('dbNameInput');
    const superAdminInput = document.getElementById('superAdminInput');
    const btnInitializeDB = document.getElementById('btnInitializeDB');
    const initStatus = document.getElementById('initStatus');

    const btnRegisterNewUser = document.getElementById('btnRegisterNewUser');
    const newIdentityInfo = document.getElementById('newIdentityInfo');
    const newEthAddressElem = document.getElementById('newEthAddress');
    const newMnemonicElem = document.getElementById('newMnemonic');
    const btnProtectWebAuthn = document.getElementById('btnProtectWebAuthn');
    const btnLoginWebAuthn = document.getElementById('btnLoginWebAuthn');
    const mnemonicLoginInput = document.getElementById('mnemonicLoginInput');
    const btnLoginMnemonic = document.getElementById('btnLoginMnemonic');
    const btnLogout = document.getElementById('btnLogout');
    const btnShowMnemonic = document.getElementById('btnShowMnemonic');

    const statusRbacActive = document.getElementById('statusRbacActive');
    const statusActiveAddress = document.getElementById('statusActiveAddress');
    const statusCurrentRole = document.getElementById('statusCurrentRole');
    const statusWebAuthnProtected = document.getElementById('statusWebAuthnProtected');
    const statusVolatileIdentity = document.getElementById('statusVolatileIdentity');
    const statusWebAuthnRegistered = document.getElementById('statusWebAuthnRegistered');

    const secureNoteIdInput = document.getElementById('secureNoteIdInput');
    const secureNoteContentInput = document.getElementById('secureNoteContentInput');
    const btnSaveSecureNote = document.getElementById('btnSaveSecureNote');
    const loadSecureNoteIdInput = document.getElementById('loadSecureNoteIdInput');
    const btnLoadSecureNote = document.getElementById('btnLoadSecureNote');
    const loadedSecureNoteContent = document.getElementById('loadedSecureNoteContent');

    const targetEthForRole = document.getElementById('targetEthForRole');
    const roleToAssign = document.getElementById('roleToAssign');
    const assignRoleBtn = document.getElementById('assignRoleBtn');

    const realtimeNodeValueForTest = document.getElementById('realtimeNodeValueForTest');
    const putLegitP2PBtn = document.getElementById('putLegitP2PBtn');
    const putFakeSigP2PBtn = document.getElementById('putFakeSigP2PBtn');
    const putNoPermissionP2PBtn = document.getElementById('putNoPermissionP2PBtn');
    const realtimeNodeLogDisplay = document.getElementById('realtimeNodeLogDisplay');

    const logConsole = document.getElementById('logConsole');

    // --- Application State ---
    let db = null;
    let sm = null;
    let volatileIdentityCache = null;
    let roleListenerUnsubscribe = null;
    let realtimeTestNodeUnsubscribe = null;
    const REALTIME_TEST_NODE_ID = 'realtime_security_test_node';

    // --- Logging Utilities ---
    function logToUI(message, type = 'log') {
      const entry = document.createElement('div');
      entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
      const typeToClass = { error: 'log-error', warn: 'log-warn', info: 'log-info', success: 'log-success' };
      if (typeToClass[type]) entry.classList.add(typeToClass[type]);
      logConsole.appendChild(entry);
      logConsole.scrollTop = logConsole.scrollHeight;
      console[type] ? console[type](message) : console.log(message);
    }

    function logToRealtimeDisplay(message) {
      const timestamp = new Date().toLocaleTimeString();
      realtimeNodeLogDisplay.textContent += `\n[${timestamp}] ${message}`;
      realtimeNodeLogDisplay.scrollTop = realtimeNodeLogDisplay.scrollHeight;
    }

    // --- Central State Handler (The Core of the Refactor) ---
    async function handleSecurityStateChange(securityState) {
      logToUI(`RBAC State Change: Active=${securityState.isActive}, Addr=${securityState.activeAddress?.substring(0, 10) || 'N/A'}...`, 'info');

      statusRbacActive.textContent = securityState.isActive;
      statusActiveAddress.textContent = securityState.activeAddress || 'N/A';
      statusWebAuthnProtected.textContent = securityState.isWebAuthnProtected;
      statusVolatileIdentity.textContent = securityState.hasVolatileIdentity;
      statusWebAuthnRegistered.textContent = securityState.hasWebAuthnHardwareRegistration;

      const isGdbReady = !!db;
      const canPerformActions = isGdbReady && securityState.isActive;

  btnRegisterNewUser.disabled = !isGdbReady || securityState.isActive;
  btnProtectWebAuthn.disabled = !securityState.hasVolatileIdentity || securityState.isActive;
  btnLoginWebAuthn.disabled = !isGdbReady || !securityState.hasWebAuthnHardwareRegistration || securityState.isActive;
  btnLoginMnemonic.disabled = !isGdbReady || securityState.isActive;
  btnLogout.disabled = !canPerformActions;
  btnShowMnemonic.disabled = !canPerformActions || !sm.getMnemonicForDisplayAfterRegistrationOrRecovery();
  btnSaveSecureNote.disabled = !canPerformActions;
  btnLoadSecureNote.disabled = !canPerformActions;
  assignRoleBtn.disabled = !canPerformActions;
  putLegitP2PBtn.disabled = !canPerformActions;
  putFakeSigP2PBtn.disabled = !canPerformActions;
  putNoPermissionP2PBtn.disabled = !canPerformActions;

      if (securityState.hasVolatileIdentity && volatileIdentityCache) {
        newMnemonicElem.textContent = volatileIdentityCache.mnemonic;
        newEthAddressElem.textContent = volatileIdentityCache.address;
        newIdentityInfo.classList.remove('hidden');
      } else {
        newIdentityInfo.classList.add('hidden');
        if (!securityState.isActive) volatileIdentityCache = null;
      }

      if (roleListenerUnsubscribe) {
        roleListenerUnsubscribe();
        roleListenerUnsubscribe = null;
      }
      if (canPerformActions && securityState.activeAddress) {
        const userNodeKey = `user:${securityState.activeAddress}`;
        try {
          const { unsubscribe } = await db.get(userNodeKey, (userNode) => {
            const currentEth = sm.getActiveEthAddress();
            const superAdmins = superAdminInput.value.split(',').map(s => s.trim().toLowerCase()).filter(Boolean);

            if (currentEth && superAdmins.includes(currentEth.toLowerCase())) {
              statusCurrentRole.textContent = 'superadmin (from config)';
              return;
            }

            let role = 'guest';
            if (userNode && userNode.value && userNode.value.role) {
              role = userNode.value.role;
            }
            statusCurrentRole.textContent = role;
            logToUI(`Reactive role update: Role is now '${role}'.`, 'info');
          });
          roleListenerUnsubscribe = unsubscribe;
        } catch (e) {
          statusCurrentRole.textContent = 'Error subscribing';
          logToUI(`Error setting up role subscription: ${e.message}`, 'error');
        }
      } else {
        statusCurrentRole.textContent = 'N/A';
      }
    }

    // --- Initialization ---
    async function initializeApp() {
      if (db) { logToUI("DB already initialized.", "warn"); return; }
      const dbName = dbNameInput.value.trim();
      if (!dbName) { logToUI("DB Name is required.", "error"); return; }

      initStatus.textContent = "Initializing...";
      logToUI(`Initializing GDB with name: ${dbName}...`);

      db = await gdb(dbName, { sm: true });
      sm = db.sm;
      try {
        logToUI("GDB instance ready.", "success");
        await setupAutomaticRealtimeSubscription();
      } catch (e) {
        logToUI(`GDB setup error: ${e.message}", "error");
        initStatus.textContent = "GDB Initialization failed.";
        db = null;
        return;
      }

      sm.setSecurityStateChangeCallback(handleSecurityStateChange);

      const superAdmins = superAdminInput.value.split(',').map(s => s.trim()).filter(Boolean);
      await sm.createSecurityContext(db, superAdmins);
      logToUI("Security Context initialized. Session may be restored.", "success");

      localStorage.setItem('gdb_testbed_v2_last_db_name', dbName);
      btnInitializeDB.disabled = true;
      dbNameInput.disabled = true;
      superAdminInput.disabled = true;
  initStatus.textContent = `Initialized: ${dbName}`;
    }

    async function autoInitialize() {
      const persistedDBName = localStorage.getItem('gdb_testbed_v2_last_db_name');
      if (persistedDBName) {
        dbNameInput.value = persistedDBName;
  logToUI('Attempting auto-initialization with persisted DB name: ' + persistedDBName, 'info');
        await initializeApp();
      } else {
        initStatus.textContent = "Ready to initialize.";
        handleSecurityStateChange({ isActive: false });
      }
    }

    // --- Event Listeners ---
    btnInitializeDB.addEventListener('click', initializeApp);

    btnRegisterNewUser.addEventListener('click', async () => {
      logToUI("Generating new volatile identity...", "info");
      try {
        const identity = await sm.startNewUserRegistration();
        if (identity) {
          volatileIdentityCache = identity;
          newEthAddressElem.textContent = identity.address;
          newMnemonicElem.textContent = identity.mnemonic;
          newIdentityInfo.classList.remove('hidden');
          logToUI('New volatile ID created for ' + identity.address.substring(0, 10) + '... SAVE MNEMONIC!', 'success');
        } else {
          logToUI("Failed to generate identity.", "warn");
        }
      } catch (e) {
  logToUI('Registration error: ' + e.message, 'error');
      }
    });

    btnProtectWebAuthn.addEventListener('click', async () => {
      if (!volatileIdentityCache) { logToUI("No volatile identity to protect.", "error"); return; }
      logToUI("Protecting with WebAuthn...", "info");
      try {
        const address = await sm.protectCurrentIdentityWithWebAuthn(volatileIdentityCache.privateKey);
        if (address) {
          logToUI(`Identity protected with WebAuthn & logged in.`, "success");
          volatileIdentityCache = null;
        } else { logToUI("WebAuthn protection cancelled or failed.", "warn"); }
      } catch (e) { logToUI(`WebAuthn protection error: ${e.message}", "error"); }
    });

    btnLoginWebAuthn.addEventListener('click', async () => {
      logToUI("Attempting WebAuthn login...", "info");
      try {
        const address = await sm.loginCurrentUserWithWebAuthn();
        if (address) logToUI(`Logged in with WebAuthn.`, "success");
        else logToUI("WebAuthn login failed or cancelled.", "warn");
      } catch (e) { logToUI(`WebAuthn login error: ${e.message}", "error"); }
    });

    btnLoginMnemonic.addEventListener('click', async () => {
      const mnemonic = mnemonicLoginInput.value.trim();
      if (!mnemonic) { logToUI("Mnemonic is required.", "error"); return; }
      logToUI("Attempting mnemonic login...", "info");
      try {
        volatileIdentityCache = await sm.loginOrRecoverUserWithMnemonic(mnemonic);
        if (volatileIdentityCache) {
          logToUI(`Logged in with mnemonic. You can now protect this with WebAuthn.`, "success");
          mnemonicLoginInput.value = '';
        } else logToUI("Mnemonic login failed.", "error");
      } catch (e) { logToUI(`Mnemonic login error: ${e.message}", "error"); }
    });

    btnLogout.addEventListener('click', async () => {
      logToUI("Logging out...", "info");
      if (roleListenerUnsubscribe) roleListenerUnsubscribe();
      if (realtimeTestNodeUnsubscribe) realtimeTestNodeUnsubscribe();
  await sm.clearSecurity();
      loadedSecureNoteContent.textContent = ''; // Clear decrypted note
      logToUI("Logged out successfully.", "success");
    });

    btnShowMnemonic.addEventListener('click', () => {
  const mnemonic = sm.getMnemonicForDisplayAfterRegistrationOrRecovery();
      if (mnemonic) {
        if (confirm("WARNING: Displaying secret mnemonic phrase. Continue?")) {
          alert(`Your current session mnemonic is:\n\n${mnemonic}`);
          logToUI("Mnemonic displayed.", "warn");
        }
      } else { logToUI("No fresh mnemonic available to display.", "warn"); }
    });

    btnSaveSecureNote.addEventListener('click', async () => {
  if (!sm.isSecurityActive()) { logToUI("Login required to save secure note.", "error"); return; }
      const content = secureNoteContentInput.value;
      let noteId = secureNoteIdInput.value.trim();
      if (!content) { logToUI("Note content cannot be empty.", "warn"); return; }

      logToUI(`Saving secure note (ID: ${noteId || 'new'})... (via sm.put)`, "info");
      try {
        const savedNodeId = await sm.put({ note_content: content, savedAt: new Date().toISOString() }, noteId || undefined);
        logToUI(`Secure note saved. Node ID: ${savedNodeId}`, "success");
        if (!noteId) secureNoteIdInput.value = savedNodeId;
        loadSecureNoteIdInput.value = savedNodeId;
      } catch (error) {
        logToUI(`Failed to save secure note: ${error.message}", "error");
      }
    });

    btnLoadSecureNote.addEventListener('click', async () => {
      if (!sm.isSecurityActive()) {
        logToUI("Login is required to decrypt notes.", "warn");
        return;
      }
      const noteIdToLoad = loadSecureNoteIdInput.value.trim();
      if (!noteIdToLoad) { logToUI("Enter Note ID to load.", "warn"); return; }

      logToUI(`Loading secure note ID: ${noteIdToLoad}... (via sm.get)`, "info");
      loadedSecureNoteContent.textContent = 'Loading...';
      try {
        const { result: node } = await sm.get(noteIdToLoad);
        if (node) {
          if (node.value && node.value._gdb_decryption_failed) {
            logToUI(`Failed to decrypt note '${noteIdToLoad}': ${node.value.reason}", "error");
            loadedSecureNoteContent.textContent = `DECRYPTION FAILED: ${node.value.reason}.`;
          } else if (node.value && node.value._gdb_decryption_unavailable) {
            logToUI(`Cannot decrypt note '${noteIdToLoad}': ${node.value.note}", "warn");
            loadedSecureNoteContent.textContent = `CANNOT DECRYPT: ${node.value.note}`;
          } else if (node.value && node.value._gdb_decryption_error_meta) {
            logToUI(`Cannot decrypt note '${noteIdToLoad}': ${node.value.note}", "error");
            loadedSecureNoteContent.textContent = `DECRYPTION METADATA ERROR: ${node.value.note}`;
          }
          else {
            logToUI(`Secure note '${noteIdToLoad}' loaded and decrypted.`, "success");
            loadedSecureNoteContent.textContent = JSON.stringify(node.value, null, 2);
            if (node.value && node.value.note_content) {
              secureNoteContentInput.value = node.value.note_content;
              secureNoteIdInput.value = node.id;
            }
          }
        } else {
          logToUI(`Secure note ID '${noteIdToLoad}' not found.", "warn");
          loadedSecureNoteContent.textContent = 'Note not found.';
        }
      } catch (error) {
        logToUI(`Failed to load secure note '${noteIdToLoad}': ${error.message}", "error");
        loadedSecureNoteContent.textContent = `Error: ${error.message}`;
      }
    });

    assignRoleBtn.addEventListener('click', async () => {
      const target = targetEthForRole.value.trim();
      const role = roleToAssign.value.trim();
      if (!target || !role) { logToUI("Target ETH and Role are required.", "error"); return; }
      logToUI(`Attempting to assign role '${role}'...`, "info");
      try {
        await sm.executeWithPermission('assignRole');
        logToUI("Permission 'assignRole' granted. Sending request...", "info");
        await sm.assignRole(target, role);
        logToUI("Role assignment request sent to GDB.", "success");
      } catch (e) { logToUI(`Assign role error: ${e.message}", "error"); }
    });

    async function setupAutomaticRealtimeSubscription() {
      if (realtimeTestNodeUnsubscribe) realtimeTestNodeUnsubscribe();
      if (!db) { return; }
      logToRealtimeDisplay(`Subscribing to P2P test node: ${REALTIME_TEST_NODE_ID}...`);
      try {
        const { unsubscribe } = await db.get(REALTIME_TEST_NODE_ID, (nodeData) => {
          const message = nodeData ? `State update: ${JSON.stringify(nodeData.value)}` : "State update: Node not found or deleted.";
          logToRealtimeDisplay(message);
        });
        realtimeTestNodeUnsubscribe = unsubscribe;
        logToRealtimeDisplay("Subscription is now ACTIVE.");
      } catch (e) { logToRealtimeDisplay(`Subscription error: ${e.message}`); }
    }

    putLegitP2PBtn.addEventListener('click', async () => {
      try {
        let value = JSON.parse(realtimeNodeValueForTest.value);
        value.ts = Date.now();
        realtimeNodeValueForTest.value = JSON.stringify(value);

        logToUI("Sending LEGITIMATE 'put'. Verifying 'write' permission...", "info");
    await sm.executeWithPermission('write');
    logToUI("'write' permission granted. Proceeding with db.put().", "info");
    await db.put(value, REALTIME_TEST_NODE_ID);
    logToUI("Legit 'put' sent. Check other browser tabs.", "success");
      } catch (e) {
    logToUI('Legit P2P error: ' + e.message, 'error');
      }
    });

    putFakeSigP2PBtn.addEventListener('click', async () => {
      if (!sm.isSecurityActive()) { logToUI("Login first to get an active address.", "warn"); return; }
      logToUI("Simulating P2P 'put' with a FAKE SIGNATURE...", "info");
      const op = {
        type: 'insert', id: REALTIME_TEST_NODE_ID, value: { fake: true },
        timestamp: db.hybridClock.now(), originEthAddress: sm.getActiveEthAddress(),
        signature: "0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcd1b"
      };
      try {
        const { validatedOperations } = await db.sm.verifyIncomingOperations([op]);
        if (validatedOperations && validatedOperations.length > 0) {
          logToUI("FAKE SIG TEST FAILED: Operation was validated!", "error");
        } else {
          logToUI("FAKE SIG TEST PASSED: Invalid operation was correctly rejected.", "success");
        }
      } catch (e) { logToUI(`Fake sig test error: ${e.message}", "error"); }
    });

    putNoPermissionP2PBtn.addEventListener('click', async () => {
      try {
        let value = JSON.parse(realtimeNodeValueForTest.value);
        value.ts = Date.now();
        realtimeNodeValueForTest.value = JSON.stringify(value);
        logToUI("Sending 'put' with VALID signature but (potentially) NO PERMISSION...", "info");

        await db.put(value, REALTIME_TEST_NODE_ID);
        logToUI("'put' sent. The receiving node's RBAC rules will determine if it's accepted.", "success");
      } catch (e) {
        logToUI(`No-permission P2P error (local check failed): ${e.message}`, "error");
      }
    });

    // --- Initial Load ---
    logToUI("Testbed loaded. Ready for initialization.");
    autoInitialize();

  </script>
</body>

</html>