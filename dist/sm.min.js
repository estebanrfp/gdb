var p7=Object.defineProperty;var u7=(Q,Y)=>{for(var J in Y)p7(Q,J,{get:Y[J],enumerable:!0,configurable:!0,set:(X)=>Y[J]=()=>X})};var FQ="6.15.0";var d7=function(Q,Y,J){const X=Y.split("|").map((G)=>G.trim());for(let G=0;G<X.length;G++)switch(Y){case"any":return;case"bigint":case"boolean":case"number":case"string":if(typeof Q===Y)return}const q=new Error(`invalid value for type ${Y}`);throw q.code="INVALID_ARGUMENT",q.argument=`value.${J}`,q.value=Q,q};async function a0(Q){const Y=Object.keys(Q);return(await Promise.all(Y.map((X)=>Promise.resolve(Q[X])))).reduce((X,q,G)=>{return X[Y[G]]=q,X},{})}function s(Q,Y,J){for(let X in Y){let q=Y[X];const G=J?J[X]:null;if(G)d7(q,G,X);Object.defineProperty(Q,X,{enumerable:!0,value:q,writable:!1})}}var I9=function(Q,Y){if(Q==null)return"null";if(Y==null)Y=new Set;if(typeof Q==="object"){if(Y.has(Q))return"[Circular]";Y.add(Q)}if(Array.isArray(Q))return"[ "+Q.map((J)=>I9(J,Y)).join(", ")+" ]";if(Q instanceof Uint8Array){let X="0x";for(let q=0;q<Q.length;q++)X+="0123456789abcdef"[Q[q]>>4],X+="0123456789abcdef"[Q[q]&15];return X}if(typeof Q==="object"&&typeof Q.toJSON==="function")return I9(Q.toJSON(),Y);switch(typeof Q){case"boolean":case"number":case"symbol":return Q.toString();case"bigint":return BigInt(Q).toString();case"string":return JSON.stringify(Q);case"object":{const J=Object.keys(Q);return J.sort(),"{ "+J.map((X)=>`${I9(X,Y)}: ${I9(Q[X],Y)}`).join(", ")+" }"}}return"[ COULD NOT SERIALIZE ]"};function BQ(Q,Y){return Q&&Q.code===Y}function c9(Q,Y,J){let X=Q;{const G=[];if(J){if(("message"in J)||("code"in J)||("name"in J))throw new Error(`value will overwrite populated values: ${I9(J)}`);for(let W in J){if(W==="shortMessage")continue;const U=J[W];G.push(W+"="+I9(U))}}if(G.push(`code=${Y}`),G.push(`version=${FQ}`),G.length)Q+=" ("+G.join(", ")+")"}let q;switch(Y){case"INVALID_ARGUMENT":q=new TypeError(Q);break;case"NUMERIC_FAULT":case"BUFFER_OVERRUN":q=new RangeError(Q);break;default:q=new Error(Q)}if(s(q,{code:Y}),J)Object.assign(q,J);if(q.shortMessage==null)s(q,{shortMessage:X});return q}function f(Q,Y,J,X){if(!Q)throw c9(Y,J,X)}function I(Q,Y,J,X){f(Q,Y,"INVALID_ARGUMENT",{argument:J,value:X})}function L9(Q){f(l7.indexOf(Q)>=0,"platform missing String.prototype.normalize","UNSUPPORTED_OPERATION",{operation:"String.prototype.normalize",info:{form:Q}})}function U8(Q,Y,J){if(J==null)J="";if(Q!==Y){let X=J,q="new";if(J)X+=".",q+=" "+J;f(!1,`private constructor; use ${X}from* methods`,"UNSUPPORTED_OPERATION",{operation:q})}}var l7=["NFD","NFC","NFKD","NFKC"].reduce((Q,Y)=>{try{if("test".normalize(Y)!=="test")throw new Error("bad");if(Y==="NFD"){const J=String.fromCharCode(233).normalize("NFD"),X=String.fromCharCode(101,769);if(J!==X)throw new Error("broken")}Q.push(Y)}catch(J){}return Q},[]);var jY=function(Q,Y,J){if(Q instanceof Uint8Array){if(J)return new Uint8Array(Q);return Q}if(typeof Q==="string"&&Q.match(/^0x(?:[0-9a-f][0-9a-f])*$/i)){const X=new Uint8Array((Q.length-2)/2);let q=2;for(let G=0;G<X.length;G++)X[G]=parseInt(Q.substring(q,q+2),16),q+=2;return X}I(!1,"invalid BytesLike value",Y||"value",Q)};function E(Q,Y){return jY(Q,Y,!1)}function l0(Q,Y){return jY(Q,Y,!0)}function H0(Q,Y){if(typeof Q!=="string"||!Q.match(/^0x[0-9A-Fa-f]*$/))return!1;if(typeof Y==="number"&&Q.length!==2+2*Y)return!1;if(Y===!0&&Q.length%2!==0)return!1;return!0}function t0(Q){return H0(Q,!0)||Q instanceof Uint8Array}function B(Q){const Y=E(Q);let J="0x";for(let X=0;X<Y.length;X++){const q=Y[X];J+=KY[(q&240)>>4]+KY[q&15]}return J}function i(Q){return"0x"+Q.map((Y)=>B(Y).substring(2)).join("")}function V8(Q){if(H0(Q,!0))return(Q.length-2)/2;return E(Q).length}function D9(Q,Y,J){const X=E(Q);if(J!=null&&J>X.length)f(!1,"cannot slice beyond data bounds","BUFFER_OVERRUN",{buffer:X,length:X.length,offset:J});return B(X.slice(Y==null?0:Y,J==null?X.length:J))}var n7=function(Q,Y,J){const X=E(Q);f(Y>=X.length,"padding exceeds data length","BUFFER_OVERRUN",{buffer:new Uint8Array(X),length:Y,offset:Y+1});const q=new Uint8Array(Y);if(q.fill(0),J)q.set(X,Y-X.length);else q.set(X,0);return B(q)};function S0(Q,Y){return n7(Q,Y,!0)}var KY="0123456789abcdef";function EQ(Q,Y){let J=c(Q,"value");const X=BigInt(Z0(Y,"width")),q=l8<<X-l8;if(J<vJ){J=-J,f(J<=q,"too low","NUMERIC_FAULT",{operation:"toTwos",fault:"overflow",value:Q});const G=(l8<<X)-l8;return(~J&G)+l8}else f(J<q,"too high","NUMERIC_FAULT",{operation:"toTwos",fault:"overflow",value:Q});return J}function SQ(Q,Y){const J=p9(Q,"value"),X=BigInt(Z0(Y,"bits"));return J&(l8<<X)-l8}function c(Q,Y){switch(typeof Q){case"bigint":return Q;case"number":return I(Number.isInteger(Q),"underflow",Y||"value",Q),I(Q>=-H9&&Q<=H9,"overflow",Y||"value",Q),BigInt(Q);case"string":try{if(Q==="")throw new Error("empty string");if(Q[0]==="-"&&Q[1]!=="-")return-BigInt(Q.substring(1));return BigInt(Q)}catch(J){I(!1,`invalid BigNumberish string: ${J.message}`,Y||"value",Q)}}I(!1,"invalid BigNumberish value",Y||"value",Q)}function p9(Q,Y){const J=c(Q,Y);return f(J>=vJ,"unsigned value cannot be negative","NUMERIC_FAULT",{fault:"overflow",operation:"getUint",value:Q}),J}function R9(Q){if(Q instanceof Uint8Array){let Y="0x0";for(let J of Q)Y+=OY[J>>4],Y+=OY[J&15];return BigInt(Y)}return c(Q)}function Z0(Q,Y){switch(typeof Q){case"bigint":return I(Q>=-H9&&Q<=H9,"overflow",Y||"value",Q),Number(Q);case"number":return I(Number.isInteger(Q),"underflow",Y||"value",Q),I(Q>=-H9&&Q<=H9,"overflow",Y||"value",Q),Q;case"string":try{if(Q==="")throw new Error("empty string");return Z0(BigInt(Q),Y)}catch(J){I(!1,`invalid numeric string: ${J.message}`,Y||"value",Q)}}I(!1,"invalid numeric value",Y||"value",Q)}function n0(Q,Y){let X=p9(Q,"value").toString(16);if(Y==null){if(X.length%2)X="0"+X}else{const q=Z0(Y,"width");f(q*2>=X.length,`value exceeds width (${q} bytes)`,"NUMERIC_FAULT",{operation:"toBeHex",fault:"overflow",value:Q});while(X.length<q*2)X="0"+X}return"0x"+X}function e(Q){const Y=p9(Q,"value");if(Y===vJ)return new Uint8Array([]);let J=Y.toString(16);if(J.length%2)J="0"+J;const X=new Uint8Array(J.length/2);for(let q=0;q<X.length;q++){const G=q*2;X[q]=parseInt(J.substring(G,G+2),16)}return X}function AQ(Q){let Y=B(t0(Q)?Q:e(Q)).substring(2);while(Y.startsWith("0"))Y=Y.substring(1);if(Y==="")Y="0";return"0x"+Y}var vJ=BigInt(0),l8=BigInt(1),H9=9007199254740991,OY="0123456789abcdef";var o7=function(Q){if(kQ==null){kQ={};for(let J=0;J<xQ.length;J++)kQ[xQ[J]]=BigInt(J)}const Y=kQ[Q];return I(Y!=null,"invalid base58 value","letter",Q),Y};function fQ(Q){const Y=E(Q);let J=R9(Y),X="";while(J)X=xQ[Number(J%gJ)]+X,J/=gJ;for(let q=0;q<Y.length;q++){if(Y[q])break;X=xQ[0]+X}return X}function bQ(Q){let Y=i7;for(let J=0;J<Q.length;J++)Y*=gJ,Y+=o7(Q[J]);return Y}var xQ="123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz",kQ=null,i7=BigInt(0),gJ=BigInt(58);var r7=function(Q,Y,J,X,q){I(!1,`invalid codepoint at offset ${Y}; ${Q}`,"bytes",J)},IY=function(Q,Y,J,X,q){if(Q==="BAD_PREFIX"||Q==="UNEXPECTED_CONTINUE"){let G=0;for(let W=Y+1;W<J.length;W++){if(J[W]>>6!==2)break;G++}return G}if(Q==="OVERRUN")return J.length-Y-1;return 0},a7=function(Q,Y,J,X,q){if(Q==="OVERLONG")return I(typeof q==="number","invalid bad code point for replacement","badCodepoint",q),X.push(q),0;return X.push(65533),IY(Q,Y,J,X,q)},t7=function(Q,Y){if(Y==null)Y=yJ.error;const J=E(Q,"bytes"),X=[];let q=0;while(q<J.length){const G=J[q++];if(G>>7===0){X.push(G);continue}let W=null,U=null;if((G&224)===192)W=1,U=127;else if((G&240)===224)W=2,U=2047;else if((G&248)===240)W=3,U=65535;else{if((G&192)===128)q+=Y("UNEXPECTED_CONTINUE",q-1,J,X);else q+=Y("BAD_PREFIX",q-1,J,X);continue}if(q-1+W>=J.length){q+=Y("OVERRUN",q-1,J,X);continue}let $=G&(1<<8-W-1)-1;for(let V=0;V<W;V++){let Z=J[q];if((Z&192)!=128){q+=Y("MISSING_CONTINUE",q,J,X),$=null;break}$=$<<6|Z&63,q++}if($===null)continue;if($>1114111){q+=Y("OUT_OF_RANGE",q-1-W,J,X,$);continue}if($>=55296&&$<=57343){q+=Y("UTF16_SURROGATE",q-1-W,J,X,$);continue}if($<=U){q+=Y("OVERLONG",q-1-W,J,X,$);continue}X.push($)}return X};function z0(Q,Y){if(I(typeof Q==="string","invalid string value","str",Q),Y!=null)L9(Y),Q=Q.normalize(Y);let J=[];for(let X=0;X<Q.length;X++){const q=Q.charCodeAt(X);if(q<128)J.push(q);else if(q<2048)J.push(q>>6|192),J.push(q&63|128);else if((q&64512)==55296){X++;const G=Q.charCodeAt(X);I(X<Q.length&&(G&64512)===56320,"invalid surrogate pair","str",Q);const W=65536+((q&1023)<<10)+(G&1023);J.push(W>>18|240),J.push(W>>12&63|128),J.push(W>>6&63|128),J.push(W&63|128)}else J.push(q>>12|224),J.push(q>>6&63|128),J.push(q&63|128)}return new Uint8Array(J)}var s7=function(Q){return Q.map((Y)=>{if(Y<=65535)return String.fromCharCode(Y);return Y-=65536,String.fromCharCode((Y>>10&1023)+55296,(Y&1023)+56320)}).join("")};function vQ(Q,Y){return s7(t7(Q,Y))}var yJ=Object.freeze({error:r7,ignore:IY,replace:a7});var e7=function(Q){let Y=Q.toString(16);while(Y.length<2)Y="0"+Y;return"0x"+Y},LY=function(Q,Y,J){let X=0;for(let q=0;q<J;q++)X=X*256+Q[Y+q];return X},DY=function(Q,Y,J,X){const q=[];while(J<Y+1+X){const G=HY(Q,J);q.push(G.result),J+=G.consumed,f(J<=Y+1+X,"child data too short","BUFFER_OVERRUN",{buffer:Q,length:X,offset:Y})}return{consumed:1+X,result:q}},HY=function(Q,Y){f(Q.length!==0,"data too short","BUFFER_OVERRUN",{buffer:Q,length:0,offset:1});const J=(X)=>{f(X<=Q.length,"data short segment too short","BUFFER_OVERRUN",{buffer:Q,length:Q.length,offset:X})};if(Q[Y]>=248){const X=Q[Y]-247;J(Y+1+X);const q=LY(Q,Y+1,X);return J(Y+1+X+q),DY(Q,Y,Y+1+X,X+q)}else if(Q[Y]>=192){const X=Q[Y]-192;return J(Y+1+X),DY(Q,Y,Y+1,X)}else if(Q[Y]>=184){const X=Q[Y]-183;J(Y+1+X);const q=LY(Q,Y+1,X);J(Y+1+X+q);const G=B(Q.slice(Y+1+X,Y+1+X+q));return{consumed:1+X+q,result:G}}else if(Q[Y]>=128){const X=Q[Y]-128;J(Y+1+X);const q=B(Q.slice(Y+1,Y+1+X));return{consumed:1+X,result:q}}return{consumed:1,result:e7(Q[Y])}};function B8(Q){const Y=E(Q,"data"),J=HY(Y,0);return I(J.consumed===Y.length,"unexpected junk after rlp payload","data",Q),J.result}var RY=function(Q){const Y=[];while(Q)Y.unshift(Q&255),Q>>=8;return Y},CY=function(Q){if(Array.isArray(Q)){let X=[];if(Q.forEach(function(G){X=X.concat(CY(G))}),X.length<=55)return X.unshift(192+X.length),X;const q=RY(X.length);return q.unshift(247+q.length),q.concat(X)}const Y=Array.prototype.slice.call(E(Q,"object"));if(Y.length===1&&Y[0]<=127)return Y;else if(Y.length<=55)return Y.unshift(128+Y.length),Y;const J=RY(Y.length);return J.unshift(183+J.length),J.concat(Y)};function v0(Q){let Y="0x";for(let J of CY(Q))Y+=PY[J>>4],Y+=PY[J&15];return Y}var PY="0123456789abcdef";function gQ(Q){const Y=E(Q,"randomBytes");Y[6]=Y[6]&15|64,Y[8]=Y[8]&63|128;const J=B(Y);return[J.substring(2,10),J.substring(10,14),J.substring(14,18),J.substring(18,22),J.substring(22,34)].join("-")}var R0=function(Q){if(!Number.isSafeInteger(Q)||Q<0)throw new Error(`Wrong positive integer: ${Q}`)};var u9=function(Q,...Y){if(!(Q instanceof Uint8Array))throw new Error("Expected Uint8Array");if(Y.length>0&&!Y.includes(Q.length))throw new Error(`Expected Uint8Array of length ${Y}, not of length=${Q.length}`)},yQ=function(Q){if(typeof Q!=="function"||typeof Q.create!=="function")throw new Error("Hash should be wrapped by utils.wrapConstructor");R0(Q.outputLen),R0(Q.blockLen)},$8=function(Q,Y=!0){if(Q.destroyed)throw new Error("Hash instance has been destroyed");if(Y&&Q.finished)throw new Error("Hash#digest() has already been called")},hQ=function(Q,Y){u9(Q);const J=Y.outputLen;if(Q.length<J)throw new Error(`digestInto() expects output buffer of length at least ${J}`)};var mQ=typeof globalThis==="object"&&("crypto"in globalThis)?globalThis.crypto:void 0;async function _Q(Q,Y,J){let X=Date.now();for(let q=0;q<Q;q++){J(q);const G=Date.now()-X;if(G>=0&&G<Y)continue;await V1(),X+=G}}function $1(Q){if(typeof Q!=="string")throw new Error(`utf8ToBytes expected string, got ${typeof Q}`);return new Uint8Array((new TextEncoder()).encode(Q))}function s0(Q){if(typeof Q==="string")Q=$1(Q);if(!TY(Q))throw new Error(`expected Uint8Array, got ${typeof Q}`);return Q}function NY(...Q){const Y=new Uint8Array(Q.reduce((X,q)=>X+q.length,0));let J=0;return Q.forEach((X)=>{if(!TY(X))throw new Error("Uint8Array expected");Y.set(X,J),J+=X.length}),Y}function cQ(Q,Y){if(Y!==void 0&&Z1.call(Y)!=="[object Object]")throw new Error("Options should be object or undefined");return Object.assign(Q,Y)}function E8(Q){const Y=(X)=>Q().update(s0(X)).digest(),J=Q();return Y.outputLen=J.outputLen,Y.blockLen=J.blockLen,Y.create=()=>Q(),Y}function wY(Q=32){if(mQ&&typeof mQ.getRandomValues==="function")return mQ.getRandomValues(new Uint8Array(Q));throw new Error("crypto.getRandomValues must be defined")}/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */var TY=(Q)=>Q instanceof Uint8Array;var P9=(Q)=>new Uint32Array(Q.buffer,Q.byteOffset,Math.floor(Q.byteLength/4)),C9=(Q)=>new DataView(Q.buffer,Q.byteOffset,Q.byteLength),o0=(Q,Y)=>Q<<32-Y|Q>>>Y,U1=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;if(!U1)throw new Error("Non little-endian hardware is not supported");var V1=async()=>{};class n8{clone(){return this._cloneInto()}}var Z1={}.toString;class hJ extends n8{constructor(Q,Y){super();this.finished=!1,this.destroyed=!1,yQ(Q);const J=s0(Y);if(this.iHash=Q.create(),typeof this.iHash.update!=="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const X=this.blockLen,q=new Uint8Array(X);q.set(J.length>X?Q.create().update(J).digest():J);for(let G=0;G<q.length;G++)q[G]^=54;this.iHash.update(q),this.oHash=Q.create();for(let G=0;G<q.length;G++)q[G]^=54^92;this.oHash.update(q),q.fill(0)}update(Q){return $8(this),this.iHash.update(Q),this}digestInto(Q){$8(this),u9(Q,this.outputLen),this.finished=!0,this.iHash.digestInto(Q),this.oHash.update(Q),this.oHash.digestInto(Q),this.destroy()}digest(){const Q=new Uint8Array(this.oHash.outputLen);return this.digestInto(Q),Q}_cloneInto(Q){Q||(Q=Object.create(Object.getPrototypeOf(this),{}));const{oHash:Y,iHash:J,finished:X,destroyed:q,blockLen:G,outputLen:W}=this;return Q=Q,Q.finished=X,Q.destroyed=q,Q.blockLen=G,Q.outputLen=W,Q.oHash=Y._cloneInto(Q.oHash),Q.iHash=J._cloneInto(Q.iHash),Q}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}var o8=(Q,Y,J)=>new hJ(Q,Y).update(J).digest();o8.create=(Q,Y)=>new hJ(Q,Y);var z1=function(Q,Y,J,X){yQ(Q);const q=cQ({dkLen:32,asyncTick:10},X),{c:G,dkLen:W,asyncTick:U}=q;if(R0(G),R0(W),R0(U),G<1)throw new Error("PBKDF2: iterations (c) should be >= 1");const $=s0(Y),V=s0(J),Z=new Uint8Array(W),K=o8.create(Q,$),M=K._cloneInto().update(V);return{c:G,dkLen:W,asyncTick:U,DK:Z,PRF:K,PRFSalt:M}},M1=function(Q,Y,J,X,q){if(Q.destroy(),Y.destroy(),X)X.destroy();return q.fill(0),J};function d9(Q,Y,J,X){const{c:q,dkLen:G,DK:W,PRF:U,PRFSalt:$}=z1(Q,Y,J,X);let V;const Z=new Uint8Array(4),K=C9(Z),M=new Uint8Array(U.outputLen);for(let j=1,z=0;z<G;j++,z+=U.outputLen){const L=W.subarray(z,z+U.outputLen);K.setInt32(0,j,!1),(V=$._cloneInto(V)).update(Z).digestInto(M),L.set(M.subarray(0,L.length));for(let H=1;H<q;H++){U._cloneInto(V).update(M).digestInto(M);for(let P=0;P<L.length;P++)L[P]^=M[P]}}return M1(U,$,W,V,M)}var K1=function(Q,Y,J,X){if(typeof Q.setBigUint64==="function")return Q.setBigUint64(Y,J,X);const q=BigInt(32),G=BigInt(4294967295),W=Number(J>>q&G),U=Number(J&G),$=X?4:0,V=X?0:4;Q.setUint32(Y+$,W,X),Q.setUint32(Y+V,U,X)};class i8 extends n8{constructor(Q,Y,J,X){super();this.blockLen=Q,this.outputLen=Y,this.padOffset=J,this.isLE=X,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(Q),this.view=C9(this.buffer)}update(Q){$8(this);const{view:Y,buffer:J,blockLen:X}=this;Q=s0(Q);const q=Q.length;for(let G=0;G<q;){const W=Math.min(X-this.pos,q-G);if(W===X){const U=C9(Q);for(;X<=q-G;G+=X)this.process(U,G);continue}if(J.set(Q.subarray(G,G+W),this.pos),this.pos+=W,G+=W,this.pos===X)this.process(Y,0),this.pos=0}return this.length+=Q.length,this.roundClean(),this}digestInto(Q){$8(this),hQ(Q,this),this.finished=!0;const{buffer:Y,view:J,blockLen:X,isLE:q}=this;let{pos:G}=this;if(Y[G++]=128,this.buffer.subarray(G).fill(0),this.padOffset>X-G)this.process(J,0),G=0;for(let Z=G;Z<X;Z++)Y[Z]=0;K1(J,X-8,BigInt(this.length*8),q),this.process(J,0);const W=C9(Q),U=this.outputLen;if(U%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const $=U/4,V=this.get();if($>V.length)throw new Error("_sha2: outputLen bigger than state");for(let Z=0;Z<$;Z++)W.setUint32(4*Z,V[Z],q)}digest(){const{buffer:Q,outputLen:Y}=this;this.digestInto(Q);const J=Q.slice(0,Y);return this.destroy(),J}_cloneInto(Q){Q||(Q=new this.constructor),Q.set(...this.get());const{blockLen:Y,buffer:J,length:X,finished:q,destroyed:G,pos:W}=this;if(Q.length=X,Q.pos=W,Q.finished=q,Q.destroyed=G,X%Y)Q.buffer.set(J);return Q}}var j1=(Q,Y,J)=>Q&Y^~Q&J,O1=(Q,Y,J)=>Q&Y^Q&J^Y&J,I1=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),S8=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),A8=new Uint32Array(64);class FY extends i8{constructor(){super(64,32,8,!1);this.A=S8[0]|0,this.B=S8[1]|0,this.C=S8[2]|0,this.D=S8[3]|0,this.E=S8[4]|0,this.F=S8[5]|0,this.G=S8[6]|0,this.H=S8[7]|0}get(){const{A:Q,B:Y,C:J,D:X,E:q,F:G,G:W,H:U}=this;return[Q,Y,J,X,q,G,W,U]}set(Q,Y,J,X,q,G,W,U){this.A=Q|0,this.B=Y|0,this.C=J|0,this.D=X|0,this.E=q|0,this.F=G|0,this.G=W|0,this.H=U|0}process(Q,Y){for(let Z=0;Z<16;Z++,Y+=4)A8[Z]=Q.getUint32(Y,!1);for(let Z=16;Z<64;Z++){const K=A8[Z-15],M=A8[Z-2],j=o0(K,7)^o0(K,18)^K>>>3,z=o0(M,17)^o0(M,19)^M>>>10;A8[Z]=z+A8[Z-7]+j+A8[Z-16]|0}let{A:J,B:X,C:q,D:G,E:W,F:U,G:$,H:V}=this;for(let Z=0;Z<64;Z++){const K=o0(W,6)^o0(W,11)^o0(W,25),M=V+K+j1(W,U,$)+I1[Z]+A8[Z]|0,z=(o0(J,2)^o0(J,13)^o0(J,22))+O1(J,X,q)|0;V=$,$=U,U=W,W=G+M|0,G=q,q=X,X=J,J=M+z|0}J=J+this.A|0,X=X+this.B|0,q=q+this.C|0,G=G+this.D|0,W=W+this.E|0,U=U+this.F|0,$=$+this.G|0,V=V+this.H|0,this.set(J,X,q,G,W,U,$,V)}roundClean(){A8.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}}var Z8=E8(()=>new FY);var BY=function(Q,Y=!1){if(Y)return{h:Number(Q&pQ),l:Number(Q>>mJ&pQ)};return{h:Number(Q>>mJ&pQ)|0,l:Number(Q&pQ)|0}},_J=function(Q,Y=!1){let J=new Uint32Array(Q.length),X=new Uint32Array(Q.length);for(let q=0;q<Q.length;q++){const{h:G,l:W}=BY(Q[q],Y);[J[q],X[q]]=[G,W]}return[J,X]},F1=function(Q,Y,J,X){const q=(Y>>>0)+(X>>>0);return{h:Q+J+(q/4294967296|0)|0,l:q|0}},pQ=BigInt(4294967295),mJ=BigInt(32),L1=(Q,Y)=>BigInt(Q>>>0)<<mJ|BigInt(Y>>>0),D1=(Q,Y,J)=>Q>>>J,H1=(Q,Y,J)=>Q<<32-J|Y>>>J,R1=(Q,Y,J)=>Q>>>J|Y<<32-J,P1=(Q,Y,J)=>Q<<32-J|Y>>>J,C1=(Q,Y,J)=>Q<<64-J|Y>>>J-32,T1=(Q,Y,J)=>Q>>>J-32|Y<<64-J,N1=(Q,Y)=>Y,w1=(Q,Y)=>Q,cJ=(Q,Y,J)=>Q<<J|Y>>>32-J,pJ=(Q,Y,J)=>Y<<J|Q>>>32-J,uJ=(Q,Y,J)=>Y<<J-32|Q>>>64-J,dJ=(Q,Y,J)=>Q<<J-32|Y>>>64-J,B1=(Q,Y,J)=>(Q>>>0)+(Y>>>0)+(J>>>0),E1=(Q,Y,J,X)=>Y+J+X+(Q/4294967296|0)|0,S1=(Q,Y,J,X)=>(Q>>>0)+(Y>>>0)+(J>>>0)+(X>>>0),A1=(Q,Y,J,X,q)=>Y+J+X+q+(Q/4294967296|0)|0,k1=(Q,Y,J,X,q)=>(Q>>>0)+(Y>>>0)+(J>>>0)+(X>>>0)+(q>>>0),x1=(Q,Y,J,X,q,G)=>Y+J+X+q+G+(Q/4294967296|0)|0;var f1={fromBig:BY,split:_J,toBig:L1,shrSH:D1,shrSL:H1,rotrSH:R1,rotrSL:P1,rotrBH:C1,rotrBL:T1,rotr32H:N1,rotr32L:w1,rotlSH:cJ,rotlSL:pJ,rotlBH:uJ,rotlBL:dJ,add:F1,add3L:B1,add3H:E1,add4L:S1,add4H:A1,add5H:x1,add5L:k1},h=f1;var[b1,v1]=(()=>h.split(["0x428a2f98d728ae22","0x7137449123ef65cd","0xb5c0fbcfec4d3b2f","0xe9b5dba58189dbbc","0x3956c25bf348b538","0x59f111f1b605d019","0x923f82a4af194f9b","0xab1c5ed5da6d8118","0xd807aa98a3030242","0x12835b0145706fbe","0x243185be4ee4b28c","0x550c7dc3d5ffb4e2","0x72be5d74f27b896f","0x80deb1fe3b1696b1","0x9bdc06a725c71235","0xc19bf174cf692694","0xe49b69c19ef14ad2","0xefbe4786384f25e3","0x0fc19dc68b8cd5b5","0x240ca1cc77ac9c65","0x2de92c6f592b0275","0x4a7484aa6ea6e483","0x5cb0a9dcbd41fbd4","0x76f988da831153b5","0x983e5152ee66dfab","0xa831c66d2db43210","0xb00327c898fb213f","0xbf597fc7beef0ee4","0xc6e00bf33da88fc2","0xd5a79147930aa725","0x06ca6351e003826f","0x142929670a0e6e70","0x27b70a8546d22ffc","0x2e1b21385c26c926","0x4d2c6dfc5ac42aed","0x53380d139d95b3df","0x650a73548baf63de","0x766a0abb3c77b2a8","0x81c2c92e47edaee6","0x92722c851482353b","0xa2bfe8a14cf10364","0xa81a664bbc423001","0xc24b8b70d0f89791","0xc76c51a30654be30","0xd192e819d6ef5218","0xd69906245565a910","0xf40e35855771202a","0x106aa07032bbd1b8","0x19a4c116b8d2d0c8","0x1e376c085141ab53","0x2748774cdf8eeb99","0x34b0bcb5e19b48a8","0x391c0cb3c5c95a63","0x4ed8aa4ae3418acb","0x5b9cca4f7763e373","0x682e6ff3d6b2b8a3","0x748f82ee5defb2fc","0x78a5636f43172f60","0x84c87814a1f0ab72","0x8cc702081a6439ec","0x90befffa23631e28","0xa4506cebde82bde9","0xbef9a3f7b2c67915","0xc67178f2e372532b","0xca273eceea26619c","0xd186b8c721c0c207","0xeada7dd6cde0eb1e","0xf57d4f7fee6ed178","0x06f067aa72176fba","0x0a637dc5a2c898a6","0x113f9804bef90dae","0x1b710b35131c471b","0x28db77f523047d84","0x32caab7b40c72493","0x3c9ebe0a15c9bebc","0x431d67c49c100d4c","0x4cc5d4becb3e42b6","0x597f299cfc657e2a","0x5fcb6fab3ad6faec","0x6c44198c4a475817"].map((Q)=>BigInt(Q))))(),k8=new Uint32Array(80),x8=new Uint32Array(80);class EY extends i8{constructor(){super(128,64,16,!1);this.Ah=1779033703|0,this.Al=4089235720|0,this.Bh=3144134277|0,this.Bl=2227873595|0,this.Ch=1013904242|0,this.Cl=4271175723|0,this.Dh=2773480762|0,this.Dl=1595750129|0,this.Eh=1359893119|0,this.El=2917565137|0,this.Fh=2600822924|0,this.Fl=725511199|0,this.Gh=528734635|0,this.Gl=4215389547|0,this.Hh=1541459225|0,this.Hl=327033209|0}get(){const{Ah:Q,Al:Y,Bh:J,Bl:X,Ch:q,Cl:G,Dh:W,Dl:U,Eh:$,El:V,Fh:Z,Fl:K,Gh:M,Gl:j,Hh:z,Hl:L}=this;return[Q,Y,J,X,q,G,W,U,$,V,Z,K,M,j,z,L]}set(Q,Y,J,X,q,G,W,U,$,V,Z,K,M,j,z,L){this.Ah=Q|0,this.Al=Y|0,this.Bh=J|0,this.Bl=X|0,this.Ch=q|0,this.Cl=G|0,this.Dh=W|0,this.Dl=U|0,this.Eh=$|0,this.El=V|0,this.Fh=Z|0,this.Fl=K|0,this.Gh=M|0,this.Gl=j|0,this.Hh=z|0,this.Hl=L|0}process(Q,Y){for(let C=0;C<16;C++,Y+=4)k8[C]=Q.getUint32(Y),x8[C]=Q.getUint32(Y+=4);for(let C=16;C<80;C++){const S=k8[C-15]|0,O=x8[C-15]|0,D=h.rotrSH(S,O,1)^h.rotrSH(S,O,8)^h.shrSH(S,O,7),T=h.rotrSL(S,O,1)^h.rotrSL(S,O,8)^h.shrSL(S,O,7),R=k8[C-2]|0,A=x8[C-2]|0,w=h.rotrSH(R,A,19)^h.rotrBH(R,A,61)^h.shrSH(R,A,6),N=h.rotrSL(R,A,19)^h.rotrBL(R,A,61)^h.shrSL(R,A,6),k=h.add4L(T,N,x8[C-7],x8[C-16]),v=h.add4H(k,D,w,k8[C-7],k8[C-16]);k8[C]=v|0,x8[C]=k|0}let{Ah:J,Al:X,Bh:q,Bl:G,Ch:W,Cl:U,Dh:$,Dl:V,Eh:Z,El:K,Fh:M,Fl:j,Gh:z,Gl:L,Hh:H,Hl:P}=this;for(let C=0;C<80;C++){const S=h.rotrSH(Z,K,14)^h.rotrSH(Z,K,18)^h.rotrBH(Z,K,41),O=h.rotrSL(Z,K,14)^h.rotrSL(Z,K,18)^h.rotrBL(Z,K,41),D=Z&M^~Z&z,T=K&j^~K&L,R=h.add5L(P,O,T,v1[C],x8[C]),A=h.add5H(R,H,S,D,b1[C],k8[C]),w=R|0,N=h.rotrSH(J,X,28)^h.rotrBH(J,X,34)^h.rotrBH(J,X,39),k=h.rotrSL(J,X,28)^h.rotrBL(J,X,34)^h.rotrBL(J,X,39),v=J&q^J&W^q&W,r=X&G^X&U^G&U;H=z|0,P=L|0,z=M|0,L=j|0,M=Z|0,j=K|0,{h:Z,l:K}=h.add($|0,V|0,A|0,w|0),$=W|0,V=U|0,W=q|0,U=G|0,q=J|0,G=X|0;const g=h.add3L(w,k,r);J=h.add3H(g,A,N,v),X=g|0}({h:J,l:X}=h.add(this.Ah|0,this.Al|0,J|0,X|0)),{h:q,l:G}=h.add(this.Bh|0,this.Bl|0,q|0,G|0),{h:W,l:U}=h.add(this.Ch|0,this.Cl|0,W|0,U|0),{h:$,l:V}=h.add(this.Dh|0,this.Dl|0,$|0,V|0),{h:Z,l:K}=h.add(this.Eh|0,this.El|0,Z|0,K|0),{h:M,l:j}=h.add(this.Fh|0,this.Fl|0,M|0,j|0),{h:z,l:L}=h.add(this.Gh|0,this.Gl|0,z|0,L|0),{h:H,l:P}=h.add(this.Hh|0,this.Hl|0,H|0,P|0),this.set(J,X,q,G,W,U,$,V,Z,K,M,j,z,L,H,P)}roundClean(){k8.fill(0),x8.fill(0)}destroy(){this.buffer.fill(0),this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}}var uQ=E8(()=>new EY);var g1=function(){if(typeof self!=="undefined")return self;if(typeof window!=="undefined")return window;if(typeof window!=="undefined")return window;throw new Error("unable to locate global object")};function lJ(Q){switch(Q){case"sha256":return Z8.create();case"sha512":return uQ.create()}I(!1,"invalid hashing algorithm name","algorithm",Q)}function kY(Q,Y){const J={sha256:Z8,sha512:uQ}[Q];return I(J!=null,"invalid hmac algorithm","algorithm",Q),o8.create(J,Y)}function xY(Q,Y,J,X,q){const G={sha256:Z8,sha512:uQ}[q];return I(G!=null,"invalid pbkdf2 algorithm","algorithm",q),d9(G,Q,Y,{c:J,dkLen:X})}function fY(Q){f(AY!=null,"platform does not support secure random numbers","UNSUPPORTED_OPERATION",{operation:"randomBytes"}),I(Number.isInteger(Q)&&Q>0&&Q<=1024,"invalid length","length",Q);const Y=new Uint8Array(Q);return AY.getRandomValues(Y),Y}var SY=g1(),AY=SY.crypto||SY.msCrypto;function z8(Q,Y,J){const X=E(Y,"key"),q=E(J,"data");return B(gY(Q,X,q))}var bY=!1,vY=function(Q,Y,J){return kY(Q,Y).update(J).digest()},gY=vY;z8._=vY;z8.lock=function(){bY=!0};z8.register=function(Q){if(bY)throw new Error("computeHmac is locked");gY=Q};Object.freeze(z8);function d1(Q,Y=24){const J=new Uint32Array(10);for(let X=24-Y;X<24;X++){for(let W=0;W<10;W++)J[W]=Q[W]^Q[W+10]^Q[W+20]^Q[W+30]^Q[W+40];for(let W=0;W<10;W+=2){const U=(W+8)%10,$=(W+2)%10,V=J[$],Z=J[$+1],K=yY(V,Z,1)^J[U],M=hY(V,Z,1)^J[U+1];for(let j=0;j<50;j+=10)Q[W+j]^=K,Q[W+j+1]^=M}let q=Q[2],G=Q[3];for(let W=0;W<24;W++){const U=_Y[W],$=yY(q,G,U),V=hY(q,G,U),Z=mY[W];q=Q[Z],G=Q[Z+1],Q[Z]=$,Q[Z+1]=V}for(let W=0;W<50;W+=10){for(let U=0;U<10;U++)J[U]=Q[W+U];for(let U=0;U<10;U++)Q[W+U]^=~J[(U+2)%10]&J[(U+4)%10]}Q[0]^=p1[X],Q[1]^=u1[X]}J.fill(0)}var[mY,_Y,cY]=[[],[],[]],y1=BigInt(0),l9=BigInt(1),h1=BigInt(2),m1=BigInt(7),_1=BigInt(256),c1=BigInt(113);for(let Q=0,Y=l9,J=1,X=0;Q<24;Q++){[J,X]=[X,(2*J+3*X)%5],mY.push(2*(5*X+J)),_Y.push((Q+1)*(Q+2)/2%64);let q=y1;for(let G=0;G<7;G++)if(Y=(Y<<l9^(Y>>m1)*c1)%_1,Y&h1)q^=l9<<(l9<<BigInt(G))-l9;cY.push(q)}var[p1,u1]=_J(cY,!0),yY=(Q,Y,J)=>J>32?uJ(Q,Y,J):cJ(Q,Y,J),hY=(Q,Y,J)=>J>32?dJ(Q,Y,J):pJ(Q,Y,J);class nJ extends n8{constructor(Q,Y,J,X=!1,q=24){super();if(this.blockLen=Q,this.suffix=Y,this.outputLen=J,this.enableXOF=X,this.rounds=q,this.pos=0,this.posOut=0,this.finished=!1,this.destroyed=!1,R0(J),0>=this.blockLen||this.blockLen>=200)throw new Error("Sha3 supports only keccak-f1600 function");this.state=new Uint8Array(200),this.state32=P9(this.state)}keccak(){d1(this.state32,this.rounds),this.posOut=0,this.pos=0}update(Q){$8(this);const{blockLen:Y,state:J}=this;Q=s0(Q);const X=Q.length;for(let q=0;q<X;){const G=Math.min(Y-this.pos,X-q);for(let W=0;W<G;W++)J[this.pos++]^=Q[q++];if(this.pos===Y)this.keccak()}return this}finish(){if(this.finished)return;this.finished=!0;const{state:Q,suffix:Y,pos:J,blockLen:X}=this;if(Q[J]^=Y,(Y&128)!==0&&J===X-1)this.keccak();Q[X-1]^=128,this.keccak()}writeInto(Q){$8(this,!1),u9(Q),this.finish();const Y=this.state,{blockLen:J}=this;for(let X=0,q=Q.length;X<q;){if(this.posOut>=J)this.keccak();const G=Math.min(J-this.posOut,q-X);Q.set(Y.subarray(this.posOut,this.posOut+G),X),this.posOut+=G,X+=G}return Q}xofInto(Q){if(!this.enableXOF)throw new Error("XOF is not possible for this instance");return this.writeInto(Q)}xof(Q){return R0(Q),this.xofInto(new Uint8Array(Q))}digestInto(Q){if(hQ(Q,this),this.finished)throw new Error("digest() was already called");return this.writeInto(Q),this.destroy(),Q}digest(){return this.digestInto(new Uint8Array(this.outputLen))}destroy(){this.destroyed=!0,this.state.fill(0)}_cloneInto(Q){const{blockLen:Y,suffix:J,outputLen:X,rounds:q,enableXOF:G}=this;return Q||(Q=new nJ(Y,J,X,G,q)),Q.state32.set(this.state32),Q.pos=this.pos,Q.posOut=this.posOut,Q.finished=this.finished,Q.rounds=q,Q.suffix=J,Q.outputLen=X,Q.enableXOF=G,Q.destroyed=this.destroyed,Q}}var l1=(Q,Y,J)=>E8(()=>new nJ(Y,Q,J));var pY=l1(1,136,32);function n(Q){const Y=E(Q,"data");return B(lY(Y))}var uY=!1,dY=function(Q){return pY(Q)},lY=dY;n._=dY;n.lock=function(){uY=!0};n.register=function(Q){if(uY)throw new TypeError("keccak256 is locked");lY=Q};Object.freeze(n);var nY=function(Q,Y,J,X){if(Q===0)return Y^J^X;else if(Q===1)return Y&J|~Y&X;else if(Q===2)return(Y|~J)^X;else if(Q===3)return Y&X|J&~X;else return Y^(J|~X)},n1=new Uint8Array([7,4,13,1,10,6,15,3,12,0,9,5,2,14,11,8]),oY=Uint8Array.from({length:16},(Q,Y)=>Y),o1=oY.map((Q)=>(9*Q+5)%16),oJ=[oY],iJ=[o1];for(let Q=0;Q<4;Q++)for(let Y of[oJ,iJ])Y.push(Y[Q].map((J)=>n1[J]));var iY=[[11,14,15,12,5,8,7,9,11,13,14,15,6,7,9,8],[12,13,11,15,6,9,9,7,12,15,11,13,7,8,7,7],[13,15,14,11,7,7,6,8,13,14,13,12,5,5,6,9],[14,11,12,14,8,6,5,5,15,12,15,14,9,9,8,6],[15,12,13,13,9,5,8,6,14,11,12,11,8,6,5,5]].map((Q)=>new Uint8Array(Q)),i1=oJ.map((Q,Y)=>Q.map((J)=>iY[Y][J])),r1=iJ.map((Q,Y)=>Q.map((J)=>iY[Y][J])),a1=new Uint32Array([0,1518500249,1859775393,2400959708,2840853838]),t1=new Uint32Array([1352829926,1548603684,1836072691,2053994217,0]),dQ=(Q,Y)=>Q<<Y|Q>>>32-Y,lQ=new Uint32Array(16);class rY extends i8{constructor(){super(64,20,8,!0);this.h0=1732584193|0,this.h1=4023233417|0,this.h2=2562383102|0,this.h3=271733878|0,this.h4=3285377520|0}get(){const{h0:Q,h1:Y,h2:J,h3:X,h4:q}=this;return[Q,Y,J,X,q]}set(Q,Y,J,X,q){this.h0=Q|0,this.h1=Y|0,this.h2=J|0,this.h3=X|0,this.h4=q|0}process(Q,Y){for(let M=0;M<16;M++,Y+=4)lQ[M]=Q.getUint32(Y,!0);let J=this.h0|0,X=J,q=this.h1|0,G=q,W=this.h2|0,U=W,$=this.h3|0,V=$,Z=this.h4|0,K=Z;for(let M=0;M<5;M++){const j=4-M,z=a1[M],L=t1[M],H=oJ[M],P=iJ[M],C=i1[M],S=r1[M];for(let O=0;O<16;O++){const D=dQ(J+nY(M,q,W,$)+lQ[H[O]]+z,C[O])+Z|0;J=Z,Z=$,$=dQ(W,10)|0,W=q,q=D}for(let O=0;O<16;O++){const D=dQ(X+nY(j,G,U,V)+lQ[P[O]]+L,S[O])+K|0;X=K,K=V,V=dQ(U,10)|0,U=G,G=D}}this.set(this.h1+W+V|0,this.h2+$+K|0,this.h3+Z+X|0,this.h4+J+G|0,this.h0+q+U|0)}roundClean(){lQ.fill(0)}destroy(){this.destroyed=!0,this.buffer.fill(0),this.set(0,0,0,0,0)}}var aY=E8(()=>new rY);function M8(Q){const Y=E(Q,"data");return B(eY(Y))}var tY=!1,sY=function(Q){return aY(Q)},eY=sY;M8._=sY;M8.lock=function(){tY=!0};M8.register=function(Q){if(tY)throw new TypeError("ripemd160 is locked");eY=Q};Object.freeze(M8);function A0(Q,Y,J,X,q){const G=E(Q,"password"),W=E(Y,"salt");return B(YX(G,W,J,X,q))}var QX=!1,JX=function(Q,Y,J,X,q){return xY(Q,Y,J,X,q)},YX=JX;A0._=JX;A0.lock=function(){QX=!0};A0.register=function(Q){if(QX)throw new Error("pbkdf2 is locked");YX=Q};Object.freeze(A0);function V0(Q){return GX(Q)}var XX=!1,qX=function(Q){return new Uint8Array(fY(Q))},GX=qX;V0._=qX;V0.lock=function(){XX=!0};V0.register=function(Q){if(XX)throw new Error("randomBytes is locked");GX=Q};Object.freeze(V0);var WX=function(Q,Y,J,X,q,G){let W=Q[Y++]^J[X++],U=Q[Y++]^J[X++],$=Q[Y++]^J[X++],V=Q[Y++]^J[X++],Z=Q[Y++]^J[X++],K=Q[Y++]^J[X++],M=Q[Y++]^J[X++],j=Q[Y++]^J[X++],z=Q[Y++]^J[X++],L=Q[Y++]^J[X++],H=Q[Y++]^J[X++],P=Q[Y++]^J[X++],C=Q[Y++]^J[X++],S=Q[Y++]^J[X++],O=Q[Y++]^J[X++],D=Q[Y++]^J[X++],T=W,R=U,A=$,w=V,N=Z,k=K,v=M,r=j,g=z,F=L,x=H,b=P,y=C,l=S,a=O,U0=D;for(let D0=0;D0<8;D0+=2)N^=d(T+y|0,7),g^=d(N+T|0,9),y^=d(g+N|0,13),T^=d(y+g|0,18),F^=d(k+R|0,7),l^=d(F+k|0,9),R^=d(l+F|0,13),k^=d(R+l|0,18),a^=d(x+v|0,7),A^=d(a+x|0,9),v^=d(A+a|0,13),x^=d(v+A|0,18),w^=d(U0+b|0,7),r^=d(w+U0|0,9),b^=d(r+w|0,13),U0^=d(b+r|0,18),R^=d(T+w|0,7),A^=d(R+T|0,9),w^=d(A+R|0,13),T^=d(w+A|0,18),v^=d(k+N|0,7),r^=d(v+k|0,9),N^=d(r+v|0,13),k^=d(N+r|0,18),b^=d(x+F|0,7),g^=d(b+x|0,9),F^=d(g+b|0,13),x^=d(F+g|0,18),y^=d(U0+a|0,7),l^=d(y+U0|0,9),a^=d(l+y|0,13),U0^=d(a+l|0,18);q[G++]=W+T|0,q[G++]=U+R|0,q[G++]=$+A|0,q[G++]=V+w|0,q[G++]=Z+N|0,q[G++]=K+k|0,q[G++]=M+v|0,q[G++]=j+r|0,q[G++]=z+g|0,q[G++]=L+F|0,q[G++]=H+x|0,q[G++]=P+b|0,q[G++]=C+y|0,q[G++]=S+l|0,q[G++]=O+a|0,q[G++]=D+U0|0},T9=function(Q,Y,J,X,q){let G=X+0,W=X+16*q;for(let U=0;U<16;U++)J[W+U]=Q[Y+(2*q-1)*16+U];for(let U=0;U<q;U++,G+=16,Y+=16){if(WX(J,W,Q,Y,J,G),U>0)W+=16;WX(J,G,Q,Y+=16,J,W)}},UX=function(Q,Y,J){const X=cQ({dkLen:32,asyncTick:10,maxmem:1073742848},J),{N:q,r:G,p:W,dkLen:U,asyncTick:$,maxmem:V,onProgress:Z}=X;if(R0(q),R0(G),R0(W),R0(U),R0($),R0(V),Z!==void 0&&typeof Z!=="function")throw new Error("progressCb should be function");const K=128*G,M=K/4;if(q<=1||(q&q-1)!==0||q>=2**(K/8)||q>4294967296)throw new Error("Scrypt: N must be larger than 1, a power of 2, less than 2^(128 * r / 8) and less than 2^32");if(W<0||W>137438953440/K)throw new Error("Scrypt: p must be a positive integer less than or equal to ((2^32 - 1) * 32) / (128 * r)");if(U<0||U>137438953440)throw new Error("Scrypt: dkLen should be positive integer less than or equal to (2^32 - 1) * 32");const j=K*(q+W);if(j>V)throw new Error(`Scrypt: parameters too large, ${j} (128 * r * (N + p)) > ${V} (maxmem)`);const z=d9(Z8,Q,Y,{c:1,dkLen:K*W}),L=P9(z),H=P9(new Uint8Array(K*q)),P=P9(new Uint8Array(K));let C=()=>{};if(Z){const S=2*q*W,O=Math.max(Math.floor(S/1e4),1);let D=0;C=()=>{if(D++,Z&&(!(D%O)||D===S))Z(D/S)}}return{N:q,r:G,p:W,dkLen:U,blockSize32:M,V:H,B32:L,B:z,tmp:P,blockMixCb:C,asyncTick:$}},VX=function(Q,Y,J,X,q){const G=d9(Z8,Q,J,{c:1,dkLen:Y});return J.fill(0),X.fill(0),q.fill(0),G};function $X(Q,Y,J){const{N:X,r:q,p:G,dkLen:W,blockSize32:U,V:$,B32:V,B:Z,tmp:K,blockMixCb:M}=UX(Q,Y,J);for(let j=0;j<G;j++){const z=U*j;for(let L=0;L<U;L++)$[L]=V[z+L];for(let L=0,H=0;L<X-1;L++)T9($,H,$,H+=U,q),M();T9($,(X-1)*U,V,z,q),M();for(let L=0;L<X;L++){const H=V[z+U-16]%X;for(let P=0;P<U;P++)K[P]=V[z+P]^$[H*U+P];T9(K,0,V,z,q),M()}}return VX(Q,W,Z,$,K)}async function ZX(Q,Y,J){const{N:X,r:q,p:G,dkLen:W,blockSize32:U,V:$,B32:V,B:Z,tmp:K,blockMixCb:M,asyncTick:j}=UX(Q,Y,J);for(let z=0;z<G;z++){const L=U*z;for(let P=0;P<U;P++)$[P]=V[L+P];let H=0;await _Q(X-1,j,()=>{T9($,H,$,H+=U,q),M()}),T9($,(X-1)*U,V,L,q),M(),await _Q(X,j,()=>{const P=V[L+U-16]%X;for(let C=0;C<U;C++)K[C]=V[L+C]^$[P*U+C];T9(K,0,V,L,q),M()})}return VX(Q,W,Z,$,K)}var d=(Q,Y)=>Q<<Y|Q>>>32-Y;async function K8(Q,Y,J,X,q,G,W){const U=E(Q,"passwd"),$=E(Y,"salt");return B(await OX(U,$,J,X,q,G,W))}function j8(Q,Y,J,X,q,G){const W=E(Q,"passwd"),U=E(Y,"salt");return B(IX(W,U,J,X,q,G))}var zX=!1,MX=!1,KX=async function(Q,Y,J,X,q,G,W){return await ZX(Q,Y,{N:J,r:X,p:q,dkLen:G,onProgress:W})},jX=function(Q,Y,J,X,q,G){return $X(Q,Y,{N:J,r:X,p:q,dkLen:G})},OX=KX,IX=jX;K8._=KX;K8.lock=function(){MX=!0};K8.register=function(Q){if(MX)throw new Error("scrypt is locked");OX=Q};Object.freeze(K8);j8._=jX;j8.lock=function(){zX=!0};j8.register=function(Q){if(zX)throw new Error("scryptSync is locked");IX=Q};Object.freeze(j8);function O0(Q){const Y=E(Q,"data");return B(HX(Y))}function n9(Q){const Y=E(Q,"data");return B(RX(Y))}var LX=function(Q){return lJ("sha256").update(Q).digest()},DX=function(Q){return lJ("sha512").update(Q).digest()},HX=LX,RX=DX,PX=!1,CX=!1;O0._=LX;O0.lock=function(){PX=!0};O0.register=function(Q){if(PX)throw new Error("sha256 is locked");HX=Q};Object.freeze(O0);n9._=DX;n9.lock=function(){CX=!0};n9.register=function(Q){if(CX)throw new Error("sha512 is locked");RX=Q};Object.freeze(O0);var sJ={};u7(sJ,{validateObject:()=>{{return b8}},utf8ToBytes:()=>{{return YG}},numberToVarBytesBE:()=>{{return QG}},numberToHexUnpadded:()=>{{return wX}},numberToBytesLE:()=>{{return rQ}},numberToBytesBE:()=>{{return f8}},hexToNumber:()=>{{return aJ}},hexToBytes:()=>{{return a8}},equalBytes:()=>{{return JG}},ensureBytes:()=>{{return k0}},createHmacDrbg:()=>{{return tJ}},concatBytes:()=>{{return N9}},bytesToNumberLE:()=>{{return iQ}},bytesToNumberBE:()=>{{return O8}},bytesToHex:()=>{{return r8}},bitSet:()=>{{return GG}},bitMask:()=>{{return o9}},bitLen:()=>{{return XG}},bitGet:()=>{{return qG}}});function r8(Q){if(!oQ(Q))throw new Error("Uint8Array expected");let Y="";for(let J=0;J<Q.length;J++)Y+=e1[Q[J]];return Y}function wX(Q){const Y=Q.toString(16);return Y.length&1?`0${Y}`:Y}function aJ(Q){if(typeof Q!=="string")throw new Error("hex string expected, got "+typeof Q);return BigInt(Q===""?"0":`0x${Q}`)}function a8(Q){if(typeof Q!=="string")throw new Error("hex string expected, got "+typeof Q);const Y=Q.length;if(Y%2)throw new Error("padded hex string expected, got unpadded hex of length "+Y);const J=new Uint8Array(Y/2);for(let X=0;X<J.length;X++){const q=X*2,G=Q.slice(q,q+2),W=Number.parseInt(G,16);if(Number.isNaN(W)||W<0)throw new Error("Invalid byte sequence");J[X]=W}return J}function O8(Q){return aJ(r8(Q))}function iQ(Q){if(!oQ(Q))throw new Error("Uint8Array expected");return aJ(r8(Uint8Array.from(Q).reverse()))}function f8(Q,Y){return a8(Q.toString(16).padStart(Y*2,"0"))}function rQ(Q,Y){return f8(Q,Y).reverse()}function QG(Q){return a8(wX(Q))}function k0(Q,Y,J){let X;if(typeof Y==="string")try{X=a8(Y)}catch(G){throw new Error(`${Q} must be valid hex string, got "${Y}". Cause: ${G}`)}else if(oQ(Y))X=Uint8Array.from(Y);else throw new Error(`${Q} must be hex string or Uint8Array`);const q=X.length;if(typeof J==="number"&&q!==J)throw new Error(`${Q} expected ${J} bytes, got ${q}`);return X}function N9(...Q){const Y=new Uint8Array(Q.reduce((X,q)=>X+q.length,0));let J=0;return Q.forEach((X)=>{if(!oQ(X))throw new Error("Uint8Array expected");Y.set(X,J),J+=X.length}),Y}function JG(Q,Y){if(Q.length!==Y.length)return!1;for(let J=0;J<Q.length;J++)if(Q[J]!==Y[J])return!1;return!0}function YG(Q){if(typeof Q!=="string")throw new Error(`utf8ToBytes expected string, got ${typeof Q}`);return new Uint8Array((new TextEncoder()).encode(Q))}function XG(Q){let Y;for(Y=0;Q>NX;Q>>=nQ,Y+=1);return Y}function qG(Q,Y){return Q>>BigInt(Y)&nQ}function tJ(Q,Y,J){if(typeof Q!=="number"||Q<2)throw new Error("hashLen must be a number");if(typeof Y!=="number"||Y<2)throw new Error("qByteLen must be a number");if(typeof J!=="function")throw new Error("hmacFn must be a function");let X=rJ(Q),q=rJ(Q),G=0;const W=()=>{X.fill(1),q.fill(0),G=0},U=(...K)=>J(q,X,...K),$=(K=rJ())=>{if(q=U(TX([0]),K),X=U(),K.length===0)return;q=U(TX([1]),K),X=U()},V=()=>{if(G++>=1000)throw new Error("drbg: tried 1000 values");let K=0;const M=[];while(K<Y){X=U();const j=X.slice();M.push(j),K+=X.length}return N9(...M)};return(K,M)=>{W(),$(K);let j=void 0;while(!(j=M(V())))$();return W(),j}}function b8(Q,Y,J={}){const X=(q,G,W)=>{const U=WG[G];if(typeof U!=="function")throw new Error(`Invalid validator "${G}", expected function`);const $=Q[q];if(W&&$===void 0)return;if(!U($,Q))throw new Error(`Invalid param ${String(q)}=${$} (${typeof $}), expected ${G}`)};for(let[q,G]of Object.entries(Y))X(q,G,!1);for(let[q,G]of Object.entries(J))X(q,G,!0);return Q}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */var NX=BigInt(0),nQ=BigInt(1),s1=BigInt(2),oQ=(Q)=>Q instanceof Uint8Array,e1=Array.from({length:256},(Q,Y)=>Y.toString(16).padStart(2,"0")),GG=(Q,Y,J)=>{return Q|(J?nQ:NX)<<BigInt(Y)},o9=(Q)=>(s1<<BigInt(Q-1))-nQ,rJ=(Q)=>new Uint8Array(Q),TX=(Q)=>Uint8Array.from(Q),WG={bigint:(Q)=>typeof Q==="bigint",function:(Q)=>typeof Q==="function",boolean:(Q)=>typeof Q==="boolean",string:(Q)=>typeof Q==="string",stringOrUint8Array:(Q)=>typeof Q==="string"||Q instanceof Uint8Array,isSafeInteger:(Q)=>Number.isSafeInteger(Q),array:(Q)=>Array.isArray(Q),field:(Q,Y)=>Y.Fp.isValid(Q),hash:(Q)=>typeof Q==="function"&&Number.isSafeInteger(Q.outputLen)};function P0(Q,Y){const J=Q%Y;return J>=$0?J:Y+J}function ZG(Q,Y,J){if(J<=$0||Y<$0)throw new Error("Expected power/modulo > 0");if(J===G0)return $0;let X=G0;while(Y>$0){if(Y&G0)X=X*Q%J;Q=Q*Q%J,Y>>=G0}return X}function x0(Q,Y,J){let X=Q;while(Y-- >$0)X*=X,X%=J;return X}function aQ(Q,Y){if(Q===$0||Y<=$0)throw new Error(`invert: expected positive integers, got n=${Q} mod=${Y}`);let J=P0(Q,Y),X=Y,q=$0,G=G0,W=G0,U=$0;while(J!==$0){const V=X/J,Z=X%J,K=q-W*V,M=G-U*V;X=J,J=Z,q=W,G=U,W=K,U=M}if(X!==G0)throw new Error("invert: does not exist");return P0(q,Y)}function zG(Q){const Y=(Q-G0)/t8;let J,X,q;for(J=Q-G0,X=0;J%t8===$0;J/=t8,X++);for(q=t8;q<Q&&ZG(q,Y,Q)!==Q-G0;q++);if(X===1){const W=(Q+G0)/eJ;return function U($,V){const Z=$.pow(V,W);if(!$.eql($.sqr(Z),V))throw new Error("Cannot find square root");return Z}}const G=(J+G0)/t8;return function W(U,$){if(U.pow($,Y)===U.neg(U.ONE))throw new Error("Cannot find square root");let V=X,Z=U.pow(U.mul(U.ONE,q),J),K=U.pow($,G),M=U.pow($,J);while(!U.eql(M,U.ONE)){if(U.eql(M,U.ZERO))return U.ZERO;let j=1;for(let L=U.sqr(M);j<V;j++){if(U.eql(L,U.ONE))break;L=U.sqr(L)}const z=U.pow(Z,G0<<BigInt(V-j-1));Z=U.sqr(z),K=U.mul(K,z),M=U.mul(M,Z),V=j}return K}}function MG(Q){if(Q%eJ===UG){const Y=(Q+G0)/eJ;return function J(X,q){const G=X.pow(q,Y);if(!X.eql(X.sqr(G),q))throw new Error("Cannot find square root");return G}}if(Q%BX===FX){const Y=(Q-FX)/BX;return function J(X,q){const G=X.mul(q,t8),W=X.pow(G,Y),U=X.mul(q,W),$=X.mul(X.mul(U,t8),W),V=X.mul(U,X.sub($,X.ONE));if(!X.eql(X.sqr(V),q))throw new Error("Cannot find square root");return V}}if(Q%$G===VG);return zG(Q)}function Q5(Q){const Y={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},J=KG.reduce((X,q)=>{return X[q]="function",X},Y);return b8(Q,J)}function jG(Q,Y,J){if(J<$0)throw new Error("Expected power > 0");if(J===$0)return Q.ONE;if(J===G0)return Y;let X=Q.ONE,q=Y;while(J>$0){if(J&G0)X=Q.mul(X,q);q=Q.sqr(q),J>>=G0}return X}function OG(Q,Y){const J=new Array(Y.length),X=Y.reduce((G,W,U)=>{if(Q.is0(W))return G;return J[U]=G,Q.mul(G,W)},Q.ONE),q=Q.inv(X);return Y.reduceRight((G,W,U)=>{if(Q.is0(W))return G;return J[U]=Q.mul(G,J[U]),Q.mul(G,W)},q),J}function J5(Q,Y){const J=Y!==void 0?Y:Q.toString(2).length,X=Math.ceil(J/8);return{nBitLength:J,nByteLength:X}}function EX(Q,Y,J=!1,X={}){if(Q<=$0)throw new Error(`Expected Field ORDER > 0, got ${Q}`);const{nBitLength:q,nByteLength:G}=J5(Q,Y);if(G>2048)throw new Error("Field lengths over 2048 bytes are not supported");const W=MG(Q),U=Object.freeze({ORDER:Q,BITS:q,BYTES:G,MASK:o9(q),ZERO:$0,ONE:G0,create:($)=>P0($,Q),isValid:($)=>{if(typeof $!=="bigint")throw new Error(`Invalid field element: expected bigint, got ${typeof $}`);return $0<=$&&$<Q},is0:($)=>$===$0,isOdd:($)=>($&G0)===G0,neg:($)=>P0(-$,Q),eql:($,V)=>$===V,sqr:($)=>P0($*$,Q),add:($,V)=>P0($+V,Q),sub:($,V)=>P0($-V,Q),mul:($,V)=>P0($*V,Q),pow:($,V)=>jG(U,$,V),div:($,V)=>P0($*aQ(V,Q),Q),sqrN:($)=>$*$,addN:($,V)=>$+V,subN:($,V)=>$-V,mulN:($,V)=>$*V,inv:($)=>aQ($,Q),sqrt:X.sqrt||(($)=>W(U,$)),invertBatch:($)=>OG(U,$),cmov:($,V,Z)=>Z?V:$,toBytes:($)=>J?rQ($,G):f8($,G),fromBytes:($)=>{if($.length!==G)throw new Error(`Fp.fromBytes: expected ${G}, got ${$.length}`);return J?iQ($):O8($)}});return Object.freeze(U)}function SX(Q){if(typeof Q!=="bigint")throw new Error("field order must be bigint");const Y=Q.toString(2).length;return Math.ceil(Y/8)}function Y5(Q){const Y=SX(Q);return Y+Math.ceil(Y/2)}function AX(Q,Y,J=!1){const X=Q.length,q=SX(Y),G=Y5(Y);if(X<16||X<G||X>1024)throw new Error(`expected ${G}-1024 bytes of input, got ${X}`);const W=J?O8(Q):iQ(Q),U=P0(W,Y-G0)+G0;return J?rQ(U,q):f8(U,q)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */var $0=BigInt(0),G0=BigInt(1),t8=BigInt(2),UG=BigInt(3),eJ=BigInt(4),FX=BigInt(5),BX=BigInt(8),VG=BigInt(9),$G=BigInt(16);var KG=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function kX(Q,Y){const J=(q,G)=>{const W=G.negate();return q?W:G},X=(q)=>{const G=Math.ceil(Y/q)+1,W=2**(q-1);return{windows:G,windowSize:W}};return{constTimeNegate:J,unsafeLadder(q,G){let W=Q.ZERO,U=q;while(G>LG){if(G&X5)W=W.add(U);U=U.double(),G>>=X5}return W},precomputeWindow(q,G){const{windows:W,windowSize:U}=X(G),$=[];let V=q,Z=V;for(let K=0;K<W;K++){Z=V,$.push(Z);for(let M=1;M<U;M++)Z=Z.add(V),$.push(Z);V=Z.double()}return $},wNAF(q,G,W){const{windows:U,windowSize:$}=X(q);let{ZERO:V,BASE:Z}=Q;const K=BigInt(2**q-1),M=2**q,j=BigInt(q);for(let z=0;z<U;z++){const L=z*$;let H=Number(W&K);if(W>>=j,H>$)H-=M,W+=X5;const P=L,C=L+Math.abs(H)-1,S=z%2!==0,O=H<0;if(H===0)Z=Z.add(J(S,G[P]));else V=V.add(J(O,G[C]))}return{p:V,f:Z}},wNAFCached(q,G,W,U){const $=q._WINDOW_SIZE||1;let V=G.get(q);if(!V){if(V=this.precomputeWindow(q,$),$!==1)G.set(q,U(V))}return this.wNAF($,V,W)}}}function q5(Q){return Q5(Q.Fp),b8(Q,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...J5(Q.n,Q.nBitLength),...Q,...{p:Q.Fp.ORDER}})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */var LG=BigInt(0),X5=BigInt(1);var DG=function(Q){const Y=q5(Q);b8(Y,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});const{endo:J,Fp:X,a:q}=Y;if(J){if(!X.eql(q,X.ZERO))throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");if(typeof J!=="object"||typeof J.beta!=="bigint"||typeof J.splitScalar!=="function")throw new Error("Expected endomorphism with beta: bigint and splitScalar: function")}return Object.freeze({...Y})};function PG(Q){const Y=DG(Q),{Fp:J}=Y,X=Y.toBytes||((z,L,H)=>{const P=L.toAffine();return N9(Uint8Array.from([4]),J.toBytes(P.x),J.toBytes(P.y))}),q=Y.fromBytes||((z)=>{const L=z.subarray(1),H=J.fromBytes(L.subarray(0,J.BYTES)),P=J.fromBytes(L.subarray(J.BYTES,2*J.BYTES));return{x:H,y:P}});function G(z){const{a:L,b:H}=Y,P=J.sqr(z),C=J.mul(P,z);return J.add(J.add(C,J.mul(z,L)),H)}if(!J.eql(J.sqr(Y.Gy),G(Y.Gx)))throw new Error("bad generator point: equation left != right");function W(z){return typeof z==="bigint"&&I8<z&&z<Y.n}function U(z){if(!W(z))throw new Error("Expected valid bigint: 0 < bigint < curve.n")}function $(z){const{allowedPrivateKeyLengths:L,nByteLength:H,wrapPrivateKey:P,n:C}=Y;if(L&&typeof z!=="bigint"){if(z instanceof Uint8Array)z=r8(z);if(typeof z!=="string"||!L.includes(z.length))throw new Error("Invalid key");z=z.padStart(H*2,"0")}let S;try{S=typeof z==="bigint"?z:O8(k0("private key",z,H))}catch(O){throw new Error(`private key must be ${H} bytes, hex or bigint, not ${typeof z}`)}if(P)S=P0(S,C);return U(S),S}const V=new Map;function Z(z){if(!(z instanceof K))throw new Error("ProjectivePoint expected")}class K{constructor(z,L,H){if(this.px=z,this.py=L,this.pz=H,z==null||!J.isValid(z))throw new Error("x required");if(L==null||!J.isValid(L))throw new Error("y required");if(H==null||!J.isValid(H))throw new Error("z required")}static fromAffine(z){const{x:L,y:H}=z||{};if(!z||!J.isValid(L)||!J.isValid(H))throw new Error("invalid affine point");if(z instanceof K)throw new Error("projective point not allowed");const P=(C)=>J.eql(C,J.ZERO);if(P(L)&&P(H))return K.ZERO;return new K(L,H,J.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(z){const L=J.invertBatch(z.map((H)=>H.pz));return z.map((H,P)=>H.toAffine(L[P])).map(K.fromAffine)}static fromHex(z){const L=K.fromAffine(q(k0("pointHex",z)));return L.assertValidity(),L}static fromPrivateKey(z){return K.BASE.multiply($(z))}_setWindowSize(z){this._WINDOW_SIZE=z,V.delete(this)}assertValidity(){if(this.is0()){if(Y.allowInfinityPoint&&!J.is0(this.py))return;throw new Error("bad point: ZERO")}const{x:z,y:L}=this.toAffine();if(!J.isValid(z)||!J.isValid(L))throw new Error("bad point: x or y not FE");const H=J.sqr(L),P=G(z);if(!J.eql(H,P))throw new Error("bad point: equation left != right");if(!this.isTorsionFree())throw new Error("bad point: not in prime-order subgroup")}hasEvenY(){const{y:z}=this.toAffine();if(J.isOdd)return!J.isOdd(z);throw new Error("Field doesn't support isOdd")}equals(z){Z(z);const{px:L,py:H,pz:P}=this,{px:C,py:S,pz:O}=z,D=J.eql(J.mul(L,O),J.mul(C,P)),T=J.eql(J.mul(H,O),J.mul(S,P));return D&&T}negate(){return new K(this.px,J.neg(this.py),this.pz)}double(){const{a:z,b:L}=Y,H=J.mul(L,xX),{px:P,py:C,pz:S}=this;let{ZERO:O,ZERO:D,ZERO:T}=J,R=J.mul(P,P),A=J.mul(C,C),w=J.mul(S,S),N=J.mul(P,C);return N=J.add(N,N),T=J.mul(P,S),T=J.add(T,T),O=J.mul(z,T),D=J.mul(H,w),D=J.add(O,D),O=J.sub(A,D),D=J.add(A,D),D=J.mul(O,D),O=J.mul(N,O),T=J.mul(H,T),w=J.mul(z,w),N=J.sub(R,w),N=J.mul(z,N),N=J.add(N,T),T=J.add(R,R),R=J.add(T,R),R=J.add(R,w),R=J.mul(R,N),D=J.add(D,R),w=J.mul(C,S),w=J.add(w,w),R=J.mul(w,N),O=J.sub(O,R),T=J.mul(w,A),T=J.add(T,T),T=J.add(T,T),new K(O,D,T)}add(z){Z(z);const{px:L,py:H,pz:P}=this,{px:C,py:S,pz:O}=z;let{ZERO:D,ZERO:T,ZERO:R}=J;const A=Y.a,w=J.mul(Y.b,xX);let N=J.mul(L,C),k=J.mul(H,S),v=J.mul(P,O),r=J.add(L,H),g=J.add(C,S);r=J.mul(r,g),g=J.add(N,k),r=J.sub(r,g),g=J.add(L,P);let F=J.add(C,O);return g=J.mul(g,F),F=J.add(N,v),g=J.sub(g,F),F=J.add(H,P),D=J.add(S,O),F=J.mul(F,D),D=J.add(k,v),F=J.sub(F,D),R=J.mul(A,g),D=J.mul(w,v),R=J.add(D,R),D=J.sub(k,R),R=J.add(k,R),T=J.mul(D,R),k=J.add(N,N),k=J.add(k,N),v=J.mul(A,v),g=J.mul(w,g),k=J.add(k,v),v=J.sub(N,v),v=J.mul(A,v),g=J.add(g,v),N=J.mul(k,g),T=J.add(T,N),N=J.mul(F,g),D=J.mul(r,D),D=J.sub(D,N),N=J.mul(r,k),R=J.mul(F,R),R=J.add(R,N),new K(D,T,R)}subtract(z){return this.add(z.negate())}is0(){return this.equals(K.ZERO)}wNAF(z){return j.wNAFCached(this,V,z,(L)=>{const H=J.invertBatch(L.map((P)=>P.pz));return L.map((P,C)=>P.toAffine(H[C])).map(K.fromAffine)})}multiplyUnsafe(z){const L=K.ZERO;if(z===I8)return L;if(U(z),z===g0)return this;const{endo:H}=Y;if(!H)return j.unsafeLadder(this,z);let{k1neg:P,k1:C,k2neg:S,k2:O}=H.splitScalar(z),D=L,T=L,R=this;while(C>I8||O>I8){if(C&g0)D=D.add(R);if(O&g0)T=T.add(R);R=R.double(),C>>=g0,O>>=g0}if(P)D=D.negate();if(S)T=T.negate();return T=new K(J.mul(T.px,H.beta),T.py,T.pz),D.add(T)}multiply(z){U(z);let L=z,H,P;const{endo:C}=Y;if(C){const{k1neg:S,k1:O,k2neg:D,k2:T}=C.splitScalar(L);let{p:R,f:A}=this.wNAF(O),{p:w,f:N}=this.wNAF(T);R=j.constTimeNegate(S,R),w=j.constTimeNegate(D,w),w=new K(J.mul(w.px,C.beta),w.py,w.pz),H=R.add(w),P=A.add(N)}else{const{p:S,f:O}=this.wNAF(L);H=S,P=O}return K.normalizeZ([H,P])[0]}multiplyAndAddUnsafe(z,L,H){const P=K.BASE,C=(O,D)=>D===I8||D===g0||!O.equals(P)?O.multiplyUnsafe(D):O.multiply(D),S=C(this,L).add(C(z,H));return S.is0()?void 0:S}toAffine(z){const{px:L,py:H,pz:P}=this,C=this.is0();if(z==null)z=C?J.ONE:J.inv(P);const S=J.mul(L,z),O=J.mul(H,z),D=J.mul(P,z);if(C)return{x:J.ZERO,y:J.ZERO};if(!J.eql(D,J.ONE))throw new Error("invZ was invalid");return{x:S,y:O}}isTorsionFree(){const{h:z,isTorsionFree:L}=Y;if(z===g0)return!0;if(L)return L(K,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:z,clearCofactor:L}=Y;if(z===g0)return this;if(L)return L(K,this);return this.multiplyUnsafe(Y.h)}toRawBytes(z=!0){return this.assertValidity(),X(K,this,z)}toHex(z=!0){return r8(this.toRawBytes(z))}}K.BASE=new K(Y.Gx,Y.Gy,J.ONE),K.ZERO=new K(J.ZERO,J.ONE,J.ZERO);const M=Y.nBitLength,j=kX(K,Y.endo?Math.ceil(M/2):M);return{CURVE:Y,ProjectivePoint:K,normPrivateKeyToScalar:$,weierstrassEquation:G,isWithinCurveOrder:W}}var CG=function(Q){const Y=q5(Q);return b8(Y,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...Y})};function fX(Q){const Y=CG(Q),{Fp:J,n:X}=Y,q=J.BYTES+1,G=2*J.BYTES+1;function W(F){return I8<F&&F<J.ORDER}function U(F){return P0(F,X)}function $(F){return aQ(F,X)}const{ProjectivePoint:V,normPrivateKeyToScalar:Z,weierstrassEquation:K,isWithinCurveOrder:M}=PG({...Y,toBytes(F,x,b){const y=x.toAffine(),l=J.toBytes(y.x),a=N9;if(b)return a(Uint8Array.from([x.hasEvenY()?2:3]),l);else return a(Uint8Array.from([4]),l,J.toBytes(y.y))},fromBytes(F){const x=F.length,b=F[0],y=F.subarray(1);if(x===q&&(b===2||b===3)){const l=O8(y);if(!W(l))throw new Error("Point is not on curve");const a=K(l);let U0=J.sqrt(a);const D0=(U0&g0)===g0;if((b&1)===1!==D0)U0=J.neg(U0);return{x:l,y:U0}}else if(x===G&&b===4){const l=J.fromBytes(y.subarray(0,J.BYTES)),a=J.fromBytes(y.subarray(J.BYTES,2*J.BYTES));return{x:l,y:a}}else throw new Error(`Point of length ${x} was invalid. Expected ${q} compressed bytes or ${G} uncompressed bytes`)}}),j=(F)=>r8(f8(F,Y.nByteLength));function z(F){const x=X>>g0;return F>x}function L(F){return z(F)?U(-F):F}const H=(F,x,b)=>O8(F.slice(x,b));class P{constructor(F,x,b){this.r=F,this.s=x,this.recovery=b,this.assertValidity()}static fromCompact(F){const x=Y.nByteLength;return F=k0("compactSignature",F,x*2),new P(H(F,0,x),H(F,x,2*x))}static fromDER(F){const{r:x,s:b}=s8.toSig(k0("DER",F));return new P(x,b)}assertValidity(){if(!M(this.r))throw new Error("r must be 0 < r < CURVE.n");if(!M(this.s))throw new Error("s must be 0 < s < CURVE.n")}addRecoveryBit(F){return new P(this.r,this.s,F)}recoverPublicKey(F){const{r:x,s:b,recovery:y}=this,l=R(k0("msgHash",F));if(y==null||![0,1,2,3].includes(y))throw new Error("recovery id invalid");const a=y===2||y===3?x+Y.n:x;if(a>=J.ORDER)throw new Error("recovery id 2 or 3 invalid");const U0=(y&1)===0?"02":"03",D0=V.fromHex(U0+j(a)),W8=$(a),p8=U(-l*W8),K9=U(b*W8),u8=V.BASE.multiplyAndAddUnsafe(D0,p8,K9);if(!u8)throw new Error("point at infinify");return u8.assertValidity(),u8}hasHighS(){return z(this.s)}normalizeS(){return this.hasHighS()?new P(this.r,U(-this.s),this.recovery):this}toDERRawBytes(){return a8(this.toDERHex())}toDERHex(){return s8.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return a8(this.toCompactHex())}toCompactHex(){return j(this.r)+j(this.s)}}const C={isValidPrivateKey(F){try{return Z(F),!0}catch(x){return!1}},normPrivateKeyToScalar:Z,randomPrivateKey:()=>{const F=Y5(Y.n);return AX(Y.randomBytes(F),Y.n)},precompute(F=8,x=V.BASE){return x._setWindowSize(F),x.multiply(BigInt(3)),x}};function S(F,x=!0){return V.fromPrivateKey(F).toRawBytes(x)}function O(F){const x=F instanceof Uint8Array,b=typeof F==="string",y=(x||b)&&F.length;if(x)return y===q||y===G;if(b)return y===2*q||y===2*G;if(F instanceof V)return!0;return!1}function D(F,x,b=!0){if(O(F))throw new Error("first arg must be private key");if(!O(x))throw new Error("second arg must be public key");return V.fromHex(x).multiply(Z(F)).toRawBytes(b)}const T=Y.bits2int||function(F){const x=O8(F),b=F.length*8-Y.nBitLength;return b>0?x>>BigInt(b):x},R=Y.bits2int_modN||function(F){return U(T(F))},A=o9(Y.nBitLength);function w(F){if(typeof F!=="bigint")throw new Error("bigint expected");if(!(I8<=F&&F<A))throw new Error(`bigint expected < 2^${Y.nBitLength}`);return f8(F,Y.nByteLength)}function N(F,x,b=k){if(["recovered","canonical"].some((d8)=>(d8 in b)))throw new Error("sign() legacy options not supported");const{hash:y,randomBytes:l}=Y;let{lowS:a,prehash:U0,extraEntropy:D0}=b;if(a==null)a=!0;if(F=k0("msgHash",F),U0)F=k0("prehashed msgHash",y(F));const W8=R(F),p8=Z(x),K9=[w(p8),w(W8)];if(D0!=null){const d8=D0===!0?l(J.BYTES):D0;K9.push(k0("extraEntropy",d8))}const u8=N9(...K9),NQ=W8;function bJ(d8){const j9=T(d8);if(!M(j9))return;const ZY=$(j9),r0=V.BASE.multiply(j9).toAffine(),O9=U(r0.x);if(O9===I8)return;const wQ=U(ZY*U(NQ+O9*p8));if(wQ===I8)return;let zY=(r0.x===O9?0:2)|Number(r0.y&g0),MY=wQ;if(a&&z(wQ))MY=L(wQ),zY^=1;return new P(O9,MY,zY)}return{seed:u8,k2sig:bJ}}const k={lowS:Y.lowS,prehash:!1},v={lowS:Y.lowS,prehash:!1};function r(F,x,b=k){const{seed:y,k2sig:l}=N(F,x,b),a=Y;return tJ(a.hash.outputLen,a.nByteLength,a.hmac)(y,l)}V.BASE._setWindowSize(8);function g(F,x,b,y=v){const l=F;if(x=k0("msgHash",x),b=k0("publicKey",b),("strict"in y))throw new Error("options.strict was renamed to lowS");const{lowS:a,prehash:U0}=y;let D0=void 0,W8;try{if(typeof l==="string"||l instanceof Uint8Array)try{D0=P.fromDER(l)}catch(r0){if(!(r0 instanceof s8.Err))throw r0;D0=P.fromCompact(l)}else if(typeof l==="object"&&typeof l.r==="bigint"&&typeof l.s==="bigint"){const{r:r0,s:O9}=l;D0=new P(r0,O9)}else throw new Error("PARSE");W8=V.fromHex(b)}catch(r0){if(r0.message==="PARSE")throw new Error("signature must be Signature instance, Uint8Array or hex string");return!1}if(a&&D0.hasHighS())return!1;if(U0)x=Y.hash(x);const{r:p8,s:K9}=D0,u8=R(x),NQ=$(K9),bJ=U(u8*NQ),d8=U(p8*NQ),j9=V.BASE.multiplyAndAddUnsafe(W8,bJ,d8)?.toAffine();if(!j9)return!1;return U(j9.x)===p8}return{CURVE:Y,getPublicKey:S,getSharedSecret:D,sign:r,verify:g,ProjectivePoint:V,Signature:P,utils:C}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */var{bytesToNumberBE:HG,hexToBytes:RG}=sJ,s8={Err:class Q extends Error{constructor(Y=""){super(Y)}},_parseInt(Q){const{Err:Y}=s8;if(Q.length<2||Q[0]!==2)throw new Y("Invalid signature integer tag");const J=Q[1],X=Q.subarray(2,J+2);if(!J||X.length!==J)throw new Y("Invalid signature integer: wrong length");if(X[0]&128)throw new Y("Invalid signature integer: negative");if(X[0]===0&&!(X[1]&128))throw new Y("Invalid signature integer: unnecessary leading zero");return{d:HG(X),l:Q.subarray(J+2)}},toSig(Q){const{Err:Y}=s8,J=typeof Q==="string"?RG(Q):Q;if(!(J instanceof Uint8Array))throw new Error("ui8a expected");let X=J.length;if(X<2||J[0]!=48)throw new Y("Invalid signature tag");if(J[1]!==X-2)throw new Y("Invalid signature: incorrect length");const{d:q,l:G}=s8._parseInt(J.subarray(2)),{d:W,l:U}=s8._parseInt(G);if(U.length)throw new Y("Invalid signature: left bytes after parsing");return{r:q,s:W}},hexFromSig(Q){const Y=(V)=>Number.parseInt(V[0],16)&8?"00"+V:V,J=(V)=>{const Z=V.toString(16);return Z.length&1?`0${Z}`:Z},X=Y(J(Q.s)),q=Y(J(Q.r)),G=X.length/2,W=q.length/2,U=J(G),$=J(W);return`30${J(W+G+4)}02${$}${q}02${U}${X}`}},I8=BigInt(0),g0=BigInt(1),S$=BigInt(2),xX=BigInt(3),A$=BigInt(4);function TG(Q){return{hash:Q,hmac:(Y,...J)=>o8(Q,Y,NY(...J)),randomBytes:wY}}function bX(Q,Y){const J=(X)=>fX({...Q,...TG(X)});return Object.freeze({...J(Y),create:J})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */var wG=function(Q){const Y=yX,J=BigInt(3),X=BigInt(6),q=BigInt(11),G=BigInt(22),W=BigInt(23),U=BigInt(44),$=BigInt(88),V=Q*Q*Q%Y,Z=V*V*Q%Y,K=x0(Z,J,Y)*Z%Y,M=x0(K,J,Y)*Z%Y,j=x0(M,G5,Y)*V%Y,z=x0(j,q,Y)*j%Y,L=x0(z,G,Y)*z%Y,H=x0(L,U,Y)*L%Y,P=x0(H,$,Y)*H%Y,C=x0(P,U,Y)*L%Y,S=x0(C,J,Y)*Z%Y,O=x0(S,W,Y)*z%Y,D=x0(O,X,Y)*V%Y,T=x0(D,G5,Y);if(!W5.eql(W5.sqr(T),Q))throw new Error("Cannot find square root");return T};/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */var yX=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),vX=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),NG=BigInt(1),G5=BigInt(2),gX=(Q,Y)=>(Q+Y/G5)/Y,W5=EX(yX,void 0,void 0,{sqrt:wG}),L8=bX({a:BigInt(0),b:BigInt(7),Fp:W5,n:vX,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:(Q)=>{const Y=vX,J=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),X=-NG*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),q=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),G=J,W=BigInt("0x100000000000000000000000000000000"),U=gX(G*Q,Y),$=gX(-X*Q,Y);let V=P0(Q-U*J-$*q,Y),Z=P0(-U*X-$*G,Y);const K=V>W,M=Z>W;if(K)V=Y-V;if(M)Z=Y-Z;if(V>W||Z>W)throw new Error("splitScalar: Endomorphism failed, k="+Q);return{k1neg:K,k1:V,k2neg:M,k2:Z}}}},Z8),m$=BigInt(0);var _$=L8.ProjectivePoint;var U5="0x0000000000000000000000000000000000000000";var tQ="0x0000000000000000000000000000000000000000000000000000000000000000";var V5=`\x19Ethereum Signed Message:
`;var uX=function(Q){return S0(e(Q),32)},hX=BigInt(0),mX=BigInt(1),_X=BigInt(2),cX=BigInt(27),pX=BigInt(28),sQ=BigInt(35),w9={};class Q0{#Q;#J;#Y;#X;get r(){return this.#Q}set r(Q){I(V8(Q)===32,"invalid r","value",Q),this.#Q=B(Q)}get s(){return I(parseInt(this.#J.substring(0,3))<8,"non-canonical s; use ._s","s",this.#J),this.#J}set s(Q){I(V8(Q)===32,"invalid s","value",Q),this.#J=B(Q)}get _s(){return this.#J}isValid(){return parseInt(this.#J.substring(0,3))<8}get v(){return this.#Y}set v(Q){const Y=Z0(Q,"value");I(Y===27||Y===28,"invalid v","v",Q),this.#Y=Y}get networkV(){return this.#X}get legacyChainId(){const Q=this.networkV;if(Q==null)return null;return Q0.getChainId(Q)}get yParity(){return this.v===27?0:1}get yParityAndS(){const Q=E(this.s);if(this.yParity)Q[0]|=128;return B(Q)}get compactSerialized(){return i([this.r,this.yParityAndS])}get serialized(){return i([this.r,this.s,this.yParity?"0x1c":"0x1b"])}constructor(Q,Y,J,X){U8(Q,w9,"Signature"),this.#Q=Y,this.#J=J,this.#Y=X,this.#X=null}[Symbol.for("nodejs.util.inspect.custom")](){return`Signature { r: "${this.r}", s: "${this._s}"${this.isValid()?"":', valid: "false"'}, yParity: ${this.yParity}, networkV: ${this.networkV} }`}clone(){const Q=new Q0(w9,this.r,this._s,this.v);if(this.networkV)Q.#X=this.networkV;return Q}toJSON(){const Q=this.networkV;return{_type:"signature",networkV:Q!=null?Q.toString():null,r:this.r,s:this._s,v:this.v}}static getChainId(Q){const Y=c(Q,"v");if(Y==cX||Y==pX)return hX;return I(Y>=sQ,"invalid EIP-155 v","v",Q),(Y-sQ)/_X}static getChainIdV(Q,Y){return c(Q)*_X+BigInt(35+Y-27)}static getNormalizedV(Q){const Y=c(Q);if(Y===hX||Y===cX)return 27;if(Y===mX||Y===pX)return 28;return I(Y>=sQ,"invalid v","v",Q),Y&mX?27:28}static from(Q){function Y($,V){I($,V,"signature",Q)}if(Q==null)return new Q0(w9,tQ,tQ,27);if(typeof Q==="string"){const $=E(Q,"signature");if($.length===64){const V=B($.slice(0,32)),Z=$.slice(32,64),K=Z[0]&128?28:27;return Z[0]&=127,new Q0(w9,V,B(Z),K)}if($.length===65){const V=B($.slice(0,32)),Z=B($.slice(32,64)),K=Q0.getNormalizedV($[64]);return new Q0(w9,V,Z,K)}Y(!1,"invalid raw signature length")}if(Q instanceof Q0)return Q.clone();const J=Q.r;Y(J!=null,"missing r");const X=uX(J),q=function($,V){if($!=null)return uX($);if(V!=null){Y(H0(V,32),"invalid yParityAndS");const Z=E(V);return Z[0]&=127,B(Z)}Y(!1,"missing s")}(Q.s,Q.yParityAndS),{networkV:G,v:W}=function($,V,Z){if($!=null){const K=c($);return{networkV:K>=sQ?K:void 0,v:Q0.getNormalizedV(K)}}if(V!=null)return Y(H0(V,32),"invalid yParityAndS"),{v:E(V)[0]&128?28:27};if(Z!=null){switch(Z0(Z,"sig.yParity")){case 0:return{v:27};case 1:return{v:28}}Y(!1,"invalid yParity")}Y(!1,"missing v")}(Q.v,Q.yParityAndS,Q.yParity),U=new Q0(w9,X,q,W);if(G)U.#X=G;return Y(Q.yParity==null||Z0(Q.yParity,"sig.yParity")===U.yParity,"yParity mismatch"),Y(Q.yParityAndS==null||Q.yParityAndS===U.yParityAndS,"yParityAndS mismatch"),U}}class W0{#Q;constructor(Q){I(V8(Q)===32,"invalid private key","privateKey","[REDACTED]"),this.#Q=B(Q)}get privateKey(){return this.#Q}get publicKey(){return W0.computePublicKey(this.#Q)}get compressedPublicKey(){return W0.computePublicKey(this.#Q,!0)}sign(Q){I(V8(Q)===32,"invalid digest length","digest",Q);const Y=L8.sign(l0(Q),l0(this.#Q),{lowS:!0});return Q0.from({r:n0(Y.r,32),s:n0(Y.s,32),v:Y.recovery?28:27})}computeSharedSecret(Q){const Y=W0.computePublicKey(Q);return B(L8.getSharedSecret(l0(this.#Q),E(Y),!1))}static computePublicKey(Q,Y){let J=E(Q,"key");if(J.length===32){const q=L8.getPublicKey(J,!!Y);return B(q)}if(J.length===64){const q=new Uint8Array(65);q[0]=4,q.set(J,1),J=q}const X=L8.ProjectivePoint.fromHex(J);return B(X.toRawBytes(Y))}static recoverPublicKey(Q,Y){I(V8(Q)===32,"invalid digest length","digest",Q);const J=Q0.from(Y);let X=L8.Signature.fromCompact(l0(i([J.r,J.s])));X=X.addRecoveryBit(J.yParity);const q=X.recoverPublicKey(l0(Q));return I(q!=null,"invalid signature for digest","signature",Y),"0x"+q.toHex(!1)}static addPoints(Q,Y,J){const X=L8.ProjectivePoint.fromHex(W0.computePublicKey(Q).substring(2)),q=L8.ProjectivePoint.fromHex(W0.computePublicKey(Y).substring(2));return"0x"+X.add(q).toHex(!!J)}}var dX=function(Q){Q=Q.toLowerCase();const Y=Q.substring(2).split(""),J=new Uint8Array(40);for(let q=0;q<40;q++)J[q]=Y[q].charCodeAt(0);const X=E(n(J));for(let q=0;q<40;q+=2){if(X[q>>1]>>4>=8)Y[q]=Y[q].toUpperCase();if((X[q>>1]&15)>=8)Y[q+1]=Y[q+1].toUpperCase()}return"0x"+Y.join("")},EG=function(Q){Q=Q.toUpperCase(),Q=Q.substring(4)+Q.substring(0,2)+"00";let Y=Q.split("").map((X)=>{return $5[X]}).join("");while(Y.length>=lX){let X=Y.substring(0,lX);Y=parseInt(X,10)%97+Y.substring(X.length)}let J=String(98-parseInt(Y,10)%97);while(J.length<2)J="0"+J;return J},AG=function(Q){Q=Q.toLowerCase();let Y=FG;for(let J=0;J<Q.length;J++)Y=Y*BG+SG[Q[J]];return Y};function _(Q){if(I(typeof Q==="string","invalid address","address",Q),Q.match(/^(0x)?[0-9a-fA-F]{40}$/)){if(!Q.startsWith("0x"))Q="0x"+Q;const Y=dX(Q);return I(!Q.match(/([A-F].*[a-f])|([a-f].*[A-F])/)||Y===Q,"bad address checksum","address",Q),Y}if(Q.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)){I(Q.substring(2,4)===EG(Q),"bad icap checksum","address",Q);let Y=AG(Q.substring(4)).toString(16);while(Y.length<40)Y="0"+Y;return dX("0x"+Y)}I(!1,"invalid address","address",Q)}var FG=BigInt(0),BG=BigInt(36),$5={};for(let Q=0;Q<10;Q++)$5[String(Q)]=String(Q);for(let Q=0;Q<26;Q++)$5[String.fromCharCode(65+Q)]=String(10+Q);var lX=15,SG=function(){const Q={};for(let Y=0;Y<36;Y++){const J="0123456789abcdefghijklmnopqrstuvwxyz"[Y];Q[J]=BigInt(Y)}return Q}();function z5(Q){return Q&&typeof Q.getAddress==="function"}async function Z5(Q,Y){const J=await Y;if(J==null||J==="0x0000000000000000000000000000000000000000")f(typeof Q!=="string","unconfigured name","UNCONFIGURED_NAME",{value:Q}),I(!1,"invalid AddressLike value; did not resolve to a value address","target",Q);return _(J)}function D8(Q,Y){if(typeof Q==="string"){if(Q.match(/^0x[0-9a-f]{40}$/i))return _(Q);return f(Y!=null,"ENS resolution requires a provider","UNSUPPORTED_OPERATION",{operation:"resolveName"}),Z5(Q,Y.resolveName(Q))}else if(z5(Q))return Z5(Q,Q.getAddress());else if(Q&&typeof Q.then==="function")return Z5(Q,Q);I(!1,"unsupported addressable value","target",Q)}var M5=function(Q,Y){return{address:_(Q),storageKeys:Y.map((J,X)=>{return I(H0(J,32),"invalid slot",`storageKeys[${X}]`,J),J.toLowerCase()})}};function e8(Q){if(Array.isArray(Q))return Q.map((J,X)=>{if(Array.isArray(J))return I(J.length===2,"invalid slot set",`value[${X}]`,J),M5(J[0],J[1]);return I(J!=null&&typeof J==="object","invalid address-slot set","value",Q),M5(J.address,J.storageKeys)});I(Q!=null&&typeof Q==="object","invalid access list","value",Q);const Y=Object.keys(Q).map((J)=>{const X=Q[J].reduce((q,G)=>{return q[G]=!0,q},{});return M5(J,Object.keys(X).sort())});return Y.sort((J,X)=>J.address.localeCompare(X.address)),Y}function nX(Q){return{address:_(Q.address),nonce:c(Q.nonce!=null?Q.nonce:0),chainId:c(Q.chainId!=null?Q.chainId:0),signature:Q0.from(Q.signature)}}function H8(Q){let Y;if(typeof Q==="string")Y=W0.computePublicKey(Q,!1);else Y=Q.publicKey;return _(n("0x"+Y.substring(4)).substring(26))}function i9(Q,Y){return H8(W0.recoverPublicKey(Q,Y))}var hG=function(Q){return{blobToKzgCommitment:(X)=>{if("computeBlobProof"in Q){if(("blobToKzgCommitment"in Q)&&typeof Q.blobToKzgCommitment==="function")return E(Q.blobToKzgCommitment(B(X)))}else if(("blobToKzgCommitment"in Q)&&typeof Q.blobToKzgCommitment==="function")return E(Q.blobToKzgCommitment(X));if(("blobToKZGCommitment"in Q)&&typeof Q.blobToKZGCommitment==="function")return E(Q.blobToKZGCommitment(B(X)));I(!1,"unsupported KZG library","kzg",Q)},computeBlobKzgProof:(X,q)=>{if(("computeBlobProof"in Q)&&typeof Q.computeBlobProof==="function")return E(Q.computeBlobProof(B(X),B(q)));if(("computeBlobKzgProof"in Q)&&typeof Q.computeBlobKzgProof==="function")return Q.computeBlobKzgProof(X,q);if(("computeBlobKZGProof"in Q)&&typeof Q.computeBlobKZGProof==="function")return E(Q.computeBlobKZGProof(B(X),B(q)));I(!1,"unsupported KZG library","kzg",Q)}}},oX=function(Q,Y){let J=Q.toString(16);while(J.length<2)J="0"+J;return J+=O0(Y).substring(4),"0x"+J},F9=function(Q){if(Q==="0x")return null;return _(Q)},eQ=function(Q,Y){try{return e8(Q)}catch(J){I(!1,J.message,Y,Q)}},mG=function(Q,Y){try{if(!Array.isArray(Q))throw new Error("authorizationList: invalid array");const J=[];for(let X=0;X<Q.length;X++){const q=Q[X];if(!Array.isArray(q))throw new Error(`authorization[${X}]: invalid array`);if(q.length!==6)throw new Error(`authorization[${X}]: wrong length`);if(!q[1])throw new Error(`authorization[${X}]: null address`);J.push({address:F9(q[1]),nonce:t(q[2],"nonce"),chainId:t(q[0],"chainId"),signature:Q0.from({yParity:Q9(q[3],"yParity"),r:S0(q[4],32),s:S0(q[5],32)})})}return J}catch(J){I(!1,J.message,Y,Q)}},Q9=function(Q,Y){if(Q==="0x")return 0;return Z0(Q,Y)},t=function(Q,Y){if(Q==="0x")return M0;const J=c(Q,Y);return I(J<=yG,"value exceeds uint size",Y,J),J},p=function(Q,Y){const J=c(Q,"value"),X=e(J);return I(X.length<=32,"value too large",`tx.${Y}`,J),X},QJ=function(Q){return e8(Q).map((Y)=>[Y.address,Y.storageKeys])},_G=function(Q){return Q.map((Y)=>{return[p(Y.chainId,"chainId"),Y.address,p(Y.nonce,"nonce"),p(Y.signature.yParity,"yParity"),e(Y.signature.r),e(Y.signature.s)]})},cG=function(Q,Y){I(Array.isArray(Q),`invalid ${Y}`,"value",Q);for(let J=0;J<Q.length;J++)I(H0(Q[J],32),"invalid ${ param } hash",`value[${J}]`,Q[J]);return Q},pG=function(Q){const Y=B8(Q);I(Array.isArray(Y)&&(Y.length===9||Y.length===6),"invalid field count for legacy transaction","data",Q);const J={type:0,nonce:Q9(Y[0],"nonce"),gasPrice:t(Y[1],"gasPrice"),gasLimit:t(Y[2],"gasLimit"),to:F9(Y[3]),value:t(Y[4],"value"),data:B(Y[5]),chainId:M0};if(Y.length===6)return J;const X=t(Y[6],"v"),q=t(Y[7],"r"),G=t(Y[8],"s");if(q===M0&&G===M0)J.chainId=X;else{let W=(X-gG)/fG;if(W<M0)W=M0;J.chainId=W,I(W!==M0||(X===bG||X===vG),"non-canonical legacy v","v",Y[6]),J.signature=Q0.from({r:S0(Y[7],32),s:S0(Y[8],32),v:X})}return J},uG=function(Q,Y){const J=[p(Q.nonce,"nonce"),p(Q.gasPrice||0,"gasPrice"),p(Q.gasLimit,"gasLimit"),Q.to||"0x",p(Q.value,"value"),Q.data];let X=M0;if(Q.chainId!=M0)X=c(Q.chainId,"tx.chainId"),I(!Y||Y.networkV==null||Y.legacyChainId===X,"tx.chainId/sig.v mismatch","sig",Y);else if(Q.signature){const G=Q.signature.legacyChainId;if(G!=null)X=G}if(!Y){if(X!==M0)J.push(e(X)),J.push("0x"),J.push("0x");return v0(J)}let q=BigInt(27+Y.yParity);if(X!==M0)q=Q0.getChainIdV(X,Y.v);else if(BigInt(Y.v)!==q)I(!1,"tx.chainId/sig.v mismatch","sig",Y);return J.push(e(q)),J.push(e(Y.r)),J.push(e(Y.s)),v0(J)},JJ=function(Q,Y){let J;try{if(J=Q9(Y[0],"yParity"),J!==0&&J!==1)throw new Error("bad yParity")}catch(W){I(!1,"invalid yParity","yParity",Y[0])}const X=S0(Y[1],32),q=S0(Y[2],32),G=Q0.from({r:X,s:q,yParity:J});Q.signature=G},dG=function(Q){const Y=B8(E(Q).slice(1));I(Array.isArray(Y)&&(Y.length===9||Y.length===12),"invalid field count for transaction type: 2","data",B(Q));const J={type:2,chainId:t(Y[0],"chainId"),nonce:Q9(Y[1],"nonce"),maxPriorityFeePerGas:t(Y[2],"maxPriorityFeePerGas"),maxFeePerGas:t(Y[3],"maxFeePerGas"),gasPrice:null,gasLimit:t(Y[4],"gasLimit"),to:F9(Y[5]),value:t(Y[6],"value"),data:B(Y[7]),accessList:eQ(Y[8],"accessList")};if(Y.length===9)return J;return JJ(J,Y.slice(9)),J},lG=function(Q,Y){const J=[p(Q.chainId,"chainId"),p(Q.nonce,"nonce"),p(Q.maxPriorityFeePerGas||0,"maxPriorityFeePerGas"),p(Q.maxFeePerGas||0,"maxFeePerGas"),p(Q.gasLimit,"gasLimit"),Q.to||"0x",p(Q.value,"value"),Q.data,QJ(Q.accessList||[])];if(Y)J.push(p(Y.yParity,"yParity")),J.push(e(Y.r)),J.push(e(Y.s));return i(["0x02",v0(J)])},nG=function(Q){const Y=B8(E(Q).slice(1));I(Array.isArray(Y)&&(Y.length===8||Y.length===11),"invalid field count for transaction type: 1","data",B(Q));const J={type:1,chainId:t(Y[0],"chainId"),nonce:Q9(Y[1],"nonce"),gasPrice:t(Y[2],"gasPrice"),gasLimit:t(Y[3],"gasLimit"),to:F9(Y[4]),value:t(Y[5],"value"),data:B(Y[6]),accessList:eQ(Y[7],"accessList")};if(Y.length===8)return J;return JJ(J,Y.slice(8)),J},oG=function(Q,Y){const J=[p(Q.chainId,"chainId"),p(Q.nonce,"nonce"),p(Q.gasPrice||0,"gasPrice"),p(Q.gasLimit,"gasLimit"),Q.to||"0x",p(Q.value,"value"),Q.data,QJ(Q.accessList||[])];if(Y)J.push(p(Y.yParity,"recoveryParam")),J.push(e(Y.r)),J.push(e(Y.s));return i(["0x01",v0(J)])},iG=function(Q){let Y=B8(E(Q).slice(1)),J="3",X=null;if(Y.length===4&&Array.isArray(Y[0])){J="3 (network format)";const G=Y[1],W=Y[2],U=Y[3];I(Array.isArray(G),"invalid network format: blobs not an array","fields[1]",G),I(Array.isArray(W),"invalid network format: commitments not an array","fields[2]",W),I(Array.isArray(U),"invalid network format: proofs not an array","fields[3]",U),I(G.length===W.length,"invalid network format: blobs/commitments length mismatch","fields",Y),I(G.length===U.length,"invalid network format: blobs/proofs length mismatch","fields",Y),X=[];for(let $=0;$<Y[1].length;$++)X.push({data:G[$],commitment:W[$],proof:U[$]});Y=Y[0]}I(Array.isArray(Y)&&(Y.length===11||Y.length===14),`invalid field count for transaction type: ${J}`,"data",B(Q));const q={type:3,chainId:t(Y[0],"chainId"),nonce:Q9(Y[1],"nonce"),maxPriorityFeePerGas:t(Y[2],"maxPriorityFeePerGas"),maxFeePerGas:t(Y[3],"maxFeePerGas"),gasPrice:null,gasLimit:t(Y[4],"gasLimit"),to:F9(Y[5]),value:t(Y[6],"value"),data:B(Y[7]),accessList:eQ(Y[8],"accessList"),maxFeePerBlobGas:t(Y[9],"maxFeePerBlobGas"),blobVersionedHashes:Y[10]};if(X)q.blobs=X;I(q.to!=null,`invalid address for transaction type: ${J}`,"data",Q),I(Array.isArray(q.blobVersionedHashes),"invalid blobVersionedHashes: must be an array","data",Q);for(let G=0;G<q.blobVersionedHashes.length;G++)I(H0(q.blobVersionedHashes[G],32),`invalid blobVersionedHash at index ${G}: must be length 32`,"data",Q);if(Y.length===11)return q;return JJ(q,Y.slice(11)),q},rG=function(Q,Y,J){const X=[p(Q.chainId,"chainId"),p(Q.nonce,"nonce"),p(Q.maxPriorityFeePerGas||0,"maxPriorityFeePerGas"),p(Q.maxFeePerGas||0,"maxFeePerGas"),p(Q.gasLimit,"gasLimit"),Q.to||U5,p(Q.value,"value"),Q.data,QJ(Q.accessList||[]),p(Q.maxFeePerBlobGas||0,"maxFeePerBlobGas"),cG(Q.blobVersionedHashes||[],"blobVersionedHashes")];if(Y){if(X.push(p(Y.yParity,"yParity")),X.push(e(Y.r)),X.push(e(Y.s)),J)return i(["0x03",v0([X,J.map((q)=>q.data),J.map((q)=>q.commitment),J.map((q)=>q.proof)])])}return i(["0x03",v0(X)])},aG=function(Q){const Y=B8(E(Q).slice(1));I(Array.isArray(Y)&&(Y.length===10||Y.length===13),"invalid field count for transaction type: 4","data",B(Q));const J={type:4,chainId:t(Y[0],"chainId"),nonce:Q9(Y[1],"nonce"),maxPriorityFeePerGas:t(Y[2],"maxPriorityFeePerGas"),maxFeePerGas:t(Y[3],"maxFeePerGas"),gasPrice:null,gasLimit:t(Y[4],"gasLimit"),to:F9(Y[5]),value:t(Y[6],"value"),data:B(Y[7]),accessList:eQ(Y[8],"accessList"),authorizationList:mG(Y[9],"authorizationList")};if(Y.length===10)return J;return JJ(J,Y.slice(10)),J},tG=function(Q,Y){const J=[p(Q.chainId,"chainId"),p(Q.nonce,"nonce"),p(Q.maxPriorityFeePerGas||0,"maxPriorityFeePerGas"),p(Q.maxFeePerGas||0,"maxFeePerGas"),p(Q.gasLimit,"gasLimit"),Q.to||"0x",p(Q.value,"value"),Q.data,QJ(Q.accessList||[]),_G(Q.authorizationList||[])];if(Y)J.push(p(Y.yParity,"yParity")),J.push(e(Y.r)),J.push(e(Y.s));return i(["0x04",v0(J)])},M0=BigInt(0),fG=BigInt(2),bG=BigInt(27),vG=BigInt(28),gG=BigInt(35),yG=BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"),K5=131072;class N0{#Q;#J;#Y;#X;#V;#$;#Z;#z;#M;#K;#j;#O;#U;#G;#q;#W;#I;get type(){return this.#Q}set type(Q){switch(Q){case null:this.#Q=null;break;case 0:case"legacy":this.#Q=0;break;case 1:case"berlin":case"eip-2930":this.#Q=1;break;case 2:case"london":case"eip-1559":this.#Q=2;break;case 3:case"cancun":case"eip-4844":this.#Q=3;break;case 4:case"pectra":case"eip-7702":this.#Q=4;break;default:I(!1,"unsupported transaction type","type",Q)}}get typeName(){switch(this.type){case 0:return"legacy";case 1:return"eip-2930";case 2:return"eip-1559";case 3:return"eip-4844";case 4:return"eip-7702"}return null}get to(){const Q=this.#J;if(Q==null&&this.type===3)return U5;return Q}set to(Q){this.#J=Q==null?null:_(Q)}get nonce(){return this.#X}set nonce(Q){this.#X=Z0(Q,"value")}get gasLimit(){return this.#V}set gasLimit(Q){this.#V=c(Q)}get gasPrice(){const Q=this.#$;if(Q==null&&(this.type===0||this.type===1))return M0;return Q}set gasPrice(Q){this.#$=Q==null?null:c(Q,"gasPrice")}get maxPriorityFeePerGas(){const Q=this.#Z;if(Q==null){if(this.type===2||this.type===3)return M0;return null}return Q}set maxPriorityFeePerGas(Q){this.#Z=Q==null?null:c(Q,"maxPriorityFeePerGas")}get maxFeePerGas(){const Q=this.#z;if(Q==null){if(this.type===2||this.type===3)return M0;return null}return Q}set maxFeePerGas(Q){this.#z=Q==null?null:c(Q,"maxFeePerGas")}get data(){return this.#Y}set data(Q){this.#Y=B(Q)}get value(){return this.#M}set value(Q){this.#M=c(Q,"value")}get chainId(){return this.#K}set chainId(Q){this.#K=c(Q)}get signature(){return this.#j||null}set signature(Q){this.#j=Q==null?null:Q0.from(Q)}get accessList(){const Q=this.#O||null;if(Q==null){if(this.type===1||this.type===2||this.type===3)return[];return null}return Q}set accessList(Q){this.#O=Q==null?null:e8(Q)}get authorizationList(){const Q=this.#I||null;if(Q==null){if(this.type===4)return[]}return Q}set authorizationList(Q){this.#I=Q==null?null:Q.map((Y)=>nX(Y))}get maxFeePerBlobGas(){const Q=this.#U;if(Q==null&&this.type===3)return M0;return Q}set maxFeePerBlobGas(Q){this.#U=Q==null?null:c(Q,"maxFeePerBlobGas")}get blobVersionedHashes(){let Q=this.#G;if(Q==null&&this.type===3)return[];return Q}set blobVersionedHashes(Q){if(Q!=null){I(Array.isArray(Q),"blobVersionedHashes must be an Array","value",Q),Q=Q.slice();for(let Y=0;Y<Q.length;Y++)I(H0(Q[Y],32),"invalid blobVersionedHash",`value[${Y}]`,Q[Y])}this.#G=Q}get blobs(){if(this.#W==null)return null;return this.#W.map((Q)=>Object.assign({},Q))}set blobs(Q){if(Q==null){this.#W=null;return}const Y=[],J=[];for(let X=0;X<Q.length;X++){const q=Q[X];if(t0(q)){f(this.#q,"adding a raw blob requires a KZG library","UNSUPPORTED_OPERATION",{operation:"set blobs()"});let G=E(q);if(I(G.length<=K5,"blob is too large",`blobs[${X}]`,q),G.length!==K5){const $=new Uint8Array(K5);$.set(G),G=$}const W=this.#q.blobToKzgCommitment(G),U=B(this.#q.computeBlobKzgProof(G,W));Y.push({data:B(G),commitment:B(W),proof:U}),J.push(oX(1,W))}else{const G=B(q.commitment);Y.push({data:B(q.data),commitment:G,proof:B(q.proof)}),J.push(oX(1,G))}}this.#W=Y,this.#G=J}get kzg(){return this.#q}set kzg(Q){if(Q==null)this.#q=null;else this.#q=hG(Q)}constructor(){this.#Q=null,this.#J=null,this.#X=0,this.#V=M0,this.#$=null,this.#Z=null,this.#z=null,this.#Y="0x",this.#M=M0,this.#K=M0,this.#j=null,this.#O=null,this.#U=null,this.#G=null,this.#q=null,this.#W=null,this.#I=null}get hash(){if(this.signature==null)return null;return n(this.#L(!0,!1))}get unsignedHash(){return n(this.unsignedSerialized)}get from(){if(this.signature==null)return null;return i9(this.unsignedHash,this.signature)}get fromPublicKey(){if(this.signature==null)return null;return W0.recoverPublicKey(this.unsignedHash,this.signature)}isSigned(){return this.signature!=null}#L(Q,Y){f(!Q||this.signature!=null,"cannot serialize unsigned transaction; maybe you meant .unsignedSerialized","UNSUPPORTED_OPERATION",{operation:".serialized"});const J=Q?this.signature:null;switch(this.inferType()){case 0:return uG(this,J);case 1:return oG(this,J);case 2:return lG(this,J);case 3:return rG(this,J,Y?this.blobs:null);case 4:return tG(this,J)}f(!1,"unsupported transaction type","UNSUPPORTED_OPERATION",{operation:".serialized"})}get serialized(){return this.#L(!0,!0)}get unsignedSerialized(){return this.#L(!1,!1)}inferType(){const Q=this.inferTypes();if(Q.indexOf(2)>=0)return 2;return Q.pop()}inferTypes(){const Q=this.gasPrice!=null,Y=this.maxFeePerGas!=null||this.maxPriorityFeePerGas!=null,J=this.accessList!=null,X=this.#U!=null||this.#G;if(this.maxFeePerGas!=null&&this.maxPriorityFeePerGas!=null)f(this.maxFeePerGas>=this.maxPriorityFeePerGas,"priorityFee cannot be more than maxFee","BAD_DATA",{value:this});f(!Y||this.type!==0&&this.type!==1,"transaction type cannot have maxFeePerGas or maxPriorityFeePerGas","BAD_DATA",{value:this}),f(this.type!==0||!J,"legacy transaction cannot have accessList","BAD_DATA",{value:this});const q=[];if(this.type!=null)q.push(this.type);else if(this.authorizationList&&this.authorizationList.length)q.push(4);else if(Y)q.push(2);else if(Q){if(q.push(1),!J)q.push(0)}else if(J)q.push(1),q.push(2);else if(X&&this.to)q.push(3);else q.push(0),q.push(1),q.push(2),q.push(3);return q.sort(),q}isLegacy(){return this.type===0}isBerlin(){return this.type===1}isLondon(){return this.type===2}isCancun(){return this.type===3}clone(){return N0.from(this)}toJSON(){const Q=(Y)=>{if(Y==null)return null;return Y.toString()};return{type:this.type,to:this.to,data:this.data,nonce:this.nonce,gasLimit:Q(this.gasLimit),gasPrice:Q(this.gasPrice),maxPriorityFeePerGas:Q(this.maxPriorityFeePerGas),maxFeePerGas:Q(this.maxFeePerGas),value:Q(this.value),chainId:Q(this.chainId),sig:this.signature?this.signature.toJSON():null,accessList:this.accessList}}static from(Q){if(Q==null)return new N0;if(typeof Q==="string"){const J=E(Q);if(J[0]>=127)return N0.from(pG(J));switch(J[0]){case 1:return N0.from(nG(J));case 2:return N0.from(dG(J));case 3:return N0.from(iG(J));case 4:return N0.from(aG(J))}f(!1,"unsupported transaction type","UNSUPPORTED_OPERATION",{operation:"from"})}const Y=new N0;if(Q.type!=null)Y.type=Q.type;if(Q.to!=null)Y.to=Q.to;if(Q.nonce!=null)Y.nonce=Q.nonce;if(Q.gasLimit!=null)Y.gasLimit=Q.gasLimit;if(Q.gasPrice!=null)Y.gasPrice=Q.gasPrice;if(Q.maxPriorityFeePerGas!=null)Y.maxPriorityFeePerGas=Q.maxPriorityFeePerGas;if(Q.maxFeePerGas!=null)Y.maxFeePerGas=Q.maxFeePerGas;if(Q.maxFeePerBlobGas!=null)Y.maxFeePerBlobGas=Q.maxFeePerBlobGas;if(Q.data!=null)Y.data=Q.data;if(Q.value!=null)Y.value=Q.value;if(Q.chainId!=null)Y.chainId=Q.chainId;if(Q.signature!=null)Y.signature=Q0.from(Q.signature);if(Q.accessList!=null)Y.accessList=Q.accessList;if(Q.authorizationList!=null)Y.authorizationList=Q.authorizationList;if(Q.blobVersionedHashes!=null)Y.blobVersionedHashes=Q.blobVersionedHashes;if(Q.kzg!=null)Y.kzg=Q.kzg;if(Q.blobs!=null)Y.blobs=Q.blobs;if(Q.hash!=null)I(Y.isSigned(),"unsigned transaction cannot define '.hash'","tx",Q),I(Y.hash===Q.hash,"hash mismatch","tx",Q);if(Q.from!=null)I(Y.isSigned(),"unsigned transaction cannot define '.from'","tx",Q),I(Y.from.toLowerCase()===(Q.from||"").toLowerCase(),"from mismatch","tx",Q);return Y}}function YJ(Q){return I(typeof Q.address==="string","invalid address for hashAuthorization","auth.address",Q),n(i(["0x05",v0([Q.chainId!=null?e(Q.chainId):"0x",_(Q.address),Q.nonce!=null?e(Q.nonce):"0x"])]))}function R8(Q){return n(z0(Q))}function r9(Q){if(typeof Q==="string")Q=z0(Q);return n(i([z0(V5),z0(String(Q.length)),Q]))}function XJ(Q,Y){const J=r9(Q);return i9(J,Y)}var QW=function(Q){const Y=E(Q),J=Y.length%32;if(J)return i([Y,tX.slice(J)]);return B(Y)},rX=function(Q){return function(Y){return I(typeof Y==="string",`invalid domain value for ${JSON.stringify(Q)}`,`domain.${Q}`,Y),Y}},O5=function(Q){{const Y=Q.match(/^(u?)int(\d+)$/);if(Y){const J=Y[1]==="",X=parseInt(Y[2]);I(X%8===0&&X!==0&&X<=256&&Y[2]===String(X),"invalid numeric width","type",Q);const q=SQ(eG,J?X-1:X),G=J?(q+eX)*sG:sX;return function(W){const U=c(W,"value");return I(U>=G&&U<=q,`value out-of-bounds for ${Q}`,"value",U),n0(J?EQ(U,256):U,32)}}}{const Y=Q.match(/^bytes(\d+)$/);if(Y){const J=parseInt(Y[1]);return I(J!==0&&J<=32&&Y[1]===String(J),"invalid bytes width","type",Q),function(X){const q=E(X);return I(q.length===J,`invalid length for ${Q}`,"value",X),QW(X)}}}switch(Q){case"address":return function(Y){return S0(_(Y),32)};case"bool":return function(Y){return!Y?YW:JW};case"bytes":return function(Y){return n(Y)};case"string":return function(Y){return R8(Y)}}return null},aX=function(Q,Y){return`${Q}(${Y.map(({name:J,type:X})=>X+" "+J).join(",")})`},qJ=function(Q){const Y=Q.match(/^([^\x5b]*)((\x5b\d*\x5d)*)(\x5b(\d*)\x5d)$/);if(Y)return{base:Y[1],index:Y[2]+Y[4],array:{base:Y[1],prefix:Y[1]+Y[2],count:Y[5]?parseInt(Y[5]):-1}};return{base:Q}};var tX=new Uint8Array(32);tX.fill(0);var sG=BigInt(-1),sX=BigInt(0),eX=BigInt(1),eG=BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"),JW=n0(eX,32),YW=n0(sX,32),iX={name:"string",version:"string",chainId:"uint256",verifyingContract:"address",salt:"bytes32"},j5=["name","version","chainId","verifyingContract","salt"],XW={name:rX("name"),version:rX("version"),chainId:function(Q){const Y=c(Q,"domain.chainId");if(I(Y>=0,"invalid chain ID","domain.chainId",Q),Number.isSafeInteger(Y))return Number(Y);return AQ(Y)},verifyingContract:function(Q){try{return _(Q).toLowerCase()}catch(Y){}I(!1,'invalid domain value "verifyingContract"',"domain.verifyingContract",Q)},salt:function(Q){const Y=E(Q,"domain.salt");return I(Y.length===32,'invalid domain value "salt"',"domain.salt",Q),B(Y)}};class C0{primaryType;#Q;get types(){return JSON.parse(this.#Q)}#J;#Y;constructor(Q){this.#J=new Map,this.#Y=new Map;const Y=new Map,J=new Map,X=new Map,q={};Object.keys(Q).forEach((U)=>{q[U]=Q[U].map(({name:$,type:V})=>{let{base:Z,index:K}=qJ(V);if(Z==="int"&&!Q.int)Z="int256";if(Z==="uint"&&!Q.uint)Z="uint256";return{name:$,type:Z+(K||"")}}),Y.set(U,new Set),J.set(U,[]),X.set(U,new Set)}),this.#Q=JSON.stringify(q);for(let U in q){const $=new Set;for(let V of q[U]){I(!$.has(V.name),`duplicate variable name ${JSON.stringify(V.name)} in ${JSON.stringify(U)}`,"types",Q),$.add(V.name);const Z=qJ(V.type).base;if(I(Z!==U,`circular type reference to ${JSON.stringify(Z)}`,"types",Q),O5(Z))continue;I(J.has(Z),`unknown type ${JSON.stringify(Z)}`,"types",Q),J.get(Z).push(U),Y.get(U).add(Z)}}const G=Array.from(J.keys()).filter((U)=>J.get(U).length===0);I(G.length!==0,"missing primary type","types",Q),I(G.length===1,`ambiguous primary types or unused types: ${G.map((U)=>JSON.stringify(U)).join(", ")}`,"types",Q),s(this,{primaryType:G[0]});function W(U,$){I(!$.has(U),`circular type reference to ${JSON.stringify(U)}`,"types",Q),$.add(U);for(let V of Y.get(U)){if(!J.has(V))continue;W(V,$);for(let Z of $)X.get(Z).add(V)}$.delete(U)}W(this.primaryType,new Set);for(let[U,$]of X){const V=Array.from($);V.sort(),this.#J.set(U,aX(U,q[U])+V.map((Z)=>aX(Z,q[Z])).join(""))}}getEncoder(Q){let Y=this.#Y.get(Q);if(!Y)Y=this.#X(Q),this.#Y.set(Q,Y);return Y}#X(Q){{const X=O5(Q);if(X)return X}const Y=qJ(Q).array;if(Y){const X=Y.prefix,q=this.getEncoder(X);return(G)=>{I(Y.count===-1||Y.count===G.length,`array length mismatch; expected length ${Y.count}`,"value",G);let W=G.map(q);if(this.#J.has(X))W=W.map(n);return n(i(W))}}const J=this.types[Q];if(J){const X=R8(this.#J.get(Q));return(q)=>{const G=J.map(({name:W,type:U})=>{const $=this.getEncoder(U)(q[W]);if(this.#J.has(U))return n($);return $});return G.unshift(X),i(G)}}I(!1,`unknown type: ${Q}`,"type",Q)}encodeType(Q){const Y=this.#J.get(Q);return I(Y,`unknown type: ${JSON.stringify(Q)}`,"name",Q),Y}encodeData(Q,Y){return this.getEncoder(Q)(Y)}hashStruct(Q,Y){return n(this.encodeData(Q,Y))}encode(Q){return this.encodeData(this.primaryType,Q)}hash(Q){return this.hashStruct(this.primaryType,Q)}_visit(Q,Y,J){if(O5(Q))return J(Q,Y);const X=qJ(Q).array;if(X)return I(X.count===-1||X.count===Y.length,`array length mismatch; expected length ${X.count}`,"value",Y),Y.map((G)=>this._visit(X.prefix,G,J));const q=this.types[Q];if(q)return q.reduce((G,{name:W,type:U})=>{return G[W]=this._visit(U,Y[W],J),G},{});I(!1,`unknown type: ${Q}`,"type",Q)}visit(Q,Y){return this._visit(this.primaryType,Q,Y)}static from(Q){return new C0(Q)}static getPrimaryType(Q){return C0.from(Q).primaryType}static hashStruct(Q,Y,J){return C0.from(Y).hashStruct(Q,J)}static hashDomain(Q){const Y=[];for(let J in Q){if(Q[J]==null)continue;const X=iX[J];I(X,`invalid typed-data domain key: ${JSON.stringify(J)}`,"domain",Q),Y.push({name:J,type:X})}return Y.sort((J,X)=>{return j5.indexOf(J.name)-j5.indexOf(X.name)}),C0.hashStruct("EIP712Domain",{EIP712Domain:Y},Q)}static encode(Q,Y,J){return i(["0x1901",C0.hashDomain(Q),C0.from(Y).hash(J)])}static hash(Q,Y,J){return n(C0.encode(Q,Y,J))}static async resolveNames(Q,Y,J,X){Q=Object.assign({},Q);for(let W in Q)if(Q[W]==null)delete Q[W];const q={};if(Q.verifyingContract&&!H0(Q.verifyingContract,20))q[Q.verifyingContract]="0x";const G=C0.from(Y);G.visit(J,(W,U)=>{if(W==="address"&&!H0(U,20))q[U]="0x";return U});for(let W in q)q[W]=await X(W);if(Q.verifyingContract&&q[Q.verifyingContract])Q.verifyingContract=q[Q.verifyingContract];return J=G.visit(J,(W,U)=>{if(W==="address"&&q[U])return q[U];return U}),{domain:Q,value:J}}static getPayload(Q,Y,J){C0.hashDomain(Q);const X={},q=[];j5.forEach((U)=>{const $=Q[U];if($==null)return;X[U]=XW[U]($),q.push({name:U,type:iX[U]})});const G=C0.from(Y);Y=G.types;const W=Object.assign({},Y);return I(W.EIP712Domain==null,"types must not contain EIP712Domain type","types.EIP712Domain",Y),W.EIP712Domain=q,G.encode(J),{types:W,domain:X,primaryType:G.primaryType,message:G.visit(J,(U,$)=>{if(U.match(/^bytes(\d*)/))return B(E($));if(U.match(/^u?int/))return c($).toString();switch(U){case"address":return $.toLowerCase();case"bool":return!!$;case"string":return I(typeof $==="string","invalid string","value",$),$}I(!1,"unsupported type","type",U)})}}}var I5=function(Q){if(Q==null)return null;return Q},K0=function(Q){if(Q==null)return null;return Q.toString()};function a9(Q){const Y={};if(Q.to)Y.to=Q.to;if(Q.from)Y.from=Q.from;if(Q.data)Y.data=B(Q.data);const J="chainId,gasLimit,gasPrice,maxFeePerBlobGas,maxFeePerGas,maxPriorityFeePerGas,value".split(/,/);for(let q of J){if(!(q in Q)||Q[q]==null)continue;Y[q]=c(Q[q],`request.${q}`)}const X="type,nonce".split(/,/);for(let q of X){if(!(q in Q)||Q[q]==null)continue;Y[q]=Z0(Q[q],`request.${q}`)}if(Q.accessList)Y.accessList=e8(Q.accessList);if(Q.authorizationList)Y.authorizationList=Q.authorizationList.slice();if("blockTag"in Q)Y.blockTag=Q.blockTag;if("enableCcipRead"in Q)Y.enableCcipRead=!!Q.enableCcipRead;if("customData"in Q)Y.customData=Q.customData;if(("blobVersionedHashes"in Q)&&Q.blobVersionedHashes)Y.blobVersionedHashes=Q.blobVersionedHashes.slice();if("kzg"in Q)Y.kzg=Q.kzg;if(("blobs"in Q)&&Q.blobs)Y.blobs=Q.blobs.map((q)=>{if(t0(q))return B(q);return Object.assign({},q)});return Y}var WW=function(Q){return{orphan:"drop-block",hash:Q.hash,number:Q.number}},Xq=function(Q,Y){return{orphan:"reorder-transaction",tx:Q,other:Y}},qq=function(Q){return{orphan:"drop-transaction",tx:Q}},UW=function(Q){return{orphan:"drop-log",log:{transactionHash:Q.transactionHash,blockHash:Q.blockHash,blockNumber:Q.blockNumber,address:Q.address,data:Q.data,topics:Object.freeze(Q.topics.slice()),index:Q.index}}},Qq=BigInt(0);class Jq{provider;number;hash;timestamp;parentHash;parentBeaconBlockRoot;nonce;difficulty;gasLimit;gasUsed;stateRoot;receiptsRoot;blobGasUsed;excessBlobGas;miner;prevRandao;extraData;baseFeePerGas;#Q;constructor(Q,Y){this.#Q=Q.transactions.map((J)=>{if(typeof J!=="string")return new GJ(J,Y);return J}),s(this,{provider:Y,hash:I5(Q.hash),number:Q.number,timestamp:Q.timestamp,parentHash:Q.parentHash,parentBeaconBlockRoot:Q.parentBeaconBlockRoot,nonce:Q.nonce,difficulty:Q.difficulty,gasLimit:Q.gasLimit,gasUsed:Q.gasUsed,blobGasUsed:Q.blobGasUsed,excessBlobGas:Q.excessBlobGas,miner:Q.miner,prevRandao:I5(Q.prevRandao),extraData:Q.extraData,baseFeePerGas:I5(Q.baseFeePerGas),stateRoot:Q.stateRoot,receiptsRoot:Q.receiptsRoot})}get transactions(){return this.#Q.map((Q)=>{if(typeof Q==="string")return Q;return Q.hash})}get prefetchedTransactions(){const Q=this.#Q.slice();if(Q.length===0)return[];return f(typeof Q[0]==="object","transactions were not prefetched with block request","UNSUPPORTED_OPERATION",{operation:"transactionResponses()"}),Q}toJSON(){const{baseFeePerGas:Q,difficulty:Y,extraData:J,gasLimit:X,gasUsed:q,hash:G,miner:W,prevRandao:U,nonce:$,number:V,parentHash:Z,parentBeaconBlockRoot:K,stateRoot:M,receiptsRoot:j,timestamp:z,transactions:L}=this;return{_type:"Block",baseFeePerGas:K0(Q),difficulty:K0(Y),extraData:J,gasLimit:K0(X),gasUsed:K0(q),blobGasUsed:K0(this.blobGasUsed),excessBlobGas:K0(this.excessBlobGas),hash:G,miner:W,prevRandao:U,nonce:$,number:V,parentHash:Z,timestamp:z,parentBeaconBlockRoot:K,stateRoot:M,receiptsRoot:j,transactions:L}}[Symbol.iterator](){let Q=0;const Y=this.transactions;return{next:()=>{if(Q<this.length)return{value:Y[Q++],done:!1};return{value:void 0,done:!0}}}}get length(){return this.#Q.length}get date(){if(this.timestamp==null)return null;return new Date(this.timestamp*1000)}async getTransaction(Q){let Y=void 0;if(typeof Q==="number")Y=this.#Q[Q];else{const J=Q.toLowerCase();for(let X of this.#Q)if(typeof X==="string"){if(X!==J)continue;Y=X;break}else{if(X.hash!==J)continue;Y=X;break}}if(Y==null)throw new Error("no such tx");if(typeof Y==="string")return await this.provider.getTransaction(Y);else return Y}getPrefetchedTransaction(Q){const Y=this.prefetchedTransactions;if(typeof Q==="number")return Y[Q];Q=Q.toLowerCase();for(let J of Y)if(J.hash===Q)return J;I(!1,"no matching transaction","indexOrHash",Q)}isMined(){return!!this.hash}isLondon(){return!!this.baseFeePerGas}orphanedEvent(){if(!this.isMined())throw new Error("");return WW(this)}}class L5{provider;transactionHash;blockHash;blockNumber;removed;address;data;topics;index;transactionIndex;constructor(Q,Y){this.provider=Y;const J=Object.freeze(Q.topics.slice());s(this,{transactionHash:Q.transactionHash,blockHash:Q.blockHash,blockNumber:Q.blockNumber,removed:Q.removed,address:Q.address,data:Q.data,topics:J,index:Q.index,transactionIndex:Q.transactionIndex})}toJSON(){const{address:Q,blockHash:Y,blockNumber:J,data:X,index:q,removed:G,topics:W,transactionHash:U,transactionIndex:$}=this;return{_type:"log",address:Q,blockHash:Y,blockNumber:J,data:X,index:q,removed:G,topics:W,transactionHash:U,transactionIndex:$}}async getBlock(){const Q=await this.provider.getBlock(this.blockHash);return f(!!Q,"failed to find transaction","UNKNOWN_ERROR",{}),Q}async getTransaction(){const Q=await this.provider.getTransaction(this.transactionHash);return f(!!Q,"failed to find transaction","UNKNOWN_ERROR",{}),Q}async getTransactionReceipt(){const Q=await this.provider.getTransactionReceipt(this.transactionHash);return f(!!Q,"failed to find transaction receipt","UNKNOWN_ERROR",{}),Q}removedEvent(){return UW(this)}}class Yq{provider;to;from;contractAddress;hash;index;blockHash;blockNumber;logsBloom;gasUsed;blobGasUsed;cumulativeGasUsed;gasPrice;blobGasPrice;type;status;root;#Q;constructor(Q,Y){this.#Q=Object.freeze(Q.logs.map((X)=>{return new L5(X,Y)}));let J=Qq;if(Q.effectiveGasPrice!=null)J=Q.effectiveGasPrice;else if(Q.gasPrice!=null)J=Q.gasPrice;s(this,{provider:Y,to:Q.to,from:Q.from,contractAddress:Q.contractAddress,hash:Q.hash,index:Q.index,blockHash:Q.blockHash,blockNumber:Q.blockNumber,logsBloom:Q.logsBloom,gasUsed:Q.gasUsed,cumulativeGasUsed:Q.cumulativeGasUsed,blobGasUsed:Q.blobGasUsed,gasPrice:J,blobGasPrice:Q.blobGasPrice,type:Q.type,status:Q.status,root:Q.root})}get logs(){return this.#Q}toJSON(){const{to:Q,from:Y,contractAddress:J,hash:X,index:q,blockHash:G,blockNumber:W,logsBloom:U,logs:$,status:V,root:Z}=this;return{_type:"TransactionReceipt",blockHash:G,blockNumber:W,contractAddress:J,cumulativeGasUsed:K0(this.cumulativeGasUsed),from:Y,gasPrice:K0(this.gasPrice),blobGasUsed:K0(this.blobGasUsed),blobGasPrice:K0(this.blobGasPrice),gasUsed:K0(this.gasUsed),hash:X,index:q,logs:$,logsBloom:U,root:Z,status:V,to:Q}}get length(){return this.logs.length}[Symbol.iterator](){let Q=0;return{next:()=>{if(Q<this.length)return{value:this.logs[Q++],done:!1};return{value:void 0,done:!0}}}}get fee(){return this.gasUsed*this.gasPrice}async getBlock(){const Q=await this.provider.getBlock(this.blockHash);if(Q==null)throw new Error("TODO");return Q}async getTransaction(){const Q=await this.provider.getTransaction(this.hash);if(Q==null)throw new Error("TODO");return Q}async getResult(){return await this.provider.getTransactionResult(this.hash)}async confirmations(){return await this.provider.getBlockNumber()-this.blockNumber+1}removedEvent(){return qq(this)}reorderedEvent(Q){return f(!Q||Q.isMined(),"unmined 'other' transction cannot be orphaned","UNSUPPORTED_OPERATION",{operation:"reorderedEvent(other)"}),Xq(this,Q)}}class GJ{provider;blockNumber;blockHash;index;hash;type;to;from;nonce;gasLimit;gasPrice;maxPriorityFeePerGas;maxFeePerGas;maxFeePerBlobGas;data;value;chainId;signature;accessList;blobVersionedHashes;authorizationList;#Q;constructor(Q,Y){this.provider=Y,this.blockNumber=Q.blockNumber!=null?Q.blockNumber:null,this.blockHash=Q.blockHash!=null?Q.blockHash:null,this.hash=Q.hash,this.index=Q.index,this.type=Q.type,this.from=Q.from,this.to=Q.to||null,this.gasLimit=Q.gasLimit,this.nonce=Q.nonce,this.data=Q.data,this.value=Q.value,this.gasPrice=Q.gasPrice,this.maxPriorityFeePerGas=Q.maxPriorityFeePerGas!=null?Q.maxPriorityFeePerGas:null,this.maxFeePerGas=Q.maxFeePerGas!=null?Q.maxFeePerGas:null,this.maxFeePerBlobGas=Q.maxFeePerBlobGas!=null?Q.maxFeePerBlobGas:null,this.chainId=Q.chainId,this.signature=Q.signature,this.accessList=Q.accessList!=null?Q.accessList:null,this.blobVersionedHashes=Q.blobVersionedHashes!=null?Q.blobVersionedHashes:null,this.authorizationList=Q.authorizationList!=null?Q.authorizationList:null,this.#Q=-1}toJSON(){const{blockNumber:Q,blockHash:Y,index:J,hash:X,type:q,to:G,from:W,nonce:U,data:$,signature:V,accessList:Z,blobVersionedHashes:K}=this;return{_type:"TransactionResponse",accessList:Z,blockNumber:Q,blockHash:Y,blobVersionedHashes:K,chainId:K0(this.chainId),data:$,from:W,gasLimit:K0(this.gasLimit),gasPrice:K0(this.gasPrice),hash:X,maxFeePerGas:K0(this.maxFeePerGas),maxPriorityFeePerGas:K0(this.maxPriorityFeePerGas),maxFeePerBlobGas:K0(this.maxFeePerBlobGas),nonce:U,signature:V,to:G,index:J,type:q,value:K0(this.value)}}async getBlock(){let Q=this.blockNumber;if(Q==null){const J=await this.getTransaction();if(J)Q=J.blockNumber}if(Q==null)return null;const Y=this.provider.getBlock(Q);if(Y==null)throw new Error("TODO");return Y}async getTransaction(){return this.provider.getTransaction(this.hash)}async confirmations(){if(this.blockNumber==null){const{tx:Y,blockNumber:J}=await a0({tx:this.getTransaction(),blockNumber:this.provider.getBlockNumber()});if(Y==null||Y.blockNumber==null)return 0;return J-Y.blockNumber+1}return await this.provider.getBlockNumber()-this.blockNumber+1}async wait(Q,Y){const J=Q==null?1:Q,X=Y==null?0:Y;let q=this.#Q,G=-1,W=q===-1?!0:!1;const U=async()=>{if(W)return null;const{blockNumber:K,nonce:M}=await a0({blockNumber:this.provider.getBlockNumber(),nonce:this.provider.getTransactionCount(this.from)});if(M<this.nonce){q=K;return}if(W)return null;const j=await this.getTransaction();if(j&&j.blockNumber!=null)return;if(G===-1){if(G=q-3,G<this.#Q)G=this.#Q}while(G<=K){if(W)return null;const z=await this.provider.getBlock(G,!0);if(z==null)return;for(let L of z)if(L===this.hash)return;for(let L=0;L<z.length;L++){const H=await z.getTransaction(L);if(H.from===this.from&&H.nonce===this.nonce){if(W)return null;const P=await this.provider.getTransactionReceipt(H.hash);if(P==null)return;if(K-P.blockNumber+1<J)return;let C="replaced";if(H.data===this.data&&H.to===this.to&&H.value===this.value)C="repriced";else if(H.data==="0x"&&H.from===H.to&&H.value===Qq)C="cancelled";f(!1,"transaction was replaced","TRANSACTION_REPLACED",{cancelled:C==="replaced"||C==="cancelled",reason:C,replacement:H.replaceableTransaction(q),hash:H.hash,receipt:P})}}G++}return},$=(K)=>{if(K==null||K.status!==0)return K;f(!1,"transaction execution reverted","CALL_EXCEPTION",{action:"sendTransaction",data:null,reason:null,invocation:null,revert:null,transaction:{to:K.to,from:K.from,data:""},receipt:K})},V=await this.provider.getTransactionReceipt(this.hash);if(J===0)return $(V);if(V){if(J===1||await V.confirmations()>=J)return $(V)}else if(await U(),J===0)return null;return await new Promise((K,M)=>{const j=[],z=()=>{j.forEach((H)=>H())};if(j.push(()=>{W=!0}),X>0){const H=setTimeout(()=>{z(),M(c9("wait for transaction timeout","TIMEOUT"))},X);j.push(()=>{clearTimeout(H)})}const L=async(H)=>{if(await H.confirmations()>=J){z();try{K($(H))}catch(P){M(P)}}};if(j.push(()=>{this.provider.off(this.hash,L)}),this.provider.on(this.hash,L),q>=0){const H=async()=>{try{await U()}catch(P){if(BQ(P,"TRANSACTION_REPLACED")){z(),M(P);return}}if(!W)this.provider.once("block",H)};j.push(()=>{this.provider.off("block",H)}),this.provider.once("block",H)}})}isMined(){return this.blockHash!=null}isLegacy(){return this.type===0}isBerlin(){return this.type===1}isLondon(){return this.type===2}isCancun(){return this.type===3}removedEvent(){return f(this.isMined(),"unmined transaction canot be orphaned","UNSUPPORTED_OPERATION",{operation:"removeEvent()"}),qq(this)}reorderedEvent(Q){return f(this.isMined(),"unmined transaction canot be orphaned","UNSUPPORTED_OPERATION",{operation:"removeEvent()"}),f(!Q||Q.isMined(),"unmined 'other' transaction canot be orphaned","UNSUPPORTED_OPERATION",{operation:"removeEvent()"}),Xq(this,Q)}replaceableTransaction(Q){I(Number.isInteger(Q)&&Q>=0,"invalid startBlock","startBlock",Q);const Y=new GJ(this,this.provider);return Y.#Q=Q,Y}}var J9=function(Q,Y){if(Q.provider)return Q.provider;f(!1,"missing provider","UNSUPPORTED_OPERATION",{operation:Y})};async function Gq(Q,Y){let J=a9(Y);if(J.to!=null)J.to=D8(J.to,Q);if(J.from!=null){const X=J.from;J.from=Promise.all([Q.getAddress(),D8(X,Q)]).then(([q,G])=>{return I(q.toLowerCase()===G.toLowerCase(),"transaction from mismatch","tx.from",G),q})}else J.from=Q.getAddress();return await a0(J)}class t9{provider;constructor(Q){s(this,{provider:Q||null})}async getNonce(Q){return J9(this,"getTransactionCount").getTransactionCount(await this.getAddress(),Q)}async populateCall(Q){return await Gq(this,Q)}async populateTransaction(Q){const Y=J9(this,"populateTransaction"),J=await Gq(this,Q);if(J.nonce==null)J.nonce=await this.getNonce("pending");if(J.gasLimit==null)J.gasLimit=await this.estimateGas(J);const X=await this.provider.getNetwork();if(J.chainId!=null){const G=c(J.chainId);I(G===X.chainId,"transaction chainId mismatch","tx.chainId",Q.chainId)}else J.chainId=X.chainId;const q=J.maxFeePerGas!=null||J.maxPriorityFeePerGas!=null;if(J.gasPrice!=null&&(J.type===2||q))I(!1,"eip-1559 transaction do not support gasPrice","tx",Q);else if((J.type===0||J.type===1)&&q)I(!1,"pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas","tx",Q);if((J.type===2||J.type==null)&&(J.maxFeePerGas!=null&&J.maxPriorityFeePerGas!=null))J.type=2;else if(J.type===0||J.type===1){const G=await Y.getFeeData();if(f(G.gasPrice!=null,"network does not support gasPrice","UNSUPPORTED_OPERATION",{operation:"getGasPrice"}),J.gasPrice==null)J.gasPrice=G.gasPrice}else{const G=await Y.getFeeData();if(J.type==null)if(G.maxFeePerGas!=null&&G.maxPriorityFeePerGas!=null){if(J.authorizationList&&J.authorizationList.length)J.type=4;else J.type=2;if(J.gasPrice!=null){const W=J.gasPrice;delete J.gasPrice,J.maxFeePerGas=W,J.maxPriorityFeePerGas=W}else{if(J.maxFeePerGas==null)J.maxFeePerGas=G.maxFeePerGas;if(J.maxPriorityFeePerGas==null)J.maxPriorityFeePerGas=G.maxPriorityFeePerGas}}else if(G.gasPrice!=null){if(f(!q,"network does not support EIP-1559","UNSUPPORTED_OPERATION",{operation:"populateTransaction"}),J.gasPrice==null)J.gasPrice=G.gasPrice;J.type=0}else f(!1,"failed to get consistent fee data","UNSUPPORTED_OPERATION",{operation:"signer.getFeeData"});else if(J.type===2||J.type===3||J.type===4){if(J.maxFeePerGas==null)J.maxFeePerGas=G.maxFeePerGas;if(J.maxPriorityFeePerGas==null)J.maxPriorityFeePerGas=G.maxPriorityFeePerGas}}return await a0(J)}async populateAuthorization(Q){const Y=Object.assign({},Q);if(Y.chainId==null)Y.chainId=(await J9(this,"getNetwork").getNetwork()).chainId;if(Y.nonce==null)Y.nonce=await this.getNonce();return Y}async estimateGas(Q){return J9(this,"estimateGas").estimateGas(await this.populateCall(Q))}async call(Q){return J9(this,"call").call(await this.populateCall(Q))}async resolveName(Q){return await J9(this,"resolveName").resolveName(Q)}async sendTransaction(Q){const Y=J9(this,"sendTransaction"),J=await this.populateTransaction(Q);delete J.from;const X=N0.from(J);return await Y.broadcastTransaction(await this.signTransaction(X))}authorize(Q){f(!1,"authorization not implemented for this signer","UNSUPPORTED_OPERATION",{operation:"authorize"})}}class s9 extends t9{address;constructor(Q,Y){super(Y);s(this,{address:Q})}async getAddress(){return this.address}connect(Q){return new s9(this.address,Q)}#Q(Q,Y){f(!1,`VoidSigner cannot sign ${Q}`,"UNSUPPORTED_OPERATION",{operation:Y})}async signTransaction(Q){this.#Q("transactions","signTransaction")}async signMessage(Q){this.#Q("messages","signMessage")}async signTypedData(Q,Y,J){this.#Q("typed-data","signTypedData")}}class Y9 extends t9{address;#Q;constructor(Q,Y){super(Y);I(Q&&typeof Q.sign==="function","invalid private key","privateKey","[ REDACTED ]"),this.#Q=Q;const J=H8(this.signingKey.publicKey);s(this,{address:J})}get signingKey(){return this.#Q}get privateKey(){return this.signingKey.privateKey}async getAddress(){return this.address}connect(Q){return new Y9(this.#Q,Q)}async signTransaction(Q){Q=a9(Q);const{to:Y,from:J}=await a0({to:Q.to?D8(Q.to,this):void 0,from:Q.from?D8(Q.from,this):void 0});if(Y!=null)Q.to=Y;if(J!=null)Q.from=J;if(Q.from!=null)I(_(Q.from)===this.address,"transaction from address mismatch","tx.from",Q.from),delete Q.from;const X=N0.from(Q);return X.signature=this.signingKey.sign(X.unsignedHash),X.serialized}async signMessage(Q){return this.signMessageSync(Q)}signMessageSync(Q){return this.signingKey.sign(r9(Q)).serialized}authorizeSync(Q){I(typeof Q.address==="string","invalid address for authorizeSync","auth.address",Q);const Y=this.signingKey.sign(YJ(Q));return Object.assign({},{address:_(Q.address),nonce:c(Q.nonce||0),chainId:c(Q.chainId||0)},{signature:Y})}async authorize(Q){return Q=Object.assign({},Q,{address:await D8(Q.address,this)}),this.authorizeSync(await this.populateAuthorization(Q))}async signTypedData(Q,Y,J){const X=await C0.resolveNames(Q,Y,J,async(q)=>{f(this.provider!=null,"cannot resolve ENS names without a provider","UNSUPPORTED_OPERATION",{operation:"resolveName",info:{name:q}});const G=await this.provider.resolveName(q);return f(G!=null,"unconfigured ENS name","UNCONFIGURED_NAME",{value:q}),G});return this.signingKey.sign(C0.hash(X.domain,Y,X.value)).serialized}}var Wq=function(Q,Y){let J=97;return Q.reduce((X,q)=>{if(q===Y)J++;else if(q.match(VW))X.push(String.fromCharCode(J)+q);else J=97,X.push(q);return X},[])};function $W(Q,Y){for(let q=WJ.length-1;q>=0;q--)Q=Q.split(WJ[q]).join(Y.substring(2*q,2*q+2));const J=[],X=Q.replace(/(:|([0-9])|([A-Z][a-z]*))/g,(q,G,W,U)=>{if(W)for(let $=parseInt(W);$>=0;$--)J.push(";");else J.push(G.toLowerCase());return""});if(X)throw new Error(`leftovers: ${JSON.stringify(X)}`);return Wq(Wq(J,";"),":")}function Uq(Q){return I(Q[0]==="0","unsupported auwl data","data",Q),$W(Q.substring(1+2*WJ.length),Q.substring(1,1+2*WJ.length))}var WJ=" !#$%&'()*+,-./<=>?@[]^_`{|}~",VW=/^[a-z]*$/i;class D5{locale;constructor(Q){s(this,{locale:Q})}split(Q){return Q.toLowerCase().split(/\s+/g)}join(Q){return Q.join(" ")}}class H5 extends D5{#Q;#J;constructor(Q,Y,J){super(Q);this.#Q=Y,this.#J=J,this.#Y=null}get _data(){return this.#Q}_decodeWords(){return Uq(this.#Q)}#Y;#X(){if(this.#Y==null){const Q=this._decodeWords();if(R8(Q.join("\n")+"\n")!==this.#J)throw new Error(`BIP39 Wordlist for ${this.locale} FAILED`);this.#Y=Q}return this.#Y}getWord(Q){const Y=this.#X();return I(Q>=0&&Q<Y.length,`invalid word index: ${Q}`,"index",Q),Y[Q]}getWordIndex(Q){return this.#X().indexOf(Q)}}var ZW="0erleonalorenseinceregesticitStanvetearctssi#ch2Athck&tneLl0And#Il.yLeOutO=S|S%b/ra@SurdU'0Ce[Cid|CountCu'Hie=IdOu,-Qui*Ro[TT]T%T*[Tu$0AptDD-tD*[Ju,M.UltV<)Vi)0Rob-0FairF%dRaid0A(EEntRee0Ead0MRRp%tS!_rmBumCoholErtI&LLeyLowMo,O}PhaReadySoT Ways0A>urAz(gOngOuntU'd0Aly,Ch%Ci|G G!GryIm$K!Noun)Nu$O` Sw T&naTiqueXietyY1ArtOlogyPe?P!Pro=Ril1ChCt-EaEnaGueMMedM%MyOundR<+Re,Ri=RowTTefa@Ti,Tw%k0KPe@SaultSetSi,SumeThma0H!>OmTa{T&dT.udeTra@0Ct]D.Gu,NtTh%ToTumn0Era+OcadoOid0AkeA*AyEsomeFulKw?d0Is:ByChel%C#D+GL<)Lc#y~MbooN<aNn RRelyRga(R*lSeS-SketTt!3A^AnAutyCau'ComeEfF%eG(Ha=H(dLie=LowLtN^Nef./TrayTt Twe&Y#d3Cyc!DKeNdOlogyRdR`Tt _{AdeAmeAnketA,EakE[IndOodO[omOu'UeUrUsh_rdAtDyIlMbNeNusOkO,Rd R(gRrowSsTtomUn)XY_{etA(AndA[A=EadEezeI{Id+IefIghtIngIskOccoliOk&OnzeOomO` OwnUsh2Bb!DdyD+tFf$oIldLbLkL!tNd!Nk Rd&Rg R,SS(e[SyTt Y Zz:Bba+B(B!CtusGeKe~LmM aMpNN$N)lNdyNn#NoeNvasNy#Pab!P.$Pta(RRb#RdRgoRpetRryRtSeShS(o/!Su$TT$ogT^Teg%yTt!UghtU'Ut]Ve3Il(gL yM|NsusNturyRe$Rta(_irAlkAmp]An+AosApt Ar+A'AtEapE{Ee'EfErryE,I{&IefIldIm}yOi)Oo'R#-U{!UnkUrn0G?Nnam#Rc!Tiz&TyVil_imApArifyAwAyE<ErkEv I{I|IffImbIn-IpO{OgO'O`OudOwnUbUmpU, Ut^_^A,C#utDeFfeeIlInL!@L%LumnMb(eMeMf%tM-Mm#Mp<yNc tNdu@NfirmNg*[N}@Nsid NtrolNv()OkOlPp PyR$ReRnR*@/Tt#U^UntryUp!Ur'Us(V Yo>_{Ad!AftAmA}AshAt AwlAzyEamEd.EekEwI{etImeIspIt-OpO[Ou^OwdUci$UelUi'Umb!Un^UshYY,$2BeLtu*PPbo?dRiousRr|Rta(R=Sh]/omTe3C!:DMa+MpN)Ng R(gShUght WnY3AlBa>BrisCadeCemb CideCl(eC%a>C*a'ErF&'F(eFyG*eLayLiv M<dMi'Ni$Nti,NyP?tP&dPos.P`PutyRi=ScribeS tSignSkSpair/royTailTe@VelopVi)Vo>3AgramAlAm#dAryCeE'lEtFf G.$Gn.yLemmaNn NosaurRe@RtSag*eScov Sea'ShSmi[S%d Splay/<)V tVideV%)Zzy5Ct%Cum|G~Lph(Ma(Na>NkeyN%OrSeUb!Ve_ftAg#AmaA,-AwEamE[IftIllInkIpI=OpUmY2CkMbNeR(g/T^Ty1Arf1Nam-:G G!RlyRnR`Sily/Sy1HoOlogyOnomy0GeItUca>1F%t0G1GhtTh 2BowD E@r-Eg<tEm|Eph<tEvat%I>Se0B?kBodyBra)Er+Ot]PloyPow Pty0Ab!A@DD![D%'EmyErgyF%)Ga+G(eH<)JoyLi,OughR-hRollSu*T Ti*TryVelope1Isode0U$Uip0AA'OdeOs]R%Upt0CapeSayS&)Ta>0Ern$H-s1Id&)IlOkeOl=1A@Amp!Ce[Ch<+C.eCludeCu'Ecu>Erci'Hau,Hib.I!I,ItOt-P<dPe@Pi*Pla(Po'P*[T&dTra0EEbrow:Br-CeCultyDeIntI`~L'MeMilyMousNNcyNtasyRmSh]TT$Th TigueUltV%.e3Atu*Bru?yD $EEdElMa!N)/iv$T^V W3B Ct]EldGu*LeLmLt N$NdNeNg NishReRmR,Sc$ShTT}[X_gAmeAshAtAv%EeIghtIpOatO{O%Ow UidUshY_mCusGIlLd~owOdOtR)Re,R+tRkRtu}RumRw?dSsil/ UndX_gi!AmeEqu|EshI&dIn+OgOntO,OwnOz&U.2ElNNnyRna)RyTu*:D+tInLaxy~ yMePRa+Rba+Rd&Rl-Rm|SSpTeTh U+Ze3N $NiusN*Nt!Nu(e/u*2O,0AntFtGg!Ng RaffeRlVe_dAn)A*A[IdeImp'ObeOomOryO=OwUe_tDde[LdOdO'RillaSpelSsipV nWn_bA)A(AntApeA[Av.yEatE&IdIefItOc yOupOwUnt_rdE[IdeIltIt?N3M:B.IrLfMm M, NdPpyRb%RdRshR=,TVeWkZ?d3AdAl`ArtAvyD+hogIght~oLmetLpNRo3Dd&Gh~NtPRe/%y5BbyCkeyLdLeLiday~owMeNeyOdPeRnRr%R'Sp.$/TelUrV 5BGeM<Mb!M%Nd*dNgryNtRd!RryRtSb<d3Brid:1EOn0EaEntifyLe2N%e4LLeg$L}[0A+Ita>M&'Mu}Pa@Po'Pro=Pul'0ChCludeComeC*a'DexD-a>Do%Du,ryF<tFl-tF%mHa!H .Iti$Je@JuryMa>N Noc|PutQuiryS<eSe@SideSpi*/$lTa@T e,ToVe,V.eVol=3On0L<dOla>Sue0Em1Ory:CketGu?RZz3AlousAns~yWel9BInKeUr}yY5D+I)MpNg!Ni%Nk/:Ng?oo3EnEpT^upY3CkDD}yNdNgdomSsTT^&TeTt&Wi4EeIfeO{Ow:BBelB%Dd DyKeMpNgua+PtopR+T T(UghUndryVaWWnWsu.Y Zy3Ad AfArnA=Ctu*FtGG$G&dIsu*M#NdNg`NsOp?dSs#Tt Vel3ArB tyBr?yC&'FeFtGhtKeMbM.NkOnQuid/Tt!VeZ?d5AdAnB, C$CkG-NelyNgOpTt yUdUn+VeY$5CkyGga+Mb N?N^Xury3R-s:Ch(eDG-G}tIdIlInJ%KeMm$NNa+Nda>NgoNs]Nu$P!Rb!R^Rg(R(eRketRria+SkSs/ T^T i$ThTrixTt XimumZe3AdowAnAsu*AtCh<-D$DiaLodyLtMb M%yNt]NuRcyR+R.RryShSsa+T$Thod3Dd!DnightLk~]M-NdNimumN%Nu>Rac!Rr%S ySs/akeXXedXtu*5Bi!DelDifyMM|N.%NkeyN, N`OnR$ReRn(gSqu.oTh T]T%Unta(U'VeVie5ChFf(LeLtiplySc!SeumShroomS-/Tu$3Self/ yTh:I=MePk(Rrow/yT]Tu*3ArCkEdGati=G!@I` PhewR=/TTw%kUtr$V WsXt3CeGht5B!I'M(eeOd!Rm$R`SeTab!TeTh(gTi)VelW5C!?Mb R'T:K0EyJe@Li+Scu*S =Ta(Vious0CurE<Tob 0Or1FF Fi)T&2L1Ay0DI=Ymp-0It0CeEI#L(eLy1EnEraIn]Po'T]1An+B.Ch?dD D(?yG<I|Ig($Ph<0Tr-h0H 0Tdo%T TputTside0AlEnEr0NN 0Yg&0/ 0O}:CtDd!GeIrLa)LmNdaNelN-N` P RadeR|RkRrotRtySsT^ThTi|TrolTt nU'VeYm|3A)AnutArAs<tL-<NN$tyNcilOp!Pp Rfe@Rm.Rs#T2O}OtoRa'Ys-$0AnoCn-Ctu*E)GGe#~LotNkO} Pe/olT^Zza_)A}tA,-A>AyEa'Ed+U{UgUn+2EmEtIntL?LeLi)NdNyOlPul?Rt]S.]Ssib!/TatoTt yV tyWd W _@i)Ai'Ed-tEf Epa*Es|EttyEv|I)IdeIm?yIntI%.yIs#Iva>IzeOb!mO)[Odu)Of.OgramOje@Omo>OofOp tyOsp O>@OudOvide2Bl-Dd(g~LpL'Mpk(N^PilPpyR^a'R.yRpo'R'ShTZz!3Ramid:99Al.yAntumArt E,]I{ItIzO>:Bb.Cco#CeCkD?DioIlInI'~yMpN^NdomN+PidReTeTh V&WZ%3AdyAlAs#BelBuildC$lCei=CipeC%dCyc!Du)F!@F%mFu'G]G*tGul?Je@LaxLea'LiefLyMa(Memb M(dMo=Nd NewNtOp&PairPeatPla)P%tQui*ScueSemb!Si,Sour)Sp#'SultTi*T*atTurnUn]Ve$ViewW?d2Y`m0BBb#CeChDeD+F!GhtGidNgOtPp!SkTu$V$V 5AdA,BotBu,CketM<)OfOkieOmSeTa>UghUndU>Y$5Bb DeGLeNNwayR$:DDd!D}[FeIlLadLm#L#LtLu>MeMp!NdTisfyToshiU)Usa+VeY1A!AnA*Att E}HemeHoolI&)I[%sOrp]OutRapRe&RiptRub1AAr^As#AtC#dC*tCt]Cur.yEdEkGm|Le@~M(?Ni%N'Nt&)RiesRvi)Ss]Tt!TupV&_dowAftAllowA*EdEllEriffIeldIftI}IpIv O{OeOotOpOrtOuld O=RimpRugUff!Y0Bl(gCkDeE+GhtGnL|Lk~yLv Mil?Mp!N)NgR&/ Tua>XZe1A>Et^IIllInIrtUll0AbAmEepEnd I)IdeIghtImOg<OtOwUsh0AllArtI!OkeOo`0A{AkeApIffOw0ApCc Ci$CkDaFtL?Ldi LidLut]L=Me#eNgOnRryRtUlUndUpUr)U`0A)A*Ati$AwnEakEci$EedEllEndH eI)Id IkeInIr.L.OilOns%O#OrtOtRayReadR(gY0Ua*UeezeUir*l_b!AdiumAffA+AirsAmpAndArtA>AyEakEelEmEpE*oI{IllIngO{Oma^O}OolOryO=Ra>gyReetRikeR#gRugg!Ud|UffUmb!Y!0Bje@Bm.BwayC)[ChDd&Ff G?G+,ItMm NNnyN'tP PplyP*meReRfa)R+Rpri'RroundR=ySpe@/a(1AllowAmpApArmE?EetIftImIngIt^Ord1MbolMptomRup/em:B!Ck!GIlL|LkNkPeR+tSk/eTtooXi3A^Am~NN<tNnisNtRm/Xt_nkAtEmeEnE%yE*EyIngIsOughtReeRi=RowUmbUnd 0CketDeG LtMb MeNyPRedSsueT!5A,BaccoDayDdl EGe` I!tK&MatoM%rowNeNgueNightOlO`PP-Pp!R^RnadoRtoi'SsT$Uri,W?dW WnY_{AdeAff-Ag-A(Ansf ApAshA=lAyEatEeEndI$IbeI{Igg ImIpOphyOub!U{UeUlyUmpetU,U`Y2BeIt]Mb!NaN}lRkeyRnRt!1El=EntyI)InI,O1PeP-$:5Ly5B*lla0Ab!Awa*C!Cov D DoFairFoldHappyIf%mIqueItIv 'KnownLo{TilUsu$Veil1Da>GradeHoldOnP Set1B<Ge0A+EEdEfulE![U$0Il.y:C<tCuumGueLidL!yL=NNishP%Rious/Ult3H-!L=tNd%Ntu*NueRbRifyRs]RyS'lT <3Ab!Br<tCiousCt%yDeoEw~a+Nta+Ol(Rtu$RusSaS.Su$T$Vid5C$I)IdLc<oLumeTeYa+:GeG#ItLk~LnutNtRfa*RmRri%ShSp/eT VeY3Al`Ap#ArA'lA` BDd(gEk&dIrdLcome/T_!AtEatEelEnE*IpIsp 0DeD`FeLd~NNdowNeNgNkNn Nt ReSdomSeShT}[5LfM<Nd OdOlRdRkRldRryR`_pE{E,!I,I>Ong::Rd3Ar~ow9UUngU`:3BraRo9NeO",zW="0x3c8acc1e7b08d8e76f9fda015ef48dc8c710a73cb7e0f77b2c18a9b5a7adde60",R5=null;class P8 extends H5{constructor(){super("en",ZW,zW)}static wordlist(){if(R5==null)R5=new P8;return R5}}var Vq=function(Q){return(1<<Q)-1<<8-Q&255},MW=function(Q){return(1<<Q)-1&255},P5=function(Q,Y){if(L9("NFKD"),Y==null)Y=P8.wordlist();const J=Y.split(Q);I(J.length%3===0&&J.length>=12&&J.length<=24,"invalid mnemonic length","mnemonic","[ REDACTED ]");const X=new Uint8Array(Math.ceil(11*J.length/8));let q=0;for(let V=0;V<J.length;V++){let Z=Y.getWordIndex(J[V].normalize("NFKD"));I(Z>=0,`invalid mnemonic word at index ${V}`,"mnemonic","[ REDACTED ]");for(let K=0;K<11;K++){if(Z&1<<10-K)X[q>>3]|=1<<7-q%8;q++}}const G=32*J.length/3,W=J.length/3,U=Vq(W),$=E(O0(X.slice(0,G/8)))[0]&U;return I($===(X[X.length-1]&U),"invalid mnemonic checksum","mnemonic","[ REDACTED ]"),B(X.slice(0,G/8))},C5=function(Q,Y){if(I(Q.length%4===0&&Q.length>=16&&Q.length<=32,"invalid entropy size","entropy","[ REDACTED ]"),Y==null)Y=P8.wordlist();const J=[0];let X=11;for(let W=0;W<Q.length;W++)if(X>8)J[J.length-1]<<=8,J[J.length-1]|=Q[W],X-=8;else J[J.length-1]<<=X,J[J.length-1]|=Q[W]>>8-X,J.push(Q[W]&MW(8-X)),X+=3;const q=Q.length/4,G=parseInt(O0(Q).substring(2,4),16)&Vq(q);return J[J.length-1]<<=q,J[J.length-1]|=G>>8-q,Y.join(J.map((W)=>Y.getWord(W)))},T5={};class C8{phrase;password;wordlist;entropy;constructor(Q,Y,J,X,q){if(X==null)X="";if(q==null)q=P8.wordlist();U8(Q,T5,"Mnemonic"),s(this,{phrase:J,password:X,wordlist:q,entropy:Y})}computeSeed(){const Q=z0("mnemonic"+this.password,"NFKD");return A0(z0(this.phrase,"NFKD"),Q,2048,64,"sha512")}static fromPhrase(Q,Y,J){const X=P5(Q,J);return Q=C5(E(X),J),new C8(T5,X,Q,Y,J)}static fromEntropy(Q,Y,J){const X=E(Q,"entropy"),q=C5(X,J);return new C8(T5,B(X),q,Y,J)}static entropyToPhrase(Q,Y){const J=E(Q,"entropy");return C5(J,Y)}static phraseToEntropy(Q,Y){return P5(Q,Y)}static isValidMnemonic(Q,Y){try{return P5(Q,Y),!0}catch(J){}return!1}}var w5=function(Q){const Y=[];for(let J=0;J<Q.length;J+=4)Y.push(Q[J]<<24|Q[J+1]<<16|Q[J+2]<<8|Q[J+3]);return Y};/*! MIT License. Copyright 2015-2022 Richard Moore <me@ricmoo.com>. See LICENSE.txt. */var I0=function(Q,Y,J,X){if(J==="a"&&!X)throw new TypeError("Private accessor was defined without a getter");if(typeof Y==="function"?Q!==Y||!X:!Y.has(Q))throw new TypeError("Cannot read private member from an object whose class did not declare it");return J==="m"?X:J==="a"?X.call(Q):X?X.value:Y.get(Q)},N5=function(Q,Y,J,X,q){if(X==="m")throw new TypeError("Private method is not writable");if(X==="a"&&!q)throw new TypeError("Private accessor was defined without a setter");if(typeof Y==="function"?Q!==Y||!q:!Y.has(Q))throw new TypeError("Cannot write private member to an object whose class did not declare it");return X==="a"?q.call(Q,J):q?q.value=J:Y.set(Q,J),J},VJ,h0,e0,KW={16:10,24:12,32:14},jW=[1,2,4,8,16,32,64,128,27,54,108,216,171,77,154,47,94,188,99,198,151,53,106,212,179,125,250,239,197,145],y0=[99,124,119,123,242,107,111,197,48,1,103,43,254,215,171,118,202,130,201,125,250,89,71,240,173,212,162,175,156,164,114,192,183,253,147,38,54,63,247,204,52,165,229,241,113,216,49,21,4,199,35,195,24,150,5,154,7,18,128,226,235,39,178,117,9,131,44,26,27,110,90,160,82,59,214,179,41,227,47,132,83,209,0,237,32,252,177,91,106,203,190,57,74,76,88,207,208,239,170,251,67,77,51,133,69,249,2,127,80,60,159,168,81,163,64,143,146,157,56,245,188,182,218,33,16,255,243,210,205,12,19,236,95,151,68,23,196,167,126,61,100,93,25,115,96,129,79,220,34,42,144,136,70,238,184,20,222,94,11,219,224,50,58,10,73,6,36,92,194,211,172,98,145,149,228,121,231,200,55,109,141,213,78,169,108,86,244,234,101,122,174,8,186,120,37,46,28,166,180,198,232,221,116,31,75,189,139,138,112,62,181,102,72,3,246,14,97,53,87,185,134,193,29,158,225,248,152,17,105,217,142,148,155,30,135,233,206,85,40,223,140,161,137,13,191,230,66,104,65,153,45,15,176,84,187,22],UJ=[82,9,106,213,48,54,165,56,191,64,163,158,129,243,215,251,124,227,57,130,155,47,255,135,52,142,67,68,196,222,233,203,84,123,148,50,166,194,35,61,238,76,149,11,66,250,195,78,8,46,161,102,40,217,36,178,118,91,162,73,109,139,209,37,114,248,246,100,134,104,152,22,212,164,92,204,93,101,182,146,108,112,72,80,253,237,185,218,94,21,70,87,167,141,157,132,144,216,171,0,140,188,211,10,247,228,88,5,184,179,69,6,208,44,30,143,202,63,15,2,193,175,189,3,1,19,138,107,58,145,17,65,79,103,220,234,151,242,207,206,240,180,230,115,150,172,116,34,231,173,53,133,226,249,55,232,28,117,223,110,71,241,26,113,29,41,197,137,111,183,98,14,170,24,190,27,252,86,62,75,198,210,121,32,154,219,192,254,120,205,90,244,31,221,168,51,136,7,199,49,177,18,16,89,39,128,236,95,96,81,127,169,25,181,74,13,45,229,122,159,147,201,156,239,160,224,59,77,174,42,245,176,200,235,187,60,131,83,153,97,23,43,4,126,186,119,214,38,225,105,20,99,85,33,12,125],OW=[3328402341,4168907908,4000806809,4135287693,4294111757,3597364157,3731845041,2445657428,1613770832,33620227,3462883241,1445669757,3892248089,3050821474,1303096294,3967186586,2412431941,528646813,2311702848,4202528135,4026202645,2992200171,2387036105,4226871307,1101901292,3017069671,1604494077,1169141738,597466303,1403299063,3832705686,2613100635,1974974402,3791519004,1033081774,1277568618,1815492186,2118074177,4126668546,2211236943,1748251740,1369810420,3521504564,4193382664,3799085459,2883115123,1647391059,706024767,134480908,2512897874,1176707941,2646852446,806885416,932615841,168101135,798661301,235341577,605164086,461406363,3756188221,3454790438,1311188841,2142417613,3933566367,302582043,495158174,1479289972,874125870,907746093,3698224818,3025820398,1537253627,2756858614,1983593293,3084310113,2108928974,1378429307,3722699582,1580150641,327451799,2790478837,3117535592,0,3253595436,1075847264,3825007647,2041688520,3059440621,3563743934,2378943302,1740553945,1916352843,2487896798,2555137236,2958579944,2244988746,3151024235,3320835882,1336584933,3992714006,2252555205,2588757463,1714631509,293963156,2319795663,3925473552,67240454,4269768577,2689618160,2017213508,631218106,1269344483,2723238387,1571005438,2151694528,93294474,1066570413,563977660,1882732616,4059428100,1673313503,2008463041,2950355573,1109467491,537923632,3858759450,4260623118,3218264685,2177748300,403442708,638784309,3287084079,3193921505,899127202,2286175436,773265209,2479146071,1437050866,4236148354,2050833735,3362022572,3126681063,840505643,3866325909,3227541664,427917720,2655997905,2749160575,1143087718,1412049534,999329963,193497219,2353415882,3354324521,1807268051,672404540,2816401017,3160301282,369822493,2916866934,3688947771,1681011286,1949973070,336202270,2454276571,201721354,1210328172,3093060836,2680341085,3184776046,1135389935,3294782118,965841320,831886756,3554993207,4068047243,3588745010,2345191491,1849112409,3664604599,26054028,2983581028,2622377682,1235855840,3630984372,2891339514,4092916743,3488279077,3395642799,4101667470,1202630377,268961816,1874508501,4034427016,1243948399,1546530418,941366308,1470539505,1941222599,2546386513,3421038627,2715671932,3899946140,1042226977,2521517021,1639824860,227249030,260737669,3765465232,2084453954,1907733956,3429263018,2420656344,100860677,4160157185,470683154,3261161891,1781871967,2924959737,1773779408,394692241,2579611992,974986535,664706745,3655459128,3958962195,731420851,571543859,3530123707,2849626480,126783113,865375399,765172662,1008606754,361203602,3387549984,2278477385,2857719295,1344809080,2782912378,59542671,1503764984,160008576,437062935,1707065306,3622233649,2218934982,3496503480,2185314755,697932208,1512910199,504303377,2075177163,2824099068,1841019862,739644986],IW=[2781242211,2230877308,2582542199,2381740923,234877682,3184946027,2984144751,1418839493,1348481072,50462977,2848876391,2102799147,434634494,1656084439,3863849899,2599188086,1167051466,2636087938,1082771913,2281340285,368048890,3954334041,3381544775,201060592,3963727277,1739838676,4250903202,3930435503,3206782108,4149453988,2531553906,1536934080,3262494647,484572669,2923271059,1783375398,1517041206,1098792767,49674231,1334037708,1550332980,4098991525,886171109,150598129,2481090929,1940642008,1398944049,1059722517,201851908,1385547719,1699095331,1587397571,674240536,2704774806,252314885,3039795866,151914247,908333586,2602270848,1038082786,651029483,1766729511,3447698098,2682942837,454166793,2652734339,1951935532,775166490,758520603,3000790638,4004797018,4217086112,4137964114,1299594043,1639438038,3464344499,2068982057,1054729187,1901997871,2534638724,4121318227,1757008337,0,750906861,1614815264,535035132,3363418545,3988151131,3201591914,1183697867,3647454910,1265776953,3734260298,3566750796,3903871064,1250283471,1807470800,717615087,3847203498,384695291,3313910595,3617213773,1432761139,2484176261,3481945413,283769337,100925954,2180939647,4037038160,1148730428,3123027871,3813386408,4087501137,4267549603,3229630528,2315620239,2906624658,3156319645,1215313976,82966005,3747855548,3245848246,1974459098,1665278241,807407632,451280895,251524083,1841287890,1283575245,337120268,891687699,801369324,3787349855,2721421207,3431482436,959321879,1469301956,4065699751,2197585534,1199193405,2898814052,3887750493,724703513,2514908019,2696962144,2551808385,3516813135,2141445340,1715741218,2119445034,2872807568,2198571144,3398190662,700968686,3547052216,1009259540,2041044702,3803995742,487983883,1991105499,1004265696,1449407026,1316239930,504629770,3683797321,168560134,1816667172,3837287516,1570751170,1857934291,4014189740,2797888098,2822345105,2754712981,936633572,2347923833,852879335,1133234376,1500395319,3084545389,2348912013,1689376213,3533459022,3762923945,3034082412,4205598294,133428468,634383082,2949277029,2398386810,3913789102,403703816,3580869306,2297460856,1867130149,1918643758,607656988,4049053350,3346248884,1368901318,600565992,2090982877,2632479860,557719327,3717614411,3697393085,2249034635,2232388234,2430627952,1115438654,3295786421,2865522278,3633334344,84280067,33027830,303828494,2747425121,1600795957,4188952407,3496589753,2434238086,1486471617,658119965,3106381470,953803233,334231800,3005978776,857870609,3151128937,1890179545,2298973838,2805175444,3056442267,574365214,2450884487,550103529,1233637070,4289353045,2018519080,2057691103,2399374476,4166623649,2148108681,387583245,3664101311,836232934,3330556482,3100665960,3280093505,2955516313,2002398509,287182607,3413881008,4238890068,3597515707,975967766],LW=[1671808611,2089089148,2006576759,2072901243,4061003762,1807603307,1873927791,3310653893,810573872,16974337,1739181671,729634347,4263110654,3613570519,2883997099,1989864566,3393556426,2191335298,3376449993,2106063485,4195741690,1508618841,1204391495,4027317232,2917941677,3563566036,2734514082,2951366063,2629772188,2767672228,1922491506,3227229120,3082974647,4246528509,2477669779,644500518,911895606,1061256767,4144166391,3427763148,878471220,2784252325,3845444069,4043897329,1905517169,3631459288,827548209,356461077,67897348,3344078279,593839651,3277757891,405286936,2527147926,84871685,2595565466,118033927,305538066,2157648768,3795705826,3945188843,661212711,2999812018,1973414517,152769033,2208177539,745822252,439235610,455947803,1857215598,1525593178,2700827552,1391895634,994932283,3596728278,3016654259,695947817,3812548067,795958831,2224493444,1408607827,3513301457,0,3979133421,543178784,4229948412,2982705585,1542305371,1790891114,3410398667,3201918910,961245753,1256100938,1289001036,1491644504,3477767631,3496721360,4012557807,2867154858,4212583931,1137018435,1305975373,861234739,2241073541,1171229253,4178635257,33948674,2139225727,1357946960,1011120188,2679776671,2833468328,1374921297,2751356323,1086357568,2408187279,2460827538,2646352285,944271416,4110742005,3168756668,3066132406,3665145818,560153121,271589392,4279952895,4077846003,3530407890,3444343245,202643468,322250259,3962553324,1608629855,2543990167,1154254916,389623319,3294073796,2817676711,2122513534,1028094525,1689045092,1575467613,422261273,1939203699,1621147744,2174228865,1339137615,3699352540,577127458,712922154,2427141008,2290289544,1187679302,3995715566,3100863416,339486740,3732514782,1591917662,186455563,3681988059,3762019296,844522546,978220090,169743370,1239126601,101321734,611076132,1558493276,3260915650,3547250131,2901361580,1655096418,2443721105,2510565781,3828863972,2039214713,3878868455,3359869896,928607799,1840765549,2374762893,3580146133,1322425422,2850048425,1823791212,1459268694,4094161908,3928346602,1706019429,2056189050,2934523822,135794696,3134549946,2022240376,628050469,779246638,472135708,2800834470,3032970164,3327236038,3894660072,3715932637,1956440180,522272287,1272813131,3185336765,2340818315,2323976074,1888542832,1044544574,3049550261,1722469478,1222152264,50660867,4127324150,236067854,1638122081,895445557,1475980887,3117443513,2257655686,3243809217,489110045,2662934430,3778599393,4162055160,2561878936,288563729,1773916777,3648039385,2391345038,2493985684,2612407707,505560094,2274497927,3911240169,3460925390,1442818645,678973480,3749357023,2358182796,2717407649,2306869641,219617805,3218761151,3862026214,1120306242,1756942440,1103331905,2578459033,762796589,252780047,2966125488,1425844308,3151392187,372911126],DW=[1667474886,2088535288,2004326894,2071694838,4075949567,1802223062,1869591006,3318043793,808472672,16843522,1734846926,724270422,4278065639,3621216949,2880169549,1987484396,3402253711,2189597983,3385409673,2105378810,4210693615,1499065266,1195886990,4042263547,2913856577,3570689971,2728590687,2947541573,2627518243,2762274643,1920112356,3233831835,3082273397,4261223649,2475929149,640051788,909531756,1061110142,4160160501,3435941763,875846760,2779116625,3857003729,4059105529,1903268834,3638064043,825316194,353713962,67374088,3351728789,589522246,3284360861,404236336,2526454071,84217610,2593830191,117901582,303183396,2155911963,3806477791,3958056653,656894286,2998062463,1970642922,151591698,2206440989,741110872,437923380,454765878,1852748508,1515908788,2694904667,1381168804,993742198,3604373943,3014905469,690584402,3823320797,791638366,2223281939,1398011302,3520161977,0,3991743681,538992704,4244381667,2981218425,1532751286,1785380564,3419096717,3200178535,960056178,1246420628,1280103576,1482221744,3486468741,3503319995,4025428677,2863326543,4227536621,1128514950,1296947098,859002214,2240123921,1162203018,4193849577,33687044,2139062782,1347481760,1010582648,2678045221,2829640523,1364325282,2745433693,1077985408,2408548869,2459086143,2644360225,943212656,4126475505,3166494563,3065430391,3671750063,555836226,269496352,4294908645,4092792573,3537006015,3452783745,202118168,320025894,3974901699,1600119230,2543297077,1145359496,387397934,3301201811,2812801621,2122220284,1027426170,1684319432,1566435258,421079858,1936954854,1616945344,2172753945,1330631070,3705438115,572679748,707427924,2425400123,2290647819,1179044492,4008585671,3099120491,336870440,3739122087,1583276732,185277718,3688593069,3772791771,842159716,976899700,168435220,1229577106,101059084,606366792,1549591736,3267517855,3553849021,2897014595,1650632388,2442242105,2509612081,3840161747,2038008818,3890688725,3368567691,926374254,1835907034,2374863873,3587531953,1313788572,2846482505,1819063512,1448540844,4109633523,3941213647,1701162954,2054852340,2930698567,134748176,3132806511,2021165296,623210314,774795868,471606328,2795958615,3031746419,3334885783,3907527627,3722280097,1953799400,522133822,1263263126,3183336545,2341176845,2324333839,1886425312,1044267644,3048588401,1718004428,1212733584,50529542,4143317495,235803164,1633788866,892690282,1465383342,3115962473,2256965911,3250673817,488449850,2661202215,3789633753,4177007595,2560144171,286339874,1768537042,3654906025,2391705863,2492770099,2610673197,505291324,2273808917,3924369609,3469625735,1431699370,673740880,3755965093,2358021891,2711746649,2307489801,218961690,3217021541,3873845719,1111672452,1751693520,1094828930,2576986153,757954394,252645662,2964376443,1414855848,3149649517,370555436],HW=[1374988112,2118214995,437757123,975658646,1001089995,530400753,2902087851,1273168787,540080725,2910219766,2295101073,4110568485,1340463100,3307916247,641025152,3043140495,3736164937,632953703,1172967064,1576976609,3274667266,2169303058,2370213795,1809054150,59727847,361929877,3211623147,2505202138,3569255213,1484005843,1239443753,2395588676,1975683434,4102977912,2572697195,666464733,3202437046,4035489047,3374361702,2110667444,1675577880,3843699074,2538681184,1649639237,2976151520,3144396420,4269907996,4178062228,1883793496,2403728665,2497604743,1383856311,2876494627,1917518562,3810496343,1716890410,3001755655,800440835,2261089178,3543599269,807962610,599762354,33778362,3977675356,2328828971,2809771154,4077384432,1315562145,1708848333,101039829,3509871135,3299278474,875451293,2733856160,92987698,2767645557,193195065,1080094634,1584504582,3178106961,1042385657,2531067453,3711829422,1306967366,2438237621,1908694277,67556463,1615861247,429456164,3602770327,2302690252,1742315127,2968011453,126454664,3877198648,2043211483,2709260871,2084704233,4169408201,0,159417987,841739592,504459436,1817866830,4245618683,260388950,1034867998,908933415,168810852,1750902305,2606453969,607530554,202008497,2472011535,3035535058,463180190,2160117071,1641816226,1517767529,470948374,3801332234,3231722213,1008918595,303765277,235474187,4069246893,766945465,337553864,1475418501,2943682380,4003061179,2743034109,4144047775,1551037884,1147550661,1543208500,2336434550,3408119516,3069049960,3102011747,3610369226,1113818384,328671808,2227573024,2236228733,3535486456,2935566865,3341394285,496906059,3702665459,226906860,2009195472,733156972,2842737049,294930682,1206477858,2835123396,2700099354,1451044056,573804783,2269728455,3644379585,2362090238,2564033334,2801107407,2776292904,3669462566,1068351396,742039012,1350078989,1784663195,1417561698,4136440770,2430122216,775550814,2193862645,2673705150,1775276924,1876241833,3475313331,3366754619,270040487,3902563182,3678124923,3441850377,1851332852,3969562369,2203032232,3868552805,2868897406,566021896,4011190502,3135740889,1248802510,3936291284,699432150,832877231,708780849,3332740144,899835584,1951317047,4236429990,3767586992,866637845,4043610186,1106041591,2144161806,395441711,1984812685,1139781709,3433712980,3835036895,2664543715,1282050075,3240894392,1181045119,2640243204,25965917,4203181171,4211818798,3009879386,2463879762,3910161971,1842759443,2597806476,933301370,1509430414,3943906441,3467192302,3076639029,3776767469,2051518780,2631065433,1441952575,404016761,1942435775,1408749034,1610459739,3745345300,2017778566,3400528769,3110650942,941896748,3265478751,371049330,3168937228,675039627,4279080257,967311729,135050206,3635733660,1683407248,2076935265,3576870512,1215061108,3501741890],RW=[1347548327,1400783205,3273267108,2520393566,3409685355,4045380933,2880240216,2471224067,1428173050,4138563181,2441661558,636813900,4233094615,3620022987,2149987652,2411029155,1239331162,1730525723,2554718734,3781033664,46346101,310463728,2743944855,3328955385,3875770207,2501218972,3955191162,3667219033,768917123,3545789473,692707433,1150208456,1786102409,2029293177,1805211710,3710368113,3065962831,401639597,1724457132,3028143674,409198410,2196052529,1620529459,1164071807,3769721975,2226875310,486441376,2499348523,1483753576,428819965,2274680428,3075636216,598438867,3799141122,1474502543,711349675,129166120,53458370,2592523643,2782082824,4063242375,2988687269,3120694122,1559041666,730517276,2460449204,4042459122,2706270690,3446004468,3573941694,533804130,2328143614,2637442643,2695033685,839224033,1973745387,957055980,2856345839,106852767,1371368976,4181598602,1033297158,2933734917,1179510461,3046200461,91341917,1862534868,4284502037,605657339,2547432937,3431546947,2003294622,3182487618,2282195339,954669403,3682191598,1201765386,3917234703,3388507166,0,2198438022,1211247597,2887651696,1315723890,4227665663,1443857720,507358933,657861945,1678381017,560487590,3516619604,975451694,2970356327,261314535,3535072918,2652609425,1333838021,2724322336,1767536459,370938394,182621114,3854606378,1128014560,487725847,185469197,2918353863,3106780840,3356761769,2237133081,1286567175,3152976349,4255350624,2683765030,3160175349,3309594171,878443390,1988838185,3704300486,1756818940,1673061617,3403100636,272786309,1075025698,545572369,2105887268,4174560061,296679730,1841768865,1260232239,4091327024,3960309330,3497509347,1814803222,2578018489,4195456072,575138148,3299409036,446754879,3629546796,4011996048,3347532110,3252238545,4270639778,915985419,3483825537,681933534,651868046,2755636671,3828103837,223377554,2607439820,1649704518,3270937875,3901806776,1580087799,4118987695,3198115200,2087309459,2842678573,3016697106,1003007129,2802849917,1860738147,2077965243,164439672,4100872472,32283319,2827177882,1709610350,2125135846,136428751,3874428392,3652904859,3460984630,3572145929,3593056380,2939266226,824852259,818324884,3224740454,930369212,2801566410,2967507152,355706840,1257309336,4148292826,243256656,790073846,2373340630,1296297904,1422699085,3756299780,3818836405,457992840,3099667487,2135319889,77422314,1560382517,1945798516,788204353,1521706781,1385356242,870912086,325965383,2358957921,2050466060,2388260884,2313884476,4006521127,901210569,3990953189,1014646705,1503449823,1062597235,2031621326,3212035895,3931371469,1533017514,350174575,2256028891,2177544179,1052338372,741876788,1606591296,1914052035,213705253,2334669897,1107234197,1899603969,3725069491,2631447780,2422494913,1635502980,1893020342,1950903388,1120974935],PW=[2807058932,1699970625,2764249623,1586903591,1808481195,1173430173,1487645946,59984867,4199882800,1844882806,1989249228,1277555970,3623636965,3419915562,1149249077,2744104290,1514790577,459744698,244860394,3235995134,1963115311,4027744588,2544078150,4190530515,1608975247,2627016082,2062270317,1507497298,2200818878,567498868,1764313568,3359936201,2305455554,2037970062,1047239000,1910319033,1337376481,2904027272,2892417312,984907214,1243112415,830661914,861968209,2135253587,2011214180,2927934315,2686254721,731183368,1750626376,4246310725,1820824798,4172763771,3542330227,48394827,2404901663,2871682645,671593195,3254988725,2073724613,145085239,2280796200,2779915199,1790575107,2187128086,472615631,3029510009,4075877127,3802222185,4107101658,3201631749,1646252340,4270507174,1402811438,1436590835,3778151818,3950355702,3963161475,4020912224,2667994737,273792366,2331590177,104699613,95345982,3175501286,2377486676,1560637892,3564045318,369057872,4213447064,3919042237,1137477952,2658625497,1119727848,2340947849,1530455833,4007360968,172466556,266959938,516552836,0,2256734592,3980931627,1890328081,1917742170,4294704398,945164165,3575528878,958871085,3647212047,2787207260,1423022939,775562294,1739656202,3876557655,2530391278,2443058075,3310321856,547512796,1265195639,437656594,3121275539,719700128,3762502690,387781147,218828297,3350065803,2830708150,2848461854,428169201,122466165,3720081049,1627235199,648017665,4122762354,1002783846,2117360635,695634755,3336358691,4234721005,4049844452,3704280881,2232435299,574624663,287343814,612205898,1039717051,840019705,2708326185,793451934,821288114,1391201670,3822090177,376187827,3113855344,1224348052,1679968233,2361698556,1058709744,752375421,2431590963,1321699145,3519142200,2734591178,188127444,2177869557,3727205754,2384911031,3215212461,2648976442,2450346104,3432737375,1180849278,331544205,3102249176,4150144569,2952102595,2159976285,2474404304,766078933,313773861,2570832044,2108100632,1668212892,3145456443,2013908262,418672217,3070356634,2594734927,1852171925,3867060991,3473416636,3907448597,2614737639,919489135,164948639,2094410160,2997825956,590424639,2486224549,1723872674,3157750862,3399941250,3501252752,3625268135,2555048196,3673637356,1343127501,4130281361,3599595085,2957853679,1297403050,81781910,3051593425,2283490410,532201772,1367295589,3926170974,895287692,1953757831,1093597963,492483431,3528626907,1446242576,1192455638,1636604631,209336225,344873464,1015671571,669961897,3375740769,3857572124,2973530695,3747192018,1933530610,3464042516,935293895,3454686199,2858115069,1863638845,3683022916,4085369519,3292445032,875313188,1080017571,3279033885,621591778,1233856572,2504130317,24197544,3017672716,3835484340,3247465558,2220981195,3060847922,1551124588,1463996600],CW=[4104605777,1097159550,396673818,660510266,2875968315,2638606623,4200115116,3808662347,821712160,1986918061,3430322568,38544885,3856137295,718002117,893681702,1654886325,2975484382,3122358053,3926825029,4274053469,796197571,1290801793,1184342925,3556361835,2405426947,2459735317,1836772287,1381620373,3196267988,1948373848,3764988233,3385345166,3263785589,2390325492,1480485785,3111247143,3780097726,2293045232,548169417,3459953789,3746175075,439452389,1362321559,1400849762,1685577905,1806599355,2174754046,137073913,1214797936,1174215055,3731654548,2079897426,1943217067,1258480242,529487843,1437280870,3945269170,3049390895,3313212038,923313619,679998000,3215307299,57326082,377642221,3474729866,2041877159,133361907,1776460110,3673476453,96392454,878845905,2801699524,777231668,4082475170,2330014213,4142626212,2213296395,1626319424,1906247262,1846563261,562755902,3708173718,1040559837,3871163981,1418573201,3294430577,114585348,1343618912,2566595609,3186202582,1078185097,3651041127,3896688048,2307622919,425408743,3371096953,2081048481,1108339068,2216610296,0,2156299017,736970802,292596766,1517440620,251657213,2235061775,2933202493,758720310,265905162,1554391400,1532285339,908999204,174567692,1474760595,4002861748,2610011675,3234156416,3693126241,2001430874,303699484,2478443234,2687165888,585122620,454499602,151849742,2345119218,3064510765,514443284,4044981591,1963412655,2581445614,2137062819,19308535,1928707164,1715193156,4219352155,1126790795,600235211,3992742070,3841024952,836553431,1669664834,2535604243,3323011204,1243905413,3141400786,4180808110,698445255,2653899549,2989552604,2253581325,3252932727,3004591147,1891211689,2487810577,3915653703,4237083816,4030667424,2100090966,865136418,1229899655,953270745,3399679628,3557504664,4118925222,2061379749,3079546586,2915017791,983426092,2022837584,1607244650,2118541908,2366882550,3635996816,972512814,3283088770,1568718495,3499326569,3576539503,621982671,2895723464,410887952,2623762152,1002142683,645401037,1494807662,2595684844,1335535747,2507040230,4293295786,3167684641,367585007,3885750714,1865862730,2668221674,2960971305,2763173681,1059270954,2777952454,2724642869,1320957812,2194319100,2429595872,2815956275,77089521,3973773121,3444575871,2448830231,1305906550,4021308739,2857194700,2516901860,3518358430,1787304780,740276417,1699839814,1592394909,2352307457,2272556026,188821243,1729977011,3687994002,274084841,3594982253,3613494426,2701949495,4162096729,322734571,2837966542,1640576439,484830689,1202797690,3537852828,4067639125,349075736,3342319475,4157467219,4255800159,1030690015,1155237496,2951971274,1757691577,607398968,2738905026,499347990,3794078908,1011452712,227885567,2818666809,213114376,3034881240,1455525988,3414450555,850817237,1817998408,3092726480],TW=[0,235474187,470948374,303765277,941896748,908933415,607530554,708780849,1883793496,2118214995,1817866830,1649639237,1215061108,1181045119,1417561698,1517767529,3767586992,4003061179,4236429990,4069246893,3635733660,3602770327,3299278474,3400528769,2430122216,2664543715,2362090238,2193862645,2835123396,2801107407,3035535058,3135740889,3678124923,3576870512,3341394285,3374361702,3810496343,3977675356,4279080257,4043610186,2876494627,2776292904,3076639029,3110650942,2472011535,2640243204,2403728665,2169303058,1001089995,899835584,666464733,699432150,59727847,226906860,530400753,294930682,1273168787,1172967064,1475418501,1509430414,1942435775,2110667444,1876241833,1641816226,2910219766,2743034109,2976151520,3211623147,2505202138,2606453969,2302690252,2269728455,3711829422,3543599269,3240894392,3475313331,3843699074,3943906441,4178062228,4144047775,1306967366,1139781709,1374988112,1610459739,1975683434,2076935265,1775276924,1742315127,1034867998,866637845,566021896,800440835,92987698,193195065,429456164,395441711,1984812685,2017778566,1784663195,1683407248,1315562145,1080094634,1383856311,1551037884,101039829,135050206,437757123,337553864,1042385657,807962610,573804783,742039012,2531067453,2564033334,2328828971,2227573024,2935566865,2700099354,3001755655,3168937228,3868552805,3902563182,4203181171,4102977912,3736164937,3501741890,3265478751,3433712980,1106041591,1340463100,1576976609,1408749034,2043211483,2009195472,1708848333,1809054150,832877231,1068351396,766945465,599762354,159417987,126454664,361929877,463180190,2709260871,2943682380,3178106961,3009879386,2572697195,2538681184,2236228733,2336434550,3509871135,3745345300,3441850377,3274667266,3910161971,3877198648,4110568485,4211818798,2597806476,2497604743,2261089178,2295101073,2733856160,2902087851,3202437046,2968011453,3936291284,3835036895,4136440770,4169408201,3535486456,3702665459,3467192302,3231722213,2051518780,1951317047,1716890410,1750902305,1113818384,1282050075,1584504582,1350078989,168810852,67556463,371049330,404016761,841739592,1008918595,775550814,540080725,3969562369,3801332234,4035489047,4269907996,3569255213,3669462566,3366754619,3332740144,2631065433,2463879762,2160117071,2395588676,2767645557,2868897406,3102011747,3069049960,202008497,33778362,270040487,504459436,875451293,975658646,675039627,641025152,2084704233,1917518562,1615861247,1851332852,1147550661,1248802510,1484005843,1451044056,933301370,967311729,733156972,632953703,260388950,25965917,328671808,496906059,1206477858,1239443753,1543208500,1441952575,2144161806,1908694277,1675577880,1842759443,3610369226,3644379585,3408119516,3307916247,4011190502,3776767469,4077384432,4245618683,2809771154,2842737049,3144396420,3043140495,2673705150,2438237621,2203032232,2370213795],NW=[0,185469197,370938394,487725847,741876788,657861945,975451694,824852259,1483753576,1400783205,1315723890,1164071807,1950903388,2135319889,1649704518,1767536459,2967507152,3152976349,2801566410,2918353863,2631447780,2547432937,2328143614,2177544179,3901806776,3818836405,4270639778,4118987695,3299409036,3483825537,3535072918,3652904859,2077965243,1893020342,1841768865,1724457132,1474502543,1559041666,1107234197,1257309336,598438867,681933534,901210569,1052338372,261314535,77422314,428819965,310463728,3409685355,3224740454,3710368113,3593056380,3875770207,3960309330,4045380933,4195456072,2471224067,2554718734,2237133081,2388260884,3212035895,3028143674,2842678573,2724322336,4138563181,4255350624,3769721975,3955191162,3667219033,3516619604,3431546947,3347532110,2933734917,2782082824,3099667487,3016697106,2196052529,2313884476,2499348523,2683765030,1179510461,1296297904,1347548327,1533017514,1786102409,1635502980,2087309459,2003294622,507358933,355706840,136428751,53458370,839224033,957055980,605657339,790073846,2373340630,2256028891,2607439820,2422494913,2706270690,2856345839,3075636216,3160175349,3573941694,3725069491,3273267108,3356761769,4181598602,4063242375,4011996048,3828103837,1033297158,915985419,730517276,545572369,296679730,446754879,129166120,213705253,1709610350,1860738147,1945798516,2029293177,1239331162,1120974935,1606591296,1422699085,4148292826,4233094615,3781033664,3931371469,3682191598,3497509347,3446004468,3328955385,2939266226,2755636671,3106780840,2988687269,2198438022,2282195339,2501218972,2652609425,1201765386,1286567175,1371368976,1521706781,1805211710,1620529459,2105887268,1988838185,533804130,350174575,164439672,46346101,870912086,954669403,636813900,788204353,2358957921,2274680428,2592523643,2441661558,2695033685,2880240216,3065962831,3182487618,3572145929,3756299780,3270937875,3388507166,4174560061,4091327024,4006521127,3854606378,1014646705,930369212,711349675,560487590,272786309,457992840,106852767,223377554,1678381017,1862534868,1914052035,2031621326,1211247597,1128014560,1580087799,1428173050,32283319,182621114,401639597,486441376,768917123,651868046,1003007129,818324884,1503449823,1385356242,1333838021,1150208456,1973745387,2125135846,1673061617,1756818940,2970356327,3120694122,2802849917,2887651696,2637442643,2520393566,2334669897,2149987652,3917234703,3799141122,4284502037,4100872472,3309594171,3460984630,3545789473,3629546796,2050466060,1899603969,1814803222,1730525723,1443857720,1560382517,1075025698,1260232239,575138148,692707433,878443390,1062597235,243256656,91341917,409198410,325965383,3403100636,3252238545,3704300486,3620022987,3874428392,3990953189,4042459122,4227665663,2460449204,2578018489,2226875310,2411029155,3198115200,3046200461,2827177882,2743944855],wW=[0,218828297,437656594,387781147,875313188,958871085,775562294,590424639,1750626376,1699970625,1917742170,2135253587,1551124588,1367295589,1180849278,1265195639,3501252752,3720081049,3399941250,3350065803,3835484340,3919042237,4270507174,4085369519,3102249176,3051593425,2734591178,2952102595,2361698556,2177869557,2530391278,2614737639,3145456443,3060847922,2708326185,2892417312,2404901663,2187128086,2504130317,2555048196,3542330227,3727205754,3375740769,3292445032,3876557655,3926170974,4246310725,4027744588,1808481195,1723872674,1910319033,2094410160,1608975247,1391201670,1173430173,1224348052,59984867,244860394,428169201,344873464,935293895,984907214,766078933,547512796,1844882806,1627235199,2011214180,2062270317,1507497298,1423022939,1137477952,1321699145,95345982,145085239,532201772,313773861,830661914,1015671571,731183368,648017665,3175501286,2957853679,2807058932,2858115069,2305455554,2220981195,2474404304,2658625497,3575528878,3625268135,3473416636,3254988725,3778151818,3963161475,4213447064,4130281361,3599595085,3683022916,3432737375,3247465558,3802222185,4020912224,4172763771,4122762354,3201631749,3017672716,2764249623,2848461854,2331590177,2280796200,2431590963,2648976442,104699613,188127444,472615631,287343814,840019705,1058709744,671593195,621591778,1852171925,1668212892,1953757831,2037970062,1514790577,1463996600,1080017571,1297403050,3673637356,3623636965,3235995134,3454686199,4007360968,3822090177,4107101658,4190530515,2997825956,3215212461,2830708150,2779915199,2256734592,2340947849,2627016082,2443058075,172466556,122466165,273792366,492483431,1047239000,861968209,612205898,695634755,1646252340,1863638845,2013908262,1963115311,1446242576,1530455833,1277555970,1093597963,1636604631,1820824798,2073724613,1989249228,1436590835,1487645946,1337376481,1119727848,164948639,81781910,331544205,516552836,1039717051,821288114,669961897,719700128,2973530695,3157750862,2871682645,2787207260,2232435299,2283490410,2667994737,2450346104,3647212047,3564045318,3279033885,3464042516,3980931627,3762502690,4150144569,4199882800,3070356634,3121275539,2904027272,2686254721,2200818878,2384911031,2570832044,2486224549,3747192018,3528626907,3310321856,3359936201,3950355702,3867060991,4049844452,4234721005,1739656202,1790575107,2108100632,1890328081,1402811438,1586903591,1233856572,1149249077,266959938,48394827,369057872,418672217,1002783846,919489135,567498868,752375421,209336225,24197544,376187827,459744698,945164165,895287692,574624663,793451934,1679968233,1764313568,2117360635,1933530610,1343127501,1560637892,1243112415,1192455638,3704280881,3519142200,3336358691,3419915562,3907448597,3857572124,4075877127,4294704398,3029510009,3113855344,2927934315,2744104290,2159976285,2377486676,2594734927,2544078150],FW=[0,151849742,303699484,454499602,607398968,758720310,908999204,1059270954,1214797936,1097159550,1517440620,1400849762,1817998408,1699839814,2118541908,2001430874,2429595872,2581445614,2194319100,2345119218,3034881240,3186202582,2801699524,2951971274,3635996816,3518358430,3399679628,3283088770,4237083816,4118925222,4002861748,3885750714,1002142683,850817237,698445255,548169417,529487843,377642221,227885567,77089521,1943217067,2061379749,1640576439,1757691577,1474760595,1592394909,1174215055,1290801793,2875968315,2724642869,3111247143,2960971305,2405426947,2253581325,2638606623,2487810577,3808662347,3926825029,4044981591,4162096729,3342319475,3459953789,3576539503,3693126241,1986918061,2137062819,1685577905,1836772287,1381620373,1532285339,1078185097,1229899655,1040559837,923313619,740276417,621982671,439452389,322734571,137073913,19308535,3871163981,4021308739,4104605777,4255800159,3263785589,3414450555,3499326569,3651041127,2933202493,2815956275,3167684641,3049390895,2330014213,2213296395,2566595609,2448830231,1305906550,1155237496,1607244650,1455525988,1776460110,1626319424,2079897426,1928707164,96392454,213114376,396673818,514443284,562755902,679998000,865136418,983426092,3708173718,3557504664,3474729866,3323011204,4180808110,4030667424,3945269170,3794078908,2507040230,2623762152,2272556026,2390325492,2975484382,3092726480,2738905026,2857194700,3973773121,3856137295,4274053469,4157467219,3371096953,3252932727,3673476453,3556361835,2763173681,2915017791,3064510765,3215307299,2156299017,2307622919,2459735317,2610011675,2081048481,1963412655,1846563261,1729977011,1480485785,1362321559,1243905413,1126790795,878845905,1030690015,645401037,796197571,274084841,425408743,38544885,188821243,3613494426,3731654548,3313212038,3430322568,4082475170,4200115116,3780097726,3896688048,2668221674,2516901860,2366882550,2216610296,3141400786,2989552604,2837966542,2687165888,1202797690,1320957812,1437280870,1554391400,1669664834,1787304780,1906247262,2022837584,265905162,114585348,499347990,349075736,736970802,585122620,972512814,821712160,2595684844,2478443234,2293045232,2174754046,3196267988,3079546586,2895723464,2777952454,3537852828,3687994002,3234156416,3385345166,4142626212,4293295786,3841024952,3992742070,174567692,57326082,410887952,292596766,777231668,660510266,1011452712,893681702,1108339068,1258480242,1343618912,1494807662,1715193156,1865862730,1948373848,2100090966,2701949495,2818666809,3004591147,3122358053,2235061775,2352307457,2535604243,2653899549,3915653703,3764988233,4219352155,4067639125,3444575871,3294430577,3746175075,3594982253,836553431,953270745,600235211,718002117,367585007,484830689,133361907,251657213,2041877159,1891211689,1806599355,1654886325,1568718495,1418573201,1335535747,1184342925];class $J{get key(){return I0(this,VJ,"f").slice()}constructor(Q){if(VJ.set(this,void 0),h0.set(this,void 0),e0.set(this,void 0),!(this instanceof $J))throw Error("AES must be instanitated with `new`");N5(this,VJ,new Uint8Array(Q),"f");const Y=KW[this.key.length];if(Y==null)throw new TypeError("invalid key size (must be 16, 24 or 32 bytes)");N5(this,e0,[],"f"),N5(this,h0,[],"f");for(let V=0;V<=Y;V++)I0(this,e0,"f").push([0,0,0,0]),I0(this,h0,"f").push([0,0,0,0]);const J=(Y+1)*4,X=this.key.length/4,q=w5(this.key);let G;for(let V=0;V<X;V++)G=V>>2,I0(this,e0,"f")[G][V%4]=q[V],I0(this,h0,"f")[Y-G][V%4]=q[V];let W=0,U=X,$;while(U<J){if($=q[X-1],q[0]^=y0[$>>16&255]<<24^y0[$>>8&255]<<16^y0[$&255]<<8^y0[$>>24&255]^jW[W]<<24,W+=1,X!=8)for(let M=1;M<X;M++)q[M]^=q[M-1];else{for(let M=1;M<X/2;M++)q[M]^=q[M-1];$=q[X/2-1],q[X/2]^=y0[$&255]^y0[$>>8&255]<<8^y0[$>>16&255]<<16^y0[$>>24&255]<<24;for(let M=X/2+1;M<X;M++)q[M]^=q[M-1]}let V=0,Z,K;while(V<X&&U<J)Z=U>>2,K=U%4,I0(this,e0,"f")[Z][K]=q[V],I0(this,h0,"f")[Y-Z][K]=q[V++],U++}for(let V=1;V<Y;V++)for(let Z=0;Z<4;Z++)$=I0(this,h0,"f")[V][Z],I0(this,h0,"f")[V][Z]=TW[$>>24&255]^NW[$>>16&255]^wW[$>>8&255]^FW[$&255]}encrypt(Q){if(Q.length!=16)throw new TypeError("invalid plaintext size (must be 16 bytes)");const Y=I0(this,e0,"f").length-1,J=[0,0,0,0];let X=w5(Q);for(let W=0;W<4;W++)X[W]^=I0(this,e0,"f")[0][W];for(let W=1;W<Y;W++){for(let U=0;U<4;U++)J[U]=OW[X[U]>>24&255]^IW[X[(U+1)%4]>>16&255]^LW[X[(U+2)%4]>>8&255]^DW[X[(U+3)%4]&255]^I0(this,e0,"f")[W][U];X=J.slice()}const q=new Uint8Array(16);let G=0;for(let W=0;W<4;W++)G=I0(this,e0,"f")[Y][W],q[4*W]=(y0[X[W]>>24&255]^G>>24)&255,q[4*W+1]=(y0[X[(W+1)%4]>>16&255]^G>>16)&255,q[4*W+2]=(y0[X[(W+2)%4]>>8&255]^G>>8)&255,q[4*W+3]=(y0[X[(W+3)%4]&255]^G)&255;return q}decrypt(Q){if(Q.length!=16)throw new TypeError("invalid ciphertext size (must be 16 bytes)");const Y=I0(this,h0,"f").length-1,J=[0,0,0,0];let X=w5(Q);for(let W=0;W<4;W++)X[W]^=I0(this,h0,"f")[0][W];for(let W=1;W<Y;W++){for(let U=0;U<4;U++)J[U]=HW[X[U]>>24&255]^RW[X[(U+3)%4]>>16&255]^PW[X[(U+2)%4]>>8&255]^CW[X[(U+1)%4]&255]^I0(this,h0,"f")[W][U];X=J.slice()}const q=new Uint8Array(16);let G=0;for(let W=0;W<4;W++)G=I0(this,h0,"f")[Y][W],q[4*W]=(UJ[X[W]>>24&255]^G>>24)&255,q[4*W+1]=(UJ[X[(W+3)%4]>>16&255]^G>>16)&255,q[4*W+2]=(UJ[X[(W+2)%4]>>8&255]^G>>8)&255,q[4*W+3]=(UJ[X[(W+1)%4]&255]^G)&255;return q}}VJ=new WeakMap,h0=new WeakMap,e0=new WeakMap;class e9{constructor(Q,Y,J){if(J&&!(this instanceof J))throw new Error(`${Q} must be instantiated with "new"`);Object.defineProperties(this,{aes:{enumerable:!0,value:new $J(Y)},name:{enumerable:!0,value:Q}})}}var ZJ=function(Q,Y,J,X,q){if(X==="m")throw new TypeError("Private method is not writable");if(X==="a"&&!q)throw new TypeError("Private accessor was defined without a setter");if(typeof Y==="function"?Q!==Y||!q:!Y.has(Q))throw new TypeError("Cannot write private member to an object whose class did not declare it");return X==="a"?q.call(Q,J):q?q.value=J:Y.set(Q,J),J},B9=function(Q,Y,J,X){if(J==="a"&&!X)throw new TypeError("Private accessor was defined without a getter");if(typeof Y==="function"?Q!==Y||!X:!Y.has(Q))throw new TypeError("Cannot read private member from an object whose class did not declare it");return J==="m"?X:J==="a"?X.call(Q):X?X.value:Y.get(Q)},QQ,T8;class JQ extends e9{constructor(Q,Y){super("ECC",Q,JQ);if(QQ.set(this,void 0),T8.set(this,void 0),Y){if(Y.length%16)throw new TypeError("invalid iv size (must be 16 bytes)");ZJ(this,QQ,new Uint8Array(Y),"f")}else ZJ(this,QQ,new Uint8Array(16),"f");ZJ(this,T8,this.iv,"f")}get iv(){return new Uint8Array(B9(this,QQ,"f"))}encrypt(Q){if(Q.length%16)throw new TypeError("invalid plaintext size (must be multiple of 16 bytes)");const Y=new Uint8Array(Q.length);for(let J=0;J<Q.length;J+=16){for(let X=0;X<16;X++)B9(this,T8,"f")[X]^=Q[J+X];ZJ(this,T8,this.aes.encrypt(B9(this,T8,"f")),"f"),Y.set(B9(this,T8,"f"),J)}return Y}decrypt(Q){if(Q.length%16)throw new TypeError("invalid ciphertext size (must be multiple of 16 bytes)");const Y=new Uint8Array(Q.length);for(let J=0;J<Q.length;J+=16){const X=this.aes.decrypt(Q.subarray(J,J+16));for(let q=0;q<16;q++)Y[J+q]=X[q]^B9(this,T8,"f")[q],B9(this,T8,"f")[q]=Q[J+q]}return Y}}QQ=new WeakMap,T8=new WeakMap;var E9=function(Q,Y,J,X,q){if(X==="m")throw new TypeError("Private method is not writable");if(X==="a"&&!q)throw new TypeError("Private accessor was defined without a setter");if(typeof Y==="function"?Q!==Y||!q:!Y.has(Q))throw new TypeError("Cannot write private member to an object whose class did not declare it");return X==="a"?q.call(Q,J):q?q.value=J:Y.set(Q,J),J},m0=function(Q,Y,J,X){if(J==="a"&&!X)throw new TypeError("Private accessor was defined without a getter");if(typeof Y==="function"?Q!==Y||!X:!Y.has(Q))throw new TypeError("Cannot read private member from an object whose class did not declare it");return J==="m"?X:J==="a"?X.call(Q):X?X.value:Y.get(Q)},YQ,X9,_0;class v8 extends e9{constructor(Q,Y){super("CTR",Q,v8);if(YQ.set(this,void 0),X9.set(this,void 0),_0.set(this,void 0),E9(this,_0,new Uint8Array(16),"f"),m0(this,_0,"f").fill(0),E9(this,YQ,m0(this,_0,"f"),"f"),E9(this,X9,16,"f"),Y==null)Y=1;if(typeof Y==="number")this.setCounterValue(Y);else this.setCounterBytes(Y)}get counter(){return new Uint8Array(m0(this,_0,"f"))}setCounterValue(Q){if(!Number.isInteger(Q)||Q<0||Q>Number.MAX_SAFE_INTEGER)throw new TypeError("invalid counter initial integer value");for(let Y=15;Y>=0;--Y)m0(this,_0,"f")[Y]=Q%256,Q=Math.floor(Q/256)}setCounterBytes(Q){if(Q.length!==16)throw new TypeError("invalid counter initial Uint8Array value length");m0(this,_0,"f").set(Q)}increment(){for(let Q=15;Q>=0;Q--)if(m0(this,_0,"f")[Q]===255)m0(this,_0,"f")[Q]=0;else{m0(this,_0,"f")[Q]++;break}}encrypt(Q){var Y,J;const X=new Uint8Array(Q);for(let q=0;q<X.length;q++){if(m0(this,X9,"f")===16)E9(this,YQ,this.aes.encrypt(m0(this,_0,"f")),"f"),E9(this,X9,0,"f"),this.increment();X[q]^=m0(this,YQ,"f")[E9(this,X9,(J=m0(this,X9,"f"),Y=J++,J),"f"),Y]}return X}decrypt(Q){return this.encrypt(Q)}}YQ=new WeakMap,X9=new WeakMap,_0=new WeakMap;function F5(Q){if(Q.length<16)throw new TypeError("PKCS#7 invalid length");const Y=Q[Q.length-1];if(Y>16)throw new TypeError("PKCS#7 padding byte out of range");const J=Q.length-Y;for(let X=0;X<Y;X++)if(Q[J+X]!==Y)throw new TypeError("PKCS#7 invalid padding byte");return new Uint8Array(Q.subarray(0,J))}function B5(Q){if(typeof Q==="string"&&!Q.startsWith("0x"))Q="0x"+Q;return l0(Q)}function S9(Q,Y){Q=String(Q);while(Q.length<Y)Q="0"+Q;return Q}function q9(Q){if(typeof Q==="string")return z0(Q,"NFKC");return l0(Q)}function q0(Q,Y){const J=Y.match(/^([a-z0-9$_.-]*)(:([a-z]+))?(!)?$/i);I(J!=null,"invalid path","path",Y);const X=J[1],q=J[3],G=J[4]==="!";let W=Q;for(let U of X.toLowerCase().split(".")){if(Array.isArray(W)){if(!U.match(/^[0-9]+$/))break;W=W[parseInt(U)]}else if(typeof W==="object"){let $=null;for(let V in W)if(V.toLowerCase()===U){$=W[V];break}W=$}else W=null;if(W==null)break}if(I(!G||W!=null,"missing required value","path",X),q&&W!=null){if(q==="int"){if(typeof W==="string"&&W.match(/^-?[0-9]+$/))return parseInt(W);else if(Number.isSafeInteger(W))return W}if(q==="number"){if(typeof W==="string"&&W.match(/^-?[0-9.]*$/))return parseFloat(W)}if(q==="data"){if(typeof W==="string")return B5(W)}if(q==="array"&&Array.isArray(W))return W;if(q===typeof W)return W;I(!1,`wrong type found for ${q} `,"path",X)}return W}function MJ(Q){try{const Y=JSON.parse(Q);if((Y.version!=null?parseInt(Y.version):0)===3)return!0}catch(Y){}return!1}var BW=function(Q,Y,J){if(q0(Q,"crypto.cipher:string")==="aes-128-ctr"){const q=q0(Q,"crypto.cipherparams.iv:data!"),G=new v8(Y,q);return B(G.decrypt(J))}f(!1,"unsupported cipher","UNSUPPORTED_OPERATION",{operation:"decrypt"})},zJ=function(Q,Y){const J=E(Y),X=q0(Q,"crypto.ciphertext:data!"),q=B(n(i([J.slice(16,32),X]))).substring(2);I(q===q0(Q,"crypto.mac:string!").toLowerCase(),"incorrect password","password","[ REDACTED ]");const G=BW(Q,J.slice(0,16),X),W=H8(G);if(Q.address){let V=Q.address.toLowerCase();if(!V.startsWith("0x"))V="0x"+V;I(_(V)===W,"keystore address/privateKey mismatch","address",Q.address)}const U={address:W,privateKey:G};if(q0(Q,"x-ethers.version:string")==="0.1"){const V=J.slice(32,64),Z=q0(Q,"x-ethers.mnemonicCiphertext:data!"),K=q0(Q,"x-ethers.mnemonicCounter:data!"),M=new v8(V,K);U.mnemonic={path:q0(Q,"x-ethers.path:string")||Zq,locale:q0(Q,"x-ethers.locale:string")||"en",entropy:B(E(M.decrypt(Z)))}}return U},zq=function(Q){const Y=q0(Q,"crypto.kdf:string");if(Y&&typeof Y==="string"){if(Y.toLowerCase()==="scrypt"){const J=q0(Q,"crypto.kdfparams.salt:data!"),X=q0(Q,"crypto.kdfparams.n:int!"),q=q0(Q,"crypto.kdfparams.r:int!"),G=q0(Q,"crypto.kdfparams.p:int!");I(X>0&&(X&X-1)===0,"invalid kdf.N","kdf.N",X),I(q>0&&G>0,"invalid kdf","kdf",Y);const W=q0(Q,"crypto.kdfparams.dklen:int!");return I(W===32,"invalid kdf.dklen","kdf.dflen",W),{name:"scrypt",salt:J,N:X,r:q,p:G,dkLen:64}}else if(Y.toLowerCase()==="pbkdf2"){const J=q0(Q,"crypto.kdfparams.salt:data!"),X=q0(Q,"crypto.kdfparams.prf:string!"),q=X.split("-").pop();I(q==="sha256"||q==="sha512","invalid kdf.pdf","kdf.pdf",X);const G=q0(Q,"crypto.kdfparams.c:int!"),W=q0(Q,"crypto.kdfparams.dklen:int!");return I(W===32,"invalid kdf.dklen","kdf.dklen",W),{name:"pbkdf2",salt:J,count:G,dkLen:W,algorithm:q}}}I(!1,"unsupported key-derivation function","kdf",Y)};function E5(Q,Y){const J=JSON.parse(Q),X=q9(Y),q=zq(J);if(q.name==="pbkdf2"){const{salt:K,count:M,dkLen:j,algorithm:z}=q,L=A0(X,K,M,j,z);return zJ(J,L)}f(q.name==="scrypt","cannot be reached","UNKNOWN_ERROR",{params:q});const{salt:G,N:W,r:U,p:$,dkLen:V}=q,Z=j8(X,G,W,U,$,V);return zJ(J,Z)}var $q=function(Q){return new Promise((Y)=>{setTimeout(()=>{Y()},Q)})};async function S5(Q,Y,J){const X=JSON.parse(Q),q=q9(Y),G=zq(X);if(G.name==="pbkdf2"){if(J)J(0),await $q(0);const{salt:M,count:j,dkLen:z,algorithm:L}=G,H=A0(q,M,j,z,L);if(J)J(1),await $q(0);return zJ(X,H)}f(G.name==="scrypt","cannot be reached","UNKNOWN_ERROR",{params:G});const{salt:W,N:U,r:$,p:V,dkLen:Z}=G,K=await K8(q,W,U,$,V,Z,J);return zJ(X,K)}var Mq=function(Q){const Y=Q.salt!=null?E(Q.salt,"options.salt"):V0(32);let J=1<<17,X=8,q=1;if(Q.scrypt){if(Q.scrypt.N)J=Q.scrypt.N;if(Q.scrypt.r)X=Q.scrypt.r;if(Q.scrypt.p)q=Q.scrypt.p}return I(typeof J==="number"&&J>0&&Number.isSafeInteger(J)&&(BigInt(J)&BigInt(J-1))===BigInt(0),"invalid scrypt N parameter","options.N",J),I(typeof X==="number"&&X>0&&Number.isSafeInteger(X),"invalid scrypt r parameter","options.r",X),I(typeof q==="number"&&q>0&&Number.isSafeInteger(q),"invalid scrypt p parameter","options.p",q),{name:"scrypt",dkLen:32,salt:Y,N:J,r:X,p:q}},Kq=function(Q,Y,J,X){const q=E(J.privateKey,"privateKey"),G=X.iv!=null?E(X.iv,"options.iv"):V0(16);I(G.length===16,"invalid options.iv length","options.iv",X.iv);const W=X.uuid!=null?E(X.uuid,"options.uuid"):V0(16);I(W.length===16,"invalid options.uuid length","options.uuid",X.iv);const U=Q.slice(0,16),$=Q.slice(16,32),V=new v8(U,G),Z=E(V.encrypt(q)),K=n(i([$,Z])),M={address:J.address.substring(2).toLowerCase(),id:gQ(W),version:3,Crypto:{cipher:"aes-128-ctr",cipherparams:{iv:B(G).substring(2)},ciphertext:B(Z).substring(2),kdf:"scrypt",kdfparams:{salt:B(Y.salt).substring(2),n:Y.N,dklen:32,p:Y.p,r:Y.r},mac:K.substring(2)}};if(J.mnemonic){const j=X.client!=null?X.client:`ethers/${FQ}`,z=J.mnemonic.path||Zq,L=J.mnemonic.locale||"en",H=Q.slice(32,64),P=E(J.mnemonic.entropy,"account.mnemonic.entropy"),C=V0(16),S=new v8(H,C),O=E(S.encrypt(P)),D=new Date,R="UTC--"+(D.getUTCFullYear()+"-"+S9(D.getUTCMonth()+1,2)+"-"+S9(D.getUTCDate(),2)+"T"+S9(D.getUTCHours(),2)+"-"+S9(D.getUTCMinutes(),2)+"-"+S9(D.getUTCSeconds(),2)+".0Z--")+M.address;M["x-ethers"]={client:j,gethFilename:R,path:z,locale:L,mnemonicCounter:B(C).substring(2),mnemonicCiphertext:B(O).substring(2),version:"0.1"}}return JSON.stringify(M)};function XQ(Q,Y,J){if(J==null)J={};const X=q9(Y),q=Mq(J),G=j8(X,q.salt,q.N,q.r,q.p,64);return Kq(E(G),q,Q,J)}async function qQ(Q,Y,J){if(J==null)J={};const X=q9(Y),q=Mq(J),G=await K8(X,q.salt,q.N,q.r,q.p,64,J.progressCallback);return Kq(E(G),q,Q,J)}var Zq="m/44'/60'/0'/0/0";var jJ=function(Q,Y){let J="";while(Q)J=AW[Q%16]+J,Q=Math.trunc(Q/16);while(J.length<Y*2)J="0"+J;return"0x"+J},A5=function(Q){const Y=E(Q),J=D9(O0(O0(Y)),0,4),X=i([Y,J]);return fQ(X)},jq=function(Q,Y,J,X){const q=new Uint8Array(37);if(Q&g8)f(X!=null,"cannot derive child of neutered node","UNSUPPORTED_OPERATION",{operation:"deriveChild"}),q.set(E(X),1);else q.set(E(J));for(let W=24;W>=0;W-=8)q[33+(W>>3)]=Q>>24-W&255;const G=E(z8("sha512",Y,q));return{IL:G.slice(0,32),IR:G.slice(32)}},Oq=function(Q,Y){const J=Y.split("/");if(I(J.length>0,"invalid path","path",Y),J[0]==="m")I(Q.depth===0,`cannot derive root path (i.e. path starting with "m/") for a node at non-zero depth ${Q.depth}`,"path",Y),J.shift();let X=Q;for(let q=0;q<J.length;q++){const G=J[q];if(G.match(/^[0-9]+'$/)){const W=parseInt(G.substring(0,G.length-1));I(W<g8,"invalid path index",`path[${q}]`,G),X=X.deriveChild(g8+W)}else if(G.match(/^[0-9]+$/)){const W=parseInt(G);I(W<g8,"invalid path index",`path[${q}]`,G),X=X.deriveChild(W)}else I(!1,"invalid path component",`path[${q}]`,G)}return X};var KJ="m/44'/60'/0'/0/0",EW=new Uint8Array([66,105,116,99,111,105,110,32,115,101,101,100]),g8=2147483648,SW=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),AW="0123456789abcdef",Q8={};class w0 extends Y9{publicKey;fingerprint;parentFingerprint;mnemonic;chainCode;path;index;depth;constructor(Q,Y,J,X,q,G,W,U,$){super(Y,$);U8(Q,Q8,"HDNodeWallet"),s(this,{publicKey:Y.compressedPublicKey});const V=D9(M8(O0(this.publicKey)),0,4);s(this,{parentFingerprint:J,fingerprint:V,chainCode:X,path:q,index:G,depth:W}),s(this,{mnemonic:U})}connect(Q){return new w0(Q8,this.signingKey,this.parentFingerprint,this.chainCode,this.path,this.index,this.depth,this.mnemonic,Q)}#Q(){const Q={address:this.address,privateKey:this.privateKey},Y=this.mnemonic;if(this.path&&Y&&Y.wordlist.locale==="en"&&Y.password==="")Q.mnemonic={path:this.path,locale:"en",entropy:Y.entropy};return Q}async encrypt(Q,Y){return await qQ(this.#Q(),Q,{progressCallback:Y})}encryptSync(Q){return XQ(this.#Q(),Q)}get extendedKey(){return f(this.depth<256,"Depth too deep","UNSUPPORTED_OPERATION",{operation:"extendedKey"}),A5(i(["0x0488ADE4",jJ(this.depth,1),this.parentFingerprint,jJ(this.index,4),this.chainCode,i(["0x00",this.privateKey])]))}hasPath(){return this.path!=null}neuter(){return new A9(Q8,this.address,this.publicKey,this.parentFingerprint,this.chainCode,this.path,this.index,this.depth,this.provider)}deriveChild(Q){const Y=Z0(Q,"index");I(Y<=4294967295,"invalid index","index",Y);let J=this.path;if(J){if(J+="/"+(Y&~g8),Y&g8)J+="'"}const{IR:X,IL:q}=jq(Y,this.chainCode,this.publicKey,this.privateKey),G=new W0(n0((R9(q)+BigInt(this.privateKey))%SW,32));return new w0(Q8,G,this.fingerprint,B(X),J,Y,this.depth+1,this.mnemonic,this.provider)}derivePath(Q){return Oq(this,Q)}static#J(Q,Y){I(t0(Q),"invalid seed","seed","[REDACTED]");const J=E(Q,"seed");I(J.length>=16&&J.length<=64,"invalid seed","seed","[REDACTED]");const X=E(z8("sha512",EW,J)),q=new W0(B(X.slice(0,32)));return new w0(Q8,q,"0x00000000",B(X.slice(32)),"m",0,0,Y,null)}static fromExtendedKey(Q){const Y=e(bQ(Q));I(Y.length===82||A5(Y.slice(0,78))===Q,"invalid extended key","extendedKey","[ REDACTED ]");const J=Y[4],X=B(Y.slice(5,9)),q=parseInt(B(Y.slice(9,13)).substring(2),16),G=B(Y.slice(13,45)),W=Y.slice(45,78);switch(B(Y.slice(0,4))){case"0x0488b21e":case"0x043587cf":{const U=B(W);return new A9(Q8,H8(U),U,X,G,null,q,J,null)}case"0x0488ade4":case"0x04358394 ":if(W[0]!==0)break;return new w0(Q8,new W0(W.slice(1)),X,G,null,q,J,null,null)}I(!1,"invalid extended key prefix","extendedKey","[ REDACTED ]")}static createRandom(Q,Y,J){if(Q==null)Q="";if(Y==null)Y=KJ;if(J==null)J=P8.wordlist();const X=C8.fromEntropy(V0(16),Q,J);return w0.#J(X.computeSeed(),X).derivePath(Y)}static fromMnemonic(Q,Y){if(!Y)Y=KJ;return w0.#J(Q.computeSeed(),Q).derivePath(Y)}static fromPhrase(Q,Y,J,X){if(Y==null)Y="";if(J==null)J=KJ;if(X==null)X=P8.wordlist();const q=C8.fromPhrase(Q,Y,X);return w0.#J(q.computeSeed(),q).derivePath(J)}static fromSeed(Q){return w0.#J(Q,null)}}class A9 extends s9{publicKey;fingerprint;parentFingerprint;chainCode;path;index;depth;constructor(Q,Y,J,X,q,G,W,U,$){super(Y,$);U8(Q,Q8,"HDNodeVoidWallet"),s(this,{publicKey:J});const V=D9(M8(O0(J)),0,4);s(this,{publicKey:J,fingerprint:V,parentFingerprint:X,chainCode:q,path:G,index:W,depth:U})}connect(Q){return new A9(Q8,this.address,this.publicKey,this.parentFingerprint,this.chainCode,this.path,this.index,this.depth,Q)}get extendedKey(){return f(this.depth<256,"Depth too deep","UNSUPPORTED_OPERATION",{operation:"extendedKey"}),A5(i(["0x0488B21E",jJ(this.depth,1),this.parentFingerprint,jJ(this.index,4),this.chainCode,this.publicKey]))}hasPath(){return this.path!=null}deriveChild(Q){const Y=Z0(Q,"index");I(Y<=4294967295,"invalid index","index",Y);let J=this.path;if(J){if(J+="/"+(Y&~g8),Y&g8)J+="'"}const{IR:X,IL:q}=jq(Y,this.chainCode,this.publicKey,null),G=W0.addPoints(q,this.publicKey,!0),W=H8(G);return new A9(Q8,W,G,this.fingerprint,B(X),J,Y,this.depth+1,this.provider)}derivePath(Q){return Oq(this,Q)}}function OJ(Q){try{if(JSON.parse(Q).encseed)return!0}catch(Y){}return!1}function IJ(Q,Y){const J=JSON.parse(Q),X=q9(Y),q=_(q0(J,"ethaddr:string!")),G=B5(q0(J,"encseed:string!"));I(G&&G.length%16===0,"invalid encseed","json",Q);const W=E(A0(X,X,2000,32,"sha256")).slice(0,16),U=G.slice(0,16),$=G.slice(16),V=new JQ(W,U),Z=F5(E(V.decrypt($)));let K="";for(let M=0;M<Z.length;M++)K+=String.fromCharCode(Z[M]);return{address:q,privateKey:R8(K)}}var Iq=function(Q){return new Promise((Y)=>{setTimeout(()=>{Y()},Q)})};class c0 extends Y9{constructor(Q,Y){if(typeof Q==="string"&&!Q.startsWith("0x"))Q="0x"+Q;let J=typeof Q==="string"?new W0(Q):Q;super(J,Y)}connect(Q){return new c0(this.signingKey,Q)}async encrypt(Q,Y){const J={address:this.address,privateKey:this.privateKey};return await qQ(J,Q,{progressCallback:Y})}encryptSync(Q){const Y={address:this.address,privateKey:this.privateKey};return XQ(Y,Q)}static#Q(Q){if(I(Q,"invalid JSON wallet","json","[ REDACTED ]"),("mnemonic"in Q)&&Q.mnemonic&&Q.mnemonic.locale==="en"){const J=C8.fromEntropy(Q.mnemonic.entropy),X=w0.fromMnemonic(J,Q.mnemonic.path);if(X.address===Q.address&&X.privateKey===Q.privateKey)return X;console.log("WARNING: JSON mismatch address/privateKey != mnemonic; fallback onto private key")}const Y=new c0(Q.privateKey);return I(Y.address===Q.address,"address/privateKey mismatch","json","[ REDACTED ]"),Y}static async fromEncryptedJson(Q,Y,J){let X=null;if(MJ(Q))X=await S5(Q,Y,J);else if(OJ(Q)){if(J)J(0),await Iq(0);if(X=IJ(Q,Y),J)J(1),await Iq(0)}return c0.#Q(X)}static fromEncryptedJsonSync(Q,Y){let J=null;if(MJ(Q))J=E5(Q,Y);else if(OJ(Q))J=IJ(Q,Y);else I(!1,"invalid JSON wallet","json","[ REDACTED ]");return c0.#Q(J)}static createRandom(Q){const Y=w0.createRandom();if(Q)return Y.connect(Q);return Y}static fromPhrase(Q,Y){const J=w0.fromPhrase(Q);if(Y)return J.connect(Y);return J}}var g9=function(Q){let Y=Q.length;while(--Y>=0)Q[Y]=0},x5=function(Q,Y,J,X,q){this.static_tree=Q,this.extra_bits=Y,this.extra_base=J,this.elems=X,this.max_length=q,this.has_stree=Q&&Q.length},f5=function(Q,Y){this.dyn_tree=Q,this.max_code=0,this.stat_desc=Y},J8=function(Q,Y,J,X,q){this.good_length=Q,this.max_lazy=Y,this.nice_length=J,this.max_chain=X,this.func=q},fU=function(){this.strm=null,this.status=0,this.pending_buf=null,this.pending_buf_size=0,this.pending_out=0,this.pending=0,this.wrap=0,this.gzhead=null,this.gzindex=0,this.method=FJ,this.last_flush=-1,this.w_size=0,this.w_bits=0,this.w_mask=0,this.window=null,this.window_size=0,this.prev=null,this.head=null,this.ins_h=0,this.hash_size=0,this.hash_bits=0,this.hash_mask=0,this.hash_shift=0,this.block_start=0,this.match_length=0,this.prev_match=0,this.match_available=0,this.strstart=0,this.match_start=0,this.lookahead=0,this.prev_length=0,this.max_chain_length=0,this.max_lazy_match=0,this.level=0,this.strategy=0,this.good_match=0,this.nice_match=0,this.dyn_ltree=new Uint16Array(NU*2),this.dyn_dtree=new Uint16Array((2*CU+1)*2),this.bl_tree=new Uint16Array((2*TU+1)*2),y8(this.dyn_ltree),y8(this.dyn_dtree),y8(this.bl_tree),this.l_desc=null,this.d_desc=null,this.bl_desc=null,this.bl_count=new Uint16Array(wU+1),this.heap=new Uint16Array(2*i5+1),y8(this.heap),this.heap_len=0,this.heap_max=0,this.depth=new Uint16Array(2*i5+1),y8(this.depth),this.sym_buf=0,this.lit_bufsize=0,this.sym_next=0,this.sym_end=0,this.opt_len=0,this.static_len=0,this.matches=0,this.insert=0,this.bi_buf=0,this.bi_valid=0},JV=function(){this.input=null,this.next_in=0,this.avail_in=0,this.total_in=0,this.output=null,this.next_out=0,this.avail_out=0,this.total_out=0,this.msg="",this.state=null,this.data_type=2,this.adler=0},PQ=function(Q){this.options=BJ.assign({level:UV,method:$V,chunkSize:16384,windowBits:15,memLevel:8,strategy:VV},Q||{});let Y=this.options;if(Y.raw&&Y.windowBits>0)Y.windowBits=-Y.windowBits;else if(Y.gzip&&Y.windowBits>0&&Y.windowBits<16)Y.windowBits+=16;this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new C7,this.strm.avail_out=0;let J=$Q.deflateInit2(this.strm,Y.level,Y.method,Y.windowBits,Y.memLevel,Y.strategy);if(J!==NJ)throw new Error(V9[J]);if(Y.header)$Q.deflateSetHeader(this.strm,Y.header);if(Y.dictionary){let X;if(typeof Y.dictionary==="string")X=LQ.string2buf(Y.dictionary);else if(T7.call(Y.dictionary)==="[object ArrayBuffer]")X=new Uint8Array(Y.dictionary);else X=Y.dictionary;if(J=$Q.deflateSetDictionary(this.strm,X),J!==NJ)throw new Error(V9[J]);this._dict_set=!0}},GY=function(Q,Y){const J=new PQ(Y);if(J.push(Q,!0),J.err)throw J.msg||V9[J.err];return J.result},ZV=function(Q,Y){return Y=Y||{},Y.raw=!0,GY(Q,Y)},zV=function(Q,Y){return Y=Y||{},Y.gzip=!0,GY(Q,Y)},bV=function(){this.strm=null,this.mode=0,this.last=!1,this.wrap=0,this.havedict=!1,this.flags=0,this.dmax=0,this.check=0,this.total=0,this.head=null,this.wbits=0,this.wsize=0,this.whave=0,this.wnext=0,this.window=null,this.hold=0,this.bits=0,this.length=0,this.offset=0,this.extra=0,this.lencode=null,this.distcode=null,this.lenbits=0,this.distbits=0,this.ncode=0,this.nlen=0,this.ndist=0,this.have=0,this.next=null,this.lens=new Uint16Array(320),this.work=new Uint16Array(288),this.lendyn=null,this.distdyn=null,this.sane=0,this.back=0,this.was=0},tV=function(){this.text=0,this.time=0,this.xflags=0,this.os=0,this.extra=null,this.extra_len=0,this.name="",this.comment="",this.hcrc=0,this.done=!1},CQ=function(Q){this.options=BJ.assign({chunkSize:65536,windowBits:15,to:""},Q||{});const Y=this.options;if(Y.raw&&Y.windowBits>=0&&Y.windowBits<16){if(Y.windowBits=-Y.windowBits,Y.windowBits===0)Y.windowBits=-15}if(Y.windowBits>=0&&Y.windowBits<16&&!(Q&&Q.windowBits))Y.windowBits+=32;if(Y.windowBits>15&&Y.windowBits<48){if((Y.windowBits&15)===0)Y.windowBits|=15}this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new C7,this.strm.avail_out=0;let J=F8.inflateInit2(this.strm,Y.windowBits);if(J!==DQ)throw new Error(V9[J]);if(this.header=new sV,F8.inflateGetHeader(this.strm,this.header),Y.dictionary){if(typeof Y.dictionary==="string")Y.dictionary=LQ.string2buf(Y.dictionary);else if(v7.call(Y.dictionary)==="[object ArrayBuffer]")Y.dictionary=new Uint8Array(Y.dictionary);if(Y.raw){if(J=F8.inflateSetDictionary(this.strm,Y.dictionary),J!==DQ)throw new Error(V9[J])}}},WY=function(Q,Y){const J=new CQ(Y);if(J.push(Q),J.err)throw J.msg||V9[J.err];return J.result},X6=function(Q,Y){return Y=Y||{},Y.raw=!0,WY(Q,Y)};/*! pako 2.1.0 https://github.com/nodeca/pako @license (MIT AND Zlib) */var xW=0,J7=1,fW=2,bW=3,vW=258,QY=29,HQ=256,zQ=HQ+1+QY,f9=30,JY=19,Y7=2*zQ+1,G9=15,k5=16,gW=7,YY=256,X7=16,q7=17,G7=18,l5=new Uint8Array([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0]),CJ=new Uint8Array([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13]),yW=new Uint8Array([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7]),W7=new Uint8Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),hW=512,w8=new Array((zQ+2)*2);g9(w8);var VQ=new Array(f9*2);g9(VQ);var MQ=new Array(hW);g9(MQ);var KQ=new Array(vW-bW+1);g9(KQ);var XY=new Array(QY);g9(XY);var TJ=new Array(f9);g9(TJ);var U7,V7,$7,Z7=(Q)=>{return Q<256?MQ[Q]:MQ[256+(Q>>>7)]},jQ=(Q,Y)=>{Q.pending_buf[Q.pending++]=Y&255,Q.pending_buf[Q.pending++]=Y>>>8&255},F0=(Q,Y,J)=>{if(Q.bi_valid>k5-J)Q.bi_buf|=Y<<Q.bi_valid&65535,jQ(Q,Q.bi_buf),Q.bi_buf=Y>>k5-Q.bi_valid,Q.bi_valid+=J-k5;else Q.bi_buf|=Y<<Q.bi_valid&65535,Q.bi_valid+=J},Y8=(Q,Y,J)=>{F0(Q,J[Y*2],J[Y*2+1])},z7=(Q,Y)=>{let J=0;do J|=Q&1,Q>>>=1,J<<=1;while(--Y>0);return J>>>1},mW=(Q)=>{if(Q.bi_valid===16)jQ(Q,Q.bi_buf),Q.bi_buf=0,Q.bi_valid=0;else if(Q.bi_valid>=8)Q.pending_buf[Q.pending++]=Q.bi_buf&255,Q.bi_buf>>=8,Q.bi_valid-=8},_W=(Q,Y)=>{const{dyn_tree:J,max_code:X}=Y,q=Y.stat_desc.static_tree,G=Y.stat_desc.has_stree,W=Y.stat_desc.extra_bits,U=Y.stat_desc.extra_base,$=Y.stat_desc.max_length;let V,Z,K,M,j,z,L=0;for(M=0;M<=G9;M++)Q.bl_count[M]=0;J[Q.heap[Q.heap_max]*2+1]=0;for(V=Q.heap_max+1;V<Y7;V++){if(Z=Q.heap[V],M=J[J[Z*2+1]*2+1]+1,M>$)M=$,L++;if(J[Z*2+1]=M,Z>X)continue;if(Q.bl_count[M]++,j=0,Z>=U)j=W[Z-U];if(z=J[Z*2],Q.opt_len+=z*(M+j),G)Q.static_len+=z*(q[Z*2+1]+j)}if(L===0)return;do{M=$-1;while(Q.bl_count[M]===0)M--;Q.bl_count[M]--,Q.bl_count[M+1]+=2,Q.bl_count[$]--,L-=2}while(L>0);for(M=$;M!==0;M--){Z=Q.bl_count[M];while(Z!==0){if(K=Q.heap[--V],K>X)continue;if(J[K*2+1]!==M)Q.opt_len+=(M-J[K*2+1])*J[K*2],J[K*2+1]=M;Z--}}},M7=(Q,Y,J)=>{const X=new Array(G9+1);let q=0,G,W;for(G=1;G<=G9;G++)q=q+J[G-1]<<1,X[G]=q;for(W=0;W<=Y;W++){let U=Q[W*2+1];if(U===0)continue;Q[W*2]=z7(X[U]++,U)}},cW=()=>{let Q,Y,J,X,q;const G=new Array(G9+1);J=0;for(X=0;X<QY-1;X++){XY[X]=J;for(Q=0;Q<1<<l5[X];Q++)KQ[J++]=X}KQ[J-1]=X,q=0;for(X=0;X<16;X++){TJ[X]=q;for(Q=0;Q<1<<CJ[X];Q++)MQ[q++]=X}q>>=7;for(;X<f9;X++){TJ[X]=q<<7;for(Q=0;Q<1<<CJ[X]-7;Q++)MQ[256+q++]=X}for(Y=0;Y<=G9;Y++)G[Y]=0;Q=0;while(Q<=143)w8[Q*2+1]=8,Q++,G[8]++;while(Q<=255)w8[Q*2+1]=9,Q++,G[9]++;while(Q<=279)w8[Q*2+1]=7,Q++,G[7]++;while(Q<=287)w8[Q*2+1]=8,Q++,G[8]++;M7(w8,zQ+1,G);for(Q=0;Q<f9;Q++)VQ[Q*2+1]=5,VQ[Q*2]=z7(Q,5);U7=new x5(w8,l5,HQ+1,zQ,G9),V7=new x5(VQ,CJ,0,f9,G9),$7=new x5(new Array(0),yW,0,JY,gW)},K7=(Q)=>{let Y;for(Y=0;Y<zQ;Y++)Q.dyn_ltree[Y*2]=0;for(Y=0;Y<f9;Y++)Q.dyn_dtree[Y*2]=0;for(Y=0;Y<JY;Y++)Q.bl_tree[Y*2]=0;Q.dyn_ltree[YY*2]=1,Q.opt_len=Q.static_len=0,Q.sym_next=Q.matches=0},j7=(Q)=>{if(Q.bi_valid>8)jQ(Q,Q.bi_buf);else if(Q.bi_valid>0)Q.pending_buf[Q.pending++]=Q.bi_buf;Q.bi_buf=0,Q.bi_valid=0},Lq=(Q,Y,J,X)=>{const q=Y*2,G=J*2;return Q[q]<Q[G]||Q[q]===Q[G]&&X[Y]<=X[J]},b5=(Q,Y,J)=>{const X=Q.heap[J];let q=J<<1;while(q<=Q.heap_len){if(q<Q.heap_len&&Lq(Y,Q.heap[q+1],Q.heap[q],Q.depth))q++;if(Lq(Y,X,Q.heap[q],Q.depth))break;Q.heap[J]=Q.heap[q],J=q,q<<=1}Q.heap[J]=X},Dq=(Q,Y,J)=>{let X,q,G=0,W,U;if(Q.sym_next!==0)do if(X=Q.pending_buf[Q.sym_buf+G++]&255,X+=(Q.pending_buf[Q.sym_buf+G++]&255)<<8,q=Q.pending_buf[Q.sym_buf+G++],X===0)Y8(Q,q,Y);else{if(W=KQ[q],Y8(Q,W+HQ+1,Y),U=l5[W],U!==0)q-=XY[W],F0(Q,q,U);if(X--,W=Z7(X),Y8(Q,W,J),U=CJ[W],U!==0)X-=TJ[W],F0(Q,X,U)}while(G<Q.sym_next);Y8(Q,YY,Y)},n5=(Q,Y)=>{const J=Y.dyn_tree,X=Y.stat_desc.static_tree,q=Y.stat_desc.has_stree,G=Y.stat_desc.elems;let W,U,$=-1,V;Q.heap_len=0,Q.heap_max=Y7;for(W=0;W<G;W++)if(J[W*2]!==0)Q.heap[++Q.heap_len]=$=W,Q.depth[W]=0;else J[W*2+1]=0;while(Q.heap_len<2)if(V=Q.heap[++Q.heap_len]=$<2?++$:0,J[V*2]=1,Q.depth[V]=0,Q.opt_len--,q)Q.static_len-=X[V*2+1];Y.max_code=$;for(W=Q.heap_len>>1;W>=1;W--)b5(Q,J,W);V=G;do W=Q.heap[1],Q.heap[1]=Q.heap[Q.heap_len--],b5(Q,J,1),U=Q.heap[1],Q.heap[--Q.heap_max]=W,Q.heap[--Q.heap_max]=U,J[V*2]=J[W*2]+J[U*2],Q.depth[V]=(Q.depth[W]>=Q.depth[U]?Q.depth[W]:Q.depth[U])+1,J[W*2+1]=J[U*2+1]=V,Q.heap[1]=V++,b5(Q,J,1);while(Q.heap_len>=2);Q.heap[--Q.heap_max]=Q.heap[1],_W(Q,Y),M7(J,$,Q.bl_count)},Hq=(Q,Y,J)=>{let X,q=-1,G,W=Y[1],U=0,$=7,V=4;if(W===0)$=138,V=3;Y[(J+1)*2+1]=65535;for(X=0;X<=J;X++){if(G=W,W=Y[(X+1)*2+1],++U<$&&G===W)continue;else if(U<V)Q.bl_tree[G*2]+=U;else if(G!==0){if(G!==q)Q.bl_tree[G*2]++;Q.bl_tree[X7*2]++}else if(U<=10)Q.bl_tree[q7*2]++;else Q.bl_tree[G7*2]++;if(U=0,q=G,W===0)$=138,V=3;else if(G===W)$=6,V=3;else $=7,V=4}},Rq=(Q,Y,J)=>{let X,q=-1,G,W=Y[1],U=0,$=7,V=4;if(W===0)$=138,V=3;for(X=0;X<=J;X++){if(G=W,W=Y[(X+1)*2+1],++U<$&&G===W)continue;else if(U<V)do Y8(Q,G,Q.bl_tree);while(--U!==0);else if(G!==0){if(G!==q)Y8(Q,G,Q.bl_tree),U--;Y8(Q,X7,Q.bl_tree),F0(Q,U-3,2)}else if(U<=10)Y8(Q,q7,Q.bl_tree),F0(Q,U-3,3);else Y8(Q,G7,Q.bl_tree),F0(Q,U-11,7);if(U=0,q=G,W===0)$=138,V=3;else if(G===W)$=6,V=3;else $=7,V=4}},pW=(Q)=>{let Y;Hq(Q,Q.dyn_ltree,Q.l_desc.max_code),Hq(Q,Q.dyn_dtree,Q.d_desc.max_code),n5(Q,Q.bl_desc);for(Y=JY-1;Y>=3;Y--)if(Q.bl_tree[W7[Y]*2+1]!==0)break;return Q.opt_len+=3*(Y+1)+5+5+4,Y},uW=(Q,Y,J,X)=>{let q;F0(Q,Y-257,5),F0(Q,J-1,5),F0(Q,X-4,4);for(q=0;q<X;q++)F0(Q,Q.bl_tree[W7[q]*2+1],3);Rq(Q,Q.dyn_ltree,Y-1),Rq(Q,Q.dyn_dtree,J-1)},dW=(Q)=>{let Y=4093624447,J;for(J=0;J<=31;J++,Y>>>=1)if(Y&1&&Q.dyn_ltree[J*2]!==0)return 0;if(Q.dyn_ltree[18]!==0||Q.dyn_ltree[20]!==0||Q.dyn_ltree[26]!==0)return 1;for(J=32;J<HQ;J++)if(Q.dyn_ltree[J*2]!==0)return 1;return 0},Pq=!1,lW=(Q)=>{if(!Pq)cW(),Pq=!0;Q.l_desc=new f5(Q.dyn_ltree,U7),Q.d_desc=new f5(Q.dyn_dtree,V7),Q.bl_desc=new f5(Q.bl_tree,$7),Q.bi_buf=0,Q.bi_valid=0,K7(Q)},O7=(Q,Y,J,X)=>{if(F0(Q,(xW<<1)+(X?1:0),3),j7(Q),jQ(Q,J),jQ(Q,~J),J)Q.pending_buf.set(Q.window.subarray(Y,Y+J),Q.pending);Q.pending+=J},nW=(Q)=>{F0(Q,J7<<1,3),Y8(Q,YY,w8),mW(Q)},oW=(Q,Y,J,X)=>{let q,G,W=0;if(Q.level>0){if(Q.strm.data_type===2)Q.strm.data_type=dW(Q);if(n5(Q,Q.l_desc),n5(Q,Q.d_desc),W=pW(Q),q=Q.opt_len+3+7>>>3,G=Q.static_len+3+7>>>3,G<=q)q=G}else q=G=J+5;if(J+4<=q&&Y!==-1)O7(Q,Y,J,X);else if(Q.strategy===4||G===q)F0(Q,(J7<<1)+(X?1:0),3),Dq(Q,w8,VQ);else F0(Q,(fW<<1)+(X?1:0),3),uW(Q,Q.l_desc.max_code+1,Q.d_desc.max_code+1,W+1),Dq(Q,Q.dyn_ltree,Q.dyn_dtree);if(K7(Q),X)j7(Q)},iW=(Q,Y,J)=>{if(Q.pending_buf[Q.sym_buf+Q.sym_next++]=Y,Q.pending_buf[Q.sym_buf+Q.sym_next++]=Y>>8,Q.pending_buf[Q.sym_buf+Q.sym_next++]=J,Y===0)Q.dyn_ltree[J*2]++;else Q.matches++,Y--,Q.dyn_ltree[(KQ[J]+HQ+1)*2]++,Q.dyn_dtree[Z7(Y)*2]++;return Q.sym_next===Q.sym_end},rW=lW,aW=O7,tW=oW,sW=iW,eW=nW,QU={_tr_init:rW,_tr_stored_block:aW,_tr_flush_block:tW,_tr_tally:sW,_tr_align:eW},JU=(Q,Y,J,X)=>{let q=Q&65535|0,G=Q>>>16&65535|0,W=0;while(J!==0){W=J>2000?2000:J,J-=W;do q=q+Y[X++]|0,G=G+q|0;while(--W);q%=65521,G%=65521}return q|G<<16|0},OQ=JU,YU=()=>{let Q,Y=[];for(var J=0;J<256;J++){Q=J;for(var X=0;X<8;X++)Q=Q&1?3988292384^Q>>>1:Q>>>1;Y[J]=Q}return Y},XU=new Uint32Array(YU()),qU=(Q,Y,J,X)=>{const q=XU,G=X+J;Q^=-1;for(let W=X;W<G;W++)Q=Q>>>8^q[(Q^Y[W])&255];return Q^-1},j0=qU,V9={2:"need dictionary",1:"stream end",0:"","-1":"file error","-2":"stream error","-3":"data error","-4":"insufficient memory","-5":"buffer error","-6":"incompatible version"},z9={Z_NO_FLUSH:0,Z_PARTIAL_FLUSH:1,Z_SYNC_FLUSH:2,Z_FULL_FLUSH:3,Z_FINISH:4,Z_BLOCK:5,Z_TREES:6,Z_OK:0,Z_STREAM_END:1,Z_NEED_DICT:2,Z_ERRNO:-1,Z_STREAM_ERROR:-2,Z_DATA_ERROR:-3,Z_MEM_ERROR:-4,Z_BUF_ERROR:-5,Z_NO_COMPRESSION:0,Z_BEST_SPEED:1,Z_BEST_COMPRESSION:9,Z_DEFAULT_COMPRESSION:-1,Z_FILTERED:1,Z_HUFFMAN_ONLY:2,Z_RLE:3,Z_FIXED:4,Z_DEFAULT_STRATEGY:0,Z_BINARY:0,Z_TEXT:1,Z_UNKNOWN:2,Z_DEFLATED:8},{_tr_init:GU,_tr_stored_block:o5,_tr_flush_block:WU,_tr_tally:m8,_tr_align:UU}=QU,{Z_NO_FLUSH:_8,Z_PARTIAL_FLUSH:VU,Z_FULL_FLUSH:$U,Z_FINISH:p0,Z_BLOCK:Cq,Z_OK:L0,Z_STREAM_END:Tq,Z_STREAM_ERROR:X8,Z_DATA_ERROR:ZU,Z_BUF_ERROR:v5,Z_DEFAULT_COMPRESSION:zU,Z_FILTERED:MU,Z_HUFFMAN_ONLY:LJ,Z_RLE:KU,Z_FIXED:jU,Z_DEFAULT_STRATEGY:OU,Z_UNKNOWN:IU,Z_DEFLATED:FJ}=z9,LU=9,DU=15,HU=8,RU=29,PU=256,i5=PU+1+RU,CU=30,TU=19,NU=2*i5+1,wU=15,u=3,h8=258,q8=h8+u+1,FU=32,b9=42,qY=57,r5=69,a5=73,t5=91,s5=103,W9=113,WQ=666,T0=1,y9=2,$9=3,h9=4,BU=3,U9=(Q,Y)=>{return Q.msg=V9[Y],Y},Nq=(Q)=>{return Q*2-(Q>4?9:0)},y8=(Q)=>{let Y=Q.length;while(--Y>=0)Q[Y]=0},EU=(Q)=>{let Y,J,X,q=Q.w_size;Y=Q.hash_size,X=Y;do J=Q.head[--X],Q.head[X]=J>=q?J-q:0;while(--Y);Y=q,X=Y;do J=Q.prev[--X],Q.prev[X]=J>=q?J-q:0;while(--Y)},SU=(Q,Y,J)=>(Y<<Q.hash_shift^J)&Q.hash_mask,c8=SU,f0=(Q)=>{const Y=Q.state;let J=Y.pending;if(J>Q.avail_out)J=Q.avail_out;if(J===0)return;if(Q.output.set(Y.pending_buf.subarray(Y.pending_out,Y.pending_out+J),Q.next_out),Q.next_out+=J,Y.pending_out+=J,Q.total_out+=J,Q.avail_out-=J,Y.pending-=J,Y.pending===0)Y.pending_out=0},b0=(Q,Y)=>{WU(Q,Q.block_start>=0?Q.block_start:-1,Q.strstart-Q.block_start,Y),Q.block_start=Q.strstart,f0(Q.strm)},o=(Q,Y)=>{Q.pending_buf[Q.pending++]=Y},GQ=(Q,Y)=>{Q.pending_buf[Q.pending++]=Y>>>8&255,Q.pending_buf[Q.pending++]=Y&255},e5=(Q,Y,J,X)=>{let q=Q.avail_in;if(q>X)q=X;if(q===0)return 0;if(Q.avail_in-=q,Y.set(Q.input.subarray(Q.next_in,Q.next_in+q),J),Q.state.wrap===1)Q.adler=OQ(Q.adler,Y,q,J);else if(Q.state.wrap===2)Q.adler=j0(Q.adler,Y,q,J);return Q.next_in+=q,Q.total_in+=q,q},I7=(Q,Y)=>{let{max_chain_length:J,strstart:X}=Q,q,G,W=Q.prev_length,U=Q.nice_match;const $=Q.strstart>Q.w_size-q8?Q.strstart-(Q.w_size-q8):0,V=Q.window,Z=Q.w_mask,K=Q.prev,M=Q.strstart+h8;let j=V[X+W-1],z=V[X+W];if(Q.prev_length>=Q.good_match)J>>=2;if(U>Q.lookahead)U=Q.lookahead;do{if(q=Y,V[q+W]!==z||V[q+W-1]!==j||V[q]!==V[X]||V[++q]!==V[X+1])continue;X+=2,q++;do;while(V[++X]===V[++q]&&V[++X]===V[++q]&&V[++X]===V[++q]&&V[++X]===V[++q]&&V[++X]===V[++q]&&V[++X]===V[++q]&&V[++X]===V[++q]&&V[++X]===V[++q]&&X<M);if(G=h8-(M-X),X=M-h8,G>W){if(Q.match_start=Y,W=G,G>=U)break;j=V[X+W-1],z=V[X+W]}}while((Y=K[Y&Z])>$&&--J!==0);if(W<=Q.lookahead)return W;return Q.lookahead},v9=(Q)=>{const Y=Q.w_size;let J,X,q;do{if(X=Q.window_size-Q.lookahead-Q.strstart,Q.strstart>=Y+(Y-q8)){if(Q.window.set(Q.window.subarray(Y,Y+Y-X),0),Q.match_start-=Y,Q.strstart-=Y,Q.block_start-=Y,Q.insert>Q.strstart)Q.insert=Q.strstart;EU(Q),X+=Y}if(Q.strm.avail_in===0)break;if(J=e5(Q.strm,Q.window,Q.strstart+Q.lookahead,X),Q.lookahead+=J,Q.lookahead+Q.insert>=u){q=Q.strstart-Q.insert,Q.ins_h=Q.window[q],Q.ins_h=c8(Q,Q.ins_h,Q.window[q+1]);while(Q.insert)if(Q.ins_h=c8(Q,Q.ins_h,Q.window[q+u-1]),Q.prev[q&Q.w_mask]=Q.head[Q.ins_h],Q.head[Q.ins_h]=q,q++,Q.insert--,Q.lookahead+Q.insert<u)break}}while(Q.lookahead<q8&&Q.strm.avail_in!==0)},L7=(Q,Y)=>{let J=Q.pending_buf_size-5>Q.w_size?Q.w_size:Q.pending_buf_size-5,X,q,G,W=0,U=Q.strm.avail_in;do{if(X=65535,G=Q.bi_valid+42>>3,Q.strm.avail_out<G)break;if(G=Q.strm.avail_out-G,q=Q.strstart-Q.block_start,X>q+Q.strm.avail_in)X=q+Q.strm.avail_in;if(X>G)X=G;if(X<J&&(X===0&&Y!==p0||Y===_8||X!==q+Q.strm.avail_in))break;if(W=Y===p0&&X===q+Q.strm.avail_in?1:0,o5(Q,0,0,W),Q.pending_buf[Q.pending-4]=X,Q.pending_buf[Q.pending-3]=X>>8,Q.pending_buf[Q.pending-2]=~X,Q.pending_buf[Q.pending-1]=~X>>8,f0(Q.strm),q){if(q>X)q=X;Q.strm.output.set(Q.window.subarray(Q.block_start,Q.block_start+q),Q.strm.next_out),Q.strm.next_out+=q,Q.strm.avail_out-=q,Q.strm.total_out+=q,Q.block_start+=q,X-=q}if(X)e5(Q.strm,Q.strm.output,Q.strm.next_out,X),Q.strm.next_out+=X,Q.strm.avail_out-=X,Q.strm.total_out+=X}while(W===0);if(U-=Q.strm.avail_in,U){if(U>=Q.w_size)Q.matches=2,Q.window.set(Q.strm.input.subarray(Q.strm.next_in-Q.w_size,Q.strm.next_in),0),Q.strstart=Q.w_size,Q.insert=Q.strstart;else{if(Q.window_size-Q.strstart<=U){if(Q.strstart-=Q.w_size,Q.window.set(Q.window.subarray(Q.w_size,Q.w_size+Q.strstart),0),Q.matches<2)Q.matches++;if(Q.insert>Q.strstart)Q.insert=Q.strstart}Q.window.set(Q.strm.input.subarray(Q.strm.next_in-U,Q.strm.next_in),Q.strstart),Q.strstart+=U,Q.insert+=U>Q.w_size-Q.insert?Q.w_size-Q.insert:U}Q.block_start=Q.strstart}if(Q.high_water<Q.strstart)Q.high_water=Q.strstart;if(W)return h9;if(Y!==_8&&Y!==p0&&Q.strm.avail_in===0&&Q.strstart===Q.block_start)return y9;if(G=Q.window_size-Q.strstart,Q.strm.avail_in>G&&Q.block_start>=Q.w_size){if(Q.block_start-=Q.w_size,Q.strstart-=Q.w_size,Q.window.set(Q.window.subarray(Q.w_size,Q.w_size+Q.strstart),0),Q.matches<2)Q.matches++;if(G+=Q.w_size,Q.insert>Q.strstart)Q.insert=Q.strstart}if(G>Q.strm.avail_in)G=Q.strm.avail_in;if(G)e5(Q.strm,Q.window,Q.strstart,G),Q.strstart+=G,Q.insert+=G>Q.w_size-Q.insert?Q.w_size-Q.insert:G;if(Q.high_water<Q.strstart)Q.high_water=Q.strstart;if(G=Q.bi_valid+42>>3,G=Q.pending_buf_size-G>65535?65535:Q.pending_buf_size-G,J=G>Q.w_size?Q.w_size:G,q=Q.strstart-Q.block_start,q>=J||(q||Y===p0)&&Y!==_8&&Q.strm.avail_in===0&&q<=G)X=q>G?G:q,W=Y===p0&&Q.strm.avail_in===0&&X===q?1:0,o5(Q,Q.block_start,X,W),Q.block_start+=X,f0(Q.strm);return W?$9:T0},g5=(Q,Y)=>{let J,X;for(;;){if(Q.lookahead<q8){if(v9(Q),Q.lookahead<q8&&Y===_8)return T0;if(Q.lookahead===0)break}if(J=0,Q.lookahead>=u)Q.ins_h=c8(Q,Q.ins_h,Q.window[Q.strstart+u-1]),J=Q.prev[Q.strstart&Q.w_mask]=Q.head[Q.ins_h],Q.head[Q.ins_h]=Q.strstart;if(J!==0&&Q.strstart-J<=Q.w_size-q8)Q.match_length=I7(Q,J);if(Q.match_length>=u)if(X=m8(Q,Q.strstart-Q.match_start,Q.match_length-u),Q.lookahead-=Q.match_length,Q.match_length<=Q.max_lazy_match&&Q.lookahead>=u){Q.match_length--;do Q.strstart++,Q.ins_h=c8(Q,Q.ins_h,Q.window[Q.strstart+u-1]),J=Q.prev[Q.strstart&Q.w_mask]=Q.head[Q.ins_h],Q.head[Q.ins_h]=Q.strstart;while(--Q.match_length!==0);Q.strstart++}else Q.strstart+=Q.match_length,Q.match_length=0,Q.ins_h=Q.window[Q.strstart],Q.ins_h=c8(Q,Q.ins_h,Q.window[Q.strstart+1]);else X=m8(Q,0,Q.window[Q.strstart]),Q.lookahead--,Q.strstart++;if(X){if(b0(Q,!1),Q.strm.avail_out===0)return T0}}if(Q.insert=Q.strstart<u-1?Q.strstart:u-1,Y===p0){if(b0(Q,!0),Q.strm.avail_out===0)return $9;return h9}if(Q.sym_next){if(b0(Q,!1),Q.strm.avail_out===0)return T0}return y9},k9=(Q,Y)=>{let J,X,q;for(;;){if(Q.lookahead<q8){if(v9(Q),Q.lookahead<q8&&Y===_8)return T0;if(Q.lookahead===0)break}if(J=0,Q.lookahead>=u)Q.ins_h=c8(Q,Q.ins_h,Q.window[Q.strstart+u-1]),J=Q.prev[Q.strstart&Q.w_mask]=Q.head[Q.ins_h],Q.head[Q.ins_h]=Q.strstart;if(Q.prev_length=Q.match_length,Q.prev_match=Q.match_start,Q.match_length=u-1,J!==0&&Q.prev_length<Q.max_lazy_match&&Q.strstart-J<=Q.w_size-q8){if(Q.match_length=I7(Q,J),Q.match_length<=5&&(Q.strategy===MU||Q.match_length===u&&Q.strstart-Q.match_start>4096))Q.match_length=u-1}if(Q.prev_length>=u&&Q.match_length<=Q.prev_length){q=Q.strstart+Q.lookahead-u,X=m8(Q,Q.strstart-1-Q.prev_match,Q.prev_length-u),Q.lookahead-=Q.prev_length-1,Q.prev_length-=2;do if(++Q.strstart<=q)Q.ins_h=c8(Q,Q.ins_h,Q.window[Q.strstart+u-1]),J=Q.prev[Q.strstart&Q.w_mask]=Q.head[Q.ins_h],Q.head[Q.ins_h]=Q.strstart;while(--Q.prev_length!==0);if(Q.match_available=0,Q.match_length=u-1,Q.strstart++,X){if(b0(Q,!1),Q.strm.avail_out===0)return T0}}else if(Q.match_available){if(X=m8(Q,0,Q.window[Q.strstart-1]),X)b0(Q,!1);if(Q.strstart++,Q.lookahead--,Q.strm.avail_out===0)return T0}else Q.match_available=1,Q.strstart++,Q.lookahead--}if(Q.match_available)X=m8(Q,0,Q.window[Q.strstart-1]),Q.match_available=0;if(Q.insert=Q.strstart<u-1?Q.strstart:u-1,Y===p0){if(b0(Q,!0),Q.strm.avail_out===0)return $9;return h9}if(Q.sym_next){if(b0(Q,!1),Q.strm.avail_out===0)return T0}return y9},AU=(Q,Y)=>{let J,X,q,G;const W=Q.window;for(;;){if(Q.lookahead<=h8){if(v9(Q),Q.lookahead<=h8&&Y===_8)return T0;if(Q.lookahead===0)break}if(Q.match_length=0,Q.lookahead>=u&&Q.strstart>0){if(q=Q.strstart-1,X=W[q],X===W[++q]&&X===W[++q]&&X===W[++q]){G=Q.strstart+h8;do;while(X===W[++q]&&X===W[++q]&&X===W[++q]&&X===W[++q]&&X===W[++q]&&X===W[++q]&&X===W[++q]&&X===W[++q]&&q<G);if(Q.match_length=h8-(G-q),Q.match_length>Q.lookahead)Q.match_length=Q.lookahead}}if(Q.match_length>=u)J=m8(Q,1,Q.match_length-u),Q.lookahead-=Q.match_length,Q.strstart+=Q.match_length,Q.match_length=0;else J=m8(Q,0,Q.window[Q.strstart]),Q.lookahead--,Q.strstart++;if(J){if(b0(Q,!1),Q.strm.avail_out===0)return T0}}if(Q.insert=0,Y===p0){if(b0(Q,!0),Q.strm.avail_out===0)return $9;return h9}if(Q.sym_next){if(b0(Q,!1),Q.strm.avail_out===0)return T0}return y9},kU=(Q,Y)=>{let J;for(;;){if(Q.lookahead===0){if(v9(Q),Q.lookahead===0){if(Y===_8)return T0;break}}if(Q.match_length=0,J=m8(Q,0,Q.window[Q.strstart]),Q.lookahead--,Q.strstart++,J){if(b0(Q,!1),Q.strm.avail_out===0)return T0}}if(Q.insert=0,Y===p0){if(b0(Q,!0),Q.strm.avail_out===0)return $9;return h9}if(Q.sym_next){if(b0(Q,!1),Q.strm.avail_out===0)return T0}return y9},UQ=[new J8(0,0,0,0,L7),new J8(4,4,8,4,g5),new J8(4,5,16,8,g5),new J8(4,6,32,32,g5),new J8(4,4,16,16,k9),new J8(8,16,32,32,k9),new J8(8,16,128,128,k9),new J8(8,32,128,256,k9),new J8(32,128,258,1024,k9),new J8(32,258,258,4096,k9)],xU=(Q)=>{Q.window_size=2*Q.w_size,y8(Q.head),Q.max_lazy_match=UQ[Q.level].max_lazy,Q.good_match=UQ[Q.level].good_length,Q.nice_match=UQ[Q.level].nice_length,Q.max_chain_length=UQ[Q.level].max_chain,Q.strstart=0,Q.block_start=0,Q.lookahead=0,Q.insert=0,Q.match_length=Q.prev_length=u-1,Q.match_available=0,Q.ins_h=0},RQ=(Q)=>{if(!Q)return 1;const Y=Q.state;if(!Y||Y.strm!==Q||Y.status!==b9&&Y.status!==qY&&Y.status!==r5&&Y.status!==a5&&Y.status!==t5&&Y.status!==s5&&Y.status!==W9&&Y.status!==WQ)return 1;return 0},D7=(Q)=>{if(RQ(Q))return U9(Q,X8);Q.total_in=Q.total_out=0,Q.data_type=IU;const Y=Q.state;if(Y.pending=0,Y.pending_out=0,Y.wrap<0)Y.wrap=-Y.wrap;return Y.status=Y.wrap===2?qY:Y.wrap?b9:W9,Q.adler=Y.wrap===2?0:1,Y.last_flush=-2,GU(Y),L0},H7=(Q)=>{const Y=D7(Q);if(Y===L0)xU(Q.state);return Y},bU=(Q,Y)=>{if(RQ(Q)||Q.state.wrap!==2)return X8;return Q.state.gzhead=Y,L0},R7=(Q,Y,J,X,q,G)=>{if(!Q)return X8;let W=1;if(Y===zU)Y=6;if(X<0)W=0,X=-X;else if(X>15)W=2,X-=16;if(q<1||q>LU||J!==FJ||X<8||X>15||Y<0||Y>9||G<0||G>jU||X===8&&W!==1)return U9(Q,X8);if(X===8)X=9;const U=new fU;return Q.state=U,U.strm=Q,U.status=b9,U.wrap=W,U.gzhead=null,U.w_bits=X,U.w_size=1<<U.w_bits,U.w_mask=U.w_size-1,U.hash_bits=q+7,U.hash_size=1<<U.hash_bits,U.hash_mask=U.hash_size-1,U.hash_shift=~~((U.hash_bits+u-1)/u),U.window=new Uint8Array(U.w_size*2),U.head=new Uint16Array(U.hash_size),U.prev=new Uint16Array(U.w_size),U.lit_bufsize=1<<q+6,U.pending_buf_size=U.lit_bufsize*4,U.pending_buf=new Uint8Array(U.pending_buf_size),U.sym_buf=U.lit_bufsize,U.sym_end=(U.lit_bufsize-1)*3,U.level=Y,U.strategy=G,U.method=J,H7(Q)},vU=(Q,Y)=>{return R7(Q,Y,FJ,DU,HU,OU)},gU=(Q,Y)=>{if(RQ(Q)||Y>Cq||Y<0)return Q?U9(Q,X8):X8;const J=Q.state;if(!Q.output||Q.avail_in!==0&&!Q.input||J.status===WQ&&Y!==p0)return U9(Q,Q.avail_out===0?v5:X8);const X=J.last_flush;if(J.last_flush=Y,J.pending!==0){if(f0(Q),Q.avail_out===0)return J.last_flush=-1,L0}else if(Q.avail_in===0&&Nq(Y)<=Nq(X)&&Y!==p0)return U9(Q,v5);if(J.status===WQ&&Q.avail_in!==0)return U9(Q,v5);if(J.status===b9&&J.wrap===0)J.status=W9;if(J.status===b9){let q=FJ+(J.w_bits-8<<4)<<8,G=-1;if(J.strategy>=LJ||J.level<2)G=0;else if(J.level<6)G=1;else if(J.level===6)G=2;else G=3;if(q|=G<<6,J.strstart!==0)q|=FU;if(q+=31-q%31,GQ(J,q),J.strstart!==0)GQ(J,Q.adler>>>16),GQ(J,Q.adler&65535);if(Q.adler=1,J.status=W9,f0(Q),J.pending!==0)return J.last_flush=-1,L0}if(J.status===qY)if(Q.adler=0,o(J,31),o(J,139),o(J,8),!J.gzhead){if(o(J,0),o(J,0),o(J,0),o(J,0),o(J,0),o(J,J.level===9?2:J.strategy>=LJ||J.level<2?4:0),o(J,BU),J.status=W9,f0(Q),J.pending!==0)return J.last_flush=-1,L0}else{if(o(J,(J.gzhead.text?1:0)+(J.gzhead.hcrc?2:0)+(!J.gzhead.extra?0:4)+(!J.gzhead.name?0:8)+(!J.gzhead.comment?0:16)),o(J,J.gzhead.time&255),o(J,J.gzhead.time>>8&255),o(J,J.gzhead.time>>16&255),o(J,J.gzhead.time>>24&255),o(J,J.level===9?2:J.strategy>=LJ||J.level<2?4:0),o(J,J.gzhead.os&255),J.gzhead.extra&&J.gzhead.extra.length)o(J,J.gzhead.extra.length&255),o(J,J.gzhead.extra.length>>8&255);if(J.gzhead.hcrc)Q.adler=j0(Q.adler,J.pending_buf,J.pending,0);J.gzindex=0,J.status=r5}if(J.status===r5){if(J.gzhead.extra){let q=J.pending,G=(J.gzhead.extra.length&65535)-J.gzindex;while(J.pending+G>J.pending_buf_size){let U=J.pending_buf_size-J.pending;if(J.pending_buf.set(J.gzhead.extra.subarray(J.gzindex,J.gzindex+U),J.pending),J.pending=J.pending_buf_size,J.gzhead.hcrc&&J.pending>q)Q.adler=j0(Q.adler,J.pending_buf,J.pending-q,q);if(J.gzindex+=U,f0(Q),J.pending!==0)return J.last_flush=-1,L0;q=0,G-=U}let W=new Uint8Array(J.gzhead.extra);if(J.pending_buf.set(W.subarray(J.gzindex,J.gzindex+G),J.pending),J.pending+=G,J.gzhead.hcrc&&J.pending>q)Q.adler=j0(Q.adler,J.pending_buf,J.pending-q,q);J.gzindex=0}J.status=a5}if(J.status===a5){if(J.gzhead.name){let q=J.pending,G;do{if(J.pending===J.pending_buf_size){if(J.gzhead.hcrc&&J.pending>q)Q.adler=j0(Q.adler,J.pending_buf,J.pending-q,q);if(f0(Q),J.pending!==0)return J.last_flush=-1,L0;q=0}if(J.gzindex<J.gzhead.name.length)G=J.gzhead.name.charCodeAt(J.gzindex++)&255;else G=0;o(J,G)}while(G!==0);if(J.gzhead.hcrc&&J.pending>q)Q.adler=j0(Q.adler,J.pending_buf,J.pending-q,q);J.gzindex=0}J.status=t5}if(J.status===t5){if(J.gzhead.comment){let q=J.pending,G;do{if(J.pending===J.pending_buf_size){if(J.gzhead.hcrc&&J.pending>q)Q.adler=j0(Q.adler,J.pending_buf,J.pending-q,q);if(f0(Q),J.pending!==0)return J.last_flush=-1,L0;q=0}if(J.gzindex<J.gzhead.comment.length)G=J.gzhead.comment.charCodeAt(J.gzindex++)&255;else G=0;o(J,G)}while(G!==0);if(J.gzhead.hcrc&&J.pending>q)Q.adler=j0(Q.adler,J.pending_buf,J.pending-q,q)}J.status=s5}if(J.status===s5){if(J.gzhead.hcrc){if(J.pending+2>J.pending_buf_size){if(f0(Q),J.pending!==0)return J.last_flush=-1,L0}o(J,Q.adler&255),o(J,Q.adler>>8&255),Q.adler=0}if(J.status=W9,f0(Q),J.pending!==0)return J.last_flush=-1,L0}if(Q.avail_in!==0||J.lookahead!==0||Y!==_8&&J.status!==WQ){let q=J.level===0?L7(J,Y):J.strategy===LJ?kU(J,Y):J.strategy===KU?AU(J,Y):UQ[J.level].func(J,Y);if(q===$9||q===h9)J.status=WQ;if(q===T0||q===$9){if(Q.avail_out===0)J.last_flush=-1;return L0}if(q===y9){if(Y===VU)UU(J);else if(Y!==Cq){if(o5(J,0,0,!1),Y===$U){if(y8(J.head),J.lookahead===0)J.strstart=0,J.block_start=0,J.insert=0}}if(f0(Q),Q.avail_out===0)return J.last_flush=-1,L0}}if(Y!==p0)return L0;if(J.wrap<=0)return Tq;if(J.wrap===2)o(J,Q.adler&255),o(J,Q.adler>>8&255),o(J,Q.adler>>16&255),o(J,Q.adler>>24&255),o(J,Q.total_in&255),o(J,Q.total_in>>8&255),o(J,Q.total_in>>16&255),o(J,Q.total_in>>24&255);else GQ(J,Q.adler>>>16),GQ(J,Q.adler&65535);if(f0(Q),J.wrap>0)J.wrap=-J.wrap;return J.pending!==0?L0:Tq},yU=(Q)=>{if(RQ(Q))return X8;const Y=Q.state.status;return Q.state=null,Y===W9?U9(Q,ZU):L0},hU=(Q,Y)=>{let J=Y.length;if(RQ(Q))return X8;const X=Q.state,q=X.wrap;if(q===2||q===1&&X.status!==b9||X.lookahead)return X8;if(q===1)Q.adler=OQ(Q.adler,Y,J,0);if(X.wrap=0,J>=X.w_size){if(q===0)y8(X.head),X.strstart=0,X.block_start=0,X.insert=0;let $=new Uint8Array(X.w_size);$.set(Y.subarray(J-X.w_size,J),0),Y=$,J=X.w_size}const{avail_in:G,next_in:W,input:U}=Q;Q.avail_in=J,Q.next_in=0,Q.input=Y,v9(X);while(X.lookahead>=u){let $=X.strstart,V=X.lookahead-(u-1);do X.ins_h=c8(X,X.ins_h,X.window[$+u-1]),X.prev[$&X.w_mask]=X.head[X.ins_h],X.head[X.ins_h]=$,$++;while(--V);X.strstart=$,X.lookahead=u-1,v9(X)}return X.strstart+=X.lookahead,X.block_start=X.strstart,X.insert=X.lookahead,X.lookahead=0,X.match_length=X.prev_length=u-1,X.match_available=0,Q.next_in=W,Q.input=U,Q.avail_in=G,X.wrap=q,L0},mU=vU,_U=R7,cU=H7,pU=D7,uU=bU,dU=gU,lU=yU,nU=hU,oU="pako deflate (from Nodeca project)",$Q={deflateInit:mU,deflateInit2:_U,deflateReset:cU,deflateResetKeep:pU,deflateSetHeader:uU,deflate:dU,deflateEnd:lU,deflateSetDictionary:nU,deflateInfo:oU},iU=(Q,Y)=>{return Object.prototype.hasOwnProperty.call(Q,Y)},rU=function(Q){const Y=Array.prototype.slice.call(arguments,1);while(Y.length){const J=Y.shift();if(!J)continue;if(typeof J!=="object")throw new TypeError(J+"must be non-object");for(let X in J)if(iU(J,X))Q[X]=J[X]}return Q},aU=(Q)=>{let Y=0;for(let X=0,q=Q.length;X<q;X++)Y+=Q[X].length;const J=new Uint8Array(Y);for(let X=0,q=0,G=Q.length;X<G;X++){let W=Q[X];J.set(W,q),q+=W.length}return J},BJ={assign:rU,flattenChunks:aU},P7=!0;try{String.fromCharCode.apply(null,new Uint8Array(1))}catch(Q){P7=!1}var IQ=new Uint8Array(256);for(let Q=0;Q<256;Q++)IQ[Q]=Q>=252?6:Q>=248?5:Q>=240?4:Q>=224?3:Q>=192?2:1;IQ[254]=IQ[254]=1;var tU=(Q)=>{if(typeof TextEncoder==="function"&&TextEncoder.prototype.encode)return(new TextEncoder()).encode(Q);let Y,J,X,q,G,W=Q.length,U=0;for(q=0;q<W;q++){if(J=Q.charCodeAt(q),(J&64512)===55296&&q+1<W){if(X=Q.charCodeAt(q+1),(X&64512)===56320)J=65536+(J-55296<<10)+(X-56320),q++}U+=J<128?1:J<2048?2:J<65536?3:4}Y=new Uint8Array(U);for(G=0,q=0;G<U;q++){if(J=Q.charCodeAt(q),(J&64512)===55296&&q+1<W){if(X=Q.charCodeAt(q+1),(X&64512)===56320)J=65536+(J-55296<<10)+(X-56320),q++}if(J<128)Y[G++]=J;else if(J<2048)Y[G++]=192|J>>>6,Y[G++]=128|J&63;else if(J<65536)Y[G++]=224|J>>>12,Y[G++]=128|J>>>6&63,Y[G++]=128|J&63;else Y[G++]=240|J>>>18,Y[G++]=128|J>>>12&63,Y[G++]=128|J>>>6&63,Y[G++]=128|J&63}return Y},sU=(Q,Y)=>{if(Y<65534){if(Q.subarray&&P7)return String.fromCharCode.apply(null,Q.length===Y?Q:Q.subarray(0,Y))}let J="";for(let X=0;X<Y;X++)J+=String.fromCharCode(Q[X]);return J},eU=(Q,Y)=>{const J=Y||Q.length;if(typeof TextDecoder==="function"&&TextDecoder.prototype.decode)return(new TextDecoder()).decode(Q.subarray(0,Y));let X,q;const G=new Array(J*2);for(q=0,X=0;X<J;){let W=Q[X++];if(W<128){G[q++]=W;continue}let U=IQ[W];if(U>4){G[q++]=65533,X+=U-1;continue}W&=U===2?31:U===3?15:7;while(U>1&&X<J)W=W<<6|Q[X++]&63,U--;if(U>1){G[q++]=65533;continue}if(W<65536)G[q++]=W;else W-=65536,G[q++]=55296|W>>10&1023,G[q++]=56320|W&1023}return sU(G,q)},QV=(Q,Y)=>{if(Y=Y||Q.length,Y>Q.length)Y=Q.length;let J=Y-1;while(J>=0&&(Q[J]&192)===128)J--;if(J<0)return Y;if(J===0)return Y;return J+IQ[Q[J]]>Y?J:Y},LQ={string2buf:tU,buf2string:eU,utf8border:QV},C7=JV,T7=Object.prototype.toString,{Z_NO_FLUSH:YV,Z_SYNC_FLUSH:XV,Z_FULL_FLUSH:qV,Z_FINISH:GV,Z_OK:NJ,Z_STREAM_END:WV,Z_DEFAULT_COMPRESSION:UV,Z_DEFAULT_STRATEGY:VV,Z_DEFLATED:$V}=z9;PQ.prototype.push=function(Q,Y){const J=this.strm,X=this.options.chunkSize;let q,G;if(this.ended)return!1;if(Y===~~Y)G=Y;else G=Y===!0?GV:YV;if(typeof Q==="string")J.input=LQ.string2buf(Q);else if(T7.call(Q)==="[object ArrayBuffer]")J.input=new Uint8Array(Q);else J.input=Q;J.next_in=0,J.avail_in=J.input.length;for(;;){if(J.avail_out===0)J.output=new Uint8Array(X),J.next_out=0,J.avail_out=X;if((G===XV||G===qV)&&J.avail_out<=6){this.onData(J.output.subarray(0,J.next_out)),J.avail_out=0;continue}if(q=$Q.deflate(J,G),q===WV){if(J.next_out>0)this.onData(J.output.subarray(0,J.next_out));return q=$Q.deflateEnd(this.strm),this.onEnd(q),this.ended=!0,q===NJ}if(J.avail_out===0){this.onData(J.output);continue}if(G>0&&J.next_out>0){this.onData(J.output.subarray(0,J.next_out)),J.avail_out=0;continue}if(J.avail_in===0)break}return!0};PQ.prototype.onData=function(Q){this.chunks.push(Q)};PQ.prototype.onEnd=function(Q){if(Q===NJ)this.result=BJ.flattenChunks(this.chunks);this.chunks=[],this.err=Q,this.msg=this.strm.msg};var MV=PQ,KV=GY,jV=ZV,OV=zV,IV=z9,LV={Deflate:MV,deflate:KV,deflateRaw:jV,gzip:OV,constants:IV},DJ=16209,DV=16191,HV=function Q(Y,J){let X,q,G,W,U,$,V,Z,K,M,j,z,L,H,P,C,S,O,D,T,R,A,w,N;const k=Y.state;X=Y.next_in,w=Y.input,q=X+(Y.avail_in-5),G=Y.next_out,N=Y.output,W=G-(J-Y.avail_out),U=G+(Y.avail_out-257),$=k.dmax,V=k.wsize,Z=k.whave,K=k.wnext,M=k.window,j=k.hold,z=k.bits,L=k.lencode,H=k.distcode,P=(1<<k.lenbits)-1,C=(1<<k.distbits)-1;Q:do{if(z<15)j+=w[X++]<<z,z+=8,j+=w[X++]<<z,z+=8;S=L[j&P];J:for(;;){if(O=S>>>24,j>>>=O,z-=O,O=S>>>16&255,O===0)N[G++]=S&65535;else if(O&16){if(D=S&65535,O&=15,O){if(z<O)j+=w[X++]<<z,z+=8;D+=j&(1<<O)-1,j>>>=O,z-=O}if(z<15)j+=w[X++]<<z,z+=8,j+=w[X++]<<z,z+=8;S=H[j&C];Y:for(;;){if(O=S>>>24,j>>>=O,z-=O,O=S>>>16&255,O&16){if(T=S&65535,O&=15,z<O){if(j+=w[X++]<<z,z+=8,z<O)j+=w[X++]<<z,z+=8}if(T+=j&(1<<O)-1,T>$){Y.msg="invalid distance too far back",k.mode=DJ;break Q}if(j>>>=O,z-=O,O=G-W,T>O){if(O=T-O,O>Z){if(k.sane){Y.msg="invalid distance too far back",k.mode=DJ;break Q}}if(R=0,A=M,K===0){if(R+=V-O,O<D){D-=O;do N[G++]=M[R++];while(--O);R=G-T,A=N}}else if(K<O){if(R+=V+K-O,O-=K,O<D){D-=O;do N[G++]=M[R++];while(--O);if(R=0,K<D){O=K,D-=O;do N[G++]=M[R++];while(--O);R=G-T,A=N}}}else if(R+=K-O,O<D){D-=O;do N[G++]=M[R++];while(--O);R=G-T,A=N}while(D>2)N[G++]=A[R++],N[G++]=A[R++],N[G++]=A[R++],D-=3;if(D){if(N[G++]=A[R++],D>1)N[G++]=A[R++]}}else{R=G-T;do N[G++]=N[R++],N[G++]=N[R++],N[G++]=N[R++],D-=3;while(D>2);if(D){if(N[G++]=N[R++],D>1)N[G++]=N[R++]}}}else if((O&64)===0){S=H[(S&65535)+(j&(1<<O)-1)];continue Y}else{Y.msg="invalid distance code",k.mode=DJ;break Q}break}}else if((O&64)===0){S=L[(S&65535)+(j&(1<<O)-1)];continue J}else if(O&32){k.mode=DV;break Q}else{Y.msg="invalid literal/length code",k.mode=DJ;break Q}break}}while(X<q&&G<U);D=z>>3,X-=D,z-=D<<3,j&=(1<<z)-1,Y.next_in=X,Y.next_out=G,Y.avail_in=X<q?5+(q-X):5-(X-q),Y.avail_out=G<U?257+(U-G):257-(G-U),k.hold=j,k.bits=z;return},x9=15,wq=852,Fq=592,Bq=0,y5=1,Eq=2,RV=new Uint16Array([3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,0,0]),PV=new Uint8Array([16,16,16,16,16,16,16,16,17,17,17,17,18,18,18,18,19,19,19,19,20,20,20,20,21,21,21,21,16,72,78]),CV=new Uint16Array([1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,0,0]),TV=new Uint8Array([16,16,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,64,64]),NV=(Q,Y,J,X,q,G,W,U)=>{const $=U.bits;let V=0,Z=0,K=0,M=0,j=0,z=0,L=0,H=0,P=0,C=0,S,O,D,T,R,A=null,w;const N=new Uint16Array(x9+1),k=new Uint16Array(x9+1);let v=null,r,g,F;for(V=0;V<=x9;V++)N[V]=0;for(Z=0;Z<X;Z++)N[Y[J+Z]]++;j=$;for(M=x9;M>=1;M--)if(N[M]!==0)break;if(j>M)j=M;if(M===0)return q[G++]=1<<24|64<<16|0,q[G++]=1<<24|64<<16|0,U.bits=1,0;for(K=1;K<M;K++)if(N[K]!==0)break;if(j<K)j=K;H=1;for(V=1;V<=x9;V++)if(H<<=1,H-=N[V],H<0)return-1;if(H>0&&(Q===Bq||M!==1))return-1;k[1]=0;for(V=1;V<x9;V++)k[V+1]=k[V]+N[V];for(Z=0;Z<X;Z++)if(Y[J+Z]!==0)W[k[Y[J+Z]]++]=Z;if(Q===Bq)A=v=W,w=20;else if(Q===y5)A=RV,v=PV,w=257;else A=CV,v=TV,w=0;if(C=0,Z=0,V=K,R=G,z=j,L=0,D=-1,P=1<<j,T=P-1,Q===y5&&P>wq||Q===Eq&&P>Fq)return 1;for(;;){if(r=V-L,W[Z]+1<w)g=0,F=W[Z];else if(W[Z]>=w)g=v[W[Z]-w],F=A[W[Z]-w];else g=96,F=0;S=1<<V-L,O=1<<z,K=O;do O-=S,q[R+(C>>L)+O]=r<<24|g<<16|F|0;while(O!==0);S=1<<V-1;while(C&S)S>>=1;if(S!==0)C&=S-1,C+=S;else C=0;if(Z++,--N[V]===0){if(V===M)break;V=Y[J+W[Z]]}if(V>j&&(C&T)!==D){if(L===0)L=j;R+=K,z=V-L,H=1<<z;while(z+L<M){if(H-=N[z+L],H<=0)break;z++,H<<=1}if(P+=1<<z,Q===y5&&P>wq||Q===Eq&&P>Fq)return 1;D=C&T,q[D]=j<<24|z<<16|R-G|0}}if(C!==0)q[R+C]=V-L<<24|64<<16|0;return U.bits=j,0},ZQ=NV,wV=0,N7=1,w7=2,{Z_FINISH:Sq,Z_BLOCK:FV,Z_TREES:HJ,Z_OK:Z9,Z_STREAM_END:BV,Z_NEED_DICT:EV,Z_STREAM_ERROR:u0,Z_DATA_ERROR:F7,Z_MEM_ERROR:B7,Z_BUF_ERROR:SV,Z_DEFLATED:Aq}=z9,EJ=16180,kq=16181,xq=16182,fq=16183,bq=16184,vq=16185,gq=16186,yq=16187,hq=16188,mq=16189,wJ=16190,N8=16191,h5=16192,_q=16193,m5=16194,cq=16195,pq=16196,uq=16197,dq=16198,RJ=16199,PJ=16200,lq=16201,nq=16202,oq=16203,iq=16204,rq=16205,_5=16206,aq=16207,tq=16208,J0=16209,E7=16210,S7=16211,AV=852,kV=592,xV=15,fV=xV,sq=(Q)=>{return(Q>>>24&255)+(Q>>>8&65280)+((Q&65280)<<8)+((Q&255)<<24)},M9=(Q)=>{if(!Q)return 1;const Y=Q.state;if(!Y||Y.strm!==Q||Y.mode<EJ||Y.mode>S7)return 1;return 0},A7=(Q)=>{if(M9(Q))return u0;const Y=Q.state;if(Q.total_in=Q.total_out=Y.total=0,Q.msg="",Y.wrap)Q.adler=Y.wrap&1;return Y.mode=EJ,Y.last=0,Y.havedict=0,Y.flags=-1,Y.dmax=32768,Y.head=null,Y.hold=0,Y.bits=0,Y.lencode=Y.lendyn=new Int32Array(AV),Y.distcode=Y.distdyn=new Int32Array(kV),Y.sane=1,Y.back=-1,Z9},k7=(Q)=>{if(M9(Q))return u0;const Y=Q.state;return Y.wsize=0,Y.whave=0,Y.wnext=0,A7(Q)},x7=(Q,Y)=>{let J;if(M9(Q))return u0;const X=Q.state;if(Y<0)J=0,Y=-Y;else if(J=(Y>>4)+5,Y<48)Y&=15;if(Y&&(Y<8||Y>15))return u0;if(X.window!==null&&X.wbits!==Y)X.window=null;return X.wrap=J,X.wbits=Y,k7(Q)},f7=(Q,Y)=>{if(!Q)return u0;const J=new bV;Q.state=J,J.strm=Q,J.window=null,J.mode=EJ;const X=x7(Q,Y);if(X!==Z9)Q.state=null;return X},vV=(Q)=>{return f7(Q,fV)},eq=!0,c5,p5,gV=(Q)=>{if(eq){c5=new Int32Array(512),p5=new Int32Array(32);let Y=0;while(Y<144)Q.lens[Y++]=8;while(Y<256)Q.lens[Y++]=9;while(Y<280)Q.lens[Y++]=7;while(Y<288)Q.lens[Y++]=8;ZQ(N7,Q.lens,0,288,c5,0,Q.work,{bits:9}),Y=0;while(Y<32)Q.lens[Y++]=5;ZQ(w7,Q.lens,0,32,p5,0,Q.work,{bits:5}),eq=!1}Q.lencode=c5,Q.lenbits=9,Q.distcode=p5,Q.distbits=5},b7=(Q,Y,J,X)=>{let q;const G=Q.state;if(G.window===null)G.wsize=1<<G.wbits,G.wnext=0,G.whave=0,G.window=new Uint8Array(G.wsize);if(X>=G.wsize)G.window.set(Y.subarray(J-G.wsize,J),0),G.wnext=0,G.whave=G.wsize;else{if(q=G.wsize-G.wnext,q>X)q=X;if(G.window.set(Y.subarray(J-X,J-X+q),G.wnext),X-=q,X)G.window.set(Y.subarray(J-X,J),0),G.wnext=X,G.whave=G.wsize;else{if(G.wnext+=q,G.wnext===G.wsize)G.wnext=0;if(G.whave<G.wsize)G.whave+=q}}return 0},yV=(Q,Y)=>{let J,X,q,G,W,U,$,V,Z,K,M,j,z,L,H=0,P,C,S,O,D,T,R,A;const w=new Uint8Array(4);let N,k;const v=new Uint8Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]);if(M9(Q)||!Q.output||!Q.input&&Q.avail_in!==0)return u0;if(J=Q.state,J.mode===N8)J.mode=h5;W=Q.next_out,q=Q.output,$=Q.avail_out,G=Q.next_in,X=Q.input,U=Q.avail_in,V=J.hold,Z=J.bits,K=U,M=$,A=Z9;Q:for(;;)switch(J.mode){case EJ:if(J.wrap===0){J.mode=h5;break}while(Z<16){if(U===0)break Q;U--,V+=X[G++]<<Z,Z+=8}if(J.wrap&2&&V===35615){if(J.wbits===0)J.wbits=15;J.check=0,w[0]=V&255,w[1]=V>>>8&255,J.check=j0(J.check,w,2,0),V=0,Z=0,J.mode=kq;break}if(J.head)J.head.done=!1;if(!(J.wrap&1)||(((V&255)<<8)+(V>>8))%31){Q.msg="incorrect header check",J.mode=J0;break}if((V&15)!==Aq){Q.msg="unknown compression method",J.mode=J0;break}if(V>>>=4,Z-=4,R=(V&15)+8,J.wbits===0)J.wbits=R;if(R>15||R>J.wbits){Q.msg="invalid window size",J.mode=J0;break}J.dmax=1<<J.wbits,J.flags=0,Q.adler=J.check=1,J.mode=V&512?mq:N8,V=0,Z=0;break;case kq:while(Z<16){if(U===0)break Q;U--,V+=X[G++]<<Z,Z+=8}if(J.flags=V,(J.flags&255)!==Aq){Q.msg="unknown compression method",J.mode=J0;break}if(J.flags&57344){Q.msg="unknown header flags set",J.mode=J0;break}if(J.head)J.head.text=V>>8&1;if(J.flags&512&&J.wrap&4)w[0]=V&255,w[1]=V>>>8&255,J.check=j0(J.check,w,2,0);V=0,Z=0,J.mode=xq;case xq:while(Z<32){if(U===0)break Q;U--,V+=X[G++]<<Z,Z+=8}if(J.head)J.head.time=V;if(J.flags&512&&J.wrap&4)w[0]=V&255,w[1]=V>>>8&255,w[2]=V>>>16&255,w[3]=V>>>24&255,J.check=j0(J.check,w,4,0);V=0,Z=0,J.mode=fq;case fq:while(Z<16){if(U===0)break Q;U--,V+=X[G++]<<Z,Z+=8}if(J.head)J.head.xflags=V&255,J.head.os=V>>8;if(J.flags&512&&J.wrap&4)w[0]=V&255,w[1]=V>>>8&255,J.check=j0(J.check,w,2,0);V=0,Z=0,J.mode=bq;case bq:if(J.flags&1024){while(Z<16){if(U===0)break Q;U--,V+=X[G++]<<Z,Z+=8}if(J.length=V,J.head)J.head.extra_len=V;if(J.flags&512&&J.wrap&4)w[0]=V&255,w[1]=V>>>8&255,J.check=j0(J.check,w,2,0);V=0,Z=0}else if(J.head)J.head.extra=null;J.mode=vq;case vq:if(J.flags&1024){if(j=J.length,j>U)j=U;if(j){if(J.head){if(R=J.head.extra_len-J.length,!J.head.extra)J.head.extra=new Uint8Array(J.head.extra_len);J.head.extra.set(X.subarray(G,G+j),R)}if(J.flags&512&&J.wrap&4)J.check=j0(J.check,X,j,G);U-=j,G+=j,J.length-=j}if(J.length)break Q}J.length=0,J.mode=gq;case gq:if(J.flags&2048){if(U===0)break Q;j=0;do if(R=X[G+j++],J.head&&R&&J.length<65536)J.head.name+=String.fromCharCode(R);while(R&&j<U);if(J.flags&512&&J.wrap&4)J.check=j0(J.check,X,j,G);if(U-=j,G+=j,R)break Q}else if(J.head)J.head.name=null;J.length=0,J.mode=yq;case yq:if(J.flags&4096){if(U===0)break Q;j=0;do if(R=X[G+j++],J.head&&R&&J.length<65536)J.head.comment+=String.fromCharCode(R);while(R&&j<U);if(J.flags&512&&J.wrap&4)J.check=j0(J.check,X,j,G);if(U-=j,G+=j,R)break Q}else if(J.head)J.head.comment=null;J.mode=hq;case hq:if(J.flags&512){while(Z<16){if(U===0)break Q;U--,V+=X[G++]<<Z,Z+=8}if(J.wrap&4&&V!==(J.check&65535)){Q.msg="header crc mismatch",J.mode=J0;break}V=0,Z=0}if(J.head)J.head.hcrc=J.flags>>9&1,J.head.done=!0;Q.adler=J.check=0,J.mode=N8;break;case mq:while(Z<32){if(U===0)break Q;U--,V+=X[G++]<<Z,Z+=8}Q.adler=J.check=sq(V),V=0,Z=0,J.mode=wJ;case wJ:if(J.havedict===0)return Q.next_out=W,Q.avail_out=$,Q.next_in=G,Q.avail_in=U,J.hold=V,J.bits=Z,EV;Q.adler=J.check=1,J.mode=N8;case N8:if(Y===FV||Y===HJ)break Q;case h5:if(J.last){V>>>=Z&7,Z-=Z&7,J.mode=_5;break}while(Z<3){if(U===0)break Q;U--,V+=X[G++]<<Z,Z+=8}switch(J.last=V&1,V>>>=1,Z-=1,V&3){case 0:J.mode=_q;break;case 1:if(gV(J),J.mode=RJ,Y===HJ){V>>>=2,Z-=2;break Q}break;case 2:J.mode=pq;break;case 3:Q.msg="invalid block type",J.mode=J0}V>>>=2,Z-=2;break;case _q:V>>>=Z&7,Z-=Z&7;while(Z<32){if(U===0)break Q;U--,V+=X[G++]<<Z,Z+=8}if((V&65535)!==(V>>>16^65535)){Q.msg="invalid stored block lengths",J.mode=J0;break}if(J.length=V&65535,V=0,Z=0,J.mode=m5,Y===HJ)break Q;case m5:J.mode=cq;case cq:if(j=J.length,j){if(j>U)j=U;if(j>$)j=$;if(j===0)break Q;q.set(X.subarray(G,G+j),W),U-=j,G+=j,$-=j,W+=j,J.length-=j;break}J.mode=N8;break;case pq:while(Z<14){if(U===0)break Q;U--,V+=X[G++]<<Z,Z+=8}if(J.nlen=(V&31)+257,V>>>=5,Z-=5,J.ndist=(V&31)+1,V>>>=5,Z-=5,J.ncode=(V&15)+4,V>>>=4,Z-=4,J.nlen>286||J.ndist>30){Q.msg="too many length or distance symbols",J.mode=J0;break}J.have=0,J.mode=uq;case uq:while(J.have<J.ncode){while(Z<3){if(U===0)break Q;U--,V+=X[G++]<<Z,Z+=8}J.lens[v[J.have++]]=V&7,V>>>=3,Z-=3}while(J.have<19)J.lens[v[J.have++]]=0;if(J.lencode=J.lendyn,J.lenbits=7,N={bits:J.lenbits},A=ZQ(wV,J.lens,0,19,J.lencode,0,J.work,N),J.lenbits=N.bits,A){Q.msg="invalid code lengths set",J.mode=J0;break}J.have=0,J.mode=dq;case dq:while(J.have<J.nlen+J.ndist){for(;;){if(H=J.lencode[V&(1<<J.lenbits)-1],P=H>>>24,C=H>>>16&255,S=H&65535,P<=Z)break;if(U===0)break Q;U--,V+=X[G++]<<Z,Z+=8}if(S<16)V>>>=P,Z-=P,J.lens[J.have++]=S;else{if(S===16){k=P+2;while(Z<k){if(U===0)break Q;U--,V+=X[G++]<<Z,Z+=8}if(V>>>=P,Z-=P,J.have===0){Q.msg="invalid bit length repeat",J.mode=J0;break}R=J.lens[J.have-1],j=3+(V&3),V>>>=2,Z-=2}else if(S===17){k=P+3;while(Z<k){if(U===0)break Q;U--,V+=X[G++]<<Z,Z+=8}V>>>=P,Z-=P,R=0,j=3+(V&7),V>>>=3,Z-=3}else{k=P+7;while(Z<k){if(U===0)break Q;U--,V+=X[G++]<<Z,Z+=8}V>>>=P,Z-=P,R=0,j=11+(V&127),V>>>=7,Z-=7}if(J.have+j>J.nlen+J.ndist){Q.msg="invalid bit length repeat",J.mode=J0;break}while(j--)J.lens[J.have++]=R}}if(J.mode===J0)break;if(J.lens[256]===0){Q.msg="invalid code -- missing end-of-block",J.mode=J0;break}if(J.lenbits=9,N={bits:J.lenbits},A=ZQ(N7,J.lens,0,J.nlen,J.lencode,0,J.work,N),J.lenbits=N.bits,A){Q.msg="invalid literal/lengths set",J.mode=J0;break}if(J.distbits=6,J.distcode=J.distdyn,N={bits:J.distbits},A=ZQ(w7,J.lens,J.nlen,J.ndist,J.distcode,0,J.work,N),J.distbits=N.bits,A){Q.msg="invalid distances set",J.mode=J0;break}if(J.mode=RJ,Y===HJ)break Q;case RJ:J.mode=PJ;case PJ:if(U>=6&&$>=258){if(Q.next_out=W,Q.avail_out=$,Q.next_in=G,Q.avail_in=U,J.hold=V,J.bits=Z,HV(Q,M),W=Q.next_out,q=Q.output,$=Q.avail_out,G=Q.next_in,X=Q.input,U=Q.avail_in,V=J.hold,Z=J.bits,J.mode===N8)J.back=-1;break}J.back=0;for(;;){if(H=J.lencode[V&(1<<J.lenbits)-1],P=H>>>24,C=H>>>16&255,S=H&65535,P<=Z)break;if(U===0)break Q;U--,V+=X[G++]<<Z,Z+=8}if(C&&(C&240)===0){O=P,D=C,T=S;for(;;){if(H=J.lencode[T+((V&(1<<O+D)-1)>>O)],P=H>>>24,C=H>>>16&255,S=H&65535,O+P<=Z)break;if(U===0)break Q;U--,V+=X[G++]<<Z,Z+=8}V>>>=O,Z-=O,J.back+=O}if(V>>>=P,Z-=P,J.back+=P,J.length=S,C===0){J.mode=rq;break}if(C&32){J.back=-1,J.mode=N8;break}if(C&64){Q.msg="invalid literal/length code",J.mode=J0;break}J.extra=C&15,J.mode=lq;case lq:if(J.extra){k=J.extra;while(Z<k){if(U===0)break Q;U--,V+=X[G++]<<Z,Z+=8}J.length+=V&(1<<J.extra)-1,V>>>=J.extra,Z-=J.extra,J.back+=J.extra}J.was=J.length,J.mode=nq;case nq:for(;;){if(H=J.distcode[V&(1<<J.distbits)-1],P=H>>>24,C=H>>>16&255,S=H&65535,P<=Z)break;if(U===0)break Q;U--,V+=X[G++]<<Z,Z+=8}if((C&240)===0){O=P,D=C,T=S;for(;;){if(H=J.distcode[T+((V&(1<<O+D)-1)>>O)],P=H>>>24,C=H>>>16&255,S=H&65535,O+P<=Z)break;if(U===0)break Q;U--,V+=X[G++]<<Z,Z+=8}V>>>=O,Z-=O,J.back+=O}if(V>>>=P,Z-=P,J.back+=P,C&64){Q.msg="invalid distance code",J.mode=J0;break}J.offset=S,J.extra=C&15,J.mode=oq;case oq:if(J.extra){k=J.extra;while(Z<k){if(U===0)break Q;U--,V+=X[G++]<<Z,Z+=8}J.offset+=V&(1<<J.extra)-1,V>>>=J.extra,Z-=J.extra,J.back+=J.extra}if(J.offset>J.dmax){Q.msg="invalid distance too far back",J.mode=J0;break}J.mode=iq;case iq:if($===0)break Q;if(j=M-$,J.offset>j){if(j=J.offset-j,j>J.whave){if(J.sane){Q.msg="invalid distance too far back",J.mode=J0;break}}if(j>J.wnext)j-=J.wnext,z=J.wsize-j;else z=J.wnext-j;if(j>J.length)j=J.length;L=J.window}else L=q,z=W-J.offset,j=J.length;if(j>$)j=$;$-=j,J.length-=j;do q[W++]=L[z++];while(--j);if(J.length===0)J.mode=PJ;break;case rq:if($===0)break Q;q[W++]=J.length,$--,J.mode=PJ;break;case _5:if(J.wrap){while(Z<32){if(U===0)break Q;U--,V|=X[G++]<<Z,Z+=8}if(M-=$,Q.total_out+=M,J.total+=M,J.wrap&4&&M)Q.adler=J.check=J.flags?j0(J.check,q,M,W-M):OQ(J.check,q,M,W-M);if(M=$,J.wrap&4&&(J.flags?V:sq(V))!==J.check){Q.msg="incorrect data check",J.mode=J0;break}V=0,Z=0}J.mode=aq;case aq:if(J.wrap&&J.flags){while(Z<32){if(U===0)break Q;U--,V+=X[G++]<<Z,Z+=8}if(J.wrap&4&&V!==(J.total&4294967295)){Q.msg="incorrect length check",J.mode=J0;break}V=0,Z=0}J.mode=tq;case tq:A=BV;break Q;case J0:A=F7;break Q;case E7:return B7;case S7:default:return u0}if(Q.next_out=W,Q.avail_out=$,Q.next_in=G,Q.avail_in=U,J.hold=V,J.bits=Z,J.wsize||M!==Q.avail_out&&J.mode<J0&&(J.mode<_5||Y!==Sq)){if(b7(Q,Q.output,Q.next_out,M-Q.avail_out));}if(K-=Q.avail_in,M-=Q.avail_out,Q.total_in+=K,Q.total_out+=M,J.total+=M,J.wrap&4&&M)Q.adler=J.check=J.flags?j0(J.check,q,M,Q.next_out-M):OQ(J.check,q,M,Q.next_out-M);if(Q.data_type=J.bits+(J.last?64:0)+(J.mode===N8?128:0)+(J.mode===RJ||J.mode===m5?256:0),(K===0&&M===0||Y===Sq)&&A===Z9)A=SV;return A},hV=(Q)=>{if(M9(Q))return u0;let Y=Q.state;if(Y.window)Y.window=null;return Q.state=null,Z9},mV=(Q,Y)=>{if(M9(Q))return u0;const J=Q.state;if((J.wrap&2)===0)return u0;return J.head=Y,Y.done=!1,Z9},_V=(Q,Y)=>{const J=Y.length;let X,q,G;if(M9(Q))return u0;if(X=Q.state,X.wrap!==0&&X.mode!==wJ)return u0;if(X.mode===wJ){if(q=1,q=OQ(q,Y,J,0),q!==X.check)return F7}if(G=b7(Q,Y,J,J),G)return X.mode=E7,B7;return X.havedict=1,Z9},cV=k7,pV=x7,uV=A7,dV=vV,lV=f7,nV=yV,oV=hV,iV=mV,rV=_V,aV="pako inflate (from Nodeca project)",F8={inflateReset:cV,inflateReset2:pV,inflateResetKeep:uV,inflateInit:dV,inflateInit2:lV,inflate:nV,inflateEnd:oV,inflateGetHeader:iV,inflateSetDictionary:rV,inflateInfo:aV},sV=tV,v7=Object.prototype.toString,{Z_NO_FLUSH:eV,Z_FINISH:Q6,Z_OK:DQ,Z_STREAM_END:u5,Z_NEED_DICT:d5,Z_STREAM_ERROR:J6,Z_DATA_ERROR:Q7,Z_MEM_ERROR:Y6}=z9;CQ.prototype.push=function(Q,Y){const J=this.strm,X=this.options.chunkSize,q=this.options.dictionary;let G,W,U;if(this.ended)return!1;if(Y===~~Y)W=Y;else W=Y===!0?Q6:eV;if(v7.call(Q)==="[object ArrayBuffer]")J.input=new Uint8Array(Q);else J.input=Q;J.next_in=0,J.avail_in=J.input.length;for(;;){if(J.avail_out===0)J.output=new Uint8Array(X),J.next_out=0,J.avail_out=X;if(G=F8.inflate(J,W),G===d5&&q){if(G=F8.inflateSetDictionary(J,q),G===DQ)G=F8.inflate(J,W);else if(G===Q7)G=d5}while(J.avail_in>0&&G===u5&&J.state.wrap>0&&Q[J.next_in]!==0)F8.inflateReset(J),G=F8.inflate(J,W);switch(G){case J6:case Q7:case d5:case Y6:return this.onEnd(G),this.ended=!0,!1}if(U=J.avail_out,J.next_out){if(J.avail_out===0||G===u5)if(this.options.to==="string"){let $=LQ.utf8border(J.output,J.next_out),V=J.next_out-$,Z=LQ.buf2string(J.output,$);if(J.next_out=V,J.avail_out=X-V,V)J.output.set(J.output.subarray($,$+V),0);this.onData(Z)}else this.onData(J.output.length===J.next_out?J.output:J.output.subarray(0,J.next_out))}if(G===DQ&&U===0)continue;if(G===u5)return G=F8.inflateEnd(this.strm),this.onEnd(G),this.ended=!0,!0;if(J.avail_in===0)break}return!0};CQ.prototype.onData=function(Q){this.chunks.push(Q)};CQ.prototype.onEnd=function(Q){if(Q===DQ)if(this.options.to==="string")this.result=this.chunks.join("");else this.result=BJ.flattenChunks(this.chunks);this.chunks=[],this.err=Q,this.msg=this.strm.msg};var q6=CQ,G6=WY,W6=X6,U6=WY,V6=z9,$6={Inflate:q6,inflate:G6,inflateRaw:W6,ungzip:U6,constants:V6},{Deflate:Z6,deflate:z6,deflateRaw:M6,gzip:K6}=LV,{Inflate:j6,inflate:O6,inflateRaw:I6,ungzip:L6}=$6,D6=Z6,H6=z6,R6=M6,P6=K6,C6=j6,T6=O6,N6=I6,w6=L6,F6=z9,UY={Deflate:D6,deflate:H6,deflateRaw:R6,gzip:P6,Inflate:C6,inflate:T6,inflateRaw:N6,ungzip:w6,constants:F6};function g7(Q,Y,J,X=[]){let q=Q;const G=Y,W=J,U=(X||[]).map((O)=>{try{return _(O)}catch(D){return console.warn(`\u26A0\uFE0F SM: Invalid superadmin address skipped: ${O}`),null}}).filter(Boolean);let $=null,V=q&&typeof q.getAddress==="function"?Z():Promise.resolve();if(!q)console.log("\u2139\uFE0F SM: Instance ready for anonymous verification (no local signer).");async function Z(){if(q)$=_(await q.getAddress()),console.log(`\u2705 SM: Initialized with signer for ${$}. SuperAdmins: ${U.join(", ")}`)}async function K(O){q=O,$=null,V=O&&typeof O.getAddress==="function"?Z():Promise.resolve(),await V}async function M(){return V}function j(O){return JSON.stringify(O,Object.keys(O).sort())}async function z(O){if(!q||!$)return console.error("\u274C SM: Cannot sign operations. No active signer."),[];const D=$,T=[];for(let R of O){const A={...R,originUser:D},w=j(A);try{const N=await q.signMessage(z0(w));T.push({...R,originUser:D,originEthAddress:D,signature:N})}catch(N){console.error(`\u274C SM: Error signing operation for ${D}:`,N.message)}}return T}async function L(O){const D=[];for(let R of O){let A=null,w=null;if(!R.signature||!R.originEthAddress||!R.originUser){console.warn("\u26A0\uFE0F SM: Incomplete op. Discarding.",R);continue}try{if(A=_(R.originEthAddress),_(R.originUser)!==A){console.warn("\u26A0\uFE0F SM: Address discrepancy. Discarding.",R);continue}}catch(b){console.warn("\u26A0\uFE0F SM: Invalid address format. Discarding.",b.message,R);continue}const{signature:N,originEthAddress:k,...v}=R;w=v;const r=j(w);try{const b=XJ(z0(r),N);if(_(b)!==A){console.warn("\u26A0\uFE0F SM: Invalid signature. Discarding.",w);continue}}catch(b){console.error("\u274C SM: Signature verification error. Discarding.",b.message,w);continue}let g;if(U.includes(A))g="superadmin",console.log(`\u2139\uFE0F SM: Sender ${A} recognized as a config Super Admin.`);else{const y=(await G.get(`user:${A}`)).result?.value;if(y&&y.role&&!(y.expiresAt&&new Date(y.expiresAt)<new Date))g=y.role;else g="guest"}const F=w.type,x=W.mapChangeTypeToAction(F,w);if(W.can(g,x))D.push(w);else console.warn(`\u26A0\uFE0F SM: Sender ${A} (role: ${g}) DENIED operation with action '${x}'.`,w)}return{validatedOperations:D}}async function H(O){if(await M(),!q)throw new Error("\uD83D\uDEE1\uFE0F SM Encrypt: User session (signer) required for encryption.");try{const D=await C("ssm-encrypt-for-current-user-v1"),T=JSON.stringify(O),R=z0(T),A=UY.deflate(R),w=V0(12),N=await crypto.subtle.encrypt({name:"AES-GCM",iv:w},D,A);return JSON.stringify({iv:B(w),encrypted:B(new Uint8Array(N)),type:"aes-gcm-self-ssm-v2"})}catch(D){throw console.error("\uD83D\uDEE1\uFE0F SM: Error in encryptDataForCurrentUser:",D),new Error("\uD83D\uDEE1\uFE0F SM: Failed to encrypt personal data.")}}async function P(O){if(await M(),!q)throw new Error("\uD83D\uDEE1\uFE0F SM Decrypt: User session (signer) required for decryption.");let D;try{D=JSON.parse(O)}catch(T){throw new Error("\uD83D\uDEE1\uFE0F SM Decrypt: encryptedString is not valid JSON.")}if(D.type!=="aes-gcm-self-ssm-v2")throw new Error("\uD83D\uDEE1\uFE0F SM Decrypt: Unsupported encryption type or incorrect version.");if(!D.iv||!D.encrypted)throw new Error("\uD83D\uDEE1\uFE0F SM Decrypt: Invalid encrypted data format.");try{const T=E(D.iv),R=E(D.encrypted),A=await C("ssm-encrypt-for-current-user-v1"),w=await crypto.subtle.decrypt({name:"AES-GCM",iv:T},A,R),N=UY.inflate(new Uint8Array(w));return JSON.parse(vQ(N))}catch(T){throw console.error("\uD83D\uDEE1\uFE0F SM: Error in decryptDataForCurrentUser:",T),new Error("\uD83D\uDEE1\uFE0F SM: Failed to decrypt personal data.")}}async function C(O="ssm-default-aes-salt"){const D=E(q.privateKey),T=z0(O),R=await crypto.subtle.importKey("raw",D,{name:"PBKDF2"},!1,["deriveKey"]);return crypto.subtle.deriveKey({name:"PBKDF2",salt:T,iterations:1e5,hash:"SHA-256"},R,{name:"AES-GCM",length:256},!0,["encrypt","decrypt"])}return{get signer(){return q},set signer(O){q=O,$=null,V=O&&typeof O.getAddress==="function"?Z():Promise.resolve()},get localUserEthAddress(){return $},set localUserEthAddress(O){$=O},_initializeAndGetAddress:Z,updateSigner:K,ready:M,signOutgoingOperations:z,verifyIncomingOperations:L,encryptDataForCurrentUser:H,decryptDataForCurrentUser:P,_deriveAesKeyInternal:C}}var m9=function(Q){if(!(Q instanceof ArrayBuffer))if(Q.buffer&&Q.buffer instanceof ArrayBuffer)Q=Q.buffer.slice(Q.byteOffset,Q.byteOffset+Q.byteLength);else throw console.error("\u274C SM: arrayBufferToBase64Url input is not ArrayBuffer nor TypedArray with .buffer",Q),new Error("arrayBufferToBase64Url: ArrayBuffer or TypedArray required.");return btoa(String.fromCharCode(...new Uint8Array(Q))).replace(/\+/g,"-").replace(/\//g,"_").replace(/=+$/,"")},_9=function(Q){let Y=Q.replace(/-/g,"+").replace(/_/g,"/");const J=atob(Y),X=new ArrayBuffer(J.length),q=new Uint8Array(X);for(let G=0;G<J.length;G++)q[G]=J.charCodeAt(G);return X};function y7(){let Q=null,Y=null,J=null,X=null,q=null;async function G(){const O=c0.createRandom();return J=O.mnemonic.phrase,console.log("\u2705 SM: New Ethereum identity generated (mnemonic and private key in memory)."),{address:await O.getAddress(),mnemonic:J,privateKey:O.privateKey}}async function W(O,D){const T=V0(12),R=E(O),A=await window.crypto.subtle.encrypt({name:"AES-GCM",iv:T},D,R);return JSON.stringify({iv:m9(T.buffer.slice(T.byteOffset,T.byteOffset+T.byteLength)),ciphertext:m9(A)})}async function U(O,D){const{iv:T,ciphertext:R}=JSON.parse(O),A=_9(T),w=_9(R),N=await window.crypto.subtle.decrypt({name:"AES-GCM",iv:new Uint8Array(A)},D,w);return B(new Uint8Array(N))}async function $(O,D){const T=await window.crypto.subtle.importKey("raw",D,{name:"PBKDF2"},!1,["deriveKey"]);return window.crypto.subtle.deriveKey({name:"PBKDF2",salt:O,iterations:200000,hash:"SHA-256"},T,{name:"AES-GCM",length:256},!0,["encrypt","decrypt"])}async function V(O,D){const T=localStorage.getItem(SJ);if(!T)return console.warn("\u26A0\uFE0F SM (_loadAndDecrypt): No encrypted Ethereum material found."),L(),null;try{const R=await this._deriveAesGcmKeyFromWebAuthn(O,D),A=await U(T,R),w=new c0(A);return Q=w,Y=await w.getAddress(),J=null,X=O,q=D,console.log(`\u2705 SM (_loadAndDecrypt): Session established for ${Y}`),Y}catch(R){return console.error("\u274C SM (_loadAndDecrypt): Error (decryption/wallet loading):",R),L(),null}}async function Z(O){if(!window.navigator.credentials||!window.navigator.credentials.create)return console.error("\u274C SM: WebAuthn is not supported by this browser."),alert("WebAuthn is not supported by this browser."),!1;const D=V0(32),T=D.buffer.slice(D.byteOffset,D.byteOffset+D.byteLength);try{const R=W0.computePublicKey(O,!1),A=E(R),w=E(n(A)),k=w.buffer.slice(w.byteOffset,w.byteOffset+Math.min(w.length,64)),r=new c0(O).address.slice(0,10),g={challenge:T,rp:{name:"GDB WebAuthn App",id:window.location.hostname},user:{id:k,name:`user-${r}`,displayName:"GDB User"},pubKeyCredParams:[{type:"public-key",alg:-7},{type:"public-key",alg:-257}],authenticatorSelection:{authenticatorAttachment:"platform",userVerification:"preferred",residentKey:"preferred",requireResidentKey:!1},timeout:60000,attestation:"none"},F=await window.navigator.credentials.create({publicKey:g});if(!F||!F.rawId||!F.id)throw new Error("WebAuthn registration failed or was canceled (no credential).");const x=F.rawId,b=await $(x,T),y=await this._encryptEthereumPrivateKey(O,b);return localStorage.setItem(SJ,y),localStorage.setItem(TQ,JSON.stringify({credentialIdBase64Url:m9(x),originalChallengeBase64Url:m9(T)})),console.log("\u2705 SM: WebAuthn registered and Ethereum key encrypted and saved."),await V(x,T)}catch(R){return console.error("\u274C SM: Error during WebAuthn registration:",R),L(),localStorage.removeItem(SJ),localStorage.removeItem(TQ),alert(`WebAuthn registration error: ${R.message||"Unknown. Check console."}`),!1}}async function K(){if(!window.navigator.credentials||!window.navigator.credentials.get)return console.error("\u274C SM: WebAuthn is not supported."),alert("WebAuthn is not supported by this browser."),null;const O=localStorage.getItem(TQ);if(!O)return console.warn("\u26A0\uFE0F SM: No WebAuthn registration details saved."),null;let D;try{D=JSON.parse(O)}catch(N){return console.error("\u274C SM: Error parsing WebAuthn registration details from localStorage:",N),null}if(!D.credentialIdBase64Url||!D.originalChallengeBase64Url)return console.error("\u274C SM: WebAuthn registration details in localStorage are incomplete."),null;const T=_9(D.credentialIdBase64Url),R=_9(D.originalChallengeBase64Url),A=V0(32),w=A.buffer.slice(A.byteOffset,A.byteOffset+A.byteLength);try{const N={challenge:w,allowCredentials:[{type:"public-key",id:T}],userVerification:"preferred",timeout:60000},k=await window.navigator.credentials.get({publicKey:N});if(!k||!k.rawId||!k.response||!k.response.authenticatorData||!k.response.signature||!k.response.clientDataJSON)throw new Error("WebAuthn authentication failed or was canceled (incomplete assertion).");if(m9(k.rawId)!==D.credentialIdBase64Url)throw new Error("WebAuthn credential ID in assertion does not match stored ID.");const v=JSON.parse((new TextDecoder()).decode(k.response.clientDataJSON));if(v.challenge!==m9(w))throw new Error("WebAuthn assertion challenge mismatch.");if(v.origin!==`https://${window.location.hostname}`&&v.origin!==`http://${window.location.hostname}`){let r=window.location.protocol+"//";if(v.origin.startsWith(r+window.location.hostname));else if(window.location.hostname==="localhost"&&v.origin.startsWith(r+"localhost"));else console.warn("\u26A0\uFE0F SM: WebAuthn assertion origin mismatch. Expected based on hostname:",window.location.hostname,"Got:",v.origin)}return console.log("\u2705 SM: Interactive WebAuthn assertion received and validated."),await V(k.rawId,R)}catch(N){return console.error("\u274C SM: Error during interactive WebAuthn login:",N),L(),null}}async function M(){console.log("\u2139\uFE0F SM: Attempting silent WebAuthn login...");const O=localStorage.getItem(TQ);if(!O)return console.warn("\u26A0\uFE0F SM Silent Login: No WebAuthn registration details."),null;let D;try{D=JSON.parse(O)}catch(T){return console.error("\u274C SM Silent Login: Error parsing registration details:",T),null}if(!D.credentialIdBase64Url||!D.originalChallengeBase64Url)return console.error("\u274C SM Silent Login: Incomplete WebAuthn registration details."),null;try{const T=_9(D.credentialIdBase64Url),R=_9(D.originalChallengeBase64Url),A=await V(T,R);if(A)return console.log(`\u2705 SM Silent Login: Success for ${A}.`),A;else return console.warn("\u26A0\uFE0F SM Silent Login: _loadAndDecryptWalletFromWebAuthnMaterial failed."),null}catch(T){return console.error("\u274C SM Silent Login: Error during silent login attempt:",T),L(),null}}async function j(O){try{const D=c0.fromPhrase(O);return Q=D,Y=await D.getAddress(),J=O,X=null,q=null,console.log(`\u2705 SM: Wallet loaded from mnemonic for ${Y}. Signer set.`),{address:Y,privateKey:D.privateKey,mnemonic:J}}catch(D){return console.error("\u274C SM: Error loading wallet from mnemonic:",D),L(),null}}function z(){return localStorage.getItem(TQ)!==null&&localStorage.getItem(SJ)!==null}function L(){Q=null,Y=null,J=null,X=null,q=null,console.log("\u2139\uFE0F SM: Wallet session closed (SM internal state cleared).")}function H(){return Q}function P(){return Y}function C(){if(J&&(!X||!q))return J;return null}function S(){return!!(Q&&X&&q)}return{createNewEthereumIdentity:G,registerAndProtectWithWebAuthn:Z,loginWithWebAuthn:K,trySilentWebAuthnLogin:M,loadWalletFromMnemonic:j,hasWebAuthnRegistration:z,logout:L,getSigner:H,getAddress:P,getMnemonicForDisplay:C,isSessionWebAuthnProtected:S}}var SJ="gdb_ethereum_material_encrypted_webauthn_v2",TQ="gdb_webauthn_registration_details_v2";function B6(Q){if(typeof Q!=="object"||Q===null||Array.isArray(Q))throw new Error("SM: Custom roles must be a valid object.");VY=Q,console.log("\uD83D\uDEE1\uFE0F SM: Custom roles set.")}function $Y(Q,Y,J=new Set){const X=VY;if(!Q||!X[Q])return!1;if(J.has(Q))return console.warn(`\u26A0\uFE0F SM: Inheritance loop detected involving role '${Q}'.`),!1;if(J.add(Q),X[Q].can&&X[Q].can.includes(Y))return J.delete(Q),!0;if(X[Q].inherits&&Array.isArray(X[Q].inherits)){if(X[Q].inherits.some((q)=>$Y(q,Y,new Set(J))))return J.delete(Q),!0}return J.delete(Q),!1}function E6(Q,Y={}){if(Q==="upsert")return"write";if(Q==="remove")return"delete";if(Q==="link")return"link";if(Q==="sync"||Q==="syncReceive"||Q==="deltaSync")return"sync";return console.warn(`\u26A0\uFE0F SM mapChangeTypeToAction: Unknown change type '${Q}'.`),"unknown"}function CK(Q){if(typeof Q==="function")kJ=Q,d0();else if(Q===null)kJ=null;else console.warn("\u26A0\uFE0F SM: Attempted to set invalid state change callback.")}var d0=function(){if(kJ)kJ({isActive:E0,activeAddress:X0?.localUserEthAddress||Y0.getAddress(),isWebAuthnProtected:i0,hasVolatileIdentity:!!B0,hasWebAuthnHardwareRegistration:Y0.hasWebAuthnRegistration()})};async function TK(){if(E0)await fJ();Y0.logout(),B0=null,i0=!1,localStorage.removeItem(G8);try{const Q=await Y0.createNewEthereumIdentity();if(Q)B0=Q;return d0(),Q}catch(Q){throw B0=null,d0(),Q}}async function NK(Q){const Y=Q||B0?.privateKey;if(!Y)return alert("SM Error: No volatile ETH identity to protect."),null;if(E0&&i0&&X0?.signer)return X0.localUserEthAddress;if(E0)await fJ();Y0.logout();const J=await Y0.registerAndProtectWithWebAuthn(Y);if(J&&Y0.getSigner()){if(B0=null,i0=!0,localStorage.setItem(G8,"true"),m)await xJ(Y0.getSigner());else console.warn("\u26A0\uFE0F SM: Identity protected, but GDB not configured. Global SM signing not active.");return J}else return i0=!1,localStorage.removeItem(G8),d0(),null}async function wK(){if(E0)await fJ();Y0.logout(),B0=null;const Q=await Y0.loginWithWebAuthn();if(Q&&Y0.getSigner()){if(i0=!0,localStorage.setItem(G8,"true"),m)await xJ(Y0.getSigner());else console.warn("\u26A0\uFE0F SM: WebAuthn login OK, but GDB not configured for full security activation.");return Q}else return i0=!1,localStorage.removeItem(G8),d0(),null}async function FK(Q){if(E0)await fJ();Y0.logout(),B0=null;const Y=await Y0.loadWalletFromMnemonic(Q);if(Y&&Y.address&&Y0.getSigner()){if(B0=Y,i0=!1,localStorage.removeItem(G8),m)await xJ(Y0.getSigner());else console.warn("\u26A0\uFE0F SM: Mnemonic loaded, but GDB not configured for full security activation.");return B0}else return d0(),null}async function S6(Q,Y=[]){if(!Q){console.error("\u274C SM: GDB instance is required.");return}if(m=Q,AJ=(Y||[]).map((J)=>{try{return _(J)}catch(X){return console.warn(`\u26A0\uFE0F SM: Invalid superadmin address skipped: ${J}`),null}}).filter(Boolean),X0=g7(null,m,{can:$Y,mapChangeTypeToAction:E6},AJ),!h7)m.use(async function J(X){const{validatedOperations:q}=await X0.verifyIncomingOperations(X);return q||[]}),h7=!0;else console.info("\uD83D\uDEE1\uFE0F SM: Security middleware already registered. Skipping duplicate registration.");if(console.info("\u2705 SM: Security context established and middleware registered."),localStorage.getItem(G8)==="true"&&Y0.hasWebAuthnRegistration()){console.info("\uD83D\uDD11 SM: Previous WebAuthn session detected. Attempting silent login...");try{const J=await Y0.trySilentWebAuthnLogin();if(J&&Y0.getSigner())i0=!0,await xJ(Y0.getSigner()),console.info(`\u2705 SM: Silent WebAuthn login successful for ${J}.`);else console.warn("\u26A0\uFE0F SM: Silent WebAuthn login failed or no signer obtained. Manual login required."),localStorage.removeItem(G8),d0()}catch(J){console.error("\u274C SM: Error during silent WebAuthn login attempt:",J),localStorage.removeItem(G8),d0()}}else d0()}async function xJ(Q){if(!m||!X0||!Q)return console.error("\u274C SM Internal: GDB, GDB's SecurityManager, or signer missing for security activation."),E0=!1,d0(),!1;const Y=X0;if(Y.signer=Q,await Y._initializeAndGetAddress(),console.info(`\u270D\uFE0F SM: Signer activated on GDB.SecurityManager for ETH: ${Y.localUserEthAddress}`),m.syncChannel&&m.syncChannel.send&&!m.syncChannel._originalSendBySM)m.syncChannel._originalSendBySM=m.syncChannel.send.bind(m.syncChannel),m.syncChannel.send=async(q)=>{const G=await X0.signOutgoingOperations(q);return m.syncChannel._originalSendBySM(G)},console.info("\uD83D\uDD12 SM: gdbInstance.syncChannel.send wrapped for signing.");const J=Y.localUserEthAddress,X=`user:${J}`;try{await m.ready;const q=await m.get(X),G=q.result?.value||{};let W=G.role;if(!W)W=AJ.includes(J)?"superadmin":"user";if(G.role!==W||!q.result||G.ethAddress!==J){const U=m.hybridClock.now();await m.graph.upsert(X,{...G,ethAddress:J,role:W},U),m.syncChannel.send([{type:"sync",timestamp:null}]),console.info(`\uD83D\uDC64 SM: User node for ${J} (role '${W}') ensured in GDB.`)}}catch(q){console.error(`\u274C SM: Error ensuring user node for ${J}:`,q)}return E0=!0,d0(),console.info(`\uD83D\uDD12 SM: P2P signing security ACTIVE for ${J}. GDB's SM will verify all incoming ops.`),!0}async function fJ(){if(console.info("\uD83E\uDDF9 SM: Clearing active signing session..."),m&&m.syncChannel&&m.syncChannel._originalSendBySM)m.syncChannel.send=m.syncChannel._originalSendBySM,delete m.syncChannel._originalSendBySM,console.info("\uD83D\uDD13 SM: gdbInstance.syncChannel.send restored to original.");if(Y0.logout(),X0)X0.signer=null,X0.localUserEthAddress=null,console.info("\uD83D\uDEE1\uFE0F SM: Signer removed from GDB.SecurityManager. It now operates in anonymous/verifier mode.");B0=null,i0=!1,localStorage.removeItem(G8),E0=!1,d0(),console.info("\u2705 SM: Signing session closed. GDB.SecurityManager continues to verify incoming P2P operations.")}async function BK(Q,Y){const J=Y??(typeof crypto!=="undefined"&&crypto.randomUUID?crypto.randomUUID():`${Date.now()}-${Math.random().toString(16).slice(2)}`),X="SM_ID_PREFIX_"+J;if(!m)throw new Error("\u274C SM.put: Not initialized");if(!X0?.signer)throw new Error("\u274C SM.put: Session not active");const{result:q}=await A6(J);if(q&&q.decrypted===!1)throw new Error(`\u274C SM.put: Cannot overwrite encrypted data on node ID '${Y}' owned by another user. DENIED.`);const G=X0;let W,U;try{const V=await G.encryptDataForCurrentUser(Q),Z=JSON.parse(V);W=Z.encrypted,U={owner:G.localUserEthAddress,encType:Z.type,iv:Z.iv}}catch(V){throw console.error(`\u274C SM.put: Encryption failed for ID ${Y||"(new)"}: ${V.message}`),V}const $={_gdbWrapperType:m7,_payload:W,_meta:U};return console.info(`\uD83D\uDCE6 SM (put): Storing wrapped secure payload for ID: ${Y||"(new)"}`),await m.put($,X),J}async function A6(Q,Y=null){if(!Q)throw new Error("\u274C SM.get: id is required");let J="SM_ID_PREFIX_"+Q;if(!m)throw new Error("\u274C SM.get: Not initialized");const X=X0,q=async($)=>{if(!$)return null;let V=$.value,Z=!1;if(V&&V._gdbWrapperType===m7){const K=V,M=K._payload,j=K._meta;if(V=typeof M==="string"?M:K,j&&j.owner&&X&&X.signer&&j.owner===X.localUserEthAddress)try{const z=JSON.stringify({iv:j.iv,encrypted:M,type:j.encType});V=await X.decryptDataForCurrentUser(z),Z=!0}catch(z){console.error(`\u274C SM.get: Decryption failed for node ${$.id}. User: ${X.localUserEthAddress}, Owner: ${j.owner}. Error: ${z.message}`)}else if(j&&j.owner)console.warn(`\u26A0\uFE0F SM.get: Decryption not attempted for node ${$.id}. Owner: ${j.owner}. Session active: ${!!(X&&X.signer)}`);else console.warn(`\u26A0\uFE0F SM.get: Secure payload wrapper for node ${$.id} lacks sufficient metadata for decryption.`)}return{id:Q,value:V,edges:$.edges||[],timestamp:$.timestamp,decrypted:Z}};if(!Y){const $=await m.get(J,null);return{result:await q($?$.result:null)}}let G=null;const W=await m.get(J,null);if(G=await q(W?W.result:null),typeof Y==="function")Y(G);const{unsubscribe:U}=await m.get(J,async($)=>{const V=await q($),Z=V&&G&&m.hybridClock?.compare(V.timestamp,G.timestamp)>0,K=JSON.stringify(V?V.value:null)!==JSON.stringify(G?G.value:null);if(!V&&G){if(G=null,typeof Y==="function")Y(null)}else if(V&&(!G||Z||K)){if(G=V,typeof Y==="function")Y(V)}});return{result:G,unsubscribe:()=>{if(U)U()}}}var _7=function(){if(!E0||!X0?.localUserEthAddress)throw new Error("\u274C SM Operation: Security not active or no local user ETH identified in SecurityManager.");return X0.localUserEthAddress};async function EK(Q,Y,J=null){if(!Q||!Y)throw new Error("\u274C SM assignRole: targetUserEthAddress, and role are required.");let X;try{X=_(Q)}catch(V){throw new Error(`\u274C SM assignRole: targetUserEthAddress '${Q}' is invalid.`)}if(!VY[Y])throw new Error(`\u274C SM assignRole: Role '${Y}' is not a defined role.`);const q=_7(),G=`user:${X}`,$={...(await m.get(G)).result?.value||{},ethAddress:X,role:Y,assignedByEthAddress:q,expiresAt:J?new Date(J).toISOString():null};await m.put($,G),console.info(`\uD83D\uDC51 SM: Role '${Y}' for ${Q} by ${q} written.`)}async function k6(){if(!E0||!X0?.localUserEthAddress)return!1;return AJ.includes(X0.localUserEthAddress)}async function x6(Q,Y="unknown"){let J;try{J=_(Q)}catch(G){throw new Error(`\u274C SM: Invalid ETH address '${Q}' when verifying role for op '${Y}'.`)}const X=await m.get(`user:${J}`);if(!X.result?.value?.role)throw console.warn(`\u26A0\uFE0F SM verifyUserRoleLocal: Node/role not found for ETH ${J}. Op: ${Y}. Data:`,X.result?.value),new Error(`\u274C SM: Role not found for ETH ${J} (operation: ${Y}).`);const q=X.result.value;if(q.expiresAt&&new Date(q.expiresAt)<new Date)throw new Error(`\u274C SM: Role for ETH ${J} has expired.`);return q.role}async function f6(Q,Y){const J=await x6(Q,Y);if(!$Y(J,Y))throw new Error(`\u274C SM: ETH User ${Q} (role ${J}) does not have permission for '${Y}'.`)}async function SK(Q){if(!Q)throw new Error("\u274C SM executeWithPermission: operationName is required.");const Y=_7();if(!(Q==="assignRole"&&await k6()))await f6(Y,Q);return Y}function AK(){return E0?X0?.localUserEthAddress:null}function c7(){return E0&&!!X0?.signer}function kK(){return E0&&i0}function xK(){return Y0.hasWebAuthnRegistration()}function fK(){if(B0&&B0.mnemonic&&!Y0.isSessionWebAuthnProtected())return B0.mnemonic;return Y0.getMnemonicForDisplay()}async function bK(Q){if(!c7()||!X0)throw new Error("\u274C SM Encryption: Local signing security not active or SecurityManager not available.");return await X0.encryptDataForCurrentUser(Q)}async function vK(Q){if(!c7()||!X0)throw new Error("\u274C SM Decryption: Local signing security not active or SecurityManager not available.");return await X0.decryptDataForCurrentUser(Q)}function gK(Q,Y,J={}){return console.log("\u2139\uFE0F SM: SecurityManager module loaded."),m=Q,Object.hasOwn(J,"superAdmins")&&S6(Q,J.superAdmins??[]),Object.hasOwn(J,"customRoles")&&B6(J.customRoles),{sm:Y}}var VY={superadmin:{can:["assignRole","deleteAny"],inherits:["admin"]},admin:{can:["delete"],inherits:["manager"]},manager:{can:["publish"],inherits:["user"]},user:{can:["write","link","sync"],inherits:["guest"]},guest:{can:["read","sync"]}},G8="gdb_sm_last_session_was_webauthn",m=null,X0=null,Y0=y7(),AJ=[],E0=!1,h7=!1,B0=null,i0=!1,kJ=null,m7="_gdbSecurePayloadV1";export{TK as startNewUserRegistration,CK as setSecurityStateChangeCallback,B6 as setCustomRoles,BK as put,NK as protectCurrentIdentityWithWebAuthn,E6 as mapChangeTypeToAction,FK as loginOrRecoverUserWithMnemonic,wK as loginCurrentUserWithWebAuthn,c7 as isSecurityActive,kK as isCurrentSessionProtectedByWebAuthn,gK as init,xK as hasExistingWebAuthnRegistration,fK as getMnemonicForDisplayAfterRegistrationOrRecovery,AK as getActiveEthAddress,A6 as get,SK as executeWithPermission,bK as encryptDataForCurrentUser,vK as decryptDataForCurrentUser,S6 as createSecurityContext,fJ as clearSecurity,$Y as can,EK as assignRole};
