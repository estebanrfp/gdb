var n5=Object.defineProperty;var a5=(J,G)=>{for(var Q in G)n5(J,Q,{get:G[Q],enumerable:!0,configurable:!0,set:(q)=>G[Q]=()=>q})};function jQ(J){const G=J.length;let Q=0,q=0;while(q<G){let W=J.charCodeAt(q++);if((W&4294967168)===0){Q++;continue}else if((W&4294965248)===0)Q+=2;else{if(W>=55296&&W<=56319){if(q<G){const X=J.charCodeAt(q);if((X&64512)===56320)++q,W=((W&1023)<<10)+(X&1023)+65536}}if((W&4294901760)===0)Q+=3;else Q+=4}}return Q}function s5(J,G,Q){const q=J.length;let W=Q,X=0;while(X<q){let Y=J.charCodeAt(X++);if((Y&4294967168)===0){G[W++]=Y;continue}else if((Y&4294965248)===0)G[W++]=Y>>6&31|192;else{if(Y>=55296&&Y<=56319){if(X<q){const U=J.charCodeAt(X);if((U&64512)===56320)++X,Y=((Y&1023)<<10)+(U&1023)+65536}}if((Y&4294901760)===0)G[W++]=Y>>12&15|224,G[W++]=Y>>6&63|128;else G[W++]=Y>>18&7|240,G[W++]=Y>>12&63|128,G[W++]=Y>>6&63|128}G[W++]=Y&63|128}}function JG(J,G,Q){t5.encodeInto(J,G.subarray(Q))}function MQ(J,G,Q){if(J.length>e5)JG(J,G,Q);else s5(J,G,Q)}function o1(J,G,Q){let q=G;const W=q+Q,X=[];let Y="";while(q<W){const U=J[q++];if((U&128)===0)X.push(U);else if((U&224)===192){const K=J[q++]&63;X.push((U&31)<<6|K)}else if((U&240)===224){const K=J[q++]&63,V=J[q++]&63;X.push((U&31)<<12|K<<6|V)}else if((U&248)===240){const K=J[q++]&63,V=J[q++]&63,Z=J[q++]&63;let H=(U&7)<<18|K<<12|V<<6|Z;if(H>65535)H-=65536,X.push(H>>>10&1023|55296),H=56320|H&1023;X.push(H)}else X.push(U);if(X.length>=QG)Y+=String.fromCharCode(...X),X.length=0}if(X.length>0)Y+=String.fromCharCode(...X);return Y}function WG(J,G,Q){const q=J.subarray(G,G+Q);return GG.decode(q)}function PQ(J,G,Q){if(Q>qG)return WG(J,G,Q);else return o1(J,G,Q)}var t5=new TextEncoder,e5=50,QG=4096,GG=new TextDecoder,qG=200;class H8{constructor(J,G){this.type=J,this.data=G}}class q0 extends Error{constructor(J){super(J);const G=Object.create(q0.prototype);Object.setPrototypeOf(this,G),Object.defineProperty(this,"name",{configurable:!0,enumerable:!1,value:q0.name})}}function NQ(J,G,Q){const q=Q/4294967296,W=Q;J.setUint32(G,q),J.setUint32(G+4,W)}function V1(J,G,Q){const q=Math.floor(Q/4294967296),W=Q;J.setUint32(G,q),J.setUint32(G+4,W)}function K1(J,G){const Q=J.getInt32(G),q=J.getUint32(G+4);return Q*4294967296+q}function CQ(J,G){const Q=J.getUint32(G),q=J.getUint32(G+4);return Q*4294967296+q}var j8=4294967295;function VG({sec:J,nsec:G}){if(J>=0&&G>=0&&J<=UG)if(G===0&&J<=YG){const Q=new Uint8Array(4);return new DataView(Q.buffer).setUint32(0,J),Q}else{const Q=J/4294967296,q=J&4294967295,W=new Uint8Array(8),X=new DataView(W.buffer);return X.setUint32(0,G<<2|Q&3),X.setUint32(4,q),W}else{const Q=new Uint8Array(12),q=new DataView(Q.buffer);return q.setUint32(0,G),V1(q,4,J),Q}}function KG(J){const G=J.getTime(),Q=Math.floor(G/1000),q=(G-Q*1000)*1e6,W=Math.floor(q/1e9);return{sec:Q+W,nsec:q-W*1e9}}function ZG(J){if(J instanceof Date){const G=KG(J);return VG(G)}else return null}function zG(J){const G=new DataView(J.buffer,J.byteOffset,J.byteLength);switch(J.byteLength){case 4:return{sec:G.getUint32(0),nsec:0};case 8:{const Q=G.getUint32(0),q=G.getUint32(4),W=(Q&3)*4294967296+q,X=Q>>>2;return{sec:W,nsec:X}}case 12:{const Q=K1(G,4),q=G.getUint32(0);return{sec:Q,nsec:q}}default:throw new q0(`Unrecognized data size for timestamp (expected 4, 8, or 12): ${J.length}`)}}function $G(J){const G=zG(J);return new Date(G.sec*1000+G.nsec/1e6)}var XG=-1,YG=4294967295,UG=17179869183,DQ={type:XG,encode:ZG,decode:$G};class o0{constructor(){this.builtInEncoders=[],this.builtInDecoders=[],this.encoders=[],this.decoders=[],this.register(DQ)}register({type:J,encode:G,decode:Q}){if(J>=0)this.encoders[J]=G,this.decoders[J]=Q;else{const q=-1-J;this.builtInEncoders[q]=G,this.builtInDecoders[q]=Q}}tryToEncode(J,G){for(let Q=0;Q<this.builtInEncoders.length;Q++){const q=this.builtInEncoders[Q];if(q!=null){const W=q(J,G);if(W!=null){const X=-1-Q;return new H8(X,W)}}}for(let Q=0;Q<this.encoders.length;Q++){const q=this.encoders[Q];if(q!=null){const W=q(J,G);if(W!=null)return new H8(Q,W)}}if(J instanceof H8)return J;return null}decode(J,G,Q){const q=G<0?this.builtInDecoders[-1-G]:this.decoders[G];if(q)return q(J,G,Q);else return new H8(G,J)}}o0.defaultCodec=new o0;var HG=function(J){return J instanceof ArrayBuffer||typeof SharedArrayBuffer!=="undefined"&&J instanceof SharedArrayBuffer};function T8(J){if(J instanceof Uint8Array)return J;else if(ArrayBuffer.isView(J))return new Uint8Array(J.buffer,J.byteOffset,J.byteLength);else if(HG(J))return new Uint8Array(J);else return Uint8Array.from(J)}var jG=100,MG=2048;class Z1{constructor(J){this.entered=!1,this.extensionCodec=J?.extensionCodec??o0.defaultCodec,this.context=J?.context,this.useBigInt64=J?.useBigInt64??!1,this.maxDepth=J?.maxDepth??jG,this.initialBufferSize=J?.initialBufferSize??MG,this.sortKeys=J?.sortKeys??!1,this.forceFloat32=J?.forceFloat32??!1,this.ignoreUndefined=J?.ignoreUndefined??!1,this.forceIntegerToFloat=J?.forceIntegerToFloat??!1,this.pos=0,this.view=new DataView(new ArrayBuffer(this.initialBufferSize)),this.bytes=new Uint8Array(this.view.buffer)}clone(){return new Z1({extensionCodec:this.extensionCodec,context:this.context,useBigInt64:this.useBigInt64,maxDepth:this.maxDepth,initialBufferSize:this.initialBufferSize,sortKeys:this.sortKeys,forceFloat32:this.forceFloat32,ignoreUndefined:this.ignoreUndefined,forceIntegerToFloat:this.forceIntegerToFloat})}reinitializeState(){this.pos=0}encodeSharedRef(J){if(this.entered)return this.clone().encodeSharedRef(J);try{return this.entered=!0,this.reinitializeState(),this.doEncode(J,1),this.bytes.subarray(0,this.pos)}finally{this.entered=!1}}encode(J){if(this.entered)return this.clone().encode(J);try{return this.entered=!0,this.reinitializeState(),this.doEncode(J,1),this.bytes.slice(0,this.pos)}finally{this.entered=!1}}doEncode(J,G){if(G>this.maxDepth)throw new Error(`Too deep objects in depth ${G}`);if(J==null)this.encodeNil();else if(typeof J==="boolean")this.encodeBoolean(J);else if(typeof J==="number")if(!this.forceIntegerToFloat)this.encodeNumber(J);else this.encodeNumberAsFloat(J);else if(typeof J==="string")this.encodeString(J);else if(this.useBigInt64&&typeof J==="bigint")this.encodeBigInt64(J);else this.encodeObject(J,G)}ensureBufferSizeToWrite(J){const G=this.pos+J;if(this.view.byteLength<G)this.resizeBuffer(G*2)}resizeBuffer(J){const G=new ArrayBuffer(J),Q=new Uint8Array(G),q=new DataView(G);Q.set(this.bytes),this.view=q,this.bytes=Q}encodeNil(){this.writeU8(192)}encodeBoolean(J){if(J===!1)this.writeU8(194);else this.writeU8(195)}encodeNumber(J){if(!this.forceIntegerToFloat&&Number.isSafeInteger(J))if(J>=0)if(J<128)this.writeU8(J);else if(J<256)this.writeU8(204),this.writeU8(J);else if(J<65536)this.writeU8(205),this.writeU16(J);else if(J<4294967296)this.writeU8(206),this.writeU32(J);else if(!this.useBigInt64)this.writeU8(207),this.writeU64(J);else this.encodeNumberAsFloat(J);else if(J>=-32)this.writeU8(224|J+32);else if(J>=-128)this.writeU8(208),this.writeI8(J);else if(J>=-32768)this.writeU8(209),this.writeI16(J);else if(J>=-2147483648)this.writeU8(210),this.writeI32(J);else if(!this.useBigInt64)this.writeU8(211),this.writeI64(J);else this.encodeNumberAsFloat(J);else this.encodeNumberAsFloat(J)}encodeNumberAsFloat(J){if(this.forceFloat32)this.writeU8(202),this.writeF32(J);else this.writeU8(203),this.writeF64(J)}encodeBigInt64(J){if(J>=BigInt(0))this.writeU8(207),this.writeBigUint64(J);else this.writeU8(211),this.writeBigInt64(J)}writeStringHeader(J){if(J<32)this.writeU8(160+J);else if(J<256)this.writeU8(217),this.writeU8(J);else if(J<65536)this.writeU8(218),this.writeU16(J);else if(J<4294967296)this.writeU8(219),this.writeU32(J);else throw new Error(`Too long string: ${J} bytes in UTF-8`)}encodeString(J){const Q=jQ(J);this.ensureBufferSizeToWrite(5+Q),this.writeStringHeader(Q),MQ(J,this.bytes,this.pos),this.pos+=Q}encodeObject(J,G){const Q=this.extensionCodec.tryToEncode(J,this.context);if(Q!=null)this.encodeExtension(Q);else if(Array.isArray(J))this.encodeArray(J,G);else if(ArrayBuffer.isView(J))this.encodeBinary(J);else if(typeof J==="object")this.encodeMap(J,G);else throw new Error(`Unrecognized object: ${Object.prototype.toString.apply(J)}`)}encodeBinary(J){const G=J.byteLength;if(G<256)this.writeU8(196),this.writeU8(G);else if(G<65536)this.writeU8(197),this.writeU16(G);else if(G<4294967296)this.writeU8(198),this.writeU32(G);else throw new Error(`Too large binary: ${G}`);const Q=T8(J);this.writeU8a(Q)}encodeArray(J,G){const Q=J.length;if(Q<16)this.writeU8(144+Q);else if(Q<65536)this.writeU8(220),this.writeU16(Q);else if(Q<4294967296)this.writeU8(221),this.writeU32(Q);else throw new Error(`Too large array: ${Q}`);for(let q of J)this.doEncode(q,G+1)}countWithoutUndefined(J,G){let Q=0;for(let q of G)if(J[q]!==void 0)Q++;return Q}encodeMap(J,G){const Q=Object.keys(J);if(this.sortKeys)Q.sort();const q=this.ignoreUndefined?this.countWithoutUndefined(J,Q):Q.length;if(q<16)this.writeU8(128+q);else if(q<65536)this.writeU8(222),this.writeU16(q);else if(q<4294967296)this.writeU8(223),this.writeU32(q);else throw new Error(`Too large map object: ${q}`);for(let W of Q){const X=J[W];if(!(this.ignoreUndefined&&X===void 0))this.encodeString(W),this.doEncode(X,G+1)}}encodeExtension(J){if(typeof J.data==="function"){const Q=J.data(this.pos+6),q=Q.length;if(q>=4294967296)throw new Error(`Too large extension object: ${q}`);this.writeU8(201),this.writeU32(q),this.writeI8(J.type),this.writeU8a(Q);return}const G=J.data.length;if(G===1)this.writeU8(212);else if(G===2)this.writeU8(213);else if(G===4)this.writeU8(214);else if(G===8)this.writeU8(215);else if(G===16)this.writeU8(216);else if(G<256)this.writeU8(199),this.writeU8(G);else if(G<65536)this.writeU8(200),this.writeU16(G);else if(G<4294967296)this.writeU8(201),this.writeU32(G);else throw new Error(`Too large extension object: ${G}`);this.writeI8(J.type),this.writeU8a(J.data)}writeU8(J){this.ensureBufferSizeToWrite(1),this.view.setUint8(this.pos,J),this.pos++}writeU8a(J){const G=J.length;this.ensureBufferSizeToWrite(G),this.bytes.set(J,this.pos),this.pos+=G}writeI8(J){this.ensureBufferSizeToWrite(1),this.view.setInt8(this.pos,J),this.pos++}writeU16(J){this.ensureBufferSizeToWrite(2),this.view.setUint16(this.pos,J),this.pos+=2}writeI16(J){this.ensureBufferSizeToWrite(2),this.view.setInt16(this.pos,J),this.pos+=2}writeU32(J){this.ensureBufferSizeToWrite(4),this.view.setUint32(this.pos,J),this.pos+=4}writeI32(J){this.ensureBufferSizeToWrite(4),this.view.setInt32(this.pos,J),this.pos+=4}writeF32(J){this.ensureBufferSizeToWrite(4),this.view.setFloat32(this.pos,J),this.pos+=4}writeF64(J){this.ensureBufferSizeToWrite(8),this.view.setFloat64(this.pos,J),this.pos+=8}writeU64(J){this.ensureBufferSizeToWrite(8),NQ(this.view,this.pos,J),this.pos+=8}writeI64(J){this.ensureBufferSizeToWrite(8),V1(this.view,this.pos,J),this.pos+=8}writeBigUint64(J){this.ensureBufferSizeToWrite(8),this.view.setBigUint64(this.pos,J),this.pos+=8}writeBigInt64(J){this.ensureBufferSizeToWrite(8),this.view.setBigInt64(this.pos,J),this.pos+=8}}function E0(J,G){return new Z1(G).encodeSharedRef(J)}function z1(J){return`${J<0?"-":""}0x${Math.abs(J).toString(16).padStart(2,"0")}`}var PG=16,NG=16;class n1{constructor(J=PG,G=NG){this.hit=0,this.miss=0,this.maxKeyLength=J,this.maxLengthPerKey=G,this.caches=[];for(let Q=0;Q<this.maxKeyLength;Q++)this.caches.push([])}canBeCached(J){return J>0&&J<=this.maxKeyLength}find(J,G,Q){const q=this.caches[Q-1];J:for(let W of q){const X=W.bytes;for(let Y=0;Y<Q;Y++)if(X[Y]!==J[G+Y])continue J;return W.str}return null}store(J,G){const Q=this.caches[J.length-1],q={bytes:J,str:G};if(Q.length>=this.maxLengthPerKey)Q[Math.random()*Q.length|0]=q;else Q.push(q)}decode(J,G,Q){const q=this.find(J,G,Q);if(q!=null)return this.hit++,q;this.miss++;const W=o1(J,G,Q),X=Uint8Array.prototype.slice.call(J,G,G+Q);return this.store(X,W),W}}var a1="array",S8="map_key",OQ="map_value",CG=(J)=>{if(typeof J==="string"||typeof J==="number")return J;throw new q0("The type of key must be string or number but "+typeof J)};class LQ{constructor(){this.stack=[],this.stackHeadPosition=-1}get length(){return this.stackHeadPosition+1}top(){return this.stack[this.stackHeadPosition]}pushArrayState(J){const G=this.getUninitializedStateFromPool();G.type=a1,G.position=0,G.size=J,G.array=new Array(J)}pushMapState(J){const G=this.getUninitializedStateFromPool();G.type=S8,G.readCount=0,G.size=J,G.map={}}getUninitializedStateFromPool(){if(this.stackHeadPosition++,this.stackHeadPosition===this.stack.length){const J={type:void 0,size:0,array:void 0,position:0,readCount:0,map:void 0,key:null};this.stack.push(J)}return this.stack[this.stackHeadPosition]}release(J){if(this.stack[this.stackHeadPosition]!==J)throw new Error("Invalid stack state. Released state is not on top of the stack.");if(J.type===a1){const Q=J;Q.size=0,Q.array=void 0,Q.position=0,Q.type=void 0}if(J.type===S8||J.type===OQ){const Q=J;Q.size=0,Q.map=void 0,Q.readCount=0,Q.type=void 0}this.stackHeadPosition--}reset(){this.stack.length=0,this.stackHeadPosition=-1}}var F8=-1,s1=new DataView(new ArrayBuffer(0)),DG=new Uint8Array(s1.buffer);try{s1.getInt8(0)}catch(J){if(!(J instanceof RangeError))throw new Error("This module is not supported in the current JavaScript engine because DataView does not throw RangeError on out-of-bounds access")}var BQ=new RangeError("Insufficient data"),BG=new n1;class $1{constructor(J){this.totalPos=0,this.pos=0,this.view=s1,this.bytes=DG,this.headByte=F8,this.stack=new LQ,this.entered=!1,this.extensionCodec=J?.extensionCodec??o0.defaultCodec,this.context=J?.context,this.useBigInt64=J?.useBigInt64??!1,this.rawStrings=J?.rawStrings??!1,this.maxStrLength=J?.maxStrLength??j8,this.maxBinLength=J?.maxBinLength??j8,this.maxArrayLength=J?.maxArrayLength??j8,this.maxMapLength=J?.maxMapLength??j8,this.maxExtLength=J?.maxExtLength??j8,this.keyDecoder=J?.keyDecoder!==void 0?J.keyDecoder:BG,this.mapKeyConverter=J?.mapKeyConverter??CG}clone(){return new $1({extensionCodec:this.extensionCodec,context:this.context,useBigInt64:this.useBigInt64,rawStrings:this.rawStrings,maxStrLength:this.maxStrLength,maxBinLength:this.maxBinLength,maxArrayLength:this.maxArrayLength,maxMapLength:this.maxMapLength,maxExtLength:this.maxExtLength,keyDecoder:this.keyDecoder})}reinitializeState(){this.totalPos=0,this.headByte=F8,this.stack.reset()}setBuffer(J){const G=T8(J);this.bytes=G,this.view=new DataView(G.buffer,G.byteOffset,G.byteLength),this.pos=0}appendBuffer(J){if(this.headByte===F8&&!this.hasRemaining(1))this.setBuffer(J);else{const G=this.bytes.subarray(this.pos),Q=T8(J),q=new Uint8Array(G.length+Q.length);q.set(G),q.set(Q,G.length),this.setBuffer(q)}}hasRemaining(J){return this.view.byteLength-this.pos>=J}createExtraByteError(J){const{view:G,pos:Q}=this;return new RangeError(`Extra ${G.byteLength-Q} of ${G.byteLength} byte(s) found at buffer[${J}]`)}decode(J){if(this.entered)return this.clone().decode(J);try{this.entered=!0,this.reinitializeState(),this.setBuffer(J);const G=this.doDecodeSync();if(this.hasRemaining(1))throw this.createExtraByteError(this.pos);return G}finally{this.entered=!1}}*decodeMulti(J){if(this.entered){yield*this.clone().decodeMulti(J);return}try{this.entered=!0,this.reinitializeState(),this.setBuffer(J);while(this.hasRemaining(1))yield this.doDecodeSync()}finally{this.entered=!1}}async decodeAsync(J){if(this.entered)return this.clone().decodeAsync(J);try{this.entered=!0;let G=!1,Q;for await(let Y of J){if(G)throw this.entered=!1,this.createExtraByteError(this.totalPos);this.appendBuffer(Y);try{Q=this.doDecodeSync(),G=!0}catch(U){if(!(U instanceof RangeError))throw U}this.totalPos+=this.pos}if(G){if(this.hasRemaining(1))throw this.createExtraByteError(this.totalPos);return Q}const{headByte:q,pos:W,totalPos:X}=this;throw new RangeError(`Insufficient data in parsing ${z1(q)} at ${X} (${W} in the current buffer)`)}finally{this.entered=!1}}decodeArrayStream(J){return this.decodeMultiAsync(J,!0)}decodeStream(J){return this.decodeMultiAsync(J,!1)}async*decodeMultiAsync(J,G){if(this.entered){yield*this.clone().decodeMultiAsync(J,G);return}try{this.entered=!0;let Q=G,q=-1;for await(let W of J){if(G&&q===0)throw this.createExtraByteError(this.totalPos);if(this.appendBuffer(W),Q)q=this.readArraySize(),Q=!1,this.complete();try{while(!0)if(yield this.doDecodeSync(),--q===0)break}catch(X){if(!(X instanceof RangeError))throw X}this.totalPos+=this.pos}}finally{this.entered=!1}}doDecodeSync(){J:while(!0){const J=this.readHeadByte();let G;if(J>=224)G=J-256;else if(J<192)if(J<128)G=J;else if(J<144){const q=J-128;if(q!==0){this.pushMapState(q),this.complete();continue J}else G={}}else if(J<160){const q=J-144;if(q!==0){this.pushArrayState(q),this.complete();continue J}else G=[]}else{const q=J-160;G=this.decodeString(q,0)}else if(J===192)G=null;else if(J===194)G=!1;else if(J===195)G=!0;else if(J===202)G=this.readF32();else if(J===203)G=this.readF64();else if(J===204)G=this.readU8();else if(J===205)G=this.readU16();else if(J===206)G=this.readU32();else if(J===207)if(this.useBigInt64)G=this.readU64AsBigInt();else G=this.readU64();else if(J===208)G=this.readI8();else if(J===209)G=this.readI16();else if(J===210)G=this.readI32();else if(J===211)if(this.useBigInt64)G=this.readI64AsBigInt();else G=this.readI64();else if(J===217){const q=this.lookU8();G=this.decodeString(q,1)}else if(J===218){const q=this.lookU16();G=this.decodeString(q,2)}else if(J===219){const q=this.lookU32();G=this.decodeString(q,4)}else if(J===220){const q=this.readU16();if(q!==0){this.pushArrayState(q),this.complete();continue J}else G=[]}else if(J===221){const q=this.readU32();if(q!==0){this.pushArrayState(q),this.complete();continue J}else G=[]}else if(J===222){const q=this.readU16();if(q!==0){this.pushMapState(q),this.complete();continue J}else G={}}else if(J===223){const q=this.readU32();if(q!==0){this.pushMapState(q),this.complete();continue J}else G={}}else if(J===196){const q=this.lookU8();G=this.decodeBinary(q,1)}else if(J===197){const q=this.lookU16();G=this.decodeBinary(q,2)}else if(J===198){const q=this.lookU32();G=this.decodeBinary(q,4)}else if(J===212)G=this.decodeExtension(1,0);else if(J===213)G=this.decodeExtension(2,0);else if(J===214)G=this.decodeExtension(4,0);else if(J===215)G=this.decodeExtension(8,0);else if(J===216)G=this.decodeExtension(16,0);else if(J===199){const q=this.lookU8();G=this.decodeExtension(q,1)}else if(J===200){const q=this.lookU16();G=this.decodeExtension(q,2)}else if(J===201){const q=this.lookU32();G=this.decodeExtension(q,4)}else throw new q0(`Unrecognized type byte: ${z1(J)}`);this.complete();const Q=this.stack;while(Q.length>0){const q=Q.top();if(q.type===a1)if(q.array[q.position]=G,q.position++,q.position===q.size)G=q.array,Q.release(q);else continue J;else if(q.type===S8){if(G==="__proto__")throw new q0("The key __proto__ is not allowed");q.key=this.mapKeyConverter(G),q.type=OQ;continue J}else if(q.map[q.key]=G,q.readCount++,q.readCount===q.size)G=q.map,Q.release(q);else{q.key=null,q.type=S8;continue J}}return G}}readHeadByte(){if(this.headByte===F8)this.headByte=this.readU8();return this.headByte}complete(){this.headByte=F8}readArraySize(){const J=this.readHeadByte();switch(J){case 220:return this.readU16();case 221:return this.readU32();default:if(J<160)return J-144;else throw new q0(`Unrecognized array type byte: ${z1(J)}`)}}pushMapState(J){if(J>this.maxMapLength)throw new q0(`Max length exceeded: map length (${J}) > maxMapLengthLength (${this.maxMapLength})`);this.stack.pushMapState(J)}pushArrayState(J){if(J>this.maxArrayLength)throw new q0(`Max length exceeded: array length (${J}) > maxArrayLength (${this.maxArrayLength})`);this.stack.pushArrayState(J)}decodeString(J,G){if(!this.rawStrings||this.stateIsMapKey())return this.decodeUtf8String(J,G);return this.decodeBinary(J,G)}decodeUtf8String(J,G){if(J>this.maxStrLength)throw new q0(`Max length exceeded: UTF-8 byte length (${J}) > maxStrLength (${this.maxStrLength})`);if(this.bytes.byteLength<this.pos+G+J)throw BQ;const Q=this.pos+G;let q;if(this.stateIsMapKey()&&this.keyDecoder?.canBeCached(J))q=this.keyDecoder.decode(this.bytes,Q,J);else q=PQ(this.bytes,Q,J);return this.pos+=G+J,q}stateIsMapKey(){if(this.stack.length>0)return this.stack.top().type===S8;return!1}decodeBinary(J,G){if(J>this.maxBinLength)throw new q0(`Max length exceeded: bin length (${J}) > maxBinLength (${this.maxBinLength})`);if(!this.hasRemaining(J+G))throw BQ;const Q=this.pos+G,q=this.bytes.subarray(Q,Q+J);return this.pos+=G+J,q}decodeExtension(J,G){if(J>this.maxExtLength)throw new q0(`Max length exceeded: ext length (${J}) > maxExtLength (${this.maxExtLength})`);const Q=this.view.getInt8(this.pos+G),q=this.decodeBinary(J,G+1);return this.extensionCodec.decode(q,Q,this.context)}lookU8(){return this.view.getUint8(this.pos)}lookU16(){return this.view.getUint16(this.pos)}lookU32(){return this.view.getUint32(this.pos)}readU8(){const J=this.view.getUint8(this.pos);return this.pos++,J}readI8(){const J=this.view.getInt8(this.pos);return this.pos++,J}readU16(){const J=this.view.getUint16(this.pos);return this.pos+=2,J}readI16(){const J=this.view.getInt16(this.pos);return this.pos+=2,J}readU32(){const J=this.view.getUint32(this.pos);return this.pos+=4,J}readI32(){const J=this.view.getInt32(this.pos);return this.pos+=4,J}readU64(){const J=CQ(this.view,this.pos);return this.pos+=8,J}readI64(){const J=K1(this.view,this.pos);return this.pos+=8,J}readU64AsBigInt(){const J=this.view.getBigUint64(this.pos);return this.pos+=8,J}readI64AsBigInt(){const J=this.view.getBigInt64(this.pos);return this.pos+=8,J}readF32(){const J=this.view.getFloat32(this.pos);return this.pos+=4,J}readF64(){const J=this.view.getFloat64(this.pos);return this.pos+=8,J}}function t1(J,G){return new $1(G).decode(J)}var B8=function(J){let G=J.length;while(--G>=0)J[G]=0},JJ=function(J,G,Q,q,W){this.static_tree=J,this.extra_bits=G,this.extra_base=Q,this.elems=q,this.max_length=W,this.has_stree=J&&J.length},QJ=function(J,G){this.dyn_tree=J,this.max_code=0,this.stat_desc=G},C0=function(J,G,Q,q,W){this.good_length=J,this.max_lazy=G,this.nice_length=Q,this.max_chain=q,this.func=W},Lq=function(){this.strm=null,this.status=0,this.pending_buf=null,this.pending_buf_size=0,this.pending_out=0,this.pending=0,this.wrap=0,this.gzhead=null,this.gzindex=0,this.method=L1,this.last_flush=-1,this.w_size=0,this.w_bits=0,this.w_mask=0,this.window=null,this.window_size=0,this.prev=null,this.head=null,this.ins_h=0,this.hash_size=0,this.hash_bits=0,this.hash_mask=0,this.hash_shift=0,this.block_start=0,this.match_length=0,this.prev_match=0,this.match_available=0,this.strstart=0,this.match_start=0,this.lookahead=0,this.prev_length=0,this.max_chain_length=0,this.max_lazy_match=0,this.level=0,this.strategy=0,this.good_match=0,this.nice_match=0,this.dyn_ltree=new Uint16Array(Hq*2),this.dyn_dtree=new Uint16Array((2*zq+1)*2),this.bl_tree=new Uint16Array((2*$q+1)*2),y0(this.dyn_ltree),y0(this.dyn_dtree),y0(this.bl_tree),this.l_desc=null,this.d_desc=null,this.bl_desc=null,this.bl_count=new Uint16Array(jq+1),this.heap=new Uint16Array(2*PJ+1),y0(this.heap),this.heap_len=0,this.heap_max=0,this.depth=new Uint16Array(2*PJ+1),y0(this.depth),this.sym_buf=0,this.lit_bufsize=0,this.sym_next=0,this.sym_end=0,this.opt_len=0,this.static_len=0,this.matches=0,this.insert=0,this.bi_buf=0,this.bi_valid=0},lq=function(){this.input=null,this.next_in=0,this.avail_in=0,this.total_in=0,this.output=null,this.next_out=0,this.avail_out=0,this.total_out=0,this.msg="",this.state=null,this.data_type=2,this.adler=0},o8=function(J){this.options=A1.assign({level:aq,method:tq,chunkSize:16384,windowBits:15,memLevel:8,strategy:sq},J||{});let G=this.options;if(G.raw&&G.windowBits>0)G.windowBits=-G.windowBits;else if(G.gzip&&G.windowBits>0&&G.windowBits<16)G.windowBits+=16;this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new w9,this.strm.avail_out=0;let Q=f8.deflateInit2(this.strm,G.level,G.method,G.windowBits,G.memLevel,G.strategy);if(Q!==B1)throw new Error(t0[Q]);if(G.header)f8.deflateSetHeader(this.strm,G.header);if(G.dictionary){let q;if(typeof G.dictionary==="string")q=l8.string2buf(G.dictionary);else if(T9.call(G.dictionary)==="[object ArrayBuffer]")q=new Uint8Array(G.dictionary);else q=G.dictionary;if(Q=f8.deflateSetDictionary(this.strm,q),Q!==B1)throw new Error(t0[Q]);this._dict_set=!0}},xJ=function(J,G){const Q=new o8(G);if(Q.push(J,!0),Q.err)throw Q.msg||t0[Q.err];return Q.result},eq=function(J,G){return G=G||{},G.raw=!0,xJ(J,G)},J6=function(J,G){return G=G||{},G.gzip=!0,xJ(J,G)},A6=function(){this.strm=null,this.mode=0,this.last=!1,this.wrap=0,this.havedict=!1,this.flags=0,this.dmax=0,this.check=0,this.total=0,this.head=null,this.wbits=0,this.wsize=0,this.whave=0,this.wnext=0,this.window=null,this.hold=0,this.bits=0,this.length=0,this.offset=0,this.extra=0,this.lencode=null,this.distcode=null,this.lenbits=0,this.distbits=0,this.ncode=0,this.nlen=0,this.ndist=0,this.have=0,this.next=null,this.lens=new Uint16Array(320),this.work=new Uint16Array(288),this.lendyn=null,this.distdyn=null,this.sane=0,this.back=0,this.was=0},u6=function(){this.text=0,this.time=0,this.xflags=0,this.os=0,this.extra=null,this.extra_len=0,this.name="",this.comment="",this.hcrc=0,this.done=!1},n8=function(J){this.options=A1.assign({chunkSize:65536,windowBits:15,to:""},J||{});const G=this.options;if(G.raw&&G.windowBits>=0&&G.windowBits<16){if(G.windowBits=-G.windowBits,G.windowBits===0)G.windowBits=-15}if(G.windowBits>=0&&G.windowBits<16&&!(J&&J.windowBits))G.windowBits+=32;if(G.windowBits>15&&G.windowBits<48){if((G.windowBits&15)===0)G.windowBits|=15}this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new w9,this.strm.avail_out=0;let Q=w0.inflateInit2(this.strm,G.windowBits);if(Q!==d8)throw new Error(t0[Q]);if(this.header=new _6,w0.inflateGetHeader(this.strm,this.header),G.dictionary){if(typeof G.dictionary==="string")G.dictionary=l8.string2buf(G.dictionary);else if(_9.call(G.dictionary)==="[object ArrayBuffer]")G.dictionary=new Uint8Array(G.dictionary);if(G.raw){if(Q=w0.inflateSetDictionary(this.strm,G.dictionary),Q!==d8)throw new Error(t0[Q])}}},wJ=function(J,G){const Q=new n8(G);if(Q.push(J),Q.err)throw Q.msg||t0[Q.err];return Q.result},i6=function(J,G){return G=G||{},G.raw=!0,wJ(J,G)};/*! pako 2.1.0 https://github.com/nodeca/pako @license (MIT AND Zlib) */var OG=0,U9=1,LG=2,AG=3,RG=258,LJ=29,i8=256,h8=i8+1+LJ,N8=30,AJ=19,V9=2*h8+1,n0=15,e1=16,kG=7,RJ=256,K9=16,Z9=17,z9=18,HJ=new Uint8Array([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0]),C1=new Uint8Array([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13]),IG=new Uint8Array([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7]),$9=new Uint8Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),xG=512,x0=new Array((h8+2)*2);B8(x0);var y8=new Array(N8*2);B8(y8);var m8=new Array(xG);B8(m8);var u8=new Array(RG-AG+1);B8(u8);var kJ=new Array(LJ);B8(kJ);var D1=new Array(N8);B8(D1);var H9,j9,M9,P9=(J)=>{return J<256?m8[J]:m8[256+(J>>>7)]},_8=(J,G)=>{J.pending_buf[J.pending++]=G&255,J.pending_buf[J.pending++]=G>>>8&255},X0=(J,G,Q)=>{if(J.bi_valid>e1-Q)J.bi_buf|=G<<J.bi_valid&65535,_8(J,J.bi_buf),J.bi_buf=G>>e1-J.bi_valid,J.bi_valid+=Q-e1;else J.bi_buf|=G<<J.bi_valid&65535,J.bi_valid+=Q},D0=(J,G,Q)=>{X0(J,Q[G*2],Q[G*2+1])},N9=(J,G)=>{let Q=0;do Q|=J&1,J>>>=1,Q<<=1;while(--G>0);return Q>>>1},wG=(J)=>{if(J.bi_valid===16)_8(J,J.bi_buf),J.bi_buf=0,J.bi_valid=0;else if(J.bi_valid>=8)J.pending_buf[J.pending++]=J.bi_buf&255,J.bi_buf>>=8,J.bi_valid-=8},TG=(J,G)=>{const{dyn_tree:Q,max_code:q}=G,W=G.stat_desc.static_tree,X=G.stat_desc.has_stree,Y=G.stat_desc.extra_bits,U=G.stat_desc.extra_base,K=G.stat_desc.max_length;let V,Z,H,$,z,D,j=0;for($=0;$<=n0;$++)J.bl_count[$]=0;Q[J.heap[J.heap_max]*2+1]=0;for(V=J.heap_max+1;V<V9;V++){if(Z=J.heap[V],$=Q[Q[Z*2+1]*2+1]+1,$>K)$=K,j++;if(Q[Z*2+1]=$,Z>q)continue;if(J.bl_count[$]++,z=0,Z>=U)z=Y[Z-U];if(D=Q[Z*2],J.opt_len+=D*($+z),X)J.static_len+=D*(W[Z*2+1]+z)}if(j===0)return;do{$=K-1;while(J.bl_count[$]===0)$--;J.bl_count[$]--,J.bl_count[$+1]+=2,J.bl_count[K]--,j-=2}while(j>0);for($=K;$!==0;$--){Z=J.bl_count[$];while(Z!==0){if(H=J.heap[--V],H>q)continue;if(Q[H*2+1]!==$)J.opt_len+=($-Q[H*2+1])*Q[H*2],Q[H*2+1]=$;Z--}}},C9=(J,G,Q)=>{const q=new Array(n0+1);let W=0,X,Y;for(X=1;X<=n0;X++)W=W+Q[X-1]<<1,q[X]=W;for(Y=0;Y<=G;Y++){let U=J[Y*2+1];if(U===0)continue;J[Y*2]=N9(q[U]++,U)}},FG=()=>{let J,G,Q,q,W;const X=new Array(n0+1);Q=0;for(q=0;q<LJ-1;q++){kJ[q]=Q;for(J=0;J<1<<HJ[q];J++)u8[Q++]=q}u8[Q-1]=q,W=0;for(q=0;q<16;q++){D1[q]=W;for(J=0;J<1<<C1[q];J++)m8[W++]=q}W>>=7;for(;q<N8;q++){D1[q]=W<<7;for(J=0;J<1<<C1[q]-7;J++)m8[256+W++]=q}for(G=0;G<=n0;G++)X[G]=0;J=0;while(J<=143)x0[J*2+1]=8,J++,X[8]++;while(J<=255)x0[J*2+1]=9,J++,X[9]++;while(J<=279)x0[J*2+1]=7,J++,X[7]++;while(J<=287)x0[J*2+1]=8,J++,X[8]++;C9(x0,h8+1,X);for(J=0;J<N8;J++)y8[J*2+1]=5,y8[J*2]=N9(J,5);H9=new JJ(x0,HJ,i8+1,h8,n0),j9=new JJ(y8,C1,0,N8,n0),M9=new JJ(new Array(0),IG,0,AJ,kG)},D9=(J)=>{let G;for(G=0;G<h8;G++)J.dyn_ltree[G*2]=0;for(G=0;G<N8;G++)J.dyn_dtree[G*2]=0;for(G=0;G<AJ;G++)J.bl_tree[G*2]=0;J.dyn_ltree[RJ*2]=1,J.opt_len=J.static_len=0,J.sym_next=J.matches=0},B9=(J)=>{if(J.bi_valid>8)_8(J,J.bi_buf);else if(J.bi_valid>0)J.pending_buf[J.pending++]=J.bi_buf;J.bi_buf=0,J.bi_valid=0},AQ=(J,G,Q,q)=>{const W=G*2,X=Q*2;return J[W]<J[X]||J[W]===J[X]&&q[G]<=q[Q]},GJ=(J,G,Q)=>{const q=J.heap[Q];let W=Q<<1;while(W<=J.heap_len){if(W<J.heap_len&&AQ(G,J.heap[W+1],J.heap[W],J.depth))W++;if(AQ(G,q,J.heap[W],J.depth))break;J.heap[Q]=J.heap[W],Q=W,W<<=1}J.heap[Q]=q},RQ=(J,G,Q)=>{let q,W,X=0,Y,U;if(J.sym_next!==0)do if(q=J.pending_buf[J.sym_buf+X++]&255,q+=(J.pending_buf[J.sym_buf+X++]&255)<<8,W=J.pending_buf[J.sym_buf+X++],q===0)D0(J,W,G);else{if(Y=u8[W],D0(J,Y+i8+1,G),U=HJ[Y],U!==0)W-=kJ[Y],X0(J,W,U);if(q--,Y=P9(q),D0(J,Y,Q),U=C1[Y],U!==0)q-=D1[Y],X0(J,q,U)}while(X<J.sym_next);D0(J,RJ,G)},jJ=(J,G)=>{const Q=G.dyn_tree,q=G.stat_desc.static_tree,W=G.stat_desc.has_stree,X=G.stat_desc.elems;let Y,U,K=-1,V;J.heap_len=0,J.heap_max=V9;for(Y=0;Y<X;Y++)if(Q[Y*2]!==0)J.heap[++J.heap_len]=K=Y,J.depth[Y]=0;else Q[Y*2+1]=0;while(J.heap_len<2)if(V=J.heap[++J.heap_len]=K<2?++K:0,Q[V*2]=1,J.depth[V]=0,J.opt_len--,W)J.static_len-=q[V*2+1];G.max_code=K;for(Y=J.heap_len>>1;Y>=1;Y--)GJ(J,Q,Y);V=X;do Y=J.heap[1],J.heap[1]=J.heap[J.heap_len--],GJ(J,Q,1),U=J.heap[1],J.heap[--J.heap_max]=Y,J.heap[--J.heap_max]=U,Q[V*2]=Q[Y*2]+Q[U*2],J.depth[V]=(J.depth[Y]>=J.depth[U]?J.depth[Y]:J.depth[U])+1,Q[Y*2+1]=Q[U*2+1]=V,J.heap[1]=V++,GJ(J,Q,1);while(J.heap_len>=2);J.heap[--J.heap_max]=J.heap[1],TG(J,G),C9(Q,K,J.bl_count)},kQ=(J,G,Q)=>{let q,W=-1,X,Y=G[1],U=0,K=7,V=4;if(Y===0)K=138,V=3;G[(Q+1)*2+1]=65535;for(q=0;q<=Q;q++){if(X=Y,Y=G[(q+1)*2+1],++U<K&&X===Y)continue;else if(U<V)J.bl_tree[X*2]+=U;else if(X!==0){if(X!==W)J.bl_tree[X*2]++;J.bl_tree[K9*2]++}else if(U<=10)J.bl_tree[Z9*2]++;else J.bl_tree[z9*2]++;if(U=0,W=X,Y===0)K=138,V=3;else if(X===Y)K=6,V=3;else K=7,V=4}},IQ=(J,G,Q)=>{let q,W=-1,X,Y=G[1],U=0,K=7,V=4;if(Y===0)K=138,V=3;for(q=0;q<=Q;q++){if(X=Y,Y=G[(q+1)*2+1],++U<K&&X===Y)continue;else if(U<V)do D0(J,X,J.bl_tree);while(--U!==0);else if(X!==0){if(X!==W)D0(J,X,J.bl_tree),U--;D0(J,K9,J.bl_tree),X0(J,U-3,2)}else if(U<=10)D0(J,Z9,J.bl_tree),X0(J,U-3,3);else D0(J,z9,J.bl_tree),X0(J,U-11,7);if(U=0,W=X,Y===0)K=138,V=3;else if(X===Y)K=6,V=3;else K=7,V=4}},SG=(J)=>{let G;kQ(J,J.dyn_ltree,J.l_desc.max_code),kQ(J,J.dyn_dtree,J.d_desc.max_code),jJ(J,J.bl_desc);for(G=AJ-1;G>=3;G--)if(J.bl_tree[$9[G]*2+1]!==0)break;return J.opt_len+=3*(G+1)+5+5+4,G},vG=(J,G,Q,q)=>{let W;X0(J,G-257,5),X0(J,Q-1,5),X0(J,q-4,4);for(W=0;W<q;W++)X0(J,J.bl_tree[$9[W]*2+1],3);IQ(J,J.dyn_ltree,G-1),IQ(J,J.dyn_dtree,Q-1)},gG=(J)=>{let G=4093624447,Q;for(Q=0;Q<=31;Q++,G>>>=1)if(G&1&&J.dyn_ltree[Q*2]!==0)return 0;if(J.dyn_ltree[18]!==0||J.dyn_ltree[20]!==0||J.dyn_ltree[26]!==0)return 1;for(Q=32;Q<i8;Q++)if(J.dyn_ltree[Q*2]!==0)return 1;return 0},xQ=!1,EG=(J)=>{if(!xQ)FG(),xQ=!0;J.l_desc=new QJ(J.dyn_ltree,H9),J.d_desc=new QJ(J.dyn_dtree,j9),J.bl_desc=new QJ(J.bl_tree,M9),J.bi_buf=0,J.bi_valid=0,D9(J)},O9=(J,G,Q,q)=>{if(X0(J,(OG<<1)+(q?1:0),3),B9(J),_8(J,Q),_8(J,~Q),Q)J.pending_buf.set(J.window.subarray(G,G+Q),J.pending);J.pending+=Q},yG=(J)=>{X0(J,U9<<1,3),D0(J,RJ,x0),wG(J)},fG=(J,G,Q,q)=>{let W,X,Y=0;if(J.level>0){if(J.strm.data_type===2)J.strm.data_type=gG(J);if(jJ(J,J.l_desc),jJ(J,J.d_desc),Y=SG(J),W=J.opt_len+3+7>>>3,X=J.static_len+3+7>>>3,X<=W)W=X}else W=X=Q+5;if(Q+4<=W&&G!==-1)O9(J,G,Q,q);else if(J.strategy===4||X===W)X0(J,(U9<<1)+(q?1:0),3),RQ(J,x0,y8);else X0(J,(LG<<1)+(q?1:0),3),vG(J,J.l_desc.max_code+1,J.d_desc.max_code+1,Y+1),RQ(J,J.dyn_ltree,J.dyn_dtree);if(D9(J),q)B9(J)},bG=(J,G,Q)=>{if(J.pending_buf[J.sym_buf+J.sym_next++]=G,J.pending_buf[J.sym_buf+J.sym_next++]=G>>8,J.pending_buf[J.sym_buf+J.sym_next++]=Q,G===0)J.dyn_ltree[Q*2]++;else J.matches++,G--,J.dyn_ltree[(u8[Q]+i8+1)*2]++,J.dyn_dtree[P9(G)*2]++;return J.sym_next===J.sym_end},hG=EG,mG=O9,uG=fG,_G=bG,cG=yG,pG={_tr_init:hG,_tr_stored_block:mG,_tr_flush_block:uG,_tr_tally:_G,_tr_align:cG},lG=(J,G,Q,q)=>{let W=J&65535|0,X=J>>>16&65535|0,Y=0;while(Q!==0){Y=Q>2000?2000:Q,Q-=Y;do W=W+G[q++]|0,X=X+W|0;while(--Y);W%=65521,X%=65521}return W|X<<16|0},c8=lG,dG=()=>{let J,G=[];for(var Q=0;Q<256;Q++){J=Q;for(var q=0;q<8;q++)J=J&1?3988292384^J>>>1:J>>>1;G[Q]=J}return G},iG=new Uint32Array(dG()),rG=(J,G,Q,q)=>{const W=iG,X=q+Q;J^=-1;for(let Y=q;Y<X;Y++)J=J>>>8^W[(J^G[Y])&255];return J^-1},t=rG,t0={2:"need dictionary",1:"stream end",0:"","-1":"file error","-2":"stream error","-3":"data error","-4":"insufficient memory","-5":"buffer error","-6":"incompatible version"},Q8={Z_NO_FLUSH:0,Z_PARTIAL_FLUSH:1,Z_SYNC_FLUSH:2,Z_FULL_FLUSH:3,Z_FINISH:4,Z_BLOCK:5,Z_TREES:6,Z_OK:0,Z_STREAM_END:1,Z_NEED_DICT:2,Z_ERRNO:-1,Z_STREAM_ERROR:-2,Z_DATA_ERROR:-3,Z_MEM_ERROR:-4,Z_BUF_ERROR:-5,Z_NO_COMPRESSION:0,Z_BEST_SPEED:1,Z_BEST_COMPRESSION:9,Z_DEFAULT_COMPRESSION:-1,Z_FILTERED:1,Z_HUFFMAN_ONLY:2,Z_RLE:3,Z_FIXED:4,Z_DEFAULT_STRATEGY:0,Z_BINARY:0,Z_TEXT:1,Z_UNKNOWN:2,Z_DEFLATED:8},{_tr_init:oG,_tr_stored_block:MJ,_tr_flush_block:nG,_tr_tally:b0,_tr_align:aG}=pG,{Z_NO_FLUSH:h0,Z_PARTIAL_FLUSH:sG,Z_FULL_FLUSH:tG,Z_FINISH:z0,Z_BLOCK:wQ,Z_OK:Q0,Z_STREAM_END:TQ,Z_STREAM_ERROR:B0,Z_DATA_ERROR:eG,Z_BUF_ERROR:qJ,Z_DEFAULT_COMPRESSION:Jq,Z_FILTERED:Qq,Z_HUFFMAN_ONLY:H1,Z_RLE:Gq,Z_FIXED:qq,Z_DEFAULT_STRATEGY:Wq,Z_UNKNOWN:Xq,Z_DEFLATED:L1}=Q8,Yq=9,Uq=15,Vq=8,Kq=29,Zq=256,PJ=Zq+1+Kq,zq=30,$q=19,Hq=2*PJ+1,jq=15,b=3,f0=258,O0=f0+b+1,Mq=32,C8=42,IJ=57,NJ=69,CJ=73,DJ=91,BJ=103,a0=113,g8=666,W0=1,O8=2,e0=3,L8=4,Pq=3,s0=(J,G)=>{return J.msg=t0[G],G},FQ=(J)=>{return J*2-(J>4?9:0)},y0=(J)=>{let G=J.length;while(--G>=0)J[G]=0},Nq=(J)=>{let G,Q,q,W=J.w_size;G=J.hash_size,q=G;do Q=J.head[--q],J.head[q]=Q>=W?Q-W:0;while(--G);G=W,q=G;do Q=J.prev[--q],J.prev[q]=Q>=W?Q-W:0;while(--G)},Cq=(J,G,Q)=>(G<<J.hash_shift^Q)&J.hash_mask,m0=Cq,V0=(J)=>{const G=J.state;let Q=G.pending;if(Q>J.avail_out)Q=J.avail_out;if(Q===0)return;if(J.output.set(G.pending_buf.subarray(G.pending_out,G.pending_out+Q),J.next_out),J.next_out+=Q,G.pending_out+=Q,J.total_out+=Q,J.avail_out-=Q,G.pending-=Q,G.pending===0)G.pending_out=0},K0=(J,G)=>{nG(J,J.block_start>=0?J.block_start:-1,J.strstart-J.block_start,G),J.block_start=J.strstart,V0(J.strm)},h=(J,G)=>{J.pending_buf[J.pending++]=G},v8=(J,G)=>{J.pending_buf[J.pending++]=G>>>8&255,J.pending_buf[J.pending++]=G&255},OJ=(J,G,Q,q)=>{let W=J.avail_in;if(W>q)W=q;if(W===0)return 0;if(J.avail_in-=W,G.set(J.input.subarray(J.next_in,J.next_in+W),Q),J.state.wrap===1)J.adler=c8(J.adler,G,W,Q);else if(J.state.wrap===2)J.adler=t(J.adler,G,W,Q);return J.next_in+=W,J.total_in+=W,W},L9=(J,G)=>{let{max_chain_length:Q,strstart:q}=J,W,X,Y=J.prev_length,U=J.nice_match;const K=J.strstart>J.w_size-O0?J.strstart-(J.w_size-O0):0,V=J.window,Z=J.w_mask,H=J.prev,$=J.strstart+f0;let z=V[q+Y-1],D=V[q+Y];if(J.prev_length>=J.good_match)Q>>=2;if(U>J.lookahead)U=J.lookahead;do{if(W=G,V[W+Y]!==D||V[W+Y-1]!==z||V[W]!==V[q]||V[++W]!==V[q+1])continue;q+=2,W++;do;while(V[++q]===V[++W]&&V[++q]===V[++W]&&V[++q]===V[++W]&&V[++q]===V[++W]&&V[++q]===V[++W]&&V[++q]===V[++W]&&V[++q]===V[++W]&&V[++q]===V[++W]&&q<$);if(X=f0-($-q),q=$-f0,X>Y){if(J.match_start=G,Y=X,X>=U)break;z=V[q+Y-1],D=V[q+Y]}}while((G=H[G&Z])>K&&--Q!==0);if(Y<=J.lookahead)return Y;return J.lookahead},D8=(J)=>{const G=J.w_size;let Q,q,W;do{if(q=J.window_size-J.lookahead-J.strstart,J.strstart>=G+(G-O0)){if(J.window.set(J.window.subarray(G,G+G-q),0),J.match_start-=G,J.strstart-=G,J.block_start-=G,J.insert>J.strstart)J.insert=J.strstart;Nq(J),q+=G}if(J.strm.avail_in===0)break;if(Q=OJ(J.strm,J.window,J.strstart+J.lookahead,q),J.lookahead+=Q,J.lookahead+J.insert>=b){W=J.strstart-J.insert,J.ins_h=J.window[W],J.ins_h=m0(J,J.ins_h,J.window[W+1]);while(J.insert)if(J.ins_h=m0(J,J.ins_h,J.window[W+b-1]),J.prev[W&J.w_mask]=J.head[J.ins_h],J.head[J.ins_h]=W,W++,J.insert--,J.lookahead+J.insert<b)break}}while(J.lookahead<O0&&J.strm.avail_in!==0)},A9=(J,G)=>{let Q=J.pending_buf_size-5>J.w_size?J.w_size:J.pending_buf_size-5,q,W,X,Y=0,U=J.strm.avail_in;do{if(q=65535,X=J.bi_valid+42>>3,J.strm.avail_out<X)break;if(X=J.strm.avail_out-X,W=J.strstart-J.block_start,q>W+J.strm.avail_in)q=W+J.strm.avail_in;if(q>X)q=X;if(q<Q&&(q===0&&G!==z0||G===h0||q!==W+J.strm.avail_in))break;if(Y=G===z0&&q===W+J.strm.avail_in?1:0,MJ(J,0,0,Y),J.pending_buf[J.pending-4]=q,J.pending_buf[J.pending-3]=q>>8,J.pending_buf[J.pending-2]=~q,J.pending_buf[J.pending-1]=~q>>8,V0(J.strm),W){if(W>q)W=q;J.strm.output.set(J.window.subarray(J.block_start,J.block_start+W),J.strm.next_out),J.strm.next_out+=W,J.strm.avail_out-=W,J.strm.total_out+=W,J.block_start+=W,q-=W}if(q)OJ(J.strm,J.strm.output,J.strm.next_out,q),J.strm.next_out+=q,J.strm.avail_out-=q,J.strm.total_out+=q}while(Y===0);if(U-=J.strm.avail_in,U){if(U>=J.w_size)J.matches=2,J.window.set(J.strm.input.subarray(J.strm.next_in-J.w_size,J.strm.next_in),0),J.strstart=J.w_size,J.insert=J.strstart;else{if(J.window_size-J.strstart<=U){if(J.strstart-=J.w_size,J.window.set(J.window.subarray(J.w_size,J.w_size+J.strstart),0),J.matches<2)J.matches++;if(J.insert>J.strstart)J.insert=J.strstart}J.window.set(J.strm.input.subarray(J.strm.next_in-U,J.strm.next_in),J.strstart),J.strstart+=U,J.insert+=U>J.w_size-J.insert?J.w_size-J.insert:U}J.block_start=J.strstart}if(J.high_water<J.strstart)J.high_water=J.strstart;if(Y)return L8;if(G!==h0&&G!==z0&&J.strm.avail_in===0&&J.strstart===J.block_start)return O8;if(X=J.window_size-J.strstart,J.strm.avail_in>X&&J.block_start>=J.w_size){if(J.block_start-=J.w_size,J.strstart-=J.w_size,J.window.set(J.window.subarray(J.w_size,J.w_size+J.strstart),0),J.matches<2)J.matches++;if(X+=J.w_size,J.insert>J.strstart)J.insert=J.strstart}if(X>J.strm.avail_in)X=J.strm.avail_in;if(X)OJ(J.strm,J.window,J.strstart,X),J.strstart+=X,J.insert+=X>J.w_size-J.insert?J.w_size-J.insert:X;if(J.high_water<J.strstart)J.high_water=J.strstart;if(X=J.bi_valid+42>>3,X=J.pending_buf_size-X>65535?65535:J.pending_buf_size-X,Q=X>J.w_size?J.w_size:X,W=J.strstart-J.block_start,W>=Q||(W||G===z0)&&G!==h0&&J.strm.avail_in===0&&W<=X)q=W>X?X:W,Y=G===z0&&J.strm.avail_in===0&&q===W?1:0,MJ(J,J.block_start,q,Y),J.block_start+=q,V0(J.strm);return Y?e0:W0},WJ=(J,G)=>{let Q,q;for(;;){if(J.lookahead<O0){if(D8(J),J.lookahead<O0&&G===h0)return W0;if(J.lookahead===0)break}if(Q=0,J.lookahead>=b)J.ins_h=m0(J,J.ins_h,J.window[J.strstart+b-1]),Q=J.prev[J.strstart&J.w_mask]=J.head[J.ins_h],J.head[J.ins_h]=J.strstart;if(Q!==0&&J.strstart-Q<=J.w_size-O0)J.match_length=L9(J,Q);if(J.match_length>=b)if(q=b0(J,J.strstart-J.match_start,J.match_length-b),J.lookahead-=J.match_length,J.match_length<=J.max_lazy_match&&J.lookahead>=b){J.match_length--;do J.strstart++,J.ins_h=m0(J,J.ins_h,J.window[J.strstart+b-1]),Q=J.prev[J.strstart&J.w_mask]=J.head[J.ins_h],J.head[J.ins_h]=J.strstart;while(--J.match_length!==0);J.strstart++}else J.strstart+=J.match_length,J.match_length=0,J.ins_h=J.window[J.strstart],J.ins_h=m0(J,J.ins_h,J.window[J.strstart+1]);else q=b0(J,0,J.window[J.strstart]),J.lookahead--,J.strstart++;if(q){if(K0(J,!1),J.strm.avail_out===0)return W0}}if(J.insert=J.strstart<b-1?J.strstart:b-1,G===z0){if(K0(J,!0),J.strm.avail_out===0)return e0;return L8}if(J.sym_next){if(K0(J,!1),J.strm.avail_out===0)return W0}return O8},M8=(J,G)=>{let Q,q,W;for(;;){if(J.lookahead<O0){if(D8(J),J.lookahead<O0&&G===h0)return W0;if(J.lookahead===0)break}if(Q=0,J.lookahead>=b)J.ins_h=m0(J,J.ins_h,J.window[J.strstart+b-1]),Q=J.prev[J.strstart&J.w_mask]=J.head[J.ins_h],J.head[J.ins_h]=J.strstart;if(J.prev_length=J.match_length,J.prev_match=J.match_start,J.match_length=b-1,Q!==0&&J.prev_length<J.max_lazy_match&&J.strstart-Q<=J.w_size-O0){if(J.match_length=L9(J,Q),J.match_length<=5&&(J.strategy===Qq||J.match_length===b&&J.strstart-J.match_start>4096))J.match_length=b-1}if(J.prev_length>=b&&J.match_length<=J.prev_length){W=J.strstart+J.lookahead-b,q=b0(J,J.strstart-1-J.prev_match,J.prev_length-b),J.lookahead-=J.prev_length-1,J.prev_length-=2;do if(++J.strstart<=W)J.ins_h=m0(J,J.ins_h,J.window[J.strstart+b-1]),Q=J.prev[J.strstart&J.w_mask]=J.head[J.ins_h],J.head[J.ins_h]=J.strstart;while(--J.prev_length!==0);if(J.match_available=0,J.match_length=b-1,J.strstart++,q){if(K0(J,!1),J.strm.avail_out===0)return W0}}else if(J.match_available){if(q=b0(J,0,J.window[J.strstart-1]),q)K0(J,!1);if(J.strstart++,J.lookahead--,J.strm.avail_out===0)return W0}else J.match_available=1,J.strstart++,J.lookahead--}if(J.match_available)q=b0(J,0,J.window[J.strstart-1]),J.match_available=0;if(J.insert=J.strstart<b-1?J.strstart:b-1,G===z0){if(K0(J,!0),J.strm.avail_out===0)return e0;return L8}if(J.sym_next){if(K0(J,!1),J.strm.avail_out===0)return W0}return O8},Dq=(J,G)=>{let Q,q,W,X;const Y=J.window;for(;;){if(J.lookahead<=f0){if(D8(J),J.lookahead<=f0&&G===h0)return W0;if(J.lookahead===0)break}if(J.match_length=0,J.lookahead>=b&&J.strstart>0){if(W=J.strstart-1,q=Y[W],q===Y[++W]&&q===Y[++W]&&q===Y[++W]){X=J.strstart+f0;do;while(q===Y[++W]&&q===Y[++W]&&q===Y[++W]&&q===Y[++W]&&q===Y[++W]&&q===Y[++W]&&q===Y[++W]&&q===Y[++W]&&W<X);if(J.match_length=f0-(X-W),J.match_length>J.lookahead)J.match_length=J.lookahead}}if(J.match_length>=b)Q=b0(J,1,J.match_length-b),J.lookahead-=J.match_length,J.strstart+=J.match_length,J.match_length=0;else Q=b0(J,0,J.window[J.strstart]),J.lookahead--,J.strstart++;if(Q){if(K0(J,!1),J.strm.avail_out===0)return W0}}if(J.insert=0,G===z0){if(K0(J,!0),J.strm.avail_out===0)return e0;return L8}if(J.sym_next){if(K0(J,!1),J.strm.avail_out===0)return W0}return O8},Bq=(J,G)=>{let Q;for(;;){if(J.lookahead===0){if(D8(J),J.lookahead===0){if(G===h0)return W0;break}}if(J.match_length=0,Q=b0(J,0,J.window[J.strstart]),J.lookahead--,J.strstart++,Q){if(K0(J,!1),J.strm.avail_out===0)return W0}}if(J.insert=0,G===z0){if(K0(J,!0),J.strm.avail_out===0)return e0;return L8}if(J.sym_next){if(K0(J,!1),J.strm.avail_out===0)return W0}return O8},E8=[new C0(0,0,0,0,A9),new C0(4,4,8,4,WJ),new C0(4,5,16,8,WJ),new C0(4,6,32,32,WJ),new C0(4,4,16,16,M8),new C0(8,16,32,32,M8),new C0(8,16,128,128,M8),new C0(8,32,128,256,M8),new C0(32,128,258,1024,M8),new C0(32,258,258,4096,M8)],Oq=(J)=>{J.window_size=2*J.w_size,y0(J.head),J.max_lazy_match=E8[J.level].max_lazy,J.good_match=E8[J.level].good_length,J.nice_match=E8[J.level].nice_length,J.max_chain_length=E8[J.level].max_chain,J.strstart=0,J.block_start=0,J.lookahead=0,J.insert=0,J.match_length=J.prev_length=b-1,J.match_available=0,J.ins_h=0},r8=(J)=>{if(!J)return 1;const G=J.state;if(!G||G.strm!==J||G.status!==C8&&G.status!==IJ&&G.status!==NJ&&G.status!==CJ&&G.status!==DJ&&G.status!==BJ&&G.status!==a0&&G.status!==g8)return 1;return 0},R9=(J)=>{if(r8(J))return s0(J,B0);J.total_in=J.total_out=0,J.data_type=Xq;const G=J.state;if(G.pending=0,G.pending_out=0,G.wrap<0)G.wrap=-G.wrap;return G.status=G.wrap===2?IJ:G.wrap?C8:a0,J.adler=G.wrap===2?0:1,G.last_flush=-2,oG(G),Q0},k9=(J)=>{const G=R9(J);if(G===Q0)Oq(J.state);return G},Aq=(J,G)=>{if(r8(J)||J.state.wrap!==2)return B0;return J.state.gzhead=G,Q0},I9=(J,G,Q,q,W,X)=>{if(!J)return B0;let Y=1;if(G===Jq)G=6;if(q<0)Y=0,q=-q;else if(q>15)Y=2,q-=16;if(W<1||W>Yq||Q!==L1||q<8||q>15||G<0||G>9||X<0||X>qq||q===8&&Y!==1)return s0(J,B0);if(q===8)q=9;const U=new Lq;return J.state=U,U.strm=J,U.status=C8,U.wrap=Y,U.gzhead=null,U.w_bits=q,U.w_size=1<<U.w_bits,U.w_mask=U.w_size-1,U.hash_bits=W+7,U.hash_size=1<<U.hash_bits,U.hash_mask=U.hash_size-1,U.hash_shift=~~((U.hash_bits+b-1)/b),U.window=new Uint8Array(U.w_size*2),U.head=new Uint16Array(U.hash_size),U.prev=new Uint16Array(U.w_size),U.lit_bufsize=1<<W+6,U.pending_buf_size=U.lit_bufsize*4,U.pending_buf=new Uint8Array(U.pending_buf_size),U.sym_buf=U.lit_bufsize,U.sym_end=(U.lit_bufsize-1)*3,U.level=G,U.strategy=X,U.method=Q,k9(J)},Rq=(J,G)=>{return I9(J,G,L1,Uq,Vq,Wq)},kq=(J,G)=>{if(r8(J)||G>wQ||G<0)return J?s0(J,B0):B0;const Q=J.state;if(!J.output||J.avail_in!==0&&!J.input||Q.status===g8&&G!==z0)return s0(J,J.avail_out===0?qJ:B0);const q=Q.last_flush;if(Q.last_flush=G,Q.pending!==0){if(V0(J),J.avail_out===0)return Q.last_flush=-1,Q0}else if(J.avail_in===0&&FQ(G)<=FQ(q)&&G!==z0)return s0(J,qJ);if(Q.status===g8&&J.avail_in!==0)return s0(J,qJ);if(Q.status===C8&&Q.wrap===0)Q.status=a0;if(Q.status===C8){let W=L1+(Q.w_bits-8<<4)<<8,X=-1;if(Q.strategy>=H1||Q.level<2)X=0;else if(Q.level<6)X=1;else if(Q.level===6)X=2;else X=3;if(W|=X<<6,Q.strstart!==0)W|=Mq;if(W+=31-W%31,v8(Q,W),Q.strstart!==0)v8(Q,J.adler>>>16),v8(Q,J.adler&65535);if(J.adler=1,Q.status=a0,V0(J),Q.pending!==0)return Q.last_flush=-1,Q0}if(Q.status===IJ)if(J.adler=0,h(Q,31),h(Q,139),h(Q,8),!Q.gzhead){if(h(Q,0),h(Q,0),h(Q,0),h(Q,0),h(Q,0),h(Q,Q.level===9?2:Q.strategy>=H1||Q.level<2?4:0),h(Q,Pq),Q.status=a0,V0(J),Q.pending!==0)return Q.last_flush=-1,Q0}else{if(h(Q,(Q.gzhead.text?1:0)+(Q.gzhead.hcrc?2:0)+(!Q.gzhead.extra?0:4)+(!Q.gzhead.name?0:8)+(!Q.gzhead.comment?0:16)),h(Q,Q.gzhead.time&255),h(Q,Q.gzhead.time>>8&255),h(Q,Q.gzhead.time>>16&255),h(Q,Q.gzhead.time>>24&255),h(Q,Q.level===9?2:Q.strategy>=H1||Q.level<2?4:0),h(Q,Q.gzhead.os&255),Q.gzhead.extra&&Q.gzhead.extra.length)h(Q,Q.gzhead.extra.length&255),h(Q,Q.gzhead.extra.length>>8&255);if(Q.gzhead.hcrc)J.adler=t(J.adler,Q.pending_buf,Q.pending,0);Q.gzindex=0,Q.status=NJ}if(Q.status===NJ){if(Q.gzhead.extra){let W=Q.pending,X=(Q.gzhead.extra.length&65535)-Q.gzindex;while(Q.pending+X>Q.pending_buf_size){let U=Q.pending_buf_size-Q.pending;if(Q.pending_buf.set(Q.gzhead.extra.subarray(Q.gzindex,Q.gzindex+U),Q.pending),Q.pending=Q.pending_buf_size,Q.gzhead.hcrc&&Q.pending>W)J.adler=t(J.adler,Q.pending_buf,Q.pending-W,W);if(Q.gzindex+=U,V0(J),Q.pending!==0)return Q.last_flush=-1,Q0;W=0,X-=U}let Y=new Uint8Array(Q.gzhead.extra);if(Q.pending_buf.set(Y.subarray(Q.gzindex,Q.gzindex+X),Q.pending),Q.pending+=X,Q.gzhead.hcrc&&Q.pending>W)J.adler=t(J.adler,Q.pending_buf,Q.pending-W,W);Q.gzindex=0}Q.status=CJ}if(Q.status===CJ){if(Q.gzhead.name){let W=Q.pending,X;do{if(Q.pending===Q.pending_buf_size){if(Q.gzhead.hcrc&&Q.pending>W)J.adler=t(J.adler,Q.pending_buf,Q.pending-W,W);if(V0(J),Q.pending!==0)return Q.last_flush=-1,Q0;W=0}if(Q.gzindex<Q.gzhead.name.length)X=Q.gzhead.name.charCodeAt(Q.gzindex++)&255;else X=0;h(Q,X)}while(X!==0);if(Q.gzhead.hcrc&&Q.pending>W)J.adler=t(J.adler,Q.pending_buf,Q.pending-W,W);Q.gzindex=0}Q.status=DJ}if(Q.status===DJ){if(Q.gzhead.comment){let W=Q.pending,X;do{if(Q.pending===Q.pending_buf_size){if(Q.gzhead.hcrc&&Q.pending>W)J.adler=t(J.adler,Q.pending_buf,Q.pending-W,W);if(V0(J),Q.pending!==0)return Q.last_flush=-1,Q0;W=0}if(Q.gzindex<Q.gzhead.comment.length)X=Q.gzhead.comment.charCodeAt(Q.gzindex++)&255;else X=0;h(Q,X)}while(X!==0);if(Q.gzhead.hcrc&&Q.pending>W)J.adler=t(J.adler,Q.pending_buf,Q.pending-W,W)}Q.status=BJ}if(Q.status===BJ){if(Q.gzhead.hcrc){if(Q.pending+2>Q.pending_buf_size){if(V0(J),Q.pending!==0)return Q.last_flush=-1,Q0}h(Q,J.adler&255),h(Q,J.adler>>8&255),J.adler=0}if(Q.status=a0,V0(J),Q.pending!==0)return Q.last_flush=-1,Q0}if(J.avail_in!==0||Q.lookahead!==0||G!==h0&&Q.status!==g8){let W=Q.level===0?A9(Q,G):Q.strategy===H1?Bq(Q,G):Q.strategy===Gq?Dq(Q,G):E8[Q.level].func(Q,G);if(W===e0||W===L8)Q.status=g8;if(W===W0||W===e0){if(J.avail_out===0)Q.last_flush=-1;return Q0}if(W===O8){if(G===sG)aG(Q);else if(G!==wQ){if(MJ(Q,0,0,!1),G===tG){if(y0(Q.head),Q.lookahead===0)Q.strstart=0,Q.block_start=0,Q.insert=0}}if(V0(J),J.avail_out===0)return Q.last_flush=-1,Q0}}if(G!==z0)return Q0;if(Q.wrap<=0)return TQ;if(Q.wrap===2)h(Q,J.adler&255),h(Q,J.adler>>8&255),h(Q,J.adler>>16&255),h(Q,J.adler>>24&255),h(Q,J.total_in&255),h(Q,J.total_in>>8&255),h(Q,J.total_in>>16&255),h(Q,J.total_in>>24&255);else v8(Q,J.adler>>>16),v8(Q,J.adler&65535);if(V0(J),Q.wrap>0)Q.wrap=-Q.wrap;return Q.pending!==0?Q0:TQ},Iq=(J)=>{if(r8(J))return B0;const G=J.state.status;return J.state=null,G===a0?s0(J,eG):Q0},xq=(J,G)=>{let Q=G.length;if(r8(J))return B0;const q=J.state,W=q.wrap;if(W===2||W===1&&q.status!==C8||q.lookahead)return B0;if(W===1)J.adler=c8(J.adler,G,Q,0);if(q.wrap=0,Q>=q.w_size){if(W===0)y0(q.head),q.strstart=0,q.block_start=0,q.insert=0;let K=new Uint8Array(q.w_size);K.set(G.subarray(Q-q.w_size,Q),0),G=K,Q=q.w_size}const{avail_in:X,next_in:Y,input:U}=J;J.avail_in=Q,J.next_in=0,J.input=G,D8(q);while(q.lookahead>=b){let K=q.strstart,V=q.lookahead-(b-1);do q.ins_h=m0(q,q.ins_h,q.window[K+b-1]),q.prev[K&q.w_mask]=q.head[q.ins_h],q.head[q.ins_h]=K,K++;while(--V);q.strstart=K,q.lookahead=b-1,D8(q)}return q.strstart+=q.lookahead,q.block_start=q.strstart,q.insert=q.lookahead,q.lookahead=0,q.match_length=q.prev_length=b-1,q.match_available=0,J.next_in=Y,J.input=U,J.avail_in=X,q.wrap=W,Q0},wq=Rq,Tq=I9,Fq=k9,Sq=R9,vq=Aq,gq=kq,Eq=Iq,yq=xq,fq="pako deflate (from Nodeca project)",f8={deflateInit:wq,deflateInit2:Tq,deflateReset:Fq,deflateResetKeep:Sq,deflateSetHeader:vq,deflate:gq,deflateEnd:Eq,deflateSetDictionary:yq,deflateInfo:fq},bq=(J,G)=>{return Object.prototype.hasOwnProperty.call(J,G)},hq=function(J){const G=Array.prototype.slice.call(arguments,1);while(G.length){const Q=G.shift();if(!Q)continue;if(typeof Q!=="object")throw new TypeError(Q+"must be non-object");for(let q in Q)if(bq(Q,q))J[q]=Q[q]}return J},mq=(J)=>{let G=0;for(let q=0,W=J.length;q<W;q++)G+=J[q].length;const Q=new Uint8Array(G);for(let q=0,W=0,X=J.length;q<X;q++){let Y=J[q];Q.set(Y,W),W+=Y.length}return Q},A1={assign:hq,flattenChunks:mq},x9=!0;try{String.fromCharCode.apply(null,new Uint8Array(1))}catch(J){x9=!1}var p8=new Uint8Array(256);for(let J=0;J<256;J++)p8[J]=J>=252?6:J>=248?5:J>=240?4:J>=224?3:J>=192?2:1;p8[254]=p8[254]=1;var uq=(J)=>{if(typeof TextEncoder==="function"&&TextEncoder.prototype.encode)return(new TextEncoder()).encode(J);let G,Q,q,W,X,Y=J.length,U=0;for(W=0;W<Y;W++){if(Q=J.charCodeAt(W),(Q&64512)===55296&&W+1<Y){if(q=J.charCodeAt(W+1),(q&64512)===56320)Q=65536+(Q-55296<<10)+(q-56320),W++}U+=Q<128?1:Q<2048?2:Q<65536?3:4}G=new Uint8Array(U);for(X=0,W=0;X<U;W++){if(Q=J.charCodeAt(W),(Q&64512)===55296&&W+1<Y){if(q=J.charCodeAt(W+1),(q&64512)===56320)Q=65536+(Q-55296<<10)+(q-56320),W++}if(Q<128)G[X++]=Q;else if(Q<2048)G[X++]=192|Q>>>6,G[X++]=128|Q&63;else if(Q<65536)G[X++]=224|Q>>>12,G[X++]=128|Q>>>6&63,G[X++]=128|Q&63;else G[X++]=240|Q>>>18,G[X++]=128|Q>>>12&63,G[X++]=128|Q>>>6&63,G[X++]=128|Q&63}return G},_q=(J,G)=>{if(G<65534){if(J.subarray&&x9)return String.fromCharCode.apply(null,J.length===G?J:J.subarray(0,G))}let Q="";for(let q=0;q<G;q++)Q+=String.fromCharCode(J[q]);return Q},cq=(J,G)=>{const Q=G||J.length;if(typeof TextDecoder==="function"&&TextDecoder.prototype.decode)return(new TextDecoder()).decode(J.subarray(0,G));let q,W;const X=new Array(Q*2);for(W=0,q=0;q<Q;){let Y=J[q++];if(Y<128){X[W++]=Y;continue}let U=p8[Y];if(U>4){X[W++]=65533,q+=U-1;continue}Y&=U===2?31:U===3?15:7;while(U>1&&q<Q)Y=Y<<6|J[q++]&63,U--;if(U>1){X[W++]=65533;continue}if(Y<65536)X[W++]=Y;else Y-=65536,X[W++]=55296|Y>>10&1023,X[W++]=56320|Y&1023}return _q(X,W)},pq=(J,G)=>{if(G=G||J.length,G>J.length)G=J.length;let Q=G-1;while(Q>=0&&(J[Q]&192)===128)Q--;if(Q<0)return G;if(Q===0)return G;return Q+p8[J[Q]]>G?Q:G},l8={string2buf:uq,buf2string:cq,utf8border:pq},w9=lq,T9=Object.prototype.toString,{Z_NO_FLUSH:dq,Z_SYNC_FLUSH:iq,Z_FULL_FLUSH:rq,Z_FINISH:oq,Z_OK:B1,Z_STREAM_END:nq,Z_DEFAULT_COMPRESSION:aq,Z_DEFAULT_STRATEGY:sq,Z_DEFLATED:tq}=Q8;o8.prototype.push=function(J,G){const Q=this.strm,q=this.options.chunkSize;let W,X;if(this.ended)return!1;if(G===~~G)X=G;else X=G===!0?oq:dq;if(typeof J==="string")Q.input=l8.string2buf(J);else if(T9.call(J)==="[object ArrayBuffer]")Q.input=new Uint8Array(J);else Q.input=J;Q.next_in=0,Q.avail_in=Q.input.length;for(;;){if(Q.avail_out===0)Q.output=new Uint8Array(q),Q.next_out=0,Q.avail_out=q;if((X===iq||X===rq)&&Q.avail_out<=6){this.onData(Q.output.subarray(0,Q.next_out)),Q.avail_out=0;continue}if(W=f8.deflate(Q,X),W===nq){if(Q.next_out>0)this.onData(Q.output.subarray(0,Q.next_out));return W=f8.deflateEnd(this.strm),this.onEnd(W),this.ended=!0,W===B1}if(Q.avail_out===0){this.onData(Q.output);continue}if(X>0&&Q.next_out>0){this.onData(Q.output.subarray(0,Q.next_out)),Q.avail_out=0;continue}if(Q.avail_in===0)break}return!0};o8.prototype.onData=function(J){this.chunks.push(J)};o8.prototype.onEnd=function(J){if(J===B1)this.result=A1.flattenChunks(this.chunks);this.chunks=[],this.err=J,this.msg=this.strm.msg};var Q6=o8,G6=xJ,q6=eq,W6=J6,X6=Q8,Y6={Deflate:Q6,deflate:G6,deflateRaw:q6,gzip:W6,constants:X6},j1=16209,U6=16191,V6=function J(G,Q){let q,W,X,Y,U,K,V,Z,H,$,z,D,j,M,A,R,k,N,T,w,L,I,E,x;const S=G.state;q=G.next_in,E=G.input,W=q+(G.avail_in-5),X=G.next_out,x=G.output,Y=X-(Q-G.avail_out),U=X+(G.avail_out-257),K=S.dmax,V=S.wsize,Z=S.whave,H=S.wnext,$=S.window,z=S.hold,D=S.bits,j=S.lencode,M=S.distcode,A=(1<<S.lenbits)-1,R=(1<<S.distbits)-1;J:do{if(D<15)z+=E[q++]<<D,D+=8,z+=E[q++]<<D,D+=8;k=j[z&A];Q:for(;;){if(N=k>>>24,z>>>=N,D-=N,N=k>>>16&255,N===0)x[X++]=k&65535;else if(N&16){if(T=k&65535,N&=15,N){if(D<N)z+=E[q++]<<D,D+=8;T+=z&(1<<N)-1,z>>>=N,D-=N}if(D<15)z+=E[q++]<<D,D+=8,z+=E[q++]<<D,D+=8;k=M[z&R];G:for(;;){if(N=k>>>24,z>>>=N,D-=N,N=k>>>16&255,N&16){if(w=k&65535,N&=15,D<N){if(z+=E[q++]<<D,D+=8,D<N)z+=E[q++]<<D,D+=8}if(w+=z&(1<<N)-1,w>K){G.msg="invalid distance too far back",S.mode=j1;break J}if(z>>>=N,D-=N,N=X-Y,w>N){if(N=w-N,N>Z){if(S.sane){G.msg="invalid distance too far back",S.mode=j1;break J}}if(L=0,I=$,H===0){if(L+=V-N,N<T){T-=N;do x[X++]=$[L++];while(--N);L=X-w,I=x}}else if(H<N){if(L+=V+H-N,N-=H,N<T){T-=N;do x[X++]=$[L++];while(--N);if(L=0,H<T){N=H,T-=N;do x[X++]=$[L++];while(--N);L=X-w,I=x}}}else if(L+=H-N,N<T){T-=N;do x[X++]=$[L++];while(--N);L=X-w,I=x}while(T>2)x[X++]=I[L++],x[X++]=I[L++],x[X++]=I[L++],T-=3;if(T){if(x[X++]=I[L++],T>1)x[X++]=I[L++]}}else{L=X-w;do x[X++]=x[L++],x[X++]=x[L++],x[X++]=x[L++],T-=3;while(T>2);if(T){if(x[X++]=x[L++],T>1)x[X++]=x[L++]}}}else if((N&64)===0){k=M[(k&65535)+(z&(1<<N)-1)];continue G}else{G.msg="invalid distance code",S.mode=j1;break J}break}}else if((N&64)===0){k=j[(k&65535)+(z&(1<<N)-1)];continue Q}else if(N&32){S.mode=U6;break J}else{G.msg="invalid literal/length code",S.mode=j1;break J}break}}while(q<W&&X<U);T=D>>3,q-=T,D-=T<<3,z&=(1<<D)-1,G.next_in=q,G.next_out=X,G.avail_in=q<W?5+(W-q):5-(q-W),G.avail_out=X<U?257+(U-X):257-(X-U),S.hold=z,S.bits=D;return},P8=15,SQ=852,vQ=592,gQ=0,XJ=1,EQ=2,K6=new Uint16Array([3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,0,0]),Z6=new Uint8Array([16,16,16,16,16,16,16,16,17,17,17,17,18,18,18,18,19,19,19,19,20,20,20,20,21,21,21,21,16,72,78]),z6=new Uint16Array([1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,0,0]),$6=new Uint8Array([16,16,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,64,64]),H6=(J,G,Q,q,W,X,Y,U)=>{const K=U.bits;let V=0,Z=0,H=0,$=0,z=0,D=0,j=0,M=0,A=0,R=0,k,N,T,w,L,I=null,E;const x=new Uint16Array(P8+1),S=new Uint16Array(P8+1);let B=null,F,P,O;for(V=0;V<=P8;V++)x[V]=0;for(Z=0;Z<q;Z++)x[G[Q+Z]]++;z=K;for($=P8;$>=1;$--)if(x[$]!==0)break;if(z>$)z=$;if($===0)return W[X++]=1<<24|64<<16|0,W[X++]=1<<24|64<<16|0,U.bits=1,0;for(H=1;H<$;H++)if(x[H]!==0)break;if(z<H)z=H;M=1;for(V=1;V<=P8;V++)if(M<<=1,M-=x[V],M<0)return-1;if(M>0&&(J===gQ||$!==1))return-1;S[1]=0;for(V=1;V<P8;V++)S[V+1]=S[V]+x[V];for(Z=0;Z<q;Z++)if(G[Q+Z]!==0)Y[S[G[Q+Z]]++]=Z;if(J===gQ)I=B=Y,E=20;else if(J===XJ)I=K6,B=Z6,E=257;else I=z6,B=$6,E=0;if(R=0,Z=0,V=H,L=X,D=z,j=0,T=-1,A=1<<z,w=A-1,J===XJ&&A>SQ||J===EQ&&A>vQ)return 1;for(;;){if(F=V-j,Y[Z]+1<E)P=0,O=Y[Z];else if(Y[Z]>=E)P=B[Y[Z]-E],O=I[Y[Z]-E];else P=96,O=0;k=1<<V-j,N=1<<D,H=N;do N-=k,W[L+(R>>j)+N]=F<<24|P<<16|O|0;while(N!==0);k=1<<V-1;while(R&k)k>>=1;if(k!==0)R&=k-1,R+=k;else R=0;if(Z++,--x[V]===0){if(V===$)break;V=G[Q+Y[Z]]}if(V>z&&(R&w)!==T){if(j===0)j=z;L+=H,D=V-j,M=1<<D;while(D+j<$){if(M-=x[D+j],M<=0)break;D++,M<<=1}if(A+=1<<D,J===XJ&&A>SQ||J===EQ&&A>vQ)return 1;T=R&w,W[T]=z<<24|D<<16|L-X|0}}if(R!==0)W[L+R]=V-j<<24|64<<16|0;return U.bits=z,0},b8=H6,j6=0,F9=1,S9=2,{Z_FINISH:yQ,Z_BLOCK:M6,Z_TREES:M1,Z_OK:J8,Z_STREAM_END:P6,Z_NEED_DICT:N6,Z_STREAM_ERROR:$0,Z_DATA_ERROR:v9,Z_MEM_ERROR:g9,Z_BUF_ERROR:C6,Z_DEFLATED:fQ}=Q8,R1=16180,bQ=16181,hQ=16182,mQ=16183,uQ=16184,_Q=16185,cQ=16186,pQ=16187,lQ=16188,dQ=16189,O1=16190,I0=16191,YJ=16192,iQ=16193,UJ=16194,rQ=16195,oQ=16196,nQ=16197,aQ=16198,P1=16199,N1=16200,sQ=16201,tQ=16202,eQ=16203,J9=16204,Q9=16205,VJ=16206,G9=16207,q9=16208,p=16209,E9=16210,y9=16211,D6=852,B6=592,O6=15,L6=O6,W9=(J)=>{return(J>>>24&255)+(J>>>8&65280)+((J&65280)<<8)+((J&255)<<24)},G8=(J)=>{if(!J)return 1;const G=J.state;if(!G||G.strm!==J||G.mode<R1||G.mode>y9)return 1;return 0},f9=(J)=>{if(G8(J))return $0;const G=J.state;if(J.total_in=J.total_out=G.total=0,J.msg="",G.wrap)J.adler=G.wrap&1;return G.mode=R1,G.last=0,G.havedict=0,G.flags=-1,G.dmax=32768,G.head=null,G.hold=0,G.bits=0,G.lencode=G.lendyn=new Int32Array(D6),G.distcode=G.distdyn=new Int32Array(B6),G.sane=1,G.back=-1,J8},b9=(J)=>{if(G8(J))return $0;const G=J.state;return G.wsize=0,G.whave=0,G.wnext=0,f9(J)},h9=(J,G)=>{let Q;if(G8(J))return $0;const q=J.state;if(G<0)Q=0,G=-G;else if(Q=(G>>4)+5,G<48)G&=15;if(G&&(G<8||G>15))return $0;if(q.window!==null&&q.wbits!==G)q.window=null;return q.wrap=Q,q.wbits=G,b9(J)},m9=(J,G)=>{if(!J)return $0;const Q=new A6;J.state=Q,Q.strm=J,Q.window=null,Q.mode=R1;const q=h9(J,G);if(q!==J8)J.state=null;return q},R6=(J)=>{return m9(J,L6)},X9=!0,KJ,ZJ,k6=(J)=>{if(X9){KJ=new Int32Array(512),ZJ=new Int32Array(32);let G=0;while(G<144)J.lens[G++]=8;while(G<256)J.lens[G++]=9;while(G<280)J.lens[G++]=7;while(G<288)J.lens[G++]=8;b8(F9,J.lens,0,288,KJ,0,J.work,{bits:9}),G=0;while(G<32)J.lens[G++]=5;b8(S9,J.lens,0,32,ZJ,0,J.work,{bits:5}),X9=!1}J.lencode=KJ,J.lenbits=9,J.distcode=ZJ,J.distbits=5},u9=(J,G,Q,q)=>{let W;const X=J.state;if(X.window===null)X.wsize=1<<X.wbits,X.wnext=0,X.whave=0,X.window=new Uint8Array(X.wsize);if(q>=X.wsize)X.window.set(G.subarray(Q-X.wsize,Q),0),X.wnext=0,X.whave=X.wsize;else{if(W=X.wsize-X.wnext,W>q)W=q;if(X.window.set(G.subarray(Q-q,Q-q+W),X.wnext),q-=W,q)X.window.set(G.subarray(Q-q,Q),0),X.wnext=q,X.whave=X.wsize;else{if(X.wnext+=W,X.wnext===X.wsize)X.wnext=0;if(X.whave<X.wsize)X.whave+=W}}return 0},I6=(J,G)=>{let Q,q,W,X,Y,U,K,V,Z,H,$,z,D,j,M=0,A,R,k,N,T,w,L,I;const E=new Uint8Array(4);let x,S;const B=new Uint8Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]);if(G8(J)||!J.output||!J.input&&J.avail_in!==0)return $0;if(Q=J.state,Q.mode===I0)Q.mode=YJ;Y=J.next_out,W=J.output,K=J.avail_out,X=J.next_in,q=J.input,U=J.avail_in,V=Q.hold,Z=Q.bits,H=U,$=K,I=J8;J:for(;;)switch(Q.mode){case R1:if(Q.wrap===0){Q.mode=YJ;break}while(Z<16){if(U===0)break J;U--,V+=q[X++]<<Z,Z+=8}if(Q.wrap&2&&V===35615){if(Q.wbits===0)Q.wbits=15;Q.check=0,E[0]=V&255,E[1]=V>>>8&255,Q.check=t(Q.check,E,2,0),V=0,Z=0,Q.mode=bQ;break}if(Q.head)Q.head.done=!1;if(!(Q.wrap&1)||(((V&255)<<8)+(V>>8))%31){J.msg="incorrect header check",Q.mode=p;break}if((V&15)!==fQ){J.msg="unknown compression method",Q.mode=p;break}if(V>>>=4,Z-=4,L=(V&15)+8,Q.wbits===0)Q.wbits=L;if(L>15||L>Q.wbits){J.msg="invalid window size",Q.mode=p;break}Q.dmax=1<<Q.wbits,Q.flags=0,J.adler=Q.check=1,Q.mode=V&512?dQ:I0,V=0,Z=0;break;case bQ:while(Z<16){if(U===0)break J;U--,V+=q[X++]<<Z,Z+=8}if(Q.flags=V,(Q.flags&255)!==fQ){J.msg="unknown compression method",Q.mode=p;break}if(Q.flags&57344){J.msg="unknown header flags set",Q.mode=p;break}if(Q.head)Q.head.text=V>>8&1;if(Q.flags&512&&Q.wrap&4)E[0]=V&255,E[1]=V>>>8&255,Q.check=t(Q.check,E,2,0);V=0,Z=0,Q.mode=hQ;case hQ:while(Z<32){if(U===0)break J;U--,V+=q[X++]<<Z,Z+=8}if(Q.head)Q.head.time=V;if(Q.flags&512&&Q.wrap&4)E[0]=V&255,E[1]=V>>>8&255,E[2]=V>>>16&255,E[3]=V>>>24&255,Q.check=t(Q.check,E,4,0);V=0,Z=0,Q.mode=mQ;case mQ:while(Z<16){if(U===0)break J;U--,V+=q[X++]<<Z,Z+=8}if(Q.head)Q.head.xflags=V&255,Q.head.os=V>>8;if(Q.flags&512&&Q.wrap&4)E[0]=V&255,E[1]=V>>>8&255,Q.check=t(Q.check,E,2,0);V=0,Z=0,Q.mode=uQ;case uQ:if(Q.flags&1024){while(Z<16){if(U===0)break J;U--,V+=q[X++]<<Z,Z+=8}if(Q.length=V,Q.head)Q.head.extra_len=V;if(Q.flags&512&&Q.wrap&4)E[0]=V&255,E[1]=V>>>8&255,Q.check=t(Q.check,E,2,0);V=0,Z=0}else if(Q.head)Q.head.extra=null;Q.mode=_Q;case _Q:if(Q.flags&1024){if(z=Q.length,z>U)z=U;if(z){if(Q.head){if(L=Q.head.extra_len-Q.length,!Q.head.extra)Q.head.extra=new Uint8Array(Q.head.extra_len);Q.head.extra.set(q.subarray(X,X+z),L)}if(Q.flags&512&&Q.wrap&4)Q.check=t(Q.check,q,z,X);U-=z,X+=z,Q.length-=z}if(Q.length)break J}Q.length=0,Q.mode=cQ;case cQ:if(Q.flags&2048){if(U===0)break J;z=0;do if(L=q[X+z++],Q.head&&L&&Q.length<65536)Q.head.name+=String.fromCharCode(L);while(L&&z<U);if(Q.flags&512&&Q.wrap&4)Q.check=t(Q.check,q,z,X);if(U-=z,X+=z,L)break J}else if(Q.head)Q.head.name=null;Q.length=0,Q.mode=pQ;case pQ:if(Q.flags&4096){if(U===0)break J;z=0;do if(L=q[X+z++],Q.head&&L&&Q.length<65536)Q.head.comment+=String.fromCharCode(L);while(L&&z<U);if(Q.flags&512&&Q.wrap&4)Q.check=t(Q.check,q,z,X);if(U-=z,X+=z,L)break J}else if(Q.head)Q.head.comment=null;Q.mode=lQ;case lQ:if(Q.flags&512){while(Z<16){if(U===0)break J;U--,V+=q[X++]<<Z,Z+=8}if(Q.wrap&4&&V!==(Q.check&65535)){J.msg="header crc mismatch",Q.mode=p;break}V=0,Z=0}if(Q.head)Q.head.hcrc=Q.flags>>9&1,Q.head.done=!0;J.adler=Q.check=0,Q.mode=I0;break;case dQ:while(Z<32){if(U===0)break J;U--,V+=q[X++]<<Z,Z+=8}J.adler=Q.check=W9(V),V=0,Z=0,Q.mode=O1;case O1:if(Q.havedict===0)return J.next_out=Y,J.avail_out=K,J.next_in=X,J.avail_in=U,Q.hold=V,Q.bits=Z,N6;J.adler=Q.check=1,Q.mode=I0;case I0:if(G===M6||G===M1)break J;case YJ:if(Q.last){V>>>=Z&7,Z-=Z&7,Q.mode=VJ;break}while(Z<3){if(U===0)break J;U--,V+=q[X++]<<Z,Z+=8}switch(Q.last=V&1,V>>>=1,Z-=1,V&3){case 0:Q.mode=iQ;break;case 1:if(k6(Q),Q.mode=P1,G===M1){V>>>=2,Z-=2;break J}break;case 2:Q.mode=oQ;break;case 3:J.msg="invalid block type",Q.mode=p}V>>>=2,Z-=2;break;case iQ:V>>>=Z&7,Z-=Z&7;while(Z<32){if(U===0)break J;U--,V+=q[X++]<<Z,Z+=8}if((V&65535)!==(V>>>16^65535)){J.msg="invalid stored block lengths",Q.mode=p;break}if(Q.length=V&65535,V=0,Z=0,Q.mode=UJ,G===M1)break J;case UJ:Q.mode=rQ;case rQ:if(z=Q.length,z){if(z>U)z=U;if(z>K)z=K;if(z===0)break J;W.set(q.subarray(X,X+z),Y),U-=z,X+=z,K-=z,Y+=z,Q.length-=z;break}Q.mode=I0;break;case oQ:while(Z<14){if(U===0)break J;U--,V+=q[X++]<<Z,Z+=8}if(Q.nlen=(V&31)+257,V>>>=5,Z-=5,Q.ndist=(V&31)+1,V>>>=5,Z-=5,Q.ncode=(V&15)+4,V>>>=4,Z-=4,Q.nlen>286||Q.ndist>30){J.msg="too many length or distance symbols",Q.mode=p;break}Q.have=0,Q.mode=nQ;case nQ:while(Q.have<Q.ncode){while(Z<3){if(U===0)break J;U--,V+=q[X++]<<Z,Z+=8}Q.lens[B[Q.have++]]=V&7,V>>>=3,Z-=3}while(Q.have<19)Q.lens[B[Q.have++]]=0;if(Q.lencode=Q.lendyn,Q.lenbits=7,x={bits:Q.lenbits},I=b8(j6,Q.lens,0,19,Q.lencode,0,Q.work,x),Q.lenbits=x.bits,I){J.msg="invalid code lengths set",Q.mode=p;break}Q.have=0,Q.mode=aQ;case aQ:while(Q.have<Q.nlen+Q.ndist){for(;;){if(M=Q.lencode[V&(1<<Q.lenbits)-1],A=M>>>24,R=M>>>16&255,k=M&65535,A<=Z)break;if(U===0)break J;U--,V+=q[X++]<<Z,Z+=8}if(k<16)V>>>=A,Z-=A,Q.lens[Q.have++]=k;else{if(k===16){S=A+2;while(Z<S){if(U===0)break J;U--,V+=q[X++]<<Z,Z+=8}if(V>>>=A,Z-=A,Q.have===0){J.msg="invalid bit length repeat",Q.mode=p;break}L=Q.lens[Q.have-1],z=3+(V&3),V>>>=2,Z-=2}else if(k===17){S=A+3;while(Z<S){if(U===0)break J;U--,V+=q[X++]<<Z,Z+=8}V>>>=A,Z-=A,L=0,z=3+(V&7),V>>>=3,Z-=3}else{S=A+7;while(Z<S){if(U===0)break J;U--,V+=q[X++]<<Z,Z+=8}V>>>=A,Z-=A,L=0,z=11+(V&127),V>>>=7,Z-=7}if(Q.have+z>Q.nlen+Q.ndist){J.msg="invalid bit length repeat",Q.mode=p;break}while(z--)Q.lens[Q.have++]=L}}if(Q.mode===p)break;if(Q.lens[256]===0){J.msg="invalid code -- missing end-of-block",Q.mode=p;break}if(Q.lenbits=9,x={bits:Q.lenbits},I=b8(F9,Q.lens,0,Q.nlen,Q.lencode,0,Q.work,x),Q.lenbits=x.bits,I){J.msg="invalid literal/lengths set",Q.mode=p;break}if(Q.distbits=6,Q.distcode=Q.distdyn,x={bits:Q.distbits},I=b8(S9,Q.lens,Q.nlen,Q.ndist,Q.distcode,0,Q.work,x),Q.distbits=x.bits,I){J.msg="invalid distances set",Q.mode=p;break}if(Q.mode=P1,G===M1)break J;case P1:Q.mode=N1;case N1:if(U>=6&&K>=258){if(J.next_out=Y,J.avail_out=K,J.next_in=X,J.avail_in=U,Q.hold=V,Q.bits=Z,V6(J,$),Y=J.next_out,W=J.output,K=J.avail_out,X=J.next_in,q=J.input,U=J.avail_in,V=Q.hold,Z=Q.bits,Q.mode===I0)Q.back=-1;break}Q.back=0;for(;;){if(M=Q.lencode[V&(1<<Q.lenbits)-1],A=M>>>24,R=M>>>16&255,k=M&65535,A<=Z)break;if(U===0)break J;U--,V+=q[X++]<<Z,Z+=8}if(R&&(R&240)===0){N=A,T=R,w=k;for(;;){if(M=Q.lencode[w+((V&(1<<N+T)-1)>>N)],A=M>>>24,R=M>>>16&255,k=M&65535,N+A<=Z)break;if(U===0)break J;U--,V+=q[X++]<<Z,Z+=8}V>>>=N,Z-=N,Q.back+=N}if(V>>>=A,Z-=A,Q.back+=A,Q.length=k,R===0){Q.mode=Q9;break}if(R&32){Q.back=-1,Q.mode=I0;break}if(R&64){J.msg="invalid literal/length code",Q.mode=p;break}Q.extra=R&15,Q.mode=sQ;case sQ:if(Q.extra){S=Q.extra;while(Z<S){if(U===0)break J;U--,V+=q[X++]<<Z,Z+=8}Q.length+=V&(1<<Q.extra)-1,V>>>=Q.extra,Z-=Q.extra,Q.back+=Q.extra}Q.was=Q.length,Q.mode=tQ;case tQ:for(;;){if(M=Q.distcode[V&(1<<Q.distbits)-1],A=M>>>24,R=M>>>16&255,k=M&65535,A<=Z)break;if(U===0)break J;U--,V+=q[X++]<<Z,Z+=8}if((R&240)===0){N=A,T=R,w=k;for(;;){if(M=Q.distcode[w+((V&(1<<N+T)-1)>>N)],A=M>>>24,R=M>>>16&255,k=M&65535,N+A<=Z)break;if(U===0)break J;U--,V+=q[X++]<<Z,Z+=8}V>>>=N,Z-=N,Q.back+=N}if(V>>>=A,Z-=A,Q.back+=A,R&64){J.msg="invalid distance code",Q.mode=p;break}Q.offset=k,Q.extra=R&15,Q.mode=eQ;case eQ:if(Q.extra){S=Q.extra;while(Z<S){if(U===0)break J;U--,V+=q[X++]<<Z,Z+=8}Q.offset+=V&(1<<Q.extra)-1,V>>>=Q.extra,Z-=Q.extra,Q.back+=Q.extra}if(Q.offset>Q.dmax){J.msg="invalid distance too far back",Q.mode=p;break}Q.mode=J9;case J9:if(K===0)break J;if(z=$-K,Q.offset>z){if(z=Q.offset-z,z>Q.whave){if(Q.sane){J.msg="invalid distance too far back",Q.mode=p;break}}if(z>Q.wnext)z-=Q.wnext,D=Q.wsize-z;else D=Q.wnext-z;if(z>Q.length)z=Q.length;j=Q.window}else j=W,D=Y-Q.offset,z=Q.length;if(z>K)z=K;K-=z,Q.length-=z;do W[Y++]=j[D++];while(--z);if(Q.length===0)Q.mode=N1;break;case Q9:if(K===0)break J;W[Y++]=Q.length,K--,Q.mode=N1;break;case VJ:if(Q.wrap){while(Z<32){if(U===0)break J;U--,V|=q[X++]<<Z,Z+=8}if($-=K,J.total_out+=$,Q.total+=$,Q.wrap&4&&$)J.adler=Q.check=Q.flags?t(Q.check,W,$,Y-$):c8(Q.check,W,$,Y-$);if($=K,Q.wrap&4&&(Q.flags?V:W9(V))!==Q.check){J.msg="incorrect data check",Q.mode=p;break}V=0,Z=0}Q.mode=G9;case G9:if(Q.wrap&&Q.flags){while(Z<32){if(U===0)break J;U--,V+=q[X++]<<Z,Z+=8}if(Q.wrap&4&&V!==(Q.total&4294967295)){J.msg="incorrect length check",Q.mode=p;break}V=0,Z=0}Q.mode=q9;case q9:I=P6;break J;case p:I=v9;break J;case E9:return g9;case y9:default:return $0}if(J.next_out=Y,J.avail_out=K,J.next_in=X,J.avail_in=U,Q.hold=V,Q.bits=Z,Q.wsize||$!==J.avail_out&&Q.mode<p&&(Q.mode<VJ||G!==yQ)){if(u9(J,J.output,J.next_out,$-J.avail_out));}if(H-=J.avail_in,$-=J.avail_out,J.total_in+=H,J.total_out+=$,Q.total+=$,Q.wrap&4&&$)J.adler=Q.check=Q.flags?t(Q.check,W,$,J.next_out-$):c8(Q.check,W,$,J.next_out-$);if(J.data_type=Q.bits+(Q.last?64:0)+(Q.mode===I0?128:0)+(Q.mode===P1||Q.mode===UJ?256:0),(H===0&&$===0||G===yQ)&&I===J8)I=C6;return I},x6=(J)=>{if(G8(J))return $0;let G=J.state;if(G.window)G.window=null;return J.state=null,J8},w6=(J,G)=>{if(G8(J))return $0;const Q=J.state;if((Q.wrap&2)===0)return $0;return Q.head=G,G.done=!1,J8},T6=(J,G)=>{const Q=G.length;let q,W,X;if(G8(J))return $0;if(q=J.state,q.wrap!==0&&q.mode!==O1)return $0;if(q.mode===O1){if(W=1,W=c8(W,G,Q,0),W!==q.check)return v9}if(X=u9(J,G,Q,Q),X)return q.mode=E9,g9;return q.havedict=1,J8},F6=b9,S6=h9,v6=f9,g6=R6,E6=m9,y6=I6,f6=x6,b6=w6,h6=T6,m6="pako inflate (from Nodeca project)",w0={inflateReset:F6,inflateReset2:S6,inflateResetKeep:v6,inflateInit:g6,inflateInit2:E6,inflate:y6,inflateEnd:f6,inflateGetHeader:b6,inflateSetDictionary:h6,inflateInfo:m6},_6=u6,_9=Object.prototype.toString,{Z_NO_FLUSH:c6,Z_FINISH:p6,Z_OK:d8,Z_STREAM_END:zJ,Z_NEED_DICT:$J,Z_STREAM_ERROR:l6,Z_DATA_ERROR:Y9,Z_MEM_ERROR:d6}=Q8;n8.prototype.push=function(J,G){const Q=this.strm,q=this.options.chunkSize,W=this.options.dictionary;let X,Y,U;if(this.ended)return!1;if(G===~~G)Y=G;else Y=G===!0?p6:c6;if(_9.call(J)==="[object ArrayBuffer]")Q.input=new Uint8Array(J);else Q.input=J;Q.next_in=0,Q.avail_in=Q.input.length;for(;;){if(Q.avail_out===0)Q.output=new Uint8Array(q),Q.next_out=0,Q.avail_out=q;if(X=w0.inflate(Q,Y),X===$J&&W){if(X=w0.inflateSetDictionary(Q,W),X===d8)X=w0.inflate(Q,Y);else if(X===Y9)X=$J}while(Q.avail_in>0&&X===zJ&&Q.state.wrap>0&&J[Q.next_in]!==0)w0.inflateReset(Q),X=w0.inflate(Q,Y);switch(X){case l6:case Y9:case $J:case d6:return this.onEnd(X),this.ended=!0,!1}if(U=Q.avail_out,Q.next_out){if(Q.avail_out===0||X===zJ)if(this.options.to==="string"){let K=l8.utf8border(Q.output,Q.next_out),V=Q.next_out-K,Z=l8.buf2string(Q.output,K);if(Q.next_out=V,Q.avail_out=q-V,V)Q.output.set(Q.output.subarray(K,K+V),0);this.onData(Z)}else this.onData(Q.output.length===Q.next_out?Q.output:Q.output.subarray(0,Q.next_out))}if(X===d8&&U===0)continue;if(X===zJ)return X=w0.inflateEnd(this.strm),this.onEnd(X),this.ended=!0,!0;if(Q.avail_in===0)break}return!0};n8.prototype.onData=function(J){this.chunks.push(J)};n8.prototype.onEnd=function(J){if(J===d8)if(this.options.to==="string")this.result=this.chunks.join("");else this.result=A1.flattenChunks(this.chunks);this.chunks=[],this.err=J,this.msg=this.strm.msg};var r6=n8,o6=wJ,n6=i6,a6=wJ,s6=Q8,t6={Inflate:r6,inflate:o6,inflateRaw:n6,ungzip:a6,constants:s6},{Deflate:e6,deflate:J7,deflateRaw:Q7,gzip:G7}=Y6,{Inflate:q7,inflate:W7,inflateRaw:X7,ungzip:Y7}=t6,U7=e6,V7=J7,K7=Q7,Z7=G7,z7=q7,$7=W7,H7=X7,j7=Y7,M7=Q8,TJ={Deflate:U7,deflate:V7,deflateRaw:K7,gzip:Z7,Inflate:z7,inflate:$7,inflateRaw:H7,ungzip:j7,constants:M7};var c9=function(J){if(!Number.isSafeInteger(J)||J<0)throw new Error("positive integer expected, got "+J)},P7=function(J){return J instanceof Uint8Array||ArrayBuffer.isView(J)&&J.constructor.name==="Uint8Array"},A8=function(J,...G){if(!P7(J))throw new Error("Uint8Array expected");if(G.length>0&&!G.includes(J.length))throw new Error("Uint8Array expected of length "+G+", got length="+J.length)},p9=function(J){if(typeof J!=="function"||typeof J.create!=="function")throw new Error("Hash should be wrapped by utils.wrapConstructor");c9(J.outputLen),c9(J.blockLen)},R8=function(J,G=!0){if(J.destroyed)throw new Error("Hash instance has been destroyed");if(G&&J.finished)throw new Error("Hash#digest() has already been called")},l9=function(J,G){A8(J);const Q=G.outputLen;if(J.length<Q)throw new Error("digestInto() expects output buffer of length at least "+Q)};var q8=typeof globalThis==="object"&&("crypto"in globalThis)?globalThis.crypto:void 0;function k1(J){return new DataView(J.buffer,J.byteOffset,J.byteLength)}function M0(J,G){return J<<32-G|J>>>G}function N7(J){if(typeof J!=="string")throw new Error("utf8ToBytes expected string, got "+typeof J);return new Uint8Array((new TextEncoder()).encode(J))}function a8(J){if(typeof J==="string")J=N7(J);return A8(J),J}function d9(...J){let G=0;for(let q=0;q<J.length;q++){const W=J[q];A8(W),G+=W.length}const Q=new Uint8Array(G);for(let q=0,W=0;q<J.length;q++){const X=J[q];Q.set(X,W),W+=X.length}return Q}function i9(J){const G=(q)=>J().update(a8(q)).digest(),Q=J();return G.outputLen=Q.outputLen,G.blockLen=Q.blockLen,G.create=()=>J(),G}function I1(J=32){if(q8&&typeof q8.getRandomValues==="function")return q8.getRandomValues(new Uint8Array(J));if(q8&&typeof q8.randomBytes==="function")return q8.randomBytes(J);throw new Error("crypto.getRandomValues must be defined")}/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */class s8{clone(){return this._cloneInto()}}function C7(J,G,Q,q){if(typeof J.setBigUint64==="function")return J.setBigUint64(G,Q,q);const W=BigInt(32),X=BigInt(4294967295),Y=Number(Q>>W&X),U=Number(Q&X),K=q?4:0,V=q?0:4;J.setUint32(G+K,Y,q),J.setUint32(G+V,U,q)}function r9(J,G,Q){return J&G^~J&Q}function o9(J,G,Q){return J&G^J&Q^G&Q}class FJ extends s8{constructor(J,G,Q,q){super();this.blockLen=J,this.outputLen=G,this.padOffset=Q,this.isLE=q,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(J),this.view=k1(this.buffer)}update(J){R8(this);const{view:G,buffer:Q,blockLen:q}=this;J=a8(J);const W=J.length;for(let X=0;X<W;){const Y=Math.min(q-this.pos,W-X);if(Y===q){const U=k1(J);for(;q<=W-X;X+=q)this.process(U,X);continue}if(Q.set(J.subarray(X,X+Y),this.pos),this.pos+=Y,X+=Y,this.pos===q)this.process(G,0),this.pos=0}return this.length+=J.length,this.roundClean(),this}digestInto(J){R8(this),l9(J,this),this.finished=!0;const{buffer:G,view:Q,blockLen:q,isLE:W}=this;let{pos:X}=this;if(G[X++]=128,this.buffer.subarray(X).fill(0),this.padOffset>q-X)this.process(Q,0),X=0;for(let Z=X;Z<q;Z++)G[Z]=0;C7(Q,q-8,BigInt(this.length*8),W),this.process(Q,0);const Y=k1(J),U=this.outputLen;if(U%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const K=U/4,V=this.get();if(K>V.length)throw new Error("_sha2: outputLen bigger than state");for(let Z=0;Z<K;Z++)Y.setUint32(4*Z,V[Z],W)}digest(){const{buffer:J,outputLen:G}=this;this.digestInto(J);const Q=J.slice(0,G);return this.destroy(),Q}_cloneInto(J){J||(J=new this.constructor),J.set(...this.get());const{blockLen:G,buffer:Q,length:q,finished:W,destroyed:X,pos:Y}=this;if(J.length=q,J.pos=Y,J.finished=W,J.destroyed=X,q%G)J.buffer.set(Q);return J}}var D7=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),u0=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),_0=new Uint32Array(64);class n9 extends FJ{constructor(){super(64,32,8,!1);this.A=u0[0]|0,this.B=u0[1]|0,this.C=u0[2]|0,this.D=u0[3]|0,this.E=u0[4]|0,this.F=u0[5]|0,this.G=u0[6]|0,this.H=u0[7]|0}get(){const{A:J,B:G,C:Q,D:q,E:W,F:X,G:Y,H:U}=this;return[J,G,Q,q,W,X,Y,U]}set(J,G,Q,q,W,X,Y,U){this.A=J|0,this.B=G|0,this.C=Q|0,this.D=q|0,this.E=W|0,this.F=X|0,this.G=Y|0,this.H=U|0}process(J,G){for(let Z=0;Z<16;Z++,G+=4)_0[Z]=J.getUint32(G,!1);for(let Z=16;Z<64;Z++){const H=_0[Z-15],$=_0[Z-2],z=M0(H,7)^M0(H,18)^H>>>3,D=M0($,17)^M0($,19)^$>>>10;_0[Z]=D+_0[Z-7]+z+_0[Z-16]|0}let{A:Q,B:q,C:W,D:X,E:Y,F:U,G:K,H:V}=this;for(let Z=0;Z<64;Z++){const H=M0(Y,6)^M0(Y,11)^M0(Y,25),$=V+H+r9(Y,U,K)+D7[Z]+_0[Z]|0,D=(M0(Q,2)^M0(Q,13)^M0(Q,22))+o9(Q,q,W)|0;V=K,K=U,U=Y,Y=X+$|0,X=W,W=q,q=Q,Q=$+D|0}Q=Q+this.A|0,q=q+this.B|0,W=W+this.C|0,X=X+this.D|0,Y=Y+this.E|0,U=U+this.F|0,K=K+this.G|0,V=V+this.H|0,this.set(Q,q,W,X,Y,U,K,V)}roundClean(){_0.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}}var x1=i9(()=>new n9);class SJ extends s8{constructor(J,G){super();this.finished=!1,this.destroyed=!1,p9(J);const Q=a8(G);if(this.iHash=J.create(),typeof this.iHash.update!=="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const q=this.blockLen,W=new Uint8Array(q);W.set(Q.length>q?J.create().update(Q).digest():Q);for(let X=0;X<W.length;X++)W[X]^=54;this.iHash.update(W),this.oHash=J.create();for(let X=0;X<W.length;X++)W[X]^=54^92;this.oHash.update(W),W.fill(0)}update(J){return R8(this),this.iHash.update(J),this}digestInto(J){R8(this),A8(J,this.outputLen),this.finished=!0,this.iHash.digestInto(J),this.oHash.update(J),this.oHash.digestInto(J),this.destroy()}digest(){const J=new Uint8Array(this.oHash.outputLen);return this.digestInto(J),J}_cloneInto(J){J||(J=Object.create(Object.getPrototypeOf(this),{}));const{oHash:G,iHash:Q,finished:q,destroyed:W,blockLen:X,outputLen:Y}=this;return J=J,J.finished=q,J.destroyed=W,J.blockLen=X,J.outputLen=Y,J.oHash=G._cloneInto(J.oHash),J.iHash=Q._cloneInto(J.iHash),J}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}var vJ=(J,G,Q)=>new SJ(J,G).update(Q).digest();vJ.create=(J,G)=>new SJ(J,G);var hJ={};a5(hJ,{validateObject:()=>{{return l0}},utf8ToBytes:()=>{{return R7}},numberToVarBytesBE:()=>{{return L7}},numberToHexUnpadded:()=>{{return Y8}},numberToBytesLE:()=>{{return S1}},numberToBytesBE:()=>{{return P0}},notImplemented:()=>{{return w7}},memoized:()=>{{return v1}},isBytes:()=>{{return c0}},inRange:()=>{{return p0}},hexToNumber:()=>{{return yJ}},hexToBytes:()=>{{return U8}},equalBytes:()=>{{return A7}},ensureBytes:()=>{{return n}},createHmacDrbg:()=>{{return bJ}},concatBytes:()=>{{return F0}},bytesToNumberLE:()=>{{return F1}},bytesToNumberBE:()=>{{return H0}},bytesToHex:()=>{{return X8}},bitSet:()=>{{return I7}},bitMask:()=>{{return t8}},bitLen:()=>{{return fJ}},bitGet:()=>{{return k7}},abytes:()=>{{return k8}},abool:()=>{{return W8}},aInRange:()=>{{return L0}}});function c0(J){return J instanceof Uint8Array||ArrayBuffer.isView(J)&&J.constructor.name==="Uint8Array"}function k8(J){if(!c0(J))throw new Error("Uint8Array expected")}function W8(J,G){if(typeof G!=="boolean")throw new Error(J+" boolean expected, got "+G)}function X8(J){k8(J);let G="";for(let Q=0;Q<J.length;Q++)G+=O7[J[Q]];return G}function Y8(J){const G=J.toString(16);return G.length&1?"0"+G:G}function yJ(J){if(typeof J!=="string")throw new Error("hex string expected, got "+typeof J);return J===""?w1:BigInt("0x"+J)}var a9=function(J){if(J>=T0._0&&J<=T0._9)return J-T0._0;if(J>=T0.A&&J<=T0.F)return J-(T0.A-10);if(J>=T0.a&&J<=T0.f)return J-(T0.a-10);return};function U8(J){if(typeof J!=="string")throw new Error("hex string expected, got "+typeof J);const G=J.length,Q=G/2;if(G%2)throw new Error("hex string expected, got unpadded hex of length "+G);const q=new Uint8Array(Q);for(let W=0,X=0;W<Q;W++,X+=2){const Y=a9(J.charCodeAt(X)),U=a9(J.charCodeAt(X+1));if(Y===void 0||U===void 0){const K=J[X]+J[X+1];throw new Error('hex string expected, got non-hex character "'+K+'" at index '+X)}q[W]=Y*16+U}return q}function H0(J){return yJ(X8(J))}function F1(J){return k8(J),yJ(X8(Uint8Array.from(J).reverse()))}function P0(J,G){return U8(J.toString(16).padStart(G*2,"0"))}function S1(J,G){return P0(J,G).reverse()}function L7(J){return U8(Y8(J))}function n(J,G,Q){let q;if(typeof G==="string")try{q=U8(G)}catch(X){throw new Error(J+" must be hex string or Uint8Array, cause: "+X)}else if(c0(G))q=Uint8Array.from(G);else throw new Error(J+" must be hex string or Uint8Array");const W=q.length;if(typeof Q==="number"&&W!==Q)throw new Error(J+" of length "+Q+" expected, got "+W);return q}function F0(...J){let G=0;for(let q=0;q<J.length;q++){const W=J[q];k8(W),G+=W.length}const Q=new Uint8Array(G);for(let q=0,W=0;q<J.length;q++){const X=J[q];Q.set(X,W),W+=X.length}return Q}function A7(J,G){if(J.length!==G.length)return!1;let Q=0;for(let q=0;q<J.length;q++)Q|=J[q]^G[q];return Q===0}function R7(J){if(typeof J!=="string")throw new Error("string expected");return new Uint8Array((new TextEncoder()).encode(J))}function p0(J,G,Q){return gJ(J)&&gJ(G)&&gJ(Q)&&G<=J&&J<Q}function L0(J,G,Q,q){if(!p0(G,Q,q))throw new Error("expected valid "+J+": "+Q+" <= n < "+q+", got "+G)}function fJ(J){let G;for(G=0;J>w1;J>>=T1,G+=1);return G}function k7(J,G){return J>>BigInt(G)&T1}function I7(J,G,Q){return J|(Q?T1:w1)<<BigInt(G)}function bJ(J,G,Q){if(typeof J!=="number"||J<2)throw new Error("hashLen must be a number");if(typeof G!=="number"||G<2)throw new Error("qByteLen must be a number");if(typeof Q!=="function")throw new Error("hmacFn must be a function");let q=EJ(J),W=EJ(J),X=0;const Y=()=>{q.fill(1),W.fill(0),X=0},U=(...H)=>Q(W,q,...H),K=(H=EJ())=>{if(W=U(s9([0]),H),q=U(),H.length===0)return;W=U(s9([1]),H),q=U()},V=()=>{if(X++>=1000)throw new Error("drbg: tried 1000 values");let H=0;const $=[];while(H<G){q=U();const z=q.slice();$.push(z),H+=q.length}return F0(...$)};return(H,$)=>{Y(),K(H);let z=void 0;while(!(z=$(V())))K();return Y(),z}}function l0(J,G,Q={}){const q=(W,X,Y)=>{const U=x7[X];if(typeof U!=="function")throw new Error("invalid validator function");const K=J[W];if(Y&&K===void 0)return;if(!U(K,J))throw new Error("param "+String(W)+" is invalid. Expected "+X+", got "+K)};for(let[W,X]of Object.entries(G))q(W,X,!1);for(let[W,X]of Object.entries(Q))q(W,X,!0);return J}function v1(J){const G=new WeakMap;return(Q,...q)=>{const W=G.get(Q);if(W!==void 0)return W;const X=J(Q,...q);return G.set(Q,X),X}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */var w1=BigInt(0),T1=BigInt(1),B7=BigInt(2),O7=Array.from({length:256},(J,G)=>G.toString(16).padStart(2,"0")),T0={_0:48,_9:57,A:65,F:70,a:97,f:102},gJ=(J)=>typeof J==="bigint"&&w1<=J,t8=(J)=>(B7<<BigInt(J-1))-T1,EJ=(J)=>new Uint8Array(J),s9=(J)=>Uint8Array.from(J),x7={bigint:(J)=>typeof J==="bigint",function:(J)=>typeof J==="function",boolean:(J)=>typeof J==="boolean",string:(J)=>typeof J==="string",stringOrUint8Array:(J)=>typeof J==="string"||c0(J),isSafeInteger:(J)=>Number.isSafeInteger(J),array:(J)=>Array.isArray(J),field:(J,G)=>G.Fp.isValid(J),hash:(J)=>typeof J==="function"&&Number.isSafeInteger(J.outputLen)},w7=()=>{throw new Error("not implemented")};function a(J,G){const Q=J%G;return Q>=s?Q:G+Q}function v7(J,G,Q){if(G<s)throw new Error("invalid exponent, negatives unsupported");if(Q<=s)throw new Error("invalid modulus");if(Q===d)return s;let q=d;while(G>s){if(G&d)q=q*J%Q;J=J*J%Q,G>>=d}return q}function Z0(J,G,Q){let q=J;while(G-- >s)q*=q,q%=Q;return q}function g1(J,G){if(J===s)throw new Error("invert: expected non-zero number");if(G<=s)throw new Error("invert: expected positive modulus, got "+G);let Q=a(J,G),q=G,W=s,X=d,Y=d,U=s;while(Q!==s){const V=q/Q,Z=q%Q,H=W-Y*V,$=X-U*V;q=Q,Q=Z,W=Y,X=U,Y=H,U=$}if(q!==d)throw new Error("invert: does not exist");return a(W,G)}function g7(J){const G=(J-d)/V8;let Q,q,W;for(Q=J-d,q=0;Q%V8===s;Q/=V8,q++);for(W=V8;W<J&&v7(W,G,J)!==J-d;W++)if(W>1000)throw new Error("Cannot find square root: likely non-prime P");if(q===1){const Y=(J+d)/mJ;return function U(K,V){const Z=K.pow(V,Y);if(!K.eql(K.sqr(Z),V))throw new Error("Cannot find square root");return Z}}const X=(Q+d)/V8;return function Y(U,K){if(U.pow(K,G)===U.neg(U.ONE))throw new Error("Cannot find square root");let V=q,Z=U.pow(U.mul(U.ONE,W),Q),H=U.pow(K,X),$=U.pow(K,Q);while(!U.eql($,U.ONE)){if(U.eql($,U.ZERO))return U.ZERO;let z=1;for(let j=U.sqr($);z<V;z++){if(U.eql(j,U.ONE))break;j=U.sqr(j)}const D=U.pow(Z,d<<BigInt(V-z-1));Z=U.sqr(D),H=U.mul(H,D),$=U.mul($,Z),V=z}return H}}function E7(J){if(J%mJ===T7){const G=(J+d)/mJ;return function Q(q,W){const X=q.pow(W,G);if(!q.eql(q.sqr(X),W))throw new Error("Cannot find square root");return X}}if(J%e9===t9){const G=(J-t9)/e9;return function Q(q,W){const X=q.mul(W,V8),Y=q.pow(X,G),U=q.mul(W,Y),K=q.mul(q.mul(U,V8),Y),V=q.mul(U,q.sub(K,q.ONE));if(!q.eql(q.sqr(V),W))throw new Error("Cannot find square root");return V}}if(J%S7===F7);return g7(J)}function uJ(J){const G={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},Q=y7.reduce((q,W)=>{return q[W]="function",q},G);return l0(J,Q)}function f7(J,G,Q){if(Q<s)throw new Error("invalid exponent, negatives unsupported");if(Q===s)return J.ONE;if(Q===d)return G;let q=J.ONE,W=G;while(Q>s){if(Q&d)q=J.mul(q,W);W=J.sqr(W),Q>>=d}return q}function b7(J,G){const Q=new Array(G.length),q=G.reduce((X,Y,U)=>{if(J.is0(Y))return X;return Q[U]=X,J.mul(X,Y)},J.ONE),W=J.inv(q);return G.reduceRight((X,Y,U)=>{if(J.is0(Y))return X;return Q[U]=J.mul(X,Q[U]),J.mul(X,Y)},W),Q}function _J(J,G){const Q=G!==void 0?G:J.toString(2).length,q=Math.ceil(Q/8);return{nBitLength:Q,nByteLength:q}}function E1(J,G,Q=!1,q={}){if(J<=s)throw new Error("invalid field: expected ORDER > 0, got "+J);const{nBitLength:W,nByteLength:X}=_J(J,G);if(X>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let Y;const U=Object.freeze({ORDER:J,isLE:Q,BITS:W,BYTES:X,MASK:t8(W),ZERO:s,ONE:d,create:(K)=>a(K,J),isValid:(K)=>{if(typeof K!=="bigint")throw new Error("invalid field element: expected bigint, got "+typeof K);return s<=K&&K<J},is0:(K)=>K===s,isOdd:(K)=>(K&d)===d,neg:(K)=>a(-K,J),eql:(K,V)=>K===V,sqr:(K)=>a(K*K,J),add:(K,V)=>a(K+V,J),sub:(K,V)=>a(K-V,J),mul:(K,V)=>a(K*V,J),pow:(K,V)=>f7(U,K,V),div:(K,V)=>a(K*g1(V,J),J),sqrN:(K)=>K*K,addN:(K,V)=>K+V,subN:(K,V)=>K-V,mulN:(K,V)=>K*V,inv:(K)=>g1(K,J),sqrt:q.sqrt||((K)=>{if(!Y)Y=E7(J);return Y(U,K)}),invertBatch:(K)=>b7(U,K),cmov:(K,V,Z)=>Z?V:K,toBytes:(K)=>Q?S1(K,X):P0(K,X),fromBytes:(K)=>{if(K.length!==X)throw new Error("Field.fromBytes: expected "+X+" bytes, got "+K.length);return Q?F1(K):H0(K)}});return Object.freeze(U)}function J5(J){if(typeof J!=="bigint")throw new Error("field order must be bigint");const G=J.toString(2).length;return Math.ceil(G/8)}function cJ(J){const G=J5(J);return G+Math.ceil(G/2)}function Q5(J,G,Q=!1){const q=J.length,W=J5(G),X=cJ(G);if(q<16||q<X||q>1024)throw new Error("expected "+X+"-1024 bytes of input, got "+q);const Y=Q?F1(J):H0(J),U=a(Y,G-d)+d;return Q?S1(U,W):P0(U,W)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */var s=BigInt(0),d=BigInt(1),V8=BigInt(2),T7=BigInt(3),mJ=BigInt(4),t9=BigInt(5),e9=BigInt(8),F7=BigInt(9),S7=BigInt(16);var y7=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];var pJ=function(J,G){const Q=G.negate();return J?Q:G},q5=function(J,G){if(!Number.isSafeInteger(J)||J<=0||J>G)throw new Error("invalid window size, expected [1.."+G+"], got W="+J)},lJ=function(J,G){q5(J,G);const Q=Math.ceil(G/J)+1,q=2**(J-1);return{windows:Q,windowSize:q}},h7=function(J,G){if(!Array.isArray(J))throw new Error("array expected");J.forEach((Q,q)=>{if(!(Q instanceof G))throw new Error("invalid point at index "+q)})},m7=function(J,G){if(!Array.isArray(J))throw new Error("array of scalars expected");J.forEach((Q,q)=>{if(!G.isValid(Q))throw new Error("invalid scalar at index "+q)})},iJ=function(J){return W5.get(J)||1};function X5(J,G){return{constTimeNegate:pJ,hasPrecomputes(Q){return iJ(Q)!==1},unsafeLadder(Q,q,W=J.ZERO){let X=Q;while(q>G5){if(q&y1)W=W.add(X);X=X.double(),q>>=y1}return W},precomputeWindow(Q,q){const{windows:W,windowSize:X}=lJ(q,G),Y=[];let U=Q,K=U;for(let V=0;V<W;V++){K=U,Y.push(K);for(let Z=1;Z<X;Z++)K=K.add(U),Y.push(K);U=K.double()}return Y},wNAF(Q,q,W){const{windows:X,windowSize:Y}=lJ(Q,G);let{ZERO:U,BASE:K}=J;const V=BigInt(2**Q-1),Z=2**Q,H=BigInt(Q);for(let $=0;$<X;$++){const z=$*Y;let D=Number(W&V);if(W>>=H,D>Y)D-=Z,W+=y1;const j=z,M=z+Math.abs(D)-1,A=$%2!==0,R=D<0;if(D===0)K=K.add(pJ(A,q[j]));else U=U.add(pJ(R,q[M]))}return{p:U,f:K}},wNAFUnsafe(Q,q,W,X=J.ZERO){const{windows:Y,windowSize:U}=lJ(Q,G),K=BigInt(2**Q-1),V=2**Q,Z=BigInt(Q);for(let H=0;H<Y;H++){const $=H*U;if(W===G5)break;let z=Number(W&K);if(W>>=Z,z>U)z-=V,W+=y1;if(z===0)continue;let D=q[$+Math.abs(z)-1];if(z<0)D=D.negate();X=X.add(D)}return X},getPrecomputes(Q,q,W){let X=dJ.get(q);if(!X){if(X=this.precomputeWindow(q,Q),Q!==1)dJ.set(q,W(X))}return X},wNAFCached(Q,q,W){const X=iJ(Q);return this.wNAF(X,this.getPrecomputes(X,Q,W),q)},wNAFCachedUnsafe(Q,q,W,X){const Y=iJ(Q);if(Y===1)return this.unsafeLadder(Q,q,X);return this.wNAFUnsafe(Y,this.getPrecomputes(Y,Q,W),q,X)},setWindowSize(Q,q){q5(q,G),W5.set(Q,q),dJ.delete(Q)}}}function Y5(J,G,Q,q){if(h7(Q,J),m7(q,G),Q.length!==q.length)throw new Error("arrays of points and scalars must have equal length");const W=J.ZERO,X=fJ(BigInt(Q.length)),Y=X>12?X-3:X>4?X-2:X?2:1,U=(1<<Y)-1,K=new Array(U+1).fill(W),V=Math.floor((G.BITS-1)/Y)*Y;let Z=W;for(let H=V;H>=0;H-=Y){K.fill(W);for(let z=0;z<q.length;z++){const D=q[z],j=Number(D>>BigInt(H)&BigInt(U));K[j]=K[j].add(Q[z])}let $=W;for(let z=K.length-1,D=W;z>0;z--)D=D.add(K[z]),$=$.add(D);if(Z=Z.add($),H!==0)for(let z=0;z<Y;z++)Z=Z.double()}return Z}function rJ(J){return uJ(J.Fp),l0(J,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({..._J(J.n,J.nBitLength),...J,...{p:J.Fp.ORDER}})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */var G5=BigInt(0),y1=BigInt(1),dJ=new WeakMap,W5=new WeakMap;var U5=function(J){if(J.lowS!==void 0)W8("lowS",J.lowS);if(J.prehash!==void 0)W8("prehash",J.prehash)},u7=function(J){const G=rJ(J);l0(G,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});const{endo:Q,Fp:q,a:W}=G;if(Q){if(!q.eql(W,q.ZERO))throw new Error("invalid endomorphism, can only be defined for Koblitz curves that have a=0");if(typeof Q!=="object"||typeof Q.beta!=="bigint"||typeof Q.splitScalar!=="function")throw new Error("invalid endomorphism, expected beta: bigint and splitScalar: function")}return Object.freeze({...G})};function p7(J){const G=u7(J),{Fp:Q}=G,q=E1(G.n,G.nBitLength),W=G.toBytes||((j,M,A)=>{const R=M.toAffine();return F0(Uint8Array.from([4]),Q.toBytes(R.x),Q.toBytes(R.y))}),X=G.fromBytes||((j)=>{const M=j.subarray(1),A=Q.fromBytes(M.subarray(0,Q.BYTES)),R=Q.fromBytes(M.subarray(Q.BYTES,2*Q.BYTES));return{x:A,y:R}});function Y(j){const{a:M,b:A}=G,R=Q.sqr(j),k=Q.mul(R,j);return Q.add(Q.add(k,Q.mul(j,M)),A)}if(!Q.eql(Q.sqr(G.Gy),Y(G.Gx)))throw new Error("bad generator point: equation left != right");function U(j){return p0(j,e,G.n)}function K(j){const{allowedPrivateKeyLengths:M,nByteLength:A,wrapPrivateKey:R,n:k}=G;if(M&&typeof j!=="bigint"){if(c0(j))j=X8(j);if(typeof j!=="string"||!M.includes(j.length))throw new Error("invalid private key");j=j.padStart(A*2,"0")}let N;try{N=typeof j==="bigint"?j:H0(n("private key",j,A))}catch(T){throw new Error("invalid private key, expected hex or "+A+" bytes, got "+typeof j)}if(R)N=a(N,k);return L0("private key",N,e,k),N}function V(j){if(!(j instanceof $))throw new Error("ProjectivePoint expected")}const Z=v1((j,M)=>{const{px:A,py:R,pz:k}=j;if(Q.eql(k,Q.ONE))return{x:A,y:R};const N=j.is0();if(M==null)M=N?Q.ONE:Q.inv(k);const T=Q.mul(A,M),w=Q.mul(R,M),L=Q.mul(k,M);if(N)return{x:Q.ZERO,y:Q.ZERO};if(!Q.eql(L,Q.ONE))throw new Error("invZ was invalid");return{x:T,y:w}}),H=v1((j)=>{if(j.is0()){if(G.allowInfinityPoint&&!Q.is0(j.py))return;throw new Error("bad point: ZERO")}const{x:M,y:A}=j.toAffine();if(!Q.isValid(M)||!Q.isValid(A))throw new Error("bad point: x or y not FE");const R=Q.sqr(A),k=Y(M);if(!Q.eql(R,k))throw new Error("bad point: equation left != right");if(!j.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});class ${constructor(j,M,A){if(this.px=j,this.py=M,this.pz=A,j==null||!Q.isValid(j))throw new Error("x required");if(M==null||!Q.isValid(M))throw new Error("y required");if(A==null||!Q.isValid(A))throw new Error("z required");Object.freeze(this)}static fromAffine(j){const{x:M,y:A}=j||{};if(!j||!Q.isValid(M)||!Q.isValid(A))throw new Error("invalid affine point");if(j instanceof $)throw new Error("projective point not allowed");const R=(k)=>Q.eql(k,Q.ZERO);if(R(M)&&R(A))return $.ZERO;return new $(M,A,Q.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(j){const M=Q.invertBatch(j.map((A)=>A.pz));return j.map((A,R)=>A.toAffine(M[R])).map($.fromAffine)}static fromHex(j){const M=$.fromAffine(X(n("pointHex",j)));return M.assertValidity(),M}static fromPrivateKey(j){return $.BASE.multiply(K(j))}static msm(j,M){return Y5($,q,j,M)}_setWindowSize(j){D.setWindowSize(this,j)}assertValidity(){H(this)}hasEvenY(){const{y:j}=this.toAffine();if(Q.isOdd)return!Q.isOdd(j);throw new Error("Field doesn't support isOdd")}equals(j){V(j);const{px:M,py:A,pz:R}=this,{px:k,py:N,pz:T}=j,w=Q.eql(Q.mul(M,T),Q.mul(k,R)),L=Q.eql(Q.mul(A,T),Q.mul(N,R));return w&&L}negate(){return new $(this.px,Q.neg(this.py),this.pz)}double(){const{a:j,b:M}=G,A=Q.mul(M,V5),{px:R,py:k,pz:N}=this;let{ZERO:T,ZERO:w,ZERO:L}=Q,I=Q.mul(R,R),E=Q.mul(k,k),x=Q.mul(N,N),S=Q.mul(R,k);return S=Q.add(S,S),L=Q.mul(R,N),L=Q.add(L,L),T=Q.mul(j,L),w=Q.mul(A,x),w=Q.add(T,w),T=Q.sub(E,w),w=Q.add(E,w),w=Q.mul(T,w),T=Q.mul(S,T),L=Q.mul(A,L),x=Q.mul(j,x),S=Q.sub(I,x),S=Q.mul(j,S),S=Q.add(S,L),L=Q.add(I,I),I=Q.add(L,I),I=Q.add(I,x),I=Q.mul(I,S),w=Q.add(w,I),x=Q.mul(k,N),x=Q.add(x,x),I=Q.mul(x,S),T=Q.sub(T,I),L=Q.mul(x,E),L=Q.add(L,L),L=Q.add(L,L),new $(T,w,L)}add(j){V(j);const{px:M,py:A,pz:R}=this,{px:k,py:N,pz:T}=j;let{ZERO:w,ZERO:L,ZERO:I}=Q;const E=G.a,x=Q.mul(G.b,V5);let S=Q.mul(M,k),B=Q.mul(A,N),F=Q.mul(R,T),P=Q.add(M,A),O=Q.add(k,N);P=Q.mul(P,O),O=Q.add(S,B),P=Q.sub(P,O),O=Q.add(M,R);let C=Q.add(k,T);return O=Q.mul(O,C),C=Q.add(S,F),O=Q.sub(O,C),C=Q.add(A,R),w=Q.add(N,T),C=Q.mul(C,w),w=Q.add(B,F),C=Q.sub(C,w),I=Q.mul(E,O),w=Q.mul(x,F),I=Q.add(w,I),w=Q.sub(B,I),I=Q.add(B,I),L=Q.mul(w,I),B=Q.add(S,S),B=Q.add(B,S),F=Q.mul(E,F),O=Q.mul(x,O),B=Q.add(B,F),F=Q.sub(S,F),F=Q.mul(E,F),O=Q.add(O,F),S=Q.mul(B,O),L=Q.add(L,S),S=Q.mul(C,O),w=Q.mul(P,w),w=Q.sub(w,S),S=Q.mul(P,B),I=Q.mul(C,I),I=Q.add(I,S),new $(w,L,I)}subtract(j){return this.add(j.negate())}is0(){return this.equals($.ZERO)}wNAF(j){return D.wNAFCached(this,j,$.normalizeZ)}multiplyUnsafe(j){const{endo:M,n:A}=G;L0("scalar",j,v0,A);const R=$.ZERO;if(j===v0)return R;if(this.is0()||j===e)return this;if(!M||D.hasPrecomputes(this))return D.wNAFCachedUnsafe(this,j,$.normalizeZ);let{k1neg:k,k1:N,k2neg:T,k2:w}=M.splitScalar(j),L=R,I=R,E=this;while(N>v0||w>v0){if(N&e)L=L.add(E);if(w&e)I=I.add(E);E=E.double(),N>>=e,w>>=e}if(k)L=L.negate();if(T)I=I.negate();return I=new $(Q.mul(I.px,M.beta),I.py,I.pz),L.add(I)}multiply(j){const{endo:M,n:A}=G;L0("scalar",j,e,A);let R,k;if(M){const{k1neg:N,k1:T,k2neg:w,k2:L}=M.splitScalar(j);let{p:I,f:E}=this.wNAF(T),{p:x,f:S}=this.wNAF(L);I=D.constTimeNegate(N,I),x=D.constTimeNegate(w,x),x=new $(Q.mul(x.px,M.beta),x.py,x.pz),R=I.add(x),k=E.add(S)}else{const{p:N,f:T}=this.wNAF(j);R=N,k=T}return $.normalizeZ([R,k])[0]}multiplyAndAddUnsafe(j,M,A){const R=$.BASE,k=(T,w)=>w===v0||w===e||!T.equals(R)?T.multiplyUnsafe(w):T.multiply(w),N=k(this,M).add(k(j,A));return N.is0()?void 0:N}toAffine(j){return Z(this,j)}isTorsionFree(){const{h:j,isTorsionFree:M}=G;if(j===e)return!0;if(M)return M($,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:j,clearCofactor:M}=G;if(j===e)return this;if(M)return M($,this);return this.multiplyUnsafe(G.h)}toRawBytes(j=!0){return W8("isCompressed",j),this.assertValidity(),W($,this,j)}toHex(j=!0){return W8("isCompressed",j),X8(this.toRawBytes(j))}}$.BASE=new $(G.Gx,G.Gy,Q.ONE),$.ZERO=new $(Q.ZERO,Q.ONE,Q.ZERO);const z=G.nBitLength,D=X5($,G.endo?Math.ceil(z/2):z);return{CURVE:G,ProjectivePoint:$,normPrivateKeyToScalar:K,weierstrassEquation:Y,isWithinCurveOrder:U}}var l7=function(J){const G=rJ(J);return l0(G,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...G})};function Z5(J){const G=l7(J),{Fp:Q,n:q}=G,W=Q.BYTES+1,X=2*Q.BYTES+1;function Y(P){return a(P,q)}function U(P){return g1(P,q)}const{ProjectivePoint:K,normPrivateKeyToScalar:V,weierstrassEquation:Z,isWithinCurveOrder:H}=p7({...G,toBytes(P,O,C){const v=O.toAffine(),g=Q.toBytes(v.x),y=F0;if(W8("isCompressed",C),C)return y(Uint8Array.from([O.hasEvenY()?2:3]),g);else return y(Uint8Array.from([4]),g,Q.toBytes(v.y))},fromBytes(P){const O=P.length,C=P[0],v=P.subarray(1);if(O===W&&(C===2||C===3)){const g=H0(v);if(!p0(g,e,Q.ORDER))throw new Error("Point is not on curve");const y=Z(g);let u;try{u=Q.sqrt(y)}catch(r){const m=r instanceof Error?": "+r.message:"";throw new Error("Point is not on curve"+m)}const c=(u&e)===e;if((C&1)===1!==c)u=Q.neg(u);return{x:g,y:u}}else if(O===X&&C===4){const g=Q.fromBytes(v.subarray(0,Q.BYTES)),y=Q.fromBytes(v.subarray(Q.BYTES,2*Q.BYTES));return{x:g,y}}else{const g=W,y=X;throw new Error("invalid Point, expected length of "+g+", or uncompressed "+y+", got "+O)}}}),$=(P)=>X8(P0(P,G.nByteLength));function z(P){const O=q>>e;return P>O}function D(P){return z(P)?Y(-P):P}const j=(P,O,C)=>H0(P.slice(O,C));class M{constructor(P,O,C){this.r=P,this.s=O,this.recovery=C,this.assertValidity()}static fromCompact(P){const O=G.nByteLength;return P=n("compactSignature",P,O*2),new M(j(P,0,O),j(P,O,2*O))}static fromDER(P){const{r:O,s:C}=S0.toSig(n("DER",P));return new M(O,C)}assertValidity(){L0("r",this.r,e,q),L0("s",this.s,e,q)}addRecoveryBit(P){return new M(this.r,this.s,P)}recoverPublicKey(P){const{r:O,s:C,recovery:v}=this,g=w(n("msgHash",P));if(v==null||![0,1,2,3].includes(v))throw new Error("recovery id invalid");const y=v===2||v===3?O+G.n:O;if(y>=Q.ORDER)throw new Error("recovery id 2 or 3 invalid");const u=(v&1)===0?"02":"03",c=K.fromHex(u+$(y)),f=U(y),r=Y(-g*f),m=Y(C*f),i=K.BASE.multiplyAndAddUnsafe(c,r,m);if(!i)throw new Error("point at infinify");return i.assertValidity(),i}hasHighS(){return z(this.s)}normalizeS(){return this.hasHighS()?new M(this.r,Y(-this.s),this.recovery):this}toDERRawBytes(){return U8(this.toDERHex())}toDERHex(){return S0.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return U8(this.toCompactHex())}toCompactHex(){return $(this.r)+$(this.s)}}const A={isValidPrivateKey(P){try{return V(P),!0}catch(O){return!1}},normPrivateKeyToScalar:V,randomPrivateKey:()=>{const P=cJ(G.n);return Q5(G.randomBytes(P),G.n)},precompute(P=8,O=K.BASE){return O._setWindowSize(P),O.multiply(BigInt(3)),O}};function R(P,O=!0){return K.fromPrivateKey(P).toRawBytes(O)}function k(P){const O=c0(P),C=typeof P==="string",v=(O||C)&&P.length;if(O)return v===W||v===X;if(C)return v===2*W||v===2*X;if(P instanceof K)return!0;return!1}function N(P,O,C=!0){if(k(P))throw new Error("first arg must be private key");if(!k(O))throw new Error("second arg must be public key");return K.fromHex(O).multiply(V(P)).toRawBytes(C)}const T=G.bits2int||function(P){if(P.length>8192)throw new Error("input is too large");const O=H0(P),C=P.length*8-G.nBitLength;return C>0?O>>BigInt(C):O},w=G.bits2int_modN||function(P){return Y(T(P))},L=t8(G.nBitLength);function I(P){return L0("num < 2^"+G.nBitLength,P,v0,L),P0(P,G.nByteLength)}function E(P,O,C=x){if(["recovered","canonical"].some((G0)=>(G0 in C)))throw new Error("sign() legacy options not supported");const{hash:v,randomBytes:g}=G;let{lowS:y,prehash:u,extraEntropy:c}=C;if(y==null)y=!0;if(P=n("msgHash",P),U5(C),u)P=n("prehashed msgHash",v(P));const f=w(P),r=V(O),m=[I(r),I(f)];if(c!=null&&c!==!1){const G0=c===!0?g(Q.BYTES):c;m.push(n("extraEntropy",G0))}const i=F0(...m),_=f;function l(G0){const o=T(G0);if(!H(o))return;const Y0=U(o),U0=K.BASE.multiply(o).toAffine(),J0=Y(U0.x);if(J0===v0)return;const r0=Y(Y0*Y(_+J0*r));if(r0===v0)return;let k0=(U0.x===J0?0:2)|Number(U0.y&e),HQ=r0;if(y&&z(r0))HQ=D(r0),k0^=1;return new M(J0,HQ,k0)}return{seed:i,k2sig:l}}const x={lowS:G.lowS,prehash:!1},S={lowS:G.lowS,prehash:!1};function B(P,O,C=x){const{seed:v,k2sig:g}=E(P,O,C),y=G;return bJ(y.hash.outputLen,y.nByteLength,y.hmac)(v,g)}K.BASE._setWindowSize(8);function F(P,O,C,v=S){const g=P;O=n("msgHash",O),C=n("publicKey",C);const{lowS:y,prehash:u,format:c}=v;if(U5(v),("strict"in v))throw new Error("options.strict was renamed to lowS");if(c!==void 0&&c!=="compact"&&c!=="der")throw new Error("format must be compact or der");const f=typeof g==="string"||c0(g),r=!f&&!c&&typeof g==="object"&&g!==null&&typeof g.r==="bigint"&&typeof g.s==="bigint";if(!f&&!r)throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");let m=void 0,i;try{if(r)m=new M(g.r,g.s);if(f){try{if(c!=="compact")m=M.fromDER(g)}catch(k0){if(!(k0 instanceof S0.Err))throw k0}if(!m&&c!=="der")m=M.fromCompact(g)}i=K.fromHex(C)}catch(k0){return!1}if(!m)return!1;if(y&&m.hasHighS())return!1;if(u)O=G.hash(O);const{r:_,s:l}=m,G0=w(O),o=U(l),Y0=Y(G0*o),U0=Y(_*o),J0=K.BASE.multiplyAndAddUnsafe(i,Y0,U0)?.toAffine();if(!J0)return!1;return Y(J0.x)===_}return{CURVE:G,getPublicKey:R,getSharedSecret:N,sign:B,verify:F,ProjectivePoint:K,Signature:M,utils:A}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */var{bytesToNumberBE:_7,hexToBytes:c7}=hJ;class K5 extends Error{constructor(J=""){super(J)}}var S0={Err:K5,_tlv:{encode:(J,G)=>{const{Err:Q}=S0;if(J<0||J>256)throw new Q("tlv.encode: wrong tag");if(G.length&1)throw new Q("tlv.encode: unpadded data");const q=G.length/2,W=Y8(q);if(W.length/2&128)throw new Q("tlv.encode: long form length too big");const X=q>127?Y8(W.length/2|128):"";return Y8(J)+X+W+G},decode(J,G){const{Err:Q}=S0;let q=0;if(J<0||J>256)throw new Q("tlv.encode: wrong tag");if(G.length<2||G[q++]!==J)throw new Q("tlv.decode: wrong tlv");const W=G[q++],X=!!(W&128);let Y=0;if(!X)Y=W;else{const K=W&127;if(!K)throw new Q("tlv.decode(long): indefinite length not supported");if(K>4)throw new Q("tlv.decode(long): byte length is too big");const V=G.subarray(q,q+K);if(V.length!==K)throw new Q("tlv.decode: length bytes not complete");if(V[0]===0)throw new Q("tlv.decode(long): zero leftmost byte");for(let Z of V)Y=Y<<8|Z;if(q+=K,Y<128)throw new Q("tlv.decode(long): not minimal encoding")}const U=G.subarray(q,q+Y);if(U.length!==Y)throw new Q("tlv.decode: wrong value length");return{v:U,l:G.subarray(q+Y)}}},_int:{encode(J){const{Err:G}=S0;if(J<v0)throw new G("integer: negative integers are not allowed");let Q=Y8(J);if(Number.parseInt(Q[0],16)&8)Q="00"+Q;if(Q.length&1)throw new G("unexpected DER parsing assertion: unpadded hex");return Q},decode(J){const{Err:G}=S0;if(J[0]&128)throw new G("invalid signature integer: negative");if(J[0]===0&&!(J[1]&128))throw new G("invalid signature integer: unnecessary leading zero");return _7(J)}},toSig(J){const{Err:G,_int:Q,_tlv:q}=S0,W=typeof J==="string"?c7(J):J;k8(W);const{v:X,l:Y}=q.decode(48,W);if(Y.length)throw new G("invalid signature: left bytes after parsing");const{v:U,l:K}=q.decode(2,X),{v:V,l:Z}=q.decode(2,K);if(Z.length)throw new G("invalid signature: left bytes after parsing");return{r:Q.decode(U),s:Q.decode(V)}},hexFromSig(J){const{_tlv:G,_int:Q}=S0,q=G.encode(2,Q.encode(J.r)),W=G.encode(2,Q.encode(J.s)),X=q+W;return G.encode(48,X)}},v0=BigInt(0),e=BigInt(1),DX=BigInt(2),V5=BigInt(3),BX=BigInt(4);function d7(J){return{hash:J,hmac:(G,...Q)=>vJ(J,G,d9(...Q)),randomBytes:I1}}function z5(J,G){const Q=(q)=>Z5({...J,...d7(q)});return{...Q(G),create:Q}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */var j5=function(J){const G=Q1,Q=BigInt(3),q=BigInt(6),W=BigInt(11),X=BigInt(22),Y=BigInt(23),U=BigInt(44),K=BigInt(88),V=J*J*J%G,Z=V*V*J%G,H=Z0(Z,Q,G)*Z%G,$=Z0(H,Q,G)*Z%G,z=Z0($,b1,G)*V%G,D=Z0(z,W,G)*z%G,j=Z0(D,X,G)*D%G,M=Z0(j,U,G)*j%G,A=Z0(M,K,G)*M%G,R=Z0(A,U,G)*j%G,k=Z0(R,Q,G)*Z%G,N=Z0(k,Y,G)*D%G,T=Z0(N,q,G)*V%G,w=Z0(T,b1,G);if(!nJ.eql(nJ.sqr(w),J))throw new Error("Cannot find square root");return w},h1=function(J,...G){let Q=H5[J];if(Q===void 0){const q=x1(Uint8Array.from(J,(W)=>W.charCodeAt(0)));Q=F0(q,q),H5[J]=Q}return x1(F0(Q,...G))},sJ=function(J){let G=tJ.utils.normPrivateKeyToScalar(J),Q=JQ.fromPrivateKey(G);return{scalar:Q.hasEvenY()?G:J1(-G),bytes:eJ(Q)}},P5=function(J){L0("x",J,e8,Q1);const G=oJ(J*J),Q=oJ(G*J+BigInt(7));let q=j5(Q);if(q%b1!==M5)q=oJ(-q);const W=new JQ(J,q,e8);return W.assertValidity(),W},N5=function(...J){return J1(I8(h1("BIP0340/challenge",...J)))},r7=function(J){return sJ(J).bytes},o7=function(J,G,Q=I1(32)){const q=n("message",J),{bytes:W,scalar:X}=sJ(G),Y=n("auxRand",Q,32),U=aJ(X^I8(h1("BIP0340/aux",Y))),K=h1("BIP0340/nonce",U,W,q),V=J1(I8(K));if(V===M5)throw new Error("sign failed: k is zero");const{bytes:Z,scalar:H}=sJ(V),$=N5(Z,W,q),z=new Uint8Array(64);if(z.set(Z,0),z.set(aJ(J1(H+$*X)),32),!C5(z,q,W))throw new Error("sign: Invalid signature produced");return z},C5=function(J,G,Q){const q=n("signature",J,64),W=n("message",G),X=n("publicKey",Q,32);try{const Y=P5(I8(X)),U=I8(q.subarray(0,32));if(!p0(U,e8,Q1))return!1;const K=I8(q.subarray(32,64));if(!p0(K,e8,f1))return!1;const V=N5(aJ(U),eJ(Y),W),Z=i7(Y,K,J1(-V));if(!Z||!Z.hasEvenY()||Z.toAffine().x!==U)return!1;return!0}catch(Y){return!1}};/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */var Q1=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),f1=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),e8=BigInt(1),b1=BigInt(2),$5=(J,G)=>(J+G/b1)/G,nJ=E1(Q1,void 0,void 0,{sqrt:j5}),tJ=z5({a:BigInt(0),b:BigInt(7),Fp:nJ,n:f1,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:(J)=>{const G=f1,Q=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),q=-e8*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),W=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),X=Q,Y=BigInt("0x100000000000000000000000000000000"),U=$5(X*J,G),K=$5(-q*J,G);let V=a(J-U*Q-K*W,G),Z=a(-U*q-K*X,G);const H=V>Y,$=Z>Y;if(H)V=G-V;if($)Z=G-Z;if(V>Y||Z>Y)throw new Error("splitScalar: Endomorphism failed, k="+J);return{k1neg:H,k1:V,k2neg:$,k2:Z}}}},x1),M5=BigInt(0),H5={},eJ=(J)=>J.toRawBytes(!0).slice(1),aJ=(J)=>P0(J,32),oJ=(J)=>a(J,Q1),J1=(J)=>a(J,f1),JQ=tJ.ProjectivePoint,i7=(J,G,Q)=>JQ.BASE.multiplyAndAddUnsafe(J,G,Q),I8=H0,m1=(()=>({getPublicKey:r7,sign:o7,verify:C5,utils:{randomPrivateKey:tJ.utils.randomPrivateKey,lift_x:P5,pointToBytes:eJ,numberToBytesBE:P0,bytesToNumberBE:H0,taggedHash:h1,mod:a}}))();var{floor:QQ,random:n7,sin:a7}=Math,K8="Trystero",d0=(J,G)=>Array(J).fill().map(G);var _1=(J)=>d0(J,()=>"0123456789AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz"[QQ(n7()*"0123456789AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz".length)]).join(""),A0=_1(20),i0=Promise.all.bind(Promise),G1=typeof window!=="undefined",{entries:c1,fromEntries:GQ,keys:D5}=Object,g0=()=>{},N0=(J)=>new Error(`Trystero: ${J}`),s7=new TextEncoder,t7=new TextDecoder,R0=(J)=>s7.encode(J),x8=(J)=>t7.decode(J),p1=(J)=>J.reduce((G,Q)=>G+Q.toString(16).padStart(2,"0"),""),q1=(...J)=>J.join("@"),e7=(J,G)=>{const Q=[...J],q=()=>{const X=a7(G++)*1e4;return X-QQ(X)};let W=Q.length;while(W){const X=QQ(q()*W--);[Q[W],Q[X]]=[Q[X],Q[W]]}return Q},B5=(J,G,Q,q)=>{return(J.relayUrls||(q?e7(G,qQ(J.appId)):G)).slice(0,J.relayUrls?J.relayUrls.length:J.relayRedundancy||Q)},j0=JSON.stringify,Z8=JSON.parse,qQ=(J,G=Number.MAX_SAFE_INTEGER)=>J.split("").reduce((Q,q)=>Q+q.charCodeAt(0),0)%G;var u1={},O5=(J,G)=>{const Q={},q=()=>{const W=new WebSocket(J);W.onclose=()=>{u1[J]??=3333,setTimeout(q,u1[J]),u1[J]*=2},W.onmessage=(X)=>G(X.data),Q.socket=W,Q.url=W.url,Q.ready=new Promise((X)=>W.onopen=()=>{X(Q),u1[J]=3333}),Q.send=(X)=>{if(W.readyState===1)W.send(X)}};return q(),Q},L5=(J)=>()=>GQ(c1(J).map(([G,Q])=>[G,Q.socket]));var WQ="AES-GCM",A5={},JW=(J)=>btoa(String.fromCharCode.apply(null,new Uint8Array(J))),QW=(J)=>{const G=atob(J);return new Uint8Array(G.length).map((Q,q)=>G.charCodeAt(q)).buffer},W1=async(J)=>A5[J]||(A5[J]=Array.from(new Uint8Array(await crypto.subtle.digest("SHA-1",R0(J)))).map((G)=>G.toString(36)).join("")),R5=async(J,G,Q)=>crypto.subtle.importKey("raw",await crypto.subtle.digest({name:"SHA-256"},R0(`${J}:${G}:${Q}`)),{name:WQ},!1,["encrypt","decrypt"]),k5="$",I5=",",x5=async(J,G)=>{const Q=crypto.getRandomValues(new Uint8Array(16));return Q.join(I5)+k5+JW(await crypto.subtle.encrypt({name:WQ,iv:Q},await J,R0(G)))},w5=async(J,G)=>{const[Q,q]=G.split(k5);return x8(await crypto.subtle.decrypt({name:WQ,iv:new Uint8Array(Q.split(I5))},await J,QW(q)))};var GW=5000,T5="icegatheringstatechange",XQ=(J)=>J.replace(/a=ice-options:trickle\s\n/g,""),YQ=(J,{rtcConfig:G,rtcPolyfill:Q,turnConfig:q})=>{const W=new(Q||RTCPeerConnection)({iceServers:qW.concat(q||[]),...G}),X={},Y=(H)=>{H.binaryType="arraybuffer",H.bufferedAmountLowThreshold=65535,H.onmessage=($)=>X.data?.($.data),H.onopen=()=>X.connect?.(),H.onclose=()=>X.close?.(),H.onerror=($)=>X.error?.($)},U=async(H)=>{if(!H.localDescription)throw new Error("No local description available");return await Promise.race([new Promise(($)=>{const z=()=>{if(H.iceGatheringState==="complete")H.removeEventListener(T5,z),$()};H.addEventListener(T5,z),z()}),new Promise(($)=>setTimeout($,GW))]),{type:H.localDescription.type,sdp:XQ(H.localDescription.sdp)}};let K=!1,V=null,Z=!1;if(J)V=W.createDataChannel("data"),Y(V);else W.ondatachannel=({channel:H})=>{V=H,Y(H)};return W.onnegotiationneeded=async()=>{try{K=!0,await W.setLocalDescription();const H=await U(W);X.signal?.({type:H.type,sdp:XQ(H.sdp)})}catch(H){X.error?.(H)}finally{K=!1}},W.onconnectionstatechange=()=>{if(["disconnected","failed","closed"].includes(W.connectionState))X.close?.()},W.ontrack=(H)=>{X.track?.(H.track,H.streams[0]),X.stream?.(H.streams[0])},W.onremovestream=(H)=>{X.stream?.(H.stream,{removed:!0})},{created:Date.now(),connection:W,get channel(){return V},get isDead(){return W.connectionState==="closed"},async signal(H){if(V?.readyState==="open"){if(H.type==="offer"||W.signalingState!=="stable"){if(await W.setRemoteDescription(H),H.type==="offer"){await W.setLocalDescription();const $=await U(W);return X.signal?.({type:$.type,sdp:$.sdp}),{type:$.type,sdp:$.sdp}}}return}try{if(H.type==="offer"){if(K||W.signalingState!=="stable"){if(Z=!J,Z)return}await W.setRemoteDescription(H),await W.setLocalDescription();const $=await U(W),z=XQ($.sdp);return X.signal?.({type:$.type,sdp:z}),{type:$.type,sdp:z}}else if(H.type==="answer"&&(W.signalingState==="have-local-offer"||W.signalingState==="have-remote-offer"))await W.setRemoteDescription(H)}catch($){X.error?.($)}},sendData:(H)=>V.send(H),destroy:()=>{if(V)V.close();W.close()},setHandlers:(H)=>Object.assign(X,H),offerPromise:J?new Promise((H)=>{const $=(z)=>{if(z.type==="offer")H(z)};X.signal=$}):Promise.resolve(),addStream:(H)=>{H.getTracks().forEach(($)=>W.addTrack($,H))},removeStream:(H)=>{W.getSenders().filter(($)=>H.getTracks().includes($.track)).forEach(($)=>W.removeTrack($))},addTrack:(H,$)=>W.addTrack(H,$),removeTrack:(H)=>{const $=W.getSenders().find((z)=>z.track===H);if($)W.removeTrack($)},replaceTrack:async(H,$)=>{const z=W.getSenders().find((D)=>D.track===H);if(z)await z.replaceTrack($)}}},qW=[...d0(3,(J,G)=>`stun:stun${G||""}.l.google.com:19302`),"stun:global.stun.twilio.com:3478"].map((J)=>({urls:J}));var WW=Object.getPrototypeOf(Uint8Array),d1=12,S5=0,i1=S5+d1,r1=i1+1,X1=r1+1,Y1=X1+1,z8=16384-Y1,l1=255,F5="bufferedamountlow",w8=(J)=>"@_"+J,v5=(J,G,Q)=>{const q={},W={},X={},Y={},U={},K={},V={},Z={onPeerJoin:g0,onPeerLeave:g0,onPeerStream:g0,onPeerTrack:g0},H=(B,F)=>(B?Array.isArray(B)?B:[B]:D5(q)).flatMap((P)=>{const O=q[P];if(!O)return console.warn(`${K8}: no peer with id ${P} found`),[];return F(P,O)}),$=(B)=>{if(!q[B])return;delete q[B],delete Y[B],delete U[B],Z.onPeerLeave(B),G(B)},z=(B)=>{if(W[B])return X[B];if(!B)throw N0("action type argument is required");const F=R0(B);if(F.byteLength>d1)throw N0(`action type string "${B}" (${F.byteLength}b) exceeds `+`byte limit (${d1}). Hint: choose a shorter name.`);const P=new Uint8Array(d1);P.set(F);let O=0;return W[B]={onComplete:g0,onProgress:g0,setOnComplete:(C)=>W[B]={...W[B],onComplete:C},setOnProgress:(C)=>W[B]={...W[B],onProgress:C},send:async(C,v,g,y)=>{if(g&&typeof g!=="object")throw N0("action meta argument must be an object");const u=typeof C;if(u==="undefined")throw N0("action data cannot be undefined");const c=u!=="string",f=C instanceof Blob,r=f||C instanceof ArrayBuffer||C instanceof WW;if(g&&!r)throw N0("action meta argument can only be used with binary data");const m=r?new Uint8Array(f?await C.arrayBuffer():C):R0(c?j0(C):C),i=g?R0(j0(g)):null,_=Math.ceil(m.byteLength/z8)+(g?1:0)||1,l=d0(_,(G0,o)=>{const Y0=o===_-1,U0=g&&o===0,J0=new Uint8Array(Y1+(U0?i.byteLength:Y0?m.byteLength-z8*(_-(g?2:1)):z8));return J0.set(P),J0.set([O],i1),J0.set([Y0|U0<<1|r<<2|c<<3],r1),J0.set([Math.round((o+1)/_*l1)],X1),J0.set(g?U0?i:m.subarray((o-1)*z8,o*z8):m.subarray(o*z8,(o+1)*z8),Y1),J0});return O=O+1&l1,i0(H(v,async(G0,o)=>{const{channel:Y0}=o;let U0=0;while(U0<_){const J0=l[U0];if(Y0.bufferedAmount>Y0.bufferedAmountLowThreshold)await new Promise((r0)=>{const k0=()=>{Y0.removeEventListener(F5,k0),r0()};Y0.addEventListener(F5,k0)});if(!q[G0])break;o.sendData(J0),U0++,y?.(J0[X1]/l1,G0,g)}}))}},X[B]||=[W[B].send,W[B].setOnComplete,W[B].setOnProgress]},D=(B,F)=>{const P=new Uint8Array(F),O=x8(P.subarray(S5,i1)).replaceAll("\0",""),[C]=P.subarray(i1,r1),[v]=P.subarray(r1,X1),[g]=P.subarray(X1,Y1),y=P.subarray(Y1),u=!!(v&1),c=!!(v&1<<1),f=!!(v&1<<2),r=!!(v&1<<3);if(!W[O]){console.warn(`${K8}: received message with unregistered type (${O})`);return}Y[B]||={},Y[B][O]||={};const m=Y[B][O][C]||={chunks:[]};if(c)m.meta=Z8(x8(y));else m.chunks.push(y);if(W[O].onProgress(g/l1,B,m.meta),!u)return;const i=new Uint8Array(m.chunks.reduce((_,l)=>_+l.byteLength,0));if(m.chunks.reduce((_,l)=>{return i.set(l,_),_+l.byteLength},0),delete Y[B][O][C],f)W[O].onComplete(i,B,m.meta);else{const _=x8(i);W[O].onComplete(r?Z8(_):_,B)}},j=async()=>{await x(""),await new Promise((B)=>setTimeout(B,99)),c1(q).forEach(([B,F])=>{F.destroy(),delete q[B]}),Q()},[M,A]=z(w8("ping")),[R,k]=z(w8("pong")),[N,T]=z(w8("signal")),[w,L]=z(w8("stream")),[I,E]=z(w8("track")),[x,S]=z(w8("leave"));if(J((B,F)=>{if(q[F])return;q[F]=B,B.setHandlers({data:(P)=>D(F,P),stream:(P)=>{Z.onPeerStream(P,F,K[F]),delete K[F]},track:(P,O)=>{Z.onPeerTrack(P,O,F,V[F]),delete V[F]},signal:(P)=>N(P,F),close:()=>$(F),error:()=>$(F)}),Z.onPeerJoin(F),B.drainEarlyData?.((P)=>D(F,P))}),A((B,F)=>R("",F)),k((B,F)=>{U[F]?.(),delete U[F]}),T((B,F)=>q[F]?.signal(B)),L((B,F)=>K[F]=B),E((B,F)=>V[F]=B),S((B,F)=>$(F)),G1)addEventListener("beforeunload",j);return{makeAction:z,leave:j,ping:async(B)=>{if(!B)throw N0("ping() must be called with target peer ID");const F=Date.now();return M("",B),await new Promise((P)=>U[B]=P),Date.now()-F},getPeers:()=>GQ(c1(q).map(([B,F])=>[B,F.connection])),addStream:(B,F,P)=>H(F,async(O,C)=>{if(P)await w(P,O);C.addStream(B)}),removeStream:(B,F)=>H(F,(P,O)=>O.removeStream(B)),addTrack:(B,F,P,O)=>H(P,async(C,v)=>{if(O)await I(O,C);v.addTrack(B,F)}),removeTrack:(B,F,P)=>H(P,(O,C)=>C.removeTrack(B,F)),replaceTrack:(B,F,P,O,C)=>H(O,async(v,g)=>{if(C)await I(C,v);g.replaceTrack(B,F,P)}),onPeerJoin:(B)=>Z.onPeerJoin=B,onPeerLeave:(B)=>Z.onPeerLeave=B,onPeerStream:(B)=>Z.onPeerStream=B,onPeerTrack:(B)=>Z.onPeerTrack=B}};var XW=20,YW=5333,g5=57333,E5=({init:J,subscribe:G,announce:Q})=>{const q={};let W=!1,X,Y,U;return(K,V,Z)=>{const{appId:H}=K;if(q[H]?.[V])return q[H][V];const $={},z={},D=q1(K8,H,V),j=W1(D),M=W1(q1(D,A0)),A=R5(K.password||"",H,V),R=(C)=>async(v)=>({type:v.type,sdp:await C(A,v.sdp)}),k=R(w5),N=R(x5),T=()=>YQ(!0,K),w=(C,v,g)=>{if(z[v]){if(z[v]!==C)C.destroy();return}z[v]=C,O(C,v),$[v]?.forEach((y,u)=>{if(u!==g)y.destroy()}),delete $[v]},L=(C,v)=>{if(z[v]===C)delete z[v]},I=(C,v)=>{if(z[C])return;const g=$[C]?.[v];if(g)delete $[C][v],g.destroy()},E=(C)=>{return Y.push(...d0(C,T)),i0(Y.splice(0,C).map((v)=>v.offerPromise.then(N).then((g)=>({peer:v,offer:g}))))},x=(C,v)=>Z?.({error:`incorrect password (${K.password}) when decrypting ${v}`,appId:H,peerId:C,roomId:V}),S=(C)=>async(v,g,y)=>{const[u,c]=await i0([j,M]);if(v!==u&&v!==c)return;const{peerId:f,offer:r,answer:m,peer:i}=typeof g==="string"?Z8(g):g;if(f===A0||z[f])return;if(f&&!r&&!m){if($[f]?.[C])return;const[[{peer:_,offer:l}],G0]=await i0([E(1),W1(q1(D,f))]);$[f]||=[],$[f][C]=_,setTimeout(()=>I(f,C),B[C]*0.9),_.setHandlers({connect:()=>w(_,f,C),close:()=>L(_,f)}),y(G0,j0({peerId:A0,offer:l}))}else if(r){if($[f]?.[C]&&A0>f)return;const l=YQ(!1,K);l.setHandlers({connect:()=>w(l,f,C),close:()=>L(l,f)});let G0;try{G0=await k(r)}catch{x(f,"offer");return}if(l.isDead)return;const[o,Y0]=await i0([W1(q1(D,f)),l.signal(G0)]);y(o,j0({peerId:A0,answer:await N(Y0)}))}else if(m){let _;try{_=await k(m)}catch(l){x(f,"answer");return}if(i)i.setHandlers({connect:()=>w(i,f,C),close:()=>L(i,f)}),i.signal(_);else{const l=$[f]?.[C];if(l&&!l.isDead)l.signal(_)}}};if(!K)throw N0("requires a config map as the first argument");if(!H&&!K.firebaseApp)throw N0("config map is missing appId field");if(!V)throw N0("roomId argument required");if(!W){const C=J(K);Y=d0(XW,T),X=Array.isArray(C)?C:[C],W=!0,U=setInterval(()=>Y=Y.filter((v)=>{const g=Date.now()-v.created<g5;if(!g)v.destroy();return g}),g5*1.03)}const B=X.map(()=>YW),F=[],P=X.map(async(C,v)=>G(await C,await j,await M,S(v),E));i0([j,M]).then(([C,v])=>{const g=async(y,u)=>{const c=await Q(y,C,v);if(typeof c==="number")B[u]=c;F[u]=setTimeout(()=>g(y,u),B[u])};P.forEach(async(y,u)=>{await y,g(await X[u],u)})});let O=g0;return q[H]||={},q[H][V]=v5((C)=>O=C,(C)=>delete z[C],()=>{delete q[H][V],F.forEach(clearTimeout),P.forEach(async(C)=>(await C)()),clearInterval(U)})}};var h5={},UW=5,m5="x",u5="EVENT",_5=G1&&m1.utils.randomPrivateKey(),VW=G1&&p1(m1.getPublicKey(_5)),UQ={},U1={},KW={},c5=()=>Math.floor(Date.now()/1000),p5=(J)=>KW[J]??=qQ(J,1e4)+20000,y5=async(J,G)=>{const Q={kind:p5(J),content:G,pubkey:VW,created_at:c5(),tags:[[m5,J]]},q=p1(new Uint8Array(await crypto.subtle.digest("SHA-256",R0(j0([0,Q.pubkey,Q.created_at,Q.kind,Q.tags,Q.content])))));return j0([u5,{...Q,id:q,sig:p1(await m1.sign(q,_5))}])},f5=(J,G)=>{return UQ[J]=G,j0(["REQ",J,{kinds:[p5(G)],since:c5(),["#"+m5]:[G]}])},b5=(J)=>{return delete UQ[J],j0(["CLOSE",J])},VQ=E5({init:(J)=>B5(J,zW,UW,!0).map((G)=>{const Q=O5(G,(q)=>{const[W,X,Y,U]=Z8(q);if(W!==u5){const K=`${K8}: relay failure from ${Q.url} - `;if(W==="NOTICE")console.warn(K+X);else if(W==="OK"&&!Y)console.warn(K+U);return}U1[X]?.(UQ[X],Y.content)});return h5[G]=Q,Q.ready}),subscribe:(J,G,Q,q)=>{const W=_1(64),X=_1(64);return U1[W]=U1[X]=(Y,U)=>q(Y,U,async(K,V)=>J.send(await y5(K,V))),J.send(f5(W,G)),J.send(f5(X,Q)),()=>{J.send(b5(W)),J.send(b5(X)),delete U1[W],delete U1[X]}},announce:async(J,G)=>J.send(await y5(G,j0({peerId:A0})))}),ZW=L5(h5),zW=["eu.purplerelay.com","ftp.halifax.rwth-aachen.de/nostr","longhorn.bgp.rodeo","multiplexer.huszonegy.world","nfdb.noswhere.com","nostr-verified.wellorder.net","nostr.cool110.xyz","nostr.data.haus","nostr.grooveix.com","nostr.huszonegy.world","nostr.mom","nostr.openhoofd.nl","nostr.petrkr.net/strfry","nostr.sathoarder.com","nostr.stakey.net","nostr.vulpem.com","nostr2.sanhauf.com","nostrelay.circum.space","relay.fountain.fm","relay.nostraddress.com","relay.nostromo.social","relay.snort.social","relay.verified-nostr.com","strfry.openhoofd.nl","yabu.me/v2"].map((J)=>"wss://"+J);var l5=(J,G,Q)=>{if(!J||!J.timestamp)return{resolved:!0,value:G.value,timestamp:G.timestamp};const q=G.timestamp,W=J.timestamp;if(Q.compare(W,q)<0)return{resolved:!0,value:G.value,timestamp:G.timestamp};return{resolved:!1}};var $W=()=>{let J=!1;const G=async(W)=>{while(J)await new Promise((X)=>setTimeout(X,10));J=!0;try{return await W()}finally{J=!1}},Q=async(W)=>{return G(async()=>{try{const X=await(await navigator.storage.getDirectory()).getFileHandle(W,{create:!1}).then((U)=>U.createSyncAccessHandle()),Y=new Uint8Array(X.getSize());return X.read(Y,{at:0}),X.close(),{type:"loaded",name:W,data:Y}}catch(X){return{type:"error",name:W,message:X.message||"File not found"}}})},q=async(W,X)=>{return G(async()=>{if(!(X instanceof Uint8Array))throw new Error("Content must be a Uint8Array");try{const Y=await(await navigator.storage.getDirectory()).getFileHandle(W,{create:!0}).then((U)=>U.createSyncAccessHandle());return Y.write(X,{at:0}),Y.truncate(X.byteLength),Y.close(),{type:"saved",name:W}}catch(Y){return{type:"error",name:W,message:Y.message||"Error saving the file"}}})};self.onmessage=async({data:{type:W,name:X,content:Y}})=>{try{const U=W==="load"?await Q(X):W==="save"?await q(X,Y):{type:"error",message:"Unrecognized action"};self.postMessage(U)}catch(U){self.postMessage({type:"error",message:U.message||"Unexpected error"})}}},d5=$W;var $8={$eq:(J,G)=>J===G,$ne:(J,G)=>J!==G,$gt:(J,G)=>J>G,$gte:(J,G)=>J>=G,$lt:(J,G)=>J<G,$lte:(J,G)=>J<=G,$in:(J,G)=>Array.isArray(G)&&G.includes(J),$between:(J,[G,Q])=>J>=G&&J<=Q,$exists:(J,G)=>G?J!==void 0:J===void 0,$text:{global:(J,G)=>{const Q=(W)=>String(W).normalize("NFD").replace(/[\u0300-\u036f]/g,"").toLowerCase().replace(/[^\w\s]/g,""),q=Q(G);return Object.values(J).some((W)=>{if(typeof W==="object")return null.fieldSearch(W,q);return Q(W).includes(q)})},field:(J,G)=>{const Q=(q)=>String(q).normalize("NFD").replace(/[\u0300-\u036f]/g,"").toLowerCase().replace(/[^\w\s]/g,"");return Array.isArray(J)?J.some((q)=>Q(q).includes(Q(G))):Q(J).includes(Q(G))}},$like:(J,G)=>{if(typeof J!=="string"||typeof G!=="string")return!1;return new RegExp(`^${G.replace(/%/g,".*").replace(/_/g,".")}\$`,"i").test(J)},$regex:(J,G)=>typeof J==="string"&&new RegExp(G.$regex||G,"i").test(J),$and:(J,G,Q)=>G.every((q)=>{return Q.createFilter(q)(J)}),$or:(J,G,Q)=>G.some((q)=>{return Q.createFilter(q)(J)}),$not:(J,G,Q)=>{return!Q.createFilter(G)(J)}},KQ=(J,G)=>{const Q=G.split(".");let q=J;for(let W of Q)if(q&&typeof q==="object"&&(W in q))q=q[W];else return;return q},ZQ=(J)=>{const G=(Q)=>{return Object.entries(J).every(([q,W])=>{if(q.startsWith("$"))return $8[q](Q,W,{filterNode:G,createFilter:ZQ});const X=KQ(Q.value,q);if(typeof W!=="object"||W===null)return $8.$eq(X,W);return Object.entries(W).every(([Y,U])=>{if(Y==="$text")return $8.$text.field(X,U);if(Y==="$between"&&U.every((K)=>K instanceof Date)){const K=new Date(X);return $8.$between(K,U)}return $8[Y]?.(X,U,{filterNode:G,createFilter:ZQ})??!1})})};return G},zQ=(J,G)=>{const Q=ZQ(G.query);let q=Object.values(J).filter(Q);if(G.field)q.sort((W,X)=>{const Y=KQ(W.value,G.field),U=KQ(X.value,G.field),K=G.order==="asc"?1:-1;if(typeof Y==="string"&&typeof U==="string")return Y.localeCompare(U)*K;return((Y??0)-(U??0))*K});if(G.$after){const W=q.findIndex((X)=>X.id===G.$after);q=W>=0?q.slice(W+1):[]}if(G.$before){const W=q.findIndex((X)=>X.id===G.$before);q=W>=0?q.slice(0,W):[]}return G.$limit?q.slice(0,G.$limit):q};class $Q{constructor(){this.physical=Date.now(),this.logical=0}now(){const J=Date.now();return this.physical=Math.max(this.physical,J),this.logical++,{physical:this.physical,logical:this.logical}}update(J){this.physical=Math.max(this.physical,J.physical),this.logical=Math.max(this.logical,J.logical)+1}compare(J,G){if(J.logical>G.logical)return 1;else if(J.logical<G.logical)return-1;else return J.physical-G.physical}}var i5=function(J,G){return J.length===G.length&&J.every((Q,q)=>Q===G[q])};async function HW(){console.log("\u26A1 GDB-P2P: Empowering distributed graph databases with real-time synchronization and scalability. Learn more: https://github.com/estebanrfp/gdb \u26A1"),console.log(navigator?.storage?.getDirectory?"OPFS is enabled.":"OPFS is not available."),navigator?.storage?.getDirectory&&await navigator.storage.getDirectory()}if(Symbol.dispose===void 0)Object.defineProperty(Symbol,"dispose",{value:Symbol.for("Symbol.dispose")});class r5{constructor(){this.nodes={}}insert(J,G,Q){this.nodes[J]={id:J,value:G,edges:[],timestamp:Q}}get(J){return this.nodes[J]||null}link(J,G){const Q=this.nodes[J],q=this.nodes[G];if(Q&&q&&!Q.edges.includes(G))Q.edges.push(G)}getAllNodes(){return Object.values(this.nodes)}serialize(){return TJ.deflate(E0(this.nodes))}deserialize(J){this.nodes=t1(TJ.inflate(new Uint8Array(J)))}}class o5{constructor(J,{password:G}={}){this.hybridClock=new $Q;const Q=localStorage.getItem(`${this.name}_time`);this.globalTimestamp=Q?JSON.parse(Q):null,this.changeList=[],this.name=J,this.password=G,this.graph=new r5,this.eventListeners=[],this.operators=$8,this.initWorker(),this.ready=this.loadGraphFromOPFS();const q=`graph-sync-room-${this.name}`,W={appId:"1234",...this.password&&{password:this.password}},X=VQ(W,q);this.room=X;const[Y,U]=X.makeAction("syncGraph");this.sendData=Y,window.addEventListener("online",async()=>{console.log("\u2705 Reconnected to the network.");const K=localStorage.getItem(`${this.name}_time`);this.globalTimestamp=K?JSON.parse(K):null,this.sendData([{type:"sync",timestamp:this.globalTimestamp}])}),window.addEventListener("offline",async()=>{console.log("\u274C Disconnected from the network.")}),document.addEventListener("visibilitychange",()=>{if(document.visibilityState==="visible"){console.log("The tab is visible again.");const K=localStorage.getItem(`${this.name}_time`);this.globalTimestamp=K?JSON.parse(K):null,this.sendData([{type:"sync",timestamp:this.globalTimestamp}])}else if(document.visibilityState==="hidden")console.log("The tab is no longer visible.")}),HW(),X.onPeerJoin(async(K)=>{console.log("\u26A1 New pair connected:",K);const V=localStorage.getItem(`${this.name}_time`);this.globalTimestamp=V?JSON.parse(V):null,this.sendData([{type:"sync",timestamp:this.globalTimestamp}])}),X.onPeerLeave((K)=>{console.log("\u26A1 Pair disconnected:",K)}),U((K)=>this.receiveChanges(K)),this.channel=new BroadcastChannel(`graphdb_sync_${this.name}`),this.channel.onmessage=async(K)=>{if(K.data==="update")console.log("\uD83D\uDD04 Update received from another tab..."),await this.loadGraphFromOPFS(),this.emit()}}initWorker=async()=>{try{const J=URL.createObjectURL(new Blob([`(${d5.toString()})()`],{type:"application/javascript"}));this.worker=new Worker(J),URL.revokeObjectURL(J),this.worker.addEventListener("message",({data:G})=>console.log("Worker message:",`${G.name} ${G.type}`)),console.log("Worker initialized successfully.")}catch({message:J}){console.error("Failed to initialize worker:",J)}};getWorker(){return this.worker}emit(){const J=this.graph.getAllNodes();this.eventListeners.forEach((G)=>G(J))}on(J){this.eventListeners.push(J)}off(J){if(J)this.eventListeners=this.eventListeners.filter((G)=>G!==J);else this.eventListeners=[]}addChange(J,G,Q){const q={id:J,timestamp:G,operation:Q};this.changeList.push(q)}async getAllNodes(){return await this.ready,this.graph.getAllNodes()}async generateHash(){return crypto.randomUUID()}async hashValue(J){const G=(new TextEncoder()).encode(J),Q=await crypto.subtle.digest("SHA-256",G);return Array.from(new Uint8Array(Q)).map((q)=>q.toString(16).padStart(2,"0")).join("")}async loadGraphFromOPFS(){try{const G=await((Q)=>new Promise((q,W)=>{const X=({data:Y})=>{if(Y.type==="loaded"&&Y.name===Q)this.worker.removeEventListener("message",X),q(new Uint8Array(Y.data));else if(Y.type==="error")this.worker.removeEventListener("message",X),W(new Error(Y.message||"Unknown error"))};this.worker.addEventListener("message",X),this.worker.postMessage({type:"load",name:Q})}))(`${this.name}_graph.msgpack`).catch(()=>new Uint8Array);G.byteLength>0?this.graph.deserialize(G):console.warn("The file '_graph.msgpack' is empty or could not be loaded."),console.log(`Graph loaded from OPFS: [ ${this.graph.getAllNodes().length} nodes ]`)}catch({message:J}){console.error("General error loading the graph from OPFS:",J)}}async saveGraphToOPFS(){try{const J=this.graph.serialize();return await((Q,q)=>new Promise((W,X)=>{const Y=({data:U})=>{if(U.type==="saved"&&U.name===Q)this.worker.removeEventListener("message",Y),W();else if(U.type==="error")this.worker.removeEventListener("message",Y),X(new Error(U.message||"Save error"))};this.worker.addEventListener("message",Y),this.worker.postMessage({type:"save",name:Q,content:q})}))(`${this.name}_graph.msgpack`,J),this.channel.postMessage("update"),!0}catch({message:J}){throw console.error("Save error:",J),new Error("Save failed")}}async put(J,G){await this.ready;const Q=this.hybridClock.now();return localStorage.setItem(`${this.name}_time`,JSON.stringify(Q)),G??=await this.generateHash(E0(J)),this.graph.insert(G,J,Q),this.addChange(G,Q,"insert"),await this.saveGraphToOPFS(),this.sendData([{type:"insert",id:G,value:J,timestamp:Q}]),this.emit(),G}async get(J,G=null){if(await this.ready,typeof J!=="string")return console.error("Parameter must be a valid ID (string)."),{result:null};const Q=this.graph.get(J);if(!Q)return console.error(`Node with ID '${J}' not found.`),{result:null};if(!G)return{result:Q};G(Q);const q=(W)=>{const X=W.find((Y)=>Y.id===J);if(X&&Q&&X.timestamp){if(this.hybridClock.compare(X.timestamp,Q.timestamp)>0)Q.value=X.value,Q.timestamp=X.timestamp,G(X)}};return this.eventListeners.push(q),{result:Q,...G&&{unsubscribe:()=>this.eventListeners.splice(this.eventListeners.indexOf(q),1)}}}async map(...J){await this.ready;let Q={...{realtime:!1,query:{},field:null,order:"asc",$limit:null,$after:null,$before:null}},q=null,W=!1;J.forEach((K)=>typeof K==="function"?q=K:K&&typeof K==="object"&&(W||=("realtime"in K),Object.assign(Q,K))),q&&!W&&(Q.realtime=!0);let X=zQ(this.graph.nodes,Q),Y=null;const U=(K)=>{const V=K.filter((z)=>!X.some((D)=>D.id===z.id)),Z=X.filter((z)=>!K.some((D)=>D.id===z.id)),H=K.filter((z)=>{const D=X.find((j)=>j.id===z.id);return D&&!i5(E0(z.value),E0(D.value))}),$=(z,D)=>{const j=D==="removed"?null:z.value,M={id:z.id,value:j,edges:z.edges||[],timestamp:z.timestamp||null,action:D};q(M)};V.forEach((z)=>$(z,"added")),Z.forEach((z)=>$(z,"removed")),H.forEach((z)=>$(z,"updated"))};if(q){if(X.forEach((K)=>{if(K.value)q({id:K.id,value:K.value,edges:K.edges,timestamp:K.timestamp,action:"initial"})}),Q.realtime)Y=(K)=>{const V=zQ(K,Q);if(!i5(E0(V),E0(X)))U(V),X=V},this.on(Y)}return{results:X,...Q.realtime&&{unsubscribe:()=>Y&&this.off(Y)}}}async remove(J){await this.ready;const G=this.hybridClock.now(),Q=this.graph.get(J);if(!Q)return console.error(`Node with ID '${J}' not found.`);delete this.graph.nodes[J],Object.values(this.graph.nodes).forEach((q)=>q.edges=q.edges.filter((W)=>W!==J)),this.addChange(J,G,"remove"),await this.saveGraphToOPFS(),localStorage.setItem(`${this.name}_time`,JSON.stringify(G)),this.sendData([{type:"remove",id:J,value:Q.value,timestamp:G}]),this.emit()}async clear(){await this.ready,this.graph.nodes={};try{await(await navigator.storage.getDirectory()).removeEntry(`${this.name}_graph.msgpack`)}catch({message:J}){console.warn(`Error deleting _graph.msgpack: ${J}`)}console.log("All data has been deleted.")}async link(J,G){await this.ready;const Q=this.hybridClock.now();if(!this.graph.nodes[J]||!this.graph.nodes[G]){console.error(`One or both nodes (${J}, ${G}) do not exist.`);return}this.graph.link(J,G),this.addChange(J,Q,"update"),await this.saveGraphToOPFS(),localStorage.setItem(`${this.name}_time`,JSON.stringify(Q)),this.sendData([{type:"link",sourceId:J,targetId:G,timestamp:Q}]),this.emit()}async applyFullGraph(J){try{this.graph.nodes={...J.nodes},await this.saveGraphToOPFS(),this.emit()}catch({message:G}){console.error(`Error applying the full graph: ${G}`)}}async receiveChanges(J){const G={insert:(Q)=>this.graph.insert(Q.id,Q.value,Q.timestamp),update:(Q)=>{const q=this.graph.get(Q.id),W=l5(q,Q,this.hybridClock);W.resolved&&Object.assign(q,{value:W.value,timestamp:W.timestamp})},remove:(Q)=>delete this.graph.nodes[Q.id],link:(Q)=>this.graph.link(Q.sourceId,Q.targetId),sync:(Q)=>{if(this.hybridClock.compare(this.globalTimestamp,Q.timestamp)>0)console.log("Sending recent data to the remote node."),this.sendData([{type:"syncReceive",graph:this.graph}])},syncReceive:(Q)=>this.applyFullGraph(Q.graph)};for(let Q of J)G[Q.type]?.(Q);await this.saveGraphToOPFS(),this.emit()}}export{o5 as default};
