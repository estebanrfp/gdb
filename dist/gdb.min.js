var X7=Object.create;var{defineProperty:Q1,getPrototypeOf:Y7,getOwnPropertyNames:yq,getOwnPropertyDescriptor:V7}=Object,Eq=Object.prototype.hasOwnProperty;var d1=(J,Q,q)=>{q=J!=null?X7(Y7(J)):{};const G=Q||!J||!J.__esModule?Q1(q,"default",{value:J,enumerable:!0}):q;for(let X of yq(J))if(!Eq.call(G,X))Q1(G,X,{get:()=>J[X],enumerable:!0});return G},hq=(J)=>{const Q=hq.moduleCache??=new WeakMap;var q=Q.get(J);if(q)return q;var G=Q1({},"__esModule",{value:!0}),X={enumerable:!1};if(J&&typeof J==="object"||typeof J==="function"){for(let Y of yq(J))if(!Eq.call(G,Y))Q1(G,Y,{get:()=>J[Y],enumerable:!(X=V7(J,Y))||X.enumerable})}return Q.set(J,G),G};var K0=(J,Q)=>()=>(Q||J((Q={exports:{}}).exports,Q),Q.exports);var mq=(J,Q)=>{for(var q in Q)Q1(J,q,{get:Q[q],enumerable:!0,configurable:!0,set:(G)=>Q[q]=()=>G})};var K7=(J,Q)=>()=>(J&&(Q=J(J=0)),Q);var q5=K0((R$,J5)=>{var MK=function(J){if(J=String(J),J.length>100)return;var Q=/^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(J);if(!Q)return;var q=parseFloat(Q[1]),G=(Q[2]||"ms").toLowerCase();switch(G){case"years":case"year":case"yrs":case"yr":case"y":return q*jK;case"weeks":case"week":case"w":return q*HK;case"days":case"day":case"d":return q*x8;case"hours":case"hour":case"hrs":case"hr":case"h":return q*r8;case"minutes":case"minute":case"mins":case"min":case"m":return q*n8;case"seconds":case"second":case"secs":case"sec":case"s":return q*o8;case"milliseconds":case"millisecond":case"msecs":case"msec":case"ms":return q;default:return}},BK=function(J){var Q=Math.abs(J);if(Q>=x8)return Math.round(J/x8)+"d";if(Q>=r8)return Math.round(J/r8)+"h";if(Q>=n8)return Math.round(J/n8)+"m";if(Q>=o8)return Math.round(J/o8)+"s";return J+"ms"},LK=function(J){var Q=Math.abs(J);if(Q>=x8)return TJ(J,Q,x8,"day");if(Q>=r8)return TJ(J,Q,r8,"hour");if(Q>=n8)return TJ(J,Q,n8,"minute");if(Q>=o8)return TJ(J,Q,o8,"second");return J+" ms"},TJ=function(J,Q,q,G){var X=Q>=q*1.5;return Math.round(J/q)+" "+G+(X?"s":"")},o8=1000,n8=o8*60,r8=n8*60,x8=r8*24,HK=x8*7,jK=x8*365.25;J5.exports=function(J,Q){Q=Q||{};var q=typeof J;if(q==="string"&&J.length>0)return MK(J);else if(q==="number"&&isFinite(J))return Q.long?LK(J):BK(J);throw new Error("val is not a non-empty string or a valid number. val="+JSON.stringify(J))}});var G5=K0((T$,Q5)=>{var PK=function(J){q.debug=q,q.default=q,q.coerce=Z,q.disable=V,q.enable=X,q.enabled=K,q.humanize=q5(),q.destroy=W,Object.keys(J).forEach(($)=>{q[$]=J[$]}),q.names=[],q.skips=[],q.formatters={};function Q($){let B=0;for(let z=0;z<$.length;z++)B=(B<<5)-B+$.charCodeAt(z),B|=0;return q.colors[Math.abs(B)%q.colors.length]}q.selectColor=Q;function q($){let B,z=null,U,M;function H(...j){if(!H.enabled)return;const P=H,x=Number(new Date),F=x-(B||x);if(P.diff=F,P.prev=B,P.curr=x,B=x,j[0]=q.coerce(j[0]),typeof j[0]!=="string")j.unshift("%O");let L=0;j[0]=j[0].replace(/%([a-zA-Z%])/g,(D,O)=>{if(D==="%%")return"%";L++;const S=q.formatters[O];if(typeof S==="function"){const y=j[L];D=S.call(P,y),j.splice(L,1),L--}return D}),q.formatArgs.call(P,j),(P.log||q.log).apply(P,j)}if(H.namespace=$,H.useColors=q.useColors(),H.color=q.selectColor($),H.extend=G,H.destroy=q.destroy,Object.defineProperty(H,"enabled",{enumerable:!0,configurable:!1,get:()=>{if(z!==null)return z;if(U!==q.namespaces)U=q.namespaces,M=q.enabled($);return M},set:(j)=>{z=j}}),typeof q.init==="function")q.init(H);return H}function G($,B){const z=q(this.namespace+(typeof B==="undefined"?":":B)+$);return z.log=this.log,z}function X($){q.save($),q.namespaces=$,q.names=[],q.skips=[];const B=(typeof $==="string"?$:"").trim().replace(" ",",").split(",").filter(Boolean);for(let z of B)if(z[0]==="-")q.skips.push(z.slice(1));else q.names.push(z)}function Y($,B){let z=0,U=0,M=-1,H=0;while(z<$.length)if(U<B.length&&(B[U]===$[z]||B[U]==="*"))if(B[U]==="*")M=U,H=z,U++;else z++,U++;else if(M!==-1)U=M+1,H++,z=H;else return!1;while(U<B.length&&B[U]==="*")U++;return U===B.length}function V(){const $=[...q.names,...q.skips.map((B)=>"-"+B)].join(",");return q.enable(""),$}function K($){for(let B of q.skips)if(Y($,B))return!1;for(let B of q.names)if(Y($,B))return!0;return!1}function Z($){if($ instanceof Error)return $.stack||$.message;return $}function W(){console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.")}return q.enable(q.load()),q};Q5.exports=PK});var Y5=K0((X5,vJ)=>{var kK=function(){if(typeof window!=="undefined"&&window.process&&(window.process.type==="renderer"||window.process.__nwjs))return!0;if(typeof navigator!=="undefined"&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/))return!1;let J;return typeof document!=="undefined"&&document.documentElement&&document.documentElement.style&&document.documentElement.style.WebkitAppearance||typeof window!=="undefined"&&window.console&&(window.console.firebug||window.console.exception&&window.console.table)||typeof navigator!=="undefined"&&navigator.userAgent&&(J=navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/))&&parseInt(J[1],10)>=31||typeof navigator!=="undefined"&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/)},CK=function(J){if(J[0]=(this.useColors?"%c":"")+this.namespace+(this.useColors?" %c":" ")+J[0]+(this.useColors?"%c ":" ")+"+"+X5.humanize(this.diff),!this.useColors)return;const Q="color: "+this.color;J.splice(1,0,Q,"color: inherit");let q=0,G=0;J[0].replace(/%[a-zA-Z%]/g,(X)=>{if(X==="%%")return;if(q++,X==="%c")G=q}),J.splice(G,0,Q)},wK=function(J){try{if(J)X5.storage.setItem("debug",J);else X5.storage.removeItem("debug")}catch(Q){}},NK=function(){let J;try{J=X5.storage.getItem("debug")}catch(Q){}if(!J&&typeof process!=="undefined"&&("env"in process))J=process.env.DEBUG;return J},xK=function(){try{return localStorage}catch(J){}};X5.formatArgs=CK;X5.save=wK;X5.load=NK;X5.useColors=kK;X5.storage=xK();X5.destroy=(()=>{let J=!1;return()=>{if(!J)J=!0,console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.")}})();X5.colors=["#0000CC","#0000FF","#0033CC","#0033FF","#0066CC","#0066FF","#0099CC","#0099FF","#00CC00","#00CC33","#00CC66","#00CC99","#00CCCC","#00CCFF","#3300CC","#3300FF","#3333CC","#3333FF","#3366CC","#3366FF","#3399CC","#3399FF","#33CC00","#33CC33","#33CC66","#33CC99","#33CCCC","#33CCFF","#6600CC","#6600FF","#6633CC","#6633FF","#66CC00","#66CC33","#9900CC","#9900FF","#9933CC","#9933FF","#99CC00","#99CC33","#CC0000","#CC0033","#CC0066","#CC0099","#CC00CC","#CC00FF","#CC3300","#CC3333","#CC3366","#CC3399","#CC33CC","#CC33FF","#CC6600","#CC6633","#CC9900","#CC9933","#CCCC00","#CCCC33","#FF0000","#FF0033","#FF0066","#FF0099","#FF00CC","#FF00FF","#FF3300","#FF3333","#FF3366","#FF3399","#FF33CC","#FF33FF","#FF6600","#FF6633","#FF9900","#FF9933","#FFCC00","#FFCC33"];X5.log=console.debug||console.log||(()=>{});vJ.exports=G5()(X5);var{formatters:OK}=vJ.exports;OK.j=function(J){try{return JSON.stringify(J)}catch(Q){return"[UnexpectedJSONParseError]: "+Q.message}}});var P5={};mq(P5,{prototype:()=>{{return uK}},once:()=>{{return mK}},default:()=>{{return bK}},EventEmitter:()=>{{return u}}});var vK,u,hJ,z5,U5,yK,H5,j5,M5,B5,EK,hK,mK,_K,L5,a8,W5,EJ,$5,Z5,bK,uK;var k5=K7(()=>{vK=function(J){console&&console.warn&&console.warn(J)},u=function(){u.init.call(this)},hJ=function(J){if(typeof J!="function")throw new TypeError('The "listener" argument must be of type Function. Received type '+typeof J)},z5=function(J){return J._maxListeners===void 0?u.defaultMaxListeners:J._maxListeners},U5=function(J,Q,q,G){var X,Y,V;if(hJ(q),Y=J._events,Y===void 0?(Y=J._events=Object.create(null),J._eventsCount=0):(Y.newListener!==void 0&&(J.emit("newListener",Q,q.listener?q.listener:q),Y=J._events),V=Y[Q]),V===void 0)V=Y[Q]=q,++J._eventsCount;else if(typeof V=="function"?V=Y[Q]=G?[q,V]:[V,q]:G?V.unshift(q):V.push(q),X=z5(J),X>0&&V.length>X&&!V.warned){V.warned=!0;var K=new Error("Possible EventEmitter memory leak detected. "+V.length+" "+String(Q)+" listeners added. Use emitter.setMaxListeners() to increase limit");K.name="MaxListenersExceededWarning",K.emitter=J,K.type=Q,K.count=V.length,vK(K)}return J},yK=function(){if(!this.fired)return this.target.removeListener(this.type,this.wrapFn),this.fired=!0,arguments.length===0?this.listener.call(this.target):this.listener.apply(this.target,arguments)},H5=function(J,Q,q){var G={fired:!1,wrapFn:void 0,target:J,type:Q,listener:q},X=yK.bind(G);return X.listener=q,G.wrapFn=X,X},j5=function(J,Q,q){var G=J._events;if(G===void 0)return[];var X=G[Q];return X===void 0?[]:typeof X=="function"?q?[X.listener||X]:[X]:q?hK(X):B5(X,X.length)},M5=function(J){var Q=this._events;if(Q!==void 0){var q=Q[J];if(typeof q=="function")return 1;if(q!==void 0)return q.length}return 0},B5=function(J,Q){for(var q=new Array(Q),G=0;G<Q;++G)q[G]=J[G];return q},EK=function(J,Q){for(;Q+1<J.length;Q++)J[Q]=J[Q+1];J.pop()},hK=function(J){for(var Q=new Array(J.length),q=0;q<Q.length;++q)Q[q]=J[q].listener||J[q];return Q},mK=function(J,Q){return new Promise(function(q,G){function X(V){J.removeListener(Q,Y),G(V)}function Y(){typeof J.removeListener=="function"&&J.removeListener("error",X),q([].slice.call(arguments))}L5(J,Q,Y,{once:!0}),Q!=="error"&&_K(J,X,{once:!0})})},_K=function(J,Q,q){typeof J.on=="function"&&L5(J,"error",Q,q)},L5=function(J,Q,q,G){if(typeof J.on=="function")G.once?J.once(Q,q):J.on(Q,q);else if(typeof J.addEventListener=="function")J.addEventListener(Q,function X(Y){G.once&&J.removeEventListener(Q,X),q(Y)});else throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type '+typeof J)},a8=typeof Reflect=="object"?Reflect:null,W5=a8&&typeof a8.apply=="function"?a8.apply:function(J,Q,q){return Function.prototype.apply.call(J,Q,q)};a8&&typeof a8.ownKeys=="function"?EJ=a8.ownKeys:Object.getOwnPropertySymbols?EJ=function(J){return Object.getOwnPropertyNames(J).concat(Object.getOwnPropertySymbols(J))}:EJ=function(J){return Object.getOwnPropertyNames(J)};$5=Number.isNaN||function(J){return J!==J};u.EventEmitter=u;u.prototype._events=void 0;u.prototype._eventsCount=0;u.prototype._maxListeners=void 0;Z5=10;Object.defineProperty(u,"defaultMaxListeners",{enumerable:!0,get:function(){return Z5},set:function(J){if(typeof J!="number"||J<0||$5(J))throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received '+J+".");Z5=J}});u.init=function(){(this._events===void 0||this._events===Object.getPrototypeOf(this)._events)&&(this._events=Object.create(null),this._eventsCount=0),this._maxListeners=this._maxListeners||void 0};u.prototype.setMaxListeners=function(J){if(typeof J!="number"||J<0||$5(J))throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received '+J+".");return this._maxListeners=J,this};u.prototype.getMaxListeners=function(){return z5(this)};u.prototype.emit=function(J){for(var Q=[],q=1;q<arguments.length;q++)Q.push(arguments[q]);var G=J==="error",X=this._events;if(X!==void 0)G=G&&X.error===void 0;else if(!G)return!1;if(G){var Y;if(Q.length>0&&(Y=Q[0]),Y instanceof Error)throw Y;var V=new Error("Unhandled error."+(Y?" ("+Y.message+")":""));throw V.context=Y,V}var K=X[J];if(K===void 0)return!1;if(typeof K=="function")W5(K,this,Q);else for(var Z=K.length,W=B5(K,Z),q=0;q<Z;++q)W5(W[q],this,Q);return!0};u.prototype.addListener=function(J,Q){return U5(this,J,Q,!1)};u.prototype.on=u.prototype.addListener;u.prototype.prependListener=function(J,Q){return U5(this,J,Q,!0)};u.prototype.once=function(J,Q){return hJ(Q),this.on(J,H5(this,J,Q)),this};u.prototype.prependOnceListener=function(J,Q){return hJ(Q),this.prependListener(J,H5(this,J,Q)),this};u.prototype.removeListener=function(J,Q){var q,G,X,Y,V;if(hJ(Q),G=this._events,G===void 0)return this;if(q=G[J],q===void 0)return this;if(q===Q||q.listener===Q)--this._eventsCount===0?this._events=Object.create(null):(delete G[J],G.removeListener&&this.emit("removeListener",J,q.listener||Q));else if(typeof q!="function"){for(X=-1,Y=q.length-1;Y>=0;Y--)if(q[Y]===Q||q[Y].listener===Q){V=q[Y].listener,X=Y;break}if(X<0)return this;X===0?q.shift():EK(q,X),q.length===1&&(G[J]=q[0]),G.removeListener!==void 0&&this.emit("removeListener",J,V||Q)}return this};u.prototype.off=u.prototype.removeListener;u.prototype.removeAllListeners=function(J){var Q,q,G;if(q=this._events,q===void 0)return this;if(q.removeListener===void 0)return arguments.length===0?(this._events=Object.create(null),this._eventsCount=0):q[J]!==void 0&&(--this._eventsCount===0?this._events=Object.create(null):delete q[J]),this;if(arguments.length===0){var X=Object.keys(q),Y;for(G=0;G<X.length;++G)Y=X[G],Y!=="removeListener"&&this.removeAllListeners(Y);return this.removeAllListeners("removeListener"),this._events=Object.create(null),this._eventsCount=0,this}if(Q=q[J],typeof Q=="function")this.removeListener(J,Q);else if(Q!==void 0)for(G=Q.length-1;G>=0;G--)this.removeListener(J,Q[G]);return this};u.prototype.listeners=function(J){return j5(this,J,!0)};u.prototype.rawListeners=function(J){return j5(this,J,!1)};u.listenerCount=function(J,Q){return typeof J.listenerCount=="function"?J.listenerCount(Q):M5.call(J,Q)};u.prototype.listenerCount=M5;u.prototype.eventNames=function(){return this._eventsCount>0?EJ(this._events):[]};bK=u,uK=u.prototype});var w5=K0((r$,C5)=>{C5.exports=class J{constructor(Q){if(!(Q>0)||(Q-1&Q)!==0)throw new Error("Max size for a FixedFIFO should be a power of two");this.buffer=new Array(Q),this.mask=Q-1,this.top=0,this.btm=0,this.next=null}clear(){this.top=this.btm=0,this.next=null,this.buffer.fill(void 0)}push(Q){if(this.buffer[this.top]!==void 0)return!1;return this.buffer[this.top]=Q,this.top=this.top+1&this.mask,!0}shift(){const Q=this.buffer[this.btm];if(Q===void 0)return;return this.buffer[this.btm]=void 0,this.btm=this.btm+1&this.mask,Q}peek(){return this.buffer[this.btm]}isEmpty(){return this.buffer[this.btm]===void 0}}});var O5=K0((a$,x5)=>{var N5=w5();x5.exports=class J{constructor(Q){this.hwm=Q||16,this.head=new N5(this.hwm),this.tail=this.head,this.length=0}clear(){this.head=this.tail,this.head.clear(),this.length=0}push(Q){if(this.length++,!this.head.push(Q)){const q=this.head;this.head=q.next=new N5(2*this.head.buffer.length),this.head.push(Q)}}shift(){if(this.length!==0)this.length--;const Q=this.tail.shift();if(Q===void 0&&this.tail.next){const q=this.tail.next;return this.tail.next=null,this.tail=q,this.tail.shift()}return Q}peek(){const Q=this.tail.peek();if(Q===void 0&&this.tail.next)return this.tail.next.peek();return Q}isEmpty(){return this.length===0}}});var D5=K0((s$,S5)=>{var F5=function(J){return J.length},cK=function(J){const Q=J.byteLength;let q="";for(let G=0;G<Q;G++)q+=String.fromCharCode(J[G]);return q},pK=function(J,Q,q=0,G=F5(Q)){const X=Math.min(G,J.byteLength-q);for(let Y=0;Y<X;Y++)J[q+Y]=Q.charCodeAt(Y);return X};S5.exports={byteLength:F5,toString:cK,write:pK}});var R5=K0((t$,A5)=>{var I5=function(J){let Q=J.length;if(J.charCodeAt(Q-1)===61)Q--;if(Q>1&&J.charCodeAt(Q-1)===61)Q--;return Q*3>>>2},fK=function(J){const Q=J.byteLength;let q="";for(let G=0;G<Q;G+=3)q+="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"[J[G]>>2]+"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"[(J[G]&3)<<4|J[G+1]>>4]+"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"[(J[G+1]&15)<<2|J[G+2]>>6]+"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"[J[G+2]&63];if(Q%3===2)q=q.substring(0,q.length-1)+"=";else if(Q%3===1)q=q.substring(0,q.length-2)+"==";return q},lK=function(J,Q,q=0,G=I5(Q)){const X=Math.min(G,J.byteLength-q);for(let Y=0,V=0;V<X;Y+=4){const K=O8[Q.charCodeAt(Y)],Z=O8[Q.charCodeAt(Y+1)],W=O8[Q.charCodeAt(Y+2)],$=O8[Q.charCodeAt(Y+3)];J[V++]=K<<2|Z>>4,J[V++]=(Z&15)<<4|W>>2,J[V++]=(W&3)<<6|$&63}return X},O8=new Uint8Array(256);for(let J=0;J<"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".length;J++)O8["ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".charCodeAt(J)]=J;O8[45]=62;O8[95]=63;A5.exports={byteLength:I5,toString:fK,write:lK}});var y5=K0((e$,v5)=>{var g5=function(J){return J.length>>>1},dK=function(J){const Q=J.byteLength;J=new DataView(J.buffer,J.byteOffset,Q);let q="",G=0;for(let X=Q-Q%4;G<X;G+=4)q+=J.getUint32(G).toString(16).padStart(8,"0");for(;G<Q;G++)q+=J.getUint8(G).toString(16).padStart(2,"0");return q},iK=function(J,Q,q=0,G=g5(Q)){const X=Math.min(G,J.byteLength-q);for(let Y=0;Y<X;Y++){const V=T5(Q.charCodeAt(Y*2)),K=T5(Q.charCodeAt(Y*2+1));if(V===void 0||K===void 0)return J.subarray(0,Y);J[q+Y]=V<<4|K}return X},T5=function(J){if(J>=48&&J<=57)return J-48;if(J>=65&&J<=70)return J-65+10;if(J>=97&&J<=102)return J-97+10};v5.exports={byteLength:g5,toString:dK,write:iK}});var h5=K0((Jz,E5)=>{var Wq=function(J){let Q=0;for(let q=0,G=J.length;q<G;q++){const X=J.charCodeAt(q);if(X>=55296&&X<=56319&&q+1<G){const Y=J.charCodeAt(q+1);if(Y>=56320&&Y<=57343){Q+=4,q++;continue}}if(X<=127)Q+=1;else if(X<=2047)Q+=2;else Q+=3}return Q},Zq;if(typeof TextDecoder!=="undefined"){const J=new TextDecoder;Zq=function Q(q){return J.decode(q)}}else Zq=function J(Q){const q=Q.byteLength;let G="",X=0;while(X<q){let Y=Q[X];if(Y<=127){G+=String.fromCharCode(Y),X++;continue}let V=0,K=0;if(Y<=223)V=1,K=Y&31;else if(Y<=239)V=2,K=Y&15;else if(Y<=244)V=3,K=Y&7;if(q-X-V>0){let Z=0;while(Z<V)Y=Q[X+Z+1],K=K<<6|Y&63,Z+=1}else K=65533,V=q-X;G+=String.fromCodePoint(K),X+=V+1}return G};var $q;if(typeof TextEncoder!=="undefined"){const J=new TextEncoder;$q=function Q(q,G,X=0,Y=Wq(G)){const V=Math.min(Y,q.byteLength-X);return J.encodeInto(G,q.subarray(X,X+V)),V}}else $q=function J(Q,q,G=0,X=Wq(q)){const Y=Math.min(X,Q.byteLength-G);Q=Q.subarray(G,G+Y);let V=0,K=0;while(V<q.length){const Z=q.codePointAt(V);if(Z<=127){Q[K++]=Z,V++;continue}let W=0,$=0;if(Z<=2047)W=6,$=192;else if(Z<=65535)W=12,$=224;else if(Z<=2097151)W=18,$=240;Q[K++]=$|Z>>W,W-=6;while(W>=0)Q[K++]=128|Z>>W&63,W-=6;V+=Z>=65536?2:1}return Y};E5.exports={byteLength:Wq,toString:Zq,write:$q}});var b5=K0((qz,_5)=>{var m5=function(J){return J.length*2},oK=function(J){const Q=J.byteLength;let q="";for(let G=0;G<Q-1;G+=2)q+=String.fromCharCode(J[G]+J[G+1]*256);return q},nK=function(J,Q,q=0,G=m5(Q)){const X=Math.min(G,J.byteLength-q);let Y=X;for(let V=0;V<Q.length;++V){if((Y-=2)<0)break;const K=Q.charCodeAt(V),Z=K>>8,W=K%256;J[q+V*2]=W,J[q+V*2+1]=Z}return X};_5.exports={byteLength:m5,toString:oK,write:nK}});var Uq=K0((f5,l5)=>{var v1=function(J){switch(J){case"ascii":return rK;case"base64":return aK;case"hex":return sK;case"utf8":case"utf-8":case void 0:case null:return tK;case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return eK;default:throw new Error(`Unknown encoding: ${J}`)}},u5=function(J){return J instanceof Uint8Array},JW=function(J){try{return v1(J),!0}catch{return!1}},qW=function(J,Q,q){const G=new Uint8Array(J);if(Q!==void 0)f5.fill(G,Q,0,G.byteLength,q);return G},QW=function(J){return new Uint8Array(J)},GW=function(J){return new Uint8Array(J)},XW=function(J,Q){return v1(Q).byteLength(J)},YW=function(J,Q){if(J===Q)return 0;const q=Math.min(J.byteLength,Q.byteLength);J=new DataView(J.buffer,J.byteOffset,J.byteLength),Q=new DataView(Q.buffer,Q.byteOffset,Q.byteLength);let G=0;for(let X=q-q%4;G<X;G+=4){const Y=J.getUint32(G,mJ),V=Q.getUint32(G,mJ);if(Y!==V)break}for(;G<q;G++){const X=J.getUint8(G),Y=Q.getUint8(G);if(X<Y)return-1;if(X>Y)return 1}return J.byteLength>Q.byteLength?1:J.byteLength<Q.byteLength?-1:0},VW=function(J,Q){if(Q===void 0)Q=J.reduce((X,Y)=>X+Y.byteLength,0);const q=new Uint8Array(Q);let G=0;for(let X of J){if(G+X.byteLength>q.byteLength){const Y=X.subarray(0,q.byteLength-G);return q.set(Y,G),q}q.set(X,G),G+=X.byteLength}return q},KW=function(J,Q,q=0,G=0,X=J.byteLength){if(X>0&&X<G)return 0;if(X===G)return 0;if(J.byteLength===0||Q.byteLength===0)return 0;if(q<0)throw new RangeError("targetStart is out of range");if(G<0||G>=J.byteLength)throw new RangeError("sourceStart is out of range");if(X<0)throw new RangeError("sourceEnd is out of range");if(q>=Q.byteLength)q=Q.byteLength;if(X>J.byteLength)X=J.byteLength;if(Q.byteLength-q<X-G)X=Q.length-q+G;const Y=X-G;if(J===Q)Q.copyWithin(q,G,X);else Q.set(J.subarray(G,X),q);return Y},WW=function(J,Q){if(J===Q)return!0;if(J.byteLength!==Q.byteLength)return!1;const q=J.byteLength;J=new DataView(J.buffer,J.byteOffset,J.byteLength),Q=new DataView(Q.buffer,Q.byteOffset,Q.byteLength);let G=0;for(let X=q-q%4;G<X;G+=4)if(J.getUint32(G,mJ)!==Q.getUint32(G,mJ))return!1;for(;G<q;G++)if(J.getUint8(G)!==Q.getUint8(G))return!1;return!0},ZW=function(J,Q,q,G,X){if(typeof Q==="string"){if(typeof q==="string")X=q,q=0,G=J.byteLength;else if(typeof G==="string")X=G,G=J.byteLength}else if(typeof Q==="number")Q=Q&255;else if(typeof Q==="boolean")Q=+Q;if(q<0||J.byteLength<q||J.byteLength<G)throw new RangeError("Out of range index");if(q===void 0)q=0;if(G===void 0)G=J.byteLength;if(G<=q)return J;if(!Q)Q=0;if(typeof Q==="number")for(let Y=q;Y<G;++Y)J[Y]=Q;else{Q=u5(Q)?Q:zq(Q,X);const Y=Q.byteLength;for(let V=0;V<G-q;++V)J[V+q]=Q[V%Y]}return J},zq=function(J,Q,q){if(typeof J==="string")return $W(J,Q);if(Array.isArray(J))return zW(J);if(ArrayBuffer.isView(J))return UW(J);return HW(J,Q,q)},$W=function(J,Q){const q=v1(Q),G=new Uint8Array(q.byteLength(J));return q.write(G,J,0,G.byteLength),G},zW=function(J){const Q=new Uint8Array(J.length);return Q.set(J),Q},UW=function(J){const Q=new Uint8Array(J.byteLength);return Q.set(J),Q},HW=function(J,Q,q){return new Uint8Array(J,Q,q)},jW=function(J,Q,q,G){return p5(J,Q,q,G)!==-1},c5=function(J,Q,q,G,X){if(J.byteLength===0)return-1;if(typeof q==="string")G=q,q=0;else if(q===void 0)q=X?0:J.length-1;else if(q<0)q+=J.byteLength;if(q>=J.byteLength)if(X)return-1;else q=J.byteLength-1;else if(q<0)if(X)q=0;else return-1;if(typeof Q==="string")Q=zq(Q,G);else if(typeof Q==="number")if(Q=Q&255,X)return J.indexOf(Q,q);else return J.lastIndexOf(Q,q);if(Q.byteLength===0)return-1;if(X){let Y=-1;for(let V=q;V<J.byteLength;V++)if(J[V]===Q[Y===-1?0:V-Y]){if(Y===-1)Y=V;if(V-Y+1===Q.byteLength)return Y}else{if(Y!==-1)V-=V-Y;Y=-1}}else{if(q+Q.byteLength>J.byteLength)q=J.byteLength-Q.byteLength;for(let Y=q;Y>=0;Y--){let V=!0;for(let K=0;K<Q.byteLength;K++)if(J[Y+K]!==Q[K]){V=!1;break}if(V)return Y}}return-1},p5=function(J,Q,q,G){return c5(J,Q,q,G,!0)},MW=function(J,Q,q,G){return c5(J,Q,q,G,!1)},F8=function(J,Q,q){const G=J[Q];J[Q]=J[q],J[q]=G},BW=function(J){const Q=J.byteLength;if(Q%2!==0)throw new RangeError("Buffer size must be a multiple of 16-bits");for(let q=0;q<Q;q+=2)F8(J,q,q+1);return J},LW=function(J){const Q=J.byteLength;if(Q%4!==0)throw new RangeError("Buffer size must be a multiple of 32-bits");for(let q=0;q<Q;q+=4)F8(J,q,q+3),F8(J,q+1,q+2);return J},PW=function(J){const Q=J.byteLength;if(Q%8!==0)throw new RangeError("Buffer size must be a multiple of 64-bits");for(let q=0;q<Q;q+=8)F8(J,q,q+7),F8(J,q+1,q+6),F8(J,q+2,q+5),F8(J,q+3,q+4);return J},kW=function(J){return J},CW=function(J,Q,q=0,G=J.byteLength){const X=J.byteLength;if(q>=X)return"";if(G<=q)return"";if(q<0)q=0;if(G>X)G=X;if(q!==0||G<X)J=J.subarray(q,G);return v1(Q).toString(J)},wW=function(J,Q,q,G,X){if(q===void 0)X="utf8";else if(G===void 0&&typeof q==="string")X=q,q=void 0;else if(X===void 0&&typeof G==="string")X=G,G=void 0;return v1(X).write(J,Q,q,G)},NW=function(J,Q,q){if(q===void 0)q=0;return new DataView(J.buffer,J.byteOffset,J.byteLength).setFloat64(q,Q,!0),q+8},xW=function(J,Q,q){if(q===void 0)q=0;return new DataView(J.buffer,J.byteOffset,J.byteLength).setFloat32(q,Q,!0),q+4},OW=function(J,Q,q){if(q===void 0)q=0;return new DataView(J.buffer,J.byteOffset,J.byteLength).setUint32(q,Q,!0),q+4},FW=function(J,Q,q){if(q===void 0)q=0;return new DataView(J.buffer,J.byteOffset,J.byteLength).setInt32(q,Q,!0),q+4},SW=function(J,Q){if(Q===void 0)Q=0;return new DataView(J.buffer,J.byteOffset,J.byteLength).getFloat64(Q,!0)},DW=function(J,Q){if(Q===void 0)Q=0;return new DataView(J.buffer,J.byteOffset,J.byteLength).getFloat32(Q,!0)},IW=function(J,Q){if(Q===void 0)Q=0;return new DataView(J.buffer,J.byteOffset,J.byteLength).getUint32(Q,!0)},AW=function(J,Q){if(Q===void 0)Q=0;return new DataView(J.buffer,J.byteOffset,J.byteLength).getInt32(Q,!0)},RW=function(J,Q,q){if(q===void 0)q=0;return new DataView(J.buffer,J.byteOffset,J.byteLength).setFloat64(q,Q,!1),q+8},TW=function(J,Q,q){if(q===void 0)q=0;return new DataView(J.buffer,J.byteOffset,J.byteLength).setFloat32(q,Q,!1),q+4},gW=function(J,Q,q){if(q===void 0)q=0;return new DataView(J.buffer,J.byteOffset,J.byteLength).setUint32(q,Q,!1),q+4},vW=function(J,Q,q){if(q===void 0)q=0;return new DataView(J.buffer,J.byteOffset,J.byteLength).setInt32(q,Q,!1),q+4},yW=function(J,Q){if(Q===void 0)Q=0;return new DataView(J.buffer,J.byteOffset,J.byteLength).getFloat64(Q,!1)},EW=function(J,Q){if(Q===void 0)Q=0;return new DataView(J.buffer,J.byteOffset,J.byteLength).getFloat32(Q,!1)},hW=function(J,Q){if(Q===void 0)Q=0;return new DataView(J.buffer,J.byteOffset,J.byteLength).getUint32(Q,!1)},mW=function(J,Q){if(Q===void 0)Q=0;return new DataView(J.buffer,J.byteOffset,J.byteLength).getInt32(Q,!1)},rK=D5(),aK=R5(),sK=y5(),tK=h5(),eK=b5(),mJ=new Uint8Array(Uint16Array.of(255).buffer)[0]===255;l5.exports=f5={isBuffer:u5,isEncoding:JW,alloc:qW,allocUnsafe:QW,allocUnsafeSlow:GW,byteLength:XW,compare:YW,concat:VW,copy:KW,equals:WW,fill:ZW,from:zq,includes:jW,indexOf:p5,lastIndexOf:MW,swap16:BW,swap32:LW,swap64:PW,toBuffer:kW,toString:CW,write:wW,writeDoubleLE:NW,writeFloatLE:xW,writeUInt32LE:OW,writeInt32LE:FW,readDoubleLE:SW,readFloatLE:DW,readUInt32LE:IW,readInt32LE:AW,writeDoubleBE:RW,writeFloatBE:TW,writeUInt32BE:gW,writeInt32BE:vW,readDoubleBE:yW,readFloatBE:EW,readUInt32BE:hW,readInt32BE:mW}});var i5=K0((Gz,d5)=>{var _W=Uq();d5.exports=class J{constructor(Q){this.encoding=Q}decode(Q){return _W.toString(Q,this.encoding)}flush(){return""}}});var n5=K0((Xz,o5)=>{var bW=Uq();o5.exports=class J{constructor(){this.codePoint=0,this.bytesSeen=0,this.bytesNeeded=0,this.lowerBoundary=128,this.upperBoundary=191}decode(Q){if(this.bytesNeeded===0){let G=!0;for(let X=Math.max(0,Q.byteLength-4),Y=Q.byteLength;X<Y&&G;X++)G=Q[X]<=127;if(G)return bW.toString(Q,"utf8")}let q="";for(let G=0,X=Q.byteLength;G<X;G++){const Y=Q[G];if(this.bytesNeeded===0){if(Y<=127)q+=String.fromCharCode(Y);else if(Y>=194&&Y<=223)this.bytesNeeded=1,this.codePoint=Y&31;else if(Y>=224&&Y<=239){if(Y===224)this.lowerBoundary=160;else if(Y===237)this.upperBoundary=159;this.bytesNeeded=2,this.codePoint=Y&15}else if(Y>=240&&Y<=244){if(Y===240)this.lowerBoundary=144;if(Y===244)this.upperBoundary=143;this.bytesNeeded=3,this.codePoint=Y&7}else q+="\uFFFD";continue}if(Y<this.lowerBoundary||Y>this.upperBoundary){this.codePoint=0,this.bytesNeeded=0,this.bytesSeen=0,this.lowerBoundary=128,this.upperBoundary=191,q+="\uFFFD";continue}if(this.lowerBoundary=128,this.upperBoundary=191,this.codePoint=this.codePoint<<6|Y&63,this.bytesSeen++,this.bytesSeen!==this.bytesNeeded)continue;q+=String.fromCodePoint(this.codePoint),this.codePoint=0,this.bytesNeeded=0,this.bytesSeen=0}return q}flush(){const Q=this.bytesNeeded>0?"\uFFFD":"";return this.codePoint=0,this.bytesNeeded=0,this.bytesSeen=0,this.lowerBoundary=128,this.upperBoundary=191,Q}}});var a5=K0((Yz,r5)=>{var pW=function(J){switch(J=J.toLowerCase(),J){case"utf8":case"utf-8":return"utf8";case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return"utf16le";case"latin1":case"binary":return"latin1";case"base64":case"ascii":case"hex":return J;default:throw new Error("Unknown encoding: "+J)}},uW=i5(),cW=n5();r5.exports=class J{constructor(Q="utf8"){switch(this.encoding=pW(Q),this.encoding){case"utf8":this.decoder=new cW;break;case"utf16le":case"base64":throw new Error("Unsupported encoding: "+this.encoding);default:this.decoder=new uW(this.encoding)}}push(Q){if(typeof Q==="string")return Q;return this.decoder.decode(Q)}write(Q){return this.push(Q)}end(Q){let q="";if(Q)q=this.push(Q);return q+=this.decoder.flush(),q}}});var OG=K0((Vz,xG)=>{var S4=function(){this.stream._duplexState|=Bq,this.updateCallback()},D4=function(J){const Q=this.stream;if(J)Q.destroy(J);if((Q._duplexState&v0)===0)Q._duplexState|=X8,Q.emit("finish");if((Q._duplexState&zG)===wq)Q._duplexState|=4;if(Q._duplexState&=X4,(Q._duplexState&e8)===0)this.update();else this.updateNextTick()},LG=function(J){const Q=this.stream;if(!J&&this.error!==bJ)J=this.error;if(J)Q.emit("error",J);Q._duplexState|=8,Q.emit("close");const{_readableState:q,_writableState:G}=Q;if(q!==null&&q.pipeline!==null)q.pipeline.done(Q,J);if(G!==null){while(G.drains!==null&&G.drains.length>0)G.drains.shift().resolve(!1);if(G.pipeline!==null)G.pipeline.done(Q,J)}},I4=function(J){const Q=this.stream;if(J)Q.destroy(J);if(Q._duplexState&=G4,this.drains!==null)g4(this.drains);if((Q._duplexState&k4)===u1){if(Q._duplexState&=Y4,(Q._duplexState&Mq)===Mq)Q.emit("drain")}this.updateCallback()},A4=function(J){if(J)this.stream.destroy(J);if(this.stream._duplexState&=rW,this.readAhead===!1&&(this.stream._duplexState&_1)===0)this.stream._duplexState&=VG;this.updateCallback()},R4=function(){if((this.stream._duplexState&s8)===0)this.stream._duplexState&=YG,this.update()},T4=function(){if((this.stream._duplexState&e8)===0)this.stream._duplexState&=WG,this.update()},g4=function(J){for(let Q=0;Q<J.length;Q++)if(--J[Q].writes===0)J.shift().resolve(!0),Q--},PG=function(J){const Q=this.stream;if(J)Q.destroy(J);if((Q._duplexState&4)===0){if((Q._duplexState&$4)===0)Q._duplexState|=J1;if((Q._duplexState&L4)===0)Q._duplexState|=b1;Q.emit("open")}if(Q._duplexState&=$G,Q._writableState!==null)Q._writableState.updateCallback();if(Q._readableState!==null)Q._readableState.updateCallback()},v4=function(J,Q){if(Q!==void 0&&Q!==null)this.push(Q);this._writableState.afterWrite(J)},y4=function(J){if(this._readableState!==null){if(J==="data")this._duplexState|=jq|kq,this._readableState.updateNextTick();if(J==="readable")this._duplexState|=Lq,this._readableState.updateNextTick()}if(this._writableState!==null){if(J==="drain")this._duplexState|=Mq,this._writableState.updateNextTick()}},E4=function(J,Q){const q=this._transformState.afterFinal;if(J)return q(J);if(Q!==null&&Q!==void 0)this.push(Q);this.push(null),q(null)},h4=function(...J){return new Promise((Q,q)=>{return CG(...J,(G)=>{if(G)return q(G);Q()})})},CG=function(J,...Q){const q=Array.isArray(J)?[...J,...Q]:[J,...Q],G=q.length&&typeof q[q.length-1]==="function"?q.pop():null;if(q.length<2)throw new Error("Pipeline requires at least 2 streams");let X=q[0],Y=null,V=null;for(let W=1;W<q.length;W++){if(Y=q[W],h1(X))X.pipe(Y,Z);else K(X,!0,W>1,Z),X.pipe(Y);X=Y}if(G){let W=!1;const $=h1(Y)||!!(Y._writableState&&Y._writableState.autoDestroy);if(Y.on("error",(B)=>{if(V===null)V=B}),Y.on("finish",()=>{if(W=!0,!$)G(V)}),$)Y.on("close",()=>G(V||(W?null:Hq)))}return Y;function K(W,$,B,z){W.on("error",z),W.on("close",U);function U(){if($&&W._readableState&&!W._readableState.ended)return z(Hq);if(B&&W._writableState&&!W._writableState.ended)return z(Hq)}}function Z(W){if(!W||V)return;V=W;for(let $ of q)$.destroy(W)}},m4=function(J){return J},wG=function(J){return!!J._readableState||!!J._writableState},h1=function(J){return typeof J._duplexState==="number"&&wG(J)},_4=function(J){return!!J._readableState&&J._readableState.ended},b4=function(J){return!!J._writableState&&J._writableState.ended},u4=function(J,Q={}){const q=J._readableState&&J._readableState.error||J._writableState&&J._writableState.error;return!Q.all&&q===bJ?null:q},c4=function(J){return h1(J)&&J.readable},p4=function(J){return(J._duplexState&1)!==1||(J._duplexState&pJ)!==0},f4=function(J){return typeof J==="object"&&J!==null&&typeof J.byteLength==="number"},NG=function(J){return f4(J)?J.byteLength:1024},qG=function(){},l4=function(){this.destroy(new Error("Stream aborted."))},d4=function(J){return J._writev!==xq.prototype._writev&&J._writev!==lJ.prototype._writev},{EventEmitter:fW}=(k5(),hq(P5)),bJ=new Error("Stream was destroyed"),Hq=new Error("Premature close"),QG=O5(),lW=a5(),o=(1<<29)-1,GG=o^1,dW=o^2,m1=1<<4,s8=2<<4,J1=4<<4,G8=8<<4,_1=16<<4,Bq=32<<4,S8=64<<4,jq=128<<4,Lq=256<<4,Pq=512<<4,F0=1024<<4,Q8=2048<<4,uJ=4096<<4,D8=8192<<4,XG=_1|Bq,iW=m1|uJ,oW=J1|m1,nW=Lq|G8,kq=_1|D8,rW=o^m1,aW=o^J1,sW=o^(J1|uJ),s5=o^uJ,tW=o^_1,eW=o^(G8|Pq),J4=o^S8,t5=o^XG,YG=o^Q8,q4=o^s8,VG=o^D8,Q4=o^kq,f0=1<<18,e8=2<<18,b1=4<<18,I8=8<<18,u1=16<<18,X8=32<<18,Mq=64<<18,t8=128<<18,Cq=256<<18,A8=512<<18,cJ=1024<<18,G4=o^(f0|Cq),KG=o^b1,X4=o^(f0|A8),Y4=o^u1,V4=o^I8,WG=o^t8,K4=o^e8,ZG=o^cJ,y1=m1|f0,$G=o^y1,wq=F0|X8,v0=4|8|2,L0=v0|1,zG=v0|wq,W4=KG&aW,pJ=t8|Q8,Z4=pJ&$G,UG=L0|Z4,$4=L0|S8|F0,e5=L0|F0|G8,z4=L0|S8|G8,U4=L0|Lq|G8|Pq,H4=L0|m1|S8|F0|uJ|D8,j4=v0|S8|F0,M4=s8|L0|Q8|J1,B4=Q8|1,L4=L0|A8|X8,P4=I8|u1,HG=I8|f0,k4=I8|u1|L0|f0,JG=L0|f0|I8|cJ,C4=b1|f0,w4=f0|Cq,N4=L0|A8|HG|X8,x4=u1|v0|A8|X8,O4=e8|L0|t8|b1,F4=A8|X8|v0,_J=Symbol.asyncIterator||Symbol("asyncIterator");class Nq{constructor(J,{highWaterMark:Q=16384,map:q=null,mapWritable:G,byteLength:X,byteLengthWritable:Y}={}){this.stream=J,this.queue=new QG,this.highWaterMark=Q,this.buffered=0,this.error=null,this.pipeline=null,this.drains=null,this.byteLength=Y||X||NG,this.map=G||q,this.afterWrite=I4.bind(this),this.afterUpdateNextTick=T4.bind(this)}get ended(){return(this.stream._duplexState&X8)!==0}push(J){if((this.stream._duplexState&F4)!==0)return!1;if(this.map!==null)J=this.map(J);if(this.buffered+=this.byteLength(J),this.queue.push(J),this.buffered<this.highWaterMark)return this.stream._duplexState|=I8,!0;return this.stream._duplexState|=P4,!1}shift(){const J=this.queue.shift();if(this.buffered-=this.byteLength(J),this.buffered===0)this.stream._duplexState&=V4;return J}end(J){if(typeof J==="function")this.stream.once("finish",J);else if(J!==void 0&&J!==null)this.push(J);this.stream._duplexState=(this.stream._duplexState|A8)&KG}autoBatch(J,Q){const q=[],G=this.stream;q.push(J);while((G._duplexState&JG)===HG)q.push(G._writableState.shift());if((G._duplexState&L0)!==0)return Q(null);G._writev(q,Q)}update(){const J=this.stream;J._duplexState|=e8;do{while((J._duplexState&JG)===I8){const Q=this.shift();J._duplexState|=w4,J._write(Q,this.afterWrite)}if((J._duplexState&C4)===0)this.updateNonPrimary()}while(this.continueUpdate()===!0);J._duplexState&=K4}updateNonPrimary(){const J=this.stream;if((J._duplexState&N4)===A8){J._duplexState=J._duplexState|f0,J._final(D4.bind(this));return}if((J._duplexState&v0)===4){if((J._duplexState&pJ)===0)J._duplexState|=y1,J._destroy(LG.bind(this));return}if((J._duplexState&UG)===1)J._duplexState=(J._duplexState|y1)&GG,J._open(PG.bind(this))}continueUpdate(){if((this.stream._duplexState&t8)===0)return!1;return this.stream._duplexState&=WG,!0}updateCallback(){if((this.stream._duplexState&O4)===b1)this.update();else this.updateNextTick()}updateNextTick(){if((this.stream._duplexState&t8)!==0)return;if(this.stream._duplexState|=t8,(this.stream._duplexState&e8)===0)queueMicrotask(this.afterUpdateNextTick)}}class jG{constructor(J,{highWaterMark:Q=16384,map:q=null,mapReadable:G,byteLength:X,byteLengthReadable:Y}={}){this.stream=J,this.queue=new QG,this.highWaterMark=Q===0?1:Q,this.buffered=0,this.readAhead=Q>0,this.error=null,this.pipeline=null,this.byteLength=Y||X||NG,this.map=G||q,this.pipeTo=null,this.afterRead=A4.bind(this),this.afterUpdateNextTick=R4.bind(this)}get ended(){return(this.stream._duplexState&F0)!==0}pipe(J,Q){if(this.pipeTo!==null)throw new Error("Can only pipe to one destination");if(typeof Q!=="function")Q=null;if(this.stream._duplexState|=Bq,this.pipeTo=J,this.pipeline=new BG(this.stream,J,Q),Q)this.stream.on("error",qG);if(h1(J)){if(J._writableState.pipeline=this.pipeline,Q)J.on("error",qG);J.on("finish",this.pipeline.finished.bind(this.pipeline))}else{const q=this.pipeline.done.bind(this.pipeline,J),G=this.pipeline.done.bind(this.pipeline,J,null);J.on("error",q),J.on("close",G),J.on("finish",this.pipeline.finished.bind(this.pipeline))}J.on("drain",S4.bind(this)),this.stream.emit("piping",J),J.emit("pipe",this.stream)}push(J){const Q=this.stream;if(J===null)return this.highWaterMark=0,Q._duplexState=(Q._duplexState|S8)&sW,!1;if(this.map!==null){if(J=this.map(J),J===null)return Q._duplexState&=s5,this.buffered<this.highWaterMark}return this.buffered+=this.byteLength(J),this.queue.push(J),Q._duplexState=(Q._duplexState|G8)&s5,this.buffered<this.highWaterMark}shift(){const J=this.queue.shift();if(this.buffered-=this.byteLength(J),this.buffered===0)this.stream._duplexState&=eW;return J}unshift(J){const Q=[this.map!==null?this.map(J):J];while(this.buffered>0)Q.push(this.shift());for(let q=0;q<Q.length-1;q++){const G=Q[q];this.buffered+=this.byteLength(G),this.queue.push(G)}this.push(Q[Q.length-1])}read(){const J=this.stream;if((J._duplexState&e5)===G8){const Q=this.shift();if(this.pipeTo!==null&&this.pipeTo.write(Q)===!1)J._duplexState&=t5;if((J._duplexState&jq)!==0)J.emit("data",Q);return Q}if(this.readAhead===!1)J._duplexState|=D8,this.updateNextTick();return null}drain(){const J=this.stream;while((J._duplexState&e5)===G8&&(J._duplexState&XG)!==0){const Q=this.shift();if(this.pipeTo!==null&&this.pipeTo.write(Q)===!1)J._duplexState&=t5;if((J._duplexState&jq)!==0)J.emit("data",Q)}}update(){const J=this.stream;J._duplexState|=s8;do{this.drain();while(this.buffered<this.highWaterMark&&(J._duplexState&H4)===D8)J._duplexState|=iW,J._read(this.afterRead),this.drain();if((J._duplexState&U4)===nW)J._duplexState|=Pq,J.emit("readable");if((J._duplexState&oW)===0)this.updateNonPrimary()}while(this.continueUpdate()===!0);J._duplexState&=q4}updateNonPrimary(){const J=this.stream;if((J._duplexState&z4)===S8){if(J._duplexState=(J._duplexState|F0)&J4,J.emit("end"),(J._duplexState&zG)===wq)J._duplexState|=4;if(this.pipeTo!==null)this.pipeTo.end()}if((J._duplexState&v0)===4){if((J._duplexState&pJ)===0)J._duplexState|=y1,J._destroy(LG.bind(this));return}if((J._duplexState&UG)===1)J._duplexState=(J._duplexState|y1)&GG,J._open(PG.bind(this))}continueUpdate(){if((this.stream._duplexState&Q8)===0)return!1;return this.stream._duplexState&=YG,!0}updateCallback(){if((this.stream._duplexState&M4)===J1)this.update();else this.updateNextTick()}updateNextTickIfOpen(){if((this.stream._duplexState&B4)!==0)return;if(this.stream._duplexState|=Q8,(this.stream._duplexState&s8)===0)queueMicrotask(this.afterUpdateNextTick)}updateNextTick(){if((this.stream._duplexState&Q8)!==0)return;if(this.stream._duplexState|=Q8,(this.stream._duplexState&s8)===0)queueMicrotask(this.afterUpdateNextTick)}}class MG{constructor(J){this.data=null,this.afterTransform=v4.bind(J),this.afterFinal=null}}class BG{constructor(J,Q,q){this.from=J,this.to=Q,this.afterPipe=q,this.error=null,this.pipeToFinished=!1}finished(){this.pipeToFinished=!0}done(J,Q){if(Q)this.error=Q;if(J===this.to){if(this.to=null,this.from!==null){if((this.from._duplexState&F0)===0||!this.pipeToFinished)this.from.destroy(this.error||new Error("Writable stream closed prematurely"));return}}if(J===this.from){if(this.from=null,this.to!==null){if((J._duplexState&F0)===0)this.to.destroy(this.error||new Error("Readable stream closed before ending"));return}}if(this.afterPipe!==null)this.afterPipe(this.error);this.to=this.from=this.afterPipe=null}}class fJ extends fW{constructor(J){super();if(this._duplexState=0,this._readableState=null,this._writableState=null,J){if(J.open)this._open=J.open;if(J.destroy)this._destroy=J.destroy;if(J.predestroy)this._predestroy=J.predestroy;if(J.signal)J.signal.addEventListener("abort",l4.bind(this))}this.on("newListener",y4)}_open(J){J(null)}_destroy(J){J(null)}_predestroy(){}get readable(){return this._readableState!==null?!0:void 0}get writable(){return this._writableState!==null?!0:void 0}get destroyed(){return(this._duplexState&8)!==0}get destroying(){return(this._duplexState&v0)!==0}destroy(J){if((this._duplexState&v0)===0){if(!J)J=bJ;if(this._duplexState=(this._duplexState|4)&W4,this._readableState!==null)this._readableState.highWaterMark=0,this._readableState.error=J;if(this._writableState!==null)this._writableState.highWaterMark=0,this._writableState.error=J;if(this._duplexState|=2,this._predestroy(),this._duplexState&=dW,this._readableState!==null)this._readableState.updateNextTick();if(this._writableState!==null)this._writableState.updateNextTick()}}}class E1 extends fJ{constructor(J){super(J);if(this._duplexState|=1|X8|D8,this._readableState=new jG(this,J),J){if(this._readableState.readAhead===!1)this._duplexState&=VG;if(J.read)this._read=J.read;if(J.eagerOpen)this._readableState.updateNextTick();if(J.encoding)this.setEncoding(J.encoding)}}setEncoding(J){const Q=new lW(J),q=this._readableState.map||m4;return this._readableState.map=G,this;function G(X){const Y=Q.push(X);return Y===""&&(X.byteLength!==0||Q.remaining>0)?null:q(Y)}}_read(J){J(null)}pipe(J,Q){return this._readableState.updateNextTick(),this._readableState.pipe(J,Q),J}read(){return this._readableState.updateNextTick(),this._readableState.read()}push(J){return this._readableState.updateNextTickIfOpen(),this._readableState.push(J)}unshift(J){return this._readableState.updateNextTickIfOpen(),this._readableState.unshift(J)}resume(){return this._duplexState|=kq,this._readableState.updateNextTick(),this}pause(){return this._duplexState&=this._readableState.readAhead===!1?Q4:tW,this}static _fromAsyncIterator(J,Q){let q;const G=new E1({...Q,read(Y){J.next().then(X).then(Y.bind(null,null)).catch(Y)},predestroy(){q=J.return()},destroy(Y){if(!q)return Y(null);q.then(Y.bind(null,null)).catch(Y)}});return G;function X(Y){if(Y.done)G.push(null);else G.push(Y.value)}}static from(J,Q){if(c4(J))return J;if(J[_J])return this._fromAsyncIterator(J[_J](),Q);if(!Array.isArray(J))J=J===void 0?[]:[J];let q=0;return new E1({...Q,read(G){this.push(q===J.length?null:J[q++]),G(null)}})}static isBackpressured(J){return(J._duplexState&j4)!==0||J._readableState.buffered>=J._readableState.highWaterMark}static isPaused(J){return(J._duplexState&_1)===0}[_J](){const J=this;let Q=null,q=null,G=null;return this.on("error",(Z)=>{Q=Z}),this.on("readable",X),this.on("close",Y),{[_J](){return this},next(){return new Promise(function(Z,W){q=Z,G=W;const $=J.read();if($!==null)V($);else if((J._duplexState&8)!==0)V(null)})},return(){return K(null)},throw(Z){return K(Z)}};function X(){if(q!==null)V(J.read())}function Y(){if(q!==null)V(null)}function V(Z){if(G===null)return;if(Q)G(Q);else if(Z===null&&(J._duplexState&F0)===0)G(bJ);else q({value:Z,done:Z===null});G=q=null}function K(Z){return J.destroy(Z),new Promise((W,$)=>{if(J._duplexState&8)return W({value:void 0,done:!0});J.once("close",function(){if(Z)$(Z);else W({value:void 0,done:!0})})})}}}class xq extends fJ{constructor(J){super(J);if(this._duplexState|=1|F0,this._writableState=new Nq(this,J),J){if(J.writev)this._writev=J.writev;if(J.write)this._write=J.write;if(J.final)this._final=J.final;if(J.eagerOpen)this._writableState.updateNextTick()}}cork(){this._duplexState|=cJ}uncork(){this._duplexState&=ZG,this._writableState.updateNextTick()}_writev(J,Q){Q(null)}_write(J,Q){this._writableState.autoBatch(J,Q)}_final(J){J(null)}static isBackpressured(J){return(J._duplexState&x4)!==0}static drained(J){if(J.destroyed)return Promise.resolve(!1);const Q=J._writableState,G=(d4(J)?Math.min(1,Q.queue.length):Q.queue.length)+(J._duplexState&Cq?1:0);if(G===0)return Promise.resolve(!0);if(Q.drains===null)Q.drains=[];return new Promise((X)=>{Q.drains.push({writes:G,resolve:X})})}write(J){return this._writableState.updateNextTick(),this._writableState.push(J)}end(J){return this._writableState.updateNextTick(),this._writableState.end(J),this}}class lJ extends E1{constructor(J){super(J);if(this._duplexState=1|this._duplexState&D8,this._writableState=new Nq(this,J),J){if(J.writev)this._writev=J.writev;if(J.write)this._write=J.write;if(J.final)this._final=J.final}}cork(){this._duplexState|=cJ}uncork(){this._duplexState&=ZG,this._writableState.updateNextTick()}_writev(J,Q){Q(null)}_write(J,Q){this._writableState.autoBatch(J,Q)}_final(J){J(null)}write(J){return this._writableState.updateNextTick(),this._writableState.push(J)}end(J){return this._writableState.updateNextTick(),this._writableState.end(J),this}}class Oq extends lJ{constructor(J){super(J);if(this._transformState=new MG(this),J){if(J.transform)this._transform=J.transform;if(J.flush)this._flush=J.flush}}_write(J,Q){if(this._readableState.buffered>=this._readableState.highWaterMark)this._transformState.data=J;else this._transform(J,this._transformState.afterTransform)}_read(J){if(this._transformState.data!==null){const Q=this._transformState.data;this._transformState.data=null,J(null),this._transform(Q,this._transformState.afterTransform)}else J(null)}destroy(J){if(super.destroy(J),this._transformState.data!==null)this._transformState.data=null,this._transformState.afterTransform()}_transform(J,Q){Q(null,J)}_flush(J){J(null)}_final(J){this._transformState.afterFinal=J,this._flush(E4.bind(this))}}class kG extends Oq{}xG.exports={pipeline:CG,pipelinePromise:h4,isStream:wG,isStreamx:h1,isEnded:_4,isFinished:b4,isDisturbed:p4,getStreamError:u4,Stream:fJ,Writable:xq,Readable:E1,Duplex:lJ,Transform:Oq,PassThrough:kG}});var Fq=K0((Kz,SG)=>{var FG=function(J,Q){for(let q in Q)Object.defineProperty(J,q,{value:Q[q],enumerable:!0,configurable:!0});return J},i4=function(J,Q,q){if(!J||typeof J==="string")throw new TypeError("Please pass an Error to err-code");if(!q)q={};if(typeof Q==="object")q=Q,Q="";if(Q)q.code=Q;try{return FG(J,q)}catch(G){q.message=J.message,q.stack=J.stack;const X=function(){};return X.prototype=Object.create(Object.getPrototypeOf(J)),FG(new X,q)}};SG.exports=i4});function _q(J){const Q=J.length;let q=0,G=0;while(G<Q){let X=J.charCodeAt(G++);if((X&4294967168)===0){q++;continue}else if((X&4294965248)===0)q+=2;else{if(X>=55296&&X<=56319){if(G<Q){const Y=J.charCodeAt(G);if((Y&64512)===56320)++G,X=((X&1023)<<10)+(Y&1023)+65536}}if((X&4294901760)===0)q+=3;else q+=4}}return q}function W7(J,Q,q){const G=J.length;let X=q,Y=0;while(Y<G){let V=J.charCodeAt(Y++);if((V&4294967168)===0){Q[X++]=V;continue}else if((V&4294965248)===0)Q[X++]=V>>6&31|192;else{if(V>=55296&&V<=56319){if(Y<G){const K=J.charCodeAt(Y);if((K&64512)===56320)++Y,V=((V&1023)<<10)+(K&1023)+65536}}if((V&4294901760)===0)Q[X++]=V>>12&15|224,Q[X++]=V>>6&63|128;else Q[X++]=V>>18&7|240,Q[X++]=V>>12&63|128,Q[X++]=V>>6&63|128}Q[X++]=V&63|128}}function z7(J,Q,q){Z7.encodeInto(J,Q.subarray(q))}function bq(J,Q,q){if(J.length>$7)z7(J,Q,q);else W7(J,Q,q)}function aJ(J,Q,q){let G=Q;const X=G+q,Y=[];let V="";while(G<X){const K=J[G++];if((K&128)===0)Y.push(K);else if((K&224)===192){const Z=J[G++]&63;Y.push((K&31)<<6|Z)}else if((K&240)===224){const Z=J[G++]&63,W=J[G++]&63;Y.push((K&31)<<12|Z<<6|W)}else if((K&248)===240){const Z=J[G++]&63,W=J[G++]&63,$=J[G++]&63;let B=(K&7)<<18|Z<<12|W<<6|$;if(B>65535)B-=65536,Y.push(B>>>10&1023|55296),B=56320|B&1023;Y.push(B)}else Y.push(K);if(Y.length>=U7)V+=String.fromCharCode(...Y),Y.length=0}if(Y.length>0)V+=String.fromCharCode(...Y);return V}function M7(J,Q,q){const G=J.subarray(Q,Q+q);return H7.decode(G)}function uq(J,Q,q){if(q>j7)return M7(J,Q,q);else return aJ(J,Q,q)}var Z7=new TextEncoder,$7=50,U7=4096,H7=new TextDecoder,j7=200;class g8{constructor(J,Q){this.type=J,this.data=Q}}class W0 extends Error{constructor(J){super(J);const Q=Object.create(W0.prototype);Object.setPrototypeOf(this,Q),Object.defineProperty(this,"name",{configurable:!0,enumerable:!1,value:W0.name})}}function cq(J,Q,q){const G=q/4294967296,X=q;J.setUint32(Q,G),J.setUint32(Q+4,X)}function i1(J,Q,q){const G=Math.floor(q/4294967296),X=q;J.setUint32(Q,G),J.setUint32(Q+4,X)}function o1(J,Q){const q=J.getInt32(Q),G=J.getUint32(Q+4);return q*4294967296+G}function pq(J,Q){const q=J.getUint32(Q),G=J.getUint32(Q+4);return q*4294967296+G}var v8=4294967295;function k7({sec:J,nsec:Q}){if(J>=0&&Q>=0&&J<=P7)if(Q===0&&J<=L7){const q=new Uint8Array(4);return new DataView(q.buffer).setUint32(0,J),q}else{const q=J/4294967296,G=J&4294967295,X=new Uint8Array(8),Y=new DataView(X.buffer);return Y.setUint32(0,Q<<2|q&3),Y.setUint32(4,G),X}else{const q=new Uint8Array(12),G=new DataView(q.buffer);return G.setUint32(0,Q),i1(G,4,J),q}}function C7(J){const Q=J.getTime(),q=Math.floor(Q/1000),G=(Q-q*1000)*1e6,X=Math.floor(G/1e9);return{sec:q+X,nsec:G-X*1e9}}function w7(J){if(J instanceof Date){const Q=C7(J);return k7(Q)}else return null}function N7(J){const Q=new DataView(J.buffer,J.byteOffset,J.byteLength);switch(J.byteLength){case 4:return{sec:Q.getUint32(0),nsec:0};case 8:{const q=Q.getUint32(0),G=Q.getUint32(4),X=(q&3)*4294967296+G,Y=q>>>2;return{sec:X,nsec:Y}}case 12:{const q=o1(Q,4),G=Q.getUint32(0);return{sec:q,nsec:G}}default:throw new W0(`Unrecognized data size for timestamp (expected 4, 8, or 12): ${J.length}`)}}function x7(J){const Q=N7(J);return new Date(Q.sec*1000+Q.nsec/1e6)}var B7=-1,L7=4294967295,P7=17179869183,fq={type:B7,encode:w7,decode:x7};class V8{constructor(){this.builtInEncoders=[],this.builtInDecoders=[],this.encoders=[],this.decoders=[],this.register(fq)}register({type:J,encode:Q,decode:q}){if(J>=0)this.encoders[J]=Q,this.decoders[J]=q;else{const G=-1-J;this.builtInEncoders[G]=Q,this.builtInDecoders[G]=q}}tryToEncode(J,Q){for(let q=0;q<this.builtInEncoders.length;q++){const G=this.builtInEncoders[q];if(G!=null){const X=G(J,Q);if(X!=null){const Y=-1-q;return new g8(Y,X)}}}for(let q=0;q<this.encoders.length;q++){const G=this.encoders[q];if(G!=null){const X=G(J,Q);if(X!=null)return new g8(q,X)}}if(J instanceof g8)return J;return null}decode(J,Q,q){const G=Q<0?this.builtInDecoders[-1-Q]:this.decoders[Q];if(G)return G(J,Q,q);else return new g8(Q,J)}}V8.defaultCodec=new V8;var O7=function(J){return J instanceof ArrayBuffer||typeof SharedArrayBuffer!=="undefined"&&J instanceof SharedArrayBuffer};function G1(J){if(J instanceof Uint8Array)return J;else if(ArrayBuffer.isView(J))return new Uint8Array(J.buffer,J.byteOffset,J.byteLength);else if(O7(J))return new Uint8Array(J);else return Uint8Array.from(J)}var lq=function(J,Q,q){if(Q!==null&&Q!==void 0){if(typeof Q!=="object"&&typeof Q!=="function")throw new TypeError("Object expected.");var G,X;if(q){if(!Symbol.asyncDispose)throw new TypeError("Symbol.asyncDispose is not defined.");G=Q[Symbol.asyncDispose]}if(G===void 0){if(!Symbol.dispose)throw new TypeError("Symbol.dispose is not defined.");if(G=Q[Symbol.dispose],q)X=G}if(typeof G!=="function")throw new TypeError("Object not disposable.");if(X)G=function(){try{X.call(this)}catch(Y){return Promise.reject(Y)}};J.stack.push({value:Q,dispose:G,async:q})}else if(q)J.stack.push({async:!0});return Q},dq=function(J){return function(Q){function q(V){Q.error=Q.hasError?new J(V,Q.error,"An error was suppressed during disposal."):V,Q.hasError=!0}var G,X=0;function Y(){while(G=Q.stack.pop())try{if(!G.async&&X===1)return X=0,Q.stack.push(G),Promise.resolve().then(Y);if(G.dispose){var V=G.dispose.call(G.value);if(G.async)return X|=2,Promise.resolve(V).then(Y,function(K){return q(K),Y()})}else X|=1}catch(K){q(K)}if(X===1)return Q.hasError?Promise.reject(Q.error):Promise.resolve();if(Q.hasError)throw Q.error}return Y()}}(typeof SuppressedError==="function"?SuppressedError:function(J,Q,q){var G=new Error(q);return G.name="SuppressedError",G.error=J,G.suppressed=Q,G}),F7=100,S7=2048;class n1{constructor(J){this.entered=!1,this.extensionCodec=J?.extensionCodec??V8.defaultCodec,this.context=J?.context,this.useBigInt64=J?.useBigInt64??!1,this.maxDepth=J?.maxDepth??F7,this.initialBufferSize=J?.initialBufferSize??S7,this.sortKeys=J?.sortKeys??!1,this.forceFloat32=J?.forceFloat32??!1,this.ignoreUndefined=J?.ignoreUndefined??!1,this.forceIntegerToFloat=J?.forceIntegerToFloat??!1,this.pos=0,this.view=new DataView(new ArrayBuffer(this.initialBufferSize)),this.bytes=new Uint8Array(this.view.buffer)}clone(){return new n1({extensionCodec:this.extensionCodec,context:this.context,useBigInt64:this.useBigInt64,maxDepth:this.maxDepth,initialBufferSize:this.initialBufferSize,sortKeys:this.sortKeys,forceFloat32:this.forceFloat32,ignoreUndefined:this.ignoreUndefined,forceIntegerToFloat:this.forceIntegerToFloat})}reinitializeState(){this.pos=0}enteringGuard(){return this.entered=!0,{[Symbol.dispose]:()=>{this.entered=!1}}}encodeSharedRef(J){const Q={stack:[],error:void 0,hasError:!1};try{if(this.entered)return this.clone().encodeSharedRef(J);const q=lq(Q,this.enteringGuard(),!1);return this.reinitializeState(),this.doEncode(J,1),this.bytes.subarray(0,this.pos)}catch(q){Q.error=q,Q.hasError=!0}finally{dq(Q)}}encode(J){const Q={stack:[],error:void 0,hasError:!1};try{if(this.entered)return this.clone().encode(J);const q=lq(Q,this.enteringGuard(),!1);return this.reinitializeState(),this.doEncode(J,1),this.bytes.slice(0,this.pos)}catch(q){Q.error=q,Q.hasError=!0}finally{dq(Q)}}doEncode(J,Q){if(Q>this.maxDepth)throw new Error(`Too deep objects in depth ${Q}`);if(J==null)this.encodeNil();else if(typeof J==="boolean")this.encodeBoolean(J);else if(typeof J==="number")if(!this.forceIntegerToFloat)this.encodeNumber(J);else this.encodeNumberAsFloat(J);else if(typeof J==="string")this.encodeString(J);else if(this.useBigInt64&&typeof J==="bigint")this.encodeBigInt64(J);else this.encodeObject(J,Q)}ensureBufferSizeToWrite(J){const Q=this.pos+J;if(this.view.byteLength<Q)this.resizeBuffer(Q*2)}resizeBuffer(J){const Q=new ArrayBuffer(J),q=new Uint8Array(Q),G=new DataView(Q);q.set(this.bytes),this.view=G,this.bytes=q}encodeNil(){this.writeU8(192)}encodeBoolean(J){if(J===!1)this.writeU8(194);else this.writeU8(195)}encodeNumber(J){if(!this.forceIntegerToFloat&&Number.isSafeInteger(J))if(J>=0)if(J<128)this.writeU8(J);else if(J<256)this.writeU8(204),this.writeU8(J);else if(J<65536)this.writeU8(205),this.writeU16(J);else if(J<4294967296)this.writeU8(206),this.writeU32(J);else if(!this.useBigInt64)this.writeU8(207),this.writeU64(J);else this.encodeNumberAsFloat(J);else if(J>=-32)this.writeU8(224|J+32);else if(J>=-128)this.writeU8(208),this.writeI8(J);else if(J>=-32768)this.writeU8(209),this.writeI16(J);else if(J>=-2147483648)this.writeU8(210),this.writeI32(J);else if(!this.useBigInt64)this.writeU8(211),this.writeI64(J);else this.encodeNumberAsFloat(J);else this.encodeNumberAsFloat(J)}encodeNumberAsFloat(J){if(this.forceFloat32)this.writeU8(202),this.writeF32(J);else this.writeU8(203),this.writeF64(J)}encodeBigInt64(J){if(J>=BigInt(0))this.writeU8(207),this.writeBigUint64(J);else this.writeU8(211),this.writeBigInt64(J)}writeStringHeader(J){if(J<32)this.writeU8(160+J);else if(J<256)this.writeU8(217),this.writeU8(J);else if(J<65536)this.writeU8(218),this.writeU16(J);else if(J<4294967296)this.writeU8(219),this.writeU32(J);else throw new Error(`Too long string: ${J} bytes in UTF-8`)}encodeString(J){const q=_q(J);this.ensureBufferSizeToWrite(5+q),this.writeStringHeader(q),bq(J,this.bytes,this.pos),this.pos+=q}encodeObject(J,Q){const q=this.extensionCodec.tryToEncode(J,this.context);if(q!=null)this.encodeExtension(q);else if(Array.isArray(J))this.encodeArray(J,Q);else if(ArrayBuffer.isView(J))this.encodeBinary(J);else if(typeof J==="object")this.encodeMap(J,Q);else throw new Error(`Unrecognized object: ${Object.prototype.toString.apply(J)}`)}encodeBinary(J){const Q=J.byteLength;if(Q<256)this.writeU8(196),this.writeU8(Q);else if(Q<65536)this.writeU8(197),this.writeU16(Q);else if(Q<4294967296)this.writeU8(198),this.writeU32(Q);else throw new Error(`Too large binary: ${Q}`);const q=G1(J);this.writeU8a(q)}encodeArray(J,Q){const q=J.length;if(q<16)this.writeU8(144+q);else if(q<65536)this.writeU8(220),this.writeU16(q);else if(q<4294967296)this.writeU8(221),this.writeU32(q);else throw new Error(`Too large array: ${q}`);for(let G of J)this.doEncode(G,Q+1)}countWithoutUndefined(J,Q){let q=0;for(let G of Q)if(J[G]!==void 0)q++;return q}encodeMap(J,Q){const q=Object.keys(J);if(this.sortKeys)q.sort();const G=this.ignoreUndefined?this.countWithoutUndefined(J,q):q.length;if(G<16)this.writeU8(128+G);else if(G<65536)this.writeU8(222),this.writeU16(G);else if(G<4294967296)this.writeU8(223),this.writeU32(G);else throw new Error(`Too large map object: ${G}`);for(let X of q){const Y=J[X];if(!(this.ignoreUndefined&&Y===void 0))this.encodeString(X),this.doEncode(Y,Q+1)}}encodeExtension(J){if(typeof J.data==="function"){const q=J.data(this.pos+6),G=q.length;if(G>=4294967296)throw new Error(`Too large extension object: ${G}`);this.writeU8(201),this.writeU32(G),this.writeI8(J.type),this.writeU8a(q);return}const Q=J.data.length;if(Q===1)this.writeU8(212);else if(Q===2)this.writeU8(213);else if(Q===4)this.writeU8(214);else if(Q===8)this.writeU8(215);else if(Q===16)this.writeU8(216);else if(Q<256)this.writeU8(199),this.writeU8(Q);else if(Q<65536)this.writeU8(200),this.writeU16(Q);else if(Q<4294967296)this.writeU8(201),this.writeU32(Q);else throw new Error(`Too large extension object: ${Q}`);this.writeI8(J.type),this.writeU8a(J.data)}writeU8(J){this.ensureBufferSizeToWrite(1),this.view.setUint8(this.pos,J),this.pos++}writeU8a(J){const Q=J.length;this.ensureBufferSizeToWrite(Q),this.bytes.set(J,this.pos),this.pos+=Q}writeI8(J){this.ensureBufferSizeToWrite(1),this.view.setInt8(this.pos,J),this.pos++}writeU16(J){this.ensureBufferSizeToWrite(2),this.view.setUint16(this.pos,J),this.pos+=2}writeI16(J){this.ensureBufferSizeToWrite(2),this.view.setInt16(this.pos,J),this.pos+=2}writeU32(J){this.ensureBufferSizeToWrite(4),this.view.setUint32(this.pos,J),this.pos+=4}writeI32(J){this.ensureBufferSizeToWrite(4),this.view.setInt32(this.pos,J),this.pos+=4}writeF32(J){this.ensureBufferSizeToWrite(4),this.view.setFloat32(this.pos,J),this.pos+=4}writeF64(J){this.ensureBufferSizeToWrite(8),this.view.setFloat64(this.pos,J),this.pos+=8}writeU64(J){this.ensureBufferSizeToWrite(8),cq(this.view,this.pos,J),this.pos+=8}writeI64(J){this.ensureBufferSizeToWrite(8),i1(this.view,this.pos,J),this.pos+=8}writeBigUint64(J){this.ensureBufferSizeToWrite(8),this.view.setBigUint64(this.pos,J),this.pos+=8}writeBigInt64(J){this.ensureBufferSizeToWrite(8),this.view.setBigInt64(this.pos,J),this.pos+=8}}function r1(J,Q){return new n1(Q).encodeSharedRef(J)}function a1(J){return`${J<0?"-":""}0x${Math.abs(J).toString(16).padStart(2,"0")}`}var D7=16,I7=16;class sJ{constructor(J=D7,Q=I7){this.hit=0,this.miss=0,this.maxKeyLength=J,this.maxLengthPerKey=Q,this.caches=[];for(let q=0;q<this.maxKeyLength;q++)this.caches.push([])}canBeCached(J){return J>0&&J<=this.maxKeyLength}find(J,Q,q){const G=this.caches[q-1];J:for(let X of G){const Y=X.bytes;for(let V=0;V<q;V++)if(Y[V]!==J[Q+V])continue J;return X.str}return null}store(J,Q){const q=this.caches[J.length-1],G={bytes:J,str:Q};if(q.length>=this.maxLengthPerKey)q[Math.random()*q.length|0]=G;else q.push(G)}decode(J,Q,q){const G=this.find(J,Q,q);if(G!=null)return this.hit++,G;this.miss++;const X=aJ(J,Q,q),Y=Uint8Array.prototype.slice.call(J,Q,Q+q);return this.store(Y,X),X}}var s1=function(J,Q,q){if(Q!==null&&Q!==void 0){if(typeof Q!=="object"&&typeof Q!=="function")throw new TypeError("Object expected.");var G,X;if(q){if(!Symbol.asyncDispose)throw new TypeError("Symbol.asyncDispose is not defined.");G=Q[Symbol.asyncDispose]}if(G===void 0){if(!Symbol.dispose)throw new TypeError("Symbol.dispose is not defined.");if(G=Q[Symbol.dispose],q)X=G}if(typeof G!=="function")throw new TypeError("Object not disposable.");if(X)G=function(){try{X.call(this)}catch(Y){return Promise.reject(Y)}};J.stack.push({value:Q,dispose:G,async:q})}else if(q)J.stack.push({async:!0});return Q},t1=function(J){return function(Q){function q(V){Q.error=Q.hasError?new J(V,Q.error,"An error was suppressed during disposal."):V,Q.hasError=!0}var G,X=0;function Y(){while(G=Q.stack.pop())try{if(!G.async&&X===1)return X=0,Q.stack.push(G),Promise.resolve().then(Y);if(G.dispose){var V=G.dispose.call(G.value);if(G.async)return X|=2,Promise.resolve(V).then(Y,function(K){return q(K),Y()})}else X|=1}catch(K){q(K)}if(X===1)return Q.hasError?Promise.reject(Q.error):Promise.resolve();if(Q.hasError)throw Q.error}return Y()}}(typeof SuppressedError==="function"?SuppressedError:function(J,Q,q){var G=new Error(q);return G.name="SuppressedError",G.error=J,G.suppressed=Q,G}),tJ="array",Y1="map_key",oq="map_value",A7=(J)=>{if(typeof J==="string"||typeof J==="number")return J;throw new W0("The type of key must be string or number but "+typeof J)};class nq{constructor(){this.stack=[],this.stackHeadPosition=-1}get length(){return this.stackHeadPosition+1}top(){return this.stack[this.stackHeadPosition]}pushArrayState(J){const Q=this.getUninitializedStateFromPool();Q.type=tJ,Q.position=0,Q.size=J,Q.array=new Array(J)}pushMapState(J){const Q=this.getUninitializedStateFromPool();Q.type=Y1,Q.readCount=0,Q.size=J,Q.map={}}getUninitializedStateFromPool(){if(this.stackHeadPosition++,this.stackHeadPosition===this.stack.length){const J={type:void 0,size:0,array:void 0,position:0,readCount:0,map:void 0,key:null};this.stack.push(J)}return this.stack[this.stackHeadPosition]}release(J){if(this.stack[this.stackHeadPosition]!==J)throw new Error("Invalid stack state. Released state is not on top of the stack.");if(J.type===tJ){const q=J;q.size=0,q.array=void 0,q.position=0,q.type=void 0}if(J.type===Y1||J.type===oq){const q=J;q.size=0,q.map=void 0,q.readCount=0,q.type=void 0}this.stackHeadPosition--}reset(){this.stack.length=0,this.stackHeadPosition=-1}}var X1=-1,eJ=new DataView(new ArrayBuffer(0)),R7=new Uint8Array(eJ.buffer);try{eJ.getInt8(0)}catch(J){if(!(J instanceof RangeError))throw new Error("This module is not supported in the current JavaScript engine because DataView does not throw RangeError on out-of-bounds access")}var iq=new RangeError("Insufficient data"),T7=new sJ;class e1{constructor(J){this.totalPos=0,this.pos=0,this.view=eJ,this.bytes=R7,this.headByte=X1,this.stack=new nq,this.entered=!1,this.extensionCodec=J?.extensionCodec??V8.defaultCodec,this.context=J?.context,this.useBigInt64=J?.useBigInt64??!1,this.rawStrings=J?.rawStrings??!1,this.maxStrLength=J?.maxStrLength??v8,this.maxBinLength=J?.maxBinLength??v8,this.maxArrayLength=J?.maxArrayLength??v8,this.maxMapLength=J?.maxMapLength??v8,this.maxExtLength=J?.maxExtLength??v8,this.keyDecoder=J?.keyDecoder!==void 0?J.keyDecoder:T7,this.mapKeyConverter=J?.mapKeyConverter??A7}clone(){return new e1({extensionCodec:this.extensionCodec,context:this.context,useBigInt64:this.useBigInt64,rawStrings:this.rawStrings,maxStrLength:this.maxStrLength,maxBinLength:this.maxBinLength,maxArrayLength:this.maxArrayLength,maxMapLength:this.maxMapLength,maxExtLength:this.maxExtLength,keyDecoder:this.keyDecoder})}reinitializeState(){this.totalPos=0,this.headByte=X1,this.stack.reset()}setBuffer(J){const Q=G1(J);this.bytes=Q,this.view=new DataView(Q.buffer,Q.byteOffset,Q.byteLength),this.pos=0}appendBuffer(J){if(this.headByte===X1&&!this.hasRemaining(1))this.setBuffer(J);else{const Q=this.bytes.subarray(this.pos),q=G1(J),G=new Uint8Array(Q.length+q.length);G.set(Q),G.set(q,Q.length),this.setBuffer(G)}}hasRemaining(J){return this.view.byteLength-this.pos>=J}createExtraByteError(J){const{view:Q,pos:q}=this;return new RangeError(`Extra ${Q.byteLength-q} of ${Q.byteLength} byte(s) found at buffer[${J}]`)}enteringGuard(){return this.entered=!0,{[Symbol.dispose]:()=>{this.entered=!1}}}decode(J){const Q={stack:[],error:void 0,hasError:!1};try{if(this.entered)return this.clone().decode(J);const q=s1(Q,this.enteringGuard(),!1);this.reinitializeState(),this.setBuffer(J);const G=this.doDecodeSync();if(this.hasRemaining(1))throw this.createExtraByteError(this.pos);return G}catch(q){Q.error=q,Q.hasError=!0}finally{t1(Q)}}*decodeMulti(J){const Q={stack:[],error:void 0,hasError:!1};try{if(this.entered){yield*this.clone().decodeMulti(J);return}const q=s1(Q,this.enteringGuard(),!1);this.reinitializeState(),this.setBuffer(J);while(this.hasRemaining(1))yield this.doDecodeSync()}catch(q){Q.error=q,Q.hasError=!0}finally{t1(Q)}}async decodeAsync(J){const Q={stack:[],error:void 0,hasError:!1};try{if(this.entered)return this.clone().decodeAsync(J);const q=s1(Q,this.enteringGuard(),!1);let G=!1,X;for await(let Z of J){if(G)throw this.entered=!1,this.createExtraByteError(this.totalPos);this.appendBuffer(Z);try{X=this.doDecodeSync(),G=!0}catch(W){if(!(W instanceof RangeError))throw W}this.totalPos+=this.pos}if(G){if(this.hasRemaining(1))throw this.createExtraByteError(this.totalPos);return X}const{headByte:Y,pos:V,totalPos:K}=this;throw new RangeError(`Insufficient data in parsing ${a1(Y)} at ${K} (${V} in the current buffer)`)}catch(q){Q.error=q,Q.hasError=!0}finally{t1(Q)}}decodeArrayStream(J){return this.decodeMultiAsync(J,!0)}decodeStream(J){return this.decodeMultiAsync(J,!1)}async*decodeMultiAsync(J,Q){const q={stack:[],error:void 0,hasError:!1};try{if(this.entered){yield*this.clone().decodeMultiAsync(J,Q);return}const G=s1(q,this.enteringGuard(),!1);let X=Q,Y=-1;for await(let V of J){if(Q&&Y===0)throw this.createExtraByteError(this.totalPos);if(this.appendBuffer(V),X)Y=this.readArraySize(),X=!1,this.complete();try{while(!0)if(yield this.doDecodeSync(),--Y===0)break}catch(K){if(!(K instanceof RangeError))throw K}this.totalPos+=this.pos}}catch(G){q.error=G,q.hasError=!0}finally{t1(q)}}doDecodeSync(){J:while(!0){const J=this.readHeadByte();let Q;if(J>=224)Q=J-256;else if(J<192)if(J<128)Q=J;else if(J<144){const G=J-128;if(G!==0){this.pushMapState(G),this.complete();continue J}else Q={}}else if(J<160){const G=J-144;if(G!==0){this.pushArrayState(G),this.complete();continue J}else Q=[]}else{const G=J-160;Q=this.decodeString(G,0)}else if(J===192)Q=null;else if(J===194)Q=!1;else if(J===195)Q=!0;else if(J===202)Q=this.readF32();else if(J===203)Q=this.readF64();else if(J===204)Q=this.readU8();else if(J===205)Q=this.readU16();else if(J===206)Q=this.readU32();else if(J===207)if(this.useBigInt64)Q=this.readU64AsBigInt();else Q=this.readU64();else if(J===208)Q=this.readI8();else if(J===209)Q=this.readI16();else if(J===210)Q=this.readI32();else if(J===211)if(this.useBigInt64)Q=this.readI64AsBigInt();else Q=this.readI64();else if(J===217){const G=this.lookU8();Q=this.decodeString(G,1)}else if(J===218){const G=this.lookU16();Q=this.decodeString(G,2)}else if(J===219){const G=this.lookU32();Q=this.decodeString(G,4)}else if(J===220){const G=this.readU16();if(G!==0){this.pushArrayState(G),this.complete();continue J}else Q=[]}else if(J===221){const G=this.readU32();if(G!==0){this.pushArrayState(G),this.complete();continue J}else Q=[]}else if(J===222){const G=this.readU16();if(G!==0){this.pushMapState(G),this.complete();continue J}else Q={}}else if(J===223){const G=this.readU32();if(G!==0){this.pushMapState(G),this.complete();continue J}else Q={}}else if(J===196){const G=this.lookU8();Q=this.decodeBinary(G,1)}else if(J===197){const G=this.lookU16();Q=this.decodeBinary(G,2)}else if(J===198){const G=this.lookU32();Q=this.decodeBinary(G,4)}else if(J===212)Q=this.decodeExtension(1,0);else if(J===213)Q=this.decodeExtension(2,0);else if(J===214)Q=this.decodeExtension(4,0);else if(J===215)Q=this.decodeExtension(8,0);else if(J===216)Q=this.decodeExtension(16,0);else if(J===199){const G=this.lookU8();Q=this.decodeExtension(G,1)}else if(J===200){const G=this.lookU16();Q=this.decodeExtension(G,2)}else if(J===201){const G=this.lookU32();Q=this.decodeExtension(G,4)}else throw new W0(`Unrecognized type byte: ${a1(J)}`);this.complete();const q=this.stack;while(q.length>0){const G=q.top();if(G.type===tJ)if(G.array[G.position]=Q,G.position++,G.position===G.size)Q=G.array,q.release(G);else continue J;else if(G.type===Y1){if(Q==="__proto__")throw new W0("The key __proto__ is not allowed");G.key=this.mapKeyConverter(Q),G.type=oq;continue J}else if(G.map[G.key]=Q,G.readCount++,G.readCount===G.size)Q=G.map,q.release(G);else{G.key=null,G.type=Y1;continue J}}return Q}}readHeadByte(){if(this.headByte===X1)this.headByte=this.readU8();return this.headByte}complete(){this.headByte=X1}readArraySize(){const J=this.readHeadByte();switch(J){case 220:return this.readU16();case 221:return this.readU32();default:if(J<160)return J-144;else throw new W0(`Unrecognized array type byte: ${a1(J)}`)}}pushMapState(J){if(J>this.maxMapLength)throw new W0(`Max length exceeded: map length (${J}) > maxMapLengthLength (${this.maxMapLength})`);this.stack.pushMapState(J)}pushArrayState(J){if(J>this.maxArrayLength)throw new W0(`Max length exceeded: array length (${J}) > maxArrayLength (${this.maxArrayLength})`);this.stack.pushArrayState(J)}decodeString(J,Q){if(!this.rawStrings||this.stateIsMapKey())return this.decodeUtf8String(J,Q);return this.decodeBinary(J,Q)}decodeUtf8String(J,Q){if(J>this.maxStrLength)throw new W0(`Max length exceeded: UTF-8 byte length (${J}) > maxStrLength (${this.maxStrLength})`);if(this.bytes.byteLength<this.pos+Q+J)throw iq;const q=this.pos+Q;let G;if(this.stateIsMapKey()&&this.keyDecoder?.canBeCached(J))G=this.keyDecoder.decode(this.bytes,q,J);else G=uq(this.bytes,q,J);return this.pos+=Q+J,G}stateIsMapKey(){if(this.stack.length>0)return this.stack.top().type===Y1;return!1}decodeBinary(J,Q){if(J>this.maxBinLength)throw new W0(`Max length exceeded: bin length (${J}) > maxBinLength (${this.maxBinLength})`);if(!this.hasRemaining(J+Q))throw iq;const q=this.pos+Q,G=this.bytes.subarray(q,q+J);return this.pos+=Q+J,G}decodeExtension(J,Q){if(J>this.maxExtLength)throw new W0(`Max length exceeded: ext length (${J}) > maxExtLength (${this.maxExtLength})`);const q=this.view.getInt8(this.pos+Q),G=this.decodeBinary(J,Q+1);return this.extensionCodec.decode(G,q,this.context)}lookU8(){return this.view.getUint8(this.pos)}lookU16(){return this.view.getUint16(this.pos)}lookU32(){return this.view.getUint32(this.pos)}readU8(){const J=this.view.getUint8(this.pos);return this.pos++,J}readI8(){const J=this.view.getInt8(this.pos);return this.pos++,J}readU16(){const J=this.view.getUint16(this.pos);return this.pos+=2,J}readI16(){const J=this.view.getInt16(this.pos);return this.pos+=2,J}readU32(){const J=this.view.getUint32(this.pos);return this.pos+=4,J}readI32(){const J=this.view.getInt32(this.pos);return this.pos+=4,J}readU64(){const J=pq(this.view,this.pos);return this.pos+=8,J}readI64(){const J=o1(this.view,this.pos);return this.pos+=8,J}readU64AsBigInt(){const J=this.view.getBigUint64(this.pos);return this.pos+=8,J}readI64AsBigInt(){const J=this.view.getBigInt64(this.pos);return this.pos+=8,J}readF32(){const J=this.view.getFloat32(this.pos);return this.pos+=4,J}readF64(){const J=this.view.getFloat64(this.pos);return this.pos+=8,J}}function J9(J,Q){return new e1(Q).decode(J)}var b8=function(J){let Q=J.length;while(--Q>=0)J[Q]=0},Q9=function(J,Q,q,G,X){this.static_tree=J,this.extra_bits=Q,this.extra_base=q,this.elems=G,this.max_length=X,this.has_stree=J&&J.length},G9=function(J,Q){this.dyn_tree=J,this.max_code=0,this.stat_desc=Q},S0=function(J,Q,q,G,X){this.good_length=J,this.max_lazy=Q,this.nice_length=q,this.max_chain=G,this.func=X},vX=function(){this.strm=null,this.status=0,this.pending_buf=null,this.pending_buf_size=0,this.pending_out=0,this.pending=0,this.wrap=0,this.gzhead=null,this.gzindex=0,this.method=ZJ,this.last_flush=-1,this.w_size=0,this.w_bits=0,this.w_mask=0,this.window=null,this.window_size=0,this.prev=null,this.head=null,this.ins_h=0,this.hash_size=0,this.hash_bits=0,this.hash_mask=0,this.hash_shift=0,this.block_start=0,this.match_length=0,this.prev_match=0,this.match_available=0,this.strstart=0,this.match_start=0,this.lookahead=0,this.prev_length=0,this.max_chain_length=0,this.max_lazy_match=0,this.level=0,this.strategy=0,this.good_match=0,this.nice_match=0,this.dyn_ltree=new Uint16Array(OX*2),this.dyn_dtree=new Uint16Array((2*NX+1)*2),this.bl_tree=new Uint16Array((2*xX+1)*2),l0(this.dyn_ltree),l0(this.dyn_dtree),l0(this.bl_tree),this.l_desc=null,this.d_desc=null,this.bl_desc=null,this.bl_count=new Uint16Array(FX+1),this.heap=new Uint16Array(2*P9+1),l0(this.heap),this.heap_len=0,this.heap_max=0,this.depth=new Uint16Array(2*P9+1),l0(this.depth),this.sym_buf=0,this.lit_bufsize=0,this.sym_next=0,this.sym_end=0,this.opt_len=0,this.static_len=0,this.matches=0,this.insert=0,this.bi_buf=0,this.bi_valid=0},qY=function(){this.input=null,this.next_in=0,this.avail_in=0,this.total_in=0,this.output=null,this.next_out=0,this.avail_out=0,this.total_out=0,this.msg="",this.state=null,this.data_type=2,this.adler=0},N1=function(J){this.options=$J.assign({level:KY,method:ZY,chunkSize:16384,windowBits:15,memLevel:8,strategy:WY},J||{});let Q=this.options;if(Q.raw&&Q.windowBits>0)Q.windowBits=-Q.windowBits;else if(Q.gzip&&Q.windowBits>0&&Q.windowBits<16)Q.windowBits+=16;this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new JQ,this.strm.avail_out=0;let q=$1.deflateInit2(this.strm,Q.level,Q.method,Q.windowBits,Q.memLevel,Q.strategy);if(q!==KJ)throw new Error($8[q]);if(Q.header)$1.deflateSetHeader(this.strm,Q.header);if(Q.dictionary){let G;if(typeof Q.dictionary==="string")G=P1.string2buf(Q.dictionary);else if(qQ.call(Q.dictionary)==="[object ArrayBuffer]")G=new Uint8Array(Q.dictionary);else G=Q.dictionary;if(q=$1.deflateSetDictionary(this.strm,G),q!==KJ)throw new Error($8[q]);this._dict_set=!0}},A9=function(J,Q){const q=new N1(Q);if(q.push(J,!0),q.err)throw q.msg||$8[q.err];return q.result},$Y=function(J,Q){return Q=Q||{},Q.raw=!0,A9(J,Q)},zY=function(J,Q){return Q=Q||{},Q.gzip=!0,A9(J,Q)},yY=function(){this.strm=null,this.mode=0,this.last=!1,this.wrap=0,this.havedict=!1,this.flags=0,this.dmax=0,this.check=0,this.total=0,this.head=null,this.wbits=0,this.wsize=0,this.whave=0,this.wnext=0,this.window=null,this.hold=0,this.bits=0,this.length=0,this.offset=0,this.extra=0,this.lencode=null,this.distcode=null,this.lenbits=0,this.distbits=0,this.ncode=0,this.nlen=0,this.ndist=0,this.have=0,this.next=null,this.lens=new Uint16Array(320),this.work=new Uint16Array(288),this.lendyn=null,this.distdyn=null,this.sane=0,this.back=0,this.was=0},sY=function(){this.text=0,this.time=0,this.xflags=0,this.os=0,this.extra=null,this.extra_len=0,this.name="",this.comment="",this.hcrc=0,this.done=!1},x1=function(J){this.options=$J.assign({chunkSize:65536,windowBits:15,to:""},J||{});const Q=this.options;if(Q.raw&&Q.windowBits>=0&&Q.windowBits<16){if(Q.windowBits=-Q.windowBits,Q.windowBits===0)Q.windowBits=-15}if(Q.windowBits>=0&&Q.windowBits<16&&!(J&&J.windowBits))Q.windowBits+=32;if(Q.windowBits>15&&Q.windowBits<48){if((Q.windowBits&15)===0)Q.windowBits|=15}this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new JQ,this.strm.avail_out=0;let q=m0.inflateInit2(this.strm,Q.windowBits);if(q!==k1)throw new Error($8[q]);if(this.header=new tY,m0.inflateGetHeader(this.strm,this.header),Q.dictionary){if(typeof Q.dictionary==="string")Q.dictionary=P1.string2buf(Q.dictionary);else if(HQ.call(Q.dictionary)==="[object ArrayBuffer]")Q.dictionary=new Uint8Array(Q.dictionary);if(Q.raw){if(q=m0.inflateSetDictionary(this.strm,Q.dictionary),q!==k1)throw new Error($8[q])}}},R9=function(J,Q){const q=new x1(Q);if(q.push(J),q.err)throw q.msg||$8[q.err];return q.result},GV=function(J,Q){return Q=Q||{},Q.raw=!0,R9(J,Q)};/*! pako 2.1.0 https://github.com/nodeca/pako @license (MIT AND Zlib) */var g7=0,v6=1,v7=2,y7=3,E7=258,O9=29,C1=256,U1=C1+1+O9,h8=30,F9=19,y6=2*U1+1,K8=15,q9=16,h7=7,S9=256,E6=16,h6=17,m6=18,M9=new Uint8Array([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0]),YJ=new Uint8Array([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13]),m7=new Uint8Array([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7]),_6=new Uint8Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),_7=512,h0=new Array((U1+2)*2);b8(h0);var Z1=new Array(h8*2);b8(Z1);var H1=new Array(_7);b8(H1);var j1=new Array(E7-y7+1);b8(j1);var D9=new Array(O9);b8(D9);var VJ=new Array(h8);b8(VJ);var b6,u6,c6,p6=(J)=>{return J<256?H1[J]:H1[256+(J>>>7)]},M1=(J,Q)=>{J.pending_buf[J.pending++]=Q&255,J.pending_buf[J.pending++]=Q>>>8&255},$0=(J,Q,q)=>{if(J.bi_valid>q9-q)J.bi_buf|=Q<<J.bi_valid&65535,M1(J,J.bi_buf),J.bi_buf=Q>>q9-J.bi_valid,J.bi_valid+=q-q9;else J.bi_buf|=Q<<J.bi_valid&65535,J.bi_valid+=q},D0=(J,Q,q)=>{$0(J,q[Q*2],q[Q*2+1])},f6=(J,Q)=>{let q=0;do q|=J&1,J>>>=1,q<<=1;while(--Q>0);return q>>>1},b7=(J)=>{if(J.bi_valid===16)M1(J,J.bi_buf),J.bi_buf=0,J.bi_valid=0;else if(J.bi_valid>=8)J.pending_buf[J.pending++]=J.bi_buf&255,J.bi_buf>>=8,J.bi_valid-=8},u7=(J,Q)=>{const{dyn_tree:q,max_code:G}=Q,X=Q.stat_desc.static_tree,Y=Q.stat_desc.has_stree,V=Q.stat_desc.extra_bits,K=Q.stat_desc.extra_base,Z=Q.stat_desc.max_length;let W,$,B,z,U,M,H=0;for(z=0;z<=K8;z++)J.bl_count[z]=0;q[J.heap[J.heap_max]*2+1]=0;for(W=J.heap_max+1;W<y6;W++){if($=J.heap[W],z=q[q[$*2+1]*2+1]+1,z>Z)z=Z,H++;if(q[$*2+1]=z,$>G)continue;if(J.bl_count[z]++,U=0,$>=K)U=V[$-K];if(M=q[$*2],J.opt_len+=M*(z+U),Y)J.static_len+=M*(X[$*2+1]+U)}if(H===0)return;do{z=Z-1;while(J.bl_count[z]===0)z--;J.bl_count[z]--,J.bl_count[z+1]+=2,J.bl_count[Z]--,H-=2}while(H>0);for(z=Z;z!==0;z--){$=J.bl_count[z];while($!==0){if(B=J.heap[--W],B>G)continue;if(q[B*2+1]!==z)J.opt_len+=(z-q[B*2+1])*q[B*2],q[B*2+1]=z;$--}}},l6=(J,Q,q)=>{const G=new Array(K8+1);let X=0,Y,V;for(Y=1;Y<=K8;Y++)X=X+q[Y-1]<<1,G[Y]=X;for(V=0;V<=Q;V++){let K=J[V*2+1];if(K===0)continue;J[V*2]=f6(G[K]++,K)}},c7=()=>{let J,Q,q,G,X;const Y=new Array(K8+1);q=0;for(G=0;G<O9-1;G++){D9[G]=q;for(J=0;J<1<<M9[G];J++)j1[q++]=G}j1[q-1]=G,X=0;for(G=0;G<16;G++){VJ[G]=X;for(J=0;J<1<<YJ[G];J++)H1[X++]=G}X>>=7;for(;G<h8;G++){VJ[G]=X<<7;for(J=0;J<1<<YJ[G]-7;J++)H1[256+X++]=G}for(Q=0;Q<=K8;Q++)Y[Q]=0;J=0;while(J<=143)h0[J*2+1]=8,J++,Y[8]++;while(J<=255)h0[J*2+1]=9,J++,Y[9]++;while(J<=279)h0[J*2+1]=7,J++,Y[7]++;while(J<=287)h0[J*2+1]=8,J++,Y[8]++;l6(h0,U1+1,Y);for(J=0;J<h8;J++)Z1[J*2+1]=5,Z1[J*2]=f6(J,5);b6=new Q9(h0,M9,C1+1,U1,K8),u6=new Q9(Z1,YJ,0,h8,K8),c6=new Q9(new Array(0),m7,0,F9,h7)},d6=(J)=>{let Q;for(Q=0;Q<U1;Q++)J.dyn_ltree[Q*2]=0;for(Q=0;Q<h8;Q++)J.dyn_dtree[Q*2]=0;for(Q=0;Q<F9;Q++)J.bl_tree[Q*2]=0;J.dyn_ltree[S9*2]=1,J.opt_len=J.static_len=0,J.sym_next=J.matches=0},i6=(J)=>{if(J.bi_valid>8)M1(J,J.bi_buf);else if(J.bi_valid>0)J.pending_buf[J.pending++]=J.bi_buf;J.bi_buf=0,J.bi_valid=0},rq=(J,Q,q,G)=>{const X=Q*2,Y=q*2;return J[X]<J[Y]||J[X]===J[Y]&&G[Q]<=G[q]},X9=(J,Q,q)=>{const G=J.heap[q];let X=q<<1;while(X<=J.heap_len){if(X<J.heap_len&&rq(Q,J.heap[X+1],J.heap[X],J.depth))X++;if(rq(Q,G,J.heap[X],J.depth))break;J.heap[q]=J.heap[X],q=X,X<<=1}J.heap[q]=G},aq=(J,Q,q)=>{let G,X,Y=0,V,K;if(J.sym_next!==0)do if(G=J.pending_buf[J.sym_buf+Y++]&255,G+=(J.pending_buf[J.sym_buf+Y++]&255)<<8,X=J.pending_buf[J.sym_buf+Y++],G===0)D0(J,X,Q);else{if(V=j1[X],D0(J,V+C1+1,Q),K=M9[V],K!==0)X-=D9[V],$0(J,X,K);if(G--,V=p6(G),D0(J,V,q),K=YJ[V],K!==0)G-=VJ[V],$0(J,G,K)}while(Y<J.sym_next);D0(J,S9,Q)},B9=(J,Q)=>{const q=Q.dyn_tree,G=Q.stat_desc.static_tree,X=Q.stat_desc.has_stree,Y=Q.stat_desc.elems;let V,K,Z=-1,W;J.heap_len=0,J.heap_max=y6;for(V=0;V<Y;V++)if(q[V*2]!==0)J.heap[++J.heap_len]=Z=V,J.depth[V]=0;else q[V*2+1]=0;while(J.heap_len<2)if(W=J.heap[++J.heap_len]=Z<2?++Z:0,q[W*2]=1,J.depth[W]=0,J.opt_len--,X)J.static_len-=G[W*2+1];Q.max_code=Z;for(V=J.heap_len>>1;V>=1;V--)X9(J,q,V);W=Y;do V=J.heap[1],J.heap[1]=J.heap[J.heap_len--],X9(J,q,1),K=J.heap[1],J.heap[--J.heap_max]=V,J.heap[--J.heap_max]=K,q[W*2]=q[V*2]+q[K*2],J.depth[W]=(J.depth[V]>=J.depth[K]?J.depth[V]:J.depth[K])+1,q[V*2+1]=q[K*2+1]=W,J.heap[1]=W++,X9(J,q,1);while(J.heap_len>=2);J.heap[--J.heap_max]=J.heap[1],u7(J,Q),l6(q,Z,J.bl_count)},sq=(J,Q,q)=>{let G,X=-1,Y,V=Q[1],K=0,Z=7,W=4;if(V===0)Z=138,W=3;Q[(q+1)*2+1]=65535;for(G=0;G<=q;G++){if(Y=V,V=Q[(G+1)*2+1],++K<Z&&Y===V)continue;else if(K<W)J.bl_tree[Y*2]+=K;else if(Y!==0){if(Y!==X)J.bl_tree[Y*2]++;J.bl_tree[E6*2]++}else if(K<=10)J.bl_tree[h6*2]++;else J.bl_tree[m6*2]++;if(K=0,X=Y,V===0)Z=138,W=3;else if(Y===V)Z=6,W=3;else Z=7,W=4}},tq=(J,Q,q)=>{let G,X=-1,Y,V=Q[1],K=0,Z=7,W=4;if(V===0)Z=138,W=3;for(G=0;G<=q;G++){if(Y=V,V=Q[(G+1)*2+1],++K<Z&&Y===V)continue;else if(K<W)do D0(J,Y,J.bl_tree);while(--K!==0);else if(Y!==0){if(Y!==X)D0(J,Y,J.bl_tree),K--;D0(J,E6,J.bl_tree),$0(J,K-3,2)}else if(K<=10)D0(J,h6,J.bl_tree),$0(J,K-3,3);else D0(J,m6,J.bl_tree),$0(J,K-11,7);if(K=0,X=Y,V===0)Z=138,W=3;else if(Y===V)Z=6,W=3;else Z=7,W=4}},p7=(J)=>{let Q;sq(J,J.dyn_ltree,J.l_desc.max_code),sq(J,J.dyn_dtree,J.d_desc.max_code),B9(J,J.bl_desc);for(Q=F9-1;Q>=3;Q--)if(J.bl_tree[_6[Q]*2+1]!==0)break;return J.opt_len+=3*(Q+1)+5+5+4,Q},f7=(J,Q,q,G)=>{let X;$0(J,Q-257,5),$0(J,q-1,5),$0(J,G-4,4);for(X=0;X<G;X++)$0(J,J.bl_tree[_6[X]*2+1],3);tq(J,J.dyn_ltree,Q-1),tq(J,J.dyn_dtree,q-1)},l7=(J)=>{let Q=4093624447,q;for(q=0;q<=31;q++,Q>>>=1)if(Q&1&&J.dyn_ltree[q*2]!==0)return 0;if(J.dyn_ltree[18]!==0||J.dyn_ltree[20]!==0||J.dyn_ltree[26]!==0)return 1;for(q=32;q<C1;q++)if(J.dyn_ltree[q*2]!==0)return 1;return 0},eq=!1,d7=(J)=>{if(!eq)c7(),eq=!0;J.l_desc=new G9(J.dyn_ltree,b6),J.d_desc=new G9(J.dyn_dtree,u6),J.bl_desc=new G9(J.bl_tree,c6),J.bi_buf=0,J.bi_valid=0,d6(J)},o6=(J,Q,q,G)=>{if($0(J,(g7<<1)+(G?1:0),3),i6(J),M1(J,q),M1(J,~q),q)J.pending_buf.set(J.window.subarray(Q,Q+q),J.pending);J.pending+=q},i7=(J)=>{$0(J,v6<<1,3),D0(J,S9,h0),b7(J)},o7=(J,Q,q,G)=>{let X,Y,V=0;if(J.level>0){if(J.strm.data_type===2)J.strm.data_type=l7(J);if(B9(J,J.l_desc),B9(J,J.d_desc),V=p7(J),X=J.opt_len+3+7>>>3,Y=J.static_len+3+7>>>3,Y<=X)X=Y}else X=Y=q+5;if(q+4<=X&&Q!==-1)o6(J,Q,q,G);else if(J.strategy===4||Y===X)$0(J,(v6<<1)+(G?1:0),3),aq(J,h0,Z1);else $0(J,(v7<<1)+(G?1:0),3),f7(J,J.l_desc.max_code+1,J.d_desc.max_code+1,V+1),aq(J,J.dyn_ltree,J.dyn_dtree);if(d6(J),G)i6(J)},n7=(J,Q,q)=>{if(J.pending_buf[J.sym_buf+J.sym_next++]=Q,J.pending_buf[J.sym_buf+J.sym_next++]=Q>>8,J.pending_buf[J.sym_buf+J.sym_next++]=q,Q===0)J.dyn_ltree[q*2]++;else J.matches++,Q--,J.dyn_ltree[(j1[q]+C1+1)*2]++,J.dyn_dtree[p6(Q)*2]++;return J.sym_next===J.sym_end},r7=d7,a7=o6,s7=o7,t7=n7,e7=i7,JX={_tr_init:r7,_tr_stored_block:a7,_tr_flush_block:s7,_tr_tally:t7,_tr_align:e7},qX=(J,Q,q,G)=>{let X=J&65535|0,Y=J>>>16&65535|0,V=0;while(q!==0){V=q>2000?2000:q,q-=V;do X=X+Q[G++]|0,Y=Y+X|0;while(--V);X%=65521,Y%=65521}return X|Y<<16|0},B1=qX,QX=()=>{let J,Q=[];for(var q=0;q<256;q++){J=q;for(var G=0;G<8;G++)J=J&1?3988292384^J>>>1:J>>>1;Q[q]=J}return Q},GX=new Uint32Array(QX()),XX=(J,Q,q,G)=>{const X=GX,Y=G+q;J^=-1;for(let V=G;V<Y;V++)J=J>>>8^X[(J^Q[V])&255];return J^-1},Q0=XX,$8={2:"need dictionary",1:"stream end",0:"","-1":"file error","-2":"stream error","-3":"data error","-4":"insufficient memory","-5":"buffer error","-6":"incompatible version"},H8={Z_NO_FLUSH:0,Z_PARTIAL_FLUSH:1,Z_SYNC_FLUSH:2,Z_FULL_FLUSH:3,Z_FINISH:4,Z_BLOCK:5,Z_TREES:6,Z_OK:0,Z_STREAM_END:1,Z_NEED_DICT:2,Z_ERRNO:-1,Z_STREAM_ERROR:-2,Z_DATA_ERROR:-3,Z_MEM_ERROR:-4,Z_BUF_ERROR:-5,Z_NO_COMPRESSION:0,Z_BEST_SPEED:1,Z_BEST_COMPRESSION:9,Z_DEFAULT_COMPRESSION:-1,Z_FILTERED:1,Z_HUFFMAN_ONLY:2,Z_RLE:3,Z_FIXED:4,Z_DEFAULT_STRATEGY:0,Z_BINARY:0,Z_TEXT:1,Z_UNKNOWN:2,Z_DEFLATED:8},{_tr_init:YX,_tr_stored_block:L9,_tr_flush_block:VX,_tr_tally:i0,_tr_align:KX}=JX,{Z_NO_FLUSH:o0,Z_PARTIAL_FLUSH:WX,Z_FULL_FLUSH:ZX,Z_FINISH:P0,Z_BLOCK:J6,Z_OK:Y0,Z_STREAM_END:q6,Z_STREAM_ERROR:I0,Z_DATA_ERROR:$X,Z_BUF_ERROR:Y9,Z_DEFAULT_COMPRESSION:zX,Z_FILTERED:UX,Z_HUFFMAN_ONLY:JJ,Z_RLE:HX,Z_FIXED:jX,Z_DEFAULT_STRATEGY:MX,Z_UNKNOWN:BX,Z_DEFLATED:ZJ}=H8,LX=9,PX=15,kX=8,CX=29,wX=256,P9=wX+1+CX,NX=30,xX=19,OX=2*P9+1,FX=15,m=3,d0=258,A0=d0+m+1,SX=32,m8=42,I9=57,k9=69,C9=73,w9=91,N9=103,W8=113,K1=666,Z0=1,u8=2,z8=3,c8=4,DX=3,Z8=(J,Q)=>{return J.msg=$8[Q],Q},Q6=(J)=>{return J*2-(J>4?9:0)},l0=(J)=>{let Q=J.length;while(--Q>=0)J[Q]=0},IX=(J)=>{let Q,q,G,X=J.w_size;Q=J.hash_size,G=Q;do q=J.head[--G],J.head[G]=q>=X?q-X:0;while(--Q);Q=X,G=Q;do q=J.prev[--G],J.prev[G]=q>=X?q-X:0;while(--Q)},AX=(J,Q,q)=>(Q<<J.hash_shift^q)&J.hash_mask,n0=AX,j0=(J)=>{const Q=J.state;let q=Q.pending;if(q>J.avail_out)q=J.avail_out;if(q===0)return;if(J.output.set(Q.pending_buf.subarray(Q.pending_out,Q.pending_out+q),J.next_out),J.next_out+=q,Q.pending_out+=q,J.total_out+=q,J.avail_out-=q,Q.pending-=q,Q.pending===0)Q.pending_out=0},M0=(J,Q)=>{VX(J,J.block_start>=0?J.block_start:-1,J.strstart-J.block_start,Q),J.block_start=J.strstart,j0(J.strm)},_=(J,Q)=>{J.pending_buf[J.pending++]=Q},V1=(J,Q)=>{J.pending_buf[J.pending++]=Q>>>8&255,J.pending_buf[J.pending++]=Q&255},x9=(J,Q,q,G)=>{let X=J.avail_in;if(X>G)X=G;if(X===0)return 0;if(J.avail_in-=X,Q.set(J.input.subarray(J.next_in,J.next_in+X),q),J.state.wrap===1)J.adler=B1(J.adler,Q,X,q);else if(J.state.wrap===2)J.adler=Q0(J.adler,Q,X,q);return J.next_in+=X,J.total_in+=X,X},n6=(J,Q)=>{let{max_chain_length:q,strstart:G}=J,X,Y,V=J.prev_length,K=J.nice_match;const Z=J.strstart>J.w_size-A0?J.strstart-(J.w_size-A0):0,W=J.window,$=J.w_mask,B=J.prev,z=J.strstart+d0;let U=W[G+V-1],M=W[G+V];if(J.prev_length>=J.good_match)q>>=2;if(K>J.lookahead)K=J.lookahead;do{if(X=Q,W[X+V]!==M||W[X+V-1]!==U||W[X]!==W[G]||W[++X]!==W[G+1])continue;G+=2,X++;do;while(W[++G]===W[++X]&&W[++G]===W[++X]&&W[++G]===W[++X]&&W[++G]===W[++X]&&W[++G]===W[++X]&&W[++G]===W[++X]&&W[++G]===W[++X]&&W[++G]===W[++X]&&G<z);if(Y=d0-(z-G),G=z-d0,Y>V){if(J.match_start=Q,V=Y,Y>=K)break;U=W[G+V-1],M=W[G+V]}}while((Q=B[Q&$])>Z&&--q!==0);if(V<=J.lookahead)return V;return J.lookahead},_8=(J)=>{const Q=J.w_size;let q,G,X;do{if(G=J.window_size-J.lookahead-J.strstart,J.strstart>=Q+(Q-A0)){if(J.window.set(J.window.subarray(Q,Q+Q-G),0),J.match_start-=Q,J.strstart-=Q,J.block_start-=Q,J.insert>J.strstart)J.insert=J.strstart;IX(J),G+=Q}if(J.strm.avail_in===0)break;if(q=x9(J.strm,J.window,J.strstart+J.lookahead,G),J.lookahead+=q,J.lookahead+J.insert>=m){X=J.strstart-J.insert,J.ins_h=J.window[X],J.ins_h=n0(J,J.ins_h,J.window[X+1]);while(J.insert)if(J.ins_h=n0(J,J.ins_h,J.window[X+m-1]),J.prev[X&J.w_mask]=J.head[J.ins_h],J.head[J.ins_h]=X,X++,J.insert--,J.lookahead+J.insert<m)break}}while(J.lookahead<A0&&J.strm.avail_in!==0)},r6=(J,Q)=>{let q=J.pending_buf_size-5>J.w_size?J.w_size:J.pending_buf_size-5,G,X,Y,V=0,K=J.strm.avail_in;do{if(G=65535,Y=J.bi_valid+42>>3,J.strm.avail_out<Y)break;if(Y=J.strm.avail_out-Y,X=J.strstart-J.block_start,G>X+J.strm.avail_in)G=X+J.strm.avail_in;if(G>Y)G=Y;if(G<q&&(G===0&&Q!==P0||Q===o0||G!==X+J.strm.avail_in))break;if(V=Q===P0&&G===X+J.strm.avail_in?1:0,L9(J,0,0,V),J.pending_buf[J.pending-4]=G,J.pending_buf[J.pending-3]=G>>8,J.pending_buf[J.pending-2]=~G,J.pending_buf[J.pending-1]=~G>>8,j0(J.strm),X){if(X>G)X=G;J.strm.output.set(J.window.subarray(J.block_start,J.block_start+X),J.strm.next_out),J.strm.next_out+=X,J.strm.avail_out-=X,J.strm.total_out+=X,J.block_start+=X,G-=X}if(G)x9(J.strm,J.strm.output,J.strm.next_out,G),J.strm.next_out+=G,J.strm.avail_out-=G,J.strm.total_out+=G}while(V===0);if(K-=J.strm.avail_in,K){if(K>=J.w_size)J.matches=2,J.window.set(J.strm.input.subarray(J.strm.next_in-J.w_size,J.strm.next_in),0),J.strstart=J.w_size,J.insert=J.strstart;else{if(J.window_size-J.strstart<=K){if(J.strstart-=J.w_size,J.window.set(J.window.subarray(J.w_size,J.w_size+J.strstart),0),J.matches<2)J.matches++;if(J.insert>J.strstart)J.insert=J.strstart}J.window.set(J.strm.input.subarray(J.strm.next_in-K,J.strm.next_in),J.strstart),J.strstart+=K,J.insert+=K>J.w_size-J.insert?J.w_size-J.insert:K}J.block_start=J.strstart}if(J.high_water<J.strstart)J.high_water=J.strstart;if(V)return c8;if(Q!==o0&&Q!==P0&&J.strm.avail_in===0&&J.strstart===J.block_start)return u8;if(Y=J.window_size-J.strstart,J.strm.avail_in>Y&&J.block_start>=J.w_size){if(J.block_start-=J.w_size,J.strstart-=J.w_size,J.window.set(J.window.subarray(J.w_size,J.w_size+J.strstart),0),J.matches<2)J.matches++;if(Y+=J.w_size,J.insert>J.strstart)J.insert=J.strstart}if(Y>J.strm.avail_in)Y=J.strm.avail_in;if(Y)x9(J.strm,J.window,J.strstart,Y),J.strstart+=Y,J.insert+=Y>J.w_size-J.insert?J.w_size-J.insert:Y;if(J.high_water<J.strstart)J.high_water=J.strstart;if(Y=J.bi_valid+42>>3,Y=J.pending_buf_size-Y>65535?65535:J.pending_buf_size-Y,q=Y>J.w_size?J.w_size:Y,X=J.strstart-J.block_start,X>=q||(X||Q===P0)&&Q!==o0&&J.strm.avail_in===0&&X<=Y)G=X>Y?Y:X,V=Q===P0&&J.strm.avail_in===0&&G===X?1:0,L9(J,J.block_start,G,V),J.block_start+=G,j0(J.strm);return V?z8:Z0},V9=(J,Q)=>{let q,G;for(;;){if(J.lookahead<A0){if(_8(J),J.lookahead<A0&&Q===o0)return Z0;if(J.lookahead===0)break}if(q=0,J.lookahead>=m)J.ins_h=n0(J,J.ins_h,J.window[J.strstart+m-1]),q=J.prev[J.strstart&J.w_mask]=J.head[J.ins_h],J.head[J.ins_h]=J.strstart;if(q!==0&&J.strstart-q<=J.w_size-A0)J.match_length=n6(J,q);if(J.match_length>=m)if(G=i0(J,J.strstart-J.match_start,J.match_length-m),J.lookahead-=J.match_length,J.match_length<=J.max_lazy_match&&J.lookahead>=m){J.match_length--;do J.strstart++,J.ins_h=n0(J,J.ins_h,J.window[J.strstart+m-1]),q=J.prev[J.strstart&J.w_mask]=J.head[J.ins_h],J.head[J.ins_h]=J.strstart;while(--J.match_length!==0);J.strstart++}else J.strstart+=J.match_length,J.match_length=0,J.ins_h=J.window[J.strstart],J.ins_h=n0(J,J.ins_h,J.window[J.strstart+1]);else G=i0(J,0,J.window[J.strstart]),J.lookahead--,J.strstart++;if(G){if(M0(J,!1),J.strm.avail_out===0)return Z0}}if(J.insert=J.strstart<m-1?J.strstart:m-1,Q===P0){if(M0(J,!0),J.strm.avail_out===0)return z8;return c8}if(J.sym_next){if(M0(J,!1),J.strm.avail_out===0)return Z0}return u8},y8=(J,Q)=>{let q,G,X;for(;;){if(J.lookahead<A0){if(_8(J),J.lookahead<A0&&Q===o0)return Z0;if(J.lookahead===0)break}if(q=0,J.lookahead>=m)J.ins_h=n0(J,J.ins_h,J.window[J.strstart+m-1]),q=J.prev[J.strstart&J.w_mask]=J.head[J.ins_h],J.head[J.ins_h]=J.strstart;if(J.prev_length=J.match_length,J.prev_match=J.match_start,J.match_length=m-1,q!==0&&J.prev_length<J.max_lazy_match&&J.strstart-q<=J.w_size-A0){if(J.match_length=n6(J,q),J.match_length<=5&&(J.strategy===UX||J.match_length===m&&J.strstart-J.match_start>4096))J.match_length=m-1}if(J.prev_length>=m&&J.match_length<=J.prev_length){X=J.strstart+J.lookahead-m,G=i0(J,J.strstart-1-J.prev_match,J.prev_length-m),J.lookahead-=J.prev_length-1,J.prev_length-=2;do if(++J.strstart<=X)J.ins_h=n0(J,J.ins_h,J.window[J.strstart+m-1]),q=J.prev[J.strstart&J.w_mask]=J.head[J.ins_h],J.head[J.ins_h]=J.strstart;while(--J.prev_length!==0);if(J.match_available=0,J.match_length=m-1,J.strstart++,G){if(M0(J,!1),J.strm.avail_out===0)return Z0}}else if(J.match_available){if(G=i0(J,0,J.window[J.strstart-1]),G)M0(J,!1);if(J.strstart++,J.lookahead--,J.strm.avail_out===0)return Z0}else J.match_available=1,J.strstart++,J.lookahead--}if(J.match_available)G=i0(J,0,J.window[J.strstart-1]),J.match_available=0;if(J.insert=J.strstart<m-1?J.strstart:m-1,Q===P0){if(M0(J,!0),J.strm.avail_out===0)return z8;return c8}if(J.sym_next){if(M0(J,!1),J.strm.avail_out===0)return Z0}return u8},RX=(J,Q)=>{let q,G,X,Y;const V=J.window;for(;;){if(J.lookahead<=d0){if(_8(J),J.lookahead<=d0&&Q===o0)return Z0;if(J.lookahead===0)break}if(J.match_length=0,J.lookahead>=m&&J.strstart>0){if(X=J.strstart-1,G=V[X],G===V[++X]&&G===V[++X]&&G===V[++X]){Y=J.strstart+d0;do;while(G===V[++X]&&G===V[++X]&&G===V[++X]&&G===V[++X]&&G===V[++X]&&G===V[++X]&&G===V[++X]&&G===V[++X]&&X<Y);if(J.match_length=d0-(Y-X),J.match_length>J.lookahead)J.match_length=J.lookahead}}if(J.match_length>=m)q=i0(J,1,J.match_length-m),J.lookahead-=J.match_length,J.strstart+=J.match_length,J.match_length=0;else q=i0(J,0,J.window[J.strstart]),J.lookahead--,J.strstart++;if(q){if(M0(J,!1),J.strm.avail_out===0)return Z0}}if(J.insert=0,Q===P0){if(M0(J,!0),J.strm.avail_out===0)return z8;return c8}if(J.sym_next){if(M0(J,!1),J.strm.avail_out===0)return Z0}return u8},TX=(J,Q)=>{let q;for(;;){if(J.lookahead===0){if(_8(J),J.lookahead===0){if(Q===o0)return Z0;break}}if(J.match_length=0,q=i0(J,0,J.window[J.strstart]),J.lookahead--,J.strstart++,q){if(M0(J,!1),J.strm.avail_out===0)return Z0}}if(J.insert=0,Q===P0){if(M0(J,!0),J.strm.avail_out===0)return z8;return c8}if(J.sym_next){if(M0(J,!1),J.strm.avail_out===0)return Z0}return u8},W1=[new S0(0,0,0,0,r6),new S0(4,4,8,4,V9),new S0(4,5,16,8,V9),new S0(4,6,32,32,V9),new S0(4,4,16,16,y8),new S0(8,16,32,32,y8),new S0(8,16,128,128,y8),new S0(8,32,128,256,y8),new S0(32,128,258,1024,y8),new S0(32,258,258,4096,y8)],gX=(J)=>{J.window_size=2*J.w_size,l0(J.head),J.max_lazy_match=W1[J.level].max_lazy,J.good_match=W1[J.level].good_length,J.nice_match=W1[J.level].nice_length,J.max_chain_length=W1[J.level].max_chain,J.strstart=0,J.block_start=0,J.lookahead=0,J.insert=0,J.match_length=J.prev_length=m-1,J.match_available=0,J.ins_h=0},w1=(J)=>{if(!J)return 1;const Q=J.state;if(!Q||Q.strm!==J||Q.status!==m8&&Q.status!==I9&&Q.status!==k9&&Q.status!==C9&&Q.status!==w9&&Q.status!==N9&&Q.status!==W8&&Q.status!==K1)return 1;return 0},a6=(J)=>{if(w1(J))return Z8(J,I0);J.total_in=J.total_out=0,J.data_type=BX;const Q=J.state;if(Q.pending=0,Q.pending_out=0,Q.wrap<0)Q.wrap=-Q.wrap;return Q.status=Q.wrap===2?I9:Q.wrap?m8:W8,J.adler=Q.wrap===2?0:1,Q.last_flush=-2,YX(Q),Y0},s6=(J)=>{const Q=a6(J);if(Q===Y0)gX(J.state);return Q},yX=(J,Q)=>{if(w1(J)||J.state.wrap!==2)return I0;return J.state.gzhead=Q,Y0},t6=(J,Q,q,G,X,Y)=>{if(!J)return I0;let V=1;if(Q===zX)Q=6;if(G<0)V=0,G=-G;else if(G>15)V=2,G-=16;if(X<1||X>LX||q!==ZJ||G<8||G>15||Q<0||Q>9||Y<0||Y>jX||G===8&&V!==1)return Z8(J,I0);if(G===8)G=9;const K=new vX;return J.state=K,K.strm=J,K.status=m8,K.wrap=V,K.gzhead=null,K.w_bits=G,K.w_size=1<<K.w_bits,K.w_mask=K.w_size-1,K.hash_bits=X+7,K.hash_size=1<<K.hash_bits,K.hash_mask=K.hash_size-1,K.hash_shift=~~((K.hash_bits+m-1)/m),K.window=new Uint8Array(K.w_size*2),K.head=new Uint16Array(K.hash_size),K.prev=new Uint16Array(K.w_size),K.lit_bufsize=1<<X+6,K.pending_buf_size=K.lit_bufsize*4,K.pending_buf=new Uint8Array(K.pending_buf_size),K.sym_buf=K.lit_bufsize,K.sym_end=(K.lit_bufsize-1)*3,K.level=Q,K.strategy=Y,K.method=q,s6(J)},EX=(J,Q)=>{return t6(J,Q,ZJ,PX,kX,MX)},hX=(J,Q)=>{if(w1(J)||Q>J6||Q<0)return J?Z8(J,I0):I0;const q=J.state;if(!J.output||J.avail_in!==0&&!J.input||q.status===K1&&Q!==P0)return Z8(J,J.avail_out===0?Y9:I0);const G=q.last_flush;if(q.last_flush=Q,q.pending!==0){if(j0(J),J.avail_out===0)return q.last_flush=-1,Y0}else if(J.avail_in===0&&Q6(Q)<=Q6(G)&&Q!==P0)return Z8(J,Y9);if(q.status===K1&&J.avail_in!==0)return Z8(J,Y9);if(q.status===m8&&q.wrap===0)q.status=W8;if(q.status===m8){let X=ZJ+(q.w_bits-8<<4)<<8,Y=-1;if(q.strategy>=JJ||q.level<2)Y=0;else if(q.level<6)Y=1;else if(q.level===6)Y=2;else Y=3;if(X|=Y<<6,q.strstart!==0)X|=SX;if(X+=31-X%31,V1(q,X),q.strstart!==0)V1(q,J.adler>>>16),V1(q,J.adler&65535);if(J.adler=1,q.status=W8,j0(J),q.pending!==0)return q.last_flush=-1,Y0}if(q.status===I9)if(J.adler=0,_(q,31),_(q,139),_(q,8),!q.gzhead){if(_(q,0),_(q,0),_(q,0),_(q,0),_(q,0),_(q,q.level===9?2:q.strategy>=JJ||q.level<2?4:0),_(q,DX),q.status=W8,j0(J),q.pending!==0)return q.last_flush=-1,Y0}else{if(_(q,(q.gzhead.text?1:0)+(q.gzhead.hcrc?2:0)+(!q.gzhead.extra?0:4)+(!q.gzhead.name?0:8)+(!q.gzhead.comment?0:16)),_(q,q.gzhead.time&255),_(q,q.gzhead.time>>8&255),_(q,q.gzhead.time>>16&255),_(q,q.gzhead.time>>24&255),_(q,q.level===9?2:q.strategy>=JJ||q.level<2?4:0),_(q,q.gzhead.os&255),q.gzhead.extra&&q.gzhead.extra.length)_(q,q.gzhead.extra.length&255),_(q,q.gzhead.extra.length>>8&255);if(q.gzhead.hcrc)J.adler=Q0(J.adler,q.pending_buf,q.pending,0);q.gzindex=0,q.status=k9}if(q.status===k9){if(q.gzhead.extra){let X=q.pending,Y=(q.gzhead.extra.length&65535)-q.gzindex;while(q.pending+Y>q.pending_buf_size){let K=q.pending_buf_size-q.pending;if(q.pending_buf.set(q.gzhead.extra.subarray(q.gzindex,q.gzindex+K),q.pending),q.pending=q.pending_buf_size,q.gzhead.hcrc&&q.pending>X)J.adler=Q0(J.adler,q.pending_buf,q.pending-X,X);if(q.gzindex+=K,j0(J),q.pending!==0)return q.last_flush=-1,Y0;X=0,Y-=K}let V=new Uint8Array(q.gzhead.extra);if(q.pending_buf.set(V.subarray(q.gzindex,q.gzindex+Y),q.pending),q.pending+=Y,q.gzhead.hcrc&&q.pending>X)J.adler=Q0(J.adler,q.pending_buf,q.pending-X,X);q.gzindex=0}q.status=C9}if(q.status===C9){if(q.gzhead.name){let X=q.pending,Y;do{if(q.pending===q.pending_buf_size){if(q.gzhead.hcrc&&q.pending>X)J.adler=Q0(J.adler,q.pending_buf,q.pending-X,X);if(j0(J),q.pending!==0)return q.last_flush=-1,Y0;X=0}if(q.gzindex<q.gzhead.name.length)Y=q.gzhead.name.charCodeAt(q.gzindex++)&255;else Y=0;_(q,Y)}while(Y!==0);if(q.gzhead.hcrc&&q.pending>X)J.adler=Q0(J.adler,q.pending_buf,q.pending-X,X);q.gzindex=0}q.status=w9}if(q.status===w9){if(q.gzhead.comment){let X=q.pending,Y;do{if(q.pending===q.pending_buf_size){if(q.gzhead.hcrc&&q.pending>X)J.adler=Q0(J.adler,q.pending_buf,q.pending-X,X);if(j0(J),q.pending!==0)return q.last_flush=-1,Y0;X=0}if(q.gzindex<q.gzhead.comment.length)Y=q.gzhead.comment.charCodeAt(q.gzindex++)&255;else Y=0;_(q,Y)}while(Y!==0);if(q.gzhead.hcrc&&q.pending>X)J.adler=Q0(J.adler,q.pending_buf,q.pending-X,X)}q.status=N9}if(q.status===N9){if(q.gzhead.hcrc){if(q.pending+2>q.pending_buf_size){if(j0(J),q.pending!==0)return q.last_flush=-1,Y0}_(q,J.adler&255),_(q,J.adler>>8&255),J.adler=0}if(q.status=W8,j0(J),q.pending!==0)return q.last_flush=-1,Y0}if(J.avail_in!==0||q.lookahead!==0||Q!==o0&&q.status!==K1){let X=q.level===0?r6(q,Q):q.strategy===JJ?TX(q,Q):q.strategy===HX?RX(q,Q):W1[q.level].func(q,Q);if(X===z8||X===c8)q.status=K1;if(X===Z0||X===z8){if(J.avail_out===0)q.last_flush=-1;return Y0}if(X===u8){if(Q===WX)KX(q);else if(Q!==J6){if(L9(q,0,0,!1),Q===ZX){if(l0(q.head),q.lookahead===0)q.strstart=0,q.block_start=0,q.insert=0}}if(j0(J),J.avail_out===0)return q.last_flush=-1,Y0}}if(Q!==P0)return Y0;if(q.wrap<=0)return q6;if(q.wrap===2)_(q,J.adler&255),_(q,J.adler>>8&255),_(q,J.adler>>16&255),_(q,J.adler>>24&255),_(q,J.total_in&255),_(q,J.total_in>>8&255),_(q,J.total_in>>16&255),_(q,J.total_in>>24&255);else V1(q,J.adler>>>16),V1(q,J.adler&65535);if(j0(J),q.wrap>0)q.wrap=-q.wrap;return q.pending!==0?Y0:q6},mX=(J)=>{if(w1(J))return I0;const Q=J.state.status;return J.state=null,Q===W8?Z8(J,$X):Y0},_X=(J,Q)=>{let q=Q.length;if(w1(J))return I0;const G=J.state,X=G.wrap;if(X===2||X===1&&G.status!==m8||G.lookahead)return I0;if(X===1)J.adler=B1(J.adler,Q,q,0);if(G.wrap=0,q>=G.w_size){if(X===0)l0(G.head),G.strstart=0,G.block_start=0,G.insert=0;let Z=new Uint8Array(G.w_size);Z.set(Q.subarray(q-G.w_size,q),0),Q=Z,q=G.w_size}const{avail_in:Y,next_in:V,input:K}=J;J.avail_in=q,J.next_in=0,J.input=Q,_8(G);while(G.lookahead>=m){let Z=G.strstart,W=G.lookahead-(m-1);do G.ins_h=n0(G,G.ins_h,G.window[Z+m-1]),G.prev[Z&G.w_mask]=G.head[G.ins_h],G.head[G.ins_h]=Z,Z++;while(--W);G.strstart=Z,G.lookahead=m-1,_8(G)}return G.strstart+=G.lookahead,G.block_start=G.strstart,G.insert=G.lookahead,G.lookahead=0,G.match_length=G.prev_length=m-1,G.match_available=0,J.next_in=V,J.input=K,J.avail_in=Y,G.wrap=X,Y0},bX=EX,uX=t6,cX=s6,pX=a6,fX=yX,lX=hX,dX=mX,iX=_X,oX="pako deflate (from Nodeca project)",$1={deflateInit:bX,deflateInit2:uX,deflateReset:cX,deflateResetKeep:pX,deflateSetHeader:fX,deflate:lX,deflateEnd:dX,deflateSetDictionary:iX,deflateInfo:oX},nX=(J,Q)=>{return Object.prototype.hasOwnProperty.call(J,Q)},rX=function(J){const Q=Array.prototype.slice.call(arguments,1);while(Q.length){const q=Q.shift();if(!q)continue;if(typeof q!=="object")throw new TypeError(q+"must be non-object");for(let G in q)if(nX(q,G))J[G]=q[G]}return J},aX=(J)=>{let Q=0;for(let G=0,X=J.length;G<X;G++)Q+=J[G].length;const q=new Uint8Array(Q);for(let G=0,X=0,Y=J.length;G<Y;G++){let V=J[G];q.set(V,X),X+=V.length}return q},$J={assign:rX,flattenChunks:aX},e6=!0;try{String.fromCharCode.apply(null,new Uint8Array(1))}catch(J){e6=!1}var L1=new Uint8Array(256);for(let J=0;J<256;J++)L1[J]=J>=252?6:J>=248?5:J>=240?4:J>=224?3:J>=192?2:1;L1[254]=L1[254]=1;var sX=(J)=>{if(typeof TextEncoder==="function"&&TextEncoder.prototype.encode)return(new TextEncoder()).encode(J);let Q,q,G,X,Y,V=J.length,K=0;for(X=0;X<V;X++){if(q=J.charCodeAt(X),(q&64512)===55296&&X+1<V){if(G=J.charCodeAt(X+1),(G&64512)===56320)q=65536+(q-55296<<10)+(G-56320),X++}K+=q<128?1:q<2048?2:q<65536?3:4}Q=new Uint8Array(K);for(Y=0,X=0;Y<K;X++){if(q=J.charCodeAt(X),(q&64512)===55296&&X+1<V){if(G=J.charCodeAt(X+1),(G&64512)===56320)q=65536+(q-55296<<10)+(G-56320),X++}if(q<128)Q[Y++]=q;else if(q<2048)Q[Y++]=192|q>>>6,Q[Y++]=128|q&63;else if(q<65536)Q[Y++]=224|q>>>12,Q[Y++]=128|q>>>6&63,Q[Y++]=128|q&63;else Q[Y++]=240|q>>>18,Q[Y++]=128|q>>>12&63,Q[Y++]=128|q>>>6&63,Q[Y++]=128|q&63}return Q},tX=(J,Q)=>{if(Q<65534){if(J.subarray&&e6)return String.fromCharCode.apply(null,J.length===Q?J:J.subarray(0,Q))}let q="";for(let G=0;G<Q;G++)q+=String.fromCharCode(J[G]);return q},eX=(J,Q)=>{const q=Q||J.length;if(typeof TextDecoder==="function"&&TextDecoder.prototype.decode)return(new TextDecoder()).decode(J.subarray(0,Q));let G,X;const Y=new Array(q*2);for(X=0,G=0;G<q;){let V=J[G++];if(V<128){Y[X++]=V;continue}let K=L1[V];if(K>4){Y[X++]=65533,G+=K-1;continue}V&=K===2?31:K===3?15:7;while(K>1&&G<q)V=V<<6|J[G++]&63,K--;if(K>1){Y[X++]=65533;continue}if(V<65536)Y[X++]=V;else V-=65536,Y[X++]=55296|V>>10&1023,Y[X++]=56320|V&1023}return tX(Y,X)},JY=(J,Q)=>{if(Q=Q||J.length,Q>J.length)Q=J.length;let q=Q-1;while(q>=0&&(J[q]&192)===128)q--;if(q<0)return Q;if(q===0)return Q;return q+L1[J[q]]>Q?q:Q},P1={string2buf:sX,buf2string:eX,utf8border:JY},JQ=qY,qQ=Object.prototype.toString,{Z_NO_FLUSH:QY,Z_SYNC_FLUSH:GY,Z_FULL_FLUSH:XY,Z_FINISH:YY,Z_OK:KJ,Z_STREAM_END:VY,Z_DEFAULT_COMPRESSION:KY,Z_DEFAULT_STRATEGY:WY,Z_DEFLATED:ZY}=H8;N1.prototype.push=function(J,Q){const q=this.strm,G=this.options.chunkSize;let X,Y;if(this.ended)return!1;if(Q===~~Q)Y=Q;else Y=Q===!0?YY:QY;if(typeof J==="string")q.input=P1.string2buf(J);else if(qQ.call(J)==="[object ArrayBuffer]")q.input=new Uint8Array(J);else q.input=J;q.next_in=0,q.avail_in=q.input.length;for(;;){if(q.avail_out===0)q.output=new Uint8Array(G),q.next_out=0,q.avail_out=G;if((Y===GY||Y===XY)&&q.avail_out<=6){this.onData(q.output.subarray(0,q.next_out)),q.avail_out=0;continue}if(X=$1.deflate(q,Y),X===VY){if(q.next_out>0)this.onData(q.output.subarray(0,q.next_out));return X=$1.deflateEnd(this.strm),this.onEnd(X),this.ended=!0,X===KJ}if(q.avail_out===0){this.onData(q.output);continue}if(Y>0&&q.next_out>0){this.onData(q.output.subarray(0,q.next_out)),q.avail_out=0;continue}if(q.avail_in===0)break}return!0};N1.prototype.onData=function(J){this.chunks.push(J)};N1.prototype.onEnd=function(J){if(J===KJ)this.result=$J.flattenChunks(this.chunks);this.chunks=[],this.err=J,this.msg=this.strm.msg};var UY=N1,HY=A9,jY=$Y,MY=zY,BY=H8,LY={Deflate:UY,deflate:HY,deflateRaw:jY,gzip:MY,constants:BY},qJ=16209,PY=16191,kY=function J(Q,q){let G,X,Y,V,K,Z,W,$,B,z,U,M,H,j,P,x,F,L,I,D,O,S,y,A;const T=Q.state;G=Q.next_in,y=Q.input,X=G+(Q.avail_in-5),Y=Q.next_out,A=Q.output,V=Y-(q-Q.avail_out),K=Y+(Q.avail_out-257),Z=T.dmax,W=T.wsize,$=T.whave,B=T.wnext,z=T.window,U=T.hold,M=T.bits,H=T.lencode,j=T.distcode,P=(1<<T.lenbits)-1,x=(1<<T.distbits)-1;J:do{if(M<15)U+=y[G++]<<M,M+=8,U+=y[G++]<<M,M+=8;F=H[U&P];q:for(;;){if(L=F>>>24,U>>>=L,M-=L,L=F>>>16&255,L===0)A[Y++]=F&65535;else if(L&16){if(I=F&65535,L&=15,L){if(M<L)U+=y[G++]<<M,M+=8;I+=U&(1<<L)-1,U>>>=L,M-=L}if(M<15)U+=y[G++]<<M,M+=8,U+=y[G++]<<M,M+=8;F=j[U&x];Q:for(;;){if(L=F>>>24,U>>>=L,M-=L,L=F>>>16&255,L&16){if(D=F&65535,L&=15,M<L){if(U+=y[G++]<<M,M+=8,M<L)U+=y[G++]<<M,M+=8}if(D+=U&(1<<L)-1,D>Z){Q.msg="invalid distance too far back",T.mode=qJ;break J}if(U>>>=L,M-=L,L=Y-V,D>L){if(L=D-L,L>$){if(T.sane){Q.msg="invalid distance too far back",T.mode=qJ;break J}}if(O=0,S=z,B===0){if(O+=W-L,L<I){I-=L;do A[Y++]=z[O++];while(--L);O=Y-D,S=A}}else if(B<L){if(O+=W+B-L,L-=B,L<I){I-=L;do A[Y++]=z[O++];while(--L);if(O=0,B<I){L=B,I-=L;do A[Y++]=z[O++];while(--L);O=Y-D,S=A}}}else if(O+=B-L,L<I){I-=L;do A[Y++]=z[O++];while(--L);O=Y-D,S=A}while(I>2)A[Y++]=S[O++],A[Y++]=S[O++],A[Y++]=S[O++],I-=3;if(I){if(A[Y++]=S[O++],I>1)A[Y++]=S[O++]}}else{O=Y-D;do A[Y++]=A[O++],A[Y++]=A[O++],A[Y++]=A[O++],I-=3;while(I>2);if(I){if(A[Y++]=A[O++],I>1)A[Y++]=A[O++]}}}else if((L&64)===0){F=j[(F&65535)+(U&(1<<L)-1)];continue Q}else{Q.msg="invalid distance code",T.mode=qJ;break J}break}}else if((L&64)===0){F=H[(F&65535)+(U&(1<<L)-1)];continue q}else if(L&32){T.mode=PY;break J}else{Q.msg="invalid literal/length code",T.mode=qJ;break J}break}}while(G<X&&Y<K);I=M>>3,G-=I,M-=I<<3,U&=(1<<M)-1,Q.next_in=G,Q.next_out=Y,Q.avail_in=G<X?5+(X-G):5-(G-X),Q.avail_out=Y<K?257+(K-Y):257-(Y-K),T.hold=U,T.bits=M;return},E8=15,G6=852,X6=592,Y6=0,K9=1,V6=2,CY=new Uint16Array([3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,0,0]),wY=new Uint8Array([16,16,16,16,16,16,16,16,17,17,17,17,18,18,18,18,19,19,19,19,20,20,20,20,21,21,21,21,16,72,78]),NY=new Uint16Array([1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,0,0]),xY=new Uint8Array([16,16,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,64,64]),OY=(J,Q,q,G,X,Y,V,K)=>{const Z=K.bits;let W=0,$=0,B=0,z=0,U=0,M=0,H=0,j=0,P=0,x=0,F,L,I,D,O,S=null,y;const A=new Uint16Array(E8+1),T=new Uint16Array(E8+1);let w=null,R,k,N;for(W=0;W<=E8;W++)A[W]=0;for($=0;$<G;$++)A[Q[q+$]]++;U=Z;for(z=E8;z>=1;z--)if(A[z]!==0)break;if(U>z)U=z;if(z===0)return X[Y++]=1<<24|64<<16|0,X[Y++]=1<<24|64<<16|0,K.bits=1,0;for(B=1;B<z;B++)if(A[B]!==0)break;if(U<B)U=B;j=1;for(W=1;W<=E8;W++)if(j<<=1,j-=A[W],j<0)return-1;if(j>0&&(J===Y6||z!==1))return-1;T[1]=0;for(W=1;W<E8;W++)T[W+1]=T[W]+A[W];for($=0;$<G;$++)if(Q[q+$]!==0)V[T[Q[q+$]]++]=$;if(J===Y6)S=w=V,y=20;else if(J===K9)S=CY,w=wY,y=257;else S=NY,w=xY,y=0;if(x=0,$=0,W=B,O=Y,M=U,H=0,I=-1,P=1<<U,D=P-1,J===K9&&P>G6||J===V6&&P>X6)return 1;for(;;){if(R=W-H,V[$]+1<y)k=0,N=V[$];else if(V[$]>=y)k=w[V[$]-y],N=S[V[$]-y];else k=96,N=0;F=1<<W-H,L=1<<M,B=L;do L-=F,X[O+(x>>H)+L]=R<<24|k<<16|N|0;while(L!==0);F=1<<W-1;while(x&F)F>>=1;if(F!==0)x&=F-1,x+=F;else x=0;if($++,--A[W]===0){if(W===z)break;W=Q[q+V[$]]}if(W>U&&(x&D)!==I){if(H===0)H=U;O+=B,M=W-H,j=1<<M;while(M+H<z){if(j-=A[M+H],j<=0)break;M++,j<<=1}if(P+=1<<M,J===K9&&P>G6||J===V6&&P>X6)return 1;I=x&D,X[I]=U<<24|M<<16|O-Y|0}}if(x!==0)X[O+x]=W-H<<24|64<<16|0;return K.bits=U,0},z1=OY,FY=0,QQ=1,GQ=2,{Z_FINISH:K6,Z_BLOCK:SY,Z_TREES:QJ,Z_OK:U8,Z_STREAM_END:DY,Z_NEED_DICT:IY,Z_STREAM_ERROR:k0,Z_DATA_ERROR:XQ,Z_MEM_ERROR:YQ,Z_BUF_ERROR:AY,Z_DEFLATED:W6}=H8,zJ=16180,Z6=16181,$6=16182,z6=16183,U6=16184,H6=16185,j6=16186,M6=16187,B6=16188,L6=16189,WJ=16190,E0=16191,W9=16192,P6=16193,Z9=16194,k6=16195,C6=16196,w6=16197,N6=16198,GJ=16199,XJ=16200,x6=16201,O6=16202,F6=16203,S6=16204,D6=16205,$9=16206,I6=16207,A6=16208,d=16209,VQ=16210,KQ=16211,RY=852,TY=592,gY=15,vY=gY,R6=(J)=>{return(J>>>24&255)+(J>>>8&65280)+((J&65280)<<8)+((J&255)<<24)},j8=(J)=>{if(!J)return 1;const Q=J.state;if(!Q||Q.strm!==J||Q.mode<zJ||Q.mode>KQ)return 1;return 0},WQ=(J)=>{if(j8(J))return k0;const Q=J.state;if(J.total_in=J.total_out=Q.total=0,J.msg="",Q.wrap)J.adler=Q.wrap&1;return Q.mode=zJ,Q.last=0,Q.havedict=0,Q.flags=-1,Q.dmax=32768,Q.head=null,Q.hold=0,Q.bits=0,Q.lencode=Q.lendyn=new Int32Array(RY),Q.distcode=Q.distdyn=new Int32Array(TY),Q.sane=1,Q.back=-1,U8},ZQ=(J)=>{if(j8(J))return k0;const Q=J.state;return Q.wsize=0,Q.whave=0,Q.wnext=0,WQ(J)},$Q=(J,Q)=>{let q;if(j8(J))return k0;const G=J.state;if(Q<0)q=0,Q=-Q;else if(q=(Q>>4)+5,Q<48)Q&=15;if(Q&&(Q<8||Q>15))return k0;if(G.window!==null&&G.wbits!==Q)G.window=null;return G.wrap=q,G.wbits=Q,ZQ(J)},zQ=(J,Q)=>{if(!J)return k0;const q=new yY;J.state=q,q.strm=J,q.window=null,q.mode=zJ;const G=$Q(J,Q);if(G!==U8)J.state=null;return G},EY=(J)=>{return zQ(J,vY)},T6=!0,z9,U9,hY=(J)=>{if(T6){z9=new Int32Array(512),U9=new Int32Array(32);let Q=0;while(Q<144)J.lens[Q++]=8;while(Q<256)J.lens[Q++]=9;while(Q<280)J.lens[Q++]=7;while(Q<288)J.lens[Q++]=8;z1(QQ,J.lens,0,288,z9,0,J.work,{bits:9}),Q=0;while(Q<32)J.lens[Q++]=5;z1(GQ,J.lens,0,32,U9,0,J.work,{bits:5}),T6=!1}J.lencode=z9,J.lenbits=9,J.distcode=U9,J.distbits=5},UQ=(J,Q,q,G)=>{let X;const Y=J.state;if(Y.window===null)Y.wsize=1<<Y.wbits,Y.wnext=0,Y.whave=0,Y.window=new Uint8Array(Y.wsize);if(G>=Y.wsize)Y.window.set(Q.subarray(q-Y.wsize,q),0),Y.wnext=0,Y.whave=Y.wsize;else{if(X=Y.wsize-Y.wnext,X>G)X=G;if(Y.window.set(Q.subarray(q-G,q-G+X),Y.wnext),G-=X,G)Y.window.set(Q.subarray(q-G,q),0),Y.wnext=G,Y.whave=Y.wsize;else{if(Y.wnext+=X,Y.wnext===Y.wsize)Y.wnext=0;if(Y.whave<Y.wsize)Y.whave+=X}}return 0},mY=(J,Q)=>{let q,G,X,Y,V,K,Z,W,$,B,z,U,M,H,j=0,P,x,F,L,I,D,O,S;const y=new Uint8Array(4);let A,T;const w=new Uint8Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]);if(j8(J)||!J.output||!J.input&&J.avail_in!==0)return k0;if(q=J.state,q.mode===E0)q.mode=W9;V=J.next_out,X=J.output,Z=J.avail_out,Y=J.next_in,G=J.input,K=J.avail_in,W=q.hold,$=q.bits,B=K,z=Z,S=U8;J:for(;;)switch(q.mode){case zJ:if(q.wrap===0){q.mode=W9;break}while($<16){if(K===0)break J;K--,W+=G[Y++]<<$,$+=8}if(q.wrap&2&&W===35615){if(q.wbits===0)q.wbits=15;q.check=0,y[0]=W&255,y[1]=W>>>8&255,q.check=Q0(q.check,y,2,0),W=0,$=0,q.mode=Z6;break}if(q.head)q.head.done=!1;if(!(q.wrap&1)||(((W&255)<<8)+(W>>8))%31){J.msg="incorrect header check",q.mode=d;break}if((W&15)!==W6){J.msg="unknown compression method",q.mode=d;break}if(W>>>=4,$-=4,O=(W&15)+8,q.wbits===0)q.wbits=O;if(O>15||O>q.wbits){J.msg="invalid window size",q.mode=d;break}q.dmax=1<<q.wbits,q.flags=0,J.adler=q.check=1,q.mode=W&512?L6:E0,W=0,$=0;break;case Z6:while($<16){if(K===0)break J;K--,W+=G[Y++]<<$,$+=8}if(q.flags=W,(q.flags&255)!==W6){J.msg="unknown compression method",q.mode=d;break}if(q.flags&57344){J.msg="unknown header flags set",q.mode=d;break}if(q.head)q.head.text=W>>8&1;if(q.flags&512&&q.wrap&4)y[0]=W&255,y[1]=W>>>8&255,q.check=Q0(q.check,y,2,0);W=0,$=0,q.mode=$6;case $6:while($<32){if(K===0)break J;K--,W+=G[Y++]<<$,$+=8}if(q.head)q.head.time=W;if(q.flags&512&&q.wrap&4)y[0]=W&255,y[1]=W>>>8&255,y[2]=W>>>16&255,y[3]=W>>>24&255,q.check=Q0(q.check,y,4,0);W=0,$=0,q.mode=z6;case z6:while($<16){if(K===0)break J;K--,W+=G[Y++]<<$,$+=8}if(q.head)q.head.xflags=W&255,q.head.os=W>>8;if(q.flags&512&&q.wrap&4)y[0]=W&255,y[1]=W>>>8&255,q.check=Q0(q.check,y,2,0);W=0,$=0,q.mode=U6;case U6:if(q.flags&1024){while($<16){if(K===0)break J;K--,W+=G[Y++]<<$,$+=8}if(q.length=W,q.head)q.head.extra_len=W;if(q.flags&512&&q.wrap&4)y[0]=W&255,y[1]=W>>>8&255,q.check=Q0(q.check,y,2,0);W=0,$=0}else if(q.head)q.head.extra=null;q.mode=H6;case H6:if(q.flags&1024){if(U=q.length,U>K)U=K;if(U){if(q.head){if(O=q.head.extra_len-q.length,!q.head.extra)q.head.extra=new Uint8Array(q.head.extra_len);q.head.extra.set(G.subarray(Y,Y+U),O)}if(q.flags&512&&q.wrap&4)q.check=Q0(q.check,G,U,Y);K-=U,Y+=U,q.length-=U}if(q.length)break J}q.length=0,q.mode=j6;case j6:if(q.flags&2048){if(K===0)break J;U=0;do if(O=G[Y+U++],q.head&&O&&q.length<65536)q.head.name+=String.fromCharCode(O);while(O&&U<K);if(q.flags&512&&q.wrap&4)q.check=Q0(q.check,G,U,Y);if(K-=U,Y+=U,O)break J}else if(q.head)q.head.name=null;q.length=0,q.mode=M6;case M6:if(q.flags&4096){if(K===0)break J;U=0;do if(O=G[Y+U++],q.head&&O&&q.length<65536)q.head.comment+=String.fromCharCode(O);while(O&&U<K);if(q.flags&512&&q.wrap&4)q.check=Q0(q.check,G,U,Y);if(K-=U,Y+=U,O)break J}else if(q.head)q.head.comment=null;q.mode=B6;case B6:if(q.flags&512){while($<16){if(K===0)break J;K--,W+=G[Y++]<<$,$+=8}if(q.wrap&4&&W!==(q.check&65535)){J.msg="header crc mismatch",q.mode=d;break}W=0,$=0}if(q.head)q.head.hcrc=q.flags>>9&1,q.head.done=!0;J.adler=q.check=0,q.mode=E0;break;case L6:while($<32){if(K===0)break J;K--,W+=G[Y++]<<$,$+=8}J.adler=q.check=R6(W),W=0,$=0,q.mode=WJ;case WJ:if(q.havedict===0)return J.next_out=V,J.avail_out=Z,J.next_in=Y,J.avail_in=K,q.hold=W,q.bits=$,IY;J.adler=q.check=1,q.mode=E0;case E0:if(Q===SY||Q===QJ)break J;case W9:if(q.last){W>>>=$&7,$-=$&7,q.mode=$9;break}while($<3){if(K===0)break J;K--,W+=G[Y++]<<$,$+=8}switch(q.last=W&1,W>>>=1,$-=1,W&3){case 0:q.mode=P6;break;case 1:if(hY(q),q.mode=GJ,Q===QJ){W>>>=2,$-=2;break J}break;case 2:q.mode=C6;break;case 3:J.msg="invalid block type",q.mode=d}W>>>=2,$-=2;break;case P6:W>>>=$&7,$-=$&7;while($<32){if(K===0)break J;K--,W+=G[Y++]<<$,$+=8}if((W&65535)!==(W>>>16^65535)){J.msg="invalid stored block lengths",q.mode=d;break}if(q.length=W&65535,W=0,$=0,q.mode=Z9,Q===QJ)break J;case Z9:q.mode=k6;case k6:if(U=q.length,U){if(U>K)U=K;if(U>Z)U=Z;if(U===0)break J;X.set(G.subarray(Y,Y+U),V),K-=U,Y+=U,Z-=U,V+=U,q.length-=U;break}q.mode=E0;break;case C6:while($<14){if(K===0)break J;K--,W+=G[Y++]<<$,$+=8}if(q.nlen=(W&31)+257,W>>>=5,$-=5,q.ndist=(W&31)+1,W>>>=5,$-=5,q.ncode=(W&15)+4,W>>>=4,$-=4,q.nlen>286||q.ndist>30){J.msg="too many length or distance symbols",q.mode=d;break}q.have=0,q.mode=w6;case w6:while(q.have<q.ncode){while($<3){if(K===0)break J;K--,W+=G[Y++]<<$,$+=8}q.lens[w[q.have++]]=W&7,W>>>=3,$-=3}while(q.have<19)q.lens[w[q.have++]]=0;if(q.lencode=q.lendyn,q.lenbits=7,A={bits:q.lenbits},S=z1(FY,q.lens,0,19,q.lencode,0,q.work,A),q.lenbits=A.bits,S){J.msg="invalid code lengths set",q.mode=d;break}q.have=0,q.mode=N6;case N6:while(q.have<q.nlen+q.ndist){for(;;){if(j=q.lencode[W&(1<<q.lenbits)-1],P=j>>>24,x=j>>>16&255,F=j&65535,P<=$)break;if(K===0)break J;K--,W+=G[Y++]<<$,$+=8}if(F<16)W>>>=P,$-=P,q.lens[q.have++]=F;else{if(F===16){T=P+2;while($<T){if(K===0)break J;K--,W+=G[Y++]<<$,$+=8}if(W>>>=P,$-=P,q.have===0){J.msg="invalid bit length repeat",q.mode=d;break}O=q.lens[q.have-1],U=3+(W&3),W>>>=2,$-=2}else if(F===17){T=P+3;while($<T){if(K===0)break J;K--,W+=G[Y++]<<$,$+=8}W>>>=P,$-=P,O=0,U=3+(W&7),W>>>=3,$-=3}else{T=P+7;while($<T){if(K===0)break J;K--,W+=G[Y++]<<$,$+=8}W>>>=P,$-=P,O=0,U=11+(W&127),W>>>=7,$-=7}if(q.have+U>q.nlen+q.ndist){J.msg="invalid bit length repeat",q.mode=d;break}while(U--)q.lens[q.have++]=O}}if(q.mode===d)break;if(q.lens[256]===0){J.msg="invalid code -- missing end-of-block",q.mode=d;break}if(q.lenbits=9,A={bits:q.lenbits},S=z1(QQ,q.lens,0,q.nlen,q.lencode,0,q.work,A),q.lenbits=A.bits,S){J.msg="invalid literal/lengths set",q.mode=d;break}if(q.distbits=6,q.distcode=q.distdyn,A={bits:q.distbits},S=z1(GQ,q.lens,q.nlen,q.ndist,q.distcode,0,q.work,A),q.distbits=A.bits,S){J.msg="invalid distances set",q.mode=d;break}if(q.mode=GJ,Q===QJ)break J;case GJ:q.mode=XJ;case XJ:if(K>=6&&Z>=258){if(J.next_out=V,J.avail_out=Z,J.next_in=Y,J.avail_in=K,q.hold=W,q.bits=$,kY(J,z),V=J.next_out,X=J.output,Z=J.avail_out,Y=J.next_in,G=J.input,K=J.avail_in,W=q.hold,$=q.bits,q.mode===E0)q.back=-1;break}q.back=0;for(;;){if(j=q.lencode[W&(1<<q.lenbits)-1],P=j>>>24,x=j>>>16&255,F=j&65535,P<=$)break;if(K===0)break J;K--,W+=G[Y++]<<$,$+=8}if(x&&(x&240)===0){L=P,I=x,D=F;for(;;){if(j=q.lencode[D+((W&(1<<L+I)-1)>>L)],P=j>>>24,x=j>>>16&255,F=j&65535,L+P<=$)break;if(K===0)break J;K--,W+=G[Y++]<<$,$+=8}W>>>=L,$-=L,q.back+=L}if(W>>>=P,$-=P,q.back+=P,q.length=F,x===0){q.mode=D6;break}if(x&32){q.back=-1,q.mode=E0;break}if(x&64){J.msg="invalid literal/length code",q.mode=d;break}q.extra=x&15,q.mode=x6;case x6:if(q.extra){T=q.extra;while($<T){if(K===0)break J;K--,W+=G[Y++]<<$,$+=8}q.length+=W&(1<<q.extra)-1,W>>>=q.extra,$-=q.extra,q.back+=q.extra}q.was=q.length,q.mode=O6;case O6:for(;;){if(j=q.distcode[W&(1<<q.distbits)-1],P=j>>>24,x=j>>>16&255,F=j&65535,P<=$)break;if(K===0)break J;K--,W+=G[Y++]<<$,$+=8}if((x&240)===0){L=P,I=x,D=F;for(;;){if(j=q.distcode[D+((W&(1<<L+I)-1)>>L)],P=j>>>24,x=j>>>16&255,F=j&65535,L+P<=$)break;if(K===0)break J;K--,W+=G[Y++]<<$,$+=8}W>>>=L,$-=L,q.back+=L}if(W>>>=P,$-=P,q.back+=P,x&64){J.msg="invalid distance code",q.mode=d;break}q.offset=F,q.extra=x&15,q.mode=F6;case F6:if(q.extra){T=q.extra;while($<T){if(K===0)break J;K--,W+=G[Y++]<<$,$+=8}q.offset+=W&(1<<q.extra)-1,W>>>=q.extra,$-=q.extra,q.back+=q.extra}if(q.offset>q.dmax){J.msg="invalid distance too far back",q.mode=d;break}q.mode=S6;case S6:if(Z===0)break J;if(U=z-Z,q.offset>U){if(U=q.offset-U,U>q.whave){if(q.sane){J.msg="invalid distance too far back",q.mode=d;break}}if(U>q.wnext)U-=q.wnext,M=q.wsize-U;else M=q.wnext-U;if(U>q.length)U=q.length;H=q.window}else H=X,M=V-q.offset,U=q.length;if(U>Z)U=Z;Z-=U,q.length-=U;do X[V++]=H[M++];while(--U);if(q.length===0)q.mode=XJ;break;case D6:if(Z===0)break J;X[V++]=q.length,Z--,q.mode=XJ;break;case $9:if(q.wrap){while($<32){if(K===0)break J;K--,W|=G[Y++]<<$,$+=8}if(z-=Z,J.total_out+=z,q.total+=z,q.wrap&4&&z)J.adler=q.check=q.flags?Q0(q.check,X,z,V-z):B1(q.check,X,z,V-z);if(z=Z,q.wrap&4&&(q.flags?W:R6(W))!==q.check){J.msg="incorrect data check",q.mode=d;break}W=0,$=0}q.mode=I6;case I6:if(q.wrap&&q.flags){while($<32){if(K===0)break J;K--,W+=G[Y++]<<$,$+=8}if(q.wrap&4&&W!==(q.total&4294967295)){J.msg="incorrect length check",q.mode=d;break}W=0,$=0}q.mode=A6;case A6:S=DY;break J;case d:S=XQ;break J;case VQ:return YQ;case KQ:default:return k0}if(J.next_out=V,J.avail_out=Z,J.next_in=Y,J.avail_in=K,q.hold=W,q.bits=$,q.wsize||z!==J.avail_out&&q.mode<d&&(q.mode<$9||Q!==K6)){if(UQ(J,J.output,J.next_out,z-J.avail_out));}if(B-=J.avail_in,z-=J.avail_out,J.total_in+=B,J.total_out+=z,q.total+=z,q.wrap&4&&z)J.adler=q.check=q.flags?Q0(q.check,X,z,J.next_out-z):B1(q.check,X,z,J.next_out-z);if(J.data_type=q.bits+(q.last?64:0)+(q.mode===E0?128:0)+(q.mode===GJ||q.mode===Z9?256:0),(B===0&&z===0||Q===K6)&&S===U8)S=AY;return S},_Y=(J)=>{if(j8(J))return k0;let Q=J.state;if(Q.window)Q.window=null;return J.state=null,U8},bY=(J,Q)=>{if(j8(J))return k0;const q=J.state;if((q.wrap&2)===0)return k0;return q.head=Q,Q.done=!1,U8},uY=(J,Q)=>{const q=Q.length;let G,X,Y;if(j8(J))return k0;if(G=J.state,G.wrap!==0&&G.mode!==WJ)return k0;if(G.mode===WJ){if(X=1,X=B1(X,Q,q,0),X!==G.check)return XQ}if(Y=UQ(J,Q,q,q),Y)return G.mode=VQ,YQ;return G.havedict=1,U8},cY=ZQ,pY=$Q,fY=WQ,lY=EY,dY=zQ,iY=mY,oY=_Y,nY=bY,rY=uY,aY="pako inflate (from Nodeca project)",m0={inflateReset:cY,inflateReset2:pY,inflateResetKeep:fY,inflateInit:lY,inflateInit2:dY,inflate:iY,inflateEnd:oY,inflateGetHeader:nY,inflateSetDictionary:rY,inflateInfo:aY},tY=sY,HQ=Object.prototype.toString,{Z_NO_FLUSH:eY,Z_FINISH:JV,Z_OK:k1,Z_STREAM_END:H9,Z_NEED_DICT:j9,Z_STREAM_ERROR:qV,Z_DATA_ERROR:g6,Z_MEM_ERROR:QV}=H8;x1.prototype.push=function(J,Q){const q=this.strm,G=this.options.chunkSize,X=this.options.dictionary;let Y,V,K;if(this.ended)return!1;if(Q===~~Q)V=Q;else V=Q===!0?JV:eY;if(HQ.call(J)==="[object ArrayBuffer]")q.input=new Uint8Array(J);else q.input=J;q.next_in=0,q.avail_in=q.input.length;for(;;){if(q.avail_out===0)q.output=new Uint8Array(G),q.next_out=0,q.avail_out=G;if(Y=m0.inflate(q,V),Y===j9&&X){if(Y=m0.inflateSetDictionary(q,X),Y===k1)Y=m0.inflate(q,V);else if(Y===g6)Y=j9}while(q.avail_in>0&&Y===H9&&q.state.wrap>0&&J[q.next_in]!==0)m0.inflateReset(q),Y=m0.inflate(q,V);switch(Y){case qV:case g6:case j9:case QV:return this.onEnd(Y),this.ended=!0,!1}if(K=q.avail_out,q.next_out){if(q.avail_out===0||Y===H9)if(this.options.to==="string"){let Z=P1.utf8border(q.output,q.next_out),W=q.next_out-Z,$=P1.buf2string(q.output,Z);if(q.next_out=W,q.avail_out=G-W,W)q.output.set(q.output.subarray(Z,Z+W),0);this.onData($)}else this.onData(q.output.length===q.next_out?q.output:q.output.subarray(0,q.next_out))}if(Y===k1&&K===0)continue;if(Y===H9)return Y=m0.inflateEnd(this.strm),this.onEnd(Y),this.ended=!0,!0;if(q.avail_in===0)break}return!0};x1.prototype.onData=function(J){this.chunks.push(J)};x1.prototype.onEnd=function(J){if(J===k1)if(this.options.to==="string")this.result=this.chunks.join("");else this.result=$J.flattenChunks(this.chunks);this.chunks=[],this.err=J,this.msg=this.strm.msg};var XV=x1,YV=R9,VV=GV,KV=R9,WV=H8,ZV={Inflate:XV,inflate:YV,inflateRaw:VV,ungzip:KV,constants:WV},{Deflate:$V,deflate:zV,deflateRaw:UV,gzip:HV}=LY,{Inflate:jV,inflate:MV,inflateRaw:BV,ungzip:LV}=ZV,PV=$V,kV=zV,CV=UV,wV=HV,NV=jV,xV=MV,OV=BV,FV=LV,SV=H8,T9={Deflate:PV,deflate:kV,deflateRaw:CV,gzip:wV,Inflate:NV,inflate:xV,inflateRaw:OV,ungzip:FV,constants:SV};var jQ=function(J){if(!Number.isSafeInteger(J)||J<0)throw new Error("positive integer expected, got "+J)},DV=function(J){return J instanceof Uint8Array||ArrayBuffer.isView(J)&&J.constructor.name==="Uint8Array"},p8=function(J,...Q){if(!DV(J))throw new Error("Uint8Array expected");if(Q.length>0&&!Q.includes(J.length))throw new Error("Uint8Array expected of length "+Q+", got length="+J.length)},MQ=function(J){if(typeof J!=="function"||typeof J.create!=="function")throw new Error("Hash should be wrapped by utils.wrapConstructor");jQ(J.outputLen),jQ(J.blockLen)},f8=function(J,Q=!0){if(J.destroyed)throw new Error("Hash instance has been destroyed");if(Q&&J.finished)throw new Error("Hash#digest() has already been called")},BQ=function(J,Q){p8(J);const q=Q.outputLen;if(J.length<q)throw new Error("digestInto() expects output buffer of length at least "+q)};var M8=typeof globalThis==="object"&&("crypto"in globalThis)?globalThis.crypto:void 0;function UJ(J){return new DataView(J.buffer,J.byteOffset,J.byteLength)}function N0(J,Q){return J<<32-Q|J>>>Q}function IV(J){if(typeof J!=="string")throw new Error("utf8ToBytes expected string, got "+typeof J);return new Uint8Array((new TextEncoder()).encode(J))}function O1(J){if(typeof J==="string")J=IV(J);return p8(J),J}function LQ(...J){let Q=0;for(let G=0;G<J.length;G++){const X=J[G];p8(X),Q+=X.length}const q=new Uint8Array(Q);for(let G=0,X=0;G<J.length;G++){const Y=J[G];q.set(Y,X),X+=Y.length}return q}function PQ(J){const Q=(G)=>J().update(O1(G)).digest(),q=J();return Q.outputLen=q.outputLen,Q.blockLen=q.blockLen,Q.create=()=>J(),Q}function HJ(J=32){if(M8&&typeof M8.getRandomValues==="function")return M8.getRandomValues(new Uint8Array(J));if(M8&&typeof M8.randomBytes==="function")return M8.randomBytes(J);throw new Error("crypto.getRandomValues must be defined")}/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */class F1{clone(){return this._cloneInto()}}function AV(J,Q,q,G){if(typeof J.setBigUint64==="function")return J.setBigUint64(Q,q,G);const X=BigInt(32),Y=BigInt(4294967295),V=Number(q>>X&Y),K=Number(q&Y),Z=G?4:0,W=G?0:4;J.setUint32(Q+Z,V,G),J.setUint32(Q+W,K,G)}function kQ(J,Q,q){return J&Q^~J&q}function CQ(J,Q,q){return J&Q^J&q^Q&q}class g9 extends F1{constructor(J,Q,q,G){super();this.blockLen=J,this.outputLen=Q,this.padOffset=q,this.isLE=G,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(J),this.view=UJ(this.buffer)}update(J){f8(this);const{view:Q,buffer:q,blockLen:G}=this;J=O1(J);const X=J.length;for(let Y=0;Y<X;){const V=Math.min(G-this.pos,X-Y);if(V===G){const K=UJ(J);for(;G<=X-Y;Y+=G)this.process(K,Y);continue}if(q.set(J.subarray(Y,Y+V),this.pos),this.pos+=V,Y+=V,this.pos===G)this.process(Q,0),this.pos=0}return this.length+=J.length,this.roundClean(),this}digestInto(J){f8(this),BQ(J,this),this.finished=!0;const{buffer:Q,view:q,blockLen:G,isLE:X}=this;let{pos:Y}=this;if(Q[Y++]=128,this.buffer.subarray(Y).fill(0),this.padOffset>G-Y)this.process(q,0),Y=0;for(let $=Y;$<G;$++)Q[$]=0;AV(q,G-8,BigInt(this.length*8),X),this.process(q,0);const V=UJ(J),K=this.outputLen;if(K%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const Z=K/4,W=this.get();if(Z>W.length)throw new Error("_sha2: outputLen bigger than state");for(let $=0;$<Z;$++)V.setUint32(4*$,W[$],X)}digest(){const{buffer:J,outputLen:Q}=this;this.digestInto(J);const q=J.slice(0,Q);return this.destroy(),q}_cloneInto(J){J||(J=new this.constructor),J.set(...this.get());const{blockLen:Q,buffer:q,length:G,finished:X,destroyed:Y,pos:V}=this;if(J.length=G,J.pos=V,J.finished=X,J.destroyed=Y,G%Q)J.buffer.set(q);return J}}var RV=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),r0=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),a0=new Uint32Array(64);class wQ extends g9{constructor(){super(64,32,8,!1);this.A=r0[0]|0,this.B=r0[1]|0,this.C=r0[2]|0,this.D=r0[3]|0,this.E=r0[4]|0,this.F=r0[5]|0,this.G=r0[6]|0,this.H=r0[7]|0}get(){const{A:J,B:Q,C:q,D:G,E:X,F:Y,G:V,H:K}=this;return[J,Q,q,G,X,Y,V,K]}set(J,Q,q,G,X,Y,V,K){this.A=J|0,this.B=Q|0,this.C=q|0,this.D=G|0,this.E=X|0,this.F=Y|0,this.G=V|0,this.H=K|0}process(J,Q){for(let $=0;$<16;$++,Q+=4)a0[$]=J.getUint32(Q,!1);for(let $=16;$<64;$++){const B=a0[$-15],z=a0[$-2],U=N0(B,7)^N0(B,18)^B>>>3,M=N0(z,17)^N0(z,19)^z>>>10;a0[$]=M+a0[$-7]+U+a0[$-16]|0}let{A:q,B:G,C:X,D:Y,E:V,F:K,G:Z,H:W}=this;for(let $=0;$<64;$++){const B=N0(V,6)^N0(V,11)^N0(V,25),z=W+B+kQ(V,K,Z)+RV[$]+a0[$]|0,M=(N0(q,2)^N0(q,13)^N0(q,22))+CQ(q,G,X)|0;W=Z,Z=K,K=V,V=Y+z|0,Y=X,X=G,G=q,q=z+M|0}q=q+this.A|0,G=G+this.B|0,X=X+this.C|0,Y=Y+this.D|0,V=V+this.E|0,K=K+this.F|0,Z=Z+this.G|0,W=W+this.H|0,this.set(q,G,X,Y,V,K,Z,W)}roundClean(){a0.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}}var jJ=PQ(()=>new wQ);class v9 extends F1{constructor(J,Q){super();this.finished=!1,this.destroyed=!1,MQ(J);const q=O1(Q);if(this.iHash=J.create(),typeof this.iHash.update!=="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const G=this.blockLen,X=new Uint8Array(G);X.set(q.length>G?J.create().update(q).digest():q);for(let Y=0;Y<X.length;Y++)X[Y]^=54;this.iHash.update(X),this.oHash=J.create();for(let Y=0;Y<X.length;Y++)X[Y]^=54^92;this.oHash.update(X),X.fill(0)}update(J){return f8(this),this.iHash.update(J),this}digestInto(J){f8(this),p8(J,this.outputLen),this.finished=!0,this.iHash.digestInto(J),this.oHash.update(J),this.oHash.digestInto(J),this.destroy()}digest(){const J=new Uint8Array(this.oHash.outputLen);return this.digestInto(J),J}_cloneInto(J){J||(J=Object.create(Object.getPrototypeOf(this),{}));const{oHash:Q,iHash:q,finished:G,destroyed:X,blockLen:Y,outputLen:V}=this;return J=J,J.finished=G,J.destroyed=X,J.blockLen=Y,J.outputLen=V,J.oHash=Q._cloneInto(J.oHash),J.iHash=q._cloneInto(J.iHash),J}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}var y9=(J,Q,q)=>new v9(J,Q).update(q).digest();y9.create=(J,Q)=>new v9(J,Q);var u9={};mq(u9,{validateObject:()=>{{return e0}},utf8ToBytes:()=>{{return EV}},numberToVarBytesBE:()=>{{return vV}},numberToHexUnpadded:()=>{{return P8}},numberToBytesLE:()=>{{return PJ}},numberToBytesBE:()=>{{return x0}},notImplemented:()=>{{return bV}},memoized:()=>{{return kJ}},isBytes:()=>{{return s0}},inRange:()=>{{return t0}},hexToNumber:()=>{{return m9}},hexToBytes:()=>{{return k8}},equalBytes:()=>{{return yV}},ensureBytes:()=>{{return e}},createHmacDrbg:()=>{{return b9}},concatBytes:()=>{{return b0}},bytesToNumberLE:()=>{{return LJ}},bytesToNumberBE:()=>{{return C0}},bytesToHex:()=>{{return L8}},bitSet:()=>{{return mV}},bitMask:()=>{{return S1}},bitLen:()=>{{return _9}},bitGet:()=>{{return hV}},abytes:()=>{{return l8}},abool:()=>{{return B8}},aInRange:()=>{{return R0}}});function s0(J){return J instanceof Uint8Array||ArrayBuffer.isView(J)&&J.constructor.name==="Uint8Array"}function l8(J){if(!s0(J))throw new Error("Uint8Array expected")}function B8(J,Q){if(typeof Q!=="boolean")throw new Error(J+" boolean expected, got "+Q)}function L8(J){l8(J);let Q="";for(let q=0;q<J.length;q++)Q+=gV[J[q]];return Q}function P8(J){const Q=J.toString(16);return Q.length&1?"0"+Q:Q}function m9(J){if(typeof J!=="string")throw new Error("hex string expected, got "+typeof J);return J===""?MJ:BigInt("0x"+J)}var NQ=function(J){if(J>=_0._0&&J<=_0._9)return J-_0._0;if(J>=_0.A&&J<=_0.F)return J-(_0.A-10);if(J>=_0.a&&J<=_0.f)return J-(_0.a-10);return};function k8(J){if(typeof J!=="string")throw new Error("hex string expected, got "+typeof J);const Q=J.length,q=Q/2;if(Q%2)throw new Error("hex string expected, got unpadded hex of length "+Q);const G=new Uint8Array(q);for(let X=0,Y=0;X<q;X++,Y+=2){const V=NQ(J.charCodeAt(Y)),K=NQ(J.charCodeAt(Y+1));if(V===void 0||K===void 0){const Z=J[Y]+J[Y+1];throw new Error('hex string expected, got non-hex character "'+Z+'" at index '+Y)}G[X]=V*16+K}return G}function C0(J){return m9(L8(J))}function LJ(J){return l8(J),m9(L8(Uint8Array.from(J).reverse()))}function x0(J,Q){return k8(J.toString(16).padStart(Q*2,"0"))}function PJ(J,Q){return x0(J,Q).reverse()}function vV(J){return k8(P8(J))}function e(J,Q,q){let G;if(typeof Q==="string")try{G=k8(Q)}catch(Y){throw new Error(J+" must be hex string or Uint8Array, cause: "+Y)}else if(s0(Q))G=Uint8Array.from(Q);else throw new Error(J+" must be hex string or Uint8Array");const X=G.length;if(typeof q==="number"&&X!==q)throw new Error(J+" of length "+q+" expected, got "+X);return G}function b0(...J){let Q=0;for(let G=0;G<J.length;G++){const X=J[G];l8(X),Q+=X.length}const q=new Uint8Array(Q);for(let G=0,X=0;G<J.length;G++){const Y=J[G];q.set(Y,X),X+=Y.length}return q}function yV(J,Q){if(J.length!==Q.length)return!1;let q=0;for(let G=0;G<J.length;G++)q|=J[G]^Q[G];return q===0}function EV(J){if(typeof J!=="string")throw new Error("string expected");return new Uint8Array((new TextEncoder()).encode(J))}function t0(J,Q,q){return E9(J)&&E9(Q)&&E9(q)&&Q<=J&&J<q}function R0(J,Q,q,G){if(!t0(Q,q,G))throw new Error("expected valid "+J+": "+q+" <= n < "+G+", got "+Q)}function _9(J){let Q;for(Q=0;J>MJ;J>>=BJ,Q+=1);return Q}function hV(J,Q){return J>>BigInt(Q)&BJ}function mV(J,Q,q){return J|(q?BJ:MJ)<<BigInt(Q)}function b9(J,Q,q){if(typeof J!=="number"||J<2)throw new Error("hashLen must be a number");if(typeof Q!=="number"||Q<2)throw new Error("qByteLen must be a number");if(typeof q!=="function")throw new Error("hmacFn must be a function");let G=h9(J),X=h9(J),Y=0;const V=()=>{G.fill(1),X.fill(0),Y=0},K=(...B)=>q(X,G,...B),Z=(B=h9())=>{if(X=K(xQ([0]),B),G=K(),B.length===0)return;X=K(xQ([1]),B),G=K()},W=()=>{if(Y++>=1000)throw new Error("drbg: tried 1000 values");let B=0;const z=[];while(B<Q){G=K();const U=G.slice();z.push(U),B+=G.length}return b0(...z)};return(B,z)=>{V(),Z(B);let U=void 0;while(!(U=z(W())))Z();return V(),U}}function e0(J,Q,q={}){const G=(X,Y,V)=>{const K=_V[Y];if(typeof K!=="function")throw new Error("invalid validator function");const Z=J[X];if(V&&Z===void 0)return;if(!K(Z,J))throw new Error("param "+String(X)+" is invalid. Expected "+Y+", got "+Z)};for(let[X,Y]of Object.entries(Q))G(X,Y,!1);for(let[X,Y]of Object.entries(q))G(X,Y,!0);return J}function kJ(J){const Q=new WeakMap;return(q,...G)=>{const X=Q.get(q);if(X!==void 0)return X;const Y=J(q,...G);return Q.set(q,Y),Y}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */var MJ=BigInt(0),BJ=BigInt(1),TV=BigInt(2),gV=Array.from({length:256},(J,Q)=>Q.toString(16).padStart(2,"0")),_0={_0:48,_9:57,A:65,F:70,a:97,f:102},E9=(J)=>typeof J==="bigint"&&MJ<=J,S1=(J)=>(TV<<BigInt(J-1))-BJ,h9=(J)=>new Uint8Array(J),xQ=(J)=>Uint8Array.from(J),_V={bigint:(J)=>typeof J==="bigint",function:(J)=>typeof J==="function",boolean:(J)=>typeof J==="boolean",string:(J)=>typeof J==="string",stringOrUint8Array:(J)=>typeof J==="string"||s0(J),isSafeInteger:(J)=>Number.isSafeInteger(J),array:(J)=>Array.isArray(J),field:(J,Q)=>Q.Fp.isValid(J),hash:(J)=>typeof J==="function"&&Number.isSafeInteger(J.outputLen)},bV=()=>{throw new Error("not implemented")};function J0(J,Q){const q=J%Q;return q>=q0?q:Q+q}function fV(J,Q,q){if(Q<q0)throw new Error("invalid exponent, negatives unsupported");if(q<=q0)throw new Error("invalid modulus");if(q===r)return q0;let G=r;while(Q>q0){if(Q&r)G=G*J%q;J=J*J%q,Q>>=r}return G}function B0(J,Q,q){let G=J;while(Q-- >q0)G*=G,G%=q;return G}function CJ(J,Q){if(J===q0)throw new Error("invert: expected non-zero number");if(Q<=q0)throw new Error("invert: expected positive modulus, got "+Q);let q=J0(J,Q),G=Q,X=q0,Y=r,V=r,K=q0;while(q!==q0){const W=G/q,$=G%q,B=X-V*W,z=Y-K*W;G=q,q=$,X=V,Y=K,V=B,K=z}if(G!==r)throw new Error("invert: does not exist");return J0(X,Q)}function lV(J){const Q=(J-r)/C8;let q,G,X;for(q=J-r,G=0;q%C8===q0;q/=C8,G++);for(X=C8;X<J&&fV(X,Q,J)!==J-r;X++)if(X>1000)throw new Error("Cannot find square root: likely non-prime P");if(G===1){const V=(J+r)/c9;return function K(Z,W){const $=Z.pow(W,V);if(!Z.eql(Z.sqr($),W))throw new Error("Cannot find square root");return $}}const Y=(q+r)/C8;return function V(K,Z){if(K.pow(Z,Q)===K.neg(K.ONE))throw new Error("Cannot find square root");let W=G,$=K.pow(K.mul(K.ONE,X),q),B=K.pow(Z,Y),z=K.pow(Z,q);while(!K.eql(z,K.ONE)){if(K.eql(z,K.ZERO))return K.ZERO;let U=1;for(let H=K.sqr(z);U<W;U++){if(K.eql(H,K.ONE))break;H=K.sqr(H)}const M=K.pow($,r<<BigInt(W-U-1));$=K.sqr(M),B=K.mul(B,M),z=K.mul(z,$),W=U}return B}}function dV(J){if(J%c9===uV){const Q=(J+r)/c9;return function q(G,X){const Y=G.pow(X,Q);if(!G.eql(G.sqr(Y),X))throw new Error("Cannot find square root");return Y}}if(J%FQ===OQ){const Q=(J-OQ)/FQ;return function q(G,X){const Y=G.mul(X,C8),V=G.pow(Y,Q),K=G.mul(X,V),Z=G.mul(G.mul(K,C8),V),W=G.mul(K,G.sub(Z,G.ONE));if(!G.eql(G.sqr(W),X))throw new Error("Cannot find square root");return W}}if(J%pV===cV);return lV(J)}function p9(J){const Q={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},q=iV.reduce((G,X)=>{return G[X]="function",G},Q);return e0(J,q)}function oV(J,Q,q){if(q<q0)throw new Error("invalid exponent, negatives unsupported");if(q===q0)return J.ONE;if(q===r)return Q;let G=J.ONE,X=Q;while(q>q0){if(q&r)G=J.mul(G,X);X=J.sqr(X),q>>=r}return G}function nV(J,Q){const q=new Array(Q.length),G=Q.reduce((Y,V,K)=>{if(J.is0(V))return Y;return q[K]=Y,J.mul(Y,V)},J.ONE),X=J.inv(G);return Q.reduceRight((Y,V,K)=>{if(J.is0(V))return Y;return q[K]=J.mul(Y,q[K]),J.mul(Y,V)},X),q}function f9(J,Q){const q=Q!==void 0?Q:J.toString(2).length,G=Math.ceil(q/8);return{nBitLength:q,nByteLength:G}}function wJ(J,Q,q=!1,G={}){if(J<=q0)throw new Error("invalid field: expected ORDER > 0, got "+J);const{nBitLength:X,nByteLength:Y}=f9(J,Q);if(Y>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let V;const K=Object.freeze({ORDER:J,isLE:q,BITS:X,BYTES:Y,MASK:S1(X),ZERO:q0,ONE:r,create:(Z)=>J0(Z,J),isValid:(Z)=>{if(typeof Z!=="bigint")throw new Error("invalid field element: expected bigint, got "+typeof Z);return q0<=Z&&Z<J},is0:(Z)=>Z===q0,isOdd:(Z)=>(Z&r)===r,neg:(Z)=>J0(-Z,J),eql:(Z,W)=>Z===W,sqr:(Z)=>J0(Z*Z,J),add:(Z,W)=>J0(Z+W,J),sub:(Z,W)=>J0(Z-W,J),mul:(Z,W)=>J0(Z*W,J),pow:(Z,W)=>oV(K,Z,W),div:(Z,W)=>J0(Z*CJ(W,J),J),sqrN:(Z)=>Z*Z,addN:(Z,W)=>Z+W,subN:(Z,W)=>Z-W,mulN:(Z,W)=>Z*W,inv:(Z)=>CJ(Z,J),sqrt:G.sqrt||((Z)=>{if(!V)V=dV(J);return V(K,Z)}),invertBatch:(Z)=>nV(K,Z),cmov:(Z,W,$)=>$?W:Z,toBytes:(Z)=>q?PJ(Z,Y):x0(Z,Y),fromBytes:(Z)=>{if(Z.length!==Y)throw new Error("Field.fromBytes: expected "+Y+" bytes, got "+Z.length);return q?LJ(Z):C0(Z)}});return Object.freeze(K)}function SQ(J){if(typeof J!=="bigint")throw new Error("field order must be bigint");const Q=J.toString(2).length;return Math.ceil(Q/8)}function l9(J){const Q=SQ(J);return Q+Math.ceil(Q/2)}function DQ(J,Q,q=!1){const G=J.length,X=SQ(Q),Y=l9(Q);if(G<16||G<Y||G>1024)throw new Error("expected "+Y+"-1024 bytes of input, got "+G);const V=q?LJ(J):C0(J),K=J0(V,Q-r)+r;return q?PJ(K,X):x0(K,X)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */var q0=BigInt(0),r=BigInt(1),C8=BigInt(2),uV=BigInt(3),c9=BigInt(4),OQ=BigInt(5),FQ=BigInt(8),cV=BigInt(9),pV=BigInt(16);var iV=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];var d9=function(J,Q){const q=Q.negate();return J?q:Q},AQ=function(J,Q){if(!Number.isSafeInteger(J)||J<=0||J>Q)throw new Error("invalid window size, expected [1.."+Q+"], got W="+J)},i9=function(J,Q){AQ(J,Q);const q=Math.ceil(Q/J)+1,G=2**(J-1);return{windows:q,windowSize:G}},rV=function(J,Q){if(!Array.isArray(J))throw new Error("array expected");J.forEach((q,G)=>{if(!(q instanceof Q))throw new Error("invalid point at index "+G)})},aV=function(J,Q){if(!Array.isArray(J))throw new Error("array of scalars expected");J.forEach((q,G)=>{if(!Q.isValid(q))throw new Error("invalid scalar at index "+G)})},n9=function(J){return RQ.get(J)||1};function TQ(J,Q){return{constTimeNegate:d9,hasPrecomputes(q){return n9(q)!==1},unsafeLadder(q,G,X=J.ZERO){let Y=q;while(G>IQ){if(G&NJ)X=X.add(Y);Y=Y.double(),G>>=NJ}return X},precomputeWindow(q,G){const{windows:X,windowSize:Y}=i9(G,Q),V=[];let K=q,Z=K;for(let W=0;W<X;W++){Z=K,V.push(Z);for(let $=1;$<Y;$++)Z=Z.add(K),V.push(Z);K=Z.double()}return V},wNAF(q,G,X){const{windows:Y,windowSize:V}=i9(q,Q);let{ZERO:K,BASE:Z}=J;const W=BigInt(2**q-1),$=2**q,B=BigInt(q);for(let z=0;z<Y;z++){const U=z*V;let M=Number(X&W);if(X>>=B,M>V)M-=$,X+=NJ;const H=U,j=U+Math.abs(M)-1,P=z%2!==0,x=M<0;if(M===0)Z=Z.add(d9(P,G[H]));else K=K.add(d9(x,G[j]))}return{p:K,f:Z}},wNAFUnsafe(q,G,X,Y=J.ZERO){const{windows:V,windowSize:K}=i9(q,Q),Z=BigInt(2**q-1),W=2**q,$=BigInt(q);for(let B=0;B<V;B++){const z=B*K;if(X===IQ)break;let U=Number(X&Z);if(X>>=$,U>K)U-=W,X+=NJ;if(U===0)continue;let M=G[z+Math.abs(U)-1];if(U<0)M=M.negate();Y=Y.add(M)}return Y},getPrecomputes(q,G,X){let Y=o9.get(G);if(!Y){if(Y=this.precomputeWindow(G,q),q!==1)o9.set(G,X(Y))}return Y},wNAFCached(q,G,X){const Y=n9(q);return this.wNAF(Y,this.getPrecomputes(Y,q,X),G)},wNAFCachedUnsafe(q,G,X,Y){const V=n9(q);if(V===1)return this.unsafeLadder(q,G,Y);return this.wNAFUnsafe(V,this.getPrecomputes(V,q,X),G,Y)},setWindowSize(q,G){AQ(G,Q),RQ.set(q,G),o9.delete(q)}}}function gQ(J,Q,q,G){if(rV(q,J),aV(G,Q),q.length!==G.length)throw new Error("arrays of points and scalars must have equal length");const X=J.ZERO,Y=_9(BigInt(q.length)),V=Y>12?Y-3:Y>4?Y-2:Y?2:1,K=(1<<V)-1,Z=new Array(K+1).fill(X),W=Math.floor((Q.BITS-1)/V)*V;let $=X;for(let B=W;B>=0;B-=V){Z.fill(X);for(let U=0;U<G.length;U++){const M=G[U],H=Number(M>>BigInt(B)&BigInt(K));Z[H]=Z[H].add(q[U])}let z=X;for(let U=Z.length-1,M=X;U>0;U--)M=M.add(Z[U]),z=z.add(M);if($=$.add(z),B!==0)for(let U=0;U<V;U++)$=$.double()}return $}function r9(J){return p9(J.Fp),e0(J,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...f9(J.n,J.nBitLength),...J,...{p:J.Fp.ORDER}})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */var IQ=BigInt(0),NJ=BigInt(1),o9=new WeakMap,RQ=new WeakMap;var vQ=function(J){if(J.lowS!==void 0)B8("lowS",J.lowS);if(J.prehash!==void 0)B8("prehash",J.prehash)},sV=function(J){const Q=r9(J);e0(Q,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});const{endo:q,Fp:G,a:X}=Q;if(q){if(!G.eql(X,G.ZERO))throw new Error("invalid endomorphism, can only be defined for Koblitz curves that have a=0");if(typeof q!=="object"||typeof q.beta!=="bigint"||typeof q.splitScalar!=="function")throw new Error("invalid endomorphism, expected beta: bigint and splitScalar: function")}return Object.freeze({...Q})};function JK(J){const Q=sV(J),{Fp:q}=Q,G=wJ(Q.n,Q.nBitLength),X=Q.toBytes||((H,j,P)=>{const x=j.toAffine();return b0(Uint8Array.from([4]),q.toBytes(x.x),q.toBytes(x.y))}),Y=Q.fromBytes||((H)=>{const j=H.subarray(1),P=q.fromBytes(j.subarray(0,q.BYTES)),x=q.fromBytes(j.subarray(q.BYTES,2*q.BYTES));return{x:P,y:x}});function V(H){const{a:j,b:P}=Q,x=q.sqr(H),F=q.mul(x,H);return q.add(q.add(F,q.mul(H,j)),P)}if(!q.eql(q.sqr(Q.Gy),V(Q.Gx)))throw new Error("bad generator point: equation left != right");function K(H){return t0(H,G0,Q.n)}function Z(H){const{allowedPrivateKeyLengths:j,nByteLength:P,wrapPrivateKey:x,n:F}=Q;if(j&&typeof H!=="bigint"){if(s0(H))H=L8(H);if(typeof H!=="string"||!j.includes(H.length))throw new Error("invalid private key");H=H.padStart(P*2,"0")}let L;try{L=typeof H==="bigint"?H:C0(e("private key",H,P))}catch(I){throw new Error("invalid private key, expected hex or "+P+" bytes, got "+typeof H)}if(x)L=J0(L,F);return R0("private key",L,G0,F),L}function W(H){if(!(H instanceof z))throw new Error("ProjectivePoint expected")}const $=kJ((H,j)=>{const{px:P,py:x,pz:F}=H;if(q.eql(F,q.ONE))return{x:P,y:x};const L=H.is0();if(j==null)j=L?q.ONE:q.inv(F);const I=q.mul(P,j),D=q.mul(x,j),O=q.mul(F,j);if(L)return{x:q.ZERO,y:q.ZERO};if(!q.eql(O,q.ONE))throw new Error("invZ was invalid");return{x:I,y:D}}),B=kJ((H)=>{if(H.is0()){if(Q.allowInfinityPoint&&!q.is0(H.py))return;throw new Error("bad point: ZERO")}const{x:j,y:P}=H.toAffine();if(!q.isValid(j)||!q.isValid(P))throw new Error("bad point: x or y not FE");const x=q.sqr(P),F=V(j);if(!q.eql(x,F))throw new Error("bad point: equation left != right");if(!H.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});class z{constructor(H,j,P){if(this.px=H,this.py=j,this.pz=P,H==null||!q.isValid(H))throw new Error("x required");if(j==null||!q.isValid(j))throw new Error("y required");if(P==null||!q.isValid(P))throw new Error("z required");Object.freeze(this)}static fromAffine(H){const{x:j,y:P}=H||{};if(!H||!q.isValid(j)||!q.isValid(P))throw new Error("invalid affine point");if(H instanceof z)throw new Error("projective point not allowed");const x=(F)=>q.eql(F,q.ZERO);if(x(j)&&x(P))return z.ZERO;return new z(j,P,q.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(H){const j=q.invertBatch(H.map((P)=>P.pz));return H.map((P,x)=>P.toAffine(j[x])).map(z.fromAffine)}static fromHex(H){const j=z.fromAffine(Y(e("pointHex",H)));return j.assertValidity(),j}static fromPrivateKey(H){return z.BASE.multiply(Z(H))}static msm(H,j){return gQ(z,G,H,j)}_setWindowSize(H){M.setWindowSize(this,H)}assertValidity(){B(this)}hasEvenY(){const{y:H}=this.toAffine();if(q.isOdd)return!q.isOdd(H);throw new Error("Field doesn't support isOdd")}equals(H){W(H);const{px:j,py:P,pz:x}=this,{px:F,py:L,pz:I}=H,D=q.eql(q.mul(j,I),q.mul(F,x)),O=q.eql(q.mul(P,I),q.mul(L,x));return D&&O}negate(){return new z(this.px,q.neg(this.py),this.pz)}double(){const{a:H,b:j}=Q,P=q.mul(j,yQ),{px:x,py:F,pz:L}=this;let{ZERO:I,ZERO:D,ZERO:O}=q,S=q.mul(x,x),y=q.mul(F,F),A=q.mul(L,L),T=q.mul(x,F);return T=q.add(T,T),O=q.mul(x,L),O=q.add(O,O),I=q.mul(H,O),D=q.mul(P,A),D=q.add(I,D),I=q.sub(y,D),D=q.add(y,D),D=q.mul(I,D),I=q.mul(T,I),O=q.mul(P,O),A=q.mul(H,A),T=q.sub(S,A),T=q.mul(H,T),T=q.add(T,O),O=q.add(S,S),S=q.add(O,S),S=q.add(S,A),S=q.mul(S,T),D=q.add(D,S),A=q.mul(F,L),A=q.add(A,A),S=q.mul(A,T),I=q.sub(I,S),O=q.mul(A,y),O=q.add(O,O),O=q.add(O,O),new z(I,D,O)}add(H){W(H);const{px:j,py:P,pz:x}=this,{px:F,py:L,pz:I}=H;let{ZERO:D,ZERO:O,ZERO:S}=q;const y=Q.a,A=q.mul(Q.b,yQ);let T=q.mul(j,F),w=q.mul(P,L),R=q.mul(x,I),k=q.add(j,P),N=q.add(F,L);k=q.mul(k,N),N=q.add(T,w),k=q.sub(k,N),N=q.add(j,x);let C=q.add(F,I);return N=q.mul(N,C),C=q.add(T,R),N=q.sub(N,C),C=q.add(P,x),D=q.add(L,I),C=q.mul(C,D),D=q.add(w,R),C=q.sub(C,D),S=q.mul(y,N),D=q.mul(A,R),S=q.add(D,S),D=q.sub(w,S),S=q.add(w,S),O=q.mul(D,S),w=q.add(T,T),w=q.add(w,T),R=q.mul(y,R),N=q.mul(A,N),w=q.add(w,R),R=q.sub(T,R),R=q.mul(y,R),N=q.add(N,R),T=q.mul(w,N),O=q.add(O,T),T=q.mul(C,N),D=q.mul(k,D),D=q.sub(D,T),T=q.mul(k,w),S=q.mul(C,S),S=q.add(S,T),new z(D,O,S)}subtract(H){return this.add(H.negate())}is0(){return this.equals(z.ZERO)}wNAF(H){return M.wNAFCached(this,H,z.normalizeZ)}multiplyUnsafe(H){const{endo:j,n:P}=Q;R0("scalar",H,c0,P);const x=z.ZERO;if(H===c0)return x;if(this.is0()||H===G0)return this;if(!j||M.hasPrecomputes(this))return M.wNAFCachedUnsafe(this,H,z.normalizeZ);let{k1neg:F,k1:L,k2neg:I,k2:D}=j.splitScalar(H),O=x,S=x,y=this;while(L>c0||D>c0){if(L&G0)O=O.add(y);if(D&G0)S=S.add(y);y=y.double(),L>>=G0,D>>=G0}if(F)O=O.negate();if(I)S=S.negate();return S=new z(q.mul(S.px,j.beta),S.py,S.pz),O.add(S)}multiply(H){const{endo:j,n:P}=Q;R0("scalar",H,G0,P);let x,F;if(j){const{k1neg:L,k1:I,k2neg:D,k2:O}=j.splitScalar(H);let{p:S,f:y}=this.wNAF(I),{p:A,f:T}=this.wNAF(O);S=M.constTimeNegate(L,S),A=M.constTimeNegate(D,A),A=new z(q.mul(A.px,j.beta),A.py,A.pz),x=S.add(A),F=y.add(T)}else{const{p:L,f:I}=this.wNAF(H);x=L,F=I}return z.normalizeZ([x,F])[0]}multiplyAndAddUnsafe(H,j,P){const x=z.BASE,F=(I,D)=>D===c0||D===G0||!I.equals(x)?I.multiplyUnsafe(D):I.multiply(D),L=F(this,j).add(F(H,P));return L.is0()?void 0:L}toAffine(H){return $(this,H)}isTorsionFree(){const{h:H,isTorsionFree:j}=Q;if(H===G0)return!0;if(j)return j(z,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:H,clearCofactor:j}=Q;if(H===G0)return this;if(j)return j(z,this);return this.multiplyUnsafe(Q.h)}toRawBytes(H=!0){return B8("isCompressed",H),this.assertValidity(),X(z,this,H)}toHex(H=!0){return B8("isCompressed",H),L8(this.toRawBytes(H))}}z.BASE=new z(Q.Gx,Q.Gy,q.ONE),z.ZERO=new z(q.ZERO,q.ONE,q.ZERO);const U=Q.nBitLength,M=TQ(z,Q.endo?Math.ceil(U/2):U);return{CURVE:Q,ProjectivePoint:z,normPrivateKeyToScalar:Z,weierstrassEquation:V,isWithinCurveOrder:K}}var qK=function(J){const Q=r9(J);return e0(Q,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...Q})};function hQ(J){const Q=qK(J),{Fp:q,n:G}=Q,X=q.BYTES+1,Y=2*q.BYTES+1;function V(k){return J0(k,G)}function K(k){return CJ(k,G)}const{ProjectivePoint:Z,normPrivateKeyToScalar:W,weierstrassEquation:$,isWithinCurveOrder:B}=JK({...Q,toBytes(k,N,C){const g=N.toAffine(),v=q.toBytes(g.x),E=b0;if(B8("isCompressed",C),C)return E(Uint8Array.from([N.hasEvenY()?2:3]),v);else return E(Uint8Array.from([4]),v,q.toBytes(g.y))},fromBytes(k){const N=k.length,C=k[0],g=k.subarray(1);if(N===X&&(C===2||C===3)){const v=C0(g);if(!t0(v,G0,q.ORDER))throw new Error("Point is not on curve");const E=$(v);let c;try{c=q.sqrt(E)}catch(s){const b=s instanceof Error?": "+s.message:"";throw new Error("Point is not on curve"+b)}const f=(c&G0)===G0;if((C&1)===1!==f)c=q.neg(c);return{x:v,y:c}}else if(N===Y&&C===4){const v=q.fromBytes(g.subarray(0,q.BYTES)),E=q.fromBytes(g.subarray(q.BYTES,2*q.BYTES));return{x:v,y:E}}else{const v=X,E=Y;throw new Error("invalid Point, expected length of "+v+", or uncompressed "+E+", got "+N)}}}),z=(k)=>L8(x0(k,Q.nByteLength));function U(k){const N=G>>G0;return k>N}function M(k){return U(k)?V(-k):k}const H=(k,N,C)=>C0(k.slice(N,C));class j{constructor(k,N,C){this.r=k,this.s=N,this.recovery=C,this.assertValidity()}static fromCompact(k){const N=Q.nByteLength;return k=e("compactSignature",k,N*2),new j(H(k,0,N),H(k,N,2*N))}static fromDER(k){const{r:N,s:C}=u0.toSig(e("DER",k));return new j(N,C)}assertValidity(){R0("r",this.r,G0,G),R0("s",this.s,G0,G)}addRecoveryBit(k){return new j(this.r,this.s,k)}recoverPublicKey(k){const{r:N,s:C,recovery:g}=this,v=D(e("msgHash",k));if(g==null||![0,1,2,3].includes(g))throw new Error("recovery id invalid");const E=g===2||g===3?N+Q.n:N;if(E>=q.ORDER)throw new Error("recovery id 2 or 3 invalid");const c=(g&1)===0?"02":"03",f=Z.fromHex(c+z(E)),h=K(E),s=V(-v*h),b=V(C*h),a=Z.BASE.multiplyAndAddUnsafe(f,s,b);if(!a)throw new Error("point at infinify");return a.assertValidity(),a}hasHighS(){return U(this.s)}normalizeS(){return this.hasHighS()?new j(this.r,V(-this.s),this.recovery):this}toDERRawBytes(){return k8(this.toDERHex())}toDERHex(){return u0.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return k8(this.toCompactHex())}toCompactHex(){return z(this.r)+z(this.s)}}const P={isValidPrivateKey(k){try{return W(k),!0}catch(N){return!1}},normPrivateKeyToScalar:W,randomPrivateKey:()=>{const k=l9(Q.n);return DQ(Q.randomBytes(k),Q.n)},precompute(k=8,N=Z.BASE){return N._setWindowSize(k),N.multiply(BigInt(3)),N}};function x(k,N=!0){return Z.fromPrivateKey(k).toRawBytes(N)}function F(k){const N=s0(k),C=typeof k==="string",g=(N||C)&&k.length;if(N)return g===X||g===Y;if(C)return g===2*X||g===2*Y;if(k instanceof Z)return!0;return!1}function L(k,N,C=!0){if(F(k))throw new Error("first arg must be private key");if(!F(N))throw new Error("second arg must be public key");return Z.fromHex(N).multiply(W(k)).toRawBytes(C)}const I=Q.bits2int||function(k){if(k.length>8192)throw new Error("input is too large");const N=C0(k),C=k.length*8-Q.nBitLength;return C>0?N>>BigInt(C):N},D=Q.bits2int_modN||function(k){return V(I(k))},O=S1(Q.nBitLength);function S(k){return R0("num < 2^"+Q.nBitLength,k,c0,O),x0(k,Q.nByteLength)}function y(k,N,C=A){if(["recovered","canonical"].some((V0)=>(V0 in C)))throw new Error("sign() legacy options not supported");const{hash:g,randomBytes:v}=Q;let{lowS:E,prehash:c,extraEntropy:f}=C;if(E==null)E=!0;if(k=e("msgHash",k),vQ(C),c)k=e("prehashed msgHash",g(k));const h=D(k),s=W(N),b=[S(s),S(h)];if(f!=null&&f!==!1){const V0=f===!0?v(q.BYTES):f;b.push(e("extraEntropy",V0))}const a=b0(...b),p=h;function i(V0){const t=I(V0);if(!B(t))return;const U0=K(t),H0=Z.BASE.multiply(t).toAffine(),X0=V(H0.x);if(X0===c0)return;const Y8=V(U0*V(p+X0*s));if(Y8===c0)return;let y0=(H0.x===X0?0:2)|Number(H0.y&G0),vq=Y8;if(E&&U(Y8))vq=M(Y8),y0^=1;return new j(X0,vq,y0)}return{seed:a,k2sig:i}}const A={lowS:Q.lowS,prehash:!1},T={lowS:Q.lowS,prehash:!1};function w(k,N,C=A){const{seed:g,k2sig:v}=y(k,N,C),E=Q;return b9(E.hash.outputLen,E.nByteLength,E.hmac)(g,v)}Z.BASE._setWindowSize(8);function R(k,N,C,g=T){const v=k;N=e("msgHash",N),C=e("publicKey",C);const{lowS:E,prehash:c,format:f}=g;if(vQ(g),("strict"in g))throw new Error("options.strict was renamed to lowS");if(f!==void 0&&f!=="compact"&&f!=="der")throw new Error("format must be compact or der");const h=typeof v==="string"||s0(v),s=!h&&!f&&typeof v==="object"&&v!==null&&typeof v.r==="bigint"&&typeof v.s==="bigint";if(!h&&!s)throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");let b=void 0,a;try{if(s)b=new j(v.r,v.s);if(h){try{if(f!=="compact")b=j.fromDER(v)}catch(y0){if(!(y0 instanceof u0.Err))throw y0}if(!b&&f!=="der")b=j.fromCompact(v)}a=Z.fromHex(C)}catch(y0){return!1}if(!b)return!1;if(E&&b.hasHighS())return!1;if(c)N=Q.hash(N);const{r:p,s:i}=b,V0=D(N),t=K(i),U0=V(V0*t),H0=V(p*t),X0=Z.BASE.multiplyAndAddUnsafe(a,U0,H0)?.toAffine();if(!X0)return!1;return V(X0.x)===p}return{CURVE:Q,getPublicKey:x,getSharedSecret:L,sign:w,verify:R,ProjectivePoint:Z,Signature:j,utils:P}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */var{bytesToNumberBE:tV,hexToBytes:eV}=u9;class EQ extends Error{constructor(J=""){super(J)}}var u0={Err:EQ,_tlv:{encode:(J,Q)=>{const{Err:q}=u0;if(J<0||J>256)throw new q("tlv.encode: wrong tag");if(Q.length&1)throw new q("tlv.encode: unpadded data");const G=Q.length/2,X=P8(G);if(X.length/2&128)throw new q("tlv.encode: long form length too big");const Y=G>127?P8(X.length/2|128):"";return P8(J)+Y+X+Q},decode(J,Q){const{Err:q}=u0;let G=0;if(J<0||J>256)throw new q("tlv.encode: wrong tag");if(Q.length<2||Q[G++]!==J)throw new q("tlv.decode: wrong tlv");const X=Q[G++],Y=!!(X&128);let V=0;if(!Y)V=X;else{const Z=X&127;if(!Z)throw new q("tlv.decode(long): indefinite length not supported");if(Z>4)throw new q("tlv.decode(long): byte length is too big");const W=Q.subarray(G,G+Z);if(W.length!==Z)throw new q("tlv.decode: length bytes not complete");if(W[0]===0)throw new q("tlv.decode(long): zero leftmost byte");for(let $ of W)V=V<<8|$;if(G+=Z,V<128)throw new q("tlv.decode(long): not minimal encoding")}const K=Q.subarray(G,G+V);if(K.length!==V)throw new q("tlv.decode: wrong value length");return{v:K,l:Q.subarray(G+V)}}},_int:{encode(J){const{Err:Q}=u0;if(J<c0)throw new Q("integer: negative integers are not allowed");let q=P8(J);if(Number.parseInt(q[0],16)&8)q="00"+q;if(q.length&1)throw new Q("unexpected DER parsing assertion: unpadded hex");return q},decode(J){const{Err:Q}=u0;if(J[0]&128)throw new Q("invalid signature integer: negative");if(J[0]===0&&!(J[1]&128))throw new Q("invalid signature integer: unnecessary leading zero");return tV(J)}},toSig(J){const{Err:Q,_int:q,_tlv:G}=u0,X=typeof J==="string"?eV(J):J;l8(X);const{v:Y,l:V}=G.decode(48,X);if(V.length)throw new Q("invalid signature: left bytes after parsing");const{v:K,l:Z}=G.decode(2,Y),{v:W,l:$}=G.decode(2,Z);if($.length)throw new Q("invalid signature: left bytes after parsing");return{r:q.decode(K),s:q.decode(W)}},hexFromSig(J){const{_tlv:Q,_int:q}=u0,G=Q.encode(2,q.encode(J.r)),X=Q.encode(2,q.encode(J.s)),Y=G+X;return Q.encode(48,Y)}},c0=BigInt(0),G0=BigInt(1),j$=BigInt(2),yQ=BigInt(3),M$=BigInt(4);function QK(J){return{hash:J,hmac:(Q,...q)=>y9(J,Q,LQ(...q)),randomBytes:HJ}}function mQ(J,Q){const q=(G)=>hQ({...J,...QK(G)});return{...q(Q),create:q}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */var uQ=function(J){const Q=A1,q=BigInt(3),G=BigInt(6),X=BigInt(11),Y=BigInt(22),V=BigInt(23),K=BigInt(44),Z=BigInt(88),W=J*J*J%Q,$=W*W*J%Q,B=B0($,q,Q)*$%Q,z=B0(B,q,Q)*$%Q,U=B0(z,OJ,Q)*W%Q,M=B0(U,X,Q)*U%Q,H=B0(M,Y,Q)*M%Q,j=B0(H,K,Q)*H%Q,P=B0(j,Z,Q)*j%Q,x=B0(P,K,Q)*H%Q,F=B0(x,q,Q)*$%Q,L=B0(F,V,Q)*M%Q,I=B0(L,G,Q)*W%Q,D=B0(I,OJ,Q);if(!s9.eql(s9.sqr(D),J))throw new Error("Cannot find square root");return D},FJ=function(J,...Q){let q=bQ[J];if(q===void 0){const G=jJ(Uint8Array.from(J,(X)=>X.charCodeAt(0)));q=b0(G,G),bQ[J]=q}return jJ(b0(q,...Q))},e9=function(J){let Q=Jq.utils.normPrivateKeyToScalar(J),q=Qq.fromPrivateKey(Q);return{scalar:q.hasEvenY()?Q:I1(-Q),bytes:qq(q)}},pQ=function(J){R0("x",J,D1,A1);const Q=a9(J*J),q=a9(Q*J+BigInt(7));let G=uQ(q);if(G%OJ!==cQ)G=a9(-G);const X=new Qq(J,G,D1);return X.assertValidity(),X},fQ=function(...J){return I1(d8(FJ("BIP0340/challenge",...J)))},XK=function(J){return e9(J).bytes},YK=function(J,Q,q=HJ(32)){const G=e("message",J),{bytes:X,scalar:Y}=e9(Q),V=e("auxRand",q,32),K=t9(Y^d8(FJ("BIP0340/aux",V))),Z=FJ("BIP0340/nonce",K,X,G),W=I1(d8(Z));if(W===cQ)throw new Error("sign failed: k is zero");const{bytes:$,scalar:B}=e9(W),z=fQ($,X,G),U=new Uint8Array(64);if(U.set($,0),U.set(t9(I1(B+z*Y)),32),!lQ(U,G,X))throw new Error("sign: Invalid signature produced");return U},lQ=function(J,Q,q){const G=e("signature",J,64),X=e("message",Q),Y=e("publicKey",q,32);try{const V=pQ(d8(Y)),K=d8(G.subarray(0,32));if(!t0(K,D1,A1))return!1;const Z=d8(G.subarray(32,64));if(!t0(Z,D1,xJ))return!1;const W=fQ(t9(K),qq(V),X),$=GK(V,Z,I1(-W));if(!$||!$.hasEvenY()||$.toAffine().x!==K)return!1;return!0}catch(V){return!1}};/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */var A1=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),xJ=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),D1=BigInt(1),OJ=BigInt(2),_Q=(J,Q)=>(J+Q/OJ)/Q,s9=wJ(A1,void 0,void 0,{sqrt:uQ}),Jq=mQ({a:BigInt(0),b:BigInt(7),Fp:s9,n:xJ,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:(J)=>{const Q=xJ,q=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),G=-D1*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),X=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),Y=q,V=BigInt("0x100000000000000000000000000000000"),K=_Q(Y*J,Q),Z=_Q(-G*J,Q);let W=J0(J-K*q-Z*X,Q),$=J0(-K*G-Z*Y,Q);const B=W>V,z=$>V;if(B)W=Q-W;if(z)$=Q-$;if(W>V||$>V)throw new Error("splitScalar: Endomorphism failed, k="+J);return{k1neg:B,k1:W,k2neg:z,k2:$}}}},jJ),cQ=BigInt(0),bQ={},qq=(J)=>J.toRawBytes(!0).slice(1),t9=(J)=>x0(J,32),a9=(J)=>J0(J,A1),I1=(J)=>J0(J,xJ),Qq=Jq.ProjectivePoint,GK=(J,Q,q)=>Qq.BASE.multiplyAndAddUnsafe(J,Q,q),d8=C0,SJ=(()=>({getPublicKey:XK,sign:YK,verify:lQ,utils:{randomPrivateKey:Jq.utils.randomPrivateKey,lift_x:pQ,pointToBytes:qq,numberToBytesBE:x0,bytesToNumberBE:C0,taggedHash:FJ,mod:J0}}))();var{floor:Gq,random:VK,sin:KK}=Math,w8="Trystero",J8=(J,Q)=>Array(J).fill().map(Q);var IJ=(J)=>J8(J,()=>"0123456789AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz"[Gq(VK()*"0123456789AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz".length)]).join(""),T0=IJ(20),q8=Promise.all.bind(Promise),R1=typeof window!=="undefined",{entries:AJ,fromEntries:Xq,keys:dQ}=Object,p0=()=>{},O0=(J)=>new Error(`Trystero: ${J}`),WK=new TextEncoder,ZK=new TextDecoder,g0=(J)=>WK.encode(J),i8=(J)=>ZK.decode(J),RJ=(J)=>J.reduce((Q,q)=>Q+q.toString(16).padStart(2,"0"),""),T1=(...J)=>J.join("@"),$K=(J,Q)=>{const q=[...J],G=()=>{const Y=KK(Q++)*1e4;return Y-Gq(Y)};let X=q.length;while(X){const Y=Gq(G()*X--);[q[X],q[Y]]=[q[Y],q[X]]}return q},iQ=(J,Q,q,G)=>{return(J.relayUrls||(G?$K(Q,Yq(J.appId)):Q)).slice(0,J.relayUrls?J.relayUrls.length:J.relayRedundancy||q)},w0=JSON.stringify,N8=JSON.parse,Yq=(J,Q=Number.MAX_SAFE_INTEGER)=>J.split("").reduce((q,G)=>q+G.charCodeAt(0),0)%Q;var DJ={},oQ=(J,Q)=>{const q={},G=()=>{const X=new WebSocket(J);X.onclose=()=>{DJ[J]??=3333,setTimeout(G,DJ[J]),DJ[J]*=2},X.onmessage=(Y)=>Q(Y.data),q.socket=X,q.url=X.url,q.ready=new Promise((Y)=>X.onopen=()=>{Y(q),DJ[J]=3333}),q.send=(Y)=>{if(X.readyState===1)X.send(Y)}};return G(),q},nQ=(J)=>()=>Xq(AJ(J).map(([Q,q])=>[Q,q.socket]));var Kq="AES-GCM",Vq={},zK=(J)=>btoa(String.fromCharCode.apply(null,new Uint8Array(J))),UK=(J)=>{const Q=atob(J);return new Uint8Array(Q.length).map((q,G)=>Q.charCodeAt(G)).buffer},g1=async(J)=>{if(Vq[J])return Vq[J];const Q=Array.from(new Uint8Array(await crypto.subtle.digest("SHA-1",g0(J)))).map((q)=>q.toString(36)).join("");return Vq[J]=Q,Q},rQ=async(J,Q,q)=>crypto.subtle.importKey("raw",await crypto.subtle.digest({name:"SHA-256"},g0(`${J}:${Q}:${q}`)),{name:Kq},!1,["encrypt","decrypt"]),aQ="$",sQ=",",tQ=async(J,Q)=>{const q=crypto.getRandomValues(new Uint8Array(16));return q.join(sQ)+aQ+zK(await crypto.subtle.encrypt({name:Kq,iv:q},await J,g0(Q)))},eQ=async(J,Q)=>{const[q,G]=Q.split(aQ);return i8(await crypto.subtle.decrypt({name:Kq,iv:new Uint8Array(q.split(sQ))},await J,UK(G)))};var vG=d1(Y5(),1);var l=typeof window!=="undefined"?window:self,yJ=l.RTCPeerConnection||l.mozRTCPeerConnection||l.webkitRTCPeerConnection,V5=l.RTCSessionDescription||l.mozRTCSessionDescription||l.webkitRTCSessionDescription,K5=l.RTCIceCandidate||l.mozRTCIceCandidate||l.webkitRTCIceCandidate,v$=l.RTCIceTransport,y$=l.RTCDataChannel,E$=l.RTCSctpTransport,h$=l.RTCDtlsTransport,m$=l.RTCCertificate,_$=l.MediaStream,b$=l.MediaStreamTrack,u$=l.MediaStreamTrackEvent,c$=l.RTCPeerConnectionIceEvent,p$=l.RTCDataChannelEvent,f$=l.RTCTrackEvent,l$=l.RTCError,d$=l.RTCErrorEvent,i$=l.RTCRtpTransceiver,o$=l.RTCRtpReceiver,n$=l.RTCRtpSender;var yG=d1(OG(),1),n=d1(Fq(),1);var IG=[],DG=[];for(let J=0;J<256;J++)if(IG[J]="0123456789abcdef"[J>>4&15]+"0123456789abcdef"[J&15],J<16)if(J<10)DG[48+J]=J;else DG[87+J]=J;var dJ=(J)=>{const Q=J.length;let q="",G=0;while(G<Q)q+=IG[J[G++]];return q};var AG="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",o4=typeof Uint8Array==="undefined"?[]:new Uint8Array(256);for(c1=0;c1<AG.length;c1++)o4[AG.charCodeAt(c1)]=c1;var c1;var n4=new TextEncoder,TG=(J)=>n4.encode(J);var RG=typeof window!=="undefined"?window:self,Sq=RG.crypto||RG.msCrypto||{},Bz=Sq.subtle||Sq.webkitSubtle;var Dq=(J)=>{const Q=new Uint8Array(J);return Sq.getRandomValues(Q)};var gG=function(J){return J.replace(/a=ice-options:trickle\s\n/g,"")},t4=function(J){console.warn(J)};/*! simple-peer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */var r4=vG.default("simple-peer"),Iq=65536,a4=5000,s4=5000;class R8 extends yG.Duplex{_pc;constructor(J){J=Object.assign({allowHalfOpen:!1},J);super(J);if(this.__objectMode=!!J.objectMode,this._id=dJ(Dq(4)).slice(0,7),this._debug("new peer %o",J),this.channelName=J.initiator?J.channelName||dJ(Dq(20)):null,this.initiator=J.initiator||!1,this.channelConfig=J.channelConfig||R8.channelConfig,this.channelNegotiated=this.channelConfig.negotiated,this.config=Object.assign({},R8.config,J.config),this.offerOptions=J.offerOptions||{},this.answerOptions=J.answerOptions||{},this.sdpTransform=J.sdpTransform||((Q)=>Q),this.trickle=J.trickle!==void 0?J.trickle:!0,this.allowHalfTrickle=J.allowHalfTrickle!==void 0?J.allowHalfTrickle:!1,this.iceCompleteTimeout=J.iceCompleteTimeout||a4,this._destroying=!1,this._connected=!1,this.remoteAddress=void 0,this.remoteFamily=void 0,this.remotePort=void 0,this.localAddress=void 0,this.localFamily=void 0,this.localPort=void 0,!yJ)if(typeof window==="undefined")throw n.default(new Error("No WebRTC support: Specify `opts.wrtc` option in this environment"),"ERR_WEBRTC_SUPPORT");else throw n.default(new Error("No WebRTC support: Not a supported browser"),"ERR_WEBRTC_SUPPORT");this._pcReady=!1,this._channelReady=!1,this._iceComplete=!1,this._iceCompleteTimer=null,this._channel=null,this._pendingCandidates=[],this._isNegotiating=!1,this._firstNegotiation=!0,this._batchedNegotiation=!1,this._queuedNegotiation=!1,this._sendersAwaitingStable=[],this._closingInterval=null,this._remoteTracks=[],this._remoteStreams=[],this._chunk=null,this._cb=null,this._interval=null;try{this._pc=new yJ(this.config)}catch(Q){this.__destroy(n.default(Q,"ERR_PC_CONSTRUCTOR"));return}if(this._isReactNativeWebrtc=typeof this._pc._peerConnectionId==="number",this._pc.oniceconnectionstatechange=()=>{this._onIceStateChange()},this._pc.onicegatheringstatechange=()=>{this._onIceStateChange()},this._pc.onconnectionstatechange=()=>{this._onConnectionStateChange()},this._pc.onsignalingstatechange=()=>{this._onSignalingStateChange()},this._pc.onicecandidate=(Q)=>{this._onIceCandidate(Q)},typeof this._pc.peerIdentity==="object")this._pc.peerIdentity.catch((Q)=>{this.__destroy(n.default(Q,"ERR_PC_PEER_IDENTITY"))});if(this.initiator||this.channelNegotiated)this._setupData({channel:this._pc.createDataChannel(this.channelName,this.channelConfig)});else this._pc.ondatachannel=(Q)=>{this._setupData(Q)};this._debug("initial negotiation"),this._needsNegotiation(),this._onFinishBound=()=>{this._onFinish()},this.once("finish",this._onFinishBound)}get bufferSize(){return this._channel&&this._channel.bufferedAmount||0}get connected(){return this._connected&&this._channel.readyState==="open"}address(){return{port:this.localPort,family:this.localFamily,address:this.localAddress}}signal(J){if(this._destroying)return;if(this.destroyed)throw n.default(new Error("cannot signal after peer is destroyed"),"ERR_DESTROYED");if(typeof J==="string")try{J=JSON.parse(J)}catch(Q){J={}}if(this._debug("signal()"),J.renegotiate&&this.initiator)this._debug("got request to renegotiate"),this._needsNegotiation();if(J.transceiverRequest&&this.initiator)this._debug("got request for transceiver"),this.addTransceiver(J.transceiverRequest.kind,J.transceiverRequest.init);if(J.candidate)if(this._pc.remoteDescription&&this._pc.remoteDescription.type)this._addIceCandidate(J.candidate);else this._pendingCandidates.push(J.candidate);if(J.sdp)this._pc.setRemoteDescription(new V5(J)).then(()=>{if(this.destroyed)return;if(this._pendingCandidates.forEach((Q)=>{this._addIceCandidate(Q)}),this._pendingCandidates=[],this._pc.remoteDescription.type==="offer")this._createAnswer()}).catch((Q)=>{this.__destroy(n.default(Q,"ERR_SET_REMOTE_DESCRIPTION"))});if(!J.sdp&&!J.candidate&&!J.renegotiate&&!J.transceiverRequest)this.__destroy(n.default(new Error("signal() called with invalid signal data"),"ERR_SIGNALING"))}_addIceCandidate(J){const Q=new K5(J);this._pc.addIceCandidate(Q).catch((q)=>{if(!Q.address||Q.address.endsWith(".local"))t4("Ignoring unsupported ICE candidate.");else this.__destroy(n.default(q,"ERR_ADD_ICE_CANDIDATE"))})}send(J){if(this._destroying)return;if(this.destroyed)throw n.default(new Error("cannot send after peer is destroyed"),"ERR_DESTROYED");this._channel.send(J)}_needsNegotiation(){if(this._debug("_needsNegotiation"),this._batchedNegotiation)return;this._batchedNegotiation=!0,queueMicrotask(()=>{if(this._batchedNegotiation=!1,this.initiator||!this._firstNegotiation)this._debug("starting batched negotiation"),this.negotiate();else this._debug("non-initiator initial negotiation request discarded");this._firstNegotiation=!1})}negotiate(){if(this._destroying)return;if(this.destroyed)throw n.default(new Error("cannot negotiate after peer is destroyed"),"ERR_DESTROYED");if(this.initiator)if(this._isNegotiating)this._queuedNegotiation=!0,this._debug("already negotiating, queueing");else this._debug("start negotiation"),setTimeout(()=>{this._createOffer()},0);else if(this._isNegotiating)this._queuedNegotiation=!0,this._debug("already negotiating, queueing");else this._debug("requesting negotiation from initiator"),this.emit("signal",{type:"renegotiate",renegotiate:!0});this._isNegotiating=!0}_final(J){if(!this._readableState.ended)this.push(null);J(null)}__destroy(J){this.end(),this._destroy(()=>{},J)}_destroy(J,Q){if(this.destroyed||this._destroying)return;this._destroying=!0,this._debug("destroying (error: %s)",Q&&(Q.message||Q)),setTimeout(()=>{if(this._connected=!1,this._pcReady=!1,this._channelReady=!1,this._remoteTracks=null,this._remoteStreams=null,this._senderMap=null,clearInterval(this._closingInterval),this._closingInterval=null,clearInterval(this._interval),this._interval=null,this._chunk=null,this._cb=null,this._onFinishBound)this.removeListener("finish",this._onFinishBound);if(this._onFinishBound=null,this._channel){try{this._channel.close()}catch(q){}this._channel.onmessage=null,this._channel.onopen=null,this._channel.onclose=null,this._channel.onerror=null}if(this._pc){try{this._pc.close()}catch(q){}this._pc.oniceconnectionstatechange=null,this._pc.onicegatheringstatechange=null,this._pc.onsignalingstatechange=null,this._pc.onicecandidate=null,this._pc.ontrack=null,this._pc.ondatachannel=null}if(this._pc=null,this._channel=null,Q)this.emit("error",Q);J()},0)}_setupData(J){if(!J.channel)return this.__destroy(n.default(new Error("Data channel event is missing `channel` property"),"ERR_DATA_CHANNEL"));if(this._channel=J.channel,this._channel.binaryType="arraybuffer",typeof this._channel.bufferedAmountLowThreshold==="number")this._channel.bufferedAmountLowThreshold=Iq;this.channelName=this._channel.label,this._channel.onmessage=(q)=>{this._onChannelMessage(q)},this._channel.onbufferedamountlow=()=>{this._onChannelBufferedAmountLow()},this._channel.onopen=()=>{this._onChannelOpen()},this._channel.onclose=()=>{this._onChannelClose()},this._channel.onerror=(q)=>{const G=q.error instanceof Error?q.error:new Error(`Datachannel error: ${q.message} ${q.filename}:${q.lineno}:${q.colno}`);this.__destroy(n.default(G,"ERR_DATA_CHANNEL"))};let Q=!1;this._closingInterval=setInterval(()=>{if(this._channel&&this._channel.readyState==="closing"){if(Q)this._onChannelClose();Q=!0}else Q=!1},s4)}_write(J,Q){if(this.destroyed)return Q(n.default(new Error("cannot write after peer is destroyed"),"ERR_DATA_CHANNEL"));if(this._connected){try{this.send(J)}catch(q){return this.__destroy(n.default(q,"ERR_DATA_CHANNEL"))}if(this._channel.bufferedAmount>Iq)this._debug("start backpressure: bufferedAmount %d",this._channel.bufferedAmount),this._cb=Q;else Q(null)}else this._debug("write before connect"),this._chunk=J,this._cb=Q}_onFinish(){if(this.destroyed)return;const J=()=>{setTimeout(()=>this.__destroy(),1000)};if(this._connected)J();else this.once("connect",J)}_startIceCompleteTimeout(){if(this.destroyed)return;if(this._iceCompleteTimer)return;this._debug("started iceComplete timeout"),this._iceCompleteTimer=setTimeout(()=>{if(!this._iceComplete)this._iceComplete=!0,this._debug("iceComplete timeout completed"),this.emit("iceTimeout"),this.emit("_iceComplete")},this.iceCompleteTimeout)}_createOffer(){if(this.destroyed)return;this._pc.createOffer(this.offerOptions).then((J)=>{if(this.destroyed)return;if(!this.trickle&&!this.allowHalfTrickle)J.sdp=gG(J.sdp);J.sdp=this.sdpTransform(J.sdp);const Q=()=>{if(this.destroyed)return;const X=this._pc.localDescription||J;this._debug("signal"),this.emit("signal",{type:X.type,sdp:X.sdp})},q=()=>{if(this._debug("createOffer success"),this.destroyed)return;if(this.trickle||this._iceComplete)Q();else this.once("_iceComplete",Q)},G=(X)=>{this.__destroy(n.default(X,"ERR_SET_LOCAL_DESCRIPTION"))};this._pc.setLocalDescription(J).then(q).catch(G)}).catch((J)=>{this.__destroy(n.default(J,"ERR_CREATE_OFFER"))})}_createAnswer(){if(this.destroyed)return;this._pc.createAnswer(this.answerOptions).then((J)=>{if(this.destroyed)return;if(!this.trickle&&!this.allowHalfTrickle)J.sdp=gG(J.sdp);J.sdp=this.sdpTransform(J.sdp);const Q=()=>{if(this.destroyed)return;const X=this._pc.localDescription||J;if(this._debug("signal"),this.emit("signal",{type:X.type,sdp:X.sdp}),!this.initiator)this._requestMissingTransceivers?.()},q=()=>{if(this.destroyed)return;if(this.trickle||this._iceComplete)Q();else this.once("_iceComplete",Q)},G=(X)=>{this.__destroy(n.default(X,"ERR_SET_LOCAL_DESCRIPTION"))};this._pc.setLocalDescription(J).then(q).catch(G)}).catch((J)=>{this.__destroy(n.default(J,"ERR_CREATE_ANSWER"))})}_onConnectionStateChange(){if(this.destroyed||this._destroying)return;if(this._pc.connectionState==="failed")this.__destroy(n.default(new Error("Connection failed."),"ERR_CONNECTION_FAILURE"))}_onIceStateChange(){if(this.destroyed)return;const J=this._pc.iceConnectionState,Q=this._pc.iceGatheringState;if(this._debug("iceStateChange (connection: %s) (gathering: %s)",J,Q),this.emit("iceStateChange",J,Q),J==="connected"||J==="completed")this._pcReady=!0,this._maybeReady();if(J==="failed")this.__destroy(n.default(new Error("Ice connection failed."),"ERR_ICE_CONNECTION_FAILURE"));if(J==="closed")this.__destroy(n.default(new Error("Ice connection closed."),"ERR_ICE_CONNECTION_CLOSED"))}getStats(J){const Q=(q)=>{if(Object.prototype.toString.call(q.values)==="[object Array]")q.values.forEach((G)=>{Object.assign(q,G)});return q};if(this._pc.getStats.length===0||this._isReactNativeWebrtc)this._pc.getStats().then((q)=>{const G=[];q.forEach((X)=>{G.push(Q(X))}),J(null,G)},(q)=>J(q));else if(this._pc.getStats.length>0)this._pc.getStats((q)=>{if(this.destroyed)return;const G=[];q.result().forEach((X)=>{const Y={};X.names().forEach((V)=>{Y[V]=X.stat(V)}),Y.id=X.id,Y.type=X.type,Y.timestamp=X.timestamp,G.push(Q(Y))}),J(null,G)},(q)=>J(q));else J(null,[])}_maybeReady(){if(this._debug("maybeReady pc %s channel %s",this._pcReady,this._channelReady),this._connected||this._connecting||!this._pcReady||!this._channelReady)return;this._connecting=!0;const J=()=>{if(this.destroyed||this._destroying)return;this.getStats((Q,q)=>{if(this.destroyed||this._destroying)return;if(Q)q=[];const G={},X={},Y={};let V=!1;q.forEach((Z)=>{if(Z.type==="remotecandidate"||Z.type==="remote-candidate")G[Z.id]=Z;if(Z.type==="localcandidate"||Z.type==="local-candidate")X[Z.id]=Z;if(Z.type==="candidatepair"||Z.type==="candidate-pair")Y[Z.id]=Z});const K=(Z)=>{V=!0;let W=X[Z.localCandidateId];if(W&&(W.ip||W.address))this.localAddress=W.ip||W.address,this.localPort=Number(W.port);else if(W&&W.ipAddress)this.localAddress=W.ipAddress,this.localPort=Number(W.portNumber);else if(typeof Z.googLocalAddress==="string")W=Z.googLocalAddress.split(":"),this.localAddress=W[0],this.localPort=Number(W[1]);if(this.localAddress)this.localFamily=this.localAddress.includes(":")?"IPv6":"IPv4";let $=G[Z.remoteCandidateId];if($&&($.ip||$.address))this.remoteAddress=$.ip||$.address,this.remotePort=Number($.port);else if($&&$.ipAddress)this.remoteAddress=$.ipAddress,this.remotePort=Number($.portNumber);else if(typeof Z.googRemoteAddress==="string")$=Z.googRemoteAddress.split(":"),this.remoteAddress=$[0],this.remotePort=Number($[1]);if(this.remoteAddress)this.remoteFamily=this.remoteAddress.includes(":")?"IPv6":"IPv4";this._debug("connect local: %s:%s remote: %s:%s",this.localAddress,this.localPort,this.remoteAddress,this.remotePort)};if(q.forEach((Z)=>{if(Z.type==="transport"&&Z.selectedCandidatePairId)K(Y[Z.selectedCandidatePairId]);if(Z.type==="googCandidatePair"&&Z.googActiveConnection==="true"||(Z.type==="candidatepair"||Z.type==="candidate-pair")&&Z.selected)K(Z)}),!V&&(!Object.keys(Y).length||Object.keys(X).length)){setTimeout(J,100);return}else this._connecting=!1,this._connected=!0;if(this._chunk){try{this.send(this._chunk)}catch(W){return this.__destroy(n.default(W,"ERR_DATA_CHANNEL"))}this._chunk=null,this._debug('sent chunk from "write before connect"');const Z=this._cb;this._cb=null,Z(null)}if(typeof this._channel.bufferedAmountLowThreshold!=="number"){if(this._interval=setInterval(()=>this._onInterval(),150),this._interval.unref)this._interval.unref()}this._debug("connect"),this.emit("connect")})};J()}_onInterval(){if(!this._cb||!this._channel||this._channel.bufferedAmount>Iq)return;this._onChannelBufferedAmountLow()}_onSignalingStateChange(){if(this.destroyed)return;if(this._pc.signalingState==="stable")if(this._isNegotiating=!1,this._debug("flushing sender queue",this._sendersAwaitingStable),this._sendersAwaitingStable.forEach((J)=>{this._pc.removeTrack(J),this._queuedNegotiation=!0}),this._sendersAwaitingStable=[],this._queuedNegotiation)this._debug("flushing negotiation queue"),this._queuedNegotiation=!1,this._needsNegotiation();else this._debug("negotiated"),this.emit("negotiated");this._debug("signalingStateChange %s",this._pc.signalingState),this.emit("signalingStateChange",this._pc.signalingState)}_onIceCandidate(J){if(this.destroyed)return;if(J.candidate&&this.trickle)this.emit("signal",{type:"candidate",candidate:{candidate:J.candidate.candidate,sdpMLineIndex:J.candidate.sdpMLineIndex,sdpMid:J.candidate.sdpMid}});else if(!J.candidate&&!this._iceComplete)this._iceComplete=!0,this.emit("_iceComplete");if(J.candidate)this._startIceCompleteTimeout()}_onChannelMessage(J){if(this.destroyed)return;let Q=J.data;if(Q instanceof ArrayBuffer)Q=new Uint8Array(Q);else if(this.__objectMode===!1)Q=TG(Q);this.push(Q)}_onChannelBufferedAmountLow(){if(this.destroyed||!this._cb)return;this._debug("ending backpressure: bufferedAmount %d",this._channel.bufferedAmount);const J=this._cb;this._cb=null,J(null)}_onChannelOpen(){if(this._connected||this.destroyed)return;this._debug("on channel open"),this._channelReady=!0,this._maybeReady()}_onChannelClose(){if(this.destroyed)return;this._debug("on channel close"),this.__destroy()}_debug(){const J=[].slice.call(arguments);J[0]="["+this._id+"] "+J[0],r4.apply(null,J)}}R8.WEBRTC_SUPPORT=!!yJ;R8.config={iceServers:[{urls:["stun:stun.l.google.com:19302","stun:global.stun.twilio.com:3478"]}],sdpSemantics:"unified-plan"};R8.channelConfig={};var EG=R8;var z0=d1(Fq(),1);/*! simple-peer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */class hG extends EG{constructor(J={}){super(J);if(!this._pc)return;if(this.streams=J.streams||(J.stream?[J.stream]:[]),this._senderMap=new Map,this.streams)this.streams.forEach((Q)=>{this.addStream(Q)});this._pc.ontrack=(Q)=>{this._onTrack(Q)}}addTransceiver(J,Q){if(this._destroying)return;if(this.destroyed)throw z0.default(new Error("cannot addTransceiver after peer is destroyed"),"ERR_DESTROYED");if(this._debug("addTransceiver()"),this.initiator)try{this._pc.addTransceiver(J,Q),this._needsNegotiation()}catch(q){this.__destroy(z0.default(q,"ERR_ADD_TRANSCEIVER"))}else this.emit("signal",{type:"transceiverRequest",transceiverRequest:{kind:J,init:Q}})}addStream(J){if(this._destroying)return;if(this.destroyed)throw z0.default(new Error("cannot addStream after peer is destroyed"),"ERR_DESTROYED");this._debug("addStream()"),J.getTracks().forEach((Q)=>{this.addTrack(Q,J)})}addTrack(J,Q){if(this._destroying)return;if(this.destroyed)throw z0.default(new Error("cannot addTrack after peer is destroyed"),"ERR_DESTROYED");this._debug("addTrack()");const q=this._senderMap.get(J)||new Map;let G=q.get(Q);if(!G)G=this._pc.addTrack(J,Q),q.set(Q,G),this._senderMap.set(J,q),this._needsNegotiation();else if(G.removed)throw z0.default(new Error("Track has been removed. You should enable/disable tracks that you want to re-add."),"ERR_SENDER_REMOVED");else throw z0.default(new Error("Track has already been added to that stream."),"ERR_SENDER_ALREADY_ADDED")}replaceTrack(J,Q,q){if(this._destroying)return;if(this.destroyed)throw z0.default(new Error("cannot replaceTrack after peer is destroyed"),"ERR_DESTROYED");this._debug("replaceTrack()");const G=this._senderMap.get(J),X=G?G.get(q):null;if(!X)throw z0.default(new Error("Cannot replace track that was never added."),"ERR_TRACK_NOT_ADDED");if(Q)this._senderMap.set(Q,G);if(X.replaceTrack!=null)X.replaceTrack(Q);else this.__destroy(z0.default(new Error("replaceTrack is not supported in this browser"),"ERR_UNSUPPORTED_REPLACETRACK"))}removeTrack(J,Q){if(this._destroying)return;if(this.destroyed)throw z0.default(new Error("cannot removeTrack after peer is destroyed"),"ERR_DESTROYED");this._debug("removeSender()");const q=this._senderMap.get(J),G=q?q.get(Q):null;if(!G)throw z0.default(new Error("Cannot remove track that was never added."),"ERR_TRACK_NOT_ADDED");try{G.removed=!0,this._pc.removeTrack(G)}catch(X){if(X.name==="NS_ERROR_UNEXPECTED")this._sendersAwaitingStable.push(G);else this.__destroy(z0.default(X,"ERR_REMOVE_TRACK"))}this._needsNegotiation()}removeStream(J){if(this._destroying)return;if(this.destroyed)throw z0.default(new Error("cannot removeStream after peer is destroyed"),"ERR_DESTROYED");this._debug("removeSenders()"),J.getTracks().forEach((Q)=>{this.removeTrack(Q,J)})}_requestMissingTransceivers(){if(this._pc.getTransceivers)this._pc.getTransceivers().forEach((J)=>{if(!J.mid&&J.sender.track&&!J.requested)J.requested=!0,this.addTransceiver(J.sender.track.kind)})}_onTrack(J){if(this.destroyed)return;J.streams.forEach((Q)=>{if(this._debug("on track"),this.emit("track",J.track,Q),this._remoteTracks.push({track:J.track,stream:Q}),this._remoteStreams.some((q)=>{return q.id===Q.id}))return;this._remoteStreams.push(Q),queueMicrotask(()=>{this._debug("on stream"),this.emit("stream",Q)})})}}var mG=hG;var _G="data",bG="signal",Aq=(J,Q)=>{const q=new mG({...{iceServers:[{urls:e4}]},...Q,initiator:J,trickle:!1}),G=(Y)=>X.push(Y);let X=[];return q.on(_G,G),{id:q._id,created:Date.now(),connection:q._pc,get channel(){return q._channel},get isDead(){return q.destroyed},signal:(Y)=>new Promise((V)=>{if(!J)q.on(bG,V);q.signal(Y)}),sendData:(Y)=>q.send(Y),destroy:()=>q.destroy(),setHandlers:(Y)=>Object.entries(Y).forEach(([V,K])=>q.on(V,K)),offerPromise:J?new Promise((Y)=>q.on(bG,Y)):Promise.resolve(),addStream:(Y)=>q.addStream(Y),removeStream:(Y)=>q.removeStream(Y),addTrack:(Y,V)=>q.addTrack(Y,V),removeTrack:(Y,V)=>q.removeTrack(Y,V),replaceTrack:(Y,V,K)=>q.replaceTrack(Y,V,K),drainEarlyData:(Y)=>{q.off(_G,G),X.forEach(Y),X=null}}},e4=[...J8(5,(J,Q)=>`stun:stun${Q||""}.l.google.com:19302`),"stun:global.stun.twilio.com:3478"];var JZ=Object.getPrototypeOf(Uint8Array),oJ=12,cG=0,nJ=cG+oJ,rJ=nJ+1,p1=rJ+1,f1=p1+1,T8=16384-f1,iJ=255,uG="bufferedamountlow",q1=(J)=>"@_"+J,pG=(J,Q,q)=>{const G={},X={},Y={},V={},K={},Z={},W={},$={onPeerJoin:p0,onPeerLeave:p0,onPeerStream:p0,onPeerTrack:p0},B=(w,R)=>(w?Array.isArray(w)?w:[w]:dQ(G)).flatMap((k)=>{const N=G[k];if(!N)return console.warn(`${w8}: no peer with id ${k} found`),[];return R(k,N)}),z=(w)=>{if(!G[w])return;delete G[w],delete V[w],delete K[w],$.onPeerLeave(w),Q(w)},U=(w)=>{if(X[w])return Y[w];if(!w)throw O0("action type argument is required");const R=g0(w);if(R.byteLength>oJ)throw O0(`action type string "${w}" (${R.byteLength}b) exceeds `+`byte limit (${oJ}). Hint: choose a shorter name.`);const k=new Uint8Array(oJ);k.set(R);let N=0;return X[w]={onComplete:p0,onProgress:p0,setOnComplete:(C)=>X[w]={...X[w],onComplete:C},setOnProgress:(C)=>X[w]={...X[w],onProgress:C},send:async(C,g,v,E)=>{if(v&&typeof v!=="object")throw O0("action meta argument must be an object");const c=typeof C;if(c==="undefined")throw O0("action data cannot be undefined");const f=c!=="string",h=C instanceof Blob,s=h||C instanceof ArrayBuffer||C instanceof JZ;if(v&&!s)throw O0("action meta argument can only be used with binary data");const b=s?new Uint8Array(h?await C.arrayBuffer():C):g0(f?w0(C):C),a=v?g0(w0(v)):null,p=Math.ceil(b.byteLength/T8)+(v?1:0)||1,i=J8(p,(V0,t)=>{const U0=t===p-1,H0=v&&t===0,X0=new Uint8Array(f1+(H0?a.byteLength:U0?b.byteLength-T8*(p-(v?2:1)):T8));return X0.set(k),X0.set([N],nJ),X0.set([U0|H0<<1|s<<2|f<<3],rJ),X0.set([Math.round((t+1)/p*iJ)],p1),X0.set(v?H0?a:b.subarray((t-1)*T8,t*T8):b.subarray(t*T8,(t+1)*T8),f1),X0});return N=N+1&iJ,q8(B(g,async(V0,t)=>{const{channel:U0}=t;let H0=0;while(H0<p){const X0=i[H0];if(U0.bufferedAmount>U0.bufferedAmountLowThreshold)await new Promise((Y8)=>{const y0=()=>{U0.removeEventListener(uG,y0),Y8()};U0.addEventListener(uG,y0)});if(!G[V0])break;t.sendData(X0),H0++,E?.(X0[p1]/iJ,V0,v)}}))}},Y[w]||=[X[w].send,X[w].setOnComplete,X[w].setOnProgress]},M=(w,R)=>{const k=new Uint8Array(R),N=i8(k.subarray(cG,nJ)).replaceAll("\0",""),[C]=k.subarray(nJ,rJ),[g]=k.subarray(rJ,p1),[v]=k.subarray(p1,f1),E=k.subarray(f1),c=!!(g&1),f=!!(g&1<<1),h=!!(g&1<<2),s=!!(g&1<<3);if(!X[N]){console.warn(`${w8}: received message with unregistered type (${N})`);return}V[w]||={},V[w][N]||={};const b=V[w][N][C]||={chunks:[]};if(f)b.meta=N8(i8(E));else b.chunks.push(E);if(X[N].onProgress(v/iJ,w,b.meta),!c)return;const a=new Uint8Array(b.chunks.reduce((p,i)=>p+i.byteLength,0));if(b.chunks.reduce((p,i)=>{return a.set(i,p),p+i.byteLength},0),delete V[w][N][C],h)X[N].onComplete(a,w,b.meta);else{const p=i8(a);X[N].onComplete(s?N8(p):p,w)}},H=async()=>{await A(""),await new Promise((w)=>setTimeout(w,99)),AJ(G).forEach(([w,R])=>{R.destroy(),delete G[w]}),q()},[j,P]=U(q1("ping")),[x,F]=U(q1("pong")),[L,I]=U(q1("signal")),[D,O]=U(q1("stream")),[S,y]=U(q1("track")),[A,T]=U(q1("leave"));if(J((w,R)=>{if(G[R])return;G[R]=w,w.setHandlers({data:(k)=>M(R,k),stream:(k)=>{$.onPeerStream(k,R,Z[R]),delete Z[R]},track:(k,N)=>{$.onPeerTrack(k,N,R,W[R]),delete W[R]},signal:(k)=>L(k,R),close:()=>z(R),error:()=>z(R)}),$.onPeerJoin(R),w.drainEarlyData?.((k)=>M(R,k))}),P((w,R)=>x("",R)),F((w,R)=>{K[R]?.(),delete K[R]}),I((w,R)=>G[R]?.signal(w)),O((w,R)=>Z[R]=w),y((w,R)=>W[R]=w),T((w,R)=>z(R)),R1)addEventListener("beforeunload",H);return{makeAction:U,leave:H,ping:async(w)=>{if(!w)throw O0("ping() must be called with target peer ID");const R=Date.now();return j("",w),await new Promise((k)=>K[w]=k),Date.now()-R},getPeers:()=>Xq(AJ(G).map(([w,R])=>[w,R.connection])),addStream:(w,R,k)=>B(R,async(N,C)=>{if(k)await D(k,N);C.addStream(w)}),removeStream:(w,R)=>B(R,(k,N)=>N.removeStream(w)),addTrack:(w,R,k,N)=>B(k,async(C,g)=>{if(N)await S(N,C);g.addTrack(w,R)}),removeTrack:(w,R,k)=>B(k,(N,C)=>C.removeTrack(w,R)),replaceTrack:(w,R,k,N,C)=>B(N,async(g,v)=>{if(C)await S(C,g);v.replaceTrack(w,R,k)}),onPeerJoin:(w)=>$.onPeerJoin=w,onPeerLeave:(w)=>$.onPeerLeave=w,onPeerStream:(w)=>$.onPeerStream=w,onPeerTrack:(w)=>$.onPeerTrack=w}};var qZ=20,QZ=5333,fG=57333,lG=({init:J,subscribe:Q,announce:q})=>{const G={};let X=!1,Y,V,K;return(Z,W,$)=>{const{appId:B}=Z;if(G[B]?.[W])return G[B][W];const z={},U={},M=T1(w8,B,W),H=g1(M),j=g1(T1(M,T0)),P=rQ(Z.password||"",B,W),x=(C)=>async(g)=>({type:g.type,sdp:await C(P,g.sdp)}),F=x(eQ),L=x(tQ),I=()=>Aq(!0,Z.rtcConfig),D=(C,g,v)=>{if(U[g]){if(U[g]!==C)C.destroy();return}U[g]=C,N(C,g),z[g]?.forEach((E,c)=>{if(c!==v)E.destroy()}),delete z[g]},O=(C,g)=>{if(U[g]===C)delete U[g]},S=(C,g)=>{if(U[C])return;const v=z[C]?.[g];if(v)delete z[C][g],v.destroy()},y=(C)=>{return V.push(...J8(C,I)),q8(V.splice(0,C).map((g)=>g.offerPromise.then(L).then((v)=>({peer:g,offer:v}))))},A=(C,g)=>$?.({error:`incorrect password (${Z.password}) when decrypting ${g}`,appId:B,peerId:C,roomId:W}),T=(C)=>async(g,v,E)=>{const[c,f]=await q8([H,j]);if(g!==c&&g!==f)return;const{peerId:h,offer:s,answer:b,peer:a}=typeof v==="string"?N8(v):v;if(h===T0||U[h])return;if(h&&!s&&!b){if(z[h]?.[C])return;const[[{peer:p,offer:i}],V0]=await q8([y(1),g1(T1(M,h))]);z[h]||=[],z[h][C]=p,setTimeout(()=>S(h,C),w[C]*0.9),p.setHandlers({connect:()=>D(p,h,C),close:()=>O(p,h)}),E(V0,w0({peerId:T0,offer:i}))}else if(s){if(z[h]?.[C]&&T0>h)return;const i=Aq(!1,Z.rtcConfig);i.setHandlers({connect:()=>D(i,h,C),close:()=>O(i,h)});let V0;try{V0=await F(s)}catch{A(h,"offer");return}if(i.isDead)return;const[t,U0]=await q8([g1(T1(M,h)),i.signal(V0)]);E(t,w0({peerId:T0,answer:await L(U0)}))}else if(b){let p;try{p=await F(b)}catch(i){A(h,"answer");return}if(a)a.setHandlers({connect:()=>D(a,h,C),close:()=>O(a,h)}),a.signal(p);else{const i=z[h]?.[C];if(i&&!i.isDead)i.signal(p)}}};if(!Z)throw O0("requires a config map as the first argument");if(!B&&!Z.firebaseApp)throw O0("config map is missing appId field");if(!W)throw O0("roomId argument required");if(!X){const C=J(Z);V=J8(qZ,I),Y=Array.isArray(C)?C:[C],X=!0,K=setInterval(()=>V=V.filter((g)=>{const v=Date.now()-g.created<fG;if(!v)g.destroy();return v}),fG*1.03)}const w=Y.map(()=>QZ),R=[],k=Y.map(async(C,g)=>Q(await C,await H,await j,T(g),y));q8([H,j]).then(([C,g])=>{const v=async(E,c)=>{const f=await q(E,C,g);if(typeof f==="number")w[c]=f;R[c]=setTimeout(()=>v(E,c),w[c])};k.forEach(async(E,c)=>{await E,v(await Y[c],c)})});let N=p0;return G[B]||={},G[B][W]=pG((C)=>N=C,(C)=>delete U[C],()=>{delete G[B][W],R.forEach(clearTimeout),k.forEach(async(C)=>(await C)()),clearInterval(K)})}};var rG={},GZ=5,aG="x",sG="EVENT",tG=R1&&SJ.utils.randomPrivateKey(),XZ=R1&&RJ(SJ.getPublicKey(tG)),Rq={},l1={},dG={},eG=()=>Math.floor(Date.now()/1000),J7=(J)=>dG[J]??(dG[J]=Yq(J,1e4)+20000),iG=async(J,Q)=>{const q={kind:J7(J),content:Q,pubkey:XZ,created_at:eG(),tags:[[aG,J]]},G=RJ(new Uint8Array(await crypto.subtle.digest("SHA-256",g0(w0([0,q.pubkey,q.created_at,q.kind,q.tags,q.content])))));return w0([sG,{...q,id:G,sig:RJ(await SJ.sign(G,tG))}])},oG=(J,Q)=>{return Rq[J]=Q,w0(["REQ",J,{kinds:[J7(Q)],since:eG(),["#"+aG]:[Q]}])},nG=(J)=>{return delete Rq[J],w0(["CLOSE",J])},Tq=lG({init:(J)=>iQ(J,VZ,GZ,!0).map((Q)=>{const q=oQ(Q,(G)=>{const[X,Y,V,K]=N8(G);if(X!==sG){const Z=`${w8}: relay failure from ${q.url} - `;if(X==="NOTICE")console.warn(Z+Y);else if(X==="OK"&&!V)console.warn(Z+K);return}l1[Y]?.(Rq[Y],V.content)});return rG[Q]=q,q.ready}),subscribe:(J,Q,q,G)=>{const X=IJ(64),Y=IJ(64);return l1[X]=l1[Y]=(V,K)=>G(V,K,async(Z,W)=>J.send(await iG(Z,W))),J.send(oG(X,Q)),J.send(oG(Y,q)),()=>{J.send(nG(X)),J.send(nG(Y)),delete l1[X],delete l1[Y]}},announce:async(J,Q)=>J.send(await iG(Q,w0({peerId:T0})))}),YZ=nQ(rG),VZ=["eu.purplerelay.com","ftp.halifax.rwth-aachen.de/nostr","longhorn.bgp.rodeo","multiplexer.huszonegy.world","nfdb.noswhere.com","nostr-verified.wellorder.net","nostr.cool110.xyz","nostr.data.haus","nostr.grooveix.com","nostr.huszonegy.world","nostr.mom","nostr.openhoofd.nl","nostr.petrkr.net/strfry","nostr.sathoarder.com","nostr.stakey.net","nostr.vulpem.com","nostr2.sanhauf.com","nostrelay.circum.space","relay.fountain.fm","relay.nostraddress.com","relay.nostromo.social","relay.snort.social","relay.verified-nostr.com","strfry.openhoofd.nl","yabu.me/v2"].map((J)=>"wss://"+J);var gq=(J,Q)=>{if(!J||!J.timestamp)return{resolved:!0,value:Q.newValue,timestamp:Q.timestamp};if(J.timestamp<Q.timestamp)return{resolved:!0,value:Q.newValue,timestamp:Q.timestamp};return{resolved:!1}};var KZ=()=>{const J=async(q)=>{try{const G=await(await navigator.storage.getDirectory()).getFileHandle(q,{create:!1}).then((Y)=>Y.createSyncAccessHandle()),X=new Uint8Array(G.getSize());return G.read(X,{at:0}),G.close(),{type:"loaded",name:q,data:X}}catch(G){return{type:"error",name:q,message:G.message||"File not found"}}},Q=async(q,G)=>{if(!(G instanceof Uint8Array))throw new Error("Content must be a Uint8Array");try{const X=await(await navigator.storage.getDirectory()).getFileHandle(q,{create:!0}).then((Y)=>Y.createSyncAccessHandle());return X.write(G,{at:0}),X.truncate(G.byteLength),X.close(),{type:"saved",name:q}}catch(X){return{type:"error",name:q,message:X.message||"Error saving the file"}}};self.onmessage=async({data:{type:q,name:G,content:X}})=>{try{const Y=q==="load"?await J(G):q==="save"?await Q(G,X):{type:"error",message:"Unrecognized action"};self.postMessage(Y)}catch(Y){self.postMessage({type:"error",message:Y.message||"Unexpected error"})}}},q7=KZ;async function WZ(){if(console.log("\u26A1 GDB-P2P: Empowering distributed graph databases with real-time synchronization and scalability. Learn more: https://github.com/estebanrfp/gdb \u26A1"),navigator?.storage?.getDirectory){const J=await navigator.storage.getDirectory();console.log("OPFS is enabled.")}else console.log("OPFS is not available.")}if(Symbol.dispose===void 0)Object.defineProperty(Symbol,"dispose",{value:Symbol.for("Symbol.dispose")});class Q7{constructor(){this.nodes={}}insert(J,Q){const q=Date.now();if(!this.nodes[J]||this.nodes[J].timestamp<q)this.nodes[J]={id:J,value:Q,edges:[],timestamp:q}}get(J){return this.nodes[J]||null}link(J,Q){const q=this.nodes[J],G=this.nodes[Q];if(q&&G&&!q.edges.includes(Q))q.edges.push(Q)}getAllNodes(){return Object.values(this.nodes)}serialize(){return T9.deflate(r1(this.nodes))}deserialize(J){this.nodes=J9(T9.inflate(new Uint8Array(J)))}}class G7{constructor(J,{password:Q}={}){this.name=J,this.password=Q,this.graph=new Q7,this.eventListeners=[],this.localHash,this.localTime=Date.now(),this.initWorker(),this.ready=(async()=>{await this.loadGraphFromOPFS()})();const q=`graph-sync-room-${this.name}`,G={appId:"1234",...this.password&&{password:this.password}},X=Tq(G,q);this.room=X,window.addEventListener("online",async()=>{console.log("\u2705 Reconnected to the network."),this.sendData([{type:"sync",hash:this.localHash,ts:this.localTime}])}),window.addEventListener("offline",async()=>{console.log("\u274C Disconnected from the network.")}),document.addEventListener("visibilitychange",()=>{if(document.visibilityState==="visible")console.log("La pesta\xF1a es visible nuevamente."),this.sendData([{type:"sync",hash:this.localHash,ts:this.localTime}]);else if(document.visibilityState==="hidden")console.log("La pesta\xF1a ya no es visible.")}),WZ(),X.onPeerJoin(async(K)=>{console.log("\u26A1 New pair connected:",K),this.sendData([{type:"sync",hash:this.localHash,ts:this.localTime}])}),X.onPeerLeave((K)=>{console.log("\u26A1 Pair disconnected:",K)});const[Y,V]=X.makeAction("syncGraph");this.sendData=Y,V((K)=>this.receiveChanges(K)),this.channel=new BroadcastChannel(`graphdb_sync_${this.name}`),this.channel.onmessage=async(K)=>{if(K.data==="update")console.log("\uD83D\uDD04 Update received from another tab..."),await this.loadGraphFromOPFS(),this.emit()}}initWorker=async()=>{try{const J=new Blob([`(${q7.toString()})()`],{type:"application/javascript"}),Q=URL.createObjectURL(J);this.worker=new Worker(Q),URL.revokeObjectURL(Q),this.worker.addEventListener("message",(q)=>{console.log("Worker message:",`${q.data.name} ${q.data.type}`)}),console.log("Worker inicializado correctamente.")}catch(J){console.error("Error al inicializar el worker:",J.message)}};emit(){const J=this.graph.getAllNodes();this.eventListeners.forEach((Q)=>Q(J))}on(J){this.eventListeners.push(J)}off(J){if(J)this.eventListeners=this.eventListeners.filter((Q)=>Q!==J);else this.eventListeners=[]}async getAllNodes(){return await this.ready,this.graph.getAllNodes()}async generateHash(J){const Q=new TextEncoder,q=await crypto.subtle.digest("SHA-256",Q.encode(J));return`0x${Array.from(new Uint8Array(q)).map((G)=>G.toString(16).padStart(2,"0")).join("")}`}async generateGraphHash(){const J=this.graph.serialize();return await this.generateHash(J)}async loadGraphFromOPFS(){try{const Q=await((q)=>{return new Promise((G,X)=>{this.worker.postMessage({type:"load",name:q});const Y=(V)=>{if(V.data.type==="loaded"&&V.data.name===q)this.worker.removeEventListener("message",Y),G(new Uint8Array(V.data.data));else if(V.data.type==="error")this.worker.removeEventListener("message",Y),X(new Error(V.data.message||"Error desconocido al cargar el archivo."))};this.worker.addEventListener("message",Y)})})(`${this.name}_graph.msgpack`).catch(()=>new Uint8Array);if(Q.byteLength>0)this.graph.deserialize(Q);else console.warn("The file '_graph.msgpack' is empty or could not be loaded.");console.log(`Graph loaded from OPFS: [ ${this.graph.getAllNodes().length} nodes ]`)}catch(J){console.error("General error loading the graph from OPFS:",J.message)}}async saveGraphToOPFS(){try{const J=this.graph.serialize();return await((q,G)=>new Promise((X,Y)=>{this.worker.postMessage({type:"save",name:q,content:G});const V=({data:K})=>{if(K.type==="saved"&&K.name===q)this.worker.removeEventListener("message",V),X();else if(K.type==="error")this.worker.removeEventListener("message",V),Y(new Error(K.message||"Error al guardar"))};this.worker.addEventListener("message",V)}))(`${this.name}_graph.msgpack`,J),this.localHash=await this.generateGraphHash(),this.localTime=Date.now(),this.channel.postMessage("update"),!0}catch(J){throw console.error("Error guardando:",J),new Error("Guardado fallido")}}async put(J,Q){await this.ready,Q??=await this.generateHash(r1(J));const q=this.graph.get(Q);if(!q)this.graph.insert(Q,J);else{const G={id:Q,newValue:J,timestamp:Date.now()},X=gq(q,G);if(X.resolved)q.value=X.value,q.timestamp=X.timestamp}if(await this.saveGraphToOPFS(),!q)this.sendData([{type:"insert",id:Q,value:J,timestamp:Date.now()}]);else this.sendData([{type:"update",id:Q,newValue:J,timestamp:Date.now()}]);return this.emit(),Q}async get(J,Q=null){await this.ready;let q=null,G=!1;if(typeof J==="object"&&J!==null)G=!0,q=this.graph.getAllNodes().filter((K)=>{return Object.entries(J).every(([Z,W])=>{return JSON.stringify(K.value[Z])===JSON.stringify(W)})}).sort((K,Z)=>Z.timestamp-K.timestamp)[0]||null;else{const Y=J;if(q=this.graph.get(Y),!q)return console.error(`Node with ID '${Y}' not found.`),null}if(!Q)return q;Q(q);const X=(Y)=>{if(G){const K=Y.filter((Z)=>{return Object.entries(J).every(([W,$])=>{return JSON.stringify(Z.value[W])===JSON.stringify($)})}).sort((Z,W)=>W.timestamp-Z.timestamp)[0]||null;if(JSON.stringify(K)!==JSON.stringify(q))q=K,Q(K)}else{const V=Y.find((K)=>K.id===J);if(V)Q(V)}};this.eventListeners.push(X)}async map(...J){await this.ready;const Q={$eq:(z,U)=>z===U,$ne:(z,U)=>z!==U,$gt:(z,U)=>z>U,$gte:(z,U)=>z>=U,$lt:(z,U)=>z<U,$lte:(z,U)=>z<=U,$in:(z,U)=>Array.isArray(U)&&U.includes(z),$between:(z,[U,M])=>z>=U&&z<=M,$exists:(z,U)=>U?z!==void 0:z===void 0,$text:(z,U)=>z?.toLowerCase().includes(U?.toLowerCase()),$and:(z,U)=>U.every((M)=>this.filterNode(z,M)),$or:(z,U)=>U.some((M)=>this.filterNode(z,M)),$not:(z,U)=>!this.filterNode(z,U)},q={realtime:!1,field:null,order:"asc",$limit:null,$after:null,$before:null};let G={},X={...q},Y=null;J.forEach((z)=>{if(typeof z==="function")Y=z;else if(z&&typeof z==="object")Object.keys(z).some((M)=>Object.hasOwnProperty.call(q,M))?Object.assign(X,z):Object.assign(G,z)});const V=(z,U=G)=>{return Object.entries(U).every(([M,H])=>{if(M.startsWith("$")){if(!Q[M])throw new Error(`Unsupported operator: ${M}`);return Q[M](z,H)}const j=z.value[M];if(typeof H!=="object"||H===null)return Q.$eq(j,H);return Object.entries(H).every(([P,x])=>{if(!Q[P])throw new Error(`Unsupported operator: ${P}`);if(P==="$between"&&typeof x?.[0]==="string"){const F=new Date(x[0]),L=new Date(x[1]),I=j instanceof Date?j:new Date(j);return!isNaN(I)&&Q.$between(I,[F,L])}return Q[P](j,x)})})},K=(z,U)=>{const{field:M,order:H}=X,j=H==="asc"?1:-1,P=z.value[M],x=U.value[M];if(P===void 0)return 1*j;if(x===void 0)return-1*j;if(typeof P==="string"&&typeof x==="string")return P.localeCompare(x)*j;return(P>x?1:-1)*j},Z=(z)=>{const U=Object.values(z).filter((P)=>V(P)),M=X.field?U.sort(K):U;let H=M;const j=X.$after||X.$before;if(j){const P=M.findIndex((x)=>x.id===j);if(P===-1){if(X.realtime)return[];throw new Error(`Cursor not found: ${j}`)}H=X.$after?M.slice(P+1):M.slice(0,P)}return X.$limit?H.slice(0,X.$limit):H};let W=Z(this.graph.nodes),$=null;const B=(z)=>{const U={added:z.filter((M)=>!W.some((H)=>H.id===M.id)),removed:W.filter((M)=>!z.some((H)=>H.id===M.id))};U.removed.forEach((M)=>Y(M.id,null,null,null,"removed")),U.added.forEach((M)=>Y(M.id,M.value,M.edges,M.timestamp,"added"))};if(Y){const z=Y.length>1;if(z)W.forEach((U)=>{Y(U.id,U.value,U.edges,U.timestamp,"initial")});else Y(W);if(X.realtime)$=(U)=>{const M=Z(U);if(JSON.stringify(M)!==JSON.stringify(W)){if(z)B(M);else Y(M);W=M}},this.on("update",$)}return X.realtime?{results:W,unsubscribe:()=>this.off("update",$)}:W}async remove(J){await this.ready;const Q=this.graph.get(J);if(!Q)return console.error(`Nodo con ID '${J}' no encontrado.`);delete this.graph.nodes[J];for(let q of Object.values(this.graph.nodes))q.edges=q.edges.filter((G)=>G!==J);await this.saveGraphToOPFS(),this.sendData([{type:"remove",id:J,value:Q.value,timestamp:Date.now()}]),this.emit()}async clear(){await this.ready,this.graph.nodes={};const J=await navigator.storage.getDirectory();try{await J.removeEntry(`${this.name}_graph.msgpack`)}catch(Q){console.warn(`Error deleting _graph.msgpack: ${Q.message}`)}console.log("All data has been deleted.")}async link(J,Q){if(await this.ready,!this.graph.nodes[J]||!this.graph.nodes[Q]){console.error(`Uno o ambos nodos (${J}, ${Q}) no existen.`);return}this.graph.link(J,Q),await this.saveGraphToOPFS(),this.sendData([{type:"link",sourceId:J,targetId:Q,timestamp:Date.now()}]),this.emit()}async applyFullGraph(J){try{this.graph.nodes={};for(let[Q,q]of Object.entries(J.nodes))this.graph.nodes[Q]=q;await this.saveGraphToOPFS()}catch(Q){console.error("Error applying the full graph:",Q.message)}}async receiveChanges(J){for(let Q of J)if(Q.type==="insert")this.graph.insert(Q.id,Q.value);else if(Q.type==="update"){const q=this.graph.get(Q.id),G=gq(q,Q);if(G.resolved)q.value=G.value,q.timestamp=G.timestamp}else if(Q.type==="remove")delete this.graph.nodes[Q.id];else if(Q.type==="link")this.graph.link(Q.sourceId,Q.targetId);else if(Q.type==="sync"){if(this.localHash!==Q.hash){if(this.localTime>Q.ts)console.log("Sending recent data to remote node."),this.sendData([{type:"syncReceive",graph:this.graph}])}}else if(Q.type==="syncReceive")await this.applyFullGraph(Q.graph);await this.saveGraphToOPFS(),this.emit()}}export{G7 as default};
