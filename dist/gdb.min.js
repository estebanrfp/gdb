var n5=Object.defineProperty;var a5=(J,G)=>{for(var Q in G)n5(J,Q,{get:G[Q],enumerable:!0,configurable:!0,set:(q)=>G[Q]=()=>q})};function HQ(J){const G=J.length;let Q=0,q=0;while(q<G){let W=J.charCodeAt(q++);if((W&4294967168)===0){Q++;continue}else if((W&4294965248)===0)Q+=2;else{if(W>=55296&&W<=56319){if(q<G){const X=J.charCodeAt(q);if((X&64512)===56320)++q,W=((W&1023)<<10)+(X&1023)+65536}}if((W&4294901760)===0)Q+=3;else Q+=4}}return Q}function s5(J,G,Q){const q=J.length;let W=Q,X=0;while(X<q){let U=J.charCodeAt(X++);if((U&4294967168)===0){G[W++]=U;continue}else if((U&4294965248)===0)G[W++]=U>>6&31|192;else{if(U>=55296&&U<=56319){if(X<q){const V=J.charCodeAt(X);if((V&64512)===56320)++X,U=((U&1023)<<10)+(V&1023)+65536}}if((U&4294901760)===0)G[W++]=U>>12&15|224,G[W++]=U>>6&63|128;else G[W++]=U>>18&7|240,G[W++]=U>>12&63|128,G[W++]=U>>6&63|128}G[W++]=U&63|128}}function JG(J,G,Q){t5.encodeInto(J,G.subarray(Q))}function jQ(J,G,Q){if(J.length>e5)JG(J,G,Q);else s5(J,G,Q)}function r1(J,G,Q){let q=G;const W=q+Q,X=[];let U="";while(q<W){const V=J[q++];if((V&128)===0)X.push(V);else if((V&224)===192){const K=J[q++]&63;X.push((V&31)<<6|K)}else if((V&240)===224){const K=J[q++]&63,Y=J[q++]&63;X.push((V&31)<<12|K<<6|Y)}else if((V&248)===240){const K=J[q++]&63,Y=J[q++]&63,Z=J[q++]&63;let H=(V&7)<<18|K<<12|Y<<6|Z;if(H>65535)H-=65536,X.push(H>>>10&1023|55296),H=56320|H&1023;X.push(H)}else X.push(V);if(X.length>=QG)U+=String.fromCharCode(...X),X.length=0}if(X.length>0)U+=String.fromCharCode(...X);return U}function WG(J,G,Q){const q=J.subarray(G,G+Q);return GG.decode(q)}function MQ(J,G,Q){if(Q>qG)return WG(J,G,Q);else return r1(J,G,Q)}var t5=new TextEncoder,e5=50,QG=4096,GG=new TextDecoder,qG=200;class H8{constructor(J,G){this.type=J,this.data=G}}class q0 extends Error{constructor(J){super(J);const G=Object.create(q0.prototype);Object.setPrototypeOf(this,G),Object.defineProperty(this,"name",{configurable:!0,enumerable:!1,value:q0.name})}}function PQ(J,G,Q){const q=Q/4294967296,W=Q;J.setUint32(G,q),J.setUint32(G+4,W)}function U1(J,G,Q){const q=Math.floor(Q/4294967296),W=Q;J.setUint32(G,q),J.setUint32(G+4,W)}function V1(J,G){const Q=J.getInt32(G),q=J.getUint32(G+4);return Q*4294967296+q}function CQ(J,G){const Q=J.getUint32(G),q=J.getUint32(G+4);return Q*4294967296+q}var j8=4294967295;function VG({sec:J,nsec:G}){if(J>=0&&G>=0&&J<=UG)if(G===0&&J<=YG){const Q=new Uint8Array(4);return new DataView(Q.buffer).setUint32(0,J),Q}else{const Q=J/4294967296,q=J&4294967295,W=new Uint8Array(8),X=new DataView(W.buffer);return X.setUint32(0,G<<2|Q&3),X.setUint32(4,q),W}else{const Q=new Uint8Array(12),q=new DataView(Q.buffer);return q.setUint32(0,G),U1(q,4,J),Q}}function KG(J){const G=J.getTime(),Q=Math.floor(G/1000),q=(G-Q*1000)*1e6,W=Math.floor(q/1e9);return{sec:Q+W,nsec:q-W*1e9}}function ZG(J){if(J instanceof Date){const G=KG(J);return VG(G)}else return null}function $G(J){const G=new DataView(J.buffer,J.byteOffset,J.byteLength);switch(J.byteLength){case 4:return{sec:G.getUint32(0),nsec:0};case 8:{const Q=G.getUint32(0),q=G.getUint32(4),W=(Q&3)*4294967296+q,X=Q>>>2;return{sec:W,nsec:X}}case 12:{const Q=V1(G,4),q=G.getUint32(0);return{sec:Q,nsec:q}}default:throw new q0(`Unrecognized data size for timestamp (expected 4, 8, or 12): ${J.length}`)}}function zG(J){const G=$G(J);return new Date(G.sec*1000+G.nsec/1e6)}var XG=-1,YG=4294967295,UG=17179869183,DQ={type:XG,encode:ZG,decode:zG};class r0{constructor(){this.builtInEncoders=[],this.builtInDecoders=[],this.encoders=[],this.decoders=[],this.register(DQ)}register({type:J,encode:G,decode:Q}){if(J>=0)this.encoders[J]=G,this.decoders[J]=Q;else{const q=-1-J;this.builtInEncoders[q]=G,this.builtInDecoders[q]=Q}}tryToEncode(J,G){for(let Q=0;Q<this.builtInEncoders.length;Q++){const q=this.builtInEncoders[Q];if(q!=null){const W=q(J,G);if(W!=null){const X=-1-Q;return new H8(X,W)}}}for(let Q=0;Q<this.encoders.length;Q++){const q=this.encoders[Q];if(q!=null){const W=q(J,G);if(W!=null)return new H8(Q,W)}}if(J instanceof H8)return J;return null}decode(J,G,Q){const q=G<0?this.builtInDecoders[-1-G]:this.decoders[G];if(q)return q(J,G,Q);else return new H8(G,J)}}r0.defaultCodec=new r0;var HG=function(J){return J instanceof ArrayBuffer||typeof SharedArrayBuffer!=="undefined"&&J instanceof SharedArrayBuffer};function T8(J){if(J instanceof Uint8Array)return J;else if(ArrayBuffer.isView(J))return new Uint8Array(J.buffer,J.byteOffset,J.byteLength);else if(HG(J))return new Uint8Array(J);else return Uint8Array.from(J)}var jG=100,MG=2048;class K1{constructor(J){this.entered=!1,this.extensionCodec=J?.extensionCodec??r0.defaultCodec,this.context=J?.context,this.useBigInt64=J?.useBigInt64??!1,this.maxDepth=J?.maxDepth??jG,this.initialBufferSize=J?.initialBufferSize??MG,this.sortKeys=J?.sortKeys??!1,this.forceFloat32=J?.forceFloat32??!1,this.ignoreUndefined=J?.ignoreUndefined??!1,this.forceIntegerToFloat=J?.forceIntegerToFloat??!1,this.pos=0,this.view=new DataView(new ArrayBuffer(this.initialBufferSize)),this.bytes=new Uint8Array(this.view.buffer)}clone(){return new K1({extensionCodec:this.extensionCodec,context:this.context,useBigInt64:this.useBigInt64,maxDepth:this.maxDepth,initialBufferSize:this.initialBufferSize,sortKeys:this.sortKeys,forceFloat32:this.forceFloat32,ignoreUndefined:this.ignoreUndefined,forceIntegerToFloat:this.forceIntegerToFloat})}reinitializeState(){this.pos=0}encodeSharedRef(J){if(this.entered)return this.clone().encodeSharedRef(J);try{return this.entered=!0,this.reinitializeState(),this.doEncode(J,1),this.bytes.subarray(0,this.pos)}finally{this.entered=!1}}encode(J){if(this.entered)return this.clone().encode(J);try{return this.entered=!0,this.reinitializeState(),this.doEncode(J,1),this.bytes.slice(0,this.pos)}finally{this.entered=!1}}doEncode(J,G){if(G>this.maxDepth)throw new Error(`Too deep objects in depth ${G}`);if(J==null)this.encodeNil();else if(typeof J==="boolean")this.encodeBoolean(J);else if(typeof J==="number")if(!this.forceIntegerToFloat)this.encodeNumber(J);else this.encodeNumberAsFloat(J);else if(typeof J==="string")this.encodeString(J);else if(this.useBigInt64&&typeof J==="bigint")this.encodeBigInt64(J);else this.encodeObject(J,G)}ensureBufferSizeToWrite(J){const G=this.pos+J;if(this.view.byteLength<G)this.resizeBuffer(G*2)}resizeBuffer(J){const G=new ArrayBuffer(J),Q=new Uint8Array(G),q=new DataView(G);Q.set(this.bytes),this.view=q,this.bytes=Q}encodeNil(){this.writeU8(192)}encodeBoolean(J){if(J===!1)this.writeU8(194);else this.writeU8(195)}encodeNumber(J){if(!this.forceIntegerToFloat&&Number.isSafeInteger(J))if(J>=0)if(J<128)this.writeU8(J);else if(J<256)this.writeU8(204),this.writeU8(J);else if(J<65536)this.writeU8(205),this.writeU16(J);else if(J<4294967296)this.writeU8(206),this.writeU32(J);else if(!this.useBigInt64)this.writeU8(207),this.writeU64(J);else this.encodeNumberAsFloat(J);else if(J>=-32)this.writeU8(224|J+32);else if(J>=-128)this.writeU8(208),this.writeI8(J);else if(J>=-32768)this.writeU8(209),this.writeI16(J);else if(J>=-2147483648)this.writeU8(210),this.writeI32(J);else if(!this.useBigInt64)this.writeU8(211),this.writeI64(J);else this.encodeNumberAsFloat(J);else this.encodeNumberAsFloat(J)}encodeNumberAsFloat(J){if(this.forceFloat32)this.writeU8(202),this.writeF32(J);else this.writeU8(203),this.writeF64(J)}encodeBigInt64(J){if(J>=BigInt(0))this.writeU8(207),this.writeBigUint64(J);else this.writeU8(211),this.writeBigInt64(J)}writeStringHeader(J){if(J<32)this.writeU8(160+J);else if(J<256)this.writeU8(217),this.writeU8(J);else if(J<65536)this.writeU8(218),this.writeU16(J);else if(J<4294967296)this.writeU8(219),this.writeU32(J);else throw new Error(`Too long string: ${J} bytes in UTF-8`)}encodeString(J){const Q=HQ(J);this.ensureBufferSizeToWrite(5+Q),this.writeStringHeader(Q),jQ(J,this.bytes,this.pos),this.pos+=Q}encodeObject(J,G){const Q=this.extensionCodec.tryToEncode(J,this.context);if(Q!=null)this.encodeExtension(Q);else if(Array.isArray(J))this.encodeArray(J,G);else if(ArrayBuffer.isView(J))this.encodeBinary(J);else if(typeof J==="object")this.encodeMap(J,G);else throw new Error(`Unrecognized object: ${Object.prototype.toString.apply(J)}`)}encodeBinary(J){const G=J.byteLength;if(G<256)this.writeU8(196),this.writeU8(G);else if(G<65536)this.writeU8(197),this.writeU16(G);else if(G<4294967296)this.writeU8(198),this.writeU32(G);else throw new Error(`Too large binary: ${G}`);const Q=T8(J);this.writeU8a(Q)}encodeArray(J,G){const Q=J.length;if(Q<16)this.writeU8(144+Q);else if(Q<65536)this.writeU8(220),this.writeU16(Q);else if(Q<4294967296)this.writeU8(221),this.writeU32(Q);else throw new Error(`Too large array: ${Q}`);for(let q of J)this.doEncode(q,G+1)}countWithoutUndefined(J,G){let Q=0;for(let q of G)if(J[q]!==void 0)Q++;return Q}encodeMap(J,G){const Q=Object.keys(J);if(this.sortKeys)Q.sort();const q=this.ignoreUndefined?this.countWithoutUndefined(J,Q):Q.length;if(q<16)this.writeU8(128+q);else if(q<65536)this.writeU8(222),this.writeU16(q);else if(q<4294967296)this.writeU8(223),this.writeU32(q);else throw new Error(`Too large map object: ${q}`);for(let W of Q){const X=J[W];if(!(this.ignoreUndefined&&X===void 0))this.encodeString(W),this.doEncode(X,G+1)}}encodeExtension(J){if(typeof J.data==="function"){const Q=J.data(this.pos+6),q=Q.length;if(q>=4294967296)throw new Error(`Too large extension object: ${q}`);this.writeU8(201),this.writeU32(q),this.writeI8(J.type),this.writeU8a(Q);return}const G=J.data.length;if(G===1)this.writeU8(212);else if(G===2)this.writeU8(213);else if(G===4)this.writeU8(214);else if(G===8)this.writeU8(215);else if(G===16)this.writeU8(216);else if(G<256)this.writeU8(199),this.writeU8(G);else if(G<65536)this.writeU8(200),this.writeU16(G);else if(G<4294967296)this.writeU8(201),this.writeU32(G);else throw new Error(`Too large extension object: ${G}`);this.writeI8(J.type),this.writeU8a(J.data)}writeU8(J){this.ensureBufferSizeToWrite(1),this.view.setUint8(this.pos,J),this.pos++}writeU8a(J){const G=J.length;this.ensureBufferSizeToWrite(G),this.bytes.set(J,this.pos),this.pos+=G}writeI8(J){this.ensureBufferSizeToWrite(1),this.view.setInt8(this.pos,J),this.pos++}writeU16(J){this.ensureBufferSizeToWrite(2),this.view.setUint16(this.pos,J),this.pos+=2}writeI16(J){this.ensureBufferSizeToWrite(2),this.view.setInt16(this.pos,J),this.pos+=2}writeU32(J){this.ensureBufferSizeToWrite(4),this.view.setUint32(this.pos,J),this.pos+=4}writeI32(J){this.ensureBufferSizeToWrite(4),this.view.setInt32(this.pos,J),this.pos+=4}writeF32(J){this.ensureBufferSizeToWrite(4),this.view.setFloat32(this.pos,J),this.pos+=4}writeF64(J){this.ensureBufferSizeToWrite(8),this.view.setFloat64(this.pos,J),this.pos+=8}writeU64(J){this.ensureBufferSizeToWrite(8),PQ(this.view,this.pos,J),this.pos+=8}writeI64(J){this.ensureBufferSizeToWrite(8),U1(this.view,this.pos,J),this.pos+=8}writeBigUint64(J){this.ensureBufferSizeToWrite(8),this.view.setBigUint64(this.pos,J),this.pos+=8}writeBigInt64(J){this.ensureBufferSizeToWrite(8),this.view.setBigInt64(this.pos,J),this.pos+=8}}function o0(J,G){return new K1(G).encodeSharedRef(J)}function Z1(J){return`${J<0?"-":""}0x${Math.abs(J).toString(16).padStart(2,"0")}`}var PG=16,CG=16;class o1{constructor(J=PG,G=CG){this.hit=0,this.miss=0,this.maxKeyLength=J,this.maxLengthPerKey=G,this.caches=[];for(let Q=0;Q<this.maxKeyLength;Q++)this.caches.push([])}canBeCached(J){return J>0&&J<=this.maxKeyLength}find(J,G,Q){const q=this.caches[Q-1];J:for(let W of q){const X=W.bytes;for(let U=0;U<Q;U++)if(X[U]!==J[G+U])continue J;return W.str}return null}store(J,G){const Q=this.caches[J.length-1],q={bytes:J,str:G};if(Q.length>=this.maxLengthPerKey)Q[Math.random()*Q.length|0]=q;else Q.push(q)}decode(J,G,Q){const q=this.find(J,G,Q);if(q!=null)return this.hit++,q;this.miss++;const W=r1(J,G,Q),X=Uint8Array.prototype.slice.call(J,G,G+Q);return this.store(X,W),W}}var n1="array",S8="map_key",BQ="map_value",DG=(J)=>{if(typeof J==="string"||typeof J==="number")return J;throw new q0("The type of key must be string or number but "+typeof J)};class NQ{constructor(){this.stack=[],this.stackHeadPosition=-1}get length(){return this.stackHeadPosition+1}top(){return this.stack[this.stackHeadPosition]}pushArrayState(J){const G=this.getUninitializedStateFromPool();G.type=n1,G.position=0,G.size=J,G.array=new Array(J)}pushMapState(J){const G=this.getUninitializedStateFromPool();G.type=S8,G.readCount=0,G.size=J,G.map={}}getUninitializedStateFromPool(){if(this.stackHeadPosition++,this.stackHeadPosition===this.stack.length){const J={type:void 0,size:0,array:void 0,position:0,readCount:0,map:void 0,key:null};this.stack.push(J)}return this.stack[this.stackHeadPosition]}release(J){if(this.stack[this.stackHeadPosition]!==J)throw new Error("Invalid stack state. Released state is not on top of the stack.");if(J.type===n1){const Q=J;Q.size=0,Q.array=void 0,Q.position=0,Q.type=void 0}if(J.type===S8||J.type===BQ){const Q=J;Q.size=0,Q.map=void 0,Q.readCount=0,Q.type=void 0}this.stackHeadPosition--}reset(){this.stack.length=0,this.stackHeadPosition=-1}}var F8=-1,a1=new DataView(new ArrayBuffer(0)),OG=new Uint8Array(a1.buffer);try{a1.getInt8(0)}catch(J){if(!(J instanceof RangeError))throw new Error("This module is not supported in the current JavaScript engine because DataView does not throw RangeError on out-of-bounds access")}var OQ=new RangeError("Insufficient data"),BG=new o1;class $1{constructor(J){this.totalPos=0,this.pos=0,this.view=a1,this.bytes=OG,this.headByte=F8,this.stack=new NQ,this.entered=!1,this.extensionCodec=J?.extensionCodec??r0.defaultCodec,this.context=J?.context,this.useBigInt64=J?.useBigInt64??!1,this.rawStrings=J?.rawStrings??!1,this.maxStrLength=J?.maxStrLength??j8,this.maxBinLength=J?.maxBinLength??j8,this.maxArrayLength=J?.maxArrayLength??j8,this.maxMapLength=J?.maxMapLength??j8,this.maxExtLength=J?.maxExtLength??j8,this.keyDecoder=J?.keyDecoder!==void 0?J.keyDecoder:BG,this.mapKeyConverter=J?.mapKeyConverter??DG}clone(){return new $1({extensionCodec:this.extensionCodec,context:this.context,useBigInt64:this.useBigInt64,rawStrings:this.rawStrings,maxStrLength:this.maxStrLength,maxBinLength:this.maxBinLength,maxArrayLength:this.maxArrayLength,maxMapLength:this.maxMapLength,maxExtLength:this.maxExtLength,keyDecoder:this.keyDecoder})}reinitializeState(){this.totalPos=0,this.headByte=F8,this.stack.reset()}setBuffer(J){const G=T8(J);this.bytes=G,this.view=new DataView(G.buffer,G.byteOffset,G.byteLength),this.pos=0}appendBuffer(J){if(this.headByte===F8&&!this.hasRemaining(1))this.setBuffer(J);else{const G=this.bytes.subarray(this.pos),Q=T8(J),q=new Uint8Array(G.length+Q.length);q.set(G),q.set(Q,G.length),this.setBuffer(q)}}hasRemaining(J){return this.view.byteLength-this.pos>=J}createExtraByteError(J){const{view:G,pos:Q}=this;return new RangeError(`Extra ${G.byteLength-Q} of ${G.byteLength} byte(s) found at buffer[${J}]`)}decode(J){if(this.entered)return this.clone().decode(J);try{this.entered=!0,this.reinitializeState(),this.setBuffer(J);const G=this.doDecodeSync();if(this.hasRemaining(1))throw this.createExtraByteError(this.pos);return G}finally{this.entered=!1}}*decodeMulti(J){if(this.entered){yield*this.clone().decodeMulti(J);return}try{this.entered=!0,this.reinitializeState(),this.setBuffer(J);while(this.hasRemaining(1))yield this.doDecodeSync()}finally{this.entered=!1}}async decodeAsync(J){if(this.entered)return this.clone().decodeAsync(J);try{this.entered=!0;let G=!1,Q;for await(let U of J){if(G)throw this.entered=!1,this.createExtraByteError(this.totalPos);this.appendBuffer(U);try{Q=this.doDecodeSync(),G=!0}catch(V){if(!(V instanceof RangeError))throw V}this.totalPos+=this.pos}if(G){if(this.hasRemaining(1))throw this.createExtraByteError(this.totalPos);return Q}const{headByte:q,pos:W,totalPos:X}=this;throw new RangeError(`Insufficient data in parsing ${Z1(q)} at ${X} (${W} in the current buffer)`)}finally{this.entered=!1}}decodeArrayStream(J){return this.decodeMultiAsync(J,!0)}decodeStream(J){return this.decodeMultiAsync(J,!1)}async*decodeMultiAsync(J,G){if(this.entered){yield*this.clone().decodeMultiAsync(J,G);return}try{this.entered=!0;let Q=G,q=-1;for await(let W of J){if(G&&q===0)throw this.createExtraByteError(this.totalPos);if(this.appendBuffer(W),Q)q=this.readArraySize(),Q=!1,this.complete();try{while(!0)if(yield this.doDecodeSync(),--q===0)break}catch(X){if(!(X instanceof RangeError))throw X}this.totalPos+=this.pos}}finally{this.entered=!1}}doDecodeSync(){J:while(!0){const J=this.readHeadByte();let G;if(J>=224)G=J-256;else if(J<192)if(J<128)G=J;else if(J<144){const q=J-128;if(q!==0){this.pushMapState(q),this.complete();continue J}else G={}}else if(J<160){const q=J-144;if(q!==0){this.pushArrayState(q),this.complete();continue J}else G=[]}else{const q=J-160;G=this.decodeString(q,0)}else if(J===192)G=null;else if(J===194)G=!1;else if(J===195)G=!0;else if(J===202)G=this.readF32();else if(J===203)G=this.readF64();else if(J===204)G=this.readU8();else if(J===205)G=this.readU16();else if(J===206)G=this.readU32();else if(J===207)if(this.useBigInt64)G=this.readU64AsBigInt();else G=this.readU64();else if(J===208)G=this.readI8();else if(J===209)G=this.readI16();else if(J===210)G=this.readI32();else if(J===211)if(this.useBigInt64)G=this.readI64AsBigInt();else G=this.readI64();else if(J===217){const q=this.lookU8();G=this.decodeString(q,1)}else if(J===218){const q=this.lookU16();G=this.decodeString(q,2)}else if(J===219){const q=this.lookU32();G=this.decodeString(q,4)}else if(J===220){const q=this.readU16();if(q!==0){this.pushArrayState(q),this.complete();continue J}else G=[]}else if(J===221){const q=this.readU32();if(q!==0){this.pushArrayState(q),this.complete();continue J}else G=[]}else if(J===222){const q=this.readU16();if(q!==0){this.pushMapState(q),this.complete();continue J}else G={}}else if(J===223){const q=this.readU32();if(q!==0){this.pushMapState(q),this.complete();continue J}else G={}}else if(J===196){const q=this.lookU8();G=this.decodeBinary(q,1)}else if(J===197){const q=this.lookU16();G=this.decodeBinary(q,2)}else if(J===198){const q=this.lookU32();G=this.decodeBinary(q,4)}else if(J===212)G=this.decodeExtension(1,0);else if(J===213)G=this.decodeExtension(2,0);else if(J===214)G=this.decodeExtension(4,0);else if(J===215)G=this.decodeExtension(8,0);else if(J===216)G=this.decodeExtension(16,0);else if(J===199){const q=this.lookU8();G=this.decodeExtension(q,1)}else if(J===200){const q=this.lookU16();G=this.decodeExtension(q,2)}else if(J===201){const q=this.lookU32();G=this.decodeExtension(q,4)}else throw new q0(`Unrecognized type byte: ${Z1(J)}`);this.complete();const Q=this.stack;while(Q.length>0){const q=Q.top();if(q.type===n1)if(q.array[q.position]=G,q.position++,q.position===q.size)G=q.array,Q.release(q);else continue J;else if(q.type===S8){if(G==="__proto__")throw new q0("The key __proto__ is not allowed");q.key=this.mapKeyConverter(G),q.type=BQ;continue J}else if(q.map[q.key]=G,q.readCount++,q.readCount===q.size)G=q.map,Q.release(q);else{q.key=null,q.type=S8;continue J}}return G}}readHeadByte(){if(this.headByte===F8)this.headByte=this.readU8();return this.headByte}complete(){this.headByte=F8}readArraySize(){const J=this.readHeadByte();switch(J){case 220:return this.readU16();case 221:return this.readU32();default:if(J<160)return J-144;else throw new q0(`Unrecognized array type byte: ${Z1(J)}`)}}pushMapState(J){if(J>this.maxMapLength)throw new q0(`Max length exceeded: map length (${J}) > maxMapLengthLength (${this.maxMapLength})`);this.stack.pushMapState(J)}pushArrayState(J){if(J>this.maxArrayLength)throw new q0(`Max length exceeded: array length (${J}) > maxArrayLength (${this.maxArrayLength})`);this.stack.pushArrayState(J)}decodeString(J,G){if(!this.rawStrings||this.stateIsMapKey())return this.decodeUtf8String(J,G);return this.decodeBinary(J,G)}decodeUtf8String(J,G){if(J>this.maxStrLength)throw new q0(`Max length exceeded: UTF-8 byte length (${J}) > maxStrLength (${this.maxStrLength})`);if(this.bytes.byteLength<this.pos+G+J)throw OQ;const Q=this.pos+G;let q;if(this.stateIsMapKey()&&this.keyDecoder?.canBeCached(J))q=this.keyDecoder.decode(this.bytes,Q,J);else q=MQ(this.bytes,Q,J);return this.pos+=G+J,q}stateIsMapKey(){if(this.stack.length>0)return this.stack.top().type===S8;return!1}decodeBinary(J,G){if(J>this.maxBinLength)throw new q0(`Max length exceeded: bin length (${J}) > maxBinLength (${this.maxBinLength})`);if(!this.hasRemaining(J+G))throw OQ;const Q=this.pos+G,q=this.bytes.subarray(Q,Q+J);return this.pos+=G+J,q}decodeExtension(J,G){if(J>this.maxExtLength)throw new q0(`Max length exceeded: ext length (${J}) > maxExtLength (${this.maxExtLength})`);const Q=this.view.getInt8(this.pos+G),q=this.decodeBinary(J,G+1);return this.extensionCodec.decode(q,Q,this.context)}lookU8(){return this.view.getUint8(this.pos)}lookU16(){return this.view.getUint16(this.pos)}lookU32(){return this.view.getUint32(this.pos)}readU8(){const J=this.view.getUint8(this.pos);return this.pos++,J}readI8(){const J=this.view.getInt8(this.pos);return this.pos++,J}readU16(){const J=this.view.getUint16(this.pos);return this.pos+=2,J}readI16(){const J=this.view.getInt16(this.pos);return this.pos+=2,J}readU32(){const J=this.view.getUint32(this.pos);return this.pos+=4,J}readI32(){const J=this.view.getInt32(this.pos);return this.pos+=4,J}readU64(){const J=CQ(this.view,this.pos);return this.pos+=8,J}readI64(){const J=V1(this.view,this.pos);return this.pos+=8,J}readU64AsBigInt(){const J=this.view.getBigUint64(this.pos);return this.pos+=8,J}readI64AsBigInt(){const J=this.view.getBigInt64(this.pos);return this.pos+=8,J}readF32(){const J=this.view.getFloat32(this.pos);return this.pos+=4,J}readF64(){const J=this.view.getFloat64(this.pos);return this.pos+=8,J}}function s1(J,G){return new $1(G).decode(J)}var B8=function(J){let G=J.length;while(--G>=0)J[G]=0},e1=function(J,G,Q,q,W){this.static_tree=J,this.extra_bits=G,this.extra_base=Q,this.elems=q,this.max_length=W,this.has_stree=J&&J.length},JJ=function(J,G){this.dyn_tree=J,this.max_code=0,this.stat_desc=G},D0=function(J,G,Q,q,W){this.good_length=J,this.max_lazy=G,this.nice_length=Q,this.max_chain=q,this.func=W},L6=function(){this.strm=null,this.status=0,this.pending_buf=null,this.pending_buf_size=0,this.pending_out=0,this.pending=0,this.wrap=0,this.gzhead=null,this.gzindex=0,this.method=N1,this.last_flush=-1,this.w_size=0,this.w_bits=0,this.w_mask=0,this.window=null,this.window_size=0,this.prev=null,this.head=null,this.ins_h=0,this.hash_size=0,this.hash_bits=0,this.hash_mask=0,this.hash_shift=0,this.block_start=0,this.match_length=0,this.prev_match=0,this.match_available=0,this.strstart=0,this.match_start=0,this.lookahead=0,this.prev_length=0,this.max_chain_length=0,this.max_lazy_match=0,this.level=0,this.strategy=0,this.good_match=0,this.nice_match=0,this.dyn_ltree=new Uint16Array(H6*2),this.dyn_dtree=new Uint16Array((2*$6+1)*2),this.bl_tree=new Uint16Array((2*z6+1)*2),E0(this.dyn_ltree),E0(this.dyn_dtree),E0(this.bl_tree),this.l_desc=null,this.d_desc=null,this.bl_desc=null,this.bl_count=new Uint16Array(j6+1),this.heap=new Uint16Array(2*MJ+1),E0(this.heap),this.heap_len=0,this.heap_max=0,this.depth=new Uint16Array(2*MJ+1),E0(this.depth),this.sym_buf=0,this.lit_bufsize=0,this.sym_next=0,this.sym_end=0,this.opt_len=0,this.static_len=0,this.matches=0,this.insert=0,this.bi_buf=0,this.bi_valid=0},l6=function(){this.input=null,this.next_in=0,this.avail_in=0,this.total_in=0,this.output=null,this.next_out=0,this.avail_out=0,this.total_out=0,this.msg="",this.state=null,this.data_type=2,this.adler=0},o8=function(J){this.options=L1.assign({level:a6,method:t6,chunkSize:16384,windowBits:15,memLevel:8,strategy:s6},J||{});let G=this.options;if(G.raw&&G.windowBits>0)G.windowBits=-G.windowBits;else if(G.gzip&&G.windowBits>0&&G.windowBits<16)G.windowBits+=16;this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new w9,this.strm.avail_out=0;let Q=f8.deflateInit2(this.strm,G.level,G.method,G.windowBits,G.memLevel,G.strategy);if(Q!==O1)throw new Error(t0[Q]);if(G.header)f8.deflateSetHeader(this.strm,G.header);if(G.dictionary){let q;if(typeof G.dictionary==="string")q=l8.string2buf(G.dictionary);else if(x9.call(G.dictionary)==="[object ArrayBuffer]")q=new Uint8Array(G.dictionary);else q=G.dictionary;if(Q=f8.deflateSetDictionary(this.strm,q),Q!==O1)throw new Error(t0[Q]);this._dict_set=!0}},kJ=function(J,G){const Q=new o8(G);if(Q.push(J,!0),Q.err)throw Q.msg||t0[Q.err];return Q.result},e6=function(J,G){return G=G||{},G.raw=!0,kJ(J,G)},J7=function(J,G){return G=G||{},G.gzip=!0,kJ(J,G)},A7=function(){this.strm=null,this.mode=0,this.last=!1,this.wrap=0,this.havedict=!1,this.flags=0,this.dmax=0,this.check=0,this.total=0,this.head=null,this.wbits=0,this.wsize=0,this.whave=0,this.wnext=0,this.window=null,this.hold=0,this.bits=0,this.length=0,this.offset=0,this.extra=0,this.lencode=null,this.distcode=null,this.lenbits=0,this.distbits=0,this.ncode=0,this.nlen=0,this.ndist=0,this.have=0,this.next=null,this.lens=new Uint16Array(320),this.work=new Uint16Array(288),this.lendyn=null,this.distdyn=null,this.sane=0,this.back=0,this.was=0},m7=function(){this.text=0,this.time=0,this.xflags=0,this.os=0,this.extra=null,this.extra_len=0,this.name="",this.comment="",this.hcrc=0,this.done=!1},n8=function(J){this.options=L1.assign({chunkSize:65536,windowBits:15,to:""},J||{});const G=this.options;if(G.raw&&G.windowBits>=0&&G.windowBits<16){if(G.windowBits=-G.windowBits,G.windowBits===0)G.windowBits=-15}if(G.windowBits>=0&&G.windowBits<16&&!(J&&J.windowBits))G.windowBits+=32;if(G.windowBits>15&&G.windowBits<48){if((G.windowBits&15)===0)G.windowBits|=15}this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new w9,this.strm.avail_out=0;let Q=x0.inflateInit2(this.strm,G.windowBits);if(Q!==d8)throw new Error(t0[Q]);if(this.header=new _7,x0.inflateGetHeader(this.strm,this.header),G.dictionary){if(typeof G.dictionary==="string")G.dictionary=l8.string2buf(G.dictionary);else if(m9.call(G.dictionary)==="[object ArrayBuffer]")G.dictionary=new Uint8Array(G.dictionary);if(G.raw){if(Q=x0.inflateSetDictionary(this.strm,G.dictionary),Q!==d8)throw new Error(t0[Q])}}},wJ=function(J,G){const Q=new n8(G);if(Q.push(J),Q.err)throw Q.msg||t0[Q.err];return Q.result},i7=function(J,G){return G=G||{},G.raw=!0,wJ(J,G)};/*! pako 2.1.0 https://github.com/nodeca/pako @license (MIT AND Zlib) */var NG=0,Y9=1,LG=2,AG=3,RG=258,NJ=29,i8=256,h8=i8+1+NJ,C8=30,LJ=19,U9=2*h8+1,n0=15,t1=16,IG=7,AJ=256,V9=16,K9=17,Z9=18,zJ=new Uint8Array([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0]),C1=new Uint8Array([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13]),kG=new Uint8Array([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7]),$9=new Uint8Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),wG=512,w0=new Array((h8+2)*2);B8(w0);var y8=new Array(C8*2);B8(y8);var u8=new Array(wG);B8(u8);var m8=new Array(RG-AG+1);B8(m8);var RJ=new Array(NJ);B8(RJ);var D1=new Array(C8);B8(D1);var z9,H9,j9,M9=(J)=>{return J<256?u8[J]:u8[256+(J>>>7)]},_8=(J,G)=>{J.pending_buf[J.pending++]=G&255,J.pending_buf[J.pending++]=G>>>8&255},X0=(J,G,Q)=>{if(J.bi_valid>t1-Q)J.bi_buf|=G<<J.bi_valid&65535,_8(J,J.bi_buf),J.bi_buf=G>>t1-J.bi_valid,J.bi_valid+=Q-t1;else J.bi_buf|=G<<J.bi_valid&65535,J.bi_valid+=Q},O0=(J,G,Q)=>{X0(J,Q[G*2],Q[G*2+1])},P9=(J,G)=>{let Q=0;do Q|=J&1,J>>>=1,Q<<=1;while(--G>0);return Q>>>1},xG=(J)=>{if(J.bi_valid===16)_8(J,J.bi_buf),J.bi_buf=0,J.bi_valid=0;else if(J.bi_valid>=8)J.pending_buf[J.pending++]=J.bi_buf&255,J.bi_buf>>=8,J.bi_valid-=8},TG=(J,G)=>{const{dyn_tree:Q,max_code:q}=G,W=G.stat_desc.static_tree,X=G.stat_desc.has_stree,U=G.stat_desc.extra_bits,V=G.stat_desc.extra_base,K=G.stat_desc.max_length;let Y,Z,H,$,z,C,j=0;for($=0;$<=n0;$++)J.bl_count[$]=0;Q[J.heap[J.heap_max]*2+1]=0;for(Y=J.heap_max+1;Y<U9;Y++){if(Z=J.heap[Y],$=Q[Q[Z*2+1]*2+1]+1,$>K)$=K,j++;if(Q[Z*2+1]=$,Z>q)continue;if(J.bl_count[$]++,z=0,Z>=V)z=U[Z-V];if(C=Q[Z*2],J.opt_len+=C*($+z),X)J.static_len+=C*(W[Z*2+1]+z)}if(j===0)return;do{$=K-1;while(J.bl_count[$]===0)$--;J.bl_count[$]--,J.bl_count[$+1]+=2,J.bl_count[K]--,j-=2}while(j>0);for($=K;$!==0;$--){Z=J.bl_count[$];while(Z!==0){if(H=J.heap[--Y],H>q)continue;if(Q[H*2+1]!==$)J.opt_len+=($-Q[H*2+1])*Q[H*2],Q[H*2+1]=$;Z--}}},C9=(J,G,Q)=>{const q=new Array(n0+1);let W=0,X,U;for(X=1;X<=n0;X++)W=W+Q[X-1]<<1,q[X]=W;for(U=0;U<=G;U++){let V=J[U*2+1];if(V===0)continue;J[U*2]=P9(q[V]++,V)}},FG=()=>{let J,G,Q,q,W;const X=new Array(n0+1);Q=0;for(q=0;q<NJ-1;q++){RJ[q]=Q;for(J=0;J<1<<zJ[q];J++)m8[Q++]=q}m8[Q-1]=q,W=0;for(q=0;q<16;q++){D1[q]=W;for(J=0;J<1<<C1[q];J++)u8[W++]=q}W>>=7;for(;q<C8;q++){D1[q]=W<<7;for(J=0;J<1<<C1[q]-7;J++)u8[256+W++]=q}for(G=0;G<=n0;G++)X[G]=0;J=0;while(J<=143)w0[J*2+1]=8,J++,X[8]++;while(J<=255)w0[J*2+1]=9,J++,X[9]++;while(J<=279)w0[J*2+1]=7,J++,X[7]++;while(J<=287)w0[J*2+1]=8,J++,X[8]++;C9(w0,h8+1,X);for(J=0;J<C8;J++)y8[J*2+1]=5,y8[J*2]=P9(J,5);z9=new e1(w0,zJ,i8+1,h8,n0),H9=new e1(y8,C1,0,C8,n0),j9=new e1(new Array(0),kG,0,LJ,IG)},D9=(J)=>{let G;for(G=0;G<h8;G++)J.dyn_ltree[G*2]=0;for(G=0;G<C8;G++)J.dyn_dtree[G*2]=0;for(G=0;G<LJ;G++)J.bl_tree[G*2]=0;J.dyn_ltree[AJ*2]=1,J.opt_len=J.static_len=0,J.sym_next=J.matches=0},O9=(J)=>{if(J.bi_valid>8)_8(J,J.bi_buf);else if(J.bi_valid>0)J.pending_buf[J.pending++]=J.bi_buf;J.bi_buf=0,J.bi_valid=0},LQ=(J,G,Q,q)=>{const W=G*2,X=Q*2;return J[W]<J[X]||J[W]===J[X]&&q[G]<=q[Q]},QJ=(J,G,Q)=>{const q=J.heap[Q];let W=Q<<1;while(W<=J.heap_len){if(W<J.heap_len&&LQ(G,J.heap[W+1],J.heap[W],J.depth))W++;if(LQ(G,q,J.heap[W],J.depth))break;J.heap[Q]=J.heap[W],Q=W,W<<=1}J.heap[Q]=q},AQ=(J,G,Q)=>{let q,W,X=0,U,V;if(J.sym_next!==0)do if(q=J.pending_buf[J.sym_buf+X++]&255,q+=(J.pending_buf[J.sym_buf+X++]&255)<<8,W=J.pending_buf[J.sym_buf+X++],q===0)O0(J,W,G);else{if(U=m8[W],O0(J,U+i8+1,G),V=zJ[U],V!==0)W-=RJ[U],X0(J,W,V);if(q--,U=M9(q),O0(J,U,Q),V=C1[U],V!==0)q-=D1[U],X0(J,q,V)}while(X<J.sym_next);O0(J,AJ,G)},HJ=(J,G)=>{const Q=G.dyn_tree,q=G.stat_desc.static_tree,W=G.stat_desc.has_stree,X=G.stat_desc.elems;let U,V,K=-1,Y;J.heap_len=0,J.heap_max=U9;for(U=0;U<X;U++)if(Q[U*2]!==0)J.heap[++J.heap_len]=K=U,J.depth[U]=0;else Q[U*2+1]=0;while(J.heap_len<2)if(Y=J.heap[++J.heap_len]=K<2?++K:0,Q[Y*2]=1,J.depth[Y]=0,J.opt_len--,W)J.static_len-=q[Y*2+1];G.max_code=K;for(U=J.heap_len>>1;U>=1;U--)QJ(J,Q,U);Y=X;do U=J.heap[1],J.heap[1]=J.heap[J.heap_len--],QJ(J,Q,1),V=J.heap[1],J.heap[--J.heap_max]=U,J.heap[--J.heap_max]=V,Q[Y*2]=Q[U*2]+Q[V*2],J.depth[Y]=(J.depth[U]>=J.depth[V]?J.depth[U]:J.depth[V])+1,Q[U*2+1]=Q[V*2+1]=Y,J.heap[1]=Y++,QJ(J,Q,1);while(J.heap_len>=2);J.heap[--J.heap_max]=J.heap[1],TG(J,G),C9(Q,K,J.bl_count)},RQ=(J,G,Q)=>{let q,W=-1,X,U=G[1],V=0,K=7,Y=4;if(U===0)K=138,Y=3;G[(Q+1)*2+1]=65535;for(q=0;q<=Q;q++){if(X=U,U=G[(q+1)*2+1],++V<K&&X===U)continue;else if(V<Y)J.bl_tree[X*2]+=V;else if(X!==0){if(X!==W)J.bl_tree[X*2]++;J.bl_tree[V9*2]++}else if(V<=10)J.bl_tree[K9*2]++;else J.bl_tree[Z9*2]++;if(V=0,W=X,U===0)K=138,Y=3;else if(X===U)K=6,Y=3;else K=7,Y=4}},IQ=(J,G,Q)=>{let q,W=-1,X,U=G[1],V=0,K=7,Y=4;if(U===0)K=138,Y=3;for(q=0;q<=Q;q++){if(X=U,U=G[(q+1)*2+1],++V<K&&X===U)continue;else if(V<Y)do O0(J,X,J.bl_tree);while(--V!==0);else if(X!==0){if(X!==W)O0(J,X,J.bl_tree),V--;O0(J,V9,J.bl_tree),X0(J,V-3,2)}else if(V<=10)O0(J,K9,J.bl_tree),X0(J,V-3,3);else O0(J,Z9,J.bl_tree),X0(J,V-11,7);if(V=0,W=X,U===0)K=138,Y=3;else if(X===U)K=6,Y=3;else K=7,Y=4}},SG=(J)=>{let G;RQ(J,J.dyn_ltree,J.l_desc.max_code),RQ(J,J.dyn_dtree,J.d_desc.max_code),HJ(J,J.bl_desc);for(G=LJ-1;G>=3;G--)if(J.bl_tree[$9[G]*2+1]!==0)break;return J.opt_len+=3*(G+1)+5+5+4,G},vG=(J,G,Q,q)=>{let W;X0(J,G-257,5),X0(J,Q-1,5),X0(J,q-4,4);for(W=0;W<q;W++)X0(J,J.bl_tree[$9[W]*2+1],3);IQ(J,J.dyn_ltree,G-1),IQ(J,J.dyn_dtree,Q-1)},gG=(J)=>{let G=4093624447,Q;for(Q=0;Q<=31;Q++,G>>>=1)if(G&1&&J.dyn_ltree[Q*2]!==0)return 0;if(J.dyn_ltree[18]!==0||J.dyn_ltree[20]!==0||J.dyn_ltree[26]!==0)return 1;for(Q=32;Q<i8;Q++)if(J.dyn_ltree[Q*2]!==0)return 1;return 0},kQ=!1,EG=(J)=>{if(!kQ)FG(),kQ=!0;J.l_desc=new JJ(J.dyn_ltree,z9),J.d_desc=new JJ(J.dyn_dtree,H9),J.bl_desc=new JJ(J.bl_tree,j9),J.bi_buf=0,J.bi_valid=0,D9(J)},B9=(J,G,Q,q)=>{if(X0(J,(NG<<1)+(q?1:0),3),O9(J),_8(J,Q),_8(J,~Q),Q)J.pending_buf.set(J.window.subarray(G,G+Q),J.pending);J.pending+=Q},yG=(J)=>{X0(J,Y9<<1,3),O0(J,AJ,w0),xG(J)},fG=(J,G,Q,q)=>{let W,X,U=0;if(J.level>0){if(J.strm.data_type===2)J.strm.data_type=gG(J);if(HJ(J,J.l_desc),HJ(J,J.d_desc),U=SG(J),W=J.opt_len+3+7>>>3,X=J.static_len+3+7>>>3,X<=W)W=X}else W=X=Q+5;if(Q+4<=W&&G!==-1)B9(J,G,Q,q);else if(J.strategy===4||X===W)X0(J,(Y9<<1)+(q?1:0),3),AQ(J,w0,y8);else X0(J,(LG<<1)+(q?1:0),3),vG(J,J.l_desc.max_code+1,J.d_desc.max_code+1,U+1),AQ(J,J.dyn_ltree,J.dyn_dtree);if(D9(J),q)O9(J)},bG=(J,G,Q)=>{if(J.pending_buf[J.sym_buf+J.sym_next++]=G,J.pending_buf[J.sym_buf+J.sym_next++]=G>>8,J.pending_buf[J.sym_buf+J.sym_next++]=Q,G===0)J.dyn_ltree[Q*2]++;else J.matches++,G--,J.dyn_ltree[(m8[Q]+i8+1)*2]++,J.dyn_dtree[M9(G)*2]++;return J.sym_next===J.sym_end},hG=EG,uG=B9,mG=fG,_G=bG,cG=yG,pG={_tr_init:hG,_tr_stored_block:uG,_tr_flush_block:mG,_tr_tally:_G,_tr_align:cG},lG=(J,G,Q,q)=>{let W=J&65535|0,X=J>>>16&65535|0,U=0;while(Q!==0){U=Q>2000?2000:Q,Q-=U;do W=W+G[q++]|0,X=X+W|0;while(--U);W%=65521,X%=65521}return W|X<<16|0},c8=lG,dG=()=>{let J,G=[];for(var Q=0;Q<256;Q++){J=Q;for(var q=0;q<8;q++)J=J&1?3988292384^J>>>1:J>>>1;G[Q]=J}return G},iG=new Uint32Array(dG()),rG=(J,G,Q,q)=>{const W=iG,X=q+Q;J^=-1;for(let U=q;U<X;U++)J=J>>>8^W[(J^G[U])&255];return J^-1},t=rG,t0={2:"need dictionary",1:"stream end",0:"","-1":"file error","-2":"stream error","-3":"data error","-4":"insufficient memory","-5":"buffer error","-6":"incompatible version"},Q8={Z_NO_FLUSH:0,Z_PARTIAL_FLUSH:1,Z_SYNC_FLUSH:2,Z_FULL_FLUSH:3,Z_FINISH:4,Z_BLOCK:5,Z_TREES:6,Z_OK:0,Z_STREAM_END:1,Z_NEED_DICT:2,Z_ERRNO:-1,Z_STREAM_ERROR:-2,Z_DATA_ERROR:-3,Z_MEM_ERROR:-4,Z_BUF_ERROR:-5,Z_NO_COMPRESSION:0,Z_BEST_SPEED:1,Z_BEST_COMPRESSION:9,Z_DEFAULT_COMPRESSION:-1,Z_FILTERED:1,Z_HUFFMAN_ONLY:2,Z_RLE:3,Z_FIXED:4,Z_DEFAULT_STRATEGY:0,Z_BINARY:0,Z_TEXT:1,Z_UNKNOWN:2,Z_DEFLATED:8},{_tr_init:oG,_tr_stored_block:jJ,_tr_flush_block:nG,_tr_tally:f0,_tr_align:aG}=pG,{Z_NO_FLUSH:b0,Z_PARTIAL_FLUSH:sG,Z_FULL_FLUSH:tG,Z_FINISH:$0,Z_BLOCK:wQ,Z_OK:Q0,Z_STREAM_END:xQ,Z_STREAM_ERROR:B0,Z_DATA_ERROR:eG,Z_BUF_ERROR:GJ,Z_DEFAULT_COMPRESSION:J6,Z_FILTERED:Q6,Z_HUFFMAN_ONLY:z1,Z_RLE:G6,Z_FIXED:q6,Z_DEFAULT_STRATEGY:W6,Z_UNKNOWN:X6,Z_DEFLATED:N1}=Q8,Y6=9,U6=15,V6=8,K6=29,Z6=256,MJ=Z6+1+K6,$6=30,z6=19,H6=2*MJ+1,j6=15,b=3,y0=258,N0=y0+b+1,M6=32,D8=42,IJ=57,PJ=69,CJ=73,DJ=91,OJ=103,a0=113,g8=666,W0=1,N8=2,e0=3,L8=4,P6=3,s0=(J,G)=>{return J.msg=t0[G],G},TQ=(J)=>{return J*2-(J>4?9:0)},E0=(J)=>{let G=J.length;while(--G>=0)J[G]=0},C6=(J)=>{let G,Q,q,W=J.w_size;G=J.hash_size,q=G;do Q=J.head[--q],J.head[q]=Q>=W?Q-W:0;while(--G);G=W,q=G;do Q=J.prev[--q],J.prev[q]=Q>=W?Q-W:0;while(--G)},D6=(J,G,Q)=>(G<<J.hash_shift^Q)&J.hash_mask,h0=D6,V0=(J)=>{const G=J.state;let Q=G.pending;if(Q>J.avail_out)Q=J.avail_out;if(Q===0)return;if(J.output.set(G.pending_buf.subarray(G.pending_out,G.pending_out+Q),J.next_out),J.next_out+=Q,G.pending_out+=Q,J.total_out+=Q,J.avail_out-=Q,G.pending-=Q,G.pending===0)G.pending_out=0},K0=(J,G)=>{nG(J,J.block_start>=0?J.block_start:-1,J.strstart-J.block_start,G),J.block_start=J.strstart,V0(J.strm)},h=(J,G)=>{J.pending_buf[J.pending++]=G},v8=(J,G)=>{J.pending_buf[J.pending++]=G>>>8&255,J.pending_buf[J.pending++]=G&255},BJ=(J,G,Q,q)=>{let W=J.avail_in;if(W>q)W=q;if(W===0)return 0;if(J.avail_in-=W,G.set(J.input.subarray(J.next_in,J.next_in+W),Q),J.state.wrap===1)J.adler=c8(J.adler,G,W,Q);else if(J.state.wrap===2)J.adler=t(J.adler,G,W,Q);return J.next_in+=W,J.total_in+=W,W},N9=(J,G)=>{let{max_chain_length:Q,strstart:q}=J,W,X,U=J.prev_length,V=J.nice_match;const K=J.strstart>J.w_size-N0?J.strstart-(J.w_size-N0):0,Y=J.window,Z=J.w_mask,H=J.prev,$=J.strstart+y0;let z=Y[q+U-1],C=Y[q+U];if(J.prev_length>=J.good_match)Q>>=2;if(V>J.lookahead)V=J.lookahead;do{if(W=G,Y[W+U]!==C||Y[W+U-1]!==z||Y[W]!==Y[q]||Y[++W]!==Y[q+1])continue;q+=2,W++;do;while(Y[++q]===Y[++W]&&Y[++q]===Y[++W]&&Y[++q]===Y[++W]&&Y[++q]===Y[++W]&&Y[++q]===Y[++W]&&Y[++q]===Y[++W]&&Y[++q]===Y[++W]&&Y[++q]===Y[++W]&&q<$);if(X=y0-($-q),q=$-y0,X>U){if(J.match_start=G,U=X,X>=V)break;z=Y[q+U-1],C=Y[q+U]}}while((G=H[G&Z])>K&&--Q!==0);if(U<=J.lookahead)return U;return J.lookahead},O8=(J)=>{const G=J.w_size;let Q,q,W;do{if(q=J.window_size-J.lookahead-J.strstart,J.strstart>=G+(G-N0)){if(J.window.set(J.window.subarray(G,G+G-q),0),J.match_start-=G,J.strstart-=G,J.block_start-=G,J.insert>J.strstart)J.insert=J.strstart;C6(J),q+=G}if(J.strm.avail_in===0)break;if(Q=BJ(J.strm,J.window,J.strstart+J.lookahead,q),J.lookahead+=Q,J.lookahead+J.insert>=b){W=J.strstart-J.insert,J.ins_h=J.window[W],J.ins_h=h0(J,J.ins_h,J.window[W+1]);while(J.insert)if(J.ins_h=h0(J,J.ins_h,J.window[W+b-1]),J.prev[W&J.w_mask]=J.head[J.ins_h],J.head[J.ins_h]=W,W++,J.insert--,J.lookahead+J.insert<b)break}}while(J.lookahead<N0&&J.strm.avail_in!==0)},L9=(J,G)=>{let Q=J.pending_buf_size-5>J.w_size?J.w_size:J.pending_buf_size-5,q,W,X,U=0,V=J.strm.avail_in;do{if(q=65535,X=J.bi_valid+42>>3,J.strm.avail_out<X)break;if(X=J.strm.avail_out-X,W=J.strstart-J.block_start,q>W+J.strm.avail_in)q=W+J.strm.avail_in;if(q>X)q=X;if(q<Q&&(q===0&&G!==$0||G===b0||q!==W+J.strm.avail_in))break;if(U=G===$0&&q===W+J.strm.avail_in?1:0,jJ(J,0,0,U),J.pending_buf[J.pending-4]=q,J.pending_buf[J.pending-3]=q>>8,J.pending_buf[J.pending-2]=~q,J.pending_buf[J.pending-1]=~q>>8,V0(J.strm),W){if(W>q)W=q;J.strm.output.set(J.window.subarray(J.block_start,J.block_start+W),J.strm.next_out),J.strm.next_out+=W,J.strm.avail_out-=W,J.strm.total_out+=W,J.block_start+=W,q-=W}if(q)BJ(J.strm,J.strm.output,J.strm.next_out,q),J.strm.next_out+=q,J.strm.avail_out-=q,J.strm.total_out+=q}while(U===0);if(V-=J.strm.avail_in,V){if(V>=J.w_size)J.matches=2,J.window.set(J.strm.input.subarray(J.strm.next_in-J.w_size,J.strm.next_in),0),J.strstart=J.w_size,J.insert=J.strstart;else{if(J.window_size-J.strstart<=V){if(J.strstart-=J.w_size,J.window.set(J.window.subarray(J.w_size,J.w_size+J.strstart),0),J.matches<2)J.matches++;if(J.insert>J.strstart)J.insert=J.strstart}J.window.set(J.strm.input.subarray(J.strm.next_in-V,J.strm.next_in),J.strstart),J.strstart+=V,J.insert+=V>J.w_size-J.insert?J.w_size-J.insert:V}J.block_start=J.strstart}if(J.high_water<J.strstart)J.high_water=J.strstart;if(U)return L8;if(G!==b0&&G!==$0&&J.strm.avail_in===0&&J.strstart===J.block_start)return N8;if(X=J.window_size-J.strstart,J.strm.avail_in>X&&J.block_start>=J.w_size){if(J.block_start-=J.w_size,J.strstart-=J.w_size,J.window.set(J.window.subarray(J.w_size,J.w_size+J.strstart),0),J.matches<2)J.matches++;if(X+=J.w_size,J.insert>J.strstart)J.insert=J.strstart}if(X>J.strm.avail_in)X=J.strm.avail_in;if(X)BJ(J.strm,J.window,J.strstart,X),J.strstart+=X,J.insert+=X>J.w_size-J.insert?J.w_size-J.insert:X;if(J.high_water<J.strstart)J.high_water=J.strstart;if(X=J.bi_valid+42>>3,X=J.pending_buf_size-X>65535?65535:J.pending_buf_size-X,Q=X>J.w_size?J.w_size:X,W=J.strstart-J.block_start,W>=Q||(W||G===$0)&&G!==b0&&J.strm.avail_in===0&&W<=X)q=W>X?X:W,U=G===$0&&J.strm.avail_in===0&&q===W?1:0,jJ(J,J.block_start,q,U),J.block_start+=q,V0(J.strm);return U?e0:W0},qJ=(J,G)=>{let Q,q;for(;;){if(J.lookahead<N0){if(O8(J),J.lookahead<N0&&G===b0)return W0;if(J.lookahead===0)break}if(Q=0,J.lookahead>=b)J.ins_h=h0(J,J.ins_h,J.window[J.strstart+b-1]),Q=J.prev[J.strstart&J.w_mask]=J.head[J.ins_h],J.head[J.ins_h]=J.strstart;if(Q!==0&&J.strstart-Q<=J.w_size-N0)J.match_length=N9(J,Q);if(J.match_length>=b)if(q=f0(J,J.strstart-J.match_start,J.match_length-b),J.lookahead-=J.match_length,J.match_length<=J.max_lazy_match&&J.lookahead>=b){J.match_length--;do J.strstart++,J.ins_h=h0(J,J.ins_h,J.window[J.strstart+b-1]),Q=J.prev[J.strstart&J.w_mask]=J.head[J.ins_h],J.head[J.ins_h]=J.strstart;while(--J.match_length!==0);J.strstart++}else J.strstart+=J.match_length,J.match_length=0,J.ins_h=J.window[J.strstart],J.ins_h=h0(J,J.ins_h,J.window[J.strstart+1]);else q=f0(J,0,J.window[J.strstart]),J.lookahead--,J.strstart++;if(q){if(K0(J,!1),J.strm.avail_out===0)return W0}}if(J.insert=J.strstart<b-1?J.strstart:b-1,G===$0){if(K0(J,!0),J.strm.avail_out===0)return e0;return L8}if(J.sym_next){if(K0(J,!1),J.strm.avail_out===0)return W0}return N8},M8=(J,G)=>{let Q,q,W;for(;;){if(J.lookahead<N0){if(O8(J),J.lookahead<N0&&G===b0)return W0;if(J.lookahead===0)break}if(Q=0,J.lookahead>=b)J.ins_h=h0(J,J.ins_h,J.window[J.strstart+b-1]),Q=J.prev[J.strstart&J.w_mask]=J.head[J.ins_h],J.head[J.ins_h]=J.strstart;if(J.prev_length=J.match_length,J.prev_match=J.match_start,J.match_length=b-1,Q!==0&&J.prev_length<J.max_lazy_match&&J.strstart-Q<=J.w_size-N0){if(J.match_length=N9(J,Q),J.match_length<=5&&(J.strategy===Q6||J.match_length===b&&J.strstart-J.match_start>4096))J.match_length=b-1}if(J.prev_length>=b&&J.match_length<=J.prev_length){W=J.strstart+J.lookahead-b,q=f0(J,J.strstart-1-J.prev_match,J.prev_length-b),J.lookahead-=J.prev_length-1,J.prev_length-=2;do if(++J.strstart<=W)J.ins_h=h0(J,J.ins_h,J.window[J.strstart+b-1]),Q=J.prev[J.strstart&J.w_mask]=J.head[J.ins_h],J.head[J.ins_h]=J.strstart;while(--J.prev_length!==0);if(J.match_available=0,J.match_length=b-1,J.strstart++,q){if(K0(J,!1),J.strm.avail_out===0)return W0}}else if(J.match_available){if(q=f0(J,0,J.window[J.strstart-1]),q)K0(J,!1);if(J.strstart++,J.lookahead--,J.strm.avail_out===0)return W0}else J.match_available=1,J.strstart++,J.lookahead--}if(J.match_available)q=f0(J,0,J.window[J.strstart-1]),J.match_available=0;if(J.insert=J.strstart<b-1?J.strstart:b-1,G===$0){if(K0(J,!0),J.strm.avail_out===0)return e0;return L8}if(J.sym_next){if(K0(J,!1),J.strm.avail_out===0)return W0}return N8},O6=(J,G)=>{let Q,q,W,X;const U=J.window;for(;;){if(J.lookahead<=y0){if(O8(J),J.lookahead<=y0&&G===b0)return W0;if(J.lookahead===0)break}if(J.match_length=0,J.lookahead>=b&&J.strstart>0){if(W=J.strstart-1,q=U[W],q===U[++W]&&q===U[++W]&&q===U[++W]){X=J.strstart+y0;do;while(q===U[++W]&&q===U[++W]&&q===U[++W]&&q===U[++W]&&q===U[++W]&&q===U[++W]&&q===U[++W]&&q===U[++W]&&W<X);if(J.match_length=y0-(X-W),J.match_length>J.lookahead)J.match_length=J.lookahead}}if(J.match_length>=b)Q=f0(J,1,J.match_length-b),J.lookahead-=J.match_length,J.strstart+=J.match_length,J.match_length=0;else Q=f0(J,0,J.window[J.strstart]),J.lookahead--,J.strstart++;if(Q){if(K0(J,!1),J.strm.avail_out===0)return W0}}if(J.insert=0,G===$0){if(K0(J,!0),J.strm.avail_out===0)return e0;return L8}if(J.sym_next){if(K0(J,!1),J.strm.avail_out===0)return W0}return N8},B6=(J,G)=>{let Q;for(;;){if(J.lookahead===0){if(O8(J),J.lookahead===0){if(G===b0)return W0;break}}if(J.match_length=0,Q=f0(J,0,J.window[J.strstart]),J.lookahead--,J.strstart++,Q){if(K0(J,!1),J.strm.avail_out===0)return W0}}if(J.insert=0,G===$0){if(K0(J,!0),J.strm.avail_out===0)return e0;return L8}if(J.sym_next){if(K0(J,!1),J.strm.avail_out===0)return W0}return N8},E8=[new D0(0,0,0,0,L9),new D0(4,4,8,4,qJ),new D0(4,5,16,8,qJ),new D0(4,6,32,32,qJ),new D0(4,4,16,16,M8),new D0(8,16,32,32,M8),new D0(8,16,128,128,M8),new D0(8,32,128,256,M8),new D0(32,128,258,1024,M8),new D0(32,258,258,4096,M8)],N6=(J)=>{J.window_size=2*J.w_size,E0(J.head),J.max_lazy_match=E8[J.level].max_lazy,J.good_match=E8[J.level].good_length,J.nice_match=E8[J.level].nice_length,J.max_chain_length=E8[J.level].max_chain,J.strstart=0,J.block_start=0,J.lookahead=0,J.insert=0,J.match_length=J.prev_length=b-1,J.match_available=0,J.ins_h=0},r8=(J)=>{if(!J)return 1;const G=J.state;if(!G||G.strm!==J||G.status!==D8&&G.status!==IJ&&G.status!==PJ&&G.status!==CJ&&G.status!==DJ&&G.status!==OJ&&G.status!==a0&&G.status!==g8)return 1;return 0},A9=(J)=>{if(r8(J))return s0(J,B0);J.total_in=J.total_out=0,J.data_type=X6;const G=J.state;if(G.pending=0,G.pending_out=0,G.wrap<0)G.wrap=-G.wrap;return G.status=G.wrap===2?IJ:G.wrap?D8:a0,J.adler=G.wrap===2?0:1,G.last_flush=-2,oG(G),Q0},R9=(J)=>{const G=A9(J);if(G===Q0)N6(J.state);return G},A6=(J,G)=>{if(r8(J)||J.state.wrap!==2)return B0;return J.state.gzhead=G,Q0},I9=(J,G,Q,q,W,X)=>{if(!J)return B0;let U=1;if(G===J6)G=6;if(q<0)U=0,q=-q;else if(q>15)U=2,q-=16;if(W<1||W>Y6||Q!==N1||q<8||q>15||G<0||G>9||X<0||X>q6||q===8&&U!==1)return s0(J,B0);if(q===8)q=9;const V=new L6;return J.state=V,V.strm=J,V.status=D8,V.wrap=U,V.gzhead=null,V.w_bits=q,V.w_size=1<<V.w_bits,V.w_mask=V.w_size-1,V.hash_bits=W+7,V.hash_size=1<<V.hash_bits,V.hash_mask=V.hash_size-1,V.hash_shift=~~((V.hash_bits+b-1)/b),V.window=new Uint8Array(V.w_size*2),V.head=new Uint16Array(V.hash_size),V.prev=new Uint16Array(V.w_size),V.lit_bufsize=1<<W+6,V.pending_buf_size=V.lit_bufsize*4,V.pending_buf=new Uint8Array(V.pending_buf_size),V.sym_buf=V.lit_bufsize,V.sym_end=(V.lit_bufsize-1)*3,V.level=G,V.strategy=X,V.method=Q,R9(J)},R6=(J,G)=>{return I9(J,G,N1,U6,V6,W6)},I6=(J,G)=>{if(r8(J)||G>wQ||G<0)return J?s0(J,B0):B0;const Q=J.state;if(!J.output||J.avail_in!==0&&!J.input||Q.status===g8&&G!==$0)return s0(J,J.avail_out===0?GJ:B0);const q=Q.last_flush;if(Q.last_flush=G,Q.pending!==0){if(V0(J),J.avail_out===0)return Q.last_flush=-1,Q0}else if(J.avail_in===0&&TQ(G)<=TQ(q)&&G!==$0)return s0(J,GJ);if(Q.status===g8&&J.avail_in!==0)return s0(J,GJ);if(Q.status===D8&&Q.wrap===0)Q.status=a0;if(Q.status===D8){let W=N1+(Q.w_bits-8<<4)<<8,X=-1;if(Q.strategy>=z1||Q.level<2)X=0;else if(Q.level<6)X=1;else if(Q.level===6)X=2;else X=3;if(W|=X<<6,Q.strstart!==0)W|=M6;if(W+=31-W%31,v8(Q,W),Q.strstart!==0)v8(Q,J.adler>>>16),v8(Q,J.adler&65535);if(J.adler=1,Q.status=a0,V0(J),Q.pending!==0)return Q.last_flush=-1,Q0}if(Q.status===IJ)if(J.adler=0,h(Q,31),h(Q,139),h(Q,8),!Q.gzhead){if(h(Q,0),h(Q,0),h(Q,0),h(Q,0),h(Q,0),h(Q,Q.level===9?2:Q.strategy>=z1||Q.level<2?4:0),h(Q,P6),Q.status=a0,V0(J),Q.pending!==0)return Q.last_flush=-1,Q0}else{if(h(Q,(Q.gzhead.text?1:0)+(Q.gzhead.hcrc?2:0)+(!Q.gzhead.extra?0:4)+(!Q.gzhead.name?0:8)+(!Q.gzhead.comment?0:16)),h(Q,Q.gzhead.time&255),h(Q,Q.gzhead.time>>8&255),h(Q,Q.gzhead.time>>16&255),h(Q,Q.gzhead.time>>24&255),h(Q,Q.level===9?2:Q.strategy>=z1||Q.level<2?4:0),h(Q,Q.gzhead.os&255),Q.gzhead.extra&&Q.gzhead.extra.length)h(Q,Q.gzhead.extra.length&255),h(Q,Q.gzhead.extra.length>>8&255);if(Q.gzhead.hcrc)J.adler=t(J.adler,Q.pending_buf,Q.pending,0);Q.gzindex=0,Q.status=PJ}if(Q.status===PJ){if(Q.gzhead.extra){let W=Q.pending,X=(Q.gzhead.extra.length&65535)-Q.gzindex;while(Q.pending+X>Q.pending_buf_size){let V=Q.pending_buf_size-Q.pending;if(Q.pending_buf.set(Q.gzhead.extra.subarray(Q.gzindex,Q.gzindex+V),Q.pending),Q.pending=Q.pending_buf_size,Q.gzhead.hcrc&&Q.pending>W)J.adler=t(J.adler,Q.pending_buf,Q.pending-W,W);if(Q.gzindex+=V,V0(J),Q.pending!==0)return Q.last_flush=-1,Q0;W=0,X-=V}let U=new Uint8Array(Q.gzhead.extra);if(Q.pending_buf.set(U.subarray(Q.gzindex,Q.gzindex+X),Q.pending),Q.pending+=X,Q.gzhead.hcrc&&Q.pending>W)J.adler=t(J.adler,Q.pending_buf,Q.pending-W,W);Q.gzindex=0}Q.status=CJ}if(Q.status===CJ){if(Q.gzhead.name){let W=Q.pending,X;do{if(Q.pending===Q.pending_buf_size){if(Q.gzhead.hcrc&&Q.pending>W)J.adler=t(J.adler,Q.pending_buf,Q.pending-W,W);if(V0(J),Q.pending!==0)return Q.last_flush=-1,Q0;W=0}if(Q.gzindex<Q.gzhead.name.length)X=Q.gzhead.name.charCodeAt(Q.gzindex++)&255;else X=0;h(Q,X)}while(X!==0);if(Q.gzhead.hcrc&&Q.pending>W)J.adler=t(J.adler,Q.pending_buf,Q.pending-W,W);Q.gzindex=0}Q.status=DJ}if(Q.status===DJ){if(Q.gzhead.comment){let W=Q.pending,X;do{if(Q.pending===Q.pending_buf_size){if(Q.gzhead.hcrc&&Q.pending>W)J.adler=t(J.adler,Q.pending_buf,Q.pending-W,W);if(V0(J),Q.pending!==0)return Q.last_flush=-1,Q0;W=0}if(Q.gzindex<Q.gzhead.comment.length)X=Q.gzhead.comment.charCodeAt(Q.gzindex++)&255;else X=0;h(Q,X)}while(X!==0);if(Q.gzhead.hcrc&&Q.pending>W)J.adler=t(J.adler,Q.pending_buf,Q.pending-W,W)}Q.status=OJ}if(Q.status===OJ){if(Q.gzhead.hcrc){if(Q.pending+2>Q.pending_buf_size){if(V0(J),Q.pending!==0)return Q.last_flush=-1,Q0}h(Q,J.adler&255),h(Q,J.adler>>8&255),J.adler=0}if(Q.status=a0,V0(J),Q.pending!==0)return Q.last_flush=-1,Q0}if(J.avail_in!==0||Q.lookahead!==0||G!==b0&&Q.status!==g8){let W=Q.level===0?L9(Q,G):Q.strategy===z1?B6(Q,G):Q.strategy===G6?O6(Q,G):E8[Q.level].func(Q,G);if(W===e0||W===L8)Q.status=g8;if(W===W0||W===e0){if(J.avail_out===0)Q.last_flush=-1;return Q0}if(W===N8){if(G===sG)aG(Q);else if(G!==wQ){if(jJ(Q,0,0,!1),G===tG){if(E0(Q.head),Q.lookahead===0)Q.strstart=0,Q.block_start=0,Q.insert=0}}if(V0(J),J.avail_out===0)return Q.last_flush=-1,Q0}}if(G!==$0)return Q0;if(Q.wrap<=0)return xQ;if(Q.wrap===2)h(Q,J.adler&255),h(Q,J.adler>>8&255),h(Q,J.adler>>16&255),h(Q,J.adler>>24&255),h(Q,J.total_in&255),h(Q,J.total_in>>8&255),h(Q,J.total_in>>16&255),h(Q,J.total_in>>24&255);else v8(Q,J.adler>>>16),v8(Q,J.adler&65535);if(V0(J),Q.wrap>0)Q.wrap=-Q.wrap;return Q.pending!==0?Q0:xQ},k6=(J)=>{if(r8(J))return B0;const G=J.state.status;return J.state=null,G===a0?s0(J,eG):Q0},w6=(J,G)=>{let Q=G.length;if(r8(J))return B0;const q=J.state,W=q.wrap;if(W===2||W===1&&q.status!==D8||q.lookahead)return B0;if(W===1)J.adler=c8(J.adler,G,Q,0);if(q.wrap=0,Q>=q.w_size){if(W===0)E0(q.head),q.strstart=0,q.block_start=0,q.insert=0;let K=new Uint8Array(q.w_size);K.set(G.subarray(Q-q.w_size,Q),0),G=K,Q=q.w_size}const{avail_in:X,next_in:U,input:V}=J;J.avail_in=Q,J.next_in=0,J.input=G,O8(q);while(q.lookahead>=b){let K=q.strstart,Y=q.lookahead-(b-1);do q.ins_h=h0(q,q.ins_h,q.window[K+b-1]),q.prev[K&q.w_mask]=q.head[q.ins_h],q.head[q.ins_h]=K,K++;while(--Y);q.strstart=K,q.lookahead=b-1,O8(q)}return q.strstart+=q.lookahead,q.block_start=q.strstart,q.insert=q.lookahead,q.lookahead=0,q.match_length=q.prev_length=b-1,q.match_available=0,J.next_in=U,J.input=V,J.avail_in=X,q.wrap=W,Q0},x6=R6,T6=I9,F6=R9,S6=A9,v6=A6,g6=I6,E6=k6,y6=w6,f6="pako deflate (from Nodeca project)",f8={deflateInit:x6,deflateInit2:T6,deflateReset:F6,deflateResetKeep:S6,deflateSetHeader:v6,deflate:g6,deflateEnd:E6,deflateSetDictionary:y6,deflateInfo:f6},b6=(J,G)=>{return Object.prototype.hasOwnProperty.call(J,G)},h6=function(J){const G=Array.prototype.slice.call(arguments,1);while(G.length){const Q=G.shift();if(!Q)continue;if(typeof Q!=="object")throw new TypeError(Q+"must be non-object");for(let q in Q)if(b6(Q,q))J[q]=Q[q]}return J},u6=(J)=>{let G=0;for(let q=0,W=J.length;q<W;q++)G+=J[q].length;const Q=new Uint8Array(G);for(let q=0,W=0,X=J.length;q<X;q++){let U=J[q];Q.set(U,W),W+=U.length}return Q},L1={assign:h6,flattenChunks:u6},k9=!0;try{String.fromCharCode.apply(null,new Uint8Array(1))}catch(J){k9=!1}var p8=new Uint8Array(256);for(let J=0;J<256;J++)p8[J]=J>=252?6:J>=248?5:J>=240?4:J>=224?3:J>=192?2:1;p8[254]=p8[254]=1;var m6=(J)=>{if(typeof TextEncoder==="function"&&TextEncoder.prototype.encode)return(new TextEncoder()).encode(J);let G,Q,q,W,X,U=J.length,V=0;for(W=0;W<U;W++){if(Q=J.charCodeAt(W),(Q&64512)===55296&&W+1<U){if(q=J.charCodeAt(W+1),(q&64512)===56320)Q=65536+(Q-55296<<10)+(q-56320),W++}V+=Q<128?1:Q<2048?2:Q<65536?3:4}G=new Uint8Array(V);for(X=0,W=0;X<V;W++){if(Q=J.charCodeAt(W),(Q&64512)===55296&&W+1<U){if(q=J.charCodeAt(W+1),(q&64512)===56320)Q=65536+(Q-55296<<10)+(q-56320),W++}if(Q<128)G[X++]=Q;else if(Q<2048)G[X++]=192|Q>>>6,G[X++]=128|Q&63;else if(Q<65536)G[X++]=224|Q>>>12,G[X++]=128|Q>>>6&63,G[X++]=128|Q&63;else G[X++]=240|Q>>>18,G[X++]=128|Q>>>12&63,G[X++]=128|Q>>>6&63,G[X++]=128|Q&63}return G},_6=(J,G)=>{if(G<65534){if(J.subarray&&k9)return String.fromCharCode.apply(null,J.length===G?J:J.subarray(0,G))}let Q="";for(let q=0;q<G;q++)Q+=String.fromCharCode(J[q]);return Q},c6=(J,G)=>{const Q=G||J.length;if(typeof TextDecoder==="function"&&TextDecoder.prototype.decode)return(new TextDecoder()).decode(J.subarray(0,G));let q,W;const X=new Array(Q*2);for(W=0,q=0;q<Q;){let U=J[q++];if(U<128){X[W++]=U;continue}let V=p8[U];if(V>4){X[W++]=65533,q+=V-1;continue}U&=V===2?31:V===3?15:7;while(V>1&&q<Q)U=U<<6|J[q++]&63,V--;if(V>1){X[W++]=65533;continue}if(U<65536)X[W++]=U;else U-=65536,X[W++]=55296|U>>10&1023,X[W++]=56320|U&1023}return _6(X,W)},p6=(J,G)=>{if(G=G||J.length,G>J.length)G=J.length;let Q=G-1;while(Q>=0&&(J[Q]&192)===128)Q--;if(Q<0)return G;if(Q===0)return G;return Q+p8[J[Q]]>G?Q:G},l8={string2buf:m6,buf2string:c6,utf8border:p6},w9=l6,x9=Object.prototype.toString,{Z_NO_FLUSH:d6,Z_SYNC_FLUSH:i6,Z_FULL_FLUSH:r6,Z_FINISH:o6,Z_OK:O1,Z_STREAM_END:n6,Z_DEFAULT_COMPRESSION:a6,Z_DEFAULT_STRATEGY:s6,Z_DEFLATED:t6}=Q8;o8.prototype.push=function(J,G){const Q=this.strm,q=this.options.chunkSize;let W,X;if(this.ended)return!1;if(G===~~G)X=G;else X=G===!0?o6:d6;if(typeof J==="string")Q.input=l8.string2buf(J);else if(x9.call(J)==="[object ArrayBuffer]")Q.input=new Uint8Array(J);else Q.input=J;Q.next_in=0,Q.avail_in=Q.input.length;for(;;){if(Q.avail_out===0)Q.output=new Uint8Array(q),Q.next_out=0,Q.avail_out=q;if((X===i6||X===r6)&&Q.avail_out<=6){this.onData(Q.output.subarray(0,Q.next_out)),Q.avail_out=0;continue}if(W=f8.deflate(Q,X),W===n6){if(Q.next_out>0)this.onData(Q.output.subarray(0,Q.next_out));return W=f8.deflateEnd(this.strm),this.onEnd(W),this.ended=!0,W===O1}if(Q.avail_out===0){this.onData(Q.output);continue}if(X>0&&Q.next_out>0){this.onData(Q.output.subarray(0,Q.next_out)),Q.avail_out=0;continue}if(Q.avail_in===0)break}return!0};o8.prototype.onData=function(J){this.chunks.push(J)};o8.prototype.onEnd=function(J){if(J===O1)this.result=L1.flattenChunks(this.chunks);this.chunks=[],this.err=J,this.msg=this.strm.msg};var Q7=o8,G7=kJ,q7=e6,W7=J7,X7=Q8,Y7={Deflate:Q7,deflate:G7,deflateRaw:q7,gzip:W7,constants:X7},H1=16209,U7=16191,V7=function J(G,Q){let q,W,X,U,V,K,Y,Z,H,$,z,C,j,M,A,R,I,D,T,x,L,k,E,w;const S=G.state;q=G.next_in,E=G.input,W=q+(G.avail_in-5),X=G.next_out,w=G.output,U=X-(Q-G.avail_out),V=X+(G.avail_out-257),K=S.dmax,Y=S.wsize,Z=S.whave,H=S.wnext,$=S.window,z=S.hold,C=S.bits,j=S.lencode,M=S.distcode,A=(1<<S.lenbits)-1,R=(1<<S.distbits)-1;J:do{if(C<15)z+=E[q++]<<C,C+=8,z+=E[q++]<<C,C+=8;I=j[z&A];Q:for(;;){if(D=I>>>24,z>>>=D,C-=D,D=I>>>16&255,D===0)w[X++]=I&65535;else if(D&16){if(T=I&65535,D&=15,D){if(C<D)z+=E[q++]<<C,C+=8;T+=z&(1<<D)-1,z>>>=D,C-=D}if(C<15)z+=E[q++]<<C,C+=8,z+=E[q++]<<C,C+=8;I=M[z&R];G:for(;;){if(D=I>>>24,z>>>=D,C-=D,D=I>>>16&255,D&16){if(x=I&65535,D&=15,C<D){if(z+=E[q++]<<C,C+=8,C<D)z+=E[q++]<<C,C+=8}if(x+=z&(1<<D)-1,x>K){G.msg="invalid distance too far back",S.mode=H1;break J}if(z>>>=D,C-=D,D=X-U,x>D){if(D=x-D,D>Z){if(S.sane){G.msg="invalid distance too far back",S.mode=H1;break J}}if(L=0,k=$,H===0){if(L+=Y-D,D<T){T-=D;do w[X++]=$[L++];while(--D);L=X-x,k=w}}else if(H<D){if(L+=Y+H-D,D-=H,D<T){T-=D;do w[X++]=$[L++];while(--D);if(L=0,H<T){D=H,T-=D;do w[X++]=$[L++];while(--D);L=X-x,k=w}}}else if(L+=H-D,D<T){T-=D;do w[X++]=$[L++];while(--D);L=X-x,k=w}while(T>2)w[X++]=k[L++],w[X++]=k[L++],w[X++]=k[L++],T-=3;if(T){if(w[X++]=k[L++],T>1)w[X++]=k[L++]}}else{L=X-x;do w[X++]=w[L++],w[X++]=w[L++],w[X++]=w[L++],T-=3;while(T>2);if(T){if(w[X++]=w[L++],T>1)w[X++]=w[L++]}}}else if((D&64)===0){I=M[(I&65535)+(z&(1<<D)-1)];continue G}else{G.msg="invalid distance code",S.mode=H1;break J}break}}else if((D&64)===0){I=j[(I&65535)+(z&(1<<D)-1)];continue Q}else if(D&32){S.mode=U7;break J}else{G.msg="invalid literal/length code",S.mode=H1;break J}break}}while(q<W&&X<V);T=C>>3,q-=T,C-=T<<3,z&=(1<<C)-1,G.next_in=q,G.next_out=X,G.avail_in=q<W?5+(W-q):5-(q-W),G.avail_out=X<V?257+(V-X):257-(X-V),S.hold=z,S.bits=C;return},P8=15,FQ=852,SQ=592,vQ=0,WJ=1,gQ=2,K7=new Uint16Array([3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,0,0]),Z7=new Uint8Array([16,16,16,16,16,16,16,16,17,17,17,17,18,18,18,18,19,19,19,19,20,20,20,20,21,21,21,21,16,72,78]),$7=new Uint16Array([1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,0,0]),z7=new Uint8Array([16,16,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,64,64]),H7=(J,G,Q,q,W,X,U,V)=>{const K=V.bits;let Y=0,Z=0,H=0,$=0,z=0,C=0,j=0,M=0,A=0,R=0,I,D,T,x,L,k=null,E;const w=new Uint16Array(P8+1),S=new Uint16Array(P8+1);let B=null,F,P,N;for(Y=0;Y<=P8;Y++)w[Y]=0;for(Z=0;Z<q;Z++)w[G[Q+Z]]++;z=K;for($=P8;$>=1;$--)if(w[$]!==0)break;if(z>$)z=$;if($===0)return W[X++]=1<<24|64<<16|0,W[X++]=1<<24|64<<16|0,V.bits=1,0;for(H=1;H<$;H++)if(w[H]!==0)break;if(z<H)z=H;M=1;for(Y=1;Y<=P8;Y++)if(M<<=1,M-=w[Y],M<0)return-1;if(M>0&&(J===vQ||$!==1))return-1;S[1]=0;for(Y=1;Y<P8;Y++)S[Y+1]=S[Y]+w[Y];for(Z=0;Z<q;Z++)if(G[Q+Z]!==0)U[S[G[Q+Z]]++]=Z;if(J===vQ)k=B=U,E=20;else if(J===WJ)k=K7,B=Z7,E=257;else k=$7,B=z7,E=0;if(R=0,Z=0,Y=H,L=X,C=z,j=0,T=-1,A=1<<z,x=A-1,J===WJ&&A>FQ||J===gQ&&A>SQ)return 1;for(;;){if(F=Y-j,U[Z]+1<E)P=0,N=U[Z];else if(U[Z]>=E)P=B[U[Z]-E],N=k[U[Z]-E];else P=96,N=0;I=1<<Y-j,D=1<<C,H=D;do D-=I,W[L+(R>>j)+D]=F<<24|P<<16|N|0;while(D!==0);I=1<<Y-1;while(R&I)I>>=1;if(I!==0)R&=I-1,R+=I;else R=0;if(Z++,--w[Y]===0){if(Y===$)break;Y=G[Q+U[Z]]}if(Y>z&&(R&x)!==T){if(j===0)j=z;L+=H,C=Y-j,M=1<<C;while(C+j<$){if(M-=w[C+j],M<=0)break;C++,M<<=1}if(A+=1<<C,J===WJ&&A>FQ||J===gQ&&A>SQ)return 1;T=R&x,W[T]=z<<24|C<<16|L-X|0}}if(R!==0)W[L+R]=Y-j<<24|64<<16|0;return V.bits=z,0},b8=H7,j7=0,T9=1,F9=2,{Z_FINISH:EQ,Z_BLOCK:M7,Z_TREES:j1,Z_OK:J8,Z_STREAM_END:P7,Z_NEED_DICT:C7,Z_STREAM_ERROR:z0,Z_DATA_ERROR:S9,Z_MEM_ERROR:v9,Z_BUF_ERROR:D7,Z_DEFLATED:yQ}=Q8,A1=16180,fQ=16181,bQ=16182,hQ=16183,uQ=16184,mQ=16185,_Q=16186,cQ=16187,pQ=16188,lQ=16189,B1=16190,k0=16191,XJ=16192,dQ=16193,YJ=16194,iQ=16195,rQ=16196,oQ=16197,nQ=16198,M1=16199,P1=16200,aQ=16201,sQ=16202,tQ=16203,eQ=16204,J9=16205,UJ=16206,Q9=16207,G9=16208,p=16209,g9=16210,E9=16211,O7=852,B7=592,N7=15,L7=N7,q9=(J)=>{return(J>>>24&255)+(J>>>8&65280)+((J&65280)<<8)+((J&255)<<24)},G8=(J)=>{if(!J)return 1;const G=J.state;if(!G||G.strm!==J||G.mode<A1||G.mode>E9)return 1;return 0},y9=(J)=>{if(G8(J))return z0;const G=J.state;if(J.total_in=J.total_out=G.total=0,J.msg="",G.wrap)J.adler=G.wrap&1;return G.mode=A1,G.last=0,G.havedict=0,G.flags=-1,G.dmax=32768,G.head=null,G.hold=0,G.bits=0,G.lencode=G.lendyn=new Int32Array(O7),G.distcode=G.distdyn=new Int32Array(B7),G.sane=1,G.back=-1,J8},f9=(J)=>{if(G8(J))return z0;const G=J.state;return G.wsize=0,G.whave=0,G.wnext=0,y9(J)},b9=(J,G)=>{let Q;if(G8(J))return z0;const q=J.state;if(G<0)Q=0,G=-G;else if(Q=(G>>4)+5,G<48)G&=15;if(G&&(G<8||G>15))return z0;if(q.window!==null&&q.wbits!==G)q.window=null;return q.wrap=Q,q.wbits=G,f9(J)},h9=(J,G)=>{if(!J)return z0;const Q=new A7;J.state=Q,Q.strm=J,Q.window=null,Q.mode=A1;const q=b9(J,G);if(q!==J8)J.state=null;return q},R7=(J)=>{return h9(J,L7)},W9=!0,VJ,KJ,I7=(J)=>{if(W9){VJ=new Int32Array(512),KJ=new Int32Array(32);let G=0;while(G<144)J.lens[G++]=8;while(G<256)J.lens[G++]=9;while(G<280)J.lens[G++]=7;while(G<288)J.lens[G++]=8;b8(T9,J.lens,0,288,VJ,0,J.work,{bits:9}),G=0;while(G<32)J.lens[G++]=5;b8(F9,J.lens,0,32,KJ,0,J.work,{bits:5}),W9=!1}J.lencode=VJ,J.lenbits=9,J.distcode=KJ,J.distbits=5},u9=(J,G,Q,q)=>{let W;const X=J.state;if(X.window===null)X.wsize=1<<X.wbits,X.wnext=0,X.whave=0,X.window=new Uint8Array(X.wsize);if(q>=X.wsize)X.window.set(G.subarray(Q-X.wsize,Q),0),X.wnext=0,X.whave=X.wsize;else{if(W=X.wsize-X.wnext,W>q)W=q;if(X.window.set(G.subarray(Q-q,Q-q+W),X.wnext),q-=W,q)X.window.set(G.subarray(Q-q,Q),0),X.wnext=q,X.whave=X.wsize;else{if(X.wnext+=W,X.wnext===X.wsize)X.wnext=0;if(X.whave<X.wsize)X.whave+=W}}return 0},k7=(J,G)=>{let Q,q,W,X,U,V,K,Y,Z,H,$,z,C,j,M=0,A,R,I,D,T,x,L,k;const E=new Uint8Array(4);let w,S;const B=new Uint8Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]);if(G8(J)||!J.output||!J.input&&J.avail_in!==0)return z0;if(Q=J.state,Q.mode===k0)Q.mode=XJ;U=J.next_out,W=J.output,K=J.avail_out,X=J.next_in,q=J.input,V=J.avail_in,Y=Q.hold,Z=Q.bits,H=V,$=K,k=J8;J:for(;;)switch(Q.mode){case A1:if(Q.wrap===0){Q.mode=XJ;break}while(Z<16){if(V===0)break J;V--,Y+=q[X++]<<Z,Z+=8}if(Q.wrap&2&&Y===35615){if(Q.wbits===0)Q.wbits=15;Q.check=0,E[0]=Y&255,E[1]=Y>>>8&255,Q.check=t(Q.check,E,2,0),Y=0,Z=0,Q.mode=fQ;break}if(Q.head)Q.head.done=!1;if(!(Q.wrap&1)||(((Y&255)<<8)+(Y>>8))%31){J.msg="incorrect header check",Q.mode=p;break}if((Y&15)!==yQ){J.msg="unknown compression method",Q.mode=p;break}if(Y>>>=4,Z-=4,L=(Y&15)+8,Q.wbits===0)Q.wbits=L;if(L>15||L>Q.wbits){J.msg="invalid window size",Q.mode=p;break}Q.dmax=1<<Q.wbits,Q.flags=0,J.adler=Q.check=1,Q.mode=Y&512?lQ:k0,Y=0,Z=0;break;case fQ:while(Z<16){if(V===0)break J;V--,Y+=q[X++]<<Z,Z+=8}if(Q.flags=Y,(Q.flags&255)!==yQ){J.msg="unknown compression method",Q.mode=p;break}if(Q.flags&57344){J.msg="unknown header flags set",Q.mode=p;break}if(Q.head)Q.head.text=Y>>8&1;if(Q.flags&512&&Q.wrap&4)E[0]=Y&255,E[1]=Y>>>8&255,Q.check=t(Q.check,E,2,0);Y=0,Z=0,Q.mode=bQ;case bQ:while(Z<32){if(V===0)break J;V--,Y+=q[X++]<<Z,Z+=8}if(Q.head)Q.head.time=Y;if(Q.flags&512&&Q.wrap&4)E[0]=Y&255,E[1]=Y>>>8&255,E[2]=Y>>>16&255,E[3]=Y>>>24&255,Q.check=t(Q.check,E,4,0);Y=0,Z=0,Q.mode=hQ;case hQ:while(Z<16){if(V===0)break J;V--,Y+=q[X++]<<Z,Z+=8}if(Q.head)Q.head.xflags=Y&255,Q.head.os=Y>>8;if(Q.flags&512&&Q.wrap&4)E[0]=Y&255,E[1]=Y>>>8&255,Q.check=t(Q.check,E,2,0);Y=0,Z=0,Q.mode=uQ;case uQ:if(Q.flags&1024){while(Z<16){if(V===0)break J;V--,Y+=q[X++]<<Z,Z+=8}if(Q.length=Y,Q.head)Q.head.extra_len=Y;if(Q.flags&512&&Q.wrap&4)E[0]=Y&255,E[1]=Y>>>8&255,Q.check=t(Q.check,E,2,0);Y=0,Z=0}else if(Q.head)Q.head.extra=null;Q.mode=mQ;case mQ:if(Q.flags&1024){if(z=Q.length,z>V)z=V;if(z){if(Q.head){if(L=Q.head.extra_len-Q.length,!Q.head.extra)Q.head.extra=new Uint8Array(Q.head.extra_len);Q.head.extra.set(q.subarray(X,X+z),L)}if(Q.flags&512&&Q.wrap&4)Q.check=t(Q.check,q,z,X);V-=z,X+=z,Q.length-=z}if(Q.length)break J}Q.length=0,Q.mode=_Q;case _Q:if(Q.flags&2048){if(V===0)break J;z=0;do if(L=q[X+z++],Q.head&&L&&Q.length<65536)Q.head.name+=String.fromCharCode(L);while(L&&z<V);if(Q.flags&512&&Q.wrap&4)Q.check=t(Q.check,q,z,X);if(V-=z,X+=z,L)break J}else if(Q.head)Q.head.name=null;Q.length=0,Q.mode=cQ;case cQ:if(Q.flags&4096){if(V===0)break J;z=0;do if(L=q[X+z++],Q.head&&L&&Q.length<65536)Q.head.comment+=String.fromCharCode(L);while(L&&z<V);if(Q.flags&512&&Q.wrap&4)Q.check=t(Q.check,q,z,X);if(V-=z,X+=z,L)break J}else if(Q.head)Q.head.comment=null;Q.mode=pQ;case pQ:if(Q.flags&512){while(Z<16){if(V===0)break J;V--,Y+=q[X++]<<Z,Z+=8}if(Q.wrap&4&&Y!==(Q.check&65535)){J.msg="header crc mismatch",Q.mode=p;break}Y=0,Z=0}if(Q.head)Q.head.hcrc=Q.flags>>9&1,Q.head.done=!0;J.adler=Q.check=0,Q.mode=k0;break;case lQ:while(Z<32){if(V===0)break J;V--,Y+=q[X++]<<Z,Z+=8}J.adler=Q.check=q9(Y),Y=0,Z=0,Q.mode=B1;case B1:if(Q.havedict===0)return J.next_out=U,J.avail_out=K,J.next_in=X,J.avail_in=V,Q.hold=Y,Q.bits=Z,C7;J.adler=Q.check=1,Q.mode=k0;case k0:if(G===M7||G===j1)break J;case XJ:if(Q.last){Y>>>=Z&7,Z-=Z&7,Q.mode=UJ;break}while(Z<3){if(V===0)break J;V--,Y+=q[X++]<<Z,Z+=8}switch(Q.last=Y&1,Y>>>=1,Z-=1,Y&3){case 0:Q.mode=dQ;break;case 1:if(I7(Q),Q.mode=M1,G===j1){Y>>>=2,Z-=2;break J}break;case 2:Q.mode=rQ;break;case 3:J.msg="invalid block type",Q.mode=p}Y>>>=2,Z-=2;break;case dQ:Y>>>=Z&7,Z-=Z&7;while(Z<32){if(V===0)break J;V--,Y+=q[X++]<<Z,Z+=8}if((Y&65535)!==(Y>>>16^65535)){J.msg="invalid stored block lengths",Q.mode=p;break}if(Q.length=Y&65535,Y=0,Z=0,Q.mode=YJ,G===j1)break J;case YJ:Q.mode=iQ;case iQ:if(z=Q.length,z){if(z>V)z=V;if(z>K)z=K;if(z===0)break J;W.set(q.subarray(X,X+z),U),V-=z,X+=z,K-=z,U+=z,Q.length-=z;break}Q.mode=k0;break;case rQ:while(Z<14){if(V===0)break J;V--,Y+=q[X++]<<Z,Z+=8}if(Q.nlen=(Y&31)+257,Y>>>=5,Z-=5,Q.ndist=(Y&31)+1,Y>>>=5,Z-=5,Q.ncode=(Y&15)+4,Y>>>=4,Z-=4,Q.nlen>286||Q.ndist>30){J.msg="too many length or distance symbols",Q.mode=p;break}Q.have=0,Q.mode=oQ;case oQ:while(Q.have<Q.ncode){while(Z<3){if(V===0)break J;V--,Y+=q[X++]<<Z,Z+=8}Q.lens[B[Q.have++]]=Y&7,Y>>>=3,Z-=3}while(Q.have<19)Q.lens[B[Q.have++]]=0;if(Q.lencode=Q.lendyn,Q.lenbits=7,w={bits:Q.lenbits},k=b8(j7,Q.lens,0,19,Q.lencode,0,Q.work,w),Q.lenbits=w.bits,k){J.msg="invalid code lengths set",Q.mode=p;break}Q.have=0,Q.mode=nQ;case nQ:while(Q.have<Q.nlen+Q.ndist){for(;;){if(M=Q.lencode[Y&(1<<Q.lenbits)-1],A=M>>>24,R=M>>>16&255,I=M&65535,A<=Z)break;if(V===0)break J;V--,Y+=q[X++]<<Z,Z+=8}if(I<16)Y>>>=A,Z-=A,Q.lens[Q.have++]=I;else{if(I===16){S=A+2;while(Z<S){if(V===0)break J;V--,Y+=q[X++]<<Z,Z+=8}if(Y>>>=A,Z-=A,Q.have===0){J.msg="invalid bit length repeat",Q.mode=p;break}L=Q.lens[Q.have-1],z=3+(Y&3),Y>>>=2,Z-=2}else if(I===17){S=A+3;while(Z<S){if(V===0)break J;V--,Y+=q[X++]<<Z,Z+=8}Y>>>=A,Z-=A,L=0,z=3+(Y&7),Y>>>=3,Z-=3}else{S=A+7;while(Z<S){if(V===0)break J;V--,Y+=q[X++]<<Z,Z+=8}Y>>>=A,Z-=A,L=0,z=11+(Y&127),Y>>>=7,Z-=7}if(Q.have+z>Q.nlen+Q.ndist){J.msg="invalid bit length repeat",Q.mode=p;break}while(z--)Q.lens[Q.have++]=L}}if(Q.mode===p)break;if(Q.lens[256]===0){J.msg="invalid code -- missing end-of-block",Q.mode=p;break}if(Q.lenbits=9,w={bits:Q.lenbits},k=b8(T9,Q.lens,0,Q.nlen,Q.lencode,0,Q.work,w),Q.lenbits=w.bits,k){J.msg="invalid literal/lengths set",Q.mode=p;break}if(Q.distbits=6,Q.distcode=Q.distdyn,w={bits:Q.distbits},k=b8(F9,Q.lens,Q.nlen,Q.ndist,Q.distcode,0,Q.work,w),Q.distbits=w.bits,k){J.msg="invalid distances set",Q.mode=p;break}if(Q.mode=M1,G===j1)break J;case M1:Q.mode=P1;case P1:if(V>=6&&K>=258){if(J.next_out=U,J.avail_out=K,J.next_in=X,J.avail_in=V,Q.hold=Y,Q.bits=Z,V7(J,$),U=J.next_out,W=J.output,K=J.avail_out,X=J.next_in,q=J.input,V=J.avail_in,Y=Q.hold,Z=Q.bits,Q.mode===k0)Q.back=-1;break}Q.back=0;for(;;){if(M=Q.lencode[Y&(1<<Q.lenbits)-1],A=M>>>24,R=M>>>16&255,I=M&65535,A<=Z)break;if(V===0)break J;V--,Y+=q[X++]<<Z,Z+=8}if(R&&(R&240)===0){D=A,T=R,x=I;for(;;){if(M=Q.lencode[x+((Y&(1<<D+T)-1)>>D)],A=M>>>24,R=M>>>16&255,I=M&65535,D+A<=Z)break;if(V===0)break J;V--,Y+=q[X++]<<Z,Z+=8}Y>>>=D,Z-=D,Q.back+=D}if(Y>>>=A,Z-=A,Q.back+=A,Q.length=I,R===0){Q.mode=J9;break}if(R&32){Q.back=-1,Q.mode=k0;break}if(R&64){J.msg="invalid literal/length code",Q.mode=p;break}Q.extra=R&15,Q.mode=aQ;case aQ:if(Q.extra){S=Q.extra;while(Z<S){if(V===0)break J;V--,Y+=q[X++]<<Z,Z+=8}Q.length+=Y&(1<<Q.extra)-1,Y>>>=Q.extra,Z-=Q.extra,Q.back+=Q.extra}Q.was=Q.length,Q.mode=sQ;case sQ:for(;;){if(M=Q.distcode[Y&(1<<Q.distbits)-1],A=M>>>24,R=M>>>16&255,I=M&65535,A<=Z)break;if(V===0)break J;V--,Y+=q[X++]<<Z,Z+=8}if((R&240)===0){D=A,T=R,x=I;for(;;){if(M=Q.distcode[x+((Y&(1<<D+T)-1)>>D)],A=M>>>24,R=M>>>16&255,I=M&65535,D+A<=Z)break;if(V===0)break J;V--,Y+=q[X++]<<Z,Z+=8}Y>>>=D,Z-=D,Q.back+=D}if(Y>>>=A,Z-=A,Q.back+=A,R&64){J.msg="invalid distance code",Q.mode=p;break}Q.offset=I,Q.extra=R&15,Q.mode=tQ;case tQ:if(Q.extra){S=Q.extra;while(Z<S){if(V===0)break J;V--,Y+=q[X++]<<Z,Z+=8}Q.offset+=Y&(1<<Q.extra)-1,Y>>>=Q.extra,Z-=Q.extra,Q.back+=Q.extra}if(Q.offset>Q.dmax){J.msg="invalid distance too far back",Q.mode=p;break}Q.mode=eQ;case eQ:if(K===0)break J;if(z=$-K,Q.offset>z){if(z=Q.offset-z,z>Q.whave){if(Q.sane){J.msg="invalid distance too far back",Q.mode=p;break}}if(z>Q.wnext)z-=Q.wnext,C=Q.wsize-z;else C=Q.wnext-z;if(z>Q.length)z=Q.length;j=Q.window}else j=W,C=U-Q.offset,z=Q.length;if(z>K)z=K;K-=z,Q.length-=z;do W[U++]=j[C++];while(--z);if(Q.length===0)Q.mode=P1;break;case J9:if(K===0)break J;W[U++]=Q.length,K--,Q.mode=P1;break;case UJ:if(Q.wrap){while(Z<32){if(V===0)break J;V--,Y|=q[X++]<<Z,Z+=8}if($-=K,J.total_out+=$,Q.total+=$,Q.wrap&4&&$)J.adler=Q.check=Q.flags?t(Q.check,W,$,U-$):c8(Q.check,W,$,U-$);if($=K,Q.wrap&4&&(Q.flags?Y:q9(Y))!==Q.check){J.msg="incorrect data check",Q.mode=p;break}Y=0,Z=0}Q.mode=Q9;case Q9:if(Q.wrap&&Q.flags){while(Z<32){if(V===0)break J;V--,Y+=q[X++]<<Z,Z+=8}if(Q.wrap&4&&Y!==(Q.total&4294967295)){J.msg="incorrect length check",Q.mode=p;break}Y=0,Z=0}Q.mode=G9;case G9:k=P7;break J;case p:k=S9;break J;case g9:return v9;case E9:default:return z0}if(J.next_out=U,J.avail_out=K,J.next_in=X,J.avail_in=V,Q.hold=Y,Q.bits=Z,Q.wsize||$!==J.avail_out&&Q.mode<p&&(Q.mode<UJ||G!==EQ)){if(u9(J,J.output,J.next_out,$-J.avail_out));}if(H-=J.avail_in,$-=J.avail_out,J.total_in+=H,J.total_out+=$,Q.total+=$,Q.wrap&4&&$)J.adler=Q.check=Q.flags?t(Q.check,W,$,J.next_out-$):c8(Q.check,W,$,J.next_out-$);if(J.data_type=Q.bits+(Q.last?64:0)+(Q.mode===k0?128:0)+(Q.mode===M1||Q.mode===YJ?256:0),(H===0&&$===0||G===EQ)&&k===J8)k=D7;return k},w7=(J)=>{if(G8(J))return z0;let G=J.state;if(G.window)G.window=null;return J.state=null,J8},x7=(J,G)=>{if(G8(J))return z0;const Q=J.state;if((Q.wrap&2)===0)return z0;return Q.head=G,G.done=!1,J8},T7=(J,G)=>{const Q=G.length;let q,W,X;if(G8(J))return z0;if(q=J.state,q.wrap!==0&&q.mode!==B1)return z0;if(q.mode===B1){if(W=1,W=c8(W,G,Q,0),W!==q.check)return S9}if(X=u9(J,G,Q,Q),X)return q.mode=g9,v9;return q.havedict=1,J8},F7=f9,S7=b9,v7=y9,g7=R7,E7=h9,y7=k7,f7=w7,b7=x7,h7=T7,u7="pako inflate (from Nodeca project)",x0={inflateReset:F7,inflateReset2:S7,inflateResetKeep:v7,inflateInit:g7,inflateInit2:E7,inflate:y7,inflateEnd:f7,inflateGetHeader:b7,inflateSetDictionary:h7,inflateInfo:u7},_7=m7,m9=Object.prototype.toString,{Z_NO_FLUSH:c7,Z_FINISH:p7,Z_OK:d8,Z_STREAM_END:ZJ,Z_NEED_DICT:$J,Z_STREAM_ERROR:l7,Z_DATA_ERROR:X9,Z_MEM_ERROR:d7}=Q8;n8.prototype.push=function(J,G){const Q=this.strm,q=this.options.chunkSize,W=this.options.dictionary;let X,U,V;if(this.ended)return!1;if(G===~~G)U=G;else U=G===!0?p7:c7;if(m9.call(J)==="[object ArrayBuffer]")Q.input=new Uint8Array(J);else Q.input=J;Q.next_in=0,Q.avail_in=Q.input.length;for(;;){if(Q.avail_out===0)Q.output=new Uint8Array(q),Q.next_out=0,Q.avail_out=q;if(X=x0.inflate(Q,U),X===$J&&W){if(X=x0.inflateSetDictionary(Q,W),X===d8)X=x0.inflate(Q,U);else if(X===X9)X=$J}while(Q.avail_in>0&&X===ZJ&&Q.state.wrap>0&&J[Q.next_in]!==0)x0.inflateReset(Q),X=x0.inflate(Q,U);switch(X){case l7:case X9:case $J:case d7:return this.onEnd(X),this.ended=!0,!1}if(V=Q.avail_out,Q.next_out){if(Q.avail_out===0||X===ZJ)if(this.options.to==="string"){let K=l8.utf8border(Q.output,Q.next_out),Y=Q.next_out-K,Z=l8.buf2string(Q.output,K);if(Q.next_out=Y,Q.avail_out=q-Y,Y)Q.output.set(Q.output.subarray(K,K+Y),0);this.onData(Z)}else this.onData(Q.output.length===Q.next_out?Q.output:Q.output.subarray(0,Q.next_out))}if(X===d8&&V===0)continue;if(X===ZJ)return X=x0.inflateEnd(this.strm),this.onEnd(X),this.ended=!0,!0;if(Q.avail_in===0)break}return!0};n8.prototype.onData=function(J){this.chunks.push(J)};n8.prototype.onEnd=function(J){if(J===d8)if(this.options.to==="string")this.result=this.chunks.join("");else this.result=L1.flattenChunks(this.chunks);this.chunks=[],this.err=J,this.msg=this.strm.msg};var r7=n8,o7=wJ,n7=i7,a7=wJ,s7=Q8,t7={Inflate:r7,inflate:o7,inflateRaw:n7,ungzip:a7,constants:s7},{Deflate:e7,deflate:Jq,deflateRaw:Qq,gzip:Gq}=Y7,{Inflate:qq,inflate:Wq,inflateRaw:Xq,ungzip:Yq}=t7,Uq=e7,Vq=Jq,Kq=Qq,Zq=Gq,$q=qq,zq=Wq,Hq=Xq,jq=Yq,Mq=Q8,xJ={Deflate:Uq,deflate:Vq,deflateRaw:Kq,gzip:Zq,Inflate:$q,inflate:zq,inflateRaw:Hq,ungzip:jq,constants:Mq};var _9=function(J){if(!Number.isSafeInteger(J)||J<0)throw new Error("positive integer expected, got "+J)},Pq=function(J){return J instanceof Uint8Array||ArrayBuffer.isView(J)&&J.constructor.name==="Uint8Array"},A8=function(J,...G){if(!Pq(J))throw new Error("Uint8Array expected");if(G.length>0&&!G.includes(J.length))throw new Error("Uint8Array expected of length "+G+", got length="+J.length)},c9=function(J){if(typeof J!=="function"||typeof J.create!=="function")throw new Error("Hash should be wrapped by utils.wrapConstructor");_9(J.outputLen),_9(J.blockLen)},R8=function(J,G=!0){if(J.destroyed)throw new Error("Hash instance has been destroyed");if(G&&J.finished)throw new Error("Hash#digest() has already been called")},p9=function(J,G){A8(J);const Q=G.outputLen;if(J.length<Q)throw new Error("digestInto() expects output buffer of length at least "+Q)};var q8=typeof globalThis==="object"&&("crypto"in globalThis)?globalThis.crypto:void 0;function R1(J){return new DataView(J.buffer,J.byteOffset,J.byteLength)}function M0(J,G){return J<<32-G|J>>>G}function Cq(J){if(typeof J!=="string")throw new Error("utf8ToBytes expected string, got "+typeof J);return new Uint8Array((new TextEncoder()).encode(J))}function a8(J){if(typeof J==="string")J=Cq(J);return A8(J),J}function l9(...J){let G=0;for(let q=0;q<J.length;q++){const W=J[q];A8(W),G+=W.length}const Q=new Uint8Array(G);for(let q=0,W=0;q<J.length;q++){const X=J[q];Q.set(X,W),W+=X.length}return Q}function d9(J){const G=(q)=>J().update(a8(q)).digest(),Q=J();return G.outputLen=Q.outputLen,G.blockLen=Q.blockLen,G.create=()=>J(),G}function I1(J=32){if(q8&&typeof q8.getRandomValues==="function")return q8.getRandomValues(new Uint8Array(J));if(q8&&typeof q8.randomBytes==="function")return q8.randomBytes(J);throw new Error("crypto.getRandomValues must be defined")}/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */class s8{clone(){return this._cloneInto()}}function Dq(J,G,Q,q){if(typeof J.setBigUint64==="function")return J.setBigUint64(G,Q,q);const W=BigInt(32),X=BigInt(4294967295),U=Number(Q>>W&X),V=Number(Q&X),K=q?4:0,Y=q?0:4;J.setUint32(G+K,U,q),J.setUint32(G+Y,V,q)}function i9(J,G,Q){return J&G^~J&Q}function r9(J,G,Q){return J&G^J&Q^G&Q}class TJ extends s8{constructor(J,G,Q,q){super();this.blockLen=J,this.outputLen=G,this.padOffset=Q,this.isLE=q,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(J),this.view=R1(this.buffer)}update(J){R8(this);const{view:G,buffer:Q,blockLen:q}=this;J=a8(J);const W=J.length;for(let X=0;X<W;){const U=Math.min(q-this.pos,W-X);if(U===q){const V=R1(J);for(;q<=W-X;X+=q)this.process(V,X);continue}if(Q.set(J.subarray(X,X+U),this.pos),this.pos+=U,X+=U,this.pos===q)this.process(G,0),this.pos=0}return this.length+=J.length,this.roundClean(),this}digestInto(J){R8(this),p9(J,this),this.finished=!0;const{buffer:G,view:Q,blockLen:q,isLE:W}=this;let{pos:X}=this;if(G[X++]=128,this.buffer.subarray(X).fill(0),this.padOffset>q-X)this.process(Q,0),X=0;for(let Z=X;Z<q;Z++)G[Z]=0;Dq(Q,q-8,BigInt(this.length*8),W),this.process(Q,0);const U=R1(J),V=this.outputLen;if(V%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const K=V/4,Y=this.get();if(K>Y.length)throw new Error("_sha2: outputLen bigger than state");for(let Z=0;Z<K;Z++)U.setUint32(4*Z,Y[Z],W)}digest(){const{buffer:J,outputLen:G}=this;this.digestInto(J);const Q=J.slice(0,G);return this.destroy(),Q}_cloneInto(J){J||(J=new this.constructor),J.set(...this.get());const{blockLen:G,buffer:Q,length:q,finished:W,destroyed:X,pos:U}=this;if(J.length=q,J.pos=U,J.finished=W,J.destroyed=X,q%G)J.buffer.set(Q);return J}}var Oq=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),u0=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),m0=new Uint32Array(64);class o9 extends TJ{constructor(){super(64,32,8,!1);this.A=u0[0]|0,this.B=u0[1]|0,this.C=u0[2]|0,this.D=u0[3]|0,this.E=u0[4]|0,this.F=u0[5]|0,this.G=u0[6]|0,this.H=u0[7]|0}get(){const{A:J,B:G,C:Q,D:q,E:W,F:X,G:U,H:V}=this;return[J,G,Q,q,W,X,U,V]}set(J,G,Q,q,W,X,U,V){this.A=J|0,this.B=G|0,this.C=Q|0,this.D=q|0,this.E=W|0,this.F=X|0,this.G=U|0,this.H=V|0}process(J,G){for(let Z=0;Z<16;Z++,G+=4)m0[Z]=J.getUint32(G,!1);for(let Z=16;Z<64;Z++){const H=m0[Z-15],$=m0[Z-2],z=M0(H,7)^M0(H,18)^H>>>3,C=M0($,17)^M0($,19)^$>>>10;m0[Z]=C+m0[Z-7]+z+m0[Z-16]|0}let{A:Q,B:q,C:W,D:X,E:U,F:V,G:K,H:Y}=this;for(let Z=0;Z<64;Z++){const H=M0(U,6)^M0(U,11)^M0(U,25),$=Y+H+i9(U,V,K)+Oq[Z]+m0[Z]|0,C=(M0(Q,2)^M0(Q,13)^M0(Q,22))+r9(Q,q,W)|0;Y=K,K=V,V=U,U=X+$|0,X=W,W=q,q=Q,Q=$+C|0}Q=Q+this.A|0,q=q+this.B|0,W=W+this.C|0,X=X+this.D|0,U=U+this.E|0,V=V+this.F|0,K=K+this.G|0,Y=Y+this.H|0,this.set(Q,q,W,X,U,V,K,Y)}roundClean(){m0.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}}var k1=d9(()=>new o9);class FJ extends s8{constructor(J,G){super();this.finished=!1,this.destroyed=!1,c9(J);const Q=a8(G);if(this.iHash=J.create(),typeof this.iHash.update!=="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const q=this.blockLen,W=new Uint8Array(q);W.set(Q.length>q?J.create().update(Q).digest():Q);for(let X=0;X<W.length;X++)W[X]^=54;this.iHash.update(W),this.oHash=J.create();for(let X=0;X<W.length;X++)W[X]^=54^92;this.oHash.update(W),W.fill(0)}update(J){return R8(this),this.iHash.update(J),this}digestInto(J){R8(this),A8(J,this.outputLen),this.finished=!0,this.iHash.digestInto(J),this.oHash.update(J),this.oHash.digestInto(J),this.destroy()}digest(){const J=new Uint8Array(this.oHash.outputLen);return this.digestInto(J),J}_cloneInto(J){J||(J=Object.create(Object.getPrototypeOf(this),{}));const{oHash:G,iHash:Q,finished:q,destroyed:W,blockLen:X,outputLen:U}=this;return J=J,J.finished=q,J.destroyed=W,J.blockLen=X,J.outputLen=U,J.oHash=G._cloneInto(J.oHash),J.iHash=Q._cloneInto(J.iHash),J}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}var SJ=(J,G,Q)=>new FJ(J,G).update(Q).digest();SJ.create=(J,G)=>new FJ(J,G);var bJ={};a5(bJ,{validateObject:()=>{{return p0}},utf8ToBytes:()=>{{return Rq}},numberToVarBytesBE:()=>{{return Lq}},numberToHexUnpadded:()=>{{return Y8}},numberToBytesLE:()=>{{return F1}},numberToBytesBE:()=>{{return P0}},notImplemented:()=>{{return xq}},memoized:()=>{{return S1}},isBytes:()=>{{return _0}},inRange:()=>{{return c0}},hexToNumber:()=>{{return EJ}},hexToBytes:()=>{{return U8}},equalBytes:()=>{{return Aq}},ensureBytes:()=>{{return n}},createHmacDrbg:()=>{{return fJ}},concatBytes:()=>{{return F0}},bytesToNumberLE:()=>{{return T1}},bytesToNumberBE:()=>{{return H0}},bytesToHex:()=>{{return X8}},bitSet:()=>{{return kq}},bitMask:()=>{{return t8}},bitLen:()=>{{return yJ}},bitGet:()=>{{return Iq}},abytes:()=>{{return I8}},abool:()=>{{return W8}},aInRange:()=>{{return L0}}});function _0(J){return J instanceof Uint8Array||ArrayBuffer.isView(J)&&J.constructor.name==="Uint8Array"}function I8(J){if(!_0(J))throw new Error("Uint8Array expected")}function W8(J,G){if(typeof G!=="boolean")throw new Error(J+" boolean expected, got "+G)}function X8(J){I8(J);let G="";for(let Q=0;Q<J.length;Q++)G+=Nq[J[Q]];return G}function Y8(J){const G=J.toString(16);return G.length&1?"0"+G:G}function EJ(J){if(typeof J!=="string")throw new Error("hex string expected, got "+typeof J);return J===""?w1:BigInt("0x"+J)}var n9=function(J){if(J>=T0._0&&J<=T0._9)return J-T0._0;if(J>=T0.A&&J<=T0.F)return J-(T0.A-10);if(J>=T0.a&&J<=T0.f)return J-(T0.a-10);return};function U8(J){if(typeof J!=="string")throw new Error("hex string expected, got "+typeof J);const G=J.length,Q=G/2;if(G%2)throw new Error("hex string expected, got unpadded hex of length "+G);const q=new Uint8Array(Q);for(let W=0,X=0;W<Q;W++,X+=2){const U=n9(J.charCodeAt(X)),V=n9(J.charCodeAt(X+1));if(U===void 0||V===void 0){const K=J[X]+J[X+1];throw new Error('hex string expected, got non-hex character "'+K+'" at index '+X)}q[W]=U*16+V}return q}function H0(J){return EJ(X8(J))}function T1(J){return I8(J),EJ(X8(Uint8Array.from(J).reverse()))}function P0(J,G){return U8(J.toString(16).padStart(G*2,"0"))}function F1(J,G){return P0(J,G).reverse()}function Lq(J){return U8(Y8(J))}function n(J,G,Q){let q;if(typeof G==="string")try{q=U8(G)}catch(X){throw new Error(J+" must be hex string or Uint8Array, cause: "+X)}else if(_0(G))q=Uint8Array.from(G);else throw new Error(J+" must be hex string or Uint8Array");const W=q.length;if(typeof Q==="number"&&W!==Q)throw new Error(J+" of length "+Q+" expected, got "+W);return q}function F0(...J){let G=0;for(let q=0;q<J.length;q++){const W=J[q];I8(W),G+=W.length}const Q=new Uint8Array(G);for(let q=0,W=0;q<J.length;q++){const X=J[q];Q.set(X,W),W+=X.length}return Q}function Aq(J,G){if(J.length!==G.length)return!1;let Q=0;for(let q=0;q<J.length;q++)Q|=J[q]^G[q];return Q===0}function Rq(J){if(typeof J!=="string")throw new Error("string expected");return new Uint8Array((new TextEncoder()).encode(J))}function c0(J,G,Q){return vJ(J)&&vJ(G)&&vJ(Q)&&G<=J&&J<Q}function L0(J,G,Q,q){if(!c0(G,Q,q))throw new Error("expected valid "+J+": "+Q+" <= n < "+q+", got "+G)}function yJ(J){let G;for(G=0;J>w1;J>>=x1,G+=1);return G}function Iq(J,G){return J>>BigInt(G)&x1}function kq(J,G,Q){return J|(Q?x1:w1)<<BigInt(G)}function fJ(J,G,Q){if(typeof J!=="number"||J<2)throw new Error("hashLen must be a number");if(typeof G!=="number"||G<2)throw new Error("qByteLen must be a number");if(typeof Q!=="function")throw new Error("hmacFn must be a function");let q=gJ(J),W=gJ(J),X=0;const U=()=>{q.fill(1),W.fill(0),X=0},V=(...H)=>Q(W,q,...H),K=(H=gJ())=>{if(W=V(a9([0]),H),q=V(),H.length===0)return;W=V(a9([1]),H),q=V()},Y=()=>{if(X++>=1000)throw new Error("drbg: tried 1000 values");let H=0;const $=[];while(H<G){q=V();const z=q.slice();$.push(z),H+=q.length}return F0(...$)};return(H,$)=>{U(),K(H);let z=void 0;while(!(z=$(Y())))K();return U(),z}}function p0(J,G,Q={}){const q=(W,X,U)=>{const V=wq[X];if(typeof V!=="function")throw new Error("invalid validator function");const K=J[W];if(U&&K===void 0)return;if(!V(K,J))throw new Error("param "+String(W)+" is invalid. Expected "+X+", got "+K)};for(let[W,X]of Object.entries(G))q(W,X,!1);for(let[W,X]of Object.entries(Q))q(W,X,!0);return J}function S1(J){const G=new WeakMap;return(Q,...q)=>{const W=G.get(Q);if(W!==void 0)return W;const X=J(Q,...q);return G.set(Q,X),X}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */var w1=BigInt(0),x1=BigInt(1),Bq=BigInt(2),Nq=Array.from({length:256},(J,G)=>G.toString(16).padStart(2,"0")),T0={_0:48,_9:57,A:65,F:70,a:97,f:102},vJ=(J)=>typeof J==="bigint"&&w1<=J,t8=(J)=>(Bq<<BigInt(J-1))-x1,gJ=(J)=>new Uint8Array(J),a9=(J)=>Uint8Array.from(J),wq={bigint:(J)=>typeof J==="bigint",function:(J)=>typeof J==="function",boolean:(J)=>typeof J==="boolean",string:(J)=>typeof J==="string",stringOrUint8Array:(J)=>typeof J==="string"||_0(J),isSafeInteger:(J)=>Number.isSafeInteger(J),array:(J)=>Array.isArray(J),field:(J,G)=>G.Fp.isValid(J),hash:(J)=>typeof J==="function"&&Number.isSafeInteger(J.outputLen)},xq=()=>{throw new Error("not implemented")};function a(J,G){const Q=J%G;return Q>=s?Q:G+Q}function vq(J,G,Q){if(G<s)throw new Error("invalid exponent, negatives unsupported");if(Q<=s)throw new Error("invalid modulus");if(Q===d)return s;let q=d;while(G>s){if(G&d)q=q*J%Q;J=J*J%Q,G>>=d}return q}function Z0(J,G,Q){let q=J;while(G-- >s)q*=q,q%=Q;return q}function v1(J,G){if(J===s)throw new Error("invert: expected non-zero number");if(G<=s)throw new Error("invert: expected positive modulus, got "+G);let Q=a(J,G),q=G,W=s,X=d,U=d,V=s;while(Q!==s){const Y=q/Q,Z=q%Q,H=W-U*Y,$=X-V*Y;q=Q,Q=Z,W=U,X=V,U=H,V=$}if(q!==d)throw new Error("invert: does not exist");return a(W,G)}function gq(J){const G=(J-d)/V8;let Q,q,W;for(Q=J-d,q=0;Q%V8===s;Q/=V8,q++);for(W=V8;W<J&&vq(W,G,J)!==J-d;W++)if(W>1000)throw new Error("Cannot find square root: likely non-prime P");if(q===1){const U=(J+d)/hJ;return function V(K,Y){const Z=K.pow(Y,U);if(!K.eql(K.sqr(Z),Y))throw new Error("Cannot find square root");return Z}}const X=(Q+d)/V8;return function U(V,K){if(V.pow(K,G)===V.neg(V.ONE))throw new Error("Cannot find square root");let Y=q,Z=V.pow(V.mul(V.ONE,W),Q),H=V.pow(K,X),$=V.pow(K,Q);while(!V.eql($,V.ONE)){if(V.eql($,V.ZERO))return V.ZERO;let z=1;for(let j=V.sqr($);z<Y;z++){if(V.eql(j,V.ONE))break;j=V.sqr(j)}const C=V.pow(Z,d<<BigInt(Y-z-1));Z=V.sqr(C),H=V.mul(H,C),$=V.mul($,Z),Y=z}return H}}function Eq(J){if(J%hJ===Tq){const G=(J+d)/hJ;return function Q(q,W){const X=q.pow(W,G);if(!q.eql(q.sqr(X),W))throw new Error("Cannot find square root");return X}}if(J%t9===s9){const G=(J-s9)/t9;return function Q(q,W){const X=q.mul(W,V8),U=q.pow(X,G),V=q.mul(W,U),K=q.mul(q.mul(V,V8),U),Y=q.mul(V,q.sub(K,q.ONE));if(!q.eql(q.sqr(Y),W))throw new Error("Cannot find square root");return Y}}if(J%Sq===Fq);return gq(J)}function uJ(J){const G={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},Q=yq.reduce((q,W)=>{return q[W]="function",q},G);return p0(J,Q)}function fq(J,G,Q){if(Q<s)throw new Error("invalid exponent, negatives unsupported");if(Q===s)return J.ONE;if(Q===d)return G;let q=J.ONE,W=G;while(Q>s){if(Q&d)q=J.mul(q,W);W=J.sqr(W),Q>>=d}return q}function bq(J,G){const Q=new Array(G.length),q=G.reduce((X,U,V)=>{if(J.is0(U))return X;return Q[V]=X,J.mul(X,U)},J.ONE),W=J.inv(q);return G.reduceRight((X,U,V)=>{if(J.is0(U))return X;return Q[V]=J.mul(X,Q[V]),J.mul(X,U)},W),Q}function mJ(J,G){const Q=G!==void 0?G:J.toString(2).length,q=Math.ceil(Q/8);return{nBitLength:Q,nByteLength:q}}function g1(J,G,Q=!1,q={}){if(J<=s)throw new Error("invalid field: expected ORDER > 0, got "+J);const{nBitLength:W,nByteLength:X}=mJ(J,G);if(X>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let U;const V=Object.freeze({ORDER:J,isLE:Q,BITS:W,BYTES:X,MASK:t8(W),ZERO:s,ONE:d,create:(K)=>a(K,J),isValid:(K)=>{if(typeof K!=="bigint")throw new Error("invalid field element: expected bigint, got "+typeof K);return s<=K&&K<J},is0:(K)=>K===s,isOdd:(K)=>(K&d)===d,neg:(K)=>a(-K,J),eql:(K,Y)=>K===Y,sqr:(K)=>a(K*K,J),add:(K,Y)=>a(K+Y,J),sub:(K,Y)=>a(K-Y,J),mul:(K,Y)=>a(K*Y,J),pow:(K,Y)=>fq(V,K,Y),div:(K,Y)=>a(K*v1(Y,J),J),sqrN:(K)=>K*K,addN:(K,Y)=>K+Y,subN:(K,Y)=>K-Y,mulN:(K,Y)=>K*Y,inv:(K)=>v1(K,J),sqrt:q.sqrt||((K)=>{if(!U)U=Eq(J);return U(V,K)}),invertBatch:(K)=>bq(V,K),cmov:(K,Y,Z)=>Z?Y:K,toBytes:(K)=>Q?F1(K,X):P0(K,X),fromBytes:(K)=>{if(K.length!==X)throw new Error("Field.fromBytes: expected "+X+" bytes, got "+K.length);return Q?T1(K):H0(K)}});return Object.freeze(V)}function e9(J){if(typeof J!=="bigint")throw new Error("field order must be bigint");const G=J.toString(2).length;return Math.ceil(G/8)}function _J(J){const G=e9(J);return G+Math.ceil(G/2)}function J5(J,G,Q=!1){const q=J.length,W=e9(G),X=_J(G);if(q<16||q<X||q>1024)throw new Error("expected "+X+"-1024 bytes of input, got "+q);const U=Q?T1(J):H0(J),V=a(U,G-d)+d;return Q?F1(V,W):P0(V,W)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */var s=BigInt(0),d=BigInt(1),V8=BigInt(2),Tq=BigInt(3),hJ=BigInt(4),s9=BigInt(5),t9=BigInt(8),Fq=BigInt(9),Sq=BigInt(16);var yq=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];var cJ=function(J,G){const Q=G.negate();return J?Q:G},G5=function(J,G){if(!Number.isSafeInteger(J)||J<=0||J>G)throw new Error("invalid window size, expected [1.."+G+"], got W="+J)},pJ=function(J,G){G5(J,G);const Q=Math.ceil(G/J)+1,q=2**(J-1);return{windows:Q,windowSize:q}},hq=function(J,G){if(!Array.isArray(J))throw new Error("array expected");J.forEach((Q,q)=>{if(!(Q instanceof G))throw new Error("invalid point at index "+q)})},uq=function(J,G){if(!Array.isArray(J))throw new Error("array of scalars expected");J.forEach((Q,q)=>{if(!G.isValid(Q))throw new Error("invalid scalar at index "+q)})},dJ=function(J){return q5.get(J)||1};function W5(J,G){return{constTimeNegate:cJ,hasPrecomputes(Q){return dJ(Q)!==1},unsafeLadder(Q,q,W=J.ZERO){let X=Q;while(q>Q5){if(q&E1)W=W.add(X);X=X.double(),q>>=E1}return W},precomputeWindow(Q,q){const{windows:W,windowSize:X}=pJ(q,G),U=[];let V=Q,K=V;for(let Y=0;Y<W;Y++){K=V,U.push(K);for(let Z=1;Z<X;Z++)K=K.add(V),U.push(K);V=K.double()}return U},wNAF(Q,q,W){const{windows:X,windowSize:U}=pJ(Q,G);let{ZERO:V,BASE:K}=J;const Y=BigInt(2**Q-1),Z=2**Q,H=BigInt(Q);for(let $=0;$<X;$++){const z=$*U;let C=Number(W&Y);if(W>>=H,C>U)C-=Z,W+=E1;const j=z,M=z+Math.abs(C)-1,A=$%2!==0,R=C<0;if(C===0)K=K.add(cJ(A,q[j]));else V=V.add(cJ(R,q[M]))}return{p:V,f:K}},wNAFUnsafe(Q,q,W,X=J.ZERO){const{windows:U,windowSize:V}=pJ(Q,G),K=BigInt(2**Q-1),Y=2**Q,Z=BigInt(Q);for(let H=0;H<U;H++){const $=H*V;if(W===Q5)break;let z=Number(W&K);if(W>>=Z,z>V)z-=Y,W+=E1;if(z===0)continue;let C=q[$+Math.abs(z)-1];if(z<0)C=C.negate();X=X.add(C)}return X},getPrecomputes(Q,q,W){let X=lJ.get(q);if(!X){if(X=this.precomputeWindow(q,Q),Q!==1)lJ.set(q,W(X))}return X},wNAFCached(Q,q,W){const X=dJ(Q);return this.wNAF(X,this.getPrecomputes(X,Q,W),q)},wNAFCachedUnsafe(Q,q,W,X){const U=dJ(Q);if(U===1)return this.unsafeLadder(Q,q,X);return this.wNAFUnsafe(U,this.getPrecomputes(U,Q,W),q,X)},setWindowSize(Q,q){G5(q,G),q5.set(Q,q),lJ.delete(Q)}}}function X5(J,G,Q,q){if(hq(Q,J),uq(q,G),Q.length!==q.length)throw new Error("arrays of points and scalars must have equal length");const W=J.ZERO,X=yJ(BigInt(Q.length)),U=X>12?X-3:X>4?X-2:X?2:1,V=(1<<U)-1,K=new Array(V+1).fill(W),Y=Math.floor((G.BITS-1)/U)*U;let Z=W;for(let H=Y;H>=0;H-=U){K.fill(W);for(let z=0;z<q.length;z++){const C=q[z],j=Number(C>>BigInt(H)&BigInt(V));K[j]=K[j].add(Q[z])}let $=W;for(let z=K.length-1,C=W;z>0;z--)C=C.add(K[z]),$=$.add(C);if(Z=Z.add($),H!==0)for(let z=0;z<U;z++)Z=Z.double()}return Z}function iJ(J){return uJ(J.Fp),p0(J,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...mJ(J.n,J.nBitLength),...J,...{p:J.Fp.ORDER}})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */var Q5=BigInt(0),E1=BigInt(1),lJ=new WeakMap,q5=new WeakMap;var Y5=function(J){if(J.lowS!==void 0)W8("lowS",J.lowS);if(J.prehash!==void 0)W8("prehash",J.prehash)},mq=function(J){const G=iJ(J);p0(G,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});const{endo:Q,Fp:q,a:W}=G;if(Q){if(!q.eql(W,q.ZERO))throw new Error("invalid endomorphism, can only be defined for Koblitz curves that have a=0");if(typeof Q!=="object"||typeof Q.beta!=="bigint"||typeof Q.splitScalar!=="function")throw new Error("invalid endomorphism, expected beta: bigint and splitScalar: function")}return Object.freeze({...G})};function pq(J){const G=mq(J),{Fp:Q}=G,q=g1(G.n,G.nBitLength),W=G.toBytes||((j,M,A)=>{const R=M.toAffine();return F0(Uint8Array.from([4]),Q.toBytes(R.x),Q.toBytes(R.y))}),X=G.fromBytes||((j)=>{const M=j.subarray(1),A=Q.fromBytes(M.subarray(0,Q.BYTES)),R=Q.fromBytes(M.subarray(Q.BYTES,2*Q.BYTES));return{x:A,y:R}});function U(j){const{a:M,b:A}=G,R=Q.sqr(j),I=Q.mul(R,j);return Q.add(Q.add(I,Q.mul(j,M)),A)}if(!Q.eql(Q.sqr(G.Gy),U(G.Gx)))throw new Error("bad generator point: equation left != right");function V(j){return c0(j,e,G.n)}function K(j){const{allowedPrivateKeyLengths:M,nByteLength:A,wrapPrivateKey:R,n:I}=G;if(M&&typeof j!=="bigint"){if(_0(j))j=X8(j);if(typeof j!=="string"||!M.includes(j.length))throw new Error("invalid private key");j=j.padStart(A*2,"0")}let D;try{D=typeof j==="bigint"?j:H0(n("private key",j,A))}catch(T){throw new Error("invalid private key, expected hex or "+A+" bytes, got "+typeof j)}if(R)D=a(D,I);return L0("private key",D,e,I),D}function Y(j){if(!(j instanceof $))throw new Error("ProjectivePoint expected")}const Z=S1((j,M)=>{const{px:A,py:R,pz:I}=j;if(Q.eql(I,Q.ONE))return{x:A,y:R};const D=j.is0();if(M==null)M=D?Q.ONE:Q.inv(I);const T=Q.mul(A,M),x=Q.mul(R,M),L=Q.mul(I,M);if(D)return{x:Q.ZERO,y:Q.ZERO};if(!Q.eql(L,Q.ONE))throw new Error("invZ was invalid");return{x:T,y:x}}),H=S1((j)=>{if(j.is0()){if(G.allowInfinityPoint&&!Q.is0(j.py))return;throw new Error("bad point: ZERO")}const{x:M,y:A}=j.toAffine();if(!Q.isValid(M)||!Q.isValid(A))throw new Error("bad point: x or y not FE");const R=Q.sqr(A),I=U(M);if(!Q.eql(R,I))throw new Error("bad point: equation left != right");if(!j.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});class ${constructor(j,M,A){if(this.px=j,this.py=M,this.pz=A,j==null||!Q.isValid(j))throw new Error("x required");if(M==null||!Q.isValid(M))throw new Error("y required");if(A==null||!Q.isValid(A))throw new Error("z required");Object.freeze(this)}static fromAffine(j){const{x:M,y:A}=j||{};if(!j||!Q.isValid(M)||!Q.isValid(A))throw new Error("invalid affine point");if(j instanceof $)throw new Error("projective point not allowed");const R=(I)=>Q.eql(I,Q.ZERO);if(R(M)&&R(A))return $.ZERO;return new $(M,A,Q.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(j){const M=Q.invertBatch(j.map((A)=>A.pz));return j.map((A,R)=>A.toAffine(M[R])).map($.fromAffine)}static fromHex(j){const M=$.fromAffine(X(n("pointHex",j)));return M.assertValidity(),M}static fromPrivateKey(j){return $.BASE.multiply(K(j))}static msm(j,M){return X5($,q,j,M)}_setWindowSize(j){C.setWindowSize(this,j)}assertValidity(){H(this)}hasEvenY(){const{y:j}=this.toAffine();if(Q.isOdd)return!Q.isOdd(j);throw new Error("Field doesn't support isOdd")}equals(j){Y(j);const{px:M,py:A,pz:R}=this,{px:I,py:D,pz:T}=j,x=Q.eql(Q.mul(M,T),Q.mul(I,R)),L=Q.eql(Q.mul(A,T),Q.mul(D,R));return x&&L}negate(){return new $(this.px,Q.neg(this.py),this.pz)}double(){const{a:j,b:M}=G,A=Q.mul(M,U5),{px:R,py:I,pz:D}=this;let{ZERO:T,ZERO:x,ZERO:L}=Q,k=Q.mul(R,R),E=Q.mul(I,I),w=Q.mul(D,D),S=Q.mul(R,I);return S=Q.add(S,S),L=Q.mul(R,D),L=Q.add(L,L),T=Q.mul(j,L),x=Q.mul(A,w),x=Q.add(T,x),T=Q.sub(E,x),x=Q.add(E,x),x=Q.mul(T,x),T=Q.mul(S,T),L=Q.mul(A,L),w=Q.mul(j,w),S=Q.sub(k,w),S=Q.mul(j,S),S=Q.add(S,L),L=Q.add(k,k),k=Q.add(L,k),k=Q.add(k,w),k=Q.mul(k,S),x=Q.add(x,k),w=Q.mul(I,D),w=Q.add(w,w),k=Q.mul(w,S),T=Q.sub(T,k),L=Q.mul(w,E),L=Q.add(L,L),L=Q.add(L,L),new $(T,x,L)}add(j){Y(j);const{px:M,py:A,pz:R}=this,{px:I,py:D,pz:T}=j;let{ZERO:x,ZERO:L,ZERO:k}=Q;const E=G.a,w=Q.mul(G.b,U5);let S=Q.mul(M,I),B=Q.mul(A,D),F=Q.mul(R,T),P=Q.add(M,A),N=Q.add(I,D);P=Q.mul(P,N),N=Q.add(S,B),P=Q.sub(P,N),N=Q.add(M,R);let O=Q.add(I,T);return N=Q.mul(N,O),O=Q.add(S,F),N=Q.sub(N,O),O=Q.add(A,R),x=Q.add(D,T),O=Q.mul(O,x),x=Q.add(B,F),O=Q.sub(O,x),k=Q.mul(E,N),x=Q.mul(w,F),k=Q.add(x,k),x=Q.sub(B,k),k=Q.add(B,k),L=Q.mul(x,k),B=Q.add(S,S),B=Q.add(B,S),F=Q.mul(E,F),N=Q.mul(w,N),B=Q.add(B,F),F=Q.sub(S,F),F=Q.mul(E,F),N=Q.add(N,F),S=Q.mul(B,N),L=Q.add(L,S),S=Q.mul(O,N),x=Q.mul(P,x),x=Q.sub(x,S),S=Q.mul(P,B),k=Q.mul(O,k),k=Q.add(k,S),new $(x,L,k)}subtract(j){return this.add(j.negate())}is0(){return this.equals($.ZERO)}wNAF(j){return C.wNAFCached(this,j,$.normalizeZ)}multiplyUnsafe(j){const{endo:M,n:A}=G;L0("scalar",j,v0,A);const R=$.ZERO;if(j===v0)return R;if(this.is0()||j===e)return this;if(!M||C.hasPrecomputes(this))return C.wNAFCachedUnsafe(this,j,$.normalizeZ);let{k1neg:I,k1:D,k2neg:T,k2:x}=M.splitScalar(j),L=R,k=R,E=this;while(D>v0||x>v0){if(D&e)L=L.add(E);if(x&e)k=k.add(E);E=E.double(),D>>=e,x>>=e}if(I)L=L.negate();if(T)k=k.negate();return k=new $(Q.mul(k.px,M.beta),k.py,k.pz),L.add(k)}multiply(j){const{endo:M,n:A}=G;L0("scalar",j,e,A);let R,I;if(M){const{k1neg:D,k1:T,k2neg:x,k2:L}=M.splitScalar(j);let{p:k,f:E}=this.wNAF(T),{p:w,f:S}=this.wNAF(L);k=C.constTimeNegate(D,k),w=C.constTimeNegate(x,w),w=new $(Q.mul(w.px,M.beta),w.py,w.pz),R=k.add(w),I=E.add(S)}else{const{p:D,f:T}=this.wNAF(j);R=D,I=T}return $.normalizeZ([R,I])[0]}multiplyAndAddUnsafe(j,M,A){const R=$.BASE,I=(T,x)=>x===v0||x===e||!T.equals(R)?T.multiplyUnsafe(x):T.multiply(x),D=I(this,M).add(I(j,A));return D.is0()?void 0:D}toAffine(j){return Z(this,j)}isTorsionFree(){const{h:j,isTorsionFree:M}=G;if(j===e)return!0;if(M)return M($,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:j,clearCofactor:M}=G;if(j===e)return this;if(M)return M($,this);return this.multiplyUnsafe(G.h)}toRawBytes(j=!0){return W8("isCompressed",j),this.assertValidity(),W($,this,j)}toHex(j=!0){return W8("isCompressed",j),X8(this.toRawBytes(j))}}$.BASE=new $(G.Gx,G.Gy,Q.ONE),$.ZERO=new $(Q.ZERO,Q.ONE,Q.ZERO);const z=G.nBitLength,C=W5($,G.endo?Math.ceil(z/2):z);return{CURVE:G,ProjectivePoint:$,normPrivateKeyToScalar:K,weierstrassEquation:U,isWithinCurveOrder:V}}var lq=function(J){const G=iJ(J);return p0(G,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...G})};function K5(J){const G=lq(J),{Fp:Q,n:q}=G,W=Q.BYTES+1,X=2*Q.BYTES+1;function U(P){return a(P,q)}function V(P){return v1(P,q)}const{ProjectivePoint:K,normPrivateKeyToScalar:Y,weierstrassEquation:Z,isWithinCurveOrder:H}=pq({...G,toBytes(P,N,O){const v=N.toAffine(),g=Q.toBytes(v.x),y=F0;if(W8("isCompressed",O),O)return y(Uint8Array.from([N.hasEvenY()?2:3]),g);else return y(Uint8Array.from([4]),g,Q.toBytes(v.y))},fromBytes(P){const N=P.length,O=P[0],v=P.subarray(1);if(N===W&&(O===2||O===3)){const g=H0(v);if(!c0(g,e,Q.ORDER))throw new Error("Point is not on curve");const y=Z(g);let m;try{m=Q.sqrt(y)}catch(r){const u=r instanceof Error?": "+r.message:"";throw new Error("Point is not on curve"+u)}const c=(m&e)===e;if((O&1)===1!==c)m=Q.neg(m);return{x:g,y:m}}else if(N===X&&O===4){const g=Q.fromBytes(v.subarray(0,Q.BYTES)),y=Q.fromBytes(v.subarray(Q.BYTES,2*Q.BYTES));return{x:g,y}}else{const g=W,y=X;throw new Error("invalid Point, expected length of "+g+", or uncompressed "+y+", got "+N)}}}),$=(P)=>X8(P0(P,G.nByteLength));function z(P){const N=q>>e;return P>N}function C(P){return z(P)?U(-P):P}const j=(P,N,O)=>H0(P.slice(N,O));class M{constructor(P,N,O){this.r=P,this.s=N,this.recovery=O,this.assertValidity()}static fromCompact(P){const N=G.nByteLength;return P=n("compactSignature",P,N*2),new M(j(P,0,N),j(P,N,2*N))}static fromDER(P){const{r:N,s:O}=S0.toSig(n("DER",P));return new M(N,O)}assertValidity(){L0("r",this.r,e,q),L0("s",this.s,e,q)}addRecoveryBit(P){return new M(this.r,this.s,P)}recoverPublicKey(P){const{r:N,s:O,recovery:v}=this,g=x(n("msgHash",P));if(v==null||![0,1,2,3].includes(v))throw new Error("recovery id invalid");const y=v===2||v===3?N+G.n:N;if(y>=Q.ORDER)throw new Error("recovery id 2 or 3 invalid");const m=(v&1)===0?"02":"03",c=K.fromHex(m+$(y)),f=V(y),r=U(-g*f),u=U(O*f),i=K.BASE.multiplyAndAddUnsafe(c,r,u);if(!i)throw new Error("point at infinify");return i.assertValidity(),i}hasHighS(){return z(this.s)}normalizeS(){return this.hasHighS()?new M(this.r,U(-this.s),this.recovery):this}toDERRawBytes(){return U8(this.toDERHex())}toDERHex(){return S0.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return U8(this.toCompactHex())}toCompactHex(){return $(this.r)+$(this.s)}}const A={isValidPrivateKey(P){try{return Y(P),!0}catch(N){return!1}},normPrivateKeyToScalar:Y,randomPrivateKey:()=>{const P=_J(G.n);return J5(G.randomBytes(P),G.n)},precompute(P=8,N=K.BASE){return N._setWindowSize(P),N.multiply(BigInt(3)),N}};function R(P,N=!0){return K.fromPrivateKey(P).toRawBytes(N)}function I(P){const N=_0(P),O=typeof P==="string",v=(N||O)&&P.length;if(N)return v===W||v===X;if(O)return v===2*W||v===2*X;if(P instanceof K)return!0;return!1}function D(P,N,O=!0){if(I(P))throw new Error("first arg must be private key");if(!I(N))throw new Error("second arg must be public key");return K.fromHex(N).multiply(Y(P)).toRawBytes(O)}const T=G.bits2int||function(P){if(P.length>8192)throw new Error("input is too large");const N=H0(P),O=P.length*8-G.nBitLength;return O>0?N>>BigInt(O):N},x=G.bits2int_modN||function(P){return U(T(P))},L=t8(G.nBitLength);function k(P){return L0("num < 2^"+G.nBitLength,P,v0,L),P0(P,G.nByteLength)}function E(P,N,O=w){if(["recovered","canonical"].some((G0)=>(G0 in O)))throw new Error("sign() legacy options not supported");const{hash:v,randomBytes:g}=G;let{lowS:y,prehash:m,extraEntropy:c}=O;if(y==null)y=!0;if(P=n("msgHash",P),Y5(O),m)P=n("prehashed msgHash",v(P));const f=x(P),r=Y(N),u=[k(r),k(f)];if(c!=null&&c!==!1){const G0=c===!0?g(Q.BYTES):c;u.push(n("extraEntropy",G0))}const i=F0(...u),_=f;function l(G0){const o=T(G0);if(!H(o))return;const Y0=V(o),U0=K.BASE.multiply(o).toAffine(),J0=U(U0.x);if(J0===v0)return;const i0=U(Y0*U(_+J0*r));if(i0===v0)return;let I0=(U0.x===J0?0:2)|Number(U0.y&e),zQ=i0;if(y&&z(i0))zQ=C(i0),I0^=1;return new M(J0,zQ,I0)}return{seed:i,k2sig:l}}const w={lowS:G.lowS,prehash:!1},S={lowS:G.lowS,prehash:!1};function B(P,N,O=w){const{seed:v,k2sig:g}=E(P,N,O),y=G;return fJ(y.hash.outputLen,y.nByteLength,y.hmac)(v,g)}K.BASE._setWindowSize(8);function F(P,N,O,v=S){const g=P;N=n("msgHash",N),O=n("publicKey",O);const{lowS:y,prehash:m,format:c}=v;if(Y5(v),("strict"in v))throw new Error("options.strict was renamed to lowS");if(c!==void 0&&c!=="compact"&&c!=="der")throw new Error("format must be compact or der");const f=typeof g==="string"||_0(g),r=!f&&!c&&typeof g==="object"&&g!==null&&typeof g.r==="bigint"&&typeof g.s==="bigint";if(!f&&!r)throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");let u=void 0,i;try{if(r)u=new M(g.r,g.s);if(f){try{if(c!=="compact")u=M.fromDER(g)}catch(I0){if(!(I0 instanceof S0.Err))throw I0}if(!u&&c!=="der")u=M.fromCompact(g)}i=K.fromHex(O)}catch(I0){return!1}if(!u)return!1;if(y&&u.hasHighS())return!1;if(m)N=G.hash(N);const{r:_,s:l}=u,G0=x(N),o=V(l),Y0=U(G0*o),U0=U(_*o),J0=K.BASE.multiplyAndAddUnsafe(i,Y0,U0)?.toAffine();if(!J0)return!1;return U(J0.x)===_}return{CURVE:G,getPublicKey:R,getSharedSecret:D,sign:B,verify:F,ProjectivePoint:K,Signature:M,utils:A}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */var{bytesToNumberBE:_q,hexToBytes:cq}=bJ;class V5 extends Error{constructor(J=""){super(J)}}var S0={Err:V5,_tlv:{encode:(J,G)=>{const{Err:Q}=S0;if(J<0||J>256)throw new Q("tlv.encode: wrong tag");if(G.length&1)throw new Q("tlv.encode: unpadded data");const q=G.length/2,W=Y8(q);if(W.length/2&128)throw new Q("tlv.encode: long form length too big");const X=q>127?Y8(W.length/2|128):"";return Y8(J)+X+W+G},decode(J,G){const{Err:Q}=S0;let q=0;if(J<0||J>256)throw new Q("tlv.encode: wrong tag");if(G.length<2||G[q++]!==J)throw new Q("tlv.decode: wrong tlv");const W=G[q++],X=!!(W&128);let U=0;if(!X)U=W;else{const K=W&127;if(!K)throw new Q("tlv.decode(long): indefinite length not supported");if(K>4)throw new Q("tlv.decode(long): byte length is too big");const Y=G.subarray(q,q+K);if(Y.length!==K)throw new Q("tlv.decode: length bytes not complete");if(Y[0]===0)throw new Q("tlv.decode(long): zero leftmost byte");for(let Z of Y)U=U<<8|Z;if(q+=K,U<128)throw new Q("tlv.decode(long): not minimal encoding")}const V=G.subarray(q,q+U);if(V.length!==U)throw new Q("tlv.decode: wrong value length");return{v:V,l:G.subarray(q+U)}}},_int:{encode(J){const{Err:G}=S0;if(J<v0)throw new G("integer: negative integers are not allowed");let Q=Y8(J);if(Number.parseInt(Q[0],16)&8)Q="00"+Q;if(Q.length&1)throw new G("unexpected DER parsing assertion: unpadded hex");return Q},decode(J){const{Err:G}=S0;if(J[0]&128)throw new G("invalid signature integer: negative");if(J[0]===0&&!(J[1]&128))throw new G("invalid signature integer: unnecessary leading zero");return _q(J)}},toSig(J){const{Err:G,_int:Q,_tlv:q}=S0,W=typeof J==="string"?cq(J):J;I8(W);const{v:X,l:U}=q.decode(48,W);if(U.length)throw new G("invalid signature: left bytes after parsing");const{v:V,l:K}=q.decode(2,X),{v:Y,l:Z}=q.decode(2,K);if(Z.length)throw new G("invalid signature: left bytes after parsing");return{r:Q.decode(V),s:Q.decode(Y)}},hexFromSig(J){const{_tlv:G,_int:Q}=S0,q=G.encode(2,Q.encode(J.r)),W=G.encode(2,Q.encode(J.s)),X=q+W;return G.encode(48,X)}},v0=BigInt(0),e=BigInt(1),OX=BigInt(2),U5=BigInt(3),BX=BigInt(4);function dq(J){return{hash:J,hmac:(G,...Q)=>SJ(J,G,l9(...Q)),randomBytes:I1}}function Z5(J,G){const Q=(q)=>K5({...J,...dq(q)});return{...Q(G),create:Q}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */var H5=function(J){const G=Q1,Q=BigInt(3),q=BigInt(6),W=BigInt(11),X=BigInt(22),U=BigInt(23),V=BigInt(44),K=BigInt(88),Y=J*J*J%G,Z=Y*Y*J%G,H=Z0(Z,Q,G)*Z%G,$=Z0(H,Q,G)*Z%G,z=Z0($,f1,G)*Y%G,C=Z0(z,W,G)*z%G,j=Z0(C,X,G)*C%G,M=Z0(j,V,G)*j%G,A=Z0(M,K,G)*M%G,R=Z0(A,V,G)*j%G,I=Z0(R,Q,G)*Z%G,D=Z0(I,U,G)*C%G,T=Z0(D,q,G)*Y%G,x=Z0(T,f1,G);if(!oJ.eql(oJ.sqr(x),J))throw new Error("Cannot find square root");return x},b1=function(J,...G){let Q=z5[J];if(Q===void 0){const q=k1(Uint8Array.from(J,(W)=>W.charCodeAt(0)));Q=F0(q,q),z5[J]=Q}return k1(F0(Q,...G))},aJ=function(J){let G=sJ.utils.normPrivateKeyToScalar(J),Q=eJ.fromPrivateKey(G);return{scalar:Q.hasEvenY()?G:J1(-G),bytes:tJ(Q)}},M5=function(J){L0("x",J,e8,Q1);const G=rJ(J*J),Q=rJ(G*J+BigInt(7));let q=H5(Q);if(q%f1!==j5)q=rJ(-q);const W=new eJ(J,q,e8);return W.assertValidity(),W},P5=function(...J){return J1(k8(b1("BIP0340/challenge",...J)))},rq=function(J){return aJ(J).bytes},oq=function(J,G,Q=I1(32)){const q=n("message",J),{bytes:W,scalar:X}=aJ(G),U=n("auxRand",Q,32),V=nJ(X^k8(b1("BIP0340/aux",U))),K=b1("BIP0340/nonce",V,W,q),Y=J1(k8(K));if(Y===j5)throw new Error("sign failed: k is zero");const{bytes:Z,scalar:H}=aJ(Y),$=P5(Z,W,q),z=new Uint8Array(64);if(z.set(Z,0),z.set(nJ(J1(H+$*X)),32),!C5(z,q,W))throw new Error("sign: Invalid signature produced");return z},C5=function(J,G,Q){const q=n("signature",J,64),W=n("message",G),X=n("publicKey",Q,32);try{const U=M5(k8(X)),V=k8(q.subarray(0,32));if(!c0(V,e8,Q1))return!1;const K=k8(q.subarray(32,64));if(!c0(K,e8,y1))return!1;const Y=P5(nJ(V),tJ(U),W),Z=iq(U,K,J1(-Y));if(!Z||!Z.hasEvenY()||Z.toAffine().x!==V)return!1;return!0}catch(U){return!1}};/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */var Q1=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),y1=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),e8=BigInt(1),f1=BigInt(2),$5=(J,G)=>(J+G/f1)/G,oJ=g1(Q1,void 0,void 0,{sqrt:H5}),sJ=Z5({a:BigInt(0),b:BigInt(7),Fp:oJ,n:y1,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:(J)=>{const G=y1,Q=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),q=-e8*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),W=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),X=Q,U=BigInt("0x100000000000000000000000000000000"),V=$5(X*J,G),K=$5(-q*J,G);let Y=a(J-V*Q-K*W,G),Z=a(-V*q-K*X,G);const H=Y>U,$=Z>U;if(H)Y=G-Y;if($)Z=G-Z;if(Y>U||Z>U)throw new Error("splitScalar: Endomorphism failed, k="+J);return{k1neg:H,k1:Y,k2neg:$,k2:Z}}}},k1),j5=BigInt(0),z5={},tJ=(J)=>J.toRawBytes(!0).slice(1),nJ=(J)=>P0(J,32),rJ=(J)=>a(J,Q1),J1=(J)=>a(J,y1),eJ=sJ.ProjectivePoint,iq=(J,G,Q)=>eJ.BASE.multiplyAndAddUnsafe(J,G,Q),k8=H0,h1=(()=>({getPublicKey:rq,sign:oq,verify:C5,utils:{randomPrivateKey:sJ.utils.randomPrivateKey,lift_x:M5,pointToBytes:tJ,numberToBytesBE:P0,bytesToNumberBE:H0,taggedHash:b1,mod:a}}))();var{floor:JQ,random:nq,sin:aq}=Math,K8="Trystero",l0=(J,G)=>Array(J).fill().map(G);var m1=(J)=>l0(J,()=>"0123456789AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz"[JQ(nq()*"0123456789AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz".length)]).join(""),A0=m1(20),d0=Promise.all.bind(Promise),D5=typeof window!=="undefined",{entries:_1,fromEntries:QQ,keys:O5}=Object,g0=()=>{},C0=(J)=>new Error(`Trystero: ${J}`),sq=new TextEncoder,tq=new TextDecoder,R0=(J)=>sq.encode(J),w8=(J)=>tq.decode(J),c1=(J)=>J.reduce((G,Q)=>G+Q.toString(16).padStart(2,"0"),""),G1=(...J)=>J.join("@"),eq=(J,G)=>{const Q=[...J],q=()=>{const X=aq(G++)*1e4;return X-JQ(X)};let W=Q.length;while(W){const X=JQ(q()*W--);[Q[W],Q[X]]=[Q[X],Q[W]]}return Q},B5=(J,G,Q,q)=>{return(J.relayUrls||(q?eq(G,GQ(J.appId)):G)).slice(0,J.relayUrls?J.relayUrls.length:J.relayRedundancy||Q)},j0=JSON.stringify,Z8=JSON.parse,GQ=(J,G=Number.MAX_SAFE_INTEGER)=>J.split("").reduce((Q,q)=>Q+q.charCodeAt(0),0)%G;var u1={},N5=(J,G)=>{const Q={},q=()=>{const W=new WebSocket(J);W.onclose=()=>{u1[J]??=3333,setTimeout(q,u1[J]),u1[J]*=2},W.onmessage=(X)=>G(X.data),Q.socket=W,Q.url=W.url,Q.ready=new Promise((X)=>W.onopen=()=>{X(Q),u1[J]=3333}),Q.send=(X)=>{if(W.readyState===1)W.send(X)}};return q(),Q},L5=(J)=>()=>QQ(_1(J).map(([G,Q])=>[G,Q.socket]));var qQ="AES-GCM",A5={},JW=(J)=>btoa(String.fromCharCode.apply(null,new Uint8Array(J))),QW=(J)=>{const G=atob(J);return new Uint8Array(G.length).map((Q,q)=>G.charCodeAt(q)).buffer},q1=async(J)=>A5[J]||(A5[J]=Array.from(new Uint8Array(await crypto.subtle.digest("SHA-1",R0(J)))).map((G)=>G.toString(36)).join("")),R5=async(J,G,Q)=>crypto.subtle.importKey("raw",await crypto.subtle.digest({name:"SHA-256"},R0(`${J}:${G}:${Q}`)),{name:qQ},!1,["encrypt","decrypt"]),I5="$",k5=",",w5=async(J,G)=>{const Q=crypto.getRandomValues(new Uint8Array(16));return Q.join(k5)+I5+JW(await crypto.subtle.encrypt({name:qQ,iv:Q},await J,R0(G)))},x5=async(J,G)=>{const[Q,q]=G.split(I5);return w8(await crypto.subtle.decrypt({name:qQ,iv:new Uint8Array(Q.split(k5))},await J,QW(q)))};var GW=5000,T5="icegatheringstatechange",WQ=(J)=>J.replace(/a=ice-options:trickle\s\n/g,""),XQ=(J,{rtcConfig:G,rtcPolyfill:Q,turnConfig:q})=>{const W=new(Q||RTCPeerConnection)({iceServers:qW.concat(q||[]),...G}),X={},U=(H)=>{H.binaryType="arraybuffer",H.bufferedAmountLowThreshold=65535,H.onmessage=($)=>X.data?.($.data),H.onopen=()=>X.connect?.(),H.onclose=()=>X.close?.(),H.onerror=($)=>X.error?.($)},V=async(H)=>{if(!H.localDescription)throw new Error("No local description available");return await Promise.race([new Promise(($)=>{const z=()=>{if(H.iceGatheringState==="complete")H.removeEventListener(T5,z),$()};H.addEventListener(T5,z),z()}),new Promise(($)=>setTimeout($,GW))]),{type:H.localDescription.type,sdp:WQ(H.localDescription.sdp)}};let K=!1,Y=null,Z=!1;if(J)Y=W.createDataChannel("data"),U(Y);else W.ondatachannel=({channel:H})=>{Y=H,U(H)};if(W.onnegotiationneeded=async()=>{try{K=!0,await W.setLocalDescription();const H=await V(W);X.signal?.({type:H.type,sdp:WQ(H.sdp)})}catch(H){X.error?.(H)}finally{K=!1}},W.onconnectionstatechange=()=>{if(["disconnected","failed","closed"].includes(W.connectionState))X.close?.()},W.ontrack=(H)=>{X.track?.(H.track,H.streams[0]),X.stream?.(H.streams[0])},W.onremovestream=(H)=>{X.stream?.(H.stream,{removed:!0})},J){if(!W.canTrickleIceCandidates)W.onnegotiationneeded()}return{created:Date.now(),connection:W,get channel(){return Y},get isDead(){return W.connectionState==="closed"},async signal(H){if(Y?.readyState==="open"){if(H.type==="offer"||W.signalingState!=="stable"){if(await W.setRemoteDescription(H),H.type==="offer"){await W.setLocalDescription();const $=await V(W);return X.signal?.({type:$.type,sdp:$.sdp}),{type:$.type,sdp:$.sdp}}}return}try{if(H.type==="offer"){if(K||W.signalingState!=="stable"){if(Z=!J,Z)return}await W.setRemoteDescription(H),await W.setLocalDescription();const $=await V(W),z=WQ($.sdp);return X.signal?.({type:$.type,sdp:z}),{type:$.type,sdp:z}}else if(H.type==="answer"&&(W.signalingState==="have-local-offer"||W.signalingState==="have-remote-offer"))await W.setRemoteDescription(H)}catch($){X.error?.($)}},sendData:(H)=>Y.send(H),destroy:()=>{if(Y)Y.close();W.close()},setHandlers:(H)=>Object.assign(X,H),offerPromise:J?new Promise((H)=>{const $=(z)=>{if(z.type==="offer")H(z)};X.signal=$}):Promise.resolve(),addStream:(H)=>{H.getTracks().forEach(($)=>W.addTrack($,H))},removeStream:(H)=>{W.getSenders().filter(($)=>H.getTracks().includes($.track)).forEach(($)=>W.removeTrack($))},addTrack:(H,$)=>W.addTrack(H,$),removeTrack:(H)=>{const $=W.getSenders().find((z)=>z.track===H);if($)W.removeTrack($)},replaceTrack:async(H,$)=>{const z=W.getSenders().find((C)=>C.track===H);if(z)await z.replaceTrack($)}}},qW=[...l0(3,(J,G)=>`stun:stun${G||""}.l.google.com:19302`),"stun:global.stun.twilio.com:3478"].map((J)=>({urls:J}));var WW=Object.getPrototypeOf(Uint8Array),l1=12,S5=0,d1=S5+l1,i1=d1+1,W1=i1+1,X1=W1+1,$8=16384-X1,p1=255,F5="bufferedamountlow",x8=(J)=>"@_"+J,v5=(J,G,Q)=>{const q={},W={},X={},U={},V={},K={},Y={},Z={onPeerJoin:g0,onPeerLeave:g0,onPeerStream:g0,onPeerTrack:g0},H=(B,F)=>(B?Array.isArray(B)?B:[B]:O5(q)).flatMap((P)=>{const N=q[P];if(!N)return console.warn(`${K8}: no peer with id ${P} found`),[];return F(P,N)}),$=(B)=>{if(!q[B])return;delete q[B],delete U[B],delete V[B],Z.onPeerLeave(B),G(B)},z=(B)=>{if(W[B])return X[B];if(!B)throw C0("action type argument is required");const F=R0(B);if(F.byteLength>l1)throw C0(`action type string "${B}" (${F.byteLength}b) exceeds `+`byte limit (${l1}). Hint: choose a shorter name.`);const P=new Uint8Array(l1);P.set(F);let N=0;return W[B]={onComplete:g0,onProgress:g0,setOnComplete:(O)=>W[B]={...W[B],onComplete:O},setOnProgress:(O)=>W[B]={...W[B],onProgress:O},send:async(O,v,g,y)=>{if(g&&typeof g!=="object")throw C0("action meta argument must be an object");const m=typeof O;if(m==="undefined")throw C0("action data cannot be undefined");const c=m!=="string",f=O instanceof Blob,r=f||O instanceof ArrayBuffer||O instanceof WW;if(g&&!r)throw C0("action meta argument can only be used with binary data");const u=r?new Uint8Array(f?await O.arrayBuffer():O):R0(c?j0(O):O),i=g?R0(j0(g)):null,_=Math.ceil(u.byteLength/$8)+(g?1:0)||1,l=l0(_,(G0,o)=>{const Y0=o===_-1,U0=g&&o===0,J0=new Uint8Array(X1+(U0?i.byteLength:Y0?u.byteLength-$8*(_-(g?2:1)):$8));return J0.set(P),J0.set([N],d1),J0.set([Y0|U0<<1|r<<2|c<<3],i1),J0.set([Math.round((o+1)/_*p1)],W1),J0.set(g?U0?i:u.subarray((o-1)*$8,o*$8):u.subarray(o*$8,(o+1)*$8),X1),J0});return N=N+1&p1,d0(H(v,async(G0,o)=>{const{channel:Y0}=o;let U0=0;while(U0<_){const J0=l[U0];if(Y0.bufferedAmount>Y0.bufferedAmountLowThreshold)await new Promise((i0)=>{const I0=()=>{Y0.removeEventListener(F5,I0),i0()};Y0.addEventListener(F5,I0)});if(!q[G0])break;o.sendData(J0),U0++,y?.(J0[W1]/p1,G0,g)}}))}},X[B]||=[W[B].send,W[B].setOnComplete,W[B].setOnProgress]},C=(B,F)=>{const P=new Uint8Array(F),N=w8(P.subarray(S5,d1)).replaceAll("\0",""),[O]=P.subarray(d1,i1),[v]=P.subarray(i1,W1),[g]=P.subarray(W1,X1),y=P.subarray(X1),m=!!(v&1),c=!!(v&1<<1),f=!!(v&1<<2),r=!!(v&1<<3);if(!W[N]){console.warn(`${K8}: received message with unregistered type (${N})`);return}U[B]||={},U[B][N]||={};const u=U[B][N][O]||={chunks:[]};if(c)u.meta=Z8(w8(y));else u.chunks.push(y);if(W[N].onProgress(g/p1,B,u.meta),!m)return;const i=new Uint8Array(u.chunks.reduce((_,l)=>_+l.byteLength,0));if(u.chunks.reduce((_,l)=>{return i.set(l,_),_+l.byteLength},0),delete U[B][N][O],f)W[N].onComplete(i,B,u.meta);else{const _=w8(i);W[N].onComplete(r?Z8(_):_,B)}},j=async()=>{await w(""),await new Promise((B)=>setTimeout(B,99)),_1(q).forEach(([B,F])=>{F.destroy(),delete q[B]}),Q()},[M,A]=z(x8("ping")),[R,I]=z(x8("pong")),[D,T]=z(x8("signal")),[x,L]=z(x8("stream")),[k,E]=z(x8("track")),[w,S]=z(x8("leave"));if(J((B,F)=>{if(q[F])return;q[F]=B,B.setHandlers({data:(P)=>C(F,P),stream:(P)=>{Z.onPeerStream(P,F,K[F]),delete K[F]},track:(P,N)=>{Z.onPeerTrack(P,N,F,Y[F]),delete Y[F]},signal:(P)=>D(P,F),close:()=>$(F),error:()=>$(F)}),Z.onPeerJoin(F),B.drainEarlyData?.((P)=>C(F,P))}),A((B,F)=>R("",F)),I((B,F)=>{V[F]?.(),delete V[F]}),T((B,F)=>q[F]?.signal(B)),L((B,F)=>K[F]=B),E((B,F)=>Y[F]=B),S((B,F)=>$(F)),D5)addEventListener("beforeunload",j);return{makeAction:z,leave:j,ping:async(B)=>{if(!B)throw C0("ping() must be called with target peer ID");const F=Date.now();return M("",B),await new Promise((P)=>V[B]=P),Date.now()-F},getPeers:()=>QQ(_1(q).map(([B,F])=>[B,F.connection])),addStream:(B,F,P)=>H(F,async(N,O)=>{if(P)await x(P,N);O.addStream(B)}),removeStream:(B,F)=>H(F,(P,N)=>N.removeStream(B)),addTrack:(B,F,P,N)=>H(P,async(O,v)=>{if(N)await k(N,O);v.addTrack(B,F)}),removeTrack:(B,F,P)=>H(P,(N,O)=>O.removeTrack(B,F)),replaceTrack:(B,F,P,N,O)=>H(N,async(v,g)=>{if(O)await k(O,v);g.replaceTrack(B,F,P)}),onPeerJoin:(B)=>Z.onPeerJoin=B,onPeerLeave:(B)=>Z.onPeerLeave=B,onPeerStream:(B)=>Z.onPeerStream=B,onPeerTrack:(B)=>Z.onPeerTrack=B}};var XW=20,YW=5333,g5=57333,E5=({init:J,subscribe:G,announce:Q})=>{const q={};let W=!1,X,U,V;return(K,Y,Z)=>{const{appId:H}=K;if(q[H]?.[Y])return q[H][Y];const $={},z={},C=G1(K8,H,Y),j=q1(C),M=q1(G1(C,A0)),A=R5(K.password||"",H,Y),R=(O)=>async(v)=>({type:v.type,sdp:await O(A,v.sdp)}),I=R(x5),D=R(w5),T=()=>XQ(!0,K),x=(O,v,g)=>{if(z[v]){if(z[v]!==O)O.destroy();return}z[v]=O,N(O,v),$[v]?.forEach((y,m)=>{if(m!==g)y.destroy()}),delete $[v]},L=(O,v)=>{if(z[v]===O)delete z[v]},k=(O,v)=>{if(z[O])return;const g=$[O]?.[v];if(g)delete $[O][v],g.destroy()},E=(O)=>{return U.push(...l0(O,T)),d0(U.splice(0,O).map((v)=>v.offerPromise.then(D).then((g)=>({peer:v,offer:g}))))},w=(O,v)=>Z?.({error:`incorrect password (${K.password}) when decrypting ${v}`,appId:H,peerId:O,roomId:Y}),S=(O)=>async(v,g,y)=>{const[m,c]=await d0([j,M]);if(v!==m&&v!==c)return;const{peerId:f,offer:r,answer:u,peer:i}=typeof g==="string"?Z8(g):g;if(f===A0||z[f])return;if(f&&!r&&!u){if($[f]?.[O])return;const[[{peer:_,offer:l}],G0]=await d0([E(1),q1(G1(C,f))]);$[f]||=[],$[f][O]=_,setTimeout(()=>k(f,O),B[O]*0.9),_.setHandlers({connect:()=>x(_,f,O),close:()=>L(_,f)}),y(G0,j0({peerId:A0,offer:l}))}else if(r){if($[f]?.[O]&&A0>f)return;const l=XQ(!1,K);l.setHandlers({connect:()=>x(l,f,O),close:()=>L(l,f)});let G0;try{G0=await I(r)}catch{w(f,"offer");return}if(l.isDead)return;const[o,Y0]=await d0([q1(G1(C,f)),l.signal(G0)]);y(o,j0({peerId:A0,answer:await D(Y0)}))}else if(u){let _;try{_=await I(u)}catch(l){w(f,"answer");return}if(i)i.setHandlers({connect:()=>x(i,f,O),close:()=>L(i,f)}),i.signal(_);else{const l=$[f]?.[O];if(l&&!l.isDead)l.signal(_)}}};if(!K)throw C0("requires a config map as the first argument");if(!H&&!K.firebaseApp)throw C0("config map is missing appId field");if(!Y)throw C0("roomId argument required");if(!W){const O=J(K);U=l0(XW,T),X=Array.isArray(O)?O:[O],W=!0,V=setInterval(()=>U=U.filter((v)=>{const g=Date.now()-v.created<g5;if(!g)v.destroy();return g}),g5*1.03)}const B=X.map(()=>YW),F=[],P=X.map(async(O,v)=>G(await O,await j,await M,S(v),E));d0([j,M]).then(([O,v])=>{const g=async(y,m)=>{const c=await Q(y,O,v);if(typeof c==="number")B[m]=c;F[m]=setTimeout(()=>g(y,m),B[m])};P.forEach(async(y,m)=>{await y,g(await X[m],m)})});let N=g0;return q[H]||={},q[H][Y]=v5((O)=>N=O,(O)=>delete z[O],()=>{delete q[H][Y],F.forEach(clearTimeout),P.forEach(async(O)=>(await O)()),clearInterval(V)})}};var h5={},UW=5,u5="x",m5="EVENT",_5=h1.utils.randomPrivateKey(),VW=c1(h1.getPublicKey(_5)),YQ={},Y1={},KW={},c5=()=>Math.floor(Date.now()/1000),p5=(J)=>KW[J]??=GQ(J,1e4)+20000,y5=async(J,G)=>{const Q={kind:p5(J),content:G,pubkey:VW,created_at:c5(),tags:[[u5,J]]},q=c1(new Uint8Array(await crypto.subtle.digest("SHA-256",R0(j0([0,Q.pubkey,Q.created_at,Q.kind,Q.tags,Q.content])))));return j0([m5,{...Q,id:q,sig:c1(await h1.sign(q,_5))}])},f5=(J,G)=>{return YQ[J]=G,j0(["REQ",J,{kinds:[p5(G)],since:c5(),["#"+u5]:[G]}])},b5=(J)=>{return delete YQ[J],j0(["CLOSE",J])},UQ=E5({init:(J)=>B5(J,$W,UW,!0).map((G)=>{const Q=N5(G,(q)=>{const[W,X,U,V]=Z8(q);if(W!==m5){const K=`${K8}: relay failure from ${Q.url} - `;if(W==="NOTICE")console.warn(K+X);else if(W==="OK"&&!U)console.warn(K+V);return}Y1[X]?.(YQ[X],U.content)});return h5[G]=Q,Q.ready}),subscribe:(J,G,Q,q)=>{const W=m1(64),X=m1(64);return Y1[W]=Y1[X]=(U,V)=>q(U,V,async(K,Y)=>J.send(await y5(K,Y))),J.send(f5(W,G)),J.send(f5(X,Q)),()=>{J.send(b5(W)),J.send(b5(X)),delete Y1[W],delete Y1[X]}},announce:async(J,G)=>J.send(await y5(G,j0({peerId:A0})))}),ZW=L5(h5),$W=["eu.purplerelay.com","ftp.halifax.rwth-aachen.de/nostr","multiplexer.huszonegy.world","nostr.cool110.xyz","nostr.data.haus","nostr.grooveix.com","nostr.huszonegy.world","nostr.mom","nostr.sathoarder.com","nostr.vulpem.com","relay.fountain.fm","relay.nostraddress.com","relay.nostromo.social","relay.snort.social","relay.verified-nostr.com","yabu.me/v2"].map((J)=>"wss://"+J);var l5=(J,G,Q)=>{if(!J||!J.timestamp)return{resolved:!0,value:G.value,timestamp:G.timestamp};const q=G.timestamp,W=J.timestamp;if(Q.compare(W,q)<0)return{resolved:!0,value:G.value,timestamp:G.timestamp};return{resolved:!1}};var zW=()=>{const J=new Map,G=async()=>{try{const K=await navigator.storage.getDirectory(),Z=await(await K.getFileHandle("~opfs-sync-test",{create:!0})).createSyncAccessHandle?.();return await Z?.close(),await K.removeEntry("~opfs-sync-test"),!!Z}catch{return!1}};let Q="idb";const q=(async()=>{if(await G())Q="sync";else try{const K=await navigator.storage.getDirectory(),Z=await(await K.getFileHandle("~opfs-async-test",{create:!0})).createWritable?.();if(await Z?.close(),await K.removeEntry("~opfs-async-test"),Z)Q="async";else Q="idb"}catch{Q="idb"}})(),W=async(K,Y)=>{if(!J.has(K))J.set(K,[]);const Z=J.get(K),H=Z[Z.length-1]||Promise.resolve();let $;const z=new Promise((C)=>$=C);Z.push(z);try{return await H,await Y()}finally{if(Z.shift(),$(),Z.length===0)J.delete(K)}},X=(()=>{let K;const Y=async()=>{if(!K)K=new Promise((Z,H)=>{const $=indexedDB.open("opfs-fallback-db",1);$.onupgradeneeded=()=>$.result.createObjectStore("files"),$.onsuccess=()=>Z($.result),$.onerror=()=>H($.error)});return K};return{getDB:Y,get:async(Z)=>{const H=await Y();return new Promise(($,z)=>{const j=H.transaction("files","readonly").objectStore("files").get(Z);j.onsuccess=()=>$(j.result||new Uint8Array),j.onerror=()=>z(j.error)})},set:async(Z,H)=>{const $=await Y();return new Promise((z,C)=>{const M=$.transaction("files","readwrite").objectStore("files").put(H,Z);M.onsuccess=()=>z(),M.onerror=()=>C(M.error)})}}})(),U=async(K)=>{await q;try{if(Q==="idb"){const z=await X.get(K);return{type:"loaded",name:K,data:z}}const Z=await(await navigator.storage.getDirectory()).getFileHandle(K);if(Q==="sync"){let z;try{z=await Z.createSyncAccessHandle();const C=z.getSize(),j=new Uint8Array(C),M=z.read(j,{at:0});return{type:"loaded",name:K,data:j.slice(0,M)}}finally{z?.close()}}const H=await Z.getFile(),$=new Uint8Array(await H.arrayBuffer());return{type:"loaded",name:K,data:$}}catch(Y){const Z=Y.name==="NotFoundError"?"File not found":Y.message||"Error reading file";return{type:"error",name:K,message:Z}}},V=async(K,Y)=>{if(await q,!(Y instanceof Uint8Array))return{type:"error",name:K,message:"Content must be a Uint8Array"};return W(K,async()=>{try{if(Q==="idb")return await X.set(K,Y),{type:"saved",name:K};const H=await(await navigator.storage.getDirectory()).getFileHandle(K,{create:!0});if(Q==="sync"){let $;try{$=await H.createSyncAccessHandle(),$.truncate(0),$.write(Y,{at:0}),$.flush()}finally{$?.close()}}else{let $;try{$=await H.createWritable(),await $.write(Y)}finally{await $?.close()}}return{type:"saved",name:K}}catch(Z){return{type:"error",name:K,message:Z.message||"Error saving file"}}})};self.onmessage=async({data:K})=>{const{type:Y,name:Z,content:H}=K;await q;const $={load:()=>U(Z),save:()=>V(Z,H)};try{const z=$[Y],C=z?await z():{type:"error",message:`Unrecognized action type: ${Y}`};self.postMessage(C)}catch(z){console.error("Worker unexpected error:",z),self.postMessage({type:"error",name:Z,message:z.message||"Unexpected worker error"})}}},d5=zW;var z8={$eq:(J,G)=>J===G,$ne:(J,G)=>J!==G,$gt:(J,G)=>J>G,$gte:(J,G)=>J>=G,$lt:(J,G)=>J<G,$lte:(J,G)=>J<=G,$in:(J,G)=>Array.isArray(G)&&G.includes(J),$between:(J,[G,Q])=>J>=G&&J<=Q,$exists:(J,G)=>G?J!==void 0:J===void 0,$text:{global:(J,G)=>{const Q=(W)=>String(W).normalize("NFD").replace(/[\u0300-\u036f]/g,"").toLowerCase().replace(/[^\w\s]/g,""),q=Q(G);return Object.values(J).some((W)=>{if(typeof W==="object")return null.fieldSearch(W,q);return Q(W).includes(q)})},field:(J,G)=>{const Q=(q)=>String(q).normalize("NFD").replace(/[\u0300-\u036f]/g,"").toLowerCase().replace(/[^\w\s]/g,"");return Array.isArray(J)?J.some((q)=>Q(q).includes(Q(G))):Q(J).includes(Q(G))}},$like:(J,G)=>{if(typeof J!=="string"||typeof G!=="string")return!1;return new RegExp(`^${G.replace(/%/g,".*").replace(/_/g,".")}\$`,"i").test(J)},$regex:(J,G)=>typeof J==="string"&&new RegExp(G.$regex||G,"i").test(J),$and:(J,G,Q)=>G.every((q)=>{return Q.createFilter(q)(J)}),$or:(J,G,Q)=>G.some((q)=>{return Q.createFilter(q)(J)}),$not:(J,G,Q)=>{return!Q.createFilter(G)(J)}},VQ=(J,G)=>{const Q=G.split(".");let q=J;for(let W of Q)if(q&&typeof q==="object"&&(W in q))q=q[W];else return;return q},KQ=(J)=>{const G=(Q)=>{return Object.entries(J).every(([q,W])=>{if(q.startsWith("$"))return z8[q](Q,W,{filterNode:G,createFilter:KQ});const X=VQ(Q.value,q);if(typeof W!=="object"||W===null)return z8.$eq(X,W);return Object.entries(W).every(([U,V])=>{if(U==="$text")return z8.$text.field(X,V);if(U==="$between"&&V.every((K)=>K instanceof Date)){const K=new Date(X);return z8.$between(K,V)}return z8[U]?.(X,V,{filterNode:G,createFilter:KQ})??!1})})};return G},ZQ=(J,G)=>{const Q=KQ(G.query);let q=Object.values(J).filter(Q);if(G.field)q.sort((W,X)=>{const U=VQ(W.value,G.field),V=VQ(X.value,G.field),K=G.order==="asc"?1:-1;if(typeof U==="string"&&typeof V==="string")return U.localeCompare(V)*K;return((U??0)-(V??0))*K});if(G.$after){const W=q.findIndex((X)=>X.id===G.$after);q=W>=0?q.slice(W+1):[]}if(G.$before){const W=q.findIndex((X)=>X.id===G.$before);q=W>=0?q.slice(0,W):[]}return G.$limit?q.slice(0,G.$limit):q};class $Q{constructor(){this.physical=Date.now(),this.logical=0}now(){const J=Date.now();return this.physical=Math.max(this.physical,J),this.logical++,{physical:this.physical,logical:this.logical}}update(J){if(!J||typeof J.physical!=="number"||typeof J.logical!=="number")return;this.physical=Math.max(this.physical,J.physical),this.logical=Math.max(this.logical,J.logical)+1}compare(J,G){if(!J&&!G)return 0;if(!J)return-1;if(!G)return 1;if(J.logical>G.logical)return 1;if(J.logical<G.logical)return-1;return J.physical-G.physical}}var i5=function(J,G){return J.length===G.length&&J.every((Q,q)=>Q===G[q])};async function HW(){console.log("\u26A1 GDB-P2P: Empowering distributed graph databases with real-time synchronization and scalability. Learn more: https://github.com/estebanrfp/gdb \u26A1"),console.log(navigator?.storage?.getDirectory?"OPFS is enabled.":"OPFS is not available."),navigator?.storage?.getDirectory&&await navigator.storage.getDirectory()}if(Symbol.dispose===void 0)Object.defineProperty(Symbol,"dispose",{value:Symbol.for("Symbol.dispose")});class r5{constructor(){this.nodes={}}insert(J,G,Q){this.nodes[J]={id:J,value:G,edges:[],timestamp:Q}}get(J){return this.nodes[J]||null}link(J,G){const Q=this.nodes[J],q=this.nodes[G];if(Q&&q&&!Q.edges.includes(G))Q.edges.push(G)}getAllNodes(){return Object.values(this.nodes)}serialize(){return xJ.deflate(o0(this.nodes))}deserialize(J){this.nodes=s1(xJ.inflate(new Uint8Array(J)))}}class o5{constructor(J,{password:G,securityManager:Q=null}={}){this.hybridClock=new $Q;const q=localStorage.getItem(`${this.name}_time`);this.globalTimestamp=q?JSON.parse(q):null,this.name=J,this.password=G,this.graph=new r5,this.securityManager=Q,this.eventListeners=[],this.operators=z8,this.initWorker(),this.ready=this.loadGraphFromOPFS();const W=`graph-sync-room-${this.name}`,X={appId:"1234",...this.password&&{password:this.password}},U=UQ(X,W);this.room=U;const[V,K]=U.makeAction("syncGraph");if(this.sendData=V,this.securityManager&&typeof this.securityManager.signOutgoingOperations==="function"){const Y=this.sendData.bind(this);this.sendData=async(Z)=>{const H=await this.securityManager.signOutgoingOperations(Z,this);return Y(H)}}window.addEventListener("online",async()=>{console.log("\u2705 Reconnected to the network.");const Y=localStorage.getItem(`${this.name}_time`);this.globalTimestamp=Y?JSON.parse(Y):null,this.sendData([{type:"sync",timestamp:this.globalTimestamp}])}),window.addEventListener("offline",async()=>{console.log("\u274C Disconnected from the network.")}),document.addEventListener("visibilitychange",()=>{if(document.visibilityState==="visible"){console.log("The tab is visible again.");const Y=localStorage.getItem(`${this.name}_time`);this.globalTimestamp=Y?JSON.parse(Y):null,this.sendData([{type:"sync",timestamp:this.globalTimestamp}])}else if(document.visibilityState==="hidden")console.log("The tab is no longer visible.")}),HW(),U.onPeerJoin(async(Y)=>{console.log("\u26A1 New pair connected:",Y);const Z=localStorage.getItem(`${this.name}_time`);this.globalTimestamp=Z?JSON.parse(Z):null,this.sendData([{type:"sync",timestamp:this.globalTimestamp}])}),U.onPeerLeave((Y)=>{console.log("\u26A1 Pair disconnected:",Y)}),K(async(Y)=>{if(this.securityManager&&typeof this.securityManager.verifyIncomingOperations==="function"){const{validatedOperations:Z,unverifiedOperations:H}=await this.securityManager.verifyIncomingOperations(Y,this);if(Z&&Z.length>0)this.receiveChanges(Z);if(H&&H.length>0&&!this.securityManager.isStrictMode())console.warn("GDB: Procesando operaciones no verificadas (modo no estricto de seguridad)."),this.receiveChanges(H)}else this.receiveChanges(Y)}),this.channel=new BroadcastChannel(`graphdb_sync_${this.name}`),this.channel.onmessage=async(Y)=>{if(Y.data==="update")console.log("\uD83D\uDD04 Update received from another tab..."),await this.loadGraphFromOPFS(),this.emit()}}initWorker(){try{const J=URL.createObjectURL(new Blob([`(${d5.toString()})()`],{type:"application/javascript"}));this.worker=new Worker(J),URL.revokeObjectURL(J),this.worker.addEventListener("message",({data:G})=>console.log("Worker message:",`${G.name} ${G.type}`)),console.log("Worker initialized successfully.")}catch({message:J}){console.error("Failed to initialize worker:",J)}}getWorker(){return this.worker}emit(){this.eventListeners.forEach((J)=>J(this.graph.nodes))}async getAllNodes(){return await this.ready,this.graph.getAllNodes()}async generateHash(){return crypto.randomUUID()}async hashValue(J){const G=(new TextEncoder()).encode(J),Q=await crypto.subtle.digest("SHA-256",G);return Array.from(new Uint8Array(Q)).map((q)=>q.toString(16).padStart(2,"0")).join("")}async loadGraphFromOPFS(){try{const G=await((Q)=>new Promise((q,W)=>{const X=async({data:U})=>{if(U.type==="loaded"&&U.name===Q)this.worker.removeEventListener("message",X),q(new Uint8Array(U.data));else if(U.type==="error")this.worker.removeEventListener("message",X),W(new Error(U.message||"Unknown error"))};this.worker.addEventListener("message",X),this.worker.postMessage({type:"load",name:Q})}))(`${this.name}_graph.msgpack`).catch(()=>new Uint8Array);G.byteLength>0?this.graph.deserialize(G):console.warn("The file '_graph.msgpack' is empty or could not be loaded."),console.log(`Graph loaded from OPFS: [ ${this.graph.getAllNodes().length} nodes ]`)}catch({message:J}){console.error("General error loading the graph from OPFS:",J)}}async saveGraphToOPFS(){try{const J=this.graph.serialize();return await((Q,q)=>new Promise((W,X)=>{const U=({data:V})=>{if(V.type==="saved"&&V.name===Q)this.worker.removeEventListener("message",U),W();else if(V.type==="error")this.worker.removeEventListener("message",U),X(new Error(V.message||"Save error"))};this.worker.addEventListener("message",U),this.worker.postMessage({type:"save",name:Q,content:q})}))(`${this.name}_graph.msgpack`,J),this.channel.postMessage("update"),!0}catch({message:J}){throw console.error("Save error:",J),new Error("Save failed")}}async put(J,G){await this.ready;const Q=this.hybridClock.now();return localStorage.setItem(`${this.name}_time`,JSON.stringify(Q)),G??=await this.generateHash(),this.graph.insert(G,J,Q),await this.saveGraphToOPFS(),await this.sendData([{type:"insert",id:G,value:J,timestamp:Q}]),this.emit(),G}async get(J,G=null){if(await this.ready,typeof J!=="string")return{result:null};const Q=this.graph.get(J);if(!Q){if(G)G(null);return{result:null}}const q=(U)=>{if(!U)return null;const V=U.value!==null&&typeof U.value==="object"?{...U.value}:U.value;return{...U,value:V}};if(!G)return{result:q(Q)};let W=Q.timestamp;G(q(Q));const X=(U)=>{const V=U[J];if(V){if(this.hybridClock.compare(V.timestamp,W)>0)W=V.timestamp,G(q(V))}else G(null),this.eventListeners.splice(this.eventListeners.indexOf(X),1)};return this.eventListeners.push(X),{result:q(Q),unsubscribe:()=>{const U=this.eventListeners.indexOf(X);if(U>-1)this.eventListeners.splice(U,1)}}}async map(...J){await this.ready;let Q={...{realtime:!1,query:{},field:null,order:"asc",$limit:null,$after:null,$before:null}},q=null,W=!1;J.forEach((K)=>typeof K==="function"?q=K:K&&typeof K==="object"&&(W||=("realtime"in K),Object.assign(Q,K))),q&&!W&&(Q.realtime=!0);let X=ZQ(this.graph.nodes,Q),U=null;const V=(K)=>{const Y=K.filter((z)=>!X.some((C)=>C.id===z.id)),Z=X.filter((z)=>!K.some((C)=>C.id===z.id)),H=K.filter((z)=>{const C=X.find((j)=>j.id===z.id);return C&&!i5(o0(z.value),o0(C.value))}),$=(z,C)=>{const j=C==="removed"?null:z.value,M={id:z.id,value:j,edges:z.edges||[],timestamp:z.timestamp||null,action:C};q(M)};Y.forEach((z)=>$(z,"added")),Z.forEach((z)=>$(z,"removed")),H.forEach((z)=>$(z,"updated"))};if(q){if(X.forEach((K)=>{if(K.value)q({id:K.id,value:K.value,edges:K.edges,timestamp:K.timestamp,action:"initial"})}),Q.realtime)U=(K)=>{const Y=ZQ(K,Q);if(!i5(o0(Y),o0(X)))V(Y),X=Y},this.eventListeners.push(U)}return{results:X,...Q.realtime&&q&&U&&{unsubscribe:()=>{const K=this.eventListeners.indexOf(U);K>-1&&this.eventListeners.splice(K,1)}}}}async remove(J){await this.ready;const G=this.hybridClock.now(),Q=this.graph.get(J);if(!Q)return console.error(`Node with ID '${J}' not found.`);delete this.graph.nodes[J],Object.values(this.graph.nodes).forEach((q)=>q.edges=q.edges.filter((W)=>W!==J)),await this.saveGraphToOPFS(),localStorage.setItem(`${this.name}_time`,JSON.stringify(G)),await this.sendData([{type:"remove",id:J,value:Q.value,timestamp:G}]),this.emit()}async clear(){await this.ready,this.graph.nodes={};try{await(await navigator.storage.getDirectory()).removeEntry(`${this.name}_graph.msgpack`)}catch({message:J}){console.warn(`Error deleting _graph.msgpack: ${J}`)}console.log("All data has been deleted.")}async link(J,G){await this.ready;const Q=this.hybridClock.now();if(!this.graph.nodes[J]||!this.graph.nodes[G]){console.error(`One or both nodes (${J}, ${G}) do not exist.`);return}this.graph.link(J,G),this.addChange(J,Q,"update"),await this.saveGraphToOPFS(),localStorage.setItem(`${this.name}_time`,JSON.stringify(Q)),await this.sendData([{type:"link",sourceId:J,targetId:G,timestamp:Q}]),this.emit()}async applyFullGraph(J){try{this.graph.nodes={...J.nodes},await this.saveGraphToOPFS(),this.emit()}catch({message:G}){console.error(`Error applying the full graph: ${G}`)}}async receiveChanges(J){const G={insert:(Q)=>this.graph.insert(Q.id,Q.value,Q.timestamp),update:(Q)=>{const q=this.graph.get(Q.id),W=l5(q,Q,this.hybridClock);W.resolved&&Object.assign(q,{value:W.value,timestamp:W.timestamp})},remove:(Q)=>delete this.graph.nodes[Q.id],link:(Q)=>this.graph.link(Q.sourceId,Q.targetId),sync:async(Q)=>{if(this.hybridClock.compare(this.globalTimestamp,Q.timestamp)>0)console.log("Sending recent data to the remote node."),await this.sendData([{type:"syncReceive",graph:this.graph}])},syncReceive:(Q)=>this.applyFullGraph(Q.graph)};for(let Q of J)G[Q.type]?.(Q);await this.saveGraphToOPFS(),this.emit()}}export{o5 as default};
