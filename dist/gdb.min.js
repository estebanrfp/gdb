function o6(W){const Q=W.length;let J=0,V=0;while(V<Q){let G=W.charCodeAt(V++);if((G&4294967168)===0){J++;continue}else if((G&4294965248)===0)J+=2;else{if(G>=55296&&G<=56319){if(V<Q){const X=W.charCodeAt(V);if((X&64512)===56320)++V,G=((G&1023)<<10)+(X&1023)+65536}}if((G&4294901760)===0)J+=3;else J+=4}}return J}function fW(W,Q,J){const V=W.length;let G=J,X=0;while(X<V){let Y=W.charCodeAt(X++);if((Y&4294967168)===0){Q[G++]=Y;continue}else if((Y&4294965248)===0)Q[G++]=Y>>6&31|192;else{if(Y>=55296&&Y<=56319){if(X<V){const q=W.charCodeAt(X);if((q&64512)===56320)++X,Y=((Y&1023)<<10)+(q&1023)+65536}}if((Y&4294901760)===0)Q[G++]=Y>>12&15|224,Q[G++]=Y>>6&63|128;else Q[G++]=Y>>18&7|240,Q[G++]=Y>>12&63|128,Q[G++]=Y>>6&63|128}Q[G++]=Y&63|128}}function hW(W,Q,J){pW.encodeInto(W,Q.subarray(J))}function a6(W,Q,J){if(W.length>bW)hW(W,Q,J);else fW(W,Q,J)}function y8(W,Q,J){let V=Q;const G=V+J,X=[];let Y="";while(V<G){const q=W[V++];if((q&128)===0)X.push(q);else if((q&224)===192){const F=W[V++]&63;X.push((q&31)<<6|F)}else if((q&240)===224){const F=W[V++]&63,U=W[V++]&63;X.push((q&31)<<12|F<<6|U)}else if((q&248)===240){const F=W[V++]&63,U=W[V++]&63,K=W[V++]&63;let $=(q&7)<<18|F<<12|U<<6|K;if($>65535)$-=65536,X.push($>>>10&1023|55296),$=56320|$&1023;X.push($)}else X.push(q);if(X.length>=uW)Y+=String.fromCharCode(...X),X.length=0}if(X.length>0)Y+=String.fromCharCode(...X);return Y}function cW(W,Q,J){const V=W.subarray(Q,Q+J);return mW.decode(V)}function s6(W,Q,J){if(J>_W)return cW(W,Q,J);else return y8(W,Q,J)}var pW=new TextEncoder,bW=50,uW=4096,mW=new TextDecoder,_W=200;class Q1{constructor(W,Q){this.type=W,this.data=Q}}class Y0 extends Error{constructor(W){super(W);const Q=Object.create(Y0.prototype);Object.setPrototypeOf(this,Q),Object.defineProperty(this,"name",{configurable:!0,enumerable:!1,value:Y0.name})}}function e6(W,Q,J){const V=J/4294967296,G=J;W.setUint32(Q,V),W.setUint32(Q+4,G)}function t1(W,Q,J){const V=Math.floor(J/4294967296),G=J;W.setUint32(Q,V),W.setUint32(Q+4,G)}function W8(W,Q){const J=W.getInt32(Q),V=W.getUint32(Q+4);return J*4294967296+V}function t6(W,Q){const J=W.getUint32(Q),V=W.getUint32(Q+4);return J*4294967296+V}var V1=4294967295;function rW({sec:W,nsec:Q}){if(W>=0&&Q>=0&&W<=iW)if(Q===0&&W<=lW){const J=new Uint8Array(4);return new DataView(J.buffer).setUint32(0,W),J}else{const J=W/4294967296,V=W&4294967295,G=new Uint8Array(8),X=new DataView(G.buffer);return X.setUint32(0,Q<<2|J&3),X.setUint32(4,V),G}else{const J=new Uint8Array(12),V=new DataView(J.buffer);return V.setUint32(0,Q),t1(V,4,W),J}}function nW(W){const Q=W.getTime(),J=Math.floor(Q/1000),V=(Q-J*1000)*1e6,G=Math.floor(V/1e9);return{sec:J+G,nsec:V-G*1e9}}function oW(W){if(W instanceof Date){const Q=nW(W);return rW(Q)}else return null}function aW(W){const Q=new DataView(W.buffer,W.byteOffset,W.byteLength);switch(W.byteLength){case 4:return{sec:Q.getUint32(0),nsec:0};case 8:{const J=Q.getUint32(0),V=Q.getUint32(4),G=(J&3)*4294967296+V,X=J>>>2;return{sec:G,nsec:X}}case 12:{const J=W8(Q,4),V=Q.getUint32(0);return{sec:J,nsec:V}}default:throw new Y0(`Unrecognized data size for timestamp (expected 4, 8, or 12): ${W.length}`)}}function sW(W){const Q=aW(W);return new Date(Q.sec*1000+Q.nsec/1e6)}var dW=-1,lW=4294967295,iW=17179869183,W5={type:dW,encode:oW,decode:sW};class u0{constructor(){this.builtInEncoders=[],this.builtInDecoders=[],this.encoders=[],this.decoders=[],this.register(W5)}register({type:W,encode:Q,decode:J}){if(W>=0)this.encoders[W]=Q,this.decoders[W]=J;else{const V=-1-W;this.builtInEncoders[V]=Q,this.builtInDecoders[V]=J}}tryToEncode(W,Q){for(let J=0;J<this.builtInEncoders.length;J++){const V=this.builtInEncoders[J];if(V!=null){const G=V(W,Q);if(G!=null){const X=-1-J;return new Q1(X,G)}}}for(let J=0;J<this.encoders.length;J++){const V=this.encoders[J];if(V!=null){const G=V(W,Q);if(G!=null)return new Q1(J,G)}}if(W instanceof Q1)return W;return null}decode(W,Q,J){const V=Q<0?this.builtInDecoders[-1-Q]:this.decoders[Q];if(V)return V(W,Q,J);else return new Q1(Q,W)}}u0.defaultCodec=new u0;var eW=function(W){return W instanceof ArrayBuffer||typeof SharedArrayBuffer!=="undefined"&&W instanceof SharedArrayBuffer};function D1(W){if(W instanceof Uint8Array)return W;else if(ArrayBuffer.isView(W))return new Uint8Array(W.buffer,W.byteOffset,W.byteLength);else if(eW(W))return new Uint8Array(W);else return Uint8Array.from(W)}var tW=100,WJ=2048;class J8{constructor(W){this.entered=!1,this.extensionCodec=W?.extensionCodec??u0.defaultCodec,this.context=W?.context,this.useBigInt64=W?.useBigInt64??!1,this.maxDepth=W?.maxDepth??tW,this.initialBufferSize=W?.initialBufferSize??WJ,this.sortKeys=W?.sortKeys??!1,this.forceFloat32=W?.forceFloat32??!1,this.ignoreUndefined=W?.ignoreUndefined??!1,this.forceIntegerToFloat=W?.forceIntegerToFloat??!1,this.pos=0,this.view=new DataView(new ArrayBuffer(this.initialBufferSize)),this.bytes=new Uint8Array(this.view.buffer)}clone(){return new J8({extensionCodec:this.extensionCodec,context:this.context,useBigInt64:this.useBigInt64,maxDepth:this.maxDepth,initialBufferSize:this.initialBufferSize,sortKeys:this.sortKeys,forceFloat32:this.forceFloat32,ignoreUndefined:this.ignoreUndefined,forceIntegerToFloat:this.forceIntegerToFloat})}reinitializeState(){this.pos=0}encodeSharedRef(W){if(this.entered)return this.clone().encodeSharedRef(W);try{return this.entered=!0,this.reinitializeState(),this.doEncode(W,1),this.bytes.subarray(0,this.pos)}finally{this.entered=!1}}encode(W){if(this.entered)return this.clone().encode(W);try{return this.entered=!0,this.reinitializeState(),this.doEncode(W,1),this.bytes.slice(0,this.pos)}finally{this.entered=!1}}doEncode(W,Q){if(Q>this.maxDepth)throw new Error(`Too deep objects in depth ${Q}`);if(W==null)this.encodeNil();else if(typeof W==="boolean")this.encodeBoolean(W);else if(typeof W==="number")if(!this.forceIntegerToFloat)this.encodeNumber(W);else this.encodeNumberAsFloat(W);else if(typeof W==="string")this.encodeString(W);else if(this.useBigInt64&&typeof W==="bigint")this.encodeBigInt64(W);else this.encodeObject(W,Q)}ensureBufferSizeToWrite(W){const Q=this.pos+W;if(this.view.byteLength<Q)this.resizeBuffer(Q*2)}resizeBuffer(W){const Q=new ArrayBuffer(W),J=new Uint8Array(Q),V=new DataView(Q);J.set(this.bytes),this.view=V,this.bytes=J}encodeNil(){this.writeU8(192)}encodeBoolean(W){if(W===!1)this.writeU8(194);else this.writeU8(195)}encodeNumber(W){if(!this.forceIntegerToFloat&&Number.isSafeInteger(W))if(W>=0)if(W<128)this.writeU8(W);else if(W<256)this.writeU8(204),this.writeU8(W);else if(W<65536)this.writeU8(205),this.writeU16(W);else if(W<4294967296)this.writeU8(206),this.writeU32(W);else if(!this.useBigInt64)this.writeU8(207),this.writeU64(W);else this.encodeNumberAsFloat(W);else if(W>=-32)this.writeU8(224|W+32);else if(W>=-128)this.writeU8(208),this.writeI8(W);else if(W>=-32768)this.writeU8(209),this.writeI16(W);else if(W>=-2147483648)this.writeU8(210),this.writeI32(W);else if(!this.useBigInt64)this.writeU8(211),this.writeI64(W);else this.encodeNumberAsFloat(W);else this.encodeNumberAsFloat(W)}encodeNumberAsFloat(W){if(this.forceFloat32)this.writeU8(202),this.writeF32(W);else this.writeU8(203),this.writeF64(W)}encodeBigInt64(W){if(W>=BigInt(0))this.writeU8(207),this.writeBigUint64(W);else this.writeU8(211),this.writeBigInt64(W)}writeStringHeader(W){if(W<32)this.writeU8(160+W);else if(W<256)this.writeU8(217),this.writeU8(W);else if(W<65536)this.writeU8(218),this.writeU16(W);else if(W<4294967296)this.writeU8(219),this.writeU32(W);else throw new Error(`Too long string: ${W} bytes in UTF-8`)}encodeString(W){const J=o6(W);this.ensureBufferSizeToWrite(5+J),this.writeStringHeader(J),a6(W,this.bytes,this.pos),this.pos+=J}encodeObject(W,Q){const J=this.extensionCodec.tryToEncode(W,this.context);if(J!=null)this.encodeExtension(J);else if(Array.isArray(W))this.encodeArray(W,Q);else if(ArrayBuffer.isView(W))this.encodeBinary(W);else if(typeof W==="object")this.encodeMap(W,Q);else throw new Error(`Unrecognized object: ${Object.prototype.toString.apply(W)}`)}encodeBinary(W){const Q=W.byteLength;if(Q<256)this.writeU8(196),this.writeU8(Q);else if(Q<65536)this.writeU8(197),this.writeU16(Q);else if(Q<4294967296)this.writeU8(198),this.writeU32(Q);else throw new Error(`Too large binary: ${Q}`);const J=D1(W);this.writeU8a(J)}encodeArray(W,Q){const J=W.length;if(J<16)this.writeU8(144+J);else if(J<65536)this.writeU8(220),this.writeU16(J);else if(J<4294967296)this.writeU8(221),this.writeU32(J);else throw new Error(`Too large array: ${J}`);for(let V of W)this.doEncode(V,Q+1)}countWithoutUndefined(W,Q){let J=0;for(let V of Q)if(W[V]!==void 0)J++;return J}encodeMap(W,Q){const J=Object.keys(W);if(this.sortKeys)J.sort();const V=this.ignoreUndefined?this.countWithoutUndefined(W,J):J.length;if(V<16)this.writeU8(128+V);else if(V<65536)this.writeU8(222),this.writeU16(V);else if(V<4294967296)this.writeU8(223),this.writeU32(V);else throw new Error(`Too large map object: ${V}`);for(let G of J){const X=W[G];if(!(this.ignoreUndefined&&X===void 0))this.encodeString(G),this.doEncode(X,Q+1)}}encodeExtension(W){if(typeof W.data==="function"){const J=W.data(this.pos+6),V=J.length;if(V>=4294967296)throw new Error(`Too large extension object: ${V}`);this.writeU8(201),this.writeU32(V),this.writeI8(W.type),this.writeU8a(J);return}const Q=W.data.length;if(Q===1)this.writeU8(212);else if(Q===2)this.writeU8(213);else if(Q===4)this.writeU8(214);else if(Q===8)this.writeU8(215);else if(Q===16)this.writeU8(216);else if(Q<256)this.writeU8(199),this.writeU8(Q);else if(Q<65536)this.writeU8(200),this.writeU16(Q);else if(Q<4294967296)this.writeU8(201),this.writeU32(Q);else throw new Error(`Too large extension object: ${Q}`);this.writeI8(W.type),this.writeU8a(W.data)}writeU8(W){this.ensureBufferSizeToWrite(1),this.view.setUint8(this.pos,W),this.pos++}writeU8a(W){const Q=W.length;this.ensureBufferSizeToWrite(Q),this.bytes.set(W,this.pos),this.pos+=Q}writeI8(W){this.ensureBufferSizeToWrite(1),this.view.setInt8(this.pos,W),this.pos++}writeU16(W){this.ensureBufferSizeToWrite(2),this.view.setUint16(this.pos,W),this.pos+=2}writeI16(W){this.ensureBufferSizeToWrite(2),this.view.setInt16(this.pos,W),this.pos+=2}writeU32(W){this.ensureBufferSizeToWrite(4),this.view.setUint32(this.pos,W),this.pos+=4}writeI32(W){this.ensureBufferSizeToWrite(4),this.view.setInt32(this.pos,W),this.pos+=4}writeF32(W){this.ensureBufferSizeToWrite(4),this.view.setFloat32(this.pos,W),this.pos+=4}writeF64(W){this.ensureBufferSizeToWrite(8),this.view.setFloat64(this.pos,W),this.pos+=8}writeU64(W){this.ensureBufferSizeToWrite(8),e6(this.view,this.pos,W),this.pos+=8}writeI64(W){this.ensureBufferSizeToWrite(8),t1(this.view,this.pos,W),this.pos+=8}writeBigUint64(W){this.ensureBufferSizeToWrite(8),this.view.setBigUint64(this.pos,W),this.pos+=8}writeBigInt64(W){this.ensureBufferSizeToWrite(8),this.view.setBigInt64(this.pos,W),this.pos+=8}}function G1(W,Q){return new J8(Q).encodeSharedRef(W)}function Q8(W){return`${W<0?"-":""}0x${Math.abs(W).toString(16).padStart(2,"0")}`}var JJ=16,QJ=16;class f8{constructor(W=JJ,Q=QJ){this.hit=0,this.miss=0,this.maxKeyLength=W,this.maxLengthPerKey=Q,this.caches=[];for(let J=0;J<this.maxKeyLength;J++)this.caches.push([])}canBeCached(W){return W>0&&W<=this.maxKeyLength}find(W,Q,J){const V=this.caches[J-1];W:for(let G of V){const X=G.bytes;for(let Y=0;Y<J;Y++)if(X[Y]!==W[Q+Y])continue W;return G.str}return null}store(W,Q){const J=this.caches[W.length-1],V={bytes:W,str:Q};if(J.length>=this.maxLengthPerKey)J[Math.random()*J.length|0]=V;else J.push(V)}decode(W,Q,J){const V=this.find(W,Q,J);if(V!=null)return this.hit++,V;this.miss++;const G=y8(W,Q,J),X=Uint8Array.prototype.slice.call(W,Q,Q+J);return this.store(X,G),G}}var p8="array",x1="map_key",Q5="map_value",VJ=(W)=>{if(typeof W==="string"||typeof W==="number")return W;throw new Y0("The type of key must be string or number but "+typeof W)};class V5{constructor(){this.stack=[],this.stackHeadPosition=-1}get length(){return this.stackHeadPosition+1}top(){return this.stack[this.stackHeadPosition]}pushArrayState(W){const Q=this.getUninitializedStateFromPool();Q.type=p8,Q.position=0,Q.size=W,Q.array=new Array(W)}pushMapState(W){const Q=this.getUninitializedStateFromPool();Q.type=x1,Q.readCount=0,Q.size=W,Q.map={}}getUninitializedStateFromPool(){if(this.stackHeadPosition++,this.stackHeadPosition===this.stack.length){const W={type:void 0,size:0,array:void 0,position:0,readCount:0,map:void 0,key:null};this.stack.push(W)}return this.stack[this.stackHeadPosition]}release(W){if(this.stack[this.stackHeadPosition]!==W)throw new Error("Invalid stack state. Released state is not on top of the stack.");if(W.type===p8){const J=W;J.size=0,J.array=void 0,J.position=0,J.type=void 0}if(W.type===x1||W.type===Q5){const J=W;J.size=0,J.map=void 0,J.readCount=0,J.type=void 0}this.stackHeadPosition--}reset(){this.stack.length=0,this.stackHeadPosition=-1}}var O1=-1,b8=new DataView(new ArrayBuffer(0)),GJ=new Uint8Array(b8.buffer);try{b8.getInt8(0)}catch(W){if(!(W instanceof RangeError))throw new Error("This module is not supported in the current JavaScript engine because DataView does not throw RangeError on out-of-bounds access")}var J5=new RangeError("Insufficient data"),XJ=new f8;class V8{constructor(W){this.totalPos=0,this.pos=0,this.view=b8,this.bytes=GJ,this.headByte=O1,this.stack=new V5,this.entered=!1,this.extensionCodec=W?.extensionCodec??u0.defaultCodec,this.context=W?.context,this.useBigInt64=W?.useBigInt64??!1,this.rawStrings=W?.rawStrings??!1,this.maxStrLength=W?.maxStrLength??V1,this.maxBinLength=W?.maxBinLength??V1,this.maxArrayLength=W?.maxArrayLength??V1,this.maxMapLength=W?.maxMapLength??V1,this.maxExtLength=W?.maxExtLength??V1,this.keyDecoder=W?.keyDecoder!==void 0?W.keyDecoder:XJ,this.mapKeyConverter=W?.mapKeyConverter??VJ}clone(){return new V8({extensionCodec:this.extensionCodec,context:this.context,useBigInt64:this.useBigInt64,rawStrings:this.rawStrings,maxStrLength:this.maxStrLength,maxBinLength:this.maxBinLength,maxArrayLength:this.maxArrayLength,maxMapLength:this.maxMapLength,maxExtLength:this.maxExtLength,keyDecoder:this.keyDecoder})}reinitializeState(){this.totalPos=0,this.headByte=O1,this.stack.reset()}setBuffer(W){const Q=D1(W);this.bytes=Q,this.view=new DataView(Q.buffer,Q.byteOffset,Q.byteLength),this.pos=0}appendBuffer(W){if(this.headByte===O1&&!this.hasRemaining(1))this.setBuffer(W);else{const Q=this.bytes.subarray(this.pos),J=D1(W),V=new Uint8Array(Q.length+J.length);V.set(Q),V.set(J,Q.length),this.setBuffer(V)}}hasRemaining(W){return this.view.byteLength-this.pos>=W}createExtraByteError(W){const{view:Q,pos:J}=this;return new RangeError(`Extra ${Q.byteLength-J} of ${Q.byteLength} byte(s) found at buffer[${W}]`)}decode(W){if(this.entered)return this.clone().decode(W);try{this.entered=!0,this.reinitializeState(),this.setBuffer(W);const Q=this.doDecodeSync();if(this.hasRemaining(1))throw this.createExtraByteError(this.pos);return Q}finally{this.entered=!1}}*decodeMulti(W){if(this.entered){yield*this.clone().decodeMulti(W);return}try{this.entered=!0,this.reinitializeState(),this.setBuffer(W);while(this.hasRemaining(1))yield this.doDecodeSync()}finally{this.entered=!1}}async decodeAsync(W){if(this.entered)return this.clone().decodeAsync(W);try{this.entered=!0;let Q=!1,J;for await(let Y of W){if(Q)throw this.entered=!1,this.createExtraByteError(this.totalPos);this.appendBuffer(Y);try{J=this.doDecodeSync(),Q=!0}catch(q){if(!(q instanceof RangeError))throw q}this.totalPos+=this.pos}if(Q){if(this.hasRemaining(1))throw this.createExtraByteError(this.totalPos);return J}const{headByte:V,pos:G,totalPos:X}=this;throw new RangeError(`Insufficient data in parsing ${Q8(V)} at ${X} (${G} in the current buffer)`)}finally{this.entered=!1}}decodeArrayStream(W){return this.decodeMultiAsync(W,!0)}decodeStream(W){return this.decodeMultiAsync(W,!1)}async*decodeMultiAsync(W,Q){if(this.entered){yield*this.clone().decodeMultiAsync(W,Q);return}try{this.entered=!0;let J=Q,V=-1;for await(let G of W){if(Q&&V===0)throw this.createExtraByteError(this.totalPos);if(this.appendBuffer(G),J)V=this.readArraySize(),J=!1,this.complete();try{while(!0)if(yield this.doDecodeSync(),--V===0)break}catch(X){if(!(X instanceof RangeError))throw X}this.totalPos+=this.pos}}finally{this.entered=!1}}doDecodeSync(){W:while(!0){const W=this.readHeadByte();let Q;if(W>=224)Q=W-256;else if(W<192)if(W<128)Q=W;else if(W<144){const V=W-128;if(V!==0){this.pushMapState(V),this.complete();continue W}else Q={}}else if(W<160){const V=W-144;if(V!==0){this.pushArrayState(V),this.complete();continue W}else Q=[]}else{const V=W-160;Q=this.decodeString(V,0)}else if(W===192)Q=null;else if(W===194)Q=!1;else if(W===195)Q=!0;else if(W===202)Q=this.readF32();else if(W===203)Q=this.readF64();else if(W===204)Q=this.readU8();else if(W===205)Q=this.readU16();else if(W===206)Q=this.readU32();else if(W===207)if(this.useBigInt64)Q=this.readU64AsBigInt();else Q=this.readU64();else if(W===208)Q=this.readI8();else if(W===209)Q=this.readI16();else if(W===210)Q=this.readI32();else if(W===211)if(this.useBigInt64)Q=this.readI64AsBigInt();else Q=this.readI64();else if(W===217){const V=this.lookU8();Q=this.decodeString(V,1)}else if(W===218){const V=this.lookU16();Q=this.decodeString(V,2)}else if(W===219){const V=this.lookU32();Q=this.decodeString(V,4)}else if(W===220){const V=this.readU16();if(V!==0){this.pushArrayState(V),this.complete();continue W}else Q=[]}else if(W===221){const V=this.readU32();if(V!==0){this.pushArrayState(V),this.complete();continue W}else Q=[]}else if(W===222){const V=this.readU16();if(V!==0){this.pushMapState(V),this.complete();continue W}else Q={}}else if(W===223){const V=this.readU32();if(V!==0){this.pushMapState(V),this.complete();continue W}else Q={}}else if(W===196){const V=this.lookU8();Q=this.decodeBinary(V,1)}else if(W===197){const V=this.lookU16();Q=this.decodeBinary(V,2)}else if(W===198){const V=this.lookU32();Q=this.decodeBinary(V,4)}else if(W===212)Q=this.decodeExtension(1,0);else if(W===213)Q=this.decodeExtension(2,0);else if(W===214)Q=this.decodeExtension(4,0);else if(W===215)Q=this.decodeExtension(8,0);else if(W===216)Q=this.decodeExtension(16,0);else if(W===199){const V=this.lookU8();Q=this.decodeExtension(V,1)}else if(W===200){const V=this.lookU16();Q=this.decodeExtension(V,2)}else if(W===201){const V=this.lookU32();Q=this.decodeExtension(V,4)}else throw new Y0(`Unrecognized type byte: ${Q8(W)}`);this.complete();const J=this.stack;while(J.length>0){const V=J.top();if(V.type===p8)if(V.array[V.position]=Q,V.position++,V.position===V.size)Q=V.array,J.release(V);else continue W;else if(V.type===x1){if(Q==="__proto__")throw new Y0("The key __proto__ is not allowed");V.key=this.mapKeyConverter(Q),V.type=Q5;continue W}else if(V.map[V.key]=Q,V.readCount++,V.readCount===V.size)Q=V.map,J.release(V);else{V.key=null,V.type=x1;continue W}}return Q}}readHeadByte(){if(this.headByte===O1)this.headByte=this.readU8();return this.headByte}complete(){this.headByte=O1}readArraySize(){const W=this.readHeadByte();switch(W){case 220:return this.readU16();case 221:return this.readU32();default:if(W<160)return W-144;else throw new Y0(`Unrecognized array type byte: ${Q8(W)}`)}}pushMapState(W){if(W>this.maxMapLength)throw new Y0(`Max length exceeded: map length (${W}) > maxMapLengthLength (${this.maxMapLength})`);this.stack.pushMapState(W)}pushArrayState(W){if(W>this.maxArrayLength)throw new Y0(`Max length exceeded: array length (${W}) > maxArrayLength (${this.maxArrayLength})`);this.stack.pushArrayState(W)}decodeString(W,Q){if(!this.rawStrings||this.stateIsMapKey())return this.decodeUtf8String(W,Q);return this.decodeBinary(W,Q)}decodeUtf8String(W,Q){if(W>this.maxStrLength)throw new Y0(`Max length exceeded: UTF-8 byte length (${W}) > maxStrLength (${this.maxStrLength})`);if(this.bytes.byteLength<this.pos+Q+W)throw J5;const J=this.pos+Q;let V;if(this.stateIsMapKey()&&this.keyDecoder?.canBeCached(W))V=this.keyDecoder.decode(this.bytes,J,W);else V=s6(this.bytes,J,W);return this.pos+=Q+W,V}stateIsMapKey(){if(this.stack.length>0)return this.stack.top().type===x1;return!1}decodeBinary(W,Q){if(W>this.maxBinLength)throw new Y0(`Max length exceeded: bin length (${W}) > maxBinLength (${this.maxBinLength})`);if(!this.hasRemaining(W+Q))throw J5;const J=this.pos+Q,V=this.bytes.subarray(J,J+W);return this.pos+=Q+W,V}decodeExtension(W,Q){if(W>this.maxExtLength)throw new Y0(`Max length exceeded: ext length (${W}) > maxExtLength (${this.maxExtLength})`);const J=this.view.getInt8(this.pos+Q),V=this.decodeBinary(W,Q+1);return this.extensionCodec.decode(V,J,this.context)}lookU8(){return this.view.getUint8(this.pos)}lookU16(){return this.view.getUint16(this.pos)}lookU32(){return this.view.getUint32(this.pos)}readU8(){const W=this.view.getUint8(this.pos);return this.pos++,W}readI8(){const W=this.view.getInt8(this.pos);return this.pos++,W}readU16(){const W=this.view.getUint16(this.pos);return this.pos+=2,W}readI16(){const W=this.view.getInt16(this.pos);return this.pos+=2,W}readU32(){const W=this.view.getUint32(this.pos);return this.pos+=4,W}readI32(){const W=this.view.getInt32(this.pos);return this.pos+=4,W}readU64(){const W=t6(this.view,this.pos);return this.pos+=8,W}readI64(){const W=W8(this.view,this.pos);return this.pos+=8,W}readU64AsBigInt(){const W=this.view.getBigUint64(this.pos);return this.pos+=8,W}readI64AsBigInt(){const W=this.view.getBigInt64(this.pos);return this.pos+=8,W}readF32(){const W=this.view.getFloat32(this.pos);return this.pos+=4,W}readF64(){const W=this.view.getFloat64(this.pos);return this.pos+=8,W}}function w1(W,Q){return new V8(Q).decode(W)}var K1=function(W){let Q=W.length;while(--Q>=0)W[Q]=0},u8=function(W,Q,J,V,G){this.static_tree=W,this.extra_bits=Q,this.extra_base=J,this.elems=V,this.max_length=G,this.has_stree=W&&W.length},m8=function(W,Q){this.dyn_tree=W,this.max_code=0,this.stat_desc=Q},j0=function(W,Q,J,V,G){this.good_length=W,this.max_lazy=Q,this.nice_length=J,this.max_chain=V,this.func=G},q9=function(){this.strm=null,this.status=0,this.pending_buf=null,this.pending_buf_size=0,this.pending_out=0,this.pending=0,this.wrap=0,this.gzhead=null,this.gzindex=0,this.method=Z8,this.last_flush=-1,this.w_size=0,this.w_bits=0,this.w_mask=0,this.window=null,this.window_size=0,this.prev=null,this.head=null,this.ins_h=0,this.hash_size=0,this.hash_bits=0,this.hash_mask=0,this.hash_shift=0,this.block_start=0,this.match_length=0,this.prev_match=0,this.match_available=0,this.strstart=0,this.match_start=0,this.lookahead=0,this.prev_length=0,this.max_chain_length=0,this.max_lazy_match=0,this.level=0,this.strategy=0,this.good_match=0,this.nice_match=0,this.dyn_ltree=new Uint16Array(eJ*2),this.dyn_dtree=new Uint16Array((2*aJ+1)*2),this.bl_tree=new Uint16Array((2*sJ+1)*2),g0(this.dyn_ltree),g0(this.dyn_dtree),g0(this.bl_tree),this.l_desc=null,this.d_desc=null,this.bl_desc=null,this.bl_count=new Uint16Array(tJ+1),this.heap=new Uint16Array(2*Q6+1),g0(this.heap),this.heap_len=0,this.heap_max=0,this.depth=new Uint16Array(2*Q6+1),g0(this.depth),this.sym_buf=0,this.lit_bufsize=0,this.sym_next=0,this.sym_end=0,this.opt_len=0,this.static_len=0,this.matches=0,this.insert=0,this.bi_buf=0,this.bi_valid=0},S9=function(){this.input=null,this.next_in=0,this.avail_in=0,this.total_in=0,this.output=null,this.next_out=0,this.avail_out=0,this.total_out=0,this.msg="",this.state=null,this.data_type=2,this.adler=0},d1=function(W){this.options=H8.assign({level:y9,method:p9,chunkSize:16384,windowBits:15,memLevel:8,strategy:f9},W||{});let Q=this.options;if(Q.raw&&Q.windowBits>0)Q.windowBits=-Q.windowBits;else if(Q.gzip&&Q.windowBits>0&&Q.windowBits<16)Q.windowBits+=16;this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new P7,this.strm.avail_out=0;let J=T1.deflateInit2(this.strm,Q.level,Q.method,Q.windowBits,Q.memLevel,Q.strategy);if(J!==F8)throw new Error(d0[J]);if(Q.header)T1.deflateSetHeader(this.strm,Q.header);if(Q.dictionary){let V;if(typeof Q.dictionary==="string")V=u1.string2buf(Q.dictionary);else if(K7.call(Q.dictionary)==="[object ArrayBuffer]")V=new Uint8Array(Q.dictionary);else V=Q.dictionary;if(J=T1.deflateSetDictionary(this.strm,V),J!==F8)throw new Error(d0[J]);this._dict_set=!0}},Z6=function(W,Q){const J=new d1(Q);if(J.push(W,!0),J.err)throw J.msg||d0[J.err];return J.result},b9=function(W,Q){return Q=Q||{},Q.raw=!0,Z6(W,Q)},h9=function(W,Q){return Q=Q||{},Q.gzip=!0,Z6(W,Q)},UQ=function(){this.strm=null,this.mode=0,this.last=!1,this.wrap=0,this.havedict=!1,this.flags=0,this.dmax=0,this.check=0,this.total=0,this.head=null,this.wbits=0,this.wsize=0,this.whave=0,this.wnext=0,this.window=null,this.hold=0,this.bits=0,this.length=0,this.offset=0,this.extra=0,this.lencode=null,this.distcode=null,this.lenbits=0,this.distbits=0,this.ncode=0,this.nlen=0,this.ndist=0,this.have=0,this.next=null,this.lens=new Uint16Array(320),this.work=new Uint16Array(288),this.lendyn=null,this.distdyn=null,this.sane=0,this.back=0,this.was=0},OQ=function(){this.text=0,this.time=0,this.xflags=0,this.os=0,this.extra=null,this.extra_len=0,this.name="",this.comment="",this.hcrc=0,this.done=!1},l1=function(W){this.options=H8.assign({chunkSize:65536,windowBits:15,to:""},W||{});const Q=this.options;if(Q.raw&&Q.windowBits>=0&&Q.windowBits<16){if(Q.windowBits=-Q.windowBits,Q.windowBits===0)Q.windowBits=-15}if(Q.windowBits>=0&&Q.windowBits<16&&!(W&&W.windowBits))Q.windowBits+=32;if(Q.windowBits>15&&Q.windowBits<48){if((Q.windowBits&15)===0)Q.windowBits|=15}this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new P7,this.strm.avail_out=0;let J=x0.inflateInit2(this.strm,Q.windowBits);if(J!==m1)throw new Error(d0[J]);if(this.header=new xQ,x0.inflateGetHeader(this.strm,this.header),Q.dictionary){if(typeof Q.dictionary==="string")Q.dictionary=u1.string2buf(Q.dictionary);else if(L7.call(Q.dictionary)==="[object ArrayBuffer]")Q.dictionary=new Uint8Array(Q.dictionary);if(Q.raw){if(J=x0.inflateSetDictionary(this.strm,Q.dictionary),J!==m1)throw new Error(d0[J])}}},H6=function(W,Q){const J=new l1(Q);if(J.push(W),J.err)throw J.msg||d0[J.err];return J.result},AQ=function(W,Q){return Q=Q||{},Q.raw=!0,H6(W,Q)};/*! pako 2.1.0 https://github.com/nodeca/pako @license (MIT AND Zlib) */var YJ=0,_5=1,qJ=2,UJ=3,PJ=258,U6=29,_1=256,E1=_1+1+U6,q1=30,P6=19,c5=2*E1+1,m0=15,h8=16,KJ=7,K6=256,d5=16,l5=17,i5=18,t8=new Uint8Array([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0]),P8=new Uint8Array([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13]),FJ=new Uint8Array([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7]),r5=new Uint8Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),zJ=512,O0=new Array((E1+2)*2);K1(O0);var A1=new Array(q1*2);K1(A1);var y1=new Array(zJ);K1(y1);var f1=new Array(PJ-UJ+1);K1(f1);var F6=new Array(U6);K1(F6);var K8=new Array(q1);K1(K8);var n5,o5,a5,s5=(W)=>{return W<256?y1[W]:y1[256+(W>>>7)]},p1=(W,Q)=>{W.pending_buf[W.pending++]=Q&255,W.pending_buf[W.pending++]=Q>>>8&255},P0=(W,Q,J)=>{if(W.bi_valid>h8-J)W.bi_buf|=Q<<W.bi_valid&65535,p1(W,W.bi_buf),W.bi_buf=Q>>h8-W.bi_valid,W.bi_valid+=J-h8;else W.bi_buf|=Q<<W.bi_valid&65535,W.bi_valid+=J},B0=(W,Q,J)=>{P0(W,J[Q*2],J[Q*2+1])},e5=(W,Q)=>{let J=0;do J|=W&1,W>>>=1,J<<=1;while(--Q>0);return J>>>1},ZJ=(W)=>{if(W.bi_valid===16)p1(W,W.bi_buf),W.bi_buf=0,W.bi_valid=0;else if(W.bi_valid>=8)W.pending_buf[W.pending++]=W.bi_buf&255,W.bi_buf>>=8,W.bi_valid-=8},HJ=(W,Q)=>{const{dyn_tree:J,max_code:V}=Q,G=Q.stat_desc.static_tree,X=Q.stat_desc.has_stree,Y=Q.stat_desc.extra_bits,q=Q.stat_desc.extra_base,F=Q.stat_desc.max_length;let U,K,$,P,z,C,S=0;for(P=0;P<=m0;P++)W.bl_count[P]=0;J[W.heap[W.heap_max]*2+1]=0;for(U=W.heap_max+1;U<c5;U++){if(K=W.heap[U],P=J[J[K*2+1]*2+1]+1,P>F)P=F,S++;if(J[K*2+1]=P,K>V)continue;if(W.bl_count[P]++,z=0,K>=q)z=Y[K-q];if(C=J[K*2],W.opt_len+=C*(P+z),X)W.static_len+=C*(G[K*2+1]+z)}if(S===0)return;do{P=F-1;while(W.bl_count[P]===0)P--;W.bl_count[P]--,W.bl_count[P+1]+=2,W.bl_count[F]--,S-=2}while(S>0);for(P=F;P!==0;P--){K=W.bl_count[P];while(K!==0){if($=W.heap[--U],$>V)continue;if(J[$*2+1]!==P)W.opt_len+=(P-J[$*2+1])*J[$*2],J[$*2+1]=P;K--}}},t5=(W,Q,J)=>{const V=new Array(m0+1);let G=0,X,Y;for(X=1;X<=m0;X++)G=G+J[X-1]<<1,V[X]=G;for(Y=0;Y<=Q;Y++){let q=W[Y*2+1];if(q===0)continue;W[Y*2]=e5(V[q]++,q)}},kJ=()=>{let W,Q,J,V,G;const X=new Array(m0+1);J=0;for(V=0;V<U6-1;V++){F6[V]=J;for(W=0;W<1<<t8[V];W++)f1[J++]=V}f1[J-1]=V,G=0;for(V=0;V<16;V++){K8[V]=G;for(W=0;W<1<<P8[V];W++)y1[G++]=V}G>>=7;for(;V<q1;V++){K8[V]=G<<7;for(W=0;W<1<<P8[V]-7;W++)y1[256+G++]=V}for(Q=0;Q<=m0;Q++)X[Q]=0;W=0;while(W<=143)O0[W*2+1]=8,W++,X[8]++;while(W<=255)O0[W*2+1]=9,W++,X[9]++;while(W<=279)O0[W*2+1]=7,W++,X[7]++;while(W<=287)O0[W*2+1]=8,W++,X[8]++;t5(O0,E1+1,X);for(W=0;W<q1;W++)A1[W*2+1]=5,A1[W*2]=e5(W,5);n5=new u8(O0,t8,_1+1,E1,m0),o5=new u8(A1,P8,0,q1,m0),a5=new u8(new Array(0),FJ,0,P6,KJ)},W7=(W)=>{let Q;for(Q=0;Q<E1;Q++)W.dyn_ltree[Q*2]=0;for(Q=0;Q<q1;Q++)W.dyn_dtree[Q*2]=0;for(Q=0;Q<P6;Q++)W.bl_tree[Q*2]=0;W.dyn_ltree[K6*2]=1,W.opt_len=W.static_len=0,W.sym_next=W.matches=0},J7=(W)=>{if(W.bi_valid>8)p1(W,W.bi_buf);else if(W.bi_valid>0)W.pending_buf[W.pending++]=W.bi_buf;W.bi_buf=0,W.bi_valid=0},G5=(W,Q,J,V)=>{const G=Q*2,X=J*2;return W[G]<W[X]||W[G]===W[X]&&V[Q]<=V[J]},_8=(W,Q,J)=>{const V=W.heap[J];let G=J<<1;while(G<=W.heap_len){if(G<W.heap_len&&G5(Q,W.heap[G+1],W.heap[G],W.depth))G++;if(G5(Q,V,W.heap[G],W.depth))break;W.heap[J]=W.heap[G],J=G,G<<=1}W.heap[J]=V},X5=(W,Q,J)=>{let V,G,X=0,Y,q;if(W.sym_next!==0)do if(V=W.pending_buf[W.sym_buf+X++]&255,V+=(W.pending_buf[W.sym_buf+X++]&255)<<8,G=W.pending_buf[W.sym_buf+X++],V===0)B0(W,G,Q);else{if(Y=f1[G],B0(W,Y+_1+1,Q),q=t8[Y],q!==0)G-=F6[Y],P0(W,G,q);if(V--,Y=s5(V),B0(W,Y,J),q=P8[Y],q!==0)V-=K8[Y],P0(W,V,q)}while(X<W.sym_next);B0(W,K6,Q)},W6=(W,Q)=>{const J=Q.dyn_tree,V=Q.stat_desc.static_tree,G=Q.stat_desc.has_stree,X=Q.stat_desc.elems;let Y,q,F=-1,U;W.heap_len=0,W.heap_max=c5;for(Y=0;Y<X;Y++)if(J[Y*2]!==0)W.heap[++W.heap_len]=F=Y,W.depth[Y]=0;else J[Y*2+1]=0;while(W.heap_len<2)if(U=W.heap[++W.heap_len]=F<2?++F:0,J[U*2]=1,W.depth[U]=0,W.opt_len--,G)W.static_len-=V[U*2+1];Q.max_code=F;for(Y=W.heap_len>>1;Y>=1;Y--)_8(W,J,Y);U=X;do Y=W.heap[1],W.heap[1]=W.heap[W.heap_len--],_8(W,J,1),q=W.heap[1],W.heap[--W.heap_max]=Y,W.heap[--W.heap_max]=q,J[U*2]=J[Y*2]+J[q*2],W.depth[U]=(W.depth[Y]>=W.depth[q]?W.depth[Y]:W.depth[q])+1,J[Y*2+1]=J[q*2+1]=U,W.heap[1]=U++,_8(W,J,1);while(W.heap_len>=2);W.heap[--W.heap_max]=W.heap[1],HJ(W,Q),t5(J,F,W.bl_count)},Y5=(W,Q,J)=>{let V,G=-1,X,Y=Q[1],q=0,F=7,U=4;if(Y===0)F=138,U=3;Q[(J+1)*2+1]=65535;for(V=0;V<=J;V++){if(X=Y,Y=Q[(V+1)*2+1],++q<F&&X===Y)continue;else if(q<U)W.bl_tree[X*2]+=q;else if(X!==0){if(X!==G)W.bl_tree[X*2]++;W.bl_tree[d5*2]++}else if(q<=10)W.bl_tree[l5*2]++;else W.bl_tree[i5*2]++;if(q=0,G=X,Y===0)F=138,U=3;else if(X===Y)F=6,U=3;else F=7,U=4}},q5=(W,Q,J)=>{let V,G=-1,X,Y=Q[1],q=0,F=7,U=4;if(Y===0)F=138,U=3;for(V=0;V<=J;V++){if(X=Y,Y=Q[(V+1)*2+1],++q<F&&X===Y)continue;else if(q<U)do B0(W,X,W.bl_tree);while(--q!==0);else if(X!==0){if(X!==G)B0(W,X,W.bl_tree),q--;B0(W,d5,W.bl_tree),P0(W,q-3,2)}else if(q<=10)B0(W,l5,W.bl_tree),P0(W,q-3,3);else B0(W,i5,W.bl_tree),P0(W,q-11,7);if(q=0,G=X,Y===0)F=138,U=3;else if(X===Y)F=6,U=3;else F=7,U=4}},$J=(W)=>{let Q;Y5(W,W.dyn_ltree,W.l_desc.max_code),Y5(W,W.dyn_dtree,W.d_desc.max_code),W6(W,W.bl_desc);for(Q=P6-1;Q>=3;Q--)if(W.bl_tree[r5[Q]*2+1]!==0)break;return W.opt_len+=3*(Q+1)+5+5+4,Q},CJ=(W,Q,J,V)=>{let G;P0(W,Q-257,5),P0(W,J-1,5),P0(W,V-4,4);for(G=0;G<V;G++)P0(W,W.bl_tree[r5[G]*2+1],3);q5(W,W.dyn_ltree,Q-1),q5(W,W.dyn_dtree,J-1)},jJ=(W)=>{let Q=4093624447,J;for(J=0;J<=31;J++,Q>>>=1)if(Q&1&&W.dyn_ltree[J*2]!==0)return 0;if(W.dyn_ltree[18]!==0||W.dyn_ltree[20]!==0||W.dyn_ltree[26]!==0)return 1;for(J=32;J<_1;J++)if(W.dyn_ltree[J*2]!==0)return 1;return 0},U5=!1,BJ=(W)=>{if(!U5)kJ(),U5=!0;W.l_desc=new m8(W.dyn_ltree,n5),W.d_desc=new m8(W.dyn_dtree,o5),W.bl_desc=new m8(W.bl_tree,a5),W.bi_buf=0,W.bi_valid=0,W7(W)},Q7=(W,Q,J,V)=>{if(P0(W,(YJ<<1)+(V?1:0),3),J7(W),p1(W,J),p1(W,~J),J)W.pending_buf.set(W.window.subarray(Q,Q+J),W.pending);W.pending+=J},RJ=(W)=>{P0(W,_5<<1,3),B0(W,K6,O0),ZJ(W)},MJ=(W,Q,J,V)=>{let G,X,Y=0;if(W.level>0){if(W.strm.data_type===2)W.strm.data_type=jJ(W);if(W6(W,W.l_desc),W6(W,W.d_desc),Y=$J(W),G=W.opt_len+3+7>>>3,X=W.static_len+3+7>>>3,X<=G)G=X}else G=X=J+5;if(J+4<=G&&Q!==-1)Q7(W,Q,J,V);else if(W.strategy===4||X===G)P0(W,(_5<<1)+(V?1:0),3),X5(W,O0,A1);else P0(W,(qJ<<1)+(V?1:0),3),CJ(W,W.l_desc.max_code+1,W.d_desc.max_code+1,Y+1),X5(W,W.dyn_ltree,W.dyn_dtree);if(W7(W),V)J7(W)},LJ=(W,Q,J)=>{if(W.pending_buf[W.sym_buf+W.sym_next++]=Q,W.pending_buf[W.sym_buf+W.sym_next++]=Q>>8,W.pending_buf[W.sym_buf+W.sym_next++]=J,Q===0)W.dyn_ltree[J*2]++;else W.matches++,Q--,W.dyn_ltree[(f1[J]+_1+1)*2]++,W.dyn_dtree[s5(Q)*2]++;return W.sym_next===W.sym_end},IJ=BJ,DJ=Q7,OJ=MJ,xJ=LJ,wJ=RJ,NJ={_tr_init:IJ,_tr_stored_block:DJ,_tr_flush_block:OJ,_tr_tally:xJ,_tr_align:wJ},SJ=(W,Q,J,V)=>{let G=W&65535|0,X=W>>>16&65535|0,Y=0;while(J!==0){Y=J>2000?2000:J,J-=Y;do G=G+Q[V++]|0,X=X+G|0;while(--Y);G%=65521,X%=65521}return G|X<<16|0},b1=SJ,vJ=()=>{let W,Q=[];for(var J=0;J<256;J++){W=J;for(var V=0;V<8;V++)W=W&1?3988292384^W>>>1:W>>>1;Q[J]=W}return Q},AJ=new Uint32Array(vJ()),TJ=(W,Q,J,V)=>{const G=AJ,X=V+J;W^=-1;for(let Y=V;Y<X;Y++)W=W>>>8^G[(W^Q[Y])&255];return W^-1},G0=TJ,d0={2:"need dictionary",1:"stream end",0:"","-1":"file error","-2":"stream error","-3":"data error","-4":"insufficient memory","-5":"buffer error","-6":"incompatible version"},r0={Z_NO_FLUSH:0,Z_PARTIAL_FLUSH:1,Z_SYNC_FLUSH:2,Z_FULL_FLUSH:3,Z_FINISH:4,Z_BLOCK:5,Z_TREES:6,Z_OK:0,Z_STREAM_END:1,Z_NEED_DICT:2,Z_ERRNO:-1,Z_STREAM_ERROR:-2,Z_DATA_ERROR:-3,Z_MEM_ERROR:-4,Z_BUF_ERROR:-5,Z_NO_COMPRESSION:0,Z_BEST_SPEED:1,Z_BEST_COMPRESSION:9,Z_DEFAULT_COMPRESSION:-1,Z_FILTERED:1,Z_HUFFMAN_ONLY:2,Z_RLE:3,Z_FIXED:4,Z_DEFAULT_STRATEGY:0,Z_BINARY:0,Z_TEXT:1,Z_UNKNOWN:2,Z_DEFLATED:8},{_tr_init:gJ,_tr_stored_block:J6,_tr_flush_block:EJ,_tr_tally:y0,_tr_align:yJ}=NJ,{Z_NO_FLUSH:f0,Z_PARTIAL_FLUSH:fJ,Z_FULL_FLUSH:pJ,Z_FINISH:H0,Z_BLOCK:P5,Z_OK:X0,Z_STREAM_END:K5,Z_STREAM_ERROR:R0,Z_DATA_ERROR:bJ,Z_BUF_ERROR:c8,Z_DEFAULT_COMPRESSION:hJ,Z_FILTERED:uJ,Z_HUFFMAN_ONLY:G8,Z_RLE:mJ,Z_FIXED:_J,Z_DEFAULT_STRATEGY:cJ,Z_UNKNOWN:dJ,Z_DEFLATED:Z8}=r0,lJ=9,iJ=15,rJ=8,nJ=29,oJ=256,Q6=oJ+1+nJ,aJ=30,sJ=19,eJ=2*Q6+1,tJ=15,a=3,E0=258,M0=E0+a+1,W9=32,U1=42,z6=57,V6=69,G6=73,X6=91,Y6=103,_0=113,S1=666,q0=1,F1=2,l0=3,z1=4,J9=3,c0=(W,Q)=>{return W.msg=d0[Q],Q},F5=(W)=>{return W*2-(W>4?9:0)},g0=(W)=>{let Q=W.length;while(--Q>=0)W[Q]=0},Q9=(W)=>{let Q,J,V,G=W.w_size;Q=W.hash_size,V=Q;do J=W.head[--V],W.head[V]=J>=G?J-G:0;while(--Q);Q=G,V=Q;do J=W.prev[--V],W.prev[V]=J>=G?J-G:0;while(--Q)},V9=(W,Q,J)=>(Q<<W.hash_shift^J)&W.hash_mask,p0=V9,F0=(W)=>{const Q=W.state;let J=Q.pending;if(J>W.avail_out)J=W.avail_out;if(J===0)return;if(W.output.set(Q.pending_buf.subarray(Q.pending_out,Q.pending_out+J),W.next_out),W.next_out+=J,Q.pending_out+=J,W.total_out+=J,W.avail_out-=J,Q.pending-=J,Q.pending===0)Q.pending_out=0},z0=(W,Q)=>{EJ(W,W.block_start>=0?W.block_start:-1,W.strstart-W.block_start,Q),W.block_start=W.strstart,F0(W.strm)},s=(W,Q)=>{W.pending_buf[W.pending++]=Q},N1=(W,Q)=>{W.pending_buf[W.pending++]=Q>>>8&255,W.pending_buf[W.pending++]=Q&255},q6=(W,Q,J,V)=>{let G=W.avail_in;if(G>V)G=V;if(G===0)return 0;if(W.avail_in-=G,Q.set(W.input.subarray(W.next_in,W.next_in+G),J),W.state.wrap===1)W.adler=b1(W.adler,Q,G,J);else if(W.state.wrap===2)W.adler=G0(W.adler,Q,G,J);return W.next_in+=G,W.total_in+=G,G},V7=(W,Q)=>{let{max_chain_length:J,strstart:V}=W,G,X,Y=W.prev_length,q=W.nice_match;const F=W.strstart>W.w_size-M0?W.strstart-(W.w_size-M0):0,U=W.window,K=W.w_mask,$=W.prev,P=W.strstart+E0;let z=U[V+Y-1],C=U[V+Y];if(W.prev_length>=W.good_match)J>>=2;if(q>W.lookahead)q=W.lookahead;do{if(G=Q,U[G+Y]!==C||U[G+Y-1]!==z||U[G]!==U[V]||U[++G]!==U[V+1])continue;V+=2,G++;do;while(U[++V]===U[++G]&&U[++V]===U[++G]&&U[++V]===U[++G]&&U[++V]===U[++G]&&U[++V]===U[++G]&&U[++V]===U[++G]&&U[++V]===U[++G]&&U[++V]===U[++G]&&V<P);if(X=E0-(P-V),V=P-E0,X>Y){if(W.match_start=Q,Y=X,X>=q)break;z=U[V+Y-1],C=U[V+Y]}}while((Q=$[Q&K])>F&&--J!==0);if(Y<=W.lookahead)return Y;return W.lookahead},P1=(W)=>{const Q=W.w_size;let J,V,G;do{if(V=W.window_size-W.lookahead-W.strstart,W.strstart>=Q+(Q-M0)){if(W.window.set(W.window.subarray(Q,Q+Q-V),0),W.match_start-=Q,W.strstart-=Q,W.block_start-=Q,W.insert>W.strstart)W.insert=W.strstart;Q9(W),V+=Q}if(W.strm.avail_in===0)break;if(J=q6(W.strm,W.window,W.strstart+W.lookahead,V),W.lookahead+=J,W.lookahead+W.insert>=a){G=W.strstart-W.insert,W.ins_h=W.window[G],W.ins_h=p0(W,W.ins_h,W.window[G+1]);while(W.insert)if(W.ins_h=p0(W,W.ins_h,W.window[G+a-1]),W.prev[G&W.w_mask]=W.head[W.ins_h],W.head[W.ins_h]=G,G++,W.insert--,W.lookahead+W.insert<a)break}}while(W.lookahead<M0&&W.strm.avail_in!==0)},G7=(W,Q)=>{let J=W.pending_buf_size-5>W.w_size?W.w_size:W.pending_buf_size-5,V,G,X,Y=0,q=W.strm.avail_in;do{if(V=65535,X=W.bi_valid+42>>3,W.strm.avail_out<X)break;if(X=W.strm.avail_out-X,G=W.strstart-W.block_start,V>G+W.strm.avail_in)V=G+W.strm.avail_in;if(V>X)V=X;if(V<J&&(V===0&&Q!==H0||Q===f0||V!==G+W.strm.avail_in))break;if(Y=Q===H0&&V===G+W.strm.avail_in?1:0,J6(W,0,0,Y),W.pending_buf[W.pending-4]=V,W.pending_buf[W.pending-3]=V>>8,W.pending_buf[W.pending-2]=~V,W.pending_buf[W.pending-1]=~V>>8,F0(W.strm),G){if(G>V)G=V;W.strm.output.set(W.window.subarray(W.block_start,W.block_start+G),W.strm.next_out),W.strm.next_out+=G,W.strm.avail_out-=G,W.strm.total_out+=G,W.block_start+=G,V-=G}if(V)q6(W.strm,W.strm.output,W.strm.next_out,V),W.strm.next_out+=V,W.strm.avail_out-=V,W.strm.total_out+=V}while(Y===0);if(q-=W.strm.avail_in,q){if(q>=W.w_size)W.matches=2,W.window.set(W.strm.input.subarray(W.strm.next_in-W.w_size,W.strm.next_in),0),W.strstart=W.w_size,W.insert=W.strstart;else{if(W.window_size-W.strstart<=q){if(W.strstart-=W.w_size,W.window.set(W.window.subarray(W.w_size,W.w_size+W.strstart),0),W.matches<2)W.matches++;if(W.insert>W.strstart)W.insert=W.strstart}W.window.set(W.strm.input.subarray(W.strm.next_in-q,W.strm.next_in),W.strstart),W.strstart+=q,W.insert+=q>W.w_size-W.insert?W.w_size-W.insert:q}W.block_start=W.strstart}if(W.high_water<W.strstart)W.high_water=W.strstart;if(Y)return z1;if(Q!==f0&&Q!==H0&&W.strm.avail_in===0&&W.strstart===W.block_start)return F1;if(X=W.window_size-W.strstart,W.strm.avail_in>X&&W.block_start>=W.w_size){if(W.block_start-=W.w_size,W.strstart-=W.w_size,W.window.set(W.window.subarray(W.w_size,W.w_size+W.strstart),0),W.matches<2)W.matches++;if(X+=W.w_size,W.insert>W.strstart)W.insert=W.strstart}if(X>W.strm.avail_in)X=W.strm.avail_in;if(X)q6(W.strm,W.window,W.strstart,X),W.strstart+=X,W.insert+=X>W.w_size-W.insert?W.w_size-W.insert:X;if(W.high_water<W.strstart)W.high_water=W.strstart;if(X=W.bi_valid+42>>3,X=W.pending_buf_size-X>65535?65535:W.pending_buf_size-X,J=X>W.w_size?W.w_size:X,G=W.strstart-W.block_start,G>=J||(G||Q===H0)&&Q!==f0&&W.strm.avail_in===0&&G<=X)V=G>X?X:G,Y=Q===H0&&W.strm.avail_in===0&&V===G?1:0,J6(W,W.block_start,V,Y),W.block_start+=V,F0(W.strm);return Y?l0:q0},d8=(W,Q)=>{let J,V;for(;;){if(W.lookahead<M0){if(P1(W),W.lookahead<M0&&Q===f0)return q0;if(W.lookahead===0)break}if(J=0,W.lookahead>=a)W.ins_h=p0(W,W.ins_h,W.window[W.strstart+a-1]),J=W.prev[W.strstart&W.w_mask]=W.head[W.ins_h],W.head[W.ins_h]=W.strstart;if(J!==0&&W.strstart-J<=W.w_size-M0)W.match_length=V7(W,J);if(W.match_length>=a)if(V=y0(W,W.strstart-W.match_start,W.match_length-a),W.lookahead-=W.match_length,W.match_length<=W.max_lazy_match&&W.lookahead>=a){W.match_length--;do W.strstart++,W.ins_h=p0(W,W.ins_h,W.window[W.strstart+a-1]),J=W.prev[W.strstart&W.w_mask]=W.head[W.ins_h],W.head[W.ins_h]=W.strstart;while(--W.match_length!==0);W.strstart++}else W.strstart+=W.match_length,W.match_length=0,W.ins_h=W.window[W.strstart],W.ins_h=p0(W,W.ins_h,W.window[W.strstart+1]);else V=y0(W,0,W.window[W.strstart]),W.lookahead--,W.strstart++;if(V){if(z0(W,!1),W.strm.avail_out===0)return q0}}if(W.insert=W.strstart<a-1?W.strstart:a-1,Q===H0){if(z0(W,!0),W.strm.avail_out===0)return l0;return z1}if(W.sym_next){if(z0(W,!1),W.strm.avail_out===0)return q0}return F1},X1=(W,Q)=>{let J,V,G;for(;;){if(W.lookahead<M0){if(P1(W),W.lookahead<M0&&Q===f0)return q0;if(W.lookahead===0)break}if(J=0,W.lookahead>=a)W.ins_h=p0(W,W.ins_h,W.window[W.strstart+a-1]),J=W.prev[W.strstart&W.w_mask]=W.head[W.ins_h],W.head[W.ins_h]=W.strstart;if(W.prev_length=W.match_length,W.prev_match=W.match_start,W.match_length=a-1,J!==0&&W.prev_length<W.max_lazy_match&&W.strstart-J<=W.w_size-M0){if(W.match_length=V7(W,J),W.match_length<=5&&(W.strategy===uJ||W.match_length===a&&W.strstart-W.match_start>4096))W.match_length=a-1}if(W.prev_length>=a&&W.match_length<=W.prev_length){G=W.strstart+W.lookahead-a,V=y0(W,W.strstart-1-W.prev_match,W.prev_length-a),W.lookahead-=W.prev_length-1,W.prev_length-=2;do if(++W.strstart<=G)W.ins_h=p0(W,W.ins_h,W.window[W.strstart+a-1]),J=W.prev[W.strstart&W.w_mask]=W.head[W.ins_h],W.head[W.ins_h]=W.strstart;while(--W.prev_length!==0);if(W.match_available=0,W.match_length=a-1,W.strstart++,V){if(z0(W,!1),W.strm.avail_out===0)return q0}}else if(W.match_available){if(V=y0(W,0,W.window[W.strstart-1]),V)z0(W,!1);if(W.strstart++,W.lookahead--,W.strm.avail_out===0)return q0}else W.match_available=1,W.strstart++,W.lookahead--}if(W.match_available)V=y0(W,0,W.window[W.strstart-1]),W.match_available=0;if(W.insert=W.strstart<a-1?W.strstart:a-1,Q===H0){if(z0(W,!0),W.strm.avail_out===0)return l0;return z1}if(W.sym_next){if(z0(W,!1),W.strm.avail_out===0)return q0}return F1},G9=(W,Q)=>{let J,V,G,X;const Y=W.window;for(;;){if(W.lookahead<=E0){if(P1(W),W.lookahead<=E0&&Q===f0)return q0;if(W.lookahead===0)break}if(W.match_length=0,W.lookahead>=a&&W.strstart>0){if(G=W.strstart-1,V=Y[G],V===Y[++G]&&V===Y[++G]&&V===Y[++G]){X=W.strstart+E0;do;while(V===Y[++G]&&V===Y[++G]&&V===Y[++G]&&V===Y[++G]&&V===Y[++G]&&V===Y[++G]&&V===Y[++G]&&V===Y[++G]&&G<X);if(W.match_length=E0-(X-G),W.match_length>W.lookahead)W.match_length=W.lookahead}}if(W.match_length>=a)J=y0(W,1,W.match_length-a),W.lookahead-=W.match_length,W.strstart+=W.match_length,W.match_length=0;else J=y0(W,0,W.window[W.strstart]),W.lookahead--,W.strstart++;if(J){if(z0(W,!1),W.strm.avail_out===0)return q0}}if(W.insert=0,Q===H0){if(z0(W,!0),W.strm.avail_out===0)return l0;return z1}if(W.sym_next){if(z0(W,!1),W.strm.avail_out===0)return q0}return F1},X9=(W,Q)=>{let J;for(;;){if(W.lookahead===0){if(P1(W),W.lookahead===0){if(Q===f0)return q0;break}}if(W.match_length=0,J=y0(W,0,W.window[W.strstart]),W.lookahead--,W.strstart++,J){if(z0(W,!1),W.strm.avail_out===0)return q0}}if(W.insert=0,Q===H0){if(z0(W,!0),W.strm.avail_out===0)return l0;return z1}if(W.sym_next){if(z0(W,!1),W.strm.avail_out===0)return q0}return F1},v1=[new j0(0,0,0,0,G7),new j0(4,4,8,4,d8),new j0(4,5,16,8,d8),new j0(4,6,32,32,d8),new j0(4,4,16,16,X1),new j0(8,16,32,32,X1),new j0(8,16,128,128,X1),new j0(8,32,128,256,X1),new j0(32,128,258,1024,X1),new j0(32,258,258,4096,X1)],Y9=(W)=>{W.window_size=2*W.w_size,g0(W.head),W.max_lazy_match=v1[W.level].max_lazy,W.good_match=v1[W.level].good_length,W.nice_match=v1[W.level].nice_length,W.max_chain_length=v1[W.level].max_chain,W.strstart=0,W.block_start=0,W.lookahead=0,W.insert=0,W.match_length=W.prev_length=a-1,W.match_available=0,W.ins_h=0},c1=(W)=>{if(!W)return 1;const Q=W.state;if(!Q||Q.strm!==W||Q.status!==U1&&Q.status!==z6&&Q.status!==V6&&Q.status!==G6&&Q.status!==X6&&Q.status!==Y6&&Q.status!==_0&&Q.status!==S1)return 1;return 0},X7=(W)=>{if(c1(W))return c0(W,R0);W.total_in=W.total_out=0,W.data_type=dJ;const Q=W.state;if(Q.pending=0,Q.pending_out=0,Q.wrap<0)Q.wrap=-Q.wrap;return Q.status=Q.wrap===2?z6:Q.wrap?U1:_0,W.adler=Q.wrap===2?0:1,Q.last_flush=-2,gJ(Q),X0},Y7=(W)=>{const Q=X7(W);if(Q===X0)Y9(W.state);return Q},U9=(W,Q)=>{if(c1(W)||W.state.wrap!==2)return R0;return W.state.gzhead=Q,X0},q7=(W,Q,J,V,G,X)=>{if(!W)return R0;let Y=1;if(Q===hJ)Q=6;if(V<0)Y=0,V=-V;else if(V>15)Y=2,V-=16;if(G<1||G>lJ||J!==Z8||V<8||V>15||Q<0||Q>9||X<0||X>_J||V===8&&Y!==1)return c0(W,R0);if(V===8)V=9;const q=new q9;return W.state=q,q.strm=W,q.status=U1,q.wrap=Y,q.gzhead=null,q.w_bits=V,q.w_size=1<<q.w_bits,q.w_mask=q.w_size-1,q.hash_bits=G+7,q.hash_size=1<<q.hash_bits,q.hash_mask=q.hash_size-1,q.hash_shift=~~((q.hash_bits+a-1)/a),q.window=new Uint8Array(q.w_size*2),q.head=new Uint16Array(q.hash_size),q.prev=new Uint16Array(q.w_size),q.lit_bufsize=1<<G+6,q.pending_buf_size=q.lit_bufsize*4,q.pending_buf=new Uint8Array(q.pending_buf_size),q.sym_buf=q.lit_bufsize,q.sym_end=(q.lit_bufsize-1)*3,q.level=Q,q.strategy=X,q.method=J,Y7(W)},P9=(W,Q)=>{return q7(W,Q,Z8,iJ,rJ,cJ)},K9=(W,Q)=>{if(c1(W)||Q>P5||Q<0)return W?c0(W,R0):R0;const J=W.state;if(!W.output||W.avail_in!==0&&!W.input||J.status===S1&&Q!==H0)return c0(W,W.avail_out===0?c8:R0);const V=J.last_flush;if(J.last_flush=Q,J.pending!==0){if(F0(W),W.avail_out===0)return J.last_flush=-1,X0}else if(W.avail_in===0&&F5(Q)<=F5(V)&&Q!==H0)return c0(W,c8);if(J.status===S1&&W.avail_in!==0)return c0(W,c8);if(J.status===U1&&J.wrap===0)J.status=_0;if(J.status===U1){let G=Z8+(J.w_bits-8<<4)<<8,X=-1;if(J.strategy>=G8||J.level<2)X=0;else if(J.level<6)X=1;else if(J.level===6)X=2;else X=3;if(G|=X<<6,J.strstart!==0)G|=W9;if(G+=31-G%31,N1(J,G),J.strstart!==0)N1(J,W.adler>>>16),N1(J,W.adler&65535);if(W.adler=1,J.status=_0,F0(W),J.pending!==0)return J.last_flush=-1,X0}if(J.status===z6)if(W.adler=0,s(J,31),s(J,139),s(J,8),!J.gzhead){if(s(J,0),s(J,0),s(J,0),s(J,0),s(J,0),s(J,J.level===9?2:J.strategy>=G8||J.level<2?4:0),s(J,J9),J.status=_0,F0(W),J.pending!==0)return J.last_flush=-1,X0}else{if(s(J,(J.gzhead.text?1:0)+(J.gzhead.hcrc?2:0)+(!J.gzhead.extra?0:4)+(!J.gzhead.name?0:8)+(!J.gzhead.comment?0:16)),s(J,J.gzhead.time&255),s(J,J.gzhead.time>>8&255),s(J,J.gzhead.time>>16&255),s(J,J.gzhead.time>>24&255),s(J,J.level===9?2:J.strategy>=G8||J.level<2?4:0),s(J,J.gzhead.os&255),J.gzhead.extra&&J.gzhead.extra.length)s(J,J.gzhead.extra.length&255),s(J,J.gzhead.extra.length>>8&255);if(J.gzhead.hcrc)W.adler=G0(W.adler,J.pending_buf,J.pending,0);J.gzindex=0,J.status=V6}if(J.status===V6){if(J.gzhead.extra){let G=J.pending,X=(J.gzhead.extra.length&65535)-J.gzindex;while(J.pending+X>J.pending_buf_size){let q=J.pending_buf_size-J.pending;if(J.pending_buf.set(J.gzhead.extra.subarray(J.gzindex,J.gzindex+q),J.pending),J.pending=J.pending_buf_size,J.gzhead.hcrc&&J.pending>G)W.adler=G0(W.adler,J.pending_buf,J.pending-G,G);if(J.gzindex+=q,F0(W),J.pending!==0)return J.last_flush=-1,X0;G=0,X-=q}let Y=new Uint8Array(J.gzhead.extra);if(J.pending_buf.set(Y.subarray(J.gzindex,J.gzindex+X),J.pending),J.pending+=X,J.gzhead.hcrc&&J.pending>G)W.adler=G0(W.adler,J.pending_buf,J.pending-G,G);J.gzindex=0}J.status=G6}if(J.status===G6){if(J.gzhead.name){let G=J.pending,X;do{if(J.pending===J.pending_buf_size){if(J.gzhead.hcrc&&J.pending>G)W.adler=G0(W.adler,J.pending_buf,J.pending-G,G);if(F0(W),J.pending!==0)return J.last_flush=-1,X0;G=0}if(J.gzindex<J.gzhead.name.length)X=J.gzhead.name.charCodeAt(J.gzindex++)&255;else X=0;s(J,X)}while(X!==0);if(J.gzhead.hcrc&&J.pending>G)W.adler=G0(W.adler,J.pending_buf,J.pending-G,G);J.gzindex=0}J.status=X6}if(J.status===X6){if(J.gzhead.comment){let G=J.pending,X;do{if(J.pending===J.pending_buf_size){if(J.gzhead.hcrc&&J.pending>G)W.adler=G0(W.adler,J.pending_buf,J.pending-G,G);if(F0(W),J.pending!==0)return J.last_flush=-1,X0;G=0}if(J.gzindex<J.gzhead.comment.length)X=J.gzhead.comment.charCodeAt(J.gzindex++)&255;else X=0;s(J,X)}while(X!==0);if(J.gzhead.hcrc&&J.pending>G)W.adler=G0(W.adler,J.pending_buf,J.pending-G,G)}J.status=Y6}if(J.status===Y6){if(J.gzhead.hcrc){if(J.pending+2>J.pending_buf_size){if(F0(W),J.pending!==0)return J.last_flush=-1,X0}s(J,W.adler&255),s(J,W.adler>>8&255),W.adler=0}if(J.status=_0,F0(W),J.pending!==0)return J.last_flush=-1,X0}if(W.avail_in!==0||J.lookahead!==0||Q!==f0&&J.status!==S1){let G=J.level===0?G7(J,Q):J.strategy===G8?X9(J,Q):J.strategy===mJ?G9(J,Q):v1[J.level].func(J,Q);if(G===l0||G===z1)J.status=S1;if(G===q0||G===l0){if(W.avail_out===0)J.last_flush=-1;return X0}if(G===F1){if(Q===fJ)yJ(J);else if(Q!==P5){if(J6(J,0,0,!1),Q===pJ){if(g0(J.head),J.lookahead===0)J.strstart=0,J.block_start=0,J.insert=0}}if(F0(W),W.avail_out===0)return J.last_flush=-1,X0}}if(Q!==H0)return X0;if(J.wrap<=0)return K5;if(J.wrap===2)s(J,W.adler&255),s(J,W.adler>>8&255),s(J,W.adler>>16&255),s(J,W.adler>>24&255),s(J,W.total_in&255),s(J,W.total_in>>8&255),s(J,W.total_in>>16&255),s(J,W.total_in>>24&255);else N1(J,W.adler>>>16),N1(J,W.adler&65535);if(F0(W),J.wrap>0)J.wrap=-J.wrap;return J.pending!==0?X0:K5},F9=(W)=>{if(c1(W))return R0;const Q=W.state.status;return W.state=null,Q===_0?c0(W,bJ):X0},z9=(W,Q)=>{let J=Q.length;if(c1(W))return R0;const V=W.state,G=V.wrap;if(G===2||G===1&&V.status!==U1||V.lookahead)return R0;if(G===1)W.adler=b1(W.adler,Q,J,0);if(V.wrap=0,J>=V.w_size){if(G===0)g0(V.head),V.strstart=0,V.block_start=0,V.insert=0;let F=new Uint8Array(V.w_size);F.set(Q.subarray(J-V.w_size,J),0),Q=F,J=V.w_size}const{avail_in:X,next_in:Y,input:q}=W;W.avail_in=J,W.next_in=0,W.input=Q,P1(V);while(V.lookahead>=a){let F=V.strstart,U=V.lookahead-(a-1);do V.ins_h=p0(V,V.ins_h,V.window[F+a-1]),V.prev[F&V.w_mask]=V.head[V.ins_h],V.head[V.ins_h]=F,F++;while(--U);V.strstart=F,V.lookahead=a-1,P1(V)}return V.strstart+=V.lookahead,V.block_start=V.strstart,V.insert=V.lookahead,V.lookahead=0,V.match_length=V.prev_length=a-1,V.match_available=0,W.next_in=Y,W.input=q,W.avail_in=X,V.wrap=G,X0},Z9=P9,H9=q7,k9=Y7,$9=X7,C9=U9,j9=K9,B9=F9,R9=z9,M9="pako deflate (from Nodeca project)",T1={deflateInit:Z9,deflateInit2:H9,deflateReset:k9,deflateResetKeep:$9,deflateSetHeader:C9,deflate:j9,deflateEnd:B9,deflateSetDictionary:R9,deflateInfo:M9},L9=(W,Q)=>{return Object.prototype.hasOwnProperty.call(W,Q)},I9=function(W){const Q=Array.prototype.slice.call(arguments,1);while(Q.length){const J=Q.shift();if(!J)continue;if(typeof J!=="object")throw new TypeError(J+"must be non-object");for(let V in J)if(L9(J,V))W[V]=J[V]}return W},D9=(W)=>{let Q=0;for(let V=0,G=W.length;V<G;V++)Q+=W[V].length;const J=new Uint8Array(Q);for(let V=0,G=0,X=W.length;V<X;V++){let Y=W[V];J.set(Y,G),G+=Y.length}return J},H8={assign:I9,flattenChunks:D9},U7=!0;try{String.fromCharCode.apply(null,new Uint8Array(1))}catch(W){U7=!1}var h1=new Uint8Array(256);for(let W=0;W<256;W++)h1[W]=W>=252?6:W>=248?5:W>=240?4:W>=224?3:W>=192?2:1;h1[254]=h1[254]=1;var O9=(W)=>{if(typeof TextEncoder==="function"&&TextEncoder.prototype.encode)return(new TextEncoder()).encode(W);let Q,J,V,G,X,Y=W.length,q=0;for(G=0;G<Y;G++){if(J=W.charCodeAt(G),(J&64512)===55296&&G+1<Y){if(V=W.charCodeAt(G+1),(V&64512)===56320)J=65536+(J-55296<<10)+(V-56320),G++}q+=J<128?1:J<2048?2:J<65536?3:4}Q=new Uint8Array(q);for(X=0,G=0;X<q;G++){if(J=W.charCodeAt(G),(J&64512)===55296&&G+1<Y){if(V=W.charCodeAt(G+1),(V&64512)===56320)J=65536+(J-55296<<10)+(V-56320),G++}if(J<128)Q[X++]=J;else if(J<2048)Q[X++]=192|J>>>6,Q[X++]=128|J&63;else if(J<65536)Q[X++]=224|J>>>12,Q[X++]=128|J>>>6&63,Q[X++]=128|J&63;else Q[X++]=240|J>>>18,Q[X++]=128|J>>>12&63,Q[X++]=128|J>>>6&63,Q[X++]=128|J&63}return Q},x9=(W,Q)=>{if(Q<65534){if(W.subarray&&U7)return String.fromCharCode.apply(null,W.length===Q?W:W.subarray(0,Q))}let J="";for(let V=0;V<Q;V++)J+=String.fromCharCode(W[V]);return J},w9=(W,Q)=>{const J=Q||W.length;if(typeof TextDecoder==="function"&&TextDecoder.prototype.decode)return(new TextDecoder()).decode(W.subarray(0,Q));let V,G;const X=new Array(J*2);for(G=0,V=0;V<J;){let Y=W[V++];if(Y<128){X[G++]=Y;continue}let q=h1[Y];if(q>4){X[G++]=65533,V+=q-1;continue}Y&=q===2?31:q===3?15:7;while(q>1&&V<J)Y=Y<<6|W[V++]&63,q--;if(q>1){X[G++]=65533;continue}if(Y<65536)X[G++]=Y;else Y-=65536,X[G++]=55296|Y>>10&1023,X[G++]=56320|Y&1023}return x9(X,G)},N9=(W,Q)=>{if(Q=Q||W.length,Q>W.length)Q=W.length;let J=Q-1;while(J>=0&&(W[J]&192)===128)J--;if(J<0)return Q;if(J===0)return Q;return J+h1[W[J]]>Q?J:Q},u1={string2buf:O9,buf2string:w9,utf8border:N9},P7=S9,K7=Object.prototype.toString,{Z_NO_FLUSH:v9,Z_SYNC_FLUSH:A9,Z_FULL_FLUSH:T9,Z_FINISH:g9,Z_OK:F8,Z_STREAM_END:E9,Z_DEFAULT_COMPRESSION:y9,Z_DEFAULT_STRATEGY:f9,Z_DEFLATED:p9}=r0;d1.prototype.push=function(W,Q){const J=this.strm,V=this.options.chunkSize;let G,X;if(this.ended)return!1;if(Q===~~Q)X=Q;else X=Q===!0?g9:v9;if(typeof W==="string")J.input=u1.string2buf(W);else if(K7.call(W)==="[object ArrayBuffer]")J.input=new Uint8Array(W);else J.input=W;J.next_in=0,J.avail_in=J.input.length;for(;;){if(J.avail_out===0)J.output=new Uint8Array(V),J.next_out=0,J.avail_out=V;if((X===A9||X===T9)&&J.avail_out<=6){this.onData(J.output.subarray(0,J.next_out)),J.avail_out=0;continue}if(G=T1.deflate(J,X),G===E9){if(J.next_out>0)this.onData(J.output.subarray(0,J.next_out));return G=T1.deflateEnd(this.strm),this.onEnd(G),this.ended=!0,G===F8}if(J.avail_out===0){this.onData(J.output);continue}if(X>0&&J.next_out>0){this.onData(J.output.subarray(0,J.next_out)),J.avail_out=0;continue}if(J.avail_in===0)break}return!0};d1.prototype.onData=function(W){this.chunks.push(W)};d1.prototype.onEnd=function(W){if(W===F8)this.result=H8.flattenChunks(this.chunks);this.chunks=[],this.err=W,this.msg=this.strm.msg};var u9=d1,m9=Z6,_9=b9,c9=h9,d9=r0,l9={Deflate:u9,deflate:m9,deflateRaw:_9,gzip:c9,constants:d9},X8=16209,i9=16191,r9=function W(Q,J){let V,G,X,Y,q,F,U,K,$,P,z,C,S,T,p,f,m,x,c,i,D,M,N,Z;const H=Q.state;V=Q.next_in,N=Q.input,G=V+(Q.avail_in-5),X=Q.next_out,Z=Q.output,Y=X-(J-Q.avail_out),q=X+(Q.avail_out-257),F=H.dmax,U=H.wsize,K=H.whave,$=H.wnext,P=H.window,z=H.hold,C=H.bits,S=H.lencode,T=H.distcode,p=(1<<H.lenbits)-1,f=(1<<H.distbits)-1;W:do{if(C<15)z+=N[V++]<<C,C+=8,z+=N[V++]<<C,C+=8;m=S[z&p];J:for(;;){if(x=m>>>24,z>>>=x,C-=x,x=m>>>16&255,x===0)Z[X++]=m&65535;else if(x&16){if(c=m&65535,x&=15,x){if(C<x)z+=N[V++]<<C,C+=8;c+=z&(1<<x)-1,z>>>=x,C-=x}if(C<15)z+=N[V++]<<C,C+=8,z+=N[V++]<<C,C+=8;m=T[z&f];Q:for(;;){if(x=m>>>24,z>>>=x,C-=x,x=m>>>16&255,x&16){if(i=m&65535,x&=15,C<x){if(z+=N[V++]<<C,C+=8,C<x)z+=N[V++]<<C,C+=8}if(i+=z&(1<<x)-1,i>F){Q.msg="invalid distance too far back",H.mode=X8;break W}if(z>>>=x,C-=x,x=X-Y,i>x){if(x=i-x,x>K){if(H.sane){Q.msg="invalid distance too far back",H.mode=X8;break W}}if(D=0,M=P,$===0){if(D+=U-x,x<c){c-=x;do Z[X++]=P[D++];while(--x);D=X-i,M=Z}}else if($<x){if(D+=U+$-x,x-=$,x<c){c-=x;do Z[X++]=P[D++];while(--x);if(D=0,$<c){x=$,c-=x;do Z[X++]=P[D++];while(--x);D=X-i,M=Z}}}else if(D+=$-x,x<c){c-=x;do Z[X++]=P[D++];while(--x);D=X-i,M=Z}while(c>2)Z[X++]=M[D++],Z[X++]=M[D++],Z[X++]=M[D++],c-=3;if(c){if(Z[X++]=M[D++],c>1)Z[X++]=M[D++]}}else{D=X-i;do Z[X++]=Z[D++],Z[X++]=Z[D++],Z[X++]=Z[D++],c-=3;while(c>2);if(c){if(Z[X++]=Z[D++],c>1)Z[X++]=Z[D++]}}}else if((x&64)===0){m=T[(m&65535)+(z&(1<<x)-1)];continue Q}else{Q.msg="invalid distance code",H.mode=X8;break W}break}}else if((x&64)===0){m=S[(m&65535)+(z&(1<<x)-1)];continue J}else if(x&32){H.mode=i9;break W}else{Q.msg="invalid literal/length code",H.mode=X8;break W}break}}while(V<G&&X<q);c=C>>3,V-=c,C-=c<<3,z&=(1<<C)-1,Q.next_in=V,Q.next_out=X,Q.avail_in=V<G?5+(G-V):5-(V-G),Q.avail_out=X<q?257+(q-X):257-(X-q),H.hold=z,H.bits=C;return},Y1=15,z5=852,Z5=592,H5=0,l8=1,k5=2,n9=new Uint16Array([3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,0,0]),o9=new Uint8Array([16,16,16,16,16,16,16,16,17,17,17,17,18,18,18,18,19,19,19,19,20,20,20,20,21,21,21,21,16,72,78]),a9=new Uint16Array([1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,0,0]),s9=new Uint8Array([16,16,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,64,64]),e9=(W,Q,J,V,G,X,Y,q)=>{const F=q.bits;let U=0,K=0,$=0,P=0,z=0,C=0,S=0,T=0,p=0,f=0,m,x,c,i,D,M=null,N;const Z=new Uint16Array(Y1+1),H=new Uint16Array(Y1+1);let R=null,k,j,O;for(U=0;U<=Y1;U++)Z[U]=0;for(K=0;K<V;K++)Z[Q[J+K]]++;z=F;for(P=Y1;P>=1;P--)if(Z[P]!==0)break;if(z>P)z=P;if(P===0)return G[X++]=1<<24|64<<16|0,G[X++]=1<<24|64<<16|0,q.bits=1,0;for($=1;$<P;$++)if(Z[$]!==0)break;if(z<$)z=$;T=1;for(U=1;U<=Y1;U++)if(T<<=1,T-=Z[U],T<0)return-1;if(T>0&&(W===H5||P!==1))return-1;H[1]=0;for(U=1;U<Y1;U++)H[U+1]=H[U]+Z[U];for(K=0;K<V;K++)if(Q[J+K]!==0)Y[H[Q[J+K]]++]=K;if(W===H5)M=R=Y,N=20;else if(W===l8)M=n9,R=o9,N=257;else M=a9,R=s9,N=0;if(f=0,K=0,U=$,D=X,C=z,S=0,c=-1,p=1<<z,i=p-1,W===l8&&p>z5||W===k5&&p>Z5)return 1;for(;;){if(k=U-S,Y[K]+1<N)j=0,O=Y[K];else if(Y[K]>=N)j=R[Y[K]-N],O=M[Y[K]-N];else j=96,O=0;m=1<<U-S,x=1<<C,$=x;do x-=m,G[D+(f>>S)+x]=k<<24|j<<16|O|0;while(x!==0);m=1<<U-1;while(f&m)m>>=1;if(m!==0)f&=m-1,f+=m;else f=0;if(K++,--Z[U]===0){if(U===P)break;U=Q[J+Y[K]]}if(U>z&&(f&i)!==c){if(S===0)S=z;D+=$,C=U-S,T=1<<C;while(C+S<P){if(T-=Z[C+S],T<=0)break;C++,T<<=1}if(p+=1<<C,W===l8&&p>z5||W===k5&&p>Z5)return 1;c=f&i,G[c]=z<<24|C<<16|D-X|0}}if(f!==0)G[D+f]=U-S<<24|64<<16|0;return q.bits=z,0},g1=e9,t9=0,F7=1,z7=2,{Z_FINISH:$5,Z_BLOCK:WQ,Z_TREES:Y8,Z_OK:i0,Z_STREAM_END:JQ,Z_NEED_DICT:QQ,Z_STREAM_ERROR:k0,Z_DATA_ERROR:Z7,Z_MEM_ERROR:H7,Z_BUF_ERROR:VQ,Z_DEFLATED:C5}=r0,k8=16180,j5=16181,B5=16182,R5=16183,M5=16184,L5=16185,I5=16186,D5=16187,O5=16188,x5=16189,z8=16190,D0=16191,i8=16192,w5=16193,r8=16194,N5=16195,S5=16196,v5=16197,A5=16198,q8=16199,U8=16200,T5=16201,g5=16202,E5=16203,y5=16204,f5=16205,n8=16206,p5=16207,b5=16208,t=16209,k7=16210,$7=16211,GQ=852,XQ=592,YQ=15,qQ=YQ,h5=(W)=>{return(W>>>24&255)+(W>>>8&65280)+((W&65280)<<8)+((W&255)<<24)},n0=(W)=>{if(!W)return 1;const Q=W.state;if(!Q||Q.strm!==W||Q.mode<k8||Q.mode>$7)return 1;return 0},C7=(W)=>{if(n0(W))return k0;const Q=W.state;if(W.total_in=W.total_out=Q.total=0,W.msg="",Q.wrap)W.adler=Q.wrap&1;return Q.mode=k8,Q.last=0,Q.havedict=0,Q.flags=-1,Q.dmax=32768,Q.head=null,Q.hold=0,Q.bits=0,Q.lencode=Q.lendyn=new Int32Array(GQ),Q.distcode=Q.distdyn=new Int32Array(XQ),Q.sane=1,Q.back=-1,i0},j7=(W)=>{if(n0(W))return k0;const Q=W.state;return Q.wsize=0,Q.whave=0,Q.wnext=0,C7(W)},B7=(W,Q)=>{let J;if(n0(W))return k0;const V=W.state;if(Q<0)J=0,Q=-Q;else if(J=(Q>>4)+5,Q<48)Q&=15;if(Q&&(Q<8||Q>15))return k0;if(V.window!==null&&V.wbits!==Q)V.window=null;return V.wrap=J,V.wbits=Q,j7(W)},R7=(W,Q)=>{if(!W)return k0;const J=new UQ;W.state=J,J.strm=W,J.window=null,J.mode=k8;const V=B7(W,Q);if(V!==i0)W.state=null;return V},PQ=(W)=>{return R7(W,qQ)},u5=!0,o8,a8,KQ=(W)=>{if(u5){o8=new Int32Array(512),a8=new Int32Array(32);let Q=0;while(Q<144)W.lens[Q++]=8;while(Q<256)W.lens[Q++]=9;while(Q<280)W.lens[Q++]=7;while(Q<288)W.lens[Q++]=8;g1(F7,W.lens,0,288,o8,0,W.work,{bits:9}),Q=0;while(Q<32)W.lens[Q++]=5;g1(z7,W.lens,0,32,a8,0,W.work,{bits:5}),u5=!1}W.lencode=o8,W.lenbits=9,W.distcode=a8,W.distbits=5},M7=(W,Q,J,V)=>{let G;const X=W.state;if(X.window===null)X.wsize=1<<X.wbits,X.wnext=0,X.whave=0,X.window=new Uint8Array(X.wsize);if(V>=X.wsize)X.window.set(Q.subarray(J-X.wsize,J),0),X.wnext=0,X.whave=X.wsize;else{if(G=X.wsize-X.wnext,G>V)G=V;if(X.window.set(Q.subarray(J-V,J-V+G),X.wnext),V-=G,V)X.window.set(Q.subarray(J-V,J),0),X.wnext=V,X.whave=X.wsize;else{if(X.wnext+=G,X.wnext===X.wsize)X.wnext=0;if(X.whave<X.wsize)X.whave+=G}}return 0},FQ=(W,Q)=>{let J,V,G,X,Y,q,F,U,K,$,P,z,C,S,T=0,p,f,m,x,c,i,D,M;const N=new Uint8Array(4);let Z,H;const R=new Uint8Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]);if(n0(W)||!W.output||!W.input&&W.avail_in!==0)return k0;if(J=W.state,J.mode===D0)J.mode=i8;Y=W.next_out,G=W.output,F=W.avail_out,X=W.next_in,V=W.input,q=W.avail_in,U=J.hold,K=J.bits,$=q,P=F,M=i0;W:for(;;)switch(J.mode){case k8:if(J.wrap===0){J.mode=i8;break}while(K<16){if(q===0)break W;q--,U+=V[X++]<<K,K+=8}if(J.wrap&2&&U===35615){if(J.wbits===0)J.wbits=15;J.check=0,N[0]=U&255,N[1]=U>>>8&255,J.check=G0(J.check,N,2,0),U=0,K=0,J.mode=j5;break}if(J.head)J.head.done=!1;if(!(J.wrap&1)||(((U&255)<<8)+(U>>8))%31){W.msg="incorrect header check",J.mode=t;break}if((U&15)!==C5){W.msg="unknown compression method",J.mode=t;break}if(U>>>=4,K-=4,D=(U&15)+8,J.wbits===0)J.wbits=D;if(D>15||D>J.wbits){W.msg="invalid window size",J.mode=t;break}J.dmax=1<<J.wbits,J.flags=0,W.adler=J.check=1,J.mode=U&512?x5:D0,U=0,K=0;break;case j5:while(K<16){if(q===0)break W;q--,U+=V[X++]<<K,K+=8}if(J.flags=U,(J.flags&255)!==C5){W.msg="unknown compression method",J.mode=t;break}if(J.flags&57344){W.msg="unknown header flags set",J.mode=t;break}if(J.head)J.head.text=U>>8&1;if(J.flags&512&&J.wrap&4)N[0]=U&255,N[1]=U>>>8&255,J.check=G0(J.check,N,2,0);U=0,K=0,J.mode=B5;case B5:while(K<32){if(q===0)break W;q--,U+=V[X++]<<K,K+=8}if(J.head)J.head.time=U;if(J.flags&512&&J.wrap&4)N[0]=U&255,N[1]=U>>>8&255,N[2]=U>>>16&255,N[3]=U>>>24&255,J.check=G0(J.check,N,4,0);U=0,K=0,J.mode=R5;case R5:while(K<16){if(q===0)break W;q--,U+=V[X++]<<K,K+=8}if(J.head)J.head.xflags=U&255,J.head.os=U>>8;if(J.flags&512&&J.wrap&4)N[0]=U&255,N[1]=U>>>8&255,J.check=G0(J.check,N,2,0);U=0,K=0,J.mode=M5;case M5:if(J.flags&1024){while(K<16){if(q===0)break W;q--,U+=V[X++]<<K,K+=8}if(J.length=U,J.head)J.head.extra_len=U;if(J.flags&512&&J.wrap&4)N[0]=U&255,N[1]=U>>>8&255,J.check=G0(J.check,N,2,0);U=0,K=0}else if(J.head)J.head.extra=null;J.mode=L5;case L5:if(J.flags&1024){if(z=J.length,z>q)z=q;if(z){if(J.head){if(D=J.head.extra_len-J.length,!J.head.extra)J.head.extra=new Uint8Array(J.head.extra_len);J.head.extra.set(V.subarray(X,X+z),D)}if(J.flags&512&&J.wrap&4)J.check=G0(J.check,V,z,X);q-=z,X+=z,J.length-=z}if(J.length)break W}J.length=0,J.mode=I5;case I5:if(J.flags&2048){if(q===0)break W;z=0;do if(D=V[X+z++],J.head&&D&&J.length<65536)J.head.name+=String.fromCharCode(D);while(D&&z<q);if(J.flags&512&&J.wrap&4)J.check=G0(J.check,V,z,X);if(q-=z,X+=z,D)break W}else if(J.head)J.head.name=null;J.length=0,J.mode=D5;case D5:if(J.flags&4096){if(q===0)break W;z=0;do if(D=V[X+z++],J.head&&D&&J.length<65536)J.head.comment+=String.fromCharCode(D);while(D&&z<q);if(J.flags&512&&J.wrap&4)J.check=G0(J.check,V,z,X);if(q-=z,X+=z,D)break W}else if(J.head)J.head.comment=null;J.mode=O5;case O5:if(J.flags&512){while(K<16){if(q===0)break W;q--,U+=V[X++]<<K,K+=8}if(J.wrap&4&&U!==(J.check&65535)){W.msg="header crc mismatch",J.mode=t;break}U=0,K=0}if(J.head)J.head.hcrc=J.flags>>9&1,J.head.done=!0;W.adler=J.check=0,J.mode=D0;break;case x5:while(K<32){if(q===0)break W;q--,U+=V[X++]<<K,K+=8}W.adler=J.check=h5(U),U=0,K=0,J.mode=z8;case z8:if(J.havedict===0)return W.next_out=Y,W.avail_out=F,W.next_in=X,W.avail_in=q,J.hold=U,J.bits=K,QQ;W.adler=J.check=1,J.mode=D0;case D0:if(Q===WQ||Q===Y8)break W;case i8:if(J.last){U>>>=K&7,K-=K&7,J.mode=n8;break}while(K<3){if(q===0)break W;q--,U+=V[X++]<<K,K+=8}switch(J.last=U&1,U>>>=1,K-=1,U&3){case 0:J.mode=w5;break;case 1:if(KQ(J),J.mode=q8,Q===Y8){U>>>=2,K-=2;break W}break;case 2:J.mode=S5;break;case 3:W.msg="invalid block type",J.mode=t}U>>>=2,K-=2;break;case w5:U>>>=K&7,K-=K&7;while(K<32){if(q===0)break W;q--,U+=V[X++]<<K,K+=8}if((U&65535)!==(U>>>16^65535)){W.msg="invalid stored block lengths",J.mode=t;break}if(J.length=U&65535,U=0,K=0,J.mode=r8,Q===Y8)break W;case r8:J.mode=N5;case N5:if(z=J.length,z){if(z>q)z=q;if(z>F)z=F;if(z===0)break W;G.set(V.subarray(X,X+z),Y),q-=z,X+=z,F-=z,Y+=z,J.length-=z;break}J.mode=D0;break;case S5:while(K<14){if(q===0)break W;q--,U+=V[X++]<<K,K+=8}if(J.nlen=(U&31)+257,U>>>=5,K-=5,J.ndist=(U&31)+1,U>>>=5,K-=5,J.ncode=(U&15)+4,U>>>=4,K-=4,J.nlen>286||J.ndist>30){W.msg="too many length or distance symbols",J.mode=t;break}J.have=0,J.mode=v5;case v5:while(J.have<J.ncode){while(K<3){if(q===0)break W;q--,U+=V[X++]<<K,K+=8}J.lens[R[J.have++]]=U&7,U>>>=3,K-=3}while(J.have<19)J.lens[R[J.have++]]=0;if(J.lencode=J.lendyn,J.lenbits=7,Z={bits:J.lenbits},M=g1(t9,J.lens,0,19,J.lencode,0,J.work,Z),J.lenbits=Z.bits,M){W.msg="invalid code lengths set",J.mode=t;break}J.have=0,J.mode=A5;case A5:while(J.have<J.nlen+J.ndist){for(;;){if(T=J.lencode[U&(1<<J.lenbits)-1],p=T>>>24,f=T>>>16&255,m=T&65535,p<=K)break;if(q===0)break W;q--,U+=V[X++]<<K,K+=8}if(m<16)U>>>=p,K-=p,J.lens[J.have++]=m;else{if(m===16){H=p+2;while(K<H){if(q===0)break W;q--,U+=V[X++]<<K,K+=8}if(U>>>=p,K-=p,J.have===0){W.msg="invalid bit length repeat",J.mode=t;break}D=J.lens[J.have-1],z=3+(U&3),U>>>=2,K-=2}else if(m===17){H=p+3;while(K<H){if(q===0)break W;q--,U+=V[X++]<<K,K+=8}U>>>=p,K-=p,D=0,z=3+(U&7),U>>>=3,K-=3}else{H=p+7;while(K<H){if(q===0)break W;q--,U+=V[X++]<<K,K+=8}U>>>=p,K-=p,D=0,z=11+(U&127),U>>>=7,K-=7}if(J.have+z>J.nlen+J.ndist){W.msg="invalid bit length repeat",J.mode=t;break}while(z--)J.lens[J.have++]=D}}if(J.mode===t)break;if(J.lens[256]===0){W.msg="invalid code -- missing end-of-block",J.mode=t;break}if(J.lenbits=9,Z={bits:J.lenbits},M=g1(F7,J.lens,0,J.nlen,J.lencode,0,J.work,Z),J.lenbits=Z.bits,M){W.msg="invalid literal/lengths set",J.mode=t;break}if(J.distbits=6,J.distcode=J.distdyn,Z={bits:J.distbits},M=g1(z7,J.lens,J.nlen,J.ndist,J.distcode,0,J.work,Z),J.distbits=Z.bits,M){W.msg="invalid distances set",J.mode=t;break}if(J.mode=q8,Q===Y8)break W;case q8:J.mode=U8;case U8:if(q>=6&&F>=258){if(W.next_out=Y,W.avail_out=F,W.next_in=X,W.avail_in=q,J.hold=U,J.bits=K,r9(W,P),Y=W.next_out,G=W.output,F=W.avail_out,X=W.next_in,V=W.input,q=W.avail_in,U=J.hold,K=J.bits,J.mode===D0)J.back=-1;break}J.back=0;for(;;){if(T=J.lencode[U&(1<<J.lenbits)-1],p=T>>>24,f=T>>>16&255,m=T&65535,p<=K)break;if(q===0)break W;q--,U+=V[X++]<<K,K+=8}if(f&&(f&240)===0){x=p,c=f,i=m;for(;;){if(T=J.lencode[i+((U&(1<<x+c)-1)>>x)],p=T>>>24,f=T>>>16&255,m=T&65535,x+p<=K)break;if(q===0)break W;q--,U+=V[X++]<<K,K+=8}U>>>=x,K-=x,J.back+=x}if(U>>>=p,K-=p,J.back+=p,J.length=m,f===0){J.mode=f5;break}if(f&32){J.back=-1,J.mode=D0;break}if(f&64){W.msg="invalid literal/length code",J.mode=t;break}J.extra=f&15,J.mode=T5;case T5:if(J.extra){H=J.extra;while(K<H){if(q===0)break W;q--,U+=V[X++]<<K,K+=8}J.length+=U&(1<<J.extra)-1,U>>>=J.extra,K-=J.extra,J.back+=J.extra}J.was=J.length,J.mode=g5;case g5:for(;;){if(T=J.distcode[U&(1<<J.distbits)-1],p=T>>>24,f=T>>>16&255,m=T&65535,p<=K)break;if(q===0)break W;q--,U+=V[X++]<<K,K+=8}if((f&240)===0){x=p,c=f,i=m;for(;;){if(T=J.distcode[i+((U&(1<<x+c)-1)>>x)],p=T>>>24,f=T>>>16&255,m=T&65535,x+p<=K)break;if(q===0)break W;q--,U+=V[X++]<<K,K+=8}U>>>=x,K-=x,J.back+=x}if(U>>>=p,K-=p,J.back+=p,f&64){W.msg="invalid distance code",J.mode=t;break}J.offset=m,J.extra=f&15,J.mode=E5;case E5:if(J.extra){H=J.extra;while(K<H){if(q===0)break W;q--,U+=V[X++]<<K,K+=8}J.offset+=U&(1<<J.extra)-1,U>>>=J.extra,K-=J.extra,J.back+=J.extra}if(J.offset>J.dmax){W.msg="invalid distance too far back",J.mode=t;break}J.mode=y5;case y5:if(F===0)break W;if(z=P-F,J.offset>z){if(z=J.offset-z,z>J.whave){if(J.sane){W.msg="invalid distance too far back",J.mode=t;break}}if(z>J.wnext)z-=J.wnext,C=J.wsize-z;else C=J.wnext-z;if(z>J.length)z=J.length;S=J.window}else S=G,C=Y-J.offset,z=J.length;if(z>F)z=F;F-=z,J.length-=z;do G[Y++]=S[C++];while(--z);if(J.length===0)J.mode=U8;break;case f5:if(F===0)break W;G[Y++]=J.length,F--,J.mode=U8;break;case n8:if(J.wrap){while(K<32){if(q===0)break W;q--,U|=V[X++]<<K,K+=8}if(P-=F,W.total_out+=P,J.total+=P,J.wrap&4&&P)W.adler=J.check=J.flags?G0(J.check,G,P,Y-P):b1(J.check,G,P,Y-P);if(P=F,J.wrap&4&&(J.flags?U:h5(U))!==J.check){W.msg="incorrect data check",J.mode=t;break}U=0,K=0}J.mode=p5;case p5:if(J.wrap&&J.flags){while(K<32){if(q===0)break W;q--,U+=V[X++]<<K,K+=8}if(J.wrap&4&&U!==(J.total&4294967295)){W.msg="incorrect length check",J.mode=t;break}U=0,K=0}J.mode=b5;case b5:M=JQ;break W;case t:M=Z7;break W;case k7:return H7;case $7:default:return k0}if(W.next_out=Y,W.avail_out=F,W.next_in=X,W.avail_in=q,J.hold=U,J.bits=K,J.wsize||P!==W.avail_out&&J.mode<t&&(J.mode<n8||Q!==$5)){if(M7(W,W.output,W.next_out,P-W.avail_out));}if($-=W.avail_in,P-=W.avail_out,W.total_in+=$,W.total_out+=P,J.total+=P,J.wrap&4&&P)W.adler=J.check=J.flags?G0(J.check,G,P,W.next_out-P):b1(J.check,G,P,W.next_out-P);if(W.data_type=J.bits+(J.last?64:0)+(J.mode===D0?128:0)+(J.mode===q8||J.mode===r8?256:0),($===0&&P===0||Q===$5)&&M===i0)M=VQ;return M},zQ=(W)=>{if(n0(W))return k0;let Q=W.state;if(Q.window)Q.window=null;return W.state=null,i0},ZQ=(W,Q)=>{if(n0(W))return k0;const J=W.state;if((J.wrap&2)===0)return k0;return J.head=Q,Q.done=!1,i0},HQ=(W,Q)=>{const J=Q.length;let V,G,X;if(n0(W))return k0;if(V=W.state,V.wrap!==0&&V.mode!==z8)return k0;if(V.mode===z8){if(G=1,G=b1(G,Q,J,0),G!==V.check)return Z7}if(X=M7(W,Q,J,J),X)return V.mode=k7,H7;return V.havedict=1,i0},kQ=j7,$Q=B7,CQ=C7,jQ=PQ,BQ=R7,RQ=FQ,MQ=zQ,LQ=ZQ,IQ=HQ,DQ="pako inflate (from Nodeca project)",x0={inflateReset:kQ,inflateReset2:$Q,inflateResetKeep:CQ,inflateInit:jQ,inflateInit2:BQ,inflate:RQ,inflateEnd:MQ,inflateGetHeader:LQ,inflateSetDictionary:IQ,inflateInfo:DQ},xQ=OQ,L7=Object.prototype.toString,{Z_NO_FLUSH:wQ,Z_FINISH:NQ,Z_OK:m1,Z_STREAM_END:s8,Z_NEED_DICT:e8,Z_STREAM_ERROR:SQ,Z_DATA_ERROR:m5,Z_MEM_ERROR:vQ}=r0;l1.prototype.push=function(W,Q){const J=this.strm,V=this.options.chunkSize,G=this.options.dictionary;let X,Y,q;if(this.ended)return!1;if(Q===~~Q)Y=Q;else Y=Q===!0?NQ:wQ;if(L7.call(W)==="[object ArrayBuffer]")J.input=new Uint8Array(W);else J.input=W;J.next_in=0,J.avail_in=J.input.length;for(;;){if(J.avail_out===0)J.output=new Uint8Array(V),J.next_out=0,J.avail_out=V;if(X=x0.inflate(J,Y),X===e8&&G){if(X=x0.inflateSetDictionary(J,G),X===m1)X=x0.inflate(J,Y);else if(X===m5)X=e8}while(J.avail_in>0&&X===s8&&J.state.wrap>0&&W[J.next_in]!==0)x0.inflateReset(J),X=x0.inflate(J,Y);switch(X){case SQ:case m5:case e8:case vQ:return this.onEnd(X),this.ended=!0,!1}if(q=J.avail_out,J.next_out){if(J.avail_out===0||X===s8)if(this.options.to==="string"){let F=u1.utf8border(J.output,J.next_out),U=J.next_out-F,K=u1.buf2string(J.output,F);if(J.next_out=U,J.avail_out=V-U,U)J.output.set(J.output.subarray(F,F+U),0);this.onData(K)}else this.onData(J.output.length===J.next_out?J.output:J.output.subarray(0,J.next_out))}if(X===m1&&q===0)continue;if(X===s8)return X=x0.inflateEnd(this.strm),this.onEnd(X),this.ended=!0,!0;if(J.avail_in===0)break}return!0};l1.prototype.onData=function(W){this.chunks.push(W)};l1.prototype.onEnd=function(W){if(W===m1)if(this.options.to==="string")this.result=this.chunks.join("");else this.result=H8.flattenChunks(this.chunks);this.chunks=[],this.err=W,this.msg=this.strm.msg};var TQ=l1,gQ=H6,EQ=AQ,yQ=H6,fQ=r0,pQ={Inflate:TQ,inflate:gQ,inflateRaw:EQ,ungzip:yQ,constants:fQ},{Deflate:bQ,deflate:hQ,deflateRaw:uQ,gzip:mQ}=l9,{Inflate:_Q,inflate:cQ,inflateRaw:dQ,ungzip:lQ}=pQ,iQ=bQ,rQ=hQ,nQ=uQ,oQ=mQ,aQ=_Q,sQ=cQ,eQ=dQ,tQ=lQ,WV=r0,Z1={Deflate:iQ,deflate:rQ,deflateRaw:nQ,gzip:oQ,Inflate:aQ,inflate:sQ,inflateRaw:eQ,ungzip:tQ,constants:WV};var A8=function(W){return W instanceof Uint8Array||ArrayBuffer.isView(W)&&W.constructor.name==="Uint8Array"},D6=function(W){if(!Number.isSafeInteger(W)||W<0)throw Error("positive integer expected, got "+W)},W1=function(W,...Q){if(!A8(W))throw Error("Uint8Array expected");if(Q.length>0&&!Q.includes(W.length))throw Error("Uint8Array expected of length "+Q+", got length="+W.length)},l7=function(W){if(typeof W!="function"||typeof W.create!="function")throw Error("Hash should be wrapped by utils.createHasher");D6(W.outputLen),D6(W.blockLen)},L8=function(W,Q=!0){if(W.destroyed)throw Error("Hash instance has been destroyed");if(Q&&W.finished)throw Error("Hash#digest() has already been called")},I8=function(...W){for(let Q=0;Q<W.length;Q++)W[Q].fill(0)},k6=function(W){return new DataView(W.buffer,W.byteOffset,W.byteLength)},L0=function(W,Q){return W<<32-Q|W>>>Q},B1=function(W){if(W1(W),i7)return W.toHex();let Q="";for(let J=0;J<W.length;J++)Q+=JV[W[J]];return Q},x7=function(W){return W>=I7&&W<=QV?W-I7:W>=D7&&W<=VV?W-(D7-10):W>=O7&&W<=GV?W-(O7-10):void 0},D8=function(W){if(typeof W!="string")throw Error("hex string expected, got "+typeof W);if(i7)return Uint8Array.fromHex(W);const Q=W.length,J=Q/2;if(Q%2)throw Error("hex string expected, got unpadded hex of length "+Q);const V=new Uint8Array(J);for(let G=0,X=0;G<J;G++,X+=2){const Y=x7(W.charCodeAt(X)),q=x7(W.charCodeAt(X+1));if(Y===void 0||q===void 0){const F=W[X]+W[X+1];throw Error('hex string expected, got non-hex character "'+F+'" at index '+X)}V[G]=16*Y+q}return V},r7=function(W){if(typeof W!="string")throw Error("string expected");return new Uint8Array((new TextEncoder()).encode(W))},g6=function(W){return typeof W=="string"&&(W=r7(W)),W1(W),W},I0=function(...W){let Q=0;for(let V=0;V<W.length;V++){const G=W[V];W1(G),Q+=G.length}const J=new Uint8Array(Q);for(let V=0,G=0;V<W.length;V++){const X=W[V];J.set(X,G),G+=X.length}return J},XV=function(W){const Q=(V)=>W().update(g6(V)).digest(),J=W();return Q.outputLen=J.outputLen,Q.blockLen=J.blockLen,Q.create=()=>W(),Q},O8=function(W=32){if(H1&&typeof H1.getRandomValues=="function")return H1.getRandomValues(new Uint8Array(W));if(H1&&typeof H1.randomBytes=="function")return Uint8Array.from(H1.randomBytes(W));throw Error("crypto.getRandomValues must be defined")},YV=function(W,Q,J){return W&Q^W&J^Q&J},x8=function(W,Q=""){if(typeof W!="boolean")throw Error((Q&&`"${Q}"`)+"expected boolean, got type="+typeof W);return W},o0=function(W,Q,J=""){const V=A8(W),G=W?.length,X=Q!==void 0;if(!V||X&&G!==Q)throw Error((J&&`"${J}" `)+"expected Uint8Array"+(X?" of length "+Q:"")+", got "+(V?"length="+G:"type="+typeof W));return W},$8=function(W){const Q=W.toString(16);return 1&Q.length?"0"+Q:Q},s7=function(W){if(typeof W!="string")throw Error("hex string expected, got "+typeof W);return W===""?f6:BigInt("0x"+W)},L1=function(W){return s7(B1(W))},e7=function(W){return W1(W),s7(B1(Uint8Array.from(W).reverse()))},T8=function(W,Q){return D8(W.toString(16).padStart(2*Q,"0"))},t7=function(W,Q){return T8(W,Q).reverse()},Q0=function(W,Q,J){let V;if(typeof Q=="string")try{V=D8(Q)}catch(X){throw Error(W+" must be hex string or Uint8Array, cause: "+X)}else{if(!A8(Q))throw Error(W+" must be hex string or Uint8Array");V=Uint8Array.from(Q)}const G=V.length;if(typeof J=="number"&&G!==J)throw Error(W+" of length "+J+" expected, got "+G);return V},w6=function(W,Q,J){return $6(W)&&$6(Q)&&$6(J)&&Q<=W&&W<J},WW=function(W){let Q;for(Q=0;W>f6;W>>=x6,Q+=1);return Q},p6=function(W,Q,J={}){if(!W||typeof W!="object")throw Error("expected valid options object");function V(G,X,Y){const q=W[G];if(Y&&q===void 0)return;const F=typeof q;if(F!==X||q===null)throw Error(`param "${G}" is invalid: expected ${X}, got ${F}`)}Object.entries(Q).forEach(([G,X])=>V(G,X,!1)),Object.entries(J).forEach(([G,X])=>V(G,X,!0))},w7=function(W){const Q=new WeakMap;return(J,...V)=>{const G=Q.get(J);if(G!==void 0)return G;const X=W(J,...V);return Q.set(J,X),X}},C0=function(W,Q){const J=W%Q;return J>=K0?J:Q+J},$0=function(W,Q,J){let V=W;for(;Q-- >K0;)V*=V,V%=J;return V},S7=function(W,Q){if(W===K0)throw Error("invert: expected non-zero number");if(Q<=K0)throw Error("invert: expected positive modulus, got "+Q);let J=C0(W,Q),V=Q,G=K0,X=U0;for(;J!==K0;){const Y=V%J,q=G-X*(V/J);V=J,J=Y,G=X,X=q}if(V!==U0)throw Error("invert: does not exist");return C0(G,Q)},b6=function(W,Q,J){if(!W.eql(W.sqr(Q),J))throw Error("Cannot find square root")},XW=function(W,Q){const J=(W.ORDER+U0)/QW,V=W.pow(Q,J);return b6(W,V,Q),V},KV=function(W,Q){const J=(W.ORDER-VW)/GW,V=W.mul(Q,s0),G=W.pow(V,J),X=W.mul(Q,G),Y=W.mul(W.mul(X,s0),G),q=W.mul(X,W.sub(Y,W.ONE));return b6(W,q,Q),q},v7=function(W){if(W<JW)throw Error("sqrt is not defined for small field");let Q=W-U0,J=0;for(;Q%s0===K0;)Q/=s0,J++;let V=s0;const G=s1(W);for(;A7(G,V)===1;)if(V++>1000)throw Error("Cannot find square root: probably non-prime P");if(J===1)return XW;let X=G.pow(V,Q);const Y=(Q+U0)/s0;return function(q,F){if(q.is0(F))return F;if(A7(q,F)!==1)throw Error("Cannot find square root");let U=J,K=q.mul(q.ONE,X),$=q.pow(F,Q),P=q.pow(F,Y);for(;!q.eql($,q.ONE);){if(q.is0($))return q.ZERO;let z=1,C=q.sqr($);for(;!q.eql(C,q.ONE);)if(z++,C=q.sqr(C),z===U)throw Error("Cannot find square root");const S=U0<<BigInt(U-z-1),T=q.pow(K,S);U=z,K=q.sqr(T),$=q.mul($,K),P=q.mul(P,T)}return P}},FV=function(W){return W%QW===JW?XW:W%GW===VW?KV:W%N7===PV?function(Q){const J=s1(Q),V=v7(Q),G=V(J,J.neg(J.ONE)),X=V(J,G),Y=V(J,J.neg(G)),q=(Q+UV)/N7;return(F,U)=>{let K=F.pow(U,q),$=F.mul(K,G);const P=F.mul(K,X),z=F.mul(K,Y),C=F.eql(F.sqr($),U),S=F.eql(F.sqr(P),U);K=F.cmov(K,$,C),$=F.cmov(z,P,S);const T=F.eql(F.sqr($),U),p=F.cmov(K,$,T);return b6(F,p,U),p}}(W):v7(W)},YW=function(W,Q,J=!1){const V=Array(Q.length).fill(J?W.ZERO:void 0),G=Q.reduce((Y,q,F)=>W.is0(q)?Y:(V[F]=Y,W.mul(Y,q)),W.ONE),X=W.inv(G);return Q.reduceRight((Y,q,F)=>W.is0(q)?Y:(V[F]=W.mul(Y,V[F]),W.mul(Y,q)),X),V},A7=function(W,Q){const J=(W.ORDER-U0)/s0,V=W.pow(Q,J),G=W.eql(V,W.ONE),X=W.eql(V,W.ZERO),Y=W.eql(V,W.neg(W.ONE));if(!G&&!X&&!Y)throw Error("invalid Legendre symbol result");return G?1:X?0:-1},qW=function(W,Q){Q!==void 0&&D6(Q);const J=Q!==void 0?Q:W.toString(2).length;return{nBitLength:J,nByteLength:Math.ceil(J/8)}},s1=function(W,Q,J=!1,V={}){if(W<=K0)throw Error("invalid field: expected ORDER > 0, got "+W);let G,X,Y,q=!1;if(typeof Q=="object"&&Q!=null){if(V.sqrt||J)throw Error("cannot specify opts in two arguments");const P=Q;P.BITS&&(G=P.BITS),P.sqrt&&(X=P.sqrt),typeof P.isLE=="boolean"&&(J=P.isLE),typeof P.modFromBytes=="boolean"&&(q=P.modFromBytes),Y=P.allowedLengths}else typeof Q=="number"&&(G=Q),V.sqrt&&(X=V.sqrt);const{nBitLength:F,nByteLength:U}=qW(W,G);if(U>2048)throw Error("invalid field: expected ORDER of <= 2048 bytes");let K;const $=Object.freeze({ORDER:W,isLE:J,BITS:F,BYTES:U,MASK:a1(F),ZERO:K0,ONE:U0,allowedLengths:Y,create(P){return C0(P,W)},isValid(P){if(typeof P!="bigint")throw Error("invalid field element: expected bigint, got "+typeof P);return K0<=P&&P<W},is0(P){return P===K0},isValidNot0(P){return!$.is0(P)&&$.isValid(P)},isOdd(P){return(P&U0)===U0},neg(P){return C0(-P,W)},eql(P,z){return P===z},sqr(P){return C0(P*P,W)},add(P,z){return C0(P+z,W)},sub(P,z){return C0(P-z,W)},mul(P,z){return C0(P*z,W)},pow(P,z){return function(C,S,T){if(T<K0)throw Error("invalid exponent, negatives unsupported");if(T===K0)return C.ONE;if(T===U0)return S;let p=C.ONE,f=S;for(;T>K0;)T&U0&&(p=C.mul(p,f)),f=C.sqr(f),T>>=U0;return p}($,P,z)},div(P,z){return C0(P*S7(z,W),W)},sqrN(P){return P*P},addN(P,z){return P+z},subN(P,z){return P-z},mulN(P,z){return P*z},inv(P){return S7(P,W)},sqrt:X||((P)=>(K||(K=FV(W)),K($,P))),toBytes(P){return J?t7(P,U):T8(P,U)},fromBytes(P,z=!0){if(Y){if(!Y.includes(P.length)||P.length>U)throw Error("Field.fromBytes: expected "+Y+" bytes, got "+P.length);const S=new Uint8Array(U);S.set(P,J?0:S.length-P.length),P=S}if(P.length!==U)throw Error("Field.fromBytes: expected "+U+" bytes, got "+P.length);let C=J?e7(P):L1(P);if(q&&(C=C0(C,W)),!z&&!$.isValid(C))throw Error("invalid field element: outside of range 0..ORDER");return C},invertBatch(P){return YW($,P)},cmov(P,z,C){return C?z:P}});return Object.freeze($)},UW=function(W){if(typeof W!="bigint")throw Error("field order must be bigint");const Q=W.toString(2).length;return Math.ceil(Q/8)},PW=function(W){const Q=UW(W);return Q+Math.ceil(Q/2)},KW=function(W,Q,J=!1){const V=W.length,G=UW(Q),X=PW(Q);if(V<16||V<X||V>1024)throw Error("expected "+X+"-1024 bytes of input, got "+V);const Y=C0(J?e7(W):L1(W),Q-U0)+U0;return J?t7(Y,G):T8(Y,G)},w8=function(W,Q){const J=Q.negate();return W?J:Q},C6=function(W,Q){const J=YW(W.Fp,Q.map((V)=>V.Z));return Q.map((V,G)=>W.fromAffine(V.toAffine(J[G])))},FW=function(W,Q){if(!Number.isSafeInteger(W)||W<=0||W>Q)throw Error("invalid window size, expected [1.."+Q+"], got W="+W)},j6=function(W,Q){FW(W,Q);const J=2**W;return{windows:Math.ceil(Q/W)+1,windowSize:2**(W-1),mask:a1(W),maxNumber:J,shiftBy:BigInt(W)}},T7=function(W,Q,J){const{windowSize:V,mask:G,maxNumber:X,shiftBy:Y}=J;let q=Number(W&G),F=W>>Y;q>V&&(q-=X,F+=e0);const U=Q*V;return{nextN:F,offset:U+Math.abs(q)-1,isZero:q===0,isNeg:q<0,isNegF:Q%2!=0,offsetF:U}},R6=function(W){return zW.get(W)||1},g7=function(W){if(W!==R1)throw Error("invalid wNAF")},ZV=function(W,Q,J,V){(function(P,z){if(!Array.isArray(P))throw Error("array expected");P.forEach((C,S)=>{if(!(C instanceof z))throw Error("invalid point at index "+S)})})(J,W),function(P,z){if(!Array.isArray(P))throw Error("array of scalars expected");P.forEach((C,S)=>{if(!z.isValid(C))throw Error("invalid scalar at index "+S)})}(V,Q);const G=J.length,X=V.length;if(G!==X)throw Error("arrays of points and scalars must have equal length");const Y=W.ZERO,q=WW(BigInt(G));let F=1;q>12?F=q-3:q>4?F=q-2:q>0&&(F=2);const U=a1(F),K=Array(Number(U)+1).fill(Y);let $=Y;for(let P=Math.floor((Q.BITS-1)/F)*F;P>=0;P-=F){K.fill(Y);for(let C=0;C<X;C++){const S=V[C],T=Number(S>>BigInt(P)&U);K[T]=K[T].add(J[C])}let z=Y;for(let C=K.length-1,S=Y;C>0;C--)S=S.add(K[C]),z=z.add(S);if($=$.add(z),P!==0)for(let C=0;C<F;C++)$=$.double()}return $},E7=function(W,Q,J){if(Q){if(Q.ORDER!==W)throw Error("Field.ORDER must match order: Fp == p, Fn == n");return function(V){p6(V,zV.reduce((G,X)=>(G[X]="function",G),{ORDER:"bigint",MASK:"bigint",BYTES:"number",BITS:"number"}))}(Q),Q}return s1(W,{isLE:J})},N6=function(W){if(!["compact","recovered","der"].includes(W))throw Error('Signature format must be "compact", "recovered", or "der"');return W},M6=function(W,Q){const J={};for(let V of Object.keys(Q))J[V]=W[V]===void 0?Q[V]:W[V];return x8(J.lowS,"lowS"),x8(J.prehash,"prehash"),J.format!==void 0&&N6(J.format),J},a0=function(W,Q){const{BYTES:J}=W;let V;if(typeof Q=="bigint")V=Q;else{let G=Q0("private key",Q);try{V=W.fromBytes(G)}catch(X){throw Error(`invalid private key: expected ui8a of size ${J}, got ${typeof Q}`)}}if(!W.isValidNot0(V))throw Error("invalid private key: out of range [1..N-1]");return V},kV=function(W,Q={}){const J=function(Z,H,R={},k){if(k===void 0&&(k=Z==="edwards"),!H||typeof H!="object")throw Error(`expected valid ${Z} CURVE object`);for(let w of["p","n","h"]){const B=H[w];if(!(typeof B=="bigint"&&B>R1))throw Error(`CURVE.${w} must be positive bigint`)}const j=E7(H.p,R.Fp,k),O=E7(H.n,R.Fn,k),L=["Gx","Gy","a","b"];for(let w of L)if(!j.isValid(H[w]))throw Error(`CURVE.${w} must be valid field element of CURVE.Fp`);return{CURVE:H=Object.freeze(Object.assign({},H)),Fp:j,Fn:O}}("weierstrass",W,Q),{Fp:V,Fn:G}=J;let X=J.CURVE;const{h:Y,n:q}=X;p6(Q,{},{allowInfinityPoint:"boolean",clearCofactor:"function",isTorsionFree:"function",fromBytes:"function",toBytes:"function",endo:"object",wrapPrivateKey:"boolean"});const{endo:F}=Q;if(F&&(!V.is0(X.a)||typeof F.beta!="bigint"||!Array.isArray(F.basises)))throw Error('invalid endo: expected "beta": bigint and "basises": array');const U=$W(V,G);function K(){if(!V.isOdd)throw Error("compression is not supported: Field does not have .isOdd()")}const $=Q.toBytes||function(Z,H,R){const{x:k,y:j}=H.toAffine(),O=V.toBytes(k);if(x8(R,"isCompressed"),R)return K(),I0(kW(!V.isOdd(j)),O);return I0(Uint8Array.of(4),O,V.toBytes(j))},P=Q.fromBytes||function(Z){o0(Z,void 0,"Point");const{publicKey:H,publicKeyUncompressed:R}=U,k=Z.length,j=Z[0],O=Z.subarray(1);if(k!==H||j!==2&&j!==3){if(k===R&&j===4){const L=V.BYTES,w=V.fromBytes(O.subarray(0,L)),B=V.fromBytes(O.subarray(L,2*L));if(!C(w,B))throw Error("bad point: is not on curve");return{x:w,y:B}}throw Error(`bad point: got length ${k}, expected compressed=${H} or uncompressed=${R}`)}{const L=V.fromBytes(O);if(!V.isValid(L))throw Error("bad point: is not on curve, wrong x");const w=z(L);let B;try{B=V.sqrt(w)}catch(v){const b=v instanceof Error?": "+v.message:"";throw Error("bad point: is not on curve, sqrt error"+b)}return K(),!(1&~j)!==V.isOdd(B)&&(B=V.neg(B)),{x:L,y:B}}};function z(Z){const H=V.sqr(Z),R=V.mul(H,Z);return V.add(V.add(R,V.mul(Z,X.a)),X.b)}function C(Z,H){const R=V.sqr(H),k=z(Z);return V.eql(R,k)}if(!C(X.Gx,X.Gy))throw Error("bad curve params: generator point");const S=V.mul(V.pow(X.a,C8),HV),T=V.mul(V.sqr(X.b),BigInt(27));if(V.is0(V.add(S,T)))throw Error("bad curve params: a or b");function p(Z,H,R=!1){if(!V.isValid(H)||R&&V.is0(H))throw Error("bad point coordinate "+Z);return H}function f(Z){if(!(Z instanceof D))throw Error("ProjectivePoint expected")}function m(Z){if(!F||!F.basises)throw Error("no endo");return function(H,R,k){const[[j,O],[L,w]]=R,B=y7(w*H,k),v=y7(-O*H,k);let b=H-B*j-v*L,A=-B*O-v*w;const h=b<S0,d=A<S0;h&&(b=-b),d&&(A=-A);const r=a1(Math.ceil(WW(k)/2))+C1;if(b<S0||b>=r||A<S0||A>=r)throw Error("splitScalar (endomorphism): failed, k="+H);return{k1neg:h,k1:b,k2neg:d,k2:A}}(Z,F.basises,G.ORDER)}const x=w7((Z,H)=>{const{X:R,Y:k,Z:j}=Z;if(V.eql(j,V.ONE))return{x:R,y:k};const O=Z.is0();H==null&&(H=O?V.ONE:V.inv(j));const L=V.mul(R,H),w=V.mul(k,H),B=V.mul(j,H);if(O)return{x:V.ZERO,y:V.ZERO};if(!V.eql(B,V.ONE))throw Error("invZ was invalid");return{x:L,y:w}}),c=w7((Z)=>{if(Z.is0()){if(Q.allowInfinityPoint&&!V.is0(Z.Y))return;throw Error("bad point: ZERO")}const{x:H,y:R}=Z.toAffine();if(!V.isValid(H)||!V.isValid(R))throw Error("bad point: x or y not field elements");if(!C(H,R))throw Error("bad point: equation left != right");if(!Z.isTorsionFree())throw Error("bad point: not in prime-order subgroup");return!0});function i(Z,H,R,k,j){return R=new D(V.mul(R.X,Z),R.Y,R.Z),H=w8(k,H),R=w8(j,R),H.add(R)}class D{constructor(Z,H,R){this.X=p("x",Z),this.Y=p("y",H,!0),this.Z=p("z",R),Object.freeze(this)}static CURVE(){return X}static fromAffine(Z){const{x:H,y:R}=Z||{};if(!Z||!V.isValid(H)||!V.isValid(R))throw Error("invalid affine point");if(Z instanceof D)throw Error("projective point not allowed");return V.is0(H)&&V.is0(R)?D.ZERO:new D(H,R,V.ONE)}static fromBytes(Z){const H=D.fromAffine(P(o0(Z,void 0,"point")));return H.assertValidity(),H}static fromHex(Z){return D.fromBytes(Q0("pointHex",Z))}get x(){return this.toAffine().x}get y(){return this.toAffine().y}precompute(Z=8,H=!0){return N.createCache(this,Z),H||this.multiply(C8),this}assertValidity(){c(this)}hasEvenY(){const{y:Z}=this.toAffine();if(!V.isOdd)throw Error("Field doesn't support isOdd");return!V.isOdd(Z)}equals(Z){f(Z);const{X:H,Y:R,Z:k}=this,{X:j,Y:O,Z:L}=Z,w=V.eql(V.mul(H,L),V.mul(j,k)),B=V.eql(V.mul(R,L),V.mul(O,k));return w&&B}negate(){return new D(this.X,V.neg(this.Y),this.Z)}double(){const{a:Z,b:H}=X,R=V.mul(H,C8),{X:k,Y:j,Z:O}=this;let{ZERO:L,ZERO:w,ZERO:B}=V,v=V.mul(k,k),b=V.mul(j,j),A=V.mul(O,O),h=V.mul(k,j);return h=V.add(h,h),B=V.mul(k,O),B=V.add(B,B),L=V.mul(Z,B),w=V.mul(R,A),w=V.add(L,w),L=V.sub(b,w),w=V.add(b,w),w=V.mul(L,w),L=V.mul(h,L),B=V.mul(R,B),A=V.mul(Z,A),h=V.sub(v,A),h=V.mul(Z,h),h=V.add(h,B),B=V.add(v,v),v=V.add(B,v),v=V.add(v,A),v=V.mul(v,h),w=V.add(w,v),A=V.mul(j,O),A=V.add(A,A),v=V.mul(A,h),L=V.sub(L,v),B=V.mul(A,b),B=V.add(B,B),B=V.add(B,B),new D(L,w,B)}add(Z){f(Z);const{X:H,Y:R,Z:k}=this,{X:j,Y:O,Z:L}=Z;let{ZERO:w,ZERO:B,ZERO:v}=V;const b=X.a,A=V.mul(X.b,C8);let h=V.mul(H,j),d=V.mul(R,O),r=V.mul(k,L),I=V.add(H,R),g=V.add(j,O);I=V.mul(I,g),g=V.add(h,d),I=V.sub(I,g),g=V.add(H,k);let y=V.add(j,L);return g=V.mul(g,y),y=V.add(h,r),g=V.sub(g,y),y=V.add(R,k),w=V.add(O,L),y=V.mul(y,w),w=V.add(d,r),y=V.sub(y,w),v=V.mul(b,g),w=V.mul(A,r),v=V.add(w,v),w=V.sub(d,v),v=V.add(d,v),B=V.mul(w,v),d=V.add(h,h),d=V.add(d,h),r=V.mul(b,r),g=V.mul(A,g),d=V.add(d,r),r=V.sub(h,r),r=V.mul(b,r),g=V.add(g,r),h=V.mul(d,g),B=V.add(B,h),h=V.mul(y,g),w=V.mul(I,w),w=V.sub(w,h),h=V.mul(I,d),v=V.mul(y,v),v=V.add(v,h),new D(w,B,v)}subtract(Z){return this.add(Z.negate())}is0(){return this.equals(D.ZERO)}multiply(Z){const{endo:H}=Q;if(!G.isValidNot0(Z))throw Error("invalid scalar: out of range");let R,k;const j=(O)=>N.cached(this,O,(L)=>C6(D,L));if(H){const{k1neg:O,k1:L,k2neg:w,k2:B}=m(Z),{p:v,f:b}=j(L),{p:A,f:h}=j(B);k=b.add(h),R=i(H.beta,v,A,O,w)}else{const{p:O,f:L}=j(Z);R=O,k=L}return C6(D,[R,k])[0]}multiplyUnsafe(Z){const{endo:H}=Q,R=this;if(!G.isValid(Z))throw Error("invalid scalar: out of range");if(Z===S0||R.is0())return D.ZERO;if(Z===C1)return R;if(N.hasCache(this))return this.multiply(Z);if(H){const{k1neg:k,k1:j,k2neg:O,k2:L}=m(Z),{p1:w,p2:B}=function(v,b,A,h){let d=b,r=v.ZERO,I=v.ZERO;for(;A>R1||h>R1;)A&e0&&(r=r.add(d)),h&e0&&(I=I.add(d)),d=d.double(),A>>=e0,h>>=e0;return{p1:r,p2:I}}(D,R,j,L);return i(H.beta,w,B,k,O)}return N.unsafe(R,Z)}multiplyAndAddUnsafe(Z,H,R){const k=this.multiplyUnsafe(H).add(Z.multiplyUnsafe(R));return k.is0()?void 0:k}toAffine(Z){return x(this,Z)}isTorsionFree(){const{isTorsionFree:Z}=Q;return Y===C1||(Z?Z(D,this):N.unsafe(this,q).is0())}clearCofactor(){const{clearCofactor:Z}=Q;return Y===C1?this:Z?Z(D,this):this.multiplyUnsafe(Y)}isSmallOrder(){return this.multiplyUnsafe(Y).is0()}toBytes(Z=!0){return x8(Z,"isCompressed"),this.assertValidity(),$(D,this,Z)}toHex(Z=!0){return B1(this.toBytes(Z))}toString(){return`<Point ${this.is0()?"ZERO":this.toHex()}>`}get px(){return this.X}get py(){return this.X}get pz(){return this.Z}toRawBytes(Z=!0){return this.toBytes(Z)}_setWindowSize(Z){this.precompute(Z)}static normalizeZ(Z){return C6(D,Z)}static msm(Z,H){return ZV(D,G,Z,H)}static fromPrivateKey(Z){return D.BASE.multiply(a0(G,Z))}}D.BASE=new D(X.Gx,X.Gy,V.ONE),D.ZERO=new D(V.ZERO,V.ONE,V.ZERO),D.Fp=V,D.Fn=G;const M=G.BITS,N=new ZW(D,Q.endo?Math.ceil(M/2):M);return D.BASE.precompute(8),D},kW=function(W){return Uint8Array.of(W?2:3)},$W=function(W,Q){return{secretKey:Q.BYTES,publicKey:1+W.BYTES,publicKeyUncompressed:1+2*W.BYTES,publicKeyHasPrefix:!0,signature:2*Q.BYTES}},$V=function(W,Q,J={}){l7(Q),p6(J,{},{hmac:"function",lowS:"boolean",randomBytes:"function",bits2int:"function",bits2int_modN:"function"});const V=J.randomBytes||O8,G=J.hmac||((M,...N)=>a7(Q,M,I0(...N))),{Fp:X,Fn:Y}=W,{ORDER:q,BITS:F}=Y,{keygen:U,getPublicKey:K,getSharedSecret:$,utils:P,lengths:z}=function(M,N={}){const{Fn:Z}=M,H=N.randomBytes||O8,R=Object.assign($W(M.Fp,Z),{seed:PW(Z.ORDER)});function k(B){try{return!!a0(Z,B)}catch(v){return!1}}function j(B=H(R.seed)){return KW(o0(B,R.seed,"seed"),Z.ORDER)}function O(B,v=!0){return M.BASE.multiply(a0(Z,B)).toBytes(v)}function L(B){if(typeof B=="bigint")return!1;if(B instanceof M)return!0;const{secretKey:v,publicKey:b,publicKeyUncompressed:A}=R;if(Z.allowedLengths||v===b)return;const h=Q0("key",B).length;return h===b||h===A}return Object.freeze({getPublicKey:O,getSharedSecret(B,v,b=!0){if(L(B)===!0)throw Error("first arg must be private key");if(L(v)===!1)throw Error("second arg must be public key");const A=a0(Z,B);return M.fromHex(v).multiply(A).toBytes(b)},keygen(B){const v=j(B);return{secretKey:v,publicKey:O(v)}},Point:M,utils:{isValidSecretKey:k,isValidPublicKey(B,v){const{publicKey:b,publicKeyUncompressed:A}=R;try{const h=B.length;return!(v===!0&&h!==b||v===!1&&h!==A||!M.fromBytes(B))}catch(h){return!1}},randomSecretKey:j,isValidPrivateKey:k,randomPrivateKey:j,normPrivateKeyToScalar:(B)=>a0(Z,B),precompute(B=8,v=M.BASE){return v.precompute(B,!1)}},lengths:R})}(W,J),C={prehash:!1,lowS:typeof J.lowS=="boolean"&&J.lowS,format:void 0,extraEntropy:!1},S="compact";function T(M){return M>q>>C1}function p(M,N){if(!Y.isValidNot0(N))throw Error(`invalid signature ${M}: out of range 1..Point.Fn.ORDER`);return N}class f{constructor(M,N,Z){this.r=p("r",M),this.s=p("s",N),Z!=null&&(this.recovery=Z),Object.freeze(this)}static fromBytes(M,N=S){let Z;if(function(j,O){N6(O);const L=z.signature;o0(j,O==="compact"?L:O==="recovered"?L+1:void 0,O+" signature")}(M,N),N==="der"){const{r:j,s:O}=N0.toSig(o0(M));return new f(j,O)}N==="recovered"&&(Z=M[0],N="compact",M=M.subarray(1));const H=Y.BYTES,R=M.subarray(0,H),k=M.subarray(H,2*H);return new f(Y.fromBytes(R),Y.fromBytes(k),Z)}static fromHex(M,N){return this.fromBytes(D8(M),N)}addRecoveryBit(M){return new f(this.r,this.s,M)}recoverPublicKey(M){const N=X.ORDER,{r:Z,s:H,recovery:R}=this;if(R==null||![0,1,2,3].includes(R))throw Error("recovery id invalid");if(q*HW<N&&R>1)throw Error("recovery id is ambiguous for h>1 curve");const k=R===2||R===3?Z+q:Z;if(!X.isValid(k))throw Error("recovery id 2 or 3 invalid");const j=X.toBytes(k),O=W.fromBytes(I0(kW(!(1&R)),j)),L=Y.inv(k),w=x(Q0("msgHash",M)),B=Y.create(-w*L),v=Y.create(H*L),b=W.BASE.multiplyUnsafe(B).add(O.multiplyUnsafe(v));if(b.is0())throw Error("point at infinify");return b.assertValidity(),b}hasHighS(){return T(this.s)}toBytes(M=S){if(N6(M),M==="der")return D8(N0.hexFromSig(this));const N=Y.toBytes(this.r),Z=Y.toBytes(this.s);if(M==="recovered"){if(this.recovery==null)throw Error("recovery bit must be present");return I0(Uint8Array.of(this.recovery),N,Z)}return I0(N,Z)}toHex(M){return B1(this.toBytes(M))}assertValidity(){}static fromCompact(M){return f.fromBytes(Q0("sig",M),"compact")}static fromDER(M){return f.fromBytes(Q0("sig",M),"der")}normalizeS(){return this.hasHighS()?new f(this.r,Y.neg(this.s),this.recovery):this}toDERRawBytes(){return this.toBytes("der")}toDERHex(){return B1(this.toBytes("der"))}toCompactRawBytes(){return this.toBytes("compact")}toCompactHex(){return B1(this.toBytes("compact"))}}const m=J.bits2int||function(M){if(M.length>8192)throw Error("input is too large");const N=L1(M),Z=8*M.length-F;return Z>0?N>>BigInt(Z):N},x=J.bits2int_modN||function(M){return Y.create(m(M))},c=a1(F);function i(M){return function(N,Z,H,R){if(!w6(Z,H,R))throw Error("expected valid "+N+": "+H+" <= n < "+R+", got "+Z)}("num < 2^"+F,M,S0,c),Y.toBytes(M)}function D(M,N){return o0(M,void 0,"message"),N?o0(Q(M),void 0,"prehashed message"):M}return Object.freeze({keygen:U,getPublicKey:K,getSharedSecret:$,utils:P,lengths:z,Point:W,sign(M,N,Z={}){M=Q0("message",M);const{seed:H,k2sig:R}=function(k,j,O){if(["recovered","canonical"].some((r)=>(r in O)))throw Error("sign() legacy options not supported");const{lowS:L,prehash:w,extraEntropy:B}=M6(O,C);k=D(k,w);const v=x(k),b=a0(Y,j),A=[i(b),i(v)];if(B!=null&&B!==!1){const r=B===!0?V(z.secretKey):B;A.push(Q0("extraEntropy",r))}const h=I0(...A),d=v;return{seed:h,k2sig(r){const I=m(r);if(!Y.isValidNot0(I))return;const g=Y.inv(I),y=W.BASE.multiply(I).toAffine(),o=Y.create(y.x);if(o===S0)return;const E=Y.create(g*Y.create(d+o*b));if(E===S0)return;let _=(y.x===o?0:2)|Number(y.y&C1),u=E;return L&&T(E)&&(u=Y.neg(E),_^=1),new f(o,u,_)}}}(M,N,Z);return function(k,j,O){if(typeof k!="number"||k<2)throw Error("hashLen must be a number");if(typeof j!="number"||j<2)throw Error("qByteLen must be a number");if(typeof O!="function")throw Error("hmacFn must be a function");const L=(I)=>new Uint8Array(I),w=(I)=>Uint8Array.of(I);let B=L(k),v=L(k),b=0;const A=()=>{B.fill(1),v.fill(0),b=0},h=(...I)=>O(v,B,...I),d=(I=L(0))=>{v=h(w(0),I),B=h(),I.length!==0&&(v=h(w(1),I),B=h())},r=()=>{if(b++>=1000)throw Error("drbg: tried 1000 values");let I=0;const g=[];for(;I<j;){B=h();const y=B.slice();g.push(y),I+=B.length}return I0(...g)};return(I,g)=>{let y;for(A(),d(I);!(y=g(r()));)d();return A(),y}}(Q.outputLen,Y.BYTES,G)(H,R)},verify(M,N,Z,H={}){const{lowS:R,prehash:k,format:j}=M6(H,C);if(Z=Q0("publicKey",Z),N=D(Q0("message",N),k),("strict"in H))throw Error("options.strict was renamed to lowS");const O=j===void 0?function(L){let w;const B=typeof L=="string"||A8(L),v=!B&&L!==null&&typeof L=="object"&&typeof L.r=="bigint"&&typeof L.s=="bigint";if(!B&&!v)throw Error("invalid signature, expected Uint8Array, hex string or Signature instance");if(v)w=new f(L.r,L.s);else if(B){try{w=f.fromBytes(Q0("sig",L),"der")}catch(b){if(!(b instanceof N0.Err))throw b}if(!w)try{w=f.fromBytes(Q0("sig",L),"compact")}catch(b){return!1}}return w||!1}(M):f.fromBytes(Q0("sig",M),j);if(O===!1)return!1;try{const L=W.fromBytes(Z);if(R&&O.hasHighS())return!1;const{r:w,s:B}=O,v=x(N),b=Y.inv(B),A=Y.create(v*b),h=Y.create(w*b),d=W.BASE.multiplyUnsafe(A).add(L.multiplyUnsafe(h));if(d.is0())return!1;return Y.create(d.x)===w}catch(L){return!1}},recoverPublicKey(M,N,Z={}){const{prehash:H}=M6(Z,C);return N=D(N,H),f.fromBytes(M,"recovered").recoverPublicKey(N).toBytes()},Signature:f,hash:Q})},CV=function(W){const{CURVE:Q,curveOpts:J}=function(G){const X={a:G.a,b:G.b,p:G.Fp.ORDER,n:G.n,h:G.h,Gx:G.Gx,Gy:G.Gy},Y=G.Fp;let q=G.allowedPrivateKeyLengths?Array.from(new Set(G.allowedPrivateKeyLengths.map((F)=>Math.ceil(F/2)))):void 0;return{CURVE:X,curveOpts:{Fp:Y,Fn:s1(X.n,{BITS:G.nBitLength,allowedLengths:q,modFromBytes:G.wrapPrivateKey}),allowInfinityPoint:G.allowInfinityPoint,endo:G.endo,isTorsionFree:G.isTorsionFree,clearCofactor:G.clearCofactor,fromBytes:G.fromBytes,toBytes:G.toBytes}}}(W),V={hmac:W.hmac,randomBytes:W.randomBytes,lowS:W.lowS,bits2int:W.bits2int,bits2int_modN:W.bits2int_modN};return{CURVE:Q,curveOpts:J,hash:W.hash,ecdsaOpts:V}},jV=function(W){const{CURVE:Q,curveOpts:J,hash:V,ecdsaOpts:G}=CV(W);return function(X,Y){const q=Y.Point;return Object.assign({},Y,{ProjectivePoint:q,CURVE:Object.assign({},X,qW(q.Fn.ORDER,q.Fn.BITS))})}(W,$V(kV(Q,J),V,G))},S8=function(W,...Q){let J=p7[W];if(J===void 0){const V=O6(r7(W));J=I0(V,V),p7[W]=J}return O6(I0(J,...Q))},v6=function(W){const{Fn:Q,BASE:J}=I1,V=a0(Q,W),G=J.multiply(V);return{scalar:u6(G.y)?V:Q.neg(V),bytes:h6(G)}},jW=function(W){const Q=N8;if(!Q.isValidNot0(W))throw Error("invalid x: Fail if x \u2265 p");const J=Q.create(W*W),V=Q.create(J*W+BigInt(7));let G=Q.sqrt(V);u6(G)||(G=Q.neg(G));const X=I1.fromAffine({x:W,y:G});return X.assertValidity(),X},BW=function(...W){return I1.Fn.create(o1(S8("BIP0340/challenge",...W)))},b7=function(W){return v6(W).bytes},MV=function(W,Q,J=O8(32)){const{Fn:V}=I1,G=Q0("message",W),{bytes:X,scalar:Y}=v6(Q),q=Q0("auxRand",J,32),F=V.toBytes(Y^o1(S8("BIP0340/aux",q))),U=S8("BIP0340/nonce",F,X,G),{bytes:K,scalar:$}=v6(U),P=BW(K,X,G),z=new Uint8Array(64);if(z.set(K,0),z.set(V.toBytes(V.create($+P*Y)),32),!RW(z,G,X))throw Error("sign: Invalid signature produced");return z},RW=function(W,Q,J){const{Fn:V,BASE:G}=I1,X=Q0("signature",W,64),Y=Q0("message",Q),q=Q0("publicKey",J,32);try{const F=jW(o1(q)),U=o1(X.subarray(0,32));if(!w6(U,f7,M1.p))return!1;const K=o1(X.subarray(32,64));if(!w6(K,f7,M1.n))return!1;const $=BW(V.toBytes(U),h6(F),Y),P=G.multiplyUnsafe(K).add(F.multiplyUnsafe(V.neg($))),{x:z,y:C}=P.toAffine();return!(P.is0()||!u6(C)||z!==U)}catch(F){return!1}},H1=typeof globalThis=="object"&&("crypto"in globalThis)?globalThis.crypto:void 0,i7=(()=>typeof Uint8Array.from([]).toHex=="function"&&typeof Uint8Array.fromHex=="function")(),JV=Array.from({length:256},(W,Q)=>Q.toString(16).padStart(2,"0")),I7=48,QV=57,D7=65,VV=70,O7=97,GV=102;class E6{}class n7 extends E6{constructor(W,Q,J,V){super(),this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.blockLen=W,this.outputLen=Q,this.padOffset=J,this.isLE=V,this.buffer=new Uint8Array(W),this.view=k6(this.buffer)}update(W){L8(this),W1(W=g6(W));const{view:Q,buffer:J,blockLen:V}=this,G=W.length;for(let X=0;X<G;){const Y=Math.min(V-this.pos,G-X);if(Y!==V)J.set(W.subarray(X,X+Y),this.pos),this.pos+=Y,X+=Y,this.pos===V&&(this.process(Q,0),this.pos=0);else{const q=k6(W);for(;V<=G-X;X+=V)this.process(q,X)}}return this.length+=W.length,this.roundClean(),this}digestInto(W){L8(this),function(K,$){W1(K);const P=$.outputLen;if(K.length<P)throw Error("digestInto() expects output buffer of length at least "+P)}(W,this),this.finished=!0;const{buffer:Q,view:J,blockLen:V,isLE:G}=this;let{pos:X}=this;Q[X++]=128,I8(this.buffer.subarray(X)),this.padOffset>V-X&&(this.process(J,0),X=0);for(let K=X;K<V;K++)Q[K]=0;(function(K,$,P,z){if(typeof K.setBigUint64=="function")return K.setBigUint64($,P,z);const C=BigInt(32),S=BigInt(4294967295),T=Number(P>>C&S),p=Number(P&S),f=z?4:0,m=z?0:4;K.setUint32($+f,T,z),K.setUint32($+m,p,z)})(J,V-8,BigInt(8*this.length),G),this.process(J,0);const Y=k6(W),q=this.outputLen;if(q%4)throw Error("_sha2: outputLen should be aligned to 32bit");const F=q/4,U=this.get();if(F>U.length)throw Error("_sha2: outputLen bigger than state");for(let K=0;K<F;K++)Y.setUint32(4*K,U[K],G)}digest(){const{buffer:W,outputLen:Q}=this;this.digestInto(W);const J=W.slice(0,Q);return this.destroy(),J}_cloneInto(W){W||(W=new this.constructor),W.set(...this.get());const{blockLen:Q,buffer:J,length:V,finished:G,destroyed:X,pos:Y}=this;return W.destroyed=X,W.finished=G,W.length=V,W.pos=Y,V%Q&&W.buffer.set(J),W}clone(){return this._cloneInto()}}var b0=Uint32Array.from([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),qV=Uint32Array.from([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),h0=new Uint32Array(64);class o7 extends n7{constructor(W=32){super(64,W,8,!1),this.A=0|b0[0],this.B=0|b0[1],this.C=0|b0[2],this.D=0|b0[3],this.E=0|b0[4],this.F=0|b0[5],this.G=0|b0[6],this.H=0|b0[7]}get(){const{A:W,B:Q,C:J,D:V,E:G,F:X,G:Y,H:q}=this;return[W,Q,J,V,G,X,Y,q]}set(W,Q,J,V,G,X,Y,q){this.A=0|W,this.B=0|Q,this.C=0|J,this.D=0|V,this.E=0|G,this.F=0|X,this.G=0|Y,this.H=0|q}process(W,Q){for(let $=0;$<16;$++,Q+=4)h0[$]=W.getUint32(Q,!1);for(let $=16;$<64;$++){const P=h0[$-15],z=h0[$-2],C=L0(P,7)^L0(P,18)^P>>>3,S=L0(z,17)^L0(z,19)^z>>>10;h0[$]=S+h0[$-7]+C+h0[$-16]|0}let{A:J,B:V,C:G,D:X,E:Y,F:q,G:F,H:U}=this;for(let $=0;$<64;$++){const P=U+(L0(Y,6)^L0(Y,11)^L0(Y,25))+((K=Y)&q^~K&F)+qV[$]+h0[$]|0,z=(L0(J,2)^L0(J,13)^L0(J,22))+YV(J,V,G)|0;U=F,F=q,q=Y,Y=X+P|0,X=G,G=V,V=J,J=P+z|0}var K;J=J+this.A|0,V=V+this.B|0,G=G+this.C|0,X=X+this.D|0,Y=Y+this.E|0,q=q+this.F|0,F=F+this.G|0,U=U+this.H|0,this.set(J,V,G,X,Y,q,F,U)}roundClean(){I8(h0)}destroy(){this.set(0,0,0,0,0,0,0,0),I8(this.buffer)}}var O6=XV(()=>new o7);class y6 extends E6{constructor(W,Q){super(),this.finished=!1,this.destroyed=!1,l7(W);const J=g6(Q);if(this.iHash=W.create(),typeof this.iHash.update!="function")throw Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const V=this.blockLen,G=new Uint8Array(V);G.set(J.length>V?W.create().update(J).digest():J);for(let X=0;X<G.length;X++)G[X]^=54;this.iHash.update(G),this.oHash=W.create();for(let X=0;X<G.length;X++)G[X]^=106;this.oHash.update(G),I8(G)}update(W){return L8(this),this.iHash.update(W),this}digestInto(W){L8(this),W1(W,this.outputLen),this.finished=!0,this.iHash.digestInto(W),this.oHash.update(W),this.oHash.digestInto(W),this.destroy()}digest(){const W=new Uint8Array(this.oHash.outputLen);return this.digestInto(W),W}_cloneInto(W){W||(W=Object.create(Object.getPrototypeOf(this),{}));const{oHash:Q,iHash:J,finished:V,destroyed:G,blockLen:X,outputLen:Y}=this;return W.finished=V,W.destroyed=G,W.blockLen=X,W.outputLen=Y,W.oHash=Q._cloneInto(W.oHash),W.iHash=J._cloneInto(W.iHash),W}clone(){return this._cloneInto()}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}var a7=(W,Q,J)=>new y6(W,Q).update(J).digest();a7.create=(W,Q)=>new y6(W,Q);var f6=BigInt(0),x6=BigInt(1),$6=(W)=>typeof W=="bigint"&&f6<=W,a1=(W)=>(x6<<BigInt(W))-x6,K0=BigInt(0),U0=BigInt(1),s0=BigInt(2),JW=BigInt(3),QW=BigInt(4),VW=BigInt(5),UV=BigInt(7),GW=BigInt(8),PV=BigInt(9),N7=BigInt(16),zV=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"],R1=BigInt(0),e0=BigInt(1),B6=new WeakMap,zW=new WeakMap;class ZW{constructor(W,Q){this.BASE=W.BASE,this.ZERO=W.ZERO,this.Fn=W.Fn,this.bits=Q}_unsafeLadder(W,Q,J=this.ZERO){let V=W;for(;Q>R1;)Q&e0&&(J=J.add(V)),V=V.double(),Q>>=e0;return J}precomputeWindow(W,Q){const{windows:J,windowSize:V}=j6(Q,this.bits),G=[];let X=W,Y=X;for(let q=0;q<J;q++){Y=X,G.push(Y);for(let F=1;F<V;F++)Y=Y.add(X),G.push(Y);X=Y.double()}return G}wNAF(W,Q,J){if(!this.Fn.isValid(J))throw Error("invalid scalar");let V=this.ZERO,G=this.BASE;const X=j6(W,this.bits);for(let Y=0;Y<X.windows;Y++){const{nextN:q,offset:F,isZero:U,isNeg:K,isNegF:$,offsetF:P}=T7(J,Y,X);J=q,U?G=G.add(w8($,Q[P])):V=V.add(w8(K,Q[F]))}return g7(J),{p:V,f:G}}wNAFUnsafe(W,Q,J,V=this.ZERO){const G=j6(W,this.bits);for(let X=0;X<G.windows&&J!==R1;X++){const{nextN:Y,offset:q,isZero:F,isNeg:U}=T7(J,X,G);if(J=Y,!F){const K=Q[q];V=V.add(U?K.negate():K)}}return g7(J),V}getPrecomputes(W,Q,J){let V=B6.get(Q);return V||(V=this.precomputeWindow(Q,W),W!==1&&(typeof J=="function"&&(V=J(V)),B6.set(Q,V))),V}cached(W,Q,J){const V=R6(W);return this.wNAF(V,this.getPrecomputes(V,W,J),Q)}unsafe(W,Q,J,V){const G=R6(W);return G===1?this._unsafeLadder(W,Q,V):this.wNAFUnsafe(G,this.getPrecomputes(G,W,J),Q,V)}createCache(W,Q){FW(Q,this.bits),zW.set(W,Q),B6.delete(W)}hasCache(W){return R6(W)!==1}}var y7=(W,Q)=>(W+(W>=0?Q:-Q)/HW)/Q,N0={Err:class extends Error{constructor(W=""){super(W)}},_tlv:{encode(W,Q){const{Err:J}=N0;if(W<0||W>256)throw new J("tlv.encode: wrong tag");if(1&Q.length)throw new J("tlv.encode: unpadded data");const V=Q.length/2,G=$8(V);if(G.length/2&128)throw new J("tlv.encode: long form length too big");const X=V>127?$8(G.length/2|128):"";return $8(W)+X+G+Q},decode(W,Q){const{Err:J}=N0;let V=0;if(W<0||W>256)throw new J("tlv.encode: wrong tag");if(Q.length<2||Q[V++]!==W)throw new J("tlv.decode: wrong tlv");const G=Q[V++];let X=0;if(128&G){const q=127&G;if(!q)throw new J("tlv.decode(long): indefinite length not supported");if(q>4)throw new J("tlv.decode(long): byte length is too big");const F=Q.subarray(V,V+q);if(F.length!==q)throw new J("tlv.decode: length bytes not complete");if(F[0]===0)throw new J("tlv.decode(long): zero leftmost byte");for(let U of F)X=X<<8|U;if(V+=q,X<128)throw new J("tlv.decode(long): not minimal encoding")}else X=G;const Y=Q.subarray(V,V+X);if(Y.length!==X)throw new J("tlv.decode: wrong value length");return{v:Y,l:Q.subarray(V+X)}}},_int:{encode(W){const{Err:Q}=N0;if(W<S0)throw new Q("integer: negative integers are not allowed");let J=$8(W);if(8&Number.parseInt(J[0],16)&&(J="00"+J),1&J.length)throw new Q("unexpected DER parsing assertion: unpadded hex");return J},decode(W){const{Err:Q}=N0;if(128&W[0])throw new Q("invalid signature integer: negative");if(W[0]===0&&!(128&W[1]))throw new Q("invalid signature integer: unnecessary leading zero");return L1(W)}},toSig(W){const{Err:Q,_int:J,_tlv:V}=N0,G=Q0("signature",W),{v:X,l:Y}=V.decode(48,G);if(Y.length)throw new Q("invalid signature: left bytes after parsing");const{v:q,l:F}=V.decode(2,X),{v:U,l:K}=V.decode(2,F);if(K.length)throw new Q("invalid signature: left bytes after parsing");return{r:J.decode(q),s:J.decode(U)}},hexFromSig(W){const{_tlv:Q,_int:J}=N0,V=Q.encode(2,J.encode(W.r))+Q.encode(2,J.encode(W.s));return Q.encode(48,V)}},S0=BigInt(0),C1=BigInt(1),HW=BigInt(2),C8=BigInt(3),HV=BigInt(4),M1={p:BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),n:BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),h:BigInt(1),a:BigInt(0),b:BigInt(7),Gx:BigInt("0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),Gy:BigInt("0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8")},BV={beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),basises:[[BigInt("0x3086d221a7d46bcde86c90e49284eb15"),-BigInt("0xe4437ed6010e88286f547fa90abfe4c3")],[BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),BigInt("0x3086d221a7d46bcde86c90e49284eb15")]]},RV=BigInt(0),f7=BigInt(1),S6=BigInt(2),N8=s1(M1.p,{sqrt(W){const Q=M1.p,J=BigInt(3),V=BigInt(6),G=BigInt(11),X=BigInt(22),Y=BigInt(23),q=BigInt(44),F=BigInt(88),U=W*W*W%Q,K=U*U*W%Q,$=$0(K,J,Q)*K%Q,P=$0($,J,Q)*K%Q,z=$0(P,S6,Q)*U%Q,C=$0(z,G,Q)*z%Q,S=$0(C,X,Q)*C%Q,T=$0(S,q,Q)*S%Q,p=$0(T,F,Q)*T%Q,f=$0(p,q,Q)*S%Q,m=$0(f,J,Q)*K%Q,x=$0(m,Y,Q)*C%Q,c=$0(x,V,Q)*U%Q,i=$0(c,S6,Q);if(!N8.eql(N8.sqr(i),W))throw Error("Cannot find square root");return i}}),CW=function(W,Q){const J=(V)=>jV({...W,hash:V});return{...J(Q),create:J}}({...M1,Fp:N8,lowS:!0,endo:BV},O6),p7={},h6=(W)=>W.toBytes(!0).slice(1),I1=(()=>CW.Point)(),u6=(W)=>W%S6===RV,o1=L1,m6=(()=>{const W=(Q=O8(48))=>KW(Q,M1.n);return CW.utils.randomSecretKey,{keygen(Q){const J=W(Q);return{secretKey:J,publicKey:b7(J)}},getPublicKey:b7,sign:MV,verify:RW,Point:I1,utils:{randomSecretKey:W,randomPrivateKey:W,taggedHash:S8,lift_x:jW,pointToBytes:h6,numberToBytesBE:T8,bytesToNumberBE:L1,mod:C0},lengths:{secretKey:32,publicKey:32,publicKeyHasPrefix:!1,signature:64,seed:48}}})(),LV=new TextEncoder,IV=new TextDecoder,t0=(W)=>LV.encode(W),n1=(W)=>IV.decode(W),A6=(W)=>Array.from(W,(Q)=>Q.toString(16).padStart(2,"0")).join(""),v0=JSON.stringify,v8=JSON.parse,MW=(W,Q=Number.MAX_SAFE_INTEGER)=>W.split("").reduce((J,V)=>J+V.charCodeAt(0),0)%Q,_6="AES-GCM",DV={},j8=(W)=>DV[W]??=crypto.subtle.digest("SHA-1",t0(W)).then((Q)=>{const J=new Uint8Array(Q);let V="";for(let G of J)V+=G.toString(36);return V}),OV=async(W,Q)=>{const J=crypto.getRandomValues(new Uint8Array(12)),V=await W,G=await crypto.subtle.encrypt({name:_6,iv:J},V,t0(Q));return`${J.join(",")}\$${((X)=>{const Y=new Uint8Array(X);let q="";for(let F=0;F<Y.length;F+=32768)q+=String.fromCharCode(...Y.subarray(F,F+32768));return btoa(q)})(G)}`},xV=async(W,Q)=>{const[J,V]=Q.split("$");if(!J||!V)throw Error("Invalid encrypted payload format");const G=Uint8Array.from(J.split(","),Number),X=await W,Y=await crypto.subtle.decrypt({name:_6,iv:G},X,(q=V,Uint8Array.from(atob(q),(F)=>F.charCodeAt(0)).buffer));var q;return n1(Y)},Z0="GenosRTC",c6=(W,Q)=>Array.from({length:W},Q),wV="0123456789AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz",T6=(W)=>Array.from(crypto.getRandomValues(new Uint8Array(W)),(Q)=>wV[Q%62]).join(""),k1=T6(20),j1=Promise.all.bind(Promise),NV=typeof window!="undefined",{entries:SV,fromEntries:LW}=Object,vV=()=>{},w0=(W)=>Error(`${Z0}: ${W}`),B8=(...W)=>W.join("@"),h7="icegatheringstatechange",u7="offer",AV=[...c6(3,(W,Q)=>`stun:stun${Q||""}.l.google.com:19302`),"stun:stun.cloudflare.com:3478"].map((W)=>({urls:W})),L6=(W,{rtcConfig:Q,rtcPolyfill:J,turnConfig:V})=>{const G=new(J||RTCPeerConnection)({iceServers:[...AV,...V||[]],...Q}),X={};let Y,q=!1,F=!1;const U=(P)=>Object.assign(P,{binaryType:"arraybuffer",bufferedAmountLowThreshold:65535,onmessage(z){return X.data?.(z.data)},onopen(){return X.connect?.()},onclose(){return X.close?.()},onerror(z){return!z?.error?.message?.includes("User-Initiated Abort")&&X.error?.(z)}}),K=()=>Promise.race([new Promise((P)=>{const z=()=>{G.iceGatheringState==="complete"&&(G.removeEventListener(h7,z),P())};G.addEventListener(h7,z),z()}),new Promise((P)=>setTimeout(P,5000))]).then(()=>({type:G.localDescription.type,sdp:G.localDescription.sdp.replace(/a=ice-options:trickle\s\n/g,"")}));W?U(Y=G.createDataChannel("data")):G.ondatachannel=({channel:P})=>U(Y=P),G.onnegotiationneeded=async()=>{try{q=!0,await G.setLocalDescription(),X.signal?.(await K())}catch(P){X.error?.(P)}finally{q=!1}},G.onconnectionstatechange=()=>{["disconnected","failed","closed"].includes(G.connectionState)&&X.close?.()},G.ontrack=(P)=>{X.track?.(P.track,P.streams[0]),X.stream?.(P.streams[0])},G.onremovestream=(P)=>X.stream?.(P.stream),W&&!G.canTrickleIceCandidates&&G.onnegotiationneeded();const $=()=>G.getSenders();return{created:Date.now(),connection:G,get channel(){return Y},get isDead(){return G.connectionState==="closed"},async signal(P){if(Y?.readyState!=="open"||P.sdp?.includes("a=rtpmap"))try{if(P.type===u7){if(q||G.signalingState!=="stable"&&!F){if(W)return;await j1([G.setLocalDescription({type:"rollback"}),G.setRemoteDescription(P)])}else await G.setRemoteDescription(P);await G.setLocalDescription();const z=await K();return X.signal?.(z),z}if(P.type==="answer"){F=!0;try{await G.setRemoteDescription(P)}finally{F=!1}}}catch(z){X.error?.(z)}},sendData(P){return Y.send(P)},destroy(){Y?.close(),G.close(),q=F=!1},setHandlers(P){return Object.assign(X,P)},offerPromise:W?new Promise((P)=>X.signal=(z)=>z.type===u7&&P(z)):Promise.resolve(),addStream(P){return P.getTracks().forEach((z)=>G.addTrack(z,P))},removeStream(P){return $().filter((z)=>P.getTracks().includes(z.track)).forEach((z)=>G.removeTrack(z))},addTrack(P,z){return G.addTrack(P,z)},removeTrack(P){const z=$().find((C)=>C.track===P);z&&G.removeTrack(z)},replaceTrack(P,z){return $().find((C)=>C.track===P)?.replaceTrack(z)}}},TV=Object.getPrototypeOf(Uint8Array),i1=16369,R8=255,I6="bufferedamountlow",$1=(W)=>"@_"+W,gV=(W,Q,J)=>{const V=new Map,G=new Map,X=new Map,Y={},q={},F={},U={},K=new Map,$=(k,...j)=>K.get(k)?.forEach((O)=>O(...j)),P=(k,j)=>{const O=k?Array.isArray(k)?k:[k]:V.keys();return Array.from(O,(L)=>{const w=V.get(L);return w?j(L,w):(console.warn(`${Z0}: no peer with id ${L}`),null)}).filter(Boolean)},z=(k)=>{V.has(k)&&(V.delete(k),delete Y[k],delete q[k],delete F[k],delete U[k],$("peer:leave",k),Q(k))},C=(k)=>new Promise((j,O)=>{let L=setTimeout(()=>{k.removeEventListener(I6,w),O(Error(Z0+": bufferLow timeout"))},5000);function w(){clearTimeout(L),k.removeEventListener(I6,w),j()}k.addEventListener(I6,w)}),S=(k)=>{if(X.has(k))return X.get(k);if(!k)throw w0("action type is required");const j=t0(k);if(j.byteLength>12)throw w0(`"${k}" exceeds 12 bytes`);const O=new Uint8Array(12).map((b,A)=>j[A]||0);let L=0;const w=new Map([["message",new Set],["progress",new Set]]),B=async(b,A,h,d)=>{if(h&&typeof h!="object")throw w0("meta must be object");if(b===void 0)throw w0("data cannot be undefined");const r=b instanceof Blob,I=r||b instanceof ArrayBuffer||b instanceof TV,g=typeof b!="string";if(h&&!I)throw w0("meta only allowed with binary");const y=I?new Uint8Array(r?await b.arrayBuffer():b):t0(g?v0(b):b),o=h?t0(v0(h)):null,E=Math.ceil(y.byteLength/i1)+(h?1:0)||1;if(E>100)throw w0("Message too large, exceeds max chunks 100");const _=c6(E,(u,l)=>{const n=l===E-1,e=h&&l===0,W0=e?o:y.subarray(h?(l-1)*i1:l*i1,h?l*i1:(l+1)*i1),V0=new Uint8Array(15+W0.byteLength);return V0.set(O),V0.set([L],12),V0.set([n|e<<1|I<<2|g<<3],13),V0.set([Math.round((l+1)/E*R8)],14),V0.set(W0,15),V0});return L=L+1&R8,j1(P(A,async(u,l)=>{const{channel:n}=l;for(let e=0;e<E;e++){let W0=0;for(;n.bufferedAmount>n.bufferedAmountLowThreshold;){if(W0++>3)throw w0(`${Z0}: send buffer full, max retries reached for peer ${u}`);try{await C(n)}catch(V0){console.warn(V0.message),await new Promise((A0)=>setTimeout(A0,200))}}if(!V.has(u))break;l.sendData(_[e]),d?.(_[e][14]/R8,u,h)}}))};G.set(k,{listeners:w,send:B});const v={send:B,on(b,A){return w.get(b)?.add(A)},off(b,A){return w.get(b)?.delete(A)}};return X.set(k,v),v},T=async()=>{try{await H(""),await new Promise((k)=>setTimeout(k,99))}catch(k){console.warn(Z0+": error sending leave",k)}for(let[k,j]of V){try{j.destroy()}catch{}V.delete(k)}J()},{send:p,on:f}=S($1("ping")),{send:m,on:x}=S($1("pong")),{send:c,on:i}=S($1("signal")),{send:D,on:M}=S($1("stream")),{send:N,on:Z}=S($1("track")),{send:H,on:R}=S($1("leave"));return W((k,j)=>{V.has(j)||(V.set(j,k),k.setHandlers({data(O){return((L,w)=>{try{const B=new Uint8Array(w),v=n1(B.subarray(0,12)).replace(/\0/g,"");if(!G.has(v))return console.warn(`${Z0}: unregistered type (${v})`);const[b]=B.subarray(12,13),[A]=B.subarray(13,14),[h]=B.subarray(14,15),d=B.subarray(15),r=!!(1&A),I=!!(2&A),g=!!(4&A),y=!!(8&A),o=G.get(v),E=(Y[L]||={})[v]||={};if(E[b]?.chunks?.length>100)return void console.warn(`${Z0}: peer ${L} sent too many chunks for nonce ${b}, ignoring.`);const _=E[b]||={chunks:[]};if(I)try{_.meta=v8(n1(d))}catch{return void console.warn(`${Z0}: failed to parse meta from peer ${L} for type ${v}`)}else _.chunks.push(d);if(o.listeners.get("progress").forEach((n)=>{try{n(h/R8,L,_.meta)}catch(e){console.error(e)}}),!r)return;const u=new Uint8Array(_.chunks.reduce((n,e)=>n+e.byteLength,0));let l;if(_.chunks.reduce((n,e)=>(u.set(e,n),n+e.byteLength),0),delete E[b],g)l=u;else if(y)try{l=v8(n1(u))}catch{return void console.warn(`${Z0}: failed to parse JSON message data from peer ${L} for type ${v}`)}else l=n1(u);o.listeners.get("message").forEach((n)=>{try{n(l,L,_.meta)}catch(e){console.error(e)}})}catch(B){console.error(`${Z0}: error handling data from peer ${L}:`,B)}})(j,O)},stream(O){$("stream:add",O,j,F[j]),delete F[j]},track(O,L){$("track:add",O,L,j,U[j]),delete U[j]},signal(O){return c(O,j)},close(){return z(j)},error(O){console.error(`${Z0}: peer error for ${j}`,O),z(j)}}),$("peer:join",j))}),f("message",(k,j)=>m("",j)),x("message",(k,j)=>{q[j]?.(),delete q[j]}),i("message",(k,j)=>V.get(j)?.signal(k)),M("message",(k,j)=>F[j]=k),Z("message",(k,j)=>U[j]=k),R("message",(k,j)=>z(j)),NV&&addEventListener("beforeunload",T),{on(k,j){K.has(k)||K.set(k,new Set),K.get(k).add(j)},off(k,j){return K.get(k)?.delete(j)},channel:S,leave:T,async ping(k){if(!k)throw w0("ping() requires target peer ID");const j=Date.now();return p("",k),await new Promise((O)=>q[k]=O),Date.now()-j},getPeers(){return LW(Array.from(V,([k,j])=>[k,j.connection]))},addStream(k,j,O){return P(j,async(L,w)=>{O&&await D(O,L),w.addStream(k)})},removeStream(k,j){return P(j,(O,L)=>L.removeStream(k))},addTrack(k,j,O,L){return P(O,async(w,B)=>{L&&await N(L,w),B.addTrack(k,j)})},removeTrack(k,j){return P(j,(O,L)=>L.removeTrack(k))},replaceTrack(k,j,O,L){return P(O,async(w,B)=>{L&&await N(L,w),B.replaceTrack(k,j)})}}},M8={},IW={};if(typeof window!="undefined"){const W=()=>{console.info("\u26A1 [GenosRTC] Network event detected. Forcing reconnection\u2026"),Object.values(IW).forEach((Q)=>{Q.socket&&Q.socket.readyState!==WebSocket.OPEN&&Q.socket.readyState!==WebSocket.CONNECTING&&Q.forceReconnect()})};window.addEventListener("online",()=>{console.info("\u2705 Reconnected to the network."),W()}),window.addEventListener("offline",async()=>{console.info("\u274C Disconnected from the network.")}),document.addEventListener("visibilitychange",()=>{document.visibilityState==="visible"&&W()})}var EV=(W,Q,J,V)=>(W.relayUrls??(V?((G,X)=>{const Y=[...G];let q=Y.length;const F=()=>{const U=1e4*Math.sin(X++);return U-Math.floor(U)};for(;q;){const U=Math.floor(F()*q--);[Y[q],Y[U]]=[Y[U],Y[q]]}return Y})(Q,MW(W.appId)):Q)).slice(0,W.relayUrls?.length??W.relayRedundancy??J),DW={},OW="EVENT",xW=m6.utils.randomSecretKey(),yV=A6(m6.getPublicKey(xW)),d6={},r1={},fV={},wW=()=>Math.floor(Date.now()/1000),NW=(W)=>fV[W]??=MW(W,1e4)+20000,m7=async(W,Q)=>{const J={kind:NW(W),content:Q,pubkey:yV,created_at:wW(),tags:[["x",W]]},V=new Uint8Array(await crypto.subtle.digest("SHA-256",t0(v0([0,J.pubkey,J.created_at,J.kind,J.tags,J.content])))),G=m6.sign(V,xW);return v0([OW,{...J,id:A6(V),sig:A6(G)}])},_7=(W,Q)=>(d6[W]=Q,v0(["REQ",W,{kinds:[NW(Q)],since:wW(),"#x":[Q]}])),c7=(W)=>(delete d6[W],v0(["CLOSE",W])),l6=(({init:W,subscribe:Q,announce:J})=>{const V={};let G,X,Y=!1;return(q,F,U)=>{const{appId:K}=q;if(V[K]?.[F])return V[K][F];if(!q||!F||!K&&!q.firebaseApp)throw w0(q?F?"appId missing":"roomId required":"config required");let $=vV;if(!Y){const Z=W(q);X=c6(20,()=>L6(!0,q)),G=Array.isArray(Z)?Z:[Z];const H=setInterval(()=>{X=X.filter((R)=>{const k=Date.now()-R.created<57333;return k||R.destroy(),k})},57333);V.offerCleanupTimer||=H,Y=!0}const P={},z={},C=B8(Z0,K,F),S=j8(C),T=j8(B8(C,k1)),p=(async(Z,H,R)=>{const k=await crypto.subtle.digest("SHA-256",t0(`${Z}:${H}:${R}`));return crypto.subtle.importKey("raw",k,{name:_6},!1,["encrypt","decrypt"])})(q.password||"",K,F),f=(Z)=>async(H)=>({type:H.type,sdp:await Z(p,H.sdp)}),m=f(xV),x=f(OV),c=(Z,H)=>{z[H]!==Z&&(z[H]?.destroy(),z[H]=Z,$(Z,H),P[H]?.forEach((R)=>R!==Z&&R.destroy()),delete P[H])},i=(Z,H)=>{z[H]===Z&&delete z[H]},D=j1(G.map(async(Z,H)=>{return Q(await Z,await S,await T,(R=H,async(k,j,O)=>{const[L,w]=await j1([S,T]);if(k!==L&&k!==w)return;const{peerId:B,offer:v,answer:b}=typeof j=="string"?v8(j):j;if(B!==k1&&!z[B])if(v){if(P[B]?.[R]&&k1>B)return;const A=L6(!1,q);A.setHandlers({connect(){return c(A,B)},close(){return i(A,B)}});try{const h=await m(v);if(A.isDead)return;const[d,r]=await j1([j8(B8(C,B)),A.signal(h).then(x)]);O(d,v0({peerId:k1,answer:r}))}catch{U?.({error:"decryption failed (offer)",appId:K,peerId:B,roomId:F})}}else if(b){const A=P[B]?.[R];if(!A||A.isDead)return;A.setHandlers({connect(){return c(A,B)},close(){return i(A,B)}});try{A.signal(await m(b))}catch{U?.({error:"decryption failed (answer)",appId:K,peerId:B,roomId:F})}}else{if(P[B]?.[R])return;const A=X.pop()||L6(!0,q),[h,{offer:d}]=await j1([j8(B8(C,B)),A.offerPromise.then(x).then((r)=>({offer:r}))]);P[B]||=[],P[B][R]=A,A.setHandlers({connect(){return c(A,B)},close(){return i(A,B)}}),O(h,v0({peerId:k1,offer:d,peer:A}))}}));var R})),M=[];D.then((Z)=>{G.forEach((H,R)=>{const k=async()=>{const j=await J(await H,await S,await T);M[R]=setTimeout(k,typeof j=="number"?j:5333)};k()}),V[K][F].onCleanup=()=>{delete V[K][F],M.forEach(clearTimeout),Z.forEach((H)=>H()),Object.keys(V).length===0&&(clearInterval(V.offerCleanupTimer),delete V.offerCleanupTimer)}}),V[K]||={};const N=gV((Z)=>$=Z,(Z)=>delete z[Z],()=>N.onCleanup?.());return V[K][F]=N}})({init(W){return EV(W,pV,5,!0).map((Q)=>{const J=((V,G)=>{const X={};let Y=null;const q=()=>{Y&&(clearTimeout(Y),Y=null);const F=new WebSocket(V);F.onclose=()=>{M8[V]??=3333,Y=setTimeout(q,M8[V]),M8[V]*=2},F.onmessage=(U)=>G(U.data),X.socket=F,X.url=F.url,X.ready=new Promise((U)=>{F.onopen=()=>{M8[V]=3333,U(X)}}),X.send=(U)=>{F.readyState===1&&F.send(U)}};return X.forceReconnect=q,q(),IW[V]=X,X})(Q,(V)=>{const[G,X,Y,q]=v8(V);if(G===OW)r1[X]?.(d6[X],Y.content);else{const F=`${Z0}: relay failure from ${J.url} - `;G==="NOTICE"?console.warn(F+X):G!=="OK"||Y||console.warn(F+q)}});return DW[Q]=J,J.ready})},subscribe(W,Q,J,V){const G=T6(64),X=T6(64);return r1[G]=r1[X]=(Y,q)=>V(Y,q,async(F,U)=>W.send(await m7(F,U))),W.send(_7(G,Q)),W.send(_7(X,J)),()=>{W.send(c7(G)),W.send(c7(X)),delete r1[G],delete r1[X]}},async announce(W,Q){return W.send(await m7(Q,v0({peerId:k1})))}}),DG=(d7=DW,()=>LW(SV(d7).map(([W,Q])=>[W,Q.socket]))),d7,pV=["black.nostrcity.club","eu.purplerelay.com","ftp.halifax.rwth-aachen.de/nostr","nostr.cool110.xyz","nostr.data.haus","nostr.mom","nostr.oxtr.dev","nostr.sathoarder.com","nostr.vulpem.com","playground.nostrcheck.me/relay","relay.agorist.space","relay.binaryrobot.com","relay.fountain.fm","relay.mostro.network","relay.nostraddress.com","relay.nostrdice.com","relay.nostromo.social","relay.oldenburg.cool","relay.snort.social","relay.verified-nostr.com","sendit.nosflare.com","yabu.me/v2","relay.damus.io"].map((W)=>"wss://"+W);function SW(W,Q,J){let V=Q.timestamp;if(V?.physical>Date.now()+7200000)V={physical:Date.now()+7200000,logical:V.logical};if(!W?.timestamp)return{resolved:!0,value:Q.value,timestamp:V};if(J.compare(V,W.timestamp)<=0)return{resolved:!1};return{resolved:!0,value:Q.value,timestamp:V}}function vW(W,Q=50){const J=`gdb_oplog_${W}`;let V=[];function G(){try{const Y=localStorage.getItem(J);V=Y?JSON.parse(Y):[]}catch(Y){console.error("\u274C GDB: Failed to load oplog from localStorage:",Y),V=[]}}function X(){try{localStorage.setItem(J,JSON.stringify(V))}catch(Y){console.error("\u274C GDB: Failed to save oplog to localStorage:",Y)}}return G(),{add(Y){if(V.push(Y),V.length>Q)V.shift();X()},getDelta(Y,q){if(!Y)return[...V];return V.filter((F)=>q(F.timestamp,Y)>0)},getOldest(){return V[0]},clear(){V=[],localStorage.removeItem(J)}}}var bV=()=>{const W=new Map,Q=async()=>{try{const F=await navigator.storage.getDirectory(),K=await(await F.getFileHandle("~opfs-sync-test",{create:!0})).createSyncAccessHandle?.();return await K?.close(),await F.removeEntry("~opfs-sync-test"),!!K}catch{return!1}};let J="idb";const V=(async()=>{if(await Q())J="sync";else try{const F=await navigator.storage.getDirectory(),K=await(await F.getFileHandle("~opfs-async-test",{create:!0})).createWritable?.();if(await K?.close(),await F.removeEntry("~opfs-async-test"),K)J="async";else J="idb"}catch{J="idb"}})(),G=async(F,U)=>{if(!W.has(F))W.set(F,[]);const K=W.get(F),$=K[K.length-1]||Promise.resolve();let P;const z=new Promise((C)=>P=C);K.push(z);try{return await $,await U()}finally{if(K.shift(),P(),K.length===0)W.delete(F)}},X=(()=>{let F;const U=async()=>{if(!F)F=new Promise((K,$)=>{const P=indexedDB.open("opfs-fallback-db",1);P.onupgradeneeded=()=>P.result.createObjectStore("files"),P.onsuccess=()=>K(P.result),P.onerror=()=>$(P.error)});return F};return{getDB:U,get:async(K)=>{const $=await U();return new Promise((P,z)=>{const S=$.transaction("files","readonly").objectStore("files").get(K);S.onsuccess=()=>P(S.result||new Uint8Array),S.onerror=()=>z(S.error)})},set:async(K,$)=>{const P=await U();return new Promise((z,C)=>{const T=P.transaction("files","readwrite").objectStore("files").put($,K);T.onsuccess=()=>z(),T.onerror=()=>C(T.error)})}}})(),Y=async(F)=>{await V;try{if(J==="idb"){const z=await X.get(F);return{type:"loaded",name:F,data:z}}const K=await(await navigator.storage.getDirectory()).getFileHandle(F);if(J==="sync"){let z;try{z=await K.createSyncAccessHandle();const C=z.getSize(),S=new Uint8Array(C),T=z.read(S,{at:0});return{type:"loaded",name:F,data:S.slice(0,T)}}finally{z?.close()}}const $=await K.getFile(),P=new Uint8Array(await $.arrayBuffer());return{type:"loaded",name:F,data:P}}catch(U){const K=U.name==="NotFoundError"?"File not found":U.message||"Error reading file";return{type:"error",name:F,message:K}}},q=async(F,U)=>{if(await V,!(U instanceof Uint8Array))return{type:"error",name:F,message:"Content must be a Uint8Array"};return G(F,async()=>{try{if(J==="idb")return await X.set(F,U),{type:"saved",name:F};const $=await(await navigator.storage.getDirectory()).getFileHandle(F,{create:!0});if(J==="sync"){let P;try{P=await $.createSyncAccessHandle(),P.truncate(0),P.write(U,{at:0}),P.flush()}finally{P?.close()}}else{let P;try{P=await $.createWritable(),await P.write(U)}finally{await P?.close()}}return{type:"saved",name:F}}catch(K){return{type:"error",name:F,message:K.message||"Error saving file"}}})};self.onmessage=async({data:F})=>{const{type:U,name:K,content:$}=F;await V;const P={load:()=>Y(K),save:()=>q(K,$)};try{const z=P[U],C=z?await z():{type:"error",message:`Unrecognized action type: ${U}`};self.postMessage(C)}catch(z){console.error("\u274C Worker unexpected error:",z),self.postMessage({type:"error",name:K,message:z.message||"Unexpected worker error"})}}},AW=bV;var J1={$eq:(W,Q)=>W===Q,$ne:(W,Q)=>W!==Q,$gt:(W,Q)=>W>Q,$gte:(W,Q)=>W>=Q,$lt:(W,Q)=>W<Q,$lte:(W,Q)=>W<=Q,$in:(W,Q)=>Array.isArray(Q)&&(Array.isArray(W)?W.some((J)=>Q.includes(J)):Q.includes(W)),$between:(W,[Q,J])=>W>=Q&&W<=J,$exists:(W,Q)=>Q?W!==void 0:W===void 0,$text:{global:(W,Q)=>{const J=(G)=>String(G).normalize("NFD").replace(/[\u0300-\u036f]/g,"").toLowerCase().replace(/[^\w\s]/g,""),V=J(Q);return Object.values(W).some((G)=>typeof G==="object"?null.fieldSearch(G,V):J(G).includes(V))},field:(W,Q)=>{const J=(G)=>String(G).normalize("NFD").replace(/[\u0300-\u036f]/g,"").toLowerCase().replace(/[^\w\s]/g,""),V=J(Q);return Array.isArray(W)?W.some((G)=>J(G).includes(V)):J(W).includes(V)}},$like:(W,Q)=>typeof W==="string"&&typeof Q==="string"&&new RegExp(`^${Q.replace(/%/g,".*").replace(/_/g,".")}\$`,"i").test(W),$regex:(W,Q)=>typeof W==="string"&&new RegExp(Q.$regex||Q,"i").test(W),$and:(W,Q,J)=>Q.every((V)=>J.createFilter(V,J.allNodes)(W)),$or:(W,Q,J)=>Q.some((V)=>J.createFilter(V,J.allNodes)(W)),$not:(W,Q,J)=>!J.createFilter(Q,J.allNodes)(W),$edge:(W,Q,J)=>{if(!W.edges?.length||typeof Q!=="object"||Q===null)return!1;const V=J.createFilter(Q,J.allNodes),G=[...W.edges],X=new Set(G).add(W.id),Y=[];while(G.length){const q=G.shift(),F=J.allNodes[q];if(!F)continue;if(V(F))Y.push(F);F.edges?.forEach((U)=>!X.has(U)&&X.add(U)&&G.push(U))}if(Y.length)W._edgeResult=Y;return Y.length>0}},i6=(W,Q)=>Q.split(".").reduce((J,V)=>J&&typeof J==="object"&&(V in J)?J[V]:void 0,W),g8=(W,Q)=>{if(Object.keys(W).length===0)return()=>!0;return(J)=>Object.entries(W).every(([V,G])=>{if(V.startsWith("$"))return J1[V](J,G,{createFilter:g8,allNodes:Q});const X=i6(J.value,V);if(typeof G!=="object"||G===null)return J1.$eq(X,G);return Object.entries(G).every(([Y,q])=>{if(Y==="$text")return J1.$text.field(X,q);if(Y==="$between"&&q.every((F)=>F instanceof Date))return J1.$between(new Date(X),q);return J1[Y]?.(X,q,{createFilter:g8,allNodes:Q})??!1})})},r6=(W,Q)=>{const{$edge:J,...V}=Q.query||{},G=g8(V,W),X=Object.values(W).filter(G);let q=[...J?(()=>{const F=g8({$edge:J},W);X.forEach((K)=>F(K));const U=new Map;return X.forEach((K)=>{if(K._edgeResult)K._edgeResult.forEach(($)=>U.set($.id,$)),delete K._edgeResult}),Array.from(U.values())})():X];if(Q.field){const F=Q.order==="asc"?1:-1;q.sort((U,K)=>{const $=i6(U.value,Q.field),P=i6(K.value,Q.field);if(typeof $==="string"&&typeof P==="string")return $.localeCompare(P)*F;return(($??0)-(P??0))*F})}if(Q.$after){const F=q.findIndex((U)=>U.id===Q.$after);q=F>=0?q.slice(F+1):[]}if(Q.$before){const F=q.findIndex((U)=>U.id===Q.$before);q=F>=0?q.slice(0,F):[]}if(Q.$limit)q=q.slice(0,Q.$limit);return q};function TW(){let W=Date.now(),Q=0;return{now(){const J=Date.now();return W=Math.max(W,J),Q++,{physical:W,logical:Q}},update(J){if(!J||typeof J.physical!=="number"||typeof J.logical!=="number"){console.warn("\u26A0\uFE0F HybridClock.update received an invalid remote timestamp.",J);return}W=Math.max(W,J.physical),Q=Math.max(Q,J.logical)+1},compare(J,V){if(!J&&!V)return 0;if(!J)return-1;if(!V)return 1;if(J.physical>V.physical)return 1;if(J.physical<V.physical)return-1;if(J.logical>V.logical)return 1;if(J.logical<V.logical)return-1;return 0}}}var gW=function(W,Q){return W.length===Q.length&&W.every((J,V)=>J===Q[V])};async function uV(){if(console.info(navigator?.storage?.getDirectory?"\u2705 OPFS is enabled.":"\uD83D\uDEAB OPFS is not available."),navigator?.storage?.getDirectory)await navigator.storage.getDirectory()}var mV=function(){const W={nodes:{}};return{get nodes(){return W.nodes},set nodes(J){W.nodes=J||{}},upsert(J,V,G){const X=W.nodes[J];W.nodes[J]={id:J,value:V&&typeof V==="object"?yW(V):V,edges:X?.edges?[...X.edges]:[],timestamp:G}},get(J){return W.nodes[J]||null},link(J,V,G){const X=W.nodes[J],Y=W.nodes[V];if(X&&Y&&!X.edges.includes(V))W.nodes[J]={...X,edges:[...X.edges,V],timestamp:G}},getAllNodes(){return Object.values(W.nodes)},serialize(){return Z1.deflate(G1(W.nodes))},deserialize(J){W.nodes=w1(Z1.inflate(new Uint8Array(J)))}}};async function uG(W,Q={}){const{password:J,sm:V=!1,ii:G=!1,rx:X=!1,ai:Y=!1,geo:q=!1,relayUrls:F=null,turnConfig:U=null,saveDelay:K=200,oplogSize:$=20}=Q,P=mV(),z=TW(),C=vW(W,$),S=[];let T=null,p=[],f=null,m=null,x=null,c=null;const i=[],D={};Object.defineProperties(D,{hybridClock:{get:()=>z},graph:{get:()=>P},syncChannel:{get:()=>m},worker:{get:()=>f},oplog:{get:()=>C},broadcastChannel:{get:()=>x},options:{get:()=>Q},pako:{get:()=>Z1},encode:{get:()=>G1},decode:{get:()=>w1},operators:{get:()=>J1},deepClone:{get:()=>yW},generateHash:{get:()=>O}});async function M(I,g){const y=new URL(`./${I}.min.js`,import.meta.url).href,o=`https://cdn.jsdelivr.net/npm/genosdb@latest/dist/${I}.min.js`;try{const E=await import(y).catch(()=>{return console.warn(`\u26A0\uFE0F ${I} not found locally, loading from CDN...`),import(o)}),_=g&&typeof g==="object"?g:{},u=typeof E.init==="function"?E.init(D,E,_):null;if(u)Object.assign(D,u);return E}catch(E){throw console.error(`\u274C Initialization of ${I} failed:`,E),E}}function N(){const I=localStorage.getItem(`${W}_time`);T=I?JSON.parse(I):null}function Z(I){T=I,localStorage.setItem(`${W}_time`,JSON.stringify(I))}function H(){try{const I=URL.createObjectURL(new Blob([`(${AW.toString()})()`],{type:"application/javascript"}));f=new Worker(I),URL.revokeObjectURL(I),f.addEventListener("message",({data:g})=>{console.info(`\uD83D\uDCBE ${g.name} ${g.type}`)}),console.info("\u2699\uFE0F Worker initialized successfully.")}catch({message:I}){console.error("\u274C Failed to initialize worker:",I)}}function R(){const I={...P.nodes};p.forEach((g)=>g(I))}const k=hV(()=>R()),j=EW(async()=>{const I=i.splice(0,i.length);if(!I.length)return!1;return await m.send(I),!0},16);async function O(){return crypto.randomUUID()}async function L(){try{const g=await((y)=>new Promise((o,E)=>{const _=async({data:u})=>{if(u.type==="loaded"&&u.name===y)f.removeEventListener("message",_),o(new Uint8Array(u.data));else if(u.type==="error")f.removeEventListener("message",_),E(new Error(u.message||"Unknown error"))};f.addEventListener("message",_),f.postMessage({type:"load",name:y})}))(`${W}_graph.msgpack`).catch(()=>new Uint8Array);g.byteLength>0?P.deserialize(g):console.warn("\u26A0\uFE0F The file '_graph.msgpack' is empty or could not be loaded."),console.info(`\u2705 Graph loaded: [ ${P.getAllNodes().length} nodes ]`)}catch({message:I}){console.error("\u274C Error loading the graph:",I)}}async function w(){try{const I=P.serialize();return await((y,o)=>new Promise((E,_)=>{const u=({data:l})=>{if(l.type==="saved"&&l.name===y)f.removeEventListener("message",u),E();else if(l.type==="error")f.removeEventListener("message",u),_(new Error(l.message||"Save error"))};f.addEventListener("message",u),f.postMessage({type:"save",name:y,content:o})}))(`${W}_graph.msgpack`,I),x.postMessage("update"),!0}catch({message:I}){throw console.error("\u274C Save error:",I),new Error("Save failed")}}const B=EW(()=>w(),K);async function v(I){try{console.info("\uD83D\uDD04 Applying full graph from remote..."),P.nodes={...I.nodes},await w()}catch({message:g}){console.error(`\u274C Error applying the full graph: ${g}`)}}async function b(I){let g=!1,y=null;const o={upsert:(E)=>{const _=P.get(E.id),u=SW(_,E,z);if(u.resolved){if(P.upsert(E.id,u.value,u.timestamp),z.update(u.timestamp),C.add({type:"upsert",id:E.id,timestamp:u.timestamp}),g=!0,!y||z.compare(u.timestamp,y)>0)y=u.timestamp}},remove:(E)=>{const _=P.get(E.id);if(_&&z.compare(_.timestamp,E.timestamp)<0){if(delete P.nodes[E.id],z.update(E.timestamp),C.add({type:"remove",id:E.id,timestamp:E.timestamp}),g=!0,!y||z.compare(E.timestamp,y)>0)y=E.timestamp}},link:(E)=>{const _=P.get(E.sourceId),u=P.get(E.targetId);if(_&&u&&z.compare(_.timestamp,E.timestamp)<0){if(P.link(E.sourceId,E.targetId,E.timestamp),z.update(E.timestamp),C.add({type:"link",sourceId:E.sourceId,targetId:E.targetId,timestamp:E.timestamp}),g=!0,!y||z.compare(E.timestamp,y)>0)y=E.timestamp}},sync:async(E)=>{const _=E.timestamp;if(_===null){console.info("\uD83D\uDCEC [SYNC REQUEST] from new peer (no timestamp). Sending full graph."),await m.send([{type:"syncReceive",graph:P}]);return}console.info("\uD83D\uDCEC [SYNC REQUEST] since:",new Date(_.physical).toLocaleString());const u=C.getOldest();if(u&&z.compare(_,u.timestamp)<0){console.info("\uD83D\uDCA5 [FALLBACK TRIGGERED] Peer is too far behind. Sending FULL graph state."),await m.send([{type:"syncReceive",graph:P}]);return}const l=C.getDelta(_,z.compare);if(l.length>0){const n=l.map((W0)=>{if(W0.type==="upsert"){const V0=P.get(W0.id);return{...W0,value:V0?V0.value:null}}return W0}),e=Z1.deflate(G1(n));console.info(`\uD83D\uDE80 [DELTA SYNC SENDING] Found ${l.length} new operations to send.`),await m.send([{type:"deltaSync",operations:e}])}else console.info("\u2705 [ALREADY SYNCED] Peer is up-to-date. Nothing to send.")},deltaSync:(E)=>{const _=E.operations.byteLength,u=w1(Z1.inflate(E.operations)),l=G1(u).byteLength;console.info(`\uD83D\uDEF0\uFE0F [DELTA SYNC RECEIVED] Applying ${u.length} operations from a peer.`),console.info(`   Compressed: ${_} bytes, Decompressed: ${l} bytes.`);for(let n of u)o[n.type]?.(n)},syncReceive:async(E)=>{if(console.info("\uD83D\uDCE6 [FULL SYNC RECEIVED] Overwriting local state with full graph from a peer."),E.graph&&E.graph.nodes){await v(E.graph),C.clear(),console.info("\uD83D\uDD12 Oplog has been cleared due to full sync."),g=!0;let _=null;for(let u in E.graph.nodes){const l=E.graph.nodes[u];if(l.timestamp&&(!_||z.compare(l.timestamp,_)>0))_=l.timestamp}if(_)console.info("\uD83D\uDCC8 [GLOBAL TIMESTAMP] Updated from full sync."),y=_,z.update(_)}else console.error("\u274C Full sync failed: received graph data is invalid.",E.graph)}};for(let E of I)if(o[E.type])await o[E.type](E);else console.warn(`\uD83E\uDD37\u200D\u2640\uFE0F [UNKNOWN MESSAGE TYPE] Received unhandled message type: "${E.type}"`);if(y){if(!T||z.compare(y,T)>0)console.info(`\uD83D\uDCC8 [GLOBAL TIMESTAMP] Advanced from ${T?.logical} to ${y.logical}.`),Z(y)}if(g)console.info("\uD83D\uDCBE [STATE CHANGED] Saving state and emitting update."),await w(),R()}Object.assign(D,{use(I){if(typeof I==="function")S.push(I)},async put(I,g){const y=z.now();Z(y),g??=await O(),P.upsert(g,I,y),C.add({type:"upsert",id:g,timestamp:y}),B();try{i.push({type:"upsert",id:g,value:I,timestamp:y}),j().catch(()=>{})}finally{k()}return g},async link(I,g){const y=z.now();if(!P.nodes[I]||!P.nodes[g]){console.warn(`\u26A0\uFE0F One or both nodes (${I}, ${g}) do not exist.`);return}P.link(I,g,y),C.add({type:"link",sourceId:I,targetId:g,timestamp:y}),B(),Z(y);try{i.push({type:"link",sourceId:I,targetId:g,timestamp:y}),j().catch(()=>{})}finally{k()}},async remove(I){const g=z.now(),y=P.get(I);if(!y)return console.warn(`\u26A0\uFE0F Node with ID '${I}' not found.`);delete P.nodes[I],C.add({type:"remove",id:I,timestamp:g}),Object.values(P.nodes).forEach((o)=>o.edges=o.edges.filter((E)=>E!==I)),B(),Z(g);try{i.push({type:"remove",id:I,value:y.value,timestamp:g}),j().catch(()=>{})}finally{k()}},async get(I,g=null){if(typeof I!=="string")return{result:null};const y=P.get(I);if(!y){if(g)g(null);return{result:null}}const o=(u)=>{if(!u)return null;const l=u.value!==null&&typeof u.value==="object"?{...u.value}:u.value;return{...u,value:l}};if(!g)return{result:o(y)};let E=y.timestamp;g(o(y));const _=(u)=>{const l=u[I];if(l){if(z.compare(l.timestamp,E)>0)E=l.timestamp,g(o(l))}else g(null),p.splice(p.indexOf(_),1)};return p.push(_),{result:o(y),unsubscribe:()=>{const u=p.indexOf(_);if(u>-1)p.splice(u,1)}}},async map(...I){let y={...{realtime:!1,query:{},field:null,order:"asc",$limit:null,$after:null,$before:null}},o=null,E=!1;I.forEach((n)=>typeof n==="function"?o=n:n&&typeof n==="object"&&(E||=("realtime"in n),Object.assign(y,n))),o&&!E&&(y.realtime=!0);let _=r6(P.nodes,y),u=null;const l=(n)=>{const e=new Map(_.map((J0)=>[J0.id,J0])),W0=new Map(n.map((J0)=>[J0.id,J0])),V0=[],A0=[],n6=[];for(let[J0,T0]of W0){const e1=e.get(J0);if(!e1)V0.push(T0);else if((T0.timestamp?.physical||0)!==(e1.timestamp?.physical||0)||(T0.timestamp?.logical||0)!==(e1.timestamp?.logical||0)||!gW(T0.edges||[],e1.edges||[]))A0.push(T0)}for(let[J0]of e)if(!W0.has(J0))n6.push(e.get(J0));const E8=(J0,T0)=>o({id:J0.id,value:T0==="removed"?null:J0.value,edges:J0.edges||[],timestamp:J0.timestamp||null,action:T0});V0.forEach((J0)=>E8(J0,"added")),n6.forEach((J0)=>E8(J0,"removed")),A0.forEach((J0)=>E8(J0,"updated"))};if(o){if(_.forEach((n)=>{o({id:n.id,value:n.value,edges:n.edges,timestamp:n.timestamp,action:"initial"})}),y.realtime){const n=(e)=>{const W0=e.timestamp?.physical||0,V0=e.timestamp?.logical||0,A0=(e.edges||[]).join(",");return`${e.id}:${W0}:${V0}:${A0}`};u=(e)=>{const W0=r6(e,y);if(W0.length!==_.length)l(W0),_=W0;else{const V0=W0.map(n),A0=_.map(n);if(!gW(V0,A0))l(W0),_=W0}},p.push(u)}}return{results:_,...y.realtime&&o&&u&&{unsubscribe:()=>{const n=p.indexOf(u);n>-1&&p.splice(n,1)}}}},async clear(){P.nodes={};try{await(await navigator.storage.getDirectory()).removeEntry(`${W}_graph.msgpack`)}catch({message:I}){console.warn(`\u26A0\uFE0F Error deleting _graph.msgpack: ${I}`)}R(),console.info("\u2705 All data has been deleted.")}}),H(),N(),await uV(),await L();const A=[];if(V)A.push(M("sm",V));if(Y)A.push(M("AIQuery",Y));if(X)A.push(M("radixindex",X));if(G)A.push(M("invertedindex",G));if(q)A.push(M("geo",q));await Promise.all(A);const h=`graph-sync-room-${W}`,d={appId:"1234",...J&&{password:J}};if(F)d.relayUrls=F;if(U)d.turnConfig=U;const r=l6(d,h);return m=r.channel("syncGraph"),c=l6(d,`app-sync-${W}`),D.room=c,r.on("peer:join",async(I)=>{console.info("\u26A1 New peer connected:",I),m.send([{type:"sync",timestamp:T}])}),r.on("peer:leave",(I)=>{console.info("\u26A1 Peer disconnected:",I)}),m.on("message",async(I)=>{let g=I;for(let y of S)try{if(g=await y(g),!g||g.length===0)return}catch(o){console.error("\u274C GDB: Middleware error, discarding message.",o);return}await b(g)}),x=new BroadcastChannel(`graphdb_sync_${W}`),x.onmessage=async(I)=>{if(I.data==="update")console.info("\uD83D\uDD04 Update received from another tab..."),await L(),N(),k()},console.info(`\u2705 GenosDB [ ${W} ] instance is ready.`),D}var yW=(W)=>{if(W===null||typeof W!=="object")return W;if(typeof structuredClone==="function")return structuredClone(W);return JSON.parse(JSON.stringify(W))},EW=(W,Q=16)=>{let J=null,V=null;return(...G)=>{if(!V)V={},V.promise=new Promise((Y,q)=>(V.resolve=Y,V.reject=q));if(J)("cancelIdleCallback"in window?cancelIdleCallback:clearTimeout)(J);const X=async()=>{J=null;try{V.resolve(await W(...G))}catch(Y){V.reject(Y)}finally{V=null}};return J=("requestIdleCallback"in window)?requestIdleCallback(X,{timeout:Q}):setTimeout(X,Q),V.promise}},hV=(W)=>{let Q=null;return()=>{if(Q!==null)return;Q=requestAnimationFrame(()=>{Q=null,W()})}};export{uG as gdb};
