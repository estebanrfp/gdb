function M6(J){const Q=J.length;let W=0,G=0;while(G<Q){let V=J.charCodeAt(G++);if((V&4294967168)===0){W++;continue}else if((V&4294965248)===0)W+=2;else{if(V>=55296&&V<=56319){if(G<Q){const q=J.charCodeAt(G);if((q&64512)===56320)++G,V=((V&1023)<<10)+(q&1023)+65536}}if((V&4294901760)===0)W+=3;else W+=4}}return W}function IJ(J,Q,W){const G=J.length;let V=W,q=0;while(q<G){let Y=J.charCodeAt(q++);if((Y&4294967168)===0){Q[V++]=Y;continue}else if((Y&4294965248)===0)Q[V++]=Y>>6&31|192;else{if(Y>=55296&&Y<=56319){if(q<G){const X=J.charCodeAt(q);if((X&64512)===56320)++q,Y=((Y&1023)<<10)+(X&1023)+65536}}if((Y&4294901760)===0)Q[V++]=Y>>12&15|224,Q[V++]=Y>>6&63|128;else Q[V++]=Y>>18&7|240,Q[V++]=Y>>12&63|128,Q[V++]=Y>>6&63|128}Q[V++]=Y&63|128}}function AJ(J,Q,W){NJ.encodeInto(J,Q.subarray(W))}function j6(J,Q,W){if(J.length>wJ)AJ(J,Q,W);else IJ(J,Q,W)}function R8(J,Q,W){let G=Q;const V=G+W,q=[];let Y="";while(G<V){const X=J[G++];if((X&128)===0)q.push(X);else if((X&224)===192){const K=J[G++]&63;q.push((X&31)<<6|K)}else if((X&240)===224){const K=J[G++]&63,U=J[G++]&63;q.push((X&31)<<12|K<<6|U)}else if((X&248)===240){const K=J[G++]&63,U=J[G++]&63,P=J[G++]&63;let Z=(X&7)<<18|K<<12|U<<6|P;if(Z>65535)Z-=65536,q.push(Z>>>10&1023|55296),Z=56320|Z&1023;q.push(Z)}else q.push(X);if(q.length>=vJ)Y+=String.fromCharCode(...q),q.length=0}if(q.length>0)Y+=String.fromCharCode(...q);return Y}function TJ(J,Q,W){const G=J.subarray(Q,Q+W);return DJ.decode(G)}function L6(J,Q,W){if(W>SJ)return TJ(J,Q,W);else return R8(J,Q,W)}var NJ=new TextEncoder,wJ=50,vJ=4096,DJ=new TextDecoder,SJ=200;class t0{constructor(J,Q){this.type=J,this.data=Q}}class s extends Error{constructor(J){super(J);const Q=Object.create(s.prototype);Object.setPrototypeOf(this,Q),Object.defineProperty(this,"name",{configurable:!0,enumerable:!1,value:s.name})}}function R6(J,Q,W){const G=W/4294967296,V=W;J.setUint32(Q,G),J.setUint32(Q+4,V)}function c1(J,Q,W){const G=Math.floor(W/4294967296),V=W;J.setUint32(Q,G),J.setUint32(Q+4,V)}function _1(J,Q){const W=J.getInt32(Q),G=J.getUint32(Q+4);return W*4294967296+G}function x6(J,Q){const W=J.getUint32(Q),G=J.getUint32(Q+4);return W*4294967296+G}var e0=4294967295;function pJ({sec:J,nsec:Q}){if(J>=0&&Q>=0&&J<=EJ)if(Q===0&&J<=yJ){const W=new Uint8Array(4);return new DataView(W.buffer).setUint32(0,J),W}else{const W=J/4294967296,G=J&4294967295,V=new Uint8Array(8),q=new DataView(V.buffer);return q.setUint32(0,Q<<2|W&3),q.setUint32(4,G),V}else{const W=new Uint8Array(12),G=new DataView(W.buffer);return G.setUint32(0,Q),c1(G,4,J),W}}function fJ(J){const Q=J.getTime(),W=Math.floor(Q/1000),G=(Q-W*1000)*1e6,V=Math.floor(G/1e9);return{sec:W+V,nsec:G-V*1e9}}function hJ(J){if(J instanceof Date){const Q=fJ(J);return pJ(Q)}else return null}function bJ(J){const Q=new DataView(J.buffer,J.byteOffset,J.byteLength);switch(J.byteLength){case 4:return{sec:Q.getUint32(0),nsec:0};case 8:{const W=Q.getUint32(0),G=Q.getUint32(4),V=(W&3)*4294967296+G,q=W>>>2;return{sec:V,nsec:q}}case 12:{const W=_1(Q,4),G=Q.getUint32(0);return{sec:W,nsec:G}}default:throw new s(`Unrecognized data size for timestamp (expected 4, 8, or 12): ${J.length}`)}}function uJ(J){const Q=bJ(J);return new Date(Q.sec*1000+Q.nsec/1e6)}var gJ=-1,yJ=4294967295,EJ=17179869183,O6={type:gJ,encode:hJ,decode:uJ};class E0{constructor(){this.builtInEncoders=[],this.builtInDecoders=[],this.encoders=[],this.decoders=[],this.register(O6)}register({type:J,encode:Q,decode:W}){if(J>=0)this.encoders[J]=Q,this.decoders[J]=W;else{const G=-1-J;this.builtInEncoders[G]=Q,this.builtInDecoders[G]=W}}tryToEncode(J,Q){for(let W=0;W<this.builtInEncoders.length;W++){const G=this.builtInEncoders[W];if(G!=null){const V=G(J,Q);if(V!=null){const q=-1-W;return new t0(q,V)}}}for(let W=0;W<this.encoders.length;W++){const G=this.encoders[W];if(G!=null){const V=G(J,Q);if(V!=null)return new t0(W,V)}}if(J instanceof t0)return J;return null}decode(J,Q,W){const G=Q<0?this.builtInDecoders[-1-Q]:this.decoders[Q];if(G)return G(J,Q,W);else return new t0(Q,J)}}E0.defaultCodec=new E0;var mJ=function(J){return J instanceof ArrayBuffer||typeof SharedArrayBuffer!=="undefined"&&J instanceof SharedArrayBuffer};function Z1(J){if(J instanceof Uint8Array)return J;else if(ArrayBuffer.isView(J))return new Uint8Array(J.buffer,J.byteOffset,J.byteLength);else if(mJ(J))return new Uint8Array(J);else return Uint8Array.from(J)}var dJ=100,cJ=2048;class l1{constructor(J){this.entered=!1,this.extensionCodec=J?.extensionCodec??E0.defaultCodec,this.context=J?.context,this.useBigInt64=J?.useBigInt64??!1,this.maxDepth=J?.maxDepth??dJ,this.initialBufferSize=J?.initialBufferSize??cJ,this.sortKeys=J?.sortKeys??!1,this.forceFloat32=J?.forceFloat32??!1,this.ignoreUndefined=J?.ignoreUndefined??!1,this.forceIntegerToFloat=J?.forceIntegerToFloat??!1,this.pos=0,this.view=new DataView(new ArrayBuffer(this.initialBufferSize)),this.bytes=new Uint8Array(this.view.buffer)}clone(){return new l1({extensionCodec:this.extensionCodec,context:this.context,useBigInt64:this.useBigInt64,maxDepth:this.maxDepth,initialBufferSize:this.initialBufferSize,sortKeys:this.sortKeys,forceFloat32:this.forceFloat32,ignoreUndefined:this.ignoreUndefined,forceIntegerToFloat:this.forceIntegerToFloat})}reinitializeState(){this.pos=0}encodeSharedRef(J){if(this.entered)return this.clone().encodeSharedRef(J);try{return this.entered=!0,this.reinitializeState(),this.doEncode(J,1),this.bytes.subarray(0,this.pos)}finally{this.entered=!1}}encode(J){if(this.entered)return this.clone().encode(J);try{return this.entered=!0,this.reinitializeState(),this.doEncode(J,1),this.bytes.slice(0,this.pos)}finally{this.entered=!1}}doEncode(J,Q){if(Q>this.maxDepth)throw new Error(`Too deep objects in depth ${Q}`);if(J==null)this.encodeNil();else if(typeof J==="boolean")this.encodeBoolean(J);else if(typeof J==="number")if(!this.forceIntegerToFloat)this.encodeNumber(J);else this.encodeNumberAsFloat(J);else if(typeof J==="string")this.encodeString(J);else if(this.useBigInt64&&typeof J==="bigint")this.encodeBigInt64(J);else this.encodeObject(J,Q)}ensureBufferSizeToWrite(J){const Q=this.pos+J;if(this.view.byteLength<Q)this.resizeBuffer(Q*2)}resizeBuffer(J){const Q=new ArrayBuffer(J),W=new Uint8Array(Q),G=new DataView(Q);W.set(this.bytes),this.view=G,this.bytes=W}encodeNil(){this.writeU8(192)}encodeBoolean(J){if(J===!1)this.writeU8(194);else this.writeU8(195)}encodeNumber(J){if(!this.forceIntegerToFloat&&Number.isSafeInteger(J))if(J>=0)if(J<128)this.writeU8(J);else if(J<256)this.writeU8(204),this.writeU8(J);else if(J<65536)this.writeU8(205),this.writeU16(J);else if(J<4294967296)this.writeU8(206),this.writeU32(J);else if(!this.useBigInt64)this.writeU8(207),this.writeU64(J);else this.encodeNumberAsFloat(J);else if(J>=-32)this.writeU8(224|J+32);else if(J>=-128)this.writeU8(208),this.writeI8(J);else if(J>=-32768)this.writeU8(209),this.writeI16(J);else if(J>=-2147483648)this.writeU8(210),this.writeI32(J);else if(!this.useBigInt64)this.writeU8(211),this.writeI64(J);else this.encodeNumberAsFloat(J);else this.encodeNumberAsFloat(J)}encodeNumberAsFloat(J){if(this.forceFloat32)this.writeU8(202),this.writeF32(J);else this.writeU8(203),this.writeF64(J)}encodeBigInt64(J){if(J>=BigInt(0))this.writeU8(207),this.writeBigUint64(J);else this.writeU8(211),this.writeBigInt64(J)}writeStringHeader(J){if(J<32)this.writeU8(160+J);else if(J<256)this.writeU8(217),this.writeU8(J);else if(J<65536)this.writeU8(218),this.writeU16(J);else if(J<4294967296)this.writeU8(219),this.writeU32(J);else throw new Error(`Too long string: ${J} bytes in UTF-8`)}encodeString(J){const W=M6(J);this.ensureBufferSizeToWrite(5+W),this.writeStringHeader(W),j6(J,this.bytes,this.pos),this.pos+=W}encodeObject(J,Q){const W=this.extensionCodec.tryToEncode(J,this.context);if(W!=null)this.encodeExtension(W);else if(Array.isArray(J))this.encodeArray(J,Q);else if(ArrayBuffer.isView(J))this.encodeBinary(J);else if(typeof J==="object")this.encodeMap(J,Q);else throw new Error(`Unrecognized object: ${Object.prototype.toString.apply(J)}`)}encodeBinary(J){const Q=J.byteLength;if(Q<256)this.writeU8(196),this.writeU8(Q);else if(Q<65536)this.writeU8(197),this.writeU16(Q);else if(Q<4294967296)this.writeU8(198),this.writeU32(Q);else throw new Error(`Too large binary: ${Q}`);const W=Z1(J);this.writeU8a(W)}encodeArray(J,Q){const W=J.length;if(W<16)this.writeU8(144+W);else if(W<65536)this.writeU8(220),this.writeU16(W);else if(W<4294967296)this.writeU8(221),this.writeU32(W);else throw new Error(`Too large array: ${W}`);for(let G of J)this.doEncode(G,Q+1)}countWithoutUndefined(J,Q){let W=0;for(let G of Q)if(J[G]!==void 0)W++;return W}encodeMap(J,Q){const W=Object.keys(J);if(this.sortKeys)W.sort();const G=this.ignoreUndefined?this.countWithoutUndefined(J,W):W.length;if(G<16)this.writeU8(128+G);else if(G<65536)this.writeU8(222),this.writeU16(G);else if(G<4294967296)this.writeU8(223),this.writeU32(G);else throw new Error(`Too large map object: ${G}`);for(let V of W){const q=J[V];if(!(this.ignoreUndefined&&q===void 0))this.encodeString(V),this.doEncode(q,Q+1)}}encodeExtension(J){if(typeof J.data==="function"){const W=J.data(this.pos+6),G=W.length;if(G>=4294967296)throw new Error(`Too large extension object: ${G}`);this.writeU8(201),this.writeU32(G),this.writeI8(J.type),this.writeU8a(W);return}const Q=J.data.length;if(Q===1)this.writeU8(212);else if(Q===2)this.writeU8(213);else if(Q===4)this.writeU8(214);else if(Q===8)this.writeU8(215);else if(Q===16)this.writeU8(216);else if(Q<256)this.writeU8(199),this.writeU8(Q);else if(Q<65536)this.writeU8(200),this.writeU16(Q);else if(Q<4294967296)this.writeU8(201),this.writeU32(Q);else throw new Error(`Too large extension object: ${Q}`);this.writeI8(J.type),this.writeU8a(J.data)}writeU8(J){this.ensureBufferSizeToWrite(1),this.view.setUint8(this.pos,J),this.pos++}writeU8a(J){const Q=J.length;this.ensureBufferSizeToWrite(Q),this.bytes.set(J,this.pos),this.pos+=Q}writeI8(J){this.ensureBufferSizeToWrite(1),this.view.setInt8(this.pos,J),this.pos++}writeU16(J){this.ensureBufferSizeToWrite(2),this.view.setUint16(this.pos,J),this.pos+=2}writeI16(J){this.ensureBufferSizeToWrite(2),this.view.setInt16(this.pos,J),this.pos+=2}writeU32(J){this.ensureBufferSizeToWrite(4),this.view.setUint32(this.pos,J),this.pos+=4}writeI32(J){this.ensureBufferSizeToWrite(4),this.view.setInt32(this.pos,J),this.pos+=4}writeF32(J){this.ensureBufferSizeToWrite(4),this.view.setFloat32(this.pos,J),this.pos+=4}writeF64(J){this.ensureBufferSizeToWrite(8),this.view.setFloat64(this.pos,J),this.pos+=8}writeU64(J){this.ensureBufferSizeToWrite(8),R6(this.view,this.pos,J),this.pos+=8}writeI64(J){this.ensureBufferSizeToWrite(8),c1(this.view,this.pos,J),this.pos+=8}writeBigUint64(J){this.ensureBufferSizeToWrite(8),this.view.setBigUint64(this.pos,J),this.pos+=8}writeBigInt64(J){this.ensureBufferSizeToWrite(8),this.view.setBigInt64(this.pos,J),this.pos+=8}}function I0(J,Q){return new l1(Q).encodeSharedRef(J)}function i1(J){return`${J<0?"-":""}0x${Math.abs(J).toString(16).padStart(2,"0")}`}var _J=16,lJ=16;class x8{constructor(J=_J,Q=lJ){this.hit=0,this.miss=0,this.maxKeyLength=J,this.maxLengthPerKey=Q,this.caches=[];for(let W=0;W<this.maxKeyLength;W++)this.caches.push([])}canBeCached(J){return J>0&&J<=this.maxKeyLength}find(J,Q,W){const G=this.caches[W-1];J:for(let V of G){const q=V.bytes;for(let Y=0;Y<W;Y++)if(q[Y]!==J[Q+Y])continue J;return V.str}return null}store(J,Q){const W=this.caches[J.length-1],G={bytes:J,str:Q};if(W.length>=this.maxLengthPerKey)W[Math.random()*W.length|0]=G;else W.push(G)}decode(J,Q,W){const G=this.find(J,Q,W);if(G!=null)return this.hit++,G;this.miss++;const V=R8(J,Q,W),q=Uint8Array.prototype.slice.call(J,Q,Q+W);return this.store(q,V),V}}var O8="array",H1="map_key",N6="map_value",iJ=(J)=>{if(typeof J==="string"||typeof J==="number")return J;throw new s("The type of key must be string or number but "+typeof J)};class w6{constructor(){this.stack=[],this.stackHeadPosition=-1}get length(){return this.stackHeadPosition+1}top(){return this.stack[this.stackHeadPosition]}pushArrayState(J){const Q=this.getUninitializedStateFromPool();Q.type=O8,Q.position=0,Q.size=J,Q.array=new Array(J)}pushMapState(J){const Q=this.getUninitializedStateFromPool();Q.type=H1,Q.readCount=0,Q.size=J,Q.map={}}getUninitializedStateFromPool(){if(this.stackHeadPosition++,this.stackHeadPosition===this.stack.length){const J={type:void 0,size:0,array:void 0,position:0,readCount:0,map:void 0,key:null};this.stack.push(J)}return this.stack[this.stackHeadPosition]}release(J){if(this.stack[this.stackHeadPosition]!==J)throw new Error("Invalid stack state. Released state is not on top of the stack.");if(J.type===O8){const W=J;W.size=0,W.array=void 0,W.position=0,W.type=void 0}if(J.type===H1||J.type===N6){const W=J;W.size=0,W.map=void 0,W.readCount=0,W.type=void 0}this.stackHeadPosition--}reset(){this.stack.length=0,this.stackHeadPosition=-1}}var k1=-1,I8=new DataView(new ArrayBuffer(0)),rJ=new Uint8Array(I8.buffer);try{I8.getInt8(0)}catch(J){if(!(J instanceof RangeError))throw new Error("This module is not supported in the current JavaScript engine because DataView does not throw RangeError on out-of-bounds access")}var I6=new RangeError("Insufficient data"),nJ=new x8;class r1{constructor(J){this.totalPos=0,this.pos=0,this.view=I8,this.bytes=rJ,this.headByte=k1,this.stack=new w6,this.entered=!1,this.extensionCodec=J?.extensionCodec??E0.defaultCodec,this.context=J?.context,this.useBigInt64=J?.useBigInt64??!1,this.rawStrings=J?.rawStrings??!1,this.maxStrLength=J?.maxStrLength??e0,this.maxBinLength=J?.maxBinLength??e0,this.maxArrayLength=J?.maxArrayLength??e0,this.maxMapLength=J?.maxMapLength??e0,this.maxExtLength=J?.maxExtLength??e0,this.keyDecoder=J?.keyDecoder!==void 0?J.keyDecoder:nJ,this.mapKeyConverter=J?.mapKeyConverter??iJ}clone(){return new r1({extensionCodec:this.extensionCodec,context:this.context,useBigInt64:this.useBigInt64,rawStrings:this.rawStrings,maxStrLength:this.maxStrLength,maxBinLength:this.maxBinLength,maxArrayLength:this.maxArrayLength,maxMapLength:this.maxMapLength,maxExtLength:this.maxExtLength,keyDecoder:this.keyDecoder})}reinitializeState(){this.totalPos=0,this.headByte=k1,this.stack.reset()}setBuffer(J){const Q=Z1(J);this.bytes=Q,this.view=new DataView(Q.buffer,Q.byteOffset,Q.byteLength),this.pos=0}appendBuffer(J){if(this.headByte===k1&&!this.hasRemaining(1))this.setBuffer(J);else{const Q=this.bytes.subarray(this.pos),W=Z1(J),G=new Uint8Array(Q.length+W.length);G.set(Q),G.set(W,Q.length),this.setBuffer(G)}}hasRemaining(J){return this.view.byteLength-this.pos>=J}createExtraByteError(J){const{view:Q,pos:W}=this;return new RangeError(`Extra ${Q.byteLength-W} of ${Q.byteLength} byte(s) found at buffer[${J}]`)}decode(J){if(this.entered)return this.clone().decode(J);try{this.entered=!0,this.reinitializeState(),this.setBuffer(J);const Q=this.doDecodeSync();if(this.hasRemaining(1))throw this.createExtraByteError(this.pos);return Q}finally{this.entered=!1}}*decodeMulti(J){if(this.entered){yield*this.clone().decodeMulti(J);return}try{this.entered=!0,this.reinitializeState(),this.setBuffer(J);while(this.hasRemaining(1))yield this.doDecodeSync()}finally{this.entered=!1}}async decodeAsync(J){if(this.entered)return this.clone().decodeAsync(J);try{this.entered=!0;let Q=!1,W;for await(let Y of J){if(Q)throw this.entered=!1,this.createExtraByteError(this.totalPos);this.appendBuffer(Y);try{W=this.doDecodeSync(),Q=!0}catch(X){if(!(X instanceof RangeError))throw X}this.totalPos+=this.pos}if(Q){if(this.hasRemaining(1))throw this.createExtraByteError(this.totalPos);return W}const{headByte:G,pos:V,totalPos:q}=this;throw new RangeError(`Insufficient data in parsing ${i1(G)} at ${q} (${V} in the current buffer)`)}finally{this.entered=!1}}decodeArrayStream(J){return this.decodeMultiAsync(J,!0)}decodeStream(J){return this.decodeMultiAsync(J,!1)}async*decodeMultiAsync(J,Q){if(this.entered){yield*this.clone().decodeMultiAsync(J,Q);return}try{this.entered=!0;let W=Q,G=-1;for await(let V of J){if(Q&&G===0)throw this.createExtraByteError(this.totalPos);if(this.appendBuffer(V),W)G=this.readArraySize(),W=!1,this.complete();try{while(!0)if(yield this.doDecodeSync(),--G===0)break}catch(q){if(!(q instanceof RangeError))throw q}this.totalPos+=this.pos}}finally{this.entered=!1}}doDecodeSync(){J:while(!0){const J=this.readHeadByte();let Q;if(J>=224)Q=J-256;else if(J<192)if(J<128)Q=J;else if(J<144){const G=J-128;if(G!==0){this.pushMapState(G),this.complete();continue J}else Q={}}else if(J<160){const G=J-144;if(G!==0){this.pushArrayState(G),this.complete();continue J}else Q=[]}else{const G=J-160;Q=this.decodeString(G,0)}else if(J===192)Q=null;else if(J===194)Q=!1;else if(J===195)Q=!0;else if(J===202)Q=this.readF32();else if(J===203)Q=this.readF64();else if(J===204)Q=this.readU8();else if(J===205)Q=this.readU16();else if(J===206)Q=this.readU32();else if(J===207)if(this.useBigInt64)Q=this.readU64AsBigInt();else Q=this.readU64();else if(J===208)Q=this.readI8();else if(J===209)Q=this.readI16();else if(J===210)Q=this.readI32();else if(J===211)if(this.useBigInt64)Q=this.readI64AsBigInt();else Q=this.readI64();else if(J===217){const G=this.lookU8();Q=this.decodeString(G,1)}else if(J===218){const G=this.lookU16();Q=this.decodeString(G,2)}else if(J===219){const G=this.lookU32();Q=this.decodeString(G,4)}else if(J===220){const G=this.readU16();if(G!==0){this.pushArrayState(G),this.complete();continue J}else Q=[]}else if(J===221){const G=this.readU32();if(G!==0){this.pushArrayState(G),this.complete();continue J}else Q=[]}else if(J===222){const G=this.readU16();if(G!==0){this.pushMapState(G),this.complete();continue J}else Q={}}else if(J===223){const G=this.readU32();if(G!==0){this.pushMapState(G),this.complete();continue J}else Q={}}else if(J===196){const G=this.lookU8();Q=this.decodeBinary(G,1)}else if(J===197){const G=this.lookU16();Q=this.decodeBinary(G,2)}else if(J===198){const G=this.lookU32();Q=this.decodeBinary(G,4)}else if(J===212)Q=this.decodeExtension(1,0);else if(J===213)Q=this.decodeExtension(2,0);else if(J===214)Q=this.decodeExtension(4,0);else if(J===215)Q=this.decodeExtension(8,0);else if(J===216)Q=this.decodeExtension(16,0);else if(J===199){const G=this.lookU8();Q=this.decodeExtension(G,1)}else if(J===200){const G=this.lookU16();Q=this.decodeExtension(G,2)}else if(J===201){const G=this.lookU32();Q=this.decodeExtension(G,4)}else throw new s(`Unrecognized type byte: ${i1(J)}`);this.complete();const W=this.stack;while(W.length>0){const G=W.top();if(G.type===O8)if(G.array[G.position]=Q,G.position++,G.position===G.size)Q=G.array,W.release(G);else continue J;else if(G.type===H1){if(Q==="__proto__")throw new s("The key __proto__ is not allowed");G.key=this.mapKeyConverter(Q),G.type=N6;continue J}else if(G.map[G.key]=Q,G.readCount++,G.readCount===G.size)Q=G.map,W.release(G);else{G.key=null,G.type=H1;continue J}}return Q}}readHeadByte(){if(this.headByte===k1)this.headByte=this.readU8();return this.headByte}complete(){this.headByte=k1}readArraySize(){const J=this.readHeadByte();switch(J){case 220:return this.readU16();case 221:return this.readU32();default:if(J<160)return J-144;else throw new s(`Unrecognized array type byte: ${i1(J)}`)}}pushMapState(J){if(J>this.maxMapLength)throw new s(`Max length exceeded: map length (${J}) > maxMapLengthLength (${this.maxMapLength})`);this.stack.pushMapState(J)}pushArrayState(J){if(J>this.maxArrayLength)throw new s(`Max length exceeded: array length (${J}) > maxArrayLength (${this.maxArrayLength})`);this.stack.pushArrayState(J)}decodeString(J,Q){if(!this.rawStrings||this.stateIsMapKey())return this.decodeUtf8String(J,Q);return this.decodeBinary(J,Q)}decodeUtf8String(J,Q){if(J>this.maxStrLength)throw new s(`Max length exceeded: UTF-8 byte length (${J}) > maxStrLength (${this.maxStrLength})`);if(this.bytes.byteLength<this.pos+Q+J)throw I6;const W=this.pos+Q;let G;if(this.stateIsMapKey()&&this.keyDecoder?.canBeCached(J))G=this.keyDecoder.decode(this.bytes,W,J);else G=L6(this.bytes,W,J);return this.pos+=Q+J,G}stateIsMapKey(){if(this.stack.length>0)return this.stack.top().type===H1;return!1}decodeBinary(J,Q){if(J>this.maxBinLength)throw new s(`Max length exceeded: bin length (${J}) > maxBinLength (${this.maxBinLength})`);if(!this.hasRemaining(J+Q))throw I6;const W=this.pos+Q,G=this.bytes.subarray(W,W+J);return this.pos+=Q+J,G}decodeExtension(J,Q){if(J>this.maxExtLength)throw new s(`Max length exceeded: ext length (${J}) > maxExtLength (${this.maxExtLength})`);const W=this.view.getInt8(this.pos+Q),G=this.decodeBinary(J,Q+1);return this.extensionCodec.decode(G,W,this.context)}lookU8(){return this.view.getUint8(this.pos)}lookU16(){return this.view.getUint16(this.pos)}lookU32(){return this.view.getUint32(this.pos)}readU8(){const J=this.view.getUint8(this.pos);return this.pos++,J}readI8(){const J=this.view.getInt8(this.pos);return this.pos++,J}readU16(){const J=this.view.getUint16(this.pos);return this.pos+=2,J}readI16(){const J=this.view.getInt16(this.pos);return this.pos+=2,J}readU32(){const J=this.view.getUint32(this.pos);return this.pos+=4,J}readI32(){const J=this.view.getInt32(this.pos);return this.pos+=4,J}readU64(){const J=x6(this.view,this.pos);return this.pos+=8,J}readI64(){const J=_1(this.view,this.pos);return this.pos+=8,J}readU64AsBigInt(){const J=this.view.getBigUint64(this.pos);return this.pos+=8,J}readI64AsBigInt(){const J=this.view.getBigInt64(this.pos);return this.pos+=8,J}readF32(){const J=this.view.getFloat32(this.pos);return this.pos+=4,J}readF64(){const J=this.view.getFloat64(this.pos);return this.pos+=8,J}}function n1(J,Q){return new r1(Q).decode(J)}var q1=function(J){let Q=J.length;while(--Q>=0)J[Q]=0},w8=function(J,Q,W,G,V){this.static_tree=J,this.extra_bits=Q,this.extra_base=W,this.elems=G,this.max_length=V,this.has_stree=J&&J.length},A8=function(J,Q){this.dyn_tree=J,this.max_code=0,this.stat_desc=Q},Z0=function(J,Q,W,G,V){this.good_length=J,this.max_lazy=Q,this.nice_length=W,this.max_chain=G,this.func=V},aW=function(){this.strm=null,this.status=0,this.pending_buf=null,this.pending_buf_size=0,this.pending_out=0,this.pending=0,this.wrap=0,this.gzhead=null,this.gzindex=0,this.method=V8,this.last_flush=-1,this.w_size=0,this.w_bits=0,this.w_mask=0,this.window=null,this.window_size=0,this.prev=null,this.head=null,this.ins_h=0,this.hash_size=0,this.hash_bits=0,this.hash_mask=0,this.hash_shift=0,this.block_start=0,this.match_length=0,this.prev_match=0,this.match_available=0,this.strstart=0,this.match_start=0,this.lookahead=0,this.prev_length=0,this.max_chain_length=0,this.max_lazy_match=0,this.level=0,this.strategy=0,this.good_match=0,this.nice_match=0,this.dyn_ltree=new Uint16Array(mW*2),this.dyn_dtree=new Uint16Array((2*bW+1)*2),this.bl_tree=new Uint16Array((2*uW+1)*2),N0(this.dyn_ltree),N0(this.dyn_dtree),N0(this.bl_tree),this.l_desc=null,this.d_desc=null,this.bl_desc=null,this.bl_count=new Uint16Array(dW+1),this.heap=new Uint16Array(2*c8+1),N0(this.heap),this.heap_len=0,this.heap_max=0,this.depth=new Uint16Array(2*c8+1),N0(this.depth),this.sym_buf=0,this.lit_bufsize=0,this.sym_next=0,this.sym_end=0,this.opt_len=0,this.static_len=0,this.matches=0,this.insert=0,this.bi_buf=0,this.bi_valid=0},B7=function(){this.input=null,this.next_in=0,this.avail_in=0,this.total_in=0,this.output=null,this.next_out=0,this.avail_out=0,this.total_out=0,this.msg="",this.state=null,this.data_type=2,this.adler=0},T1=function(J){this.options=q8.assign({level:O7,method:N7,chunkSize:16384,windowBits:15,memLevel:8,strategy:I7},J||{});let Q=this.options;if(Q.raw&&Q.windowBits>0)Q.windowBits=-Q.windowBits;else if(Q.gzip&&Q.windowBits>0&&Q.windowBits<16)Q.windowBits+=16;this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new g5,this.strm.avail_out=0;let W=j1.deflateInit2(this.strm,Q.level,Q.method,Q.windowBits,Q.memLevel,Q.strategy);if(W!==Q8)throw new Error(b0[W]);if(Q.header)j1.deflateSetHeader(this.strm,Q.header);if(Q.dictionary){let G;if(typeof Q.dictionary==="string")G=A1.string2buf(Q.dictionary);else if(y5.call(Q.dictionary)==="[object ArrayBuffer]")G=new Uint8Array(Q.dictionary);else G=Q.dictionary;if(W=j1.deflateSetDictionary(this.strm,G),W!==Q8)throw new Error(b0[W]);this._dict_set=!0}},J6=function(J,Q){const W=new T1(Q);if(W.push(J,!0),W.err)throw W.msg||b0[W.err];return W.result},w7=function(J,Q){return Q=Q||{},Q.raw=!0,J6(J,Q)},A7=function(J,Q){return Q=Q||{},Q.gzip=!0,J6(J,Q)},s7=function(){this.strm=null,this.mode=0,this.last=!1,this.wrap=0,this.havedict=!1,this.flags=0,this.dmax=0,this.check=0,this.total=0,this.head=null,this.wbits=0,this.wsize=0,this.whave=0,this.wnext=0,this.window=null,this.hold=0,this.bits=0,this.length=0,this.offset=0,this.extra=0,this.lencode=null,this.distcode=null,this.lenbits=0,this.distbits=0,this.ncode=0,this.nlen=0,this.ndist=0,this.have=0,this.next=null,this.lens=new Uint16Array(320),this.work=new Uint16Array(288),this.lendyn=null,this.distdyn=null,this.sane=0,this.back=0,this.was=0},kQ=function(){this.text=0,this.time=0,this.xflags=0,this.os=0,this.extra=null,this.extra_len=0,this.name="",this.comment="",this.hcrc=0,this.done=!1},g1=function(J){this.options=q8.assign({chunkSize:65536,windowBits:15,to:""},J||{});const Q=this.options;if(Q.raw&&Q.windowBits>=0&&Q.windowBits<16){if(Q.windowBits=-Q.windowBits,Q.windowBits===0)Q.windowBits=-15}if(Q.windowBits>=0&&Q.windowBits<16&&!(J&&J.windowBits))Q.windowBits+=32;if(Q.windowBits>15&&Q.windowBits<48){if((Q.windowBits&15)===0)Q.windowBits|=15}this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new g5,this.strm.avail_out=0;let W=R0.inflateInit2(this.strm,Q.windowBits);if(W!==v1)throw new Error(b0[W]);if(this.header=new HQ,R0.inflateGetHeader(this.strm,this.header),Q.dictionary){if(typeof Q.dictionary==="string")Q.dictionary=A1.string2buf(Q.dictionary);else if(i5.call(Q.dictionary)==="[object ArrayBuffer]")Q.dictionary=new Uint8Array(Q.dictionary);if(Q.raw){if(W=R0.inflateSetDictionary(this.strm,Q.dictionary),W!==v1)throw new Error(b0[W])}}},W6=function(J,Q){const W=new g1(Q);if(W.push(J),W.err)throw W.msg||b0[W.err];return W.result},jQ=function(J,Q){return Q=Q||{},Q.raw=!0,W6(J,Q)};/*! pako 2.1.0 https://github.com/nodeca/pako @license (MIT AND Zlib) */var oJ=0,z5=1,aJ=2,sJ=3,tJ=258,o8=29,D1=256,R1=D1+1+o8,Q1=30,a8=19,Z5=2*R1+1,p0=15,N8=16,eJ=7,s8=256,k5=16,H5=17,$5=18,u8=new Uint8Array([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0]),J8=new Uint8Array([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13]),JW=new Uint8Array([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7]),C5=new Uint8Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),WW=512,L0=new Array((R1+2)*2);q1(L0);var M1=new Array(Q1*2);q1(M1);var x1=new Array(WW);q1(x1);var O1=new Array(tJ-sJ+1);q1(O1);var t8=new Array(o8);q1(t8);var W8=new Array(Q1);q1(W8);var B5,M5,j5,L5=(J)=>{return J<256?x1[J]:x1[256+(J>>>7)]},I1=(J,Q)=>{J.pending_buf[J.pending++]=Q&255,J.pending_buf[J.pending++]=Q>>>8&255},J0=(J,Q,W)=>{if(J.bi_valid>N8-W)J.bi_buf|=Q<<J.bi_valid&65535,I1(J,J.bi_buf),J.bi_buf=Q>>N8-J.bi_valid,J.bi_valid+=W-N8;else J.bi_buf|=Q<<J.bi_valid&65535,J.bi_valid+=W},k0=(J,Q,W)=>{J0(J,W[Q*2],W[Q*2+1])},R5=(J,Q)=>{let W=0;do W|=J&1,J>>>=1,W<<=1;while(--Q>0);return W>>>1},QW=(J)=>{if(J.bi_valid===16)I1(J,J.bi_buf),J.bi_buf=0,J.bi_valid=0;else if(J.bi_valid>=8)J.pending_buf[J.pending++]=J.bi_buf&255,J.bi_buf>>=8,J.bi_valid-=8},GW=(J,Q)=>{const{dyn_tree:W,max_code:G}=Q,V=Q.stat_desc.static_tree,q=Q.stat_desc.has_stree,Y=Q.stat_desc.extra_bits,X=Q.stat_desc.extra_base,K=Q.stat_desc.max_length;let U,P,Z,z,F,H,R=0;for(z=0;z<=p0;z++)J.bl_count[z]=0;W[J.heap[J.heap_max]*2+1]=0;for(U=J.heap_max+1;U<Z5;U++){if(P=J.heap[U],z=W[W[P*2+1]*2+1]+1,z>K)z=K,R++;if(W[P*2+1]=z,P>G)continue;if(J.bl_count[z]++,F=0,P>=X)F=Y[P-X];if(H=W[P*2],J.opt_len+=H*(z+F),q)J.static_len+=H*(V[P*2+1]+F)}if(R===0)return;do{z=K-1;while(J.bl_count[z]===0)z--;J.bl_count[z]--,J.bl_count[z+1]+=2,J.bl_count[K]--,R-=2}while(R>0);for(z=K;z!==0;z--){P=J.bl_count[z];while(P!==0){if(Z=J.heap[--U],Z>G)continue;if(W[Z*2+1]!==z)J.opt_len+=(z-W[Z*2+1])*W[Z*2],W[Z*2+1]=z;P--}}},x5=(J,Q,W)=>{const G=new Array(p0+1);let V=0,q,Y;for(q=1;q<=p0;q++)V=V+W[q-1]<<1,G[q]=V;for(Y=0;Y<=Q;Y++){let X=J[Y*2+1];if(X===0)continue;J[Y*2]=R5(G[X]++,X)}},VW=()=>{let J,Q,W,G,V;const q=new Array(p0+1);W=0;for(G=0;G<o8-1;G++){t8[G]=W;for(J=0;J<1<<u8[G];J++)O1[W++]=G}O1[W-1]=G,V=0;for(G=0;G<16;G++){W8[G]=V;for(J=0;J<1<<J8[G];J++)x1[V++]=G}V>>=7;for(;G<Q1;G++){W8[G]=V<<7;for(J=0;J<1<<J8[G]-7;J++)x1[256+V++]=G}for(Q=0;Q<=p0;Q++)q[Q]=0;J=0;while(J<=143)L0[J*2+1]=8,J++,q[8]++;while(J<=255)L0[J*2+1]=9,J++,q[9]++;while(J<=279)L0[J*2+1]=7,J++,q[7]++;while(J<=287)L0[J*2+1]=8,J++,q[8]++;x5(L0,R1+1,q);for(J=0;J<Q1;J++)M1[J*2+1]=5,M1[J*2]=R5(J,5);B5=new w8(L0,u8,D1+1,R1,p0),M5=new w8(M1,J8,0,Q1,p0),j5=new w8(new Array(0),JW,0,a8,eJ)},O5=(J)=>{let Q;for(Q=0;Q<R1;Q++)J.dyn_ltree[Q*2]=0;for(Q=0;Q<Q1;Q++)J.dyn_dtree[Q*2]=0;for(Q=0;Q<a8;Q++)J.bl_tree[Q*2]=0;J.dyn_ltree[s8*2]=1,J.opt_len=J.static_len=0,J.sym_next=J.matches=0},I5=(J)=>{if(J.bi_valid>8)I1(J,J.bi_buf);else if(J.bi_valid>0)J.pending_buf[J.pending++]=J.bi_buf;J.bi_buf=0,J.bi_valid=0},A6=(J,Q,W,G)=>{const V=Q*2,q=W*2;return J[V]<J[q]||J[V]===J[q]&&G[Q]<=G[W]},v8=(J,Q,W)=>{const G=J.heap[W];let V=W<<1;while(V<=J.heap_len){if(V<J.heap_len&&A6(Q,J.heap[V+1],J.heap[V],J.depth))V++;if(A6(Q,G,J.heap[V],J.depth))break;J.heap[W]=J.heap[V],W=V,V<<=1}J.heap[W]=G},v6=(J,Q,W)=>{let G,V,q=0,Y,X;if(J.sym_next!==0)do if(G=J.pending_buf[J.sym_buf+q++]&255,G+=(J.pending_buf[J.sym_buf+q++]&255)<<8,V=J.pending_buf[J.sym_buf+q++],G===0)k0(J,V,Q);else{if(Y=O1[V],k0(J,Y+D1+1,Q),X=u8[Y],X!==0)V-=t8[Y],J0(J,V,X);if(G--,Y=L5(G),k0(J,Y,W),X=J8[Y],X!==0)G-=W8[Y],J0(J,G,X)}while(q<J.sym_next);k0(J,s8,Q)},m8=(J,Q)=>{const W=Q.dyn_tree,G=Q.stat_desc.static_tree,V=Q.stat_desc.has_stree,q=Q.stat_desc.elems;let Y,X,K=-1,U;J.heap_len=0,J.heap_max=Z5;for(Y=0;Y<q;Y++)if(W[Y*2]!==0)J.heap[++J.heap_len]=K=Y,J.depth[Y]=0;else W[Y*2+1]=0;while(J.heap_len<2)if(U=J.heap[++J.heap_len]=K<2?++K:0,W[U*2]=1,J.depth[U]=0,J.opt_len--,V)J.static_len-=G[U*2+1];Q.max_code=K;for(Y=J.heap_len>>1;Y>=1;Y--)v8(J,W,Y);U=q;do Y=J.heap[1],J.heap[1]=J.heap[J.heap_len--],v8(J,W,1),X=J.heap[1],J.heap[--J.heap_max]=Y,J.heap[--J.heap_max]=X,W[U*2]=W[Y*2]+W[X*2],J.depth[U]=(J.depth[Y]>=J.depth[X]?J.depth[Y]:J.depth[X])+1,W[Y*2+1]=W[X*2+1]=U,J.heap[1]=U++,v8(J,W,1);while(J.heap_len>=2);J.heap[--J.heap_max]=J.heap[1],GW(J,Q),x5(W,K,J.bl_count)},D6=(J,Q,W)=>{let G,V=-1,q,Y=Q[1],X=0,K=7,U=4;if(Y===0)K=138,U=3;Q[(W+1)*2+1]=65535;for(G=0;G<=W;G++){if(q=Y,Y=Q[(G+1)*2+1],++X<K&&q===Y)continue;else if(X<U)J.bl_tree[q*2]+=X;else if(q!==0){if(q!==V)J.bl_tree[q*2]++;J.bl_tree[k5*2]++}else if(X<=10)J.bl_tree[H5*2]++;else J.bl_tree[$5*2]++;if(X=0,V=q,Y===0)K=138,U=3;else if(q===Y)K=6,U=3;else K=7,U=4}},S6=(J,Q,W)=>{let G,V=-1,q,Y=Q[1],X=0,K=7,U=4;if(Y===0)K=138,U=3;for(G=0;G<=W;G++){if(q=Y,Y=Q[(G+1)*2+1],++X<K&&q===Y)continue;else if(X<U)do k0(J,q,J.bl_tree);while(--X!==0);else if(q!==0){if(q!==V)k0(J,q,J.bl_tree),X--;k0(J,k5,J.bl_tree),J0(J,X-3,2)}else if(X<=10)k0(J,H5,J.bl_tree),J0(J,X-3,3);else k0(J,$5,J.bl_tree),J0(J,X-11,7);if(X=0,V=q,Y===0)K=138,U=3;else if(q===Y)K=6,U=3;else K=7,U=4}},qW=(J)=>{let Q;D6(J,J.dyn_ltree,J.l_desc.max_code),D6(J,J.dyn_dtree,J.d_desc.max_code),m8(J,J.bl_desc);for(Q=a8-1;Q>=3;Q--)if(J.bl_tree[C5[Q]*2+1]!==0)break;return J.opt_len+=3*(Q+1)+5+5+4,Q},YW=(J,Q,W,G)=>{let V;J0(J,Q-257,5),J0(J,W-1,5),J0(J,G-4,4);for(V=0;V<G;V++)J0(J,J.bl_tree[C5[V]*2+1],3);S6(J,J.dyn_ltree,Q-1),S6(J,J.dyn_dtree,W-1)},XW=(J)=>{let Q=4093624447,W;for(W=0;W<=31;W++,Q>>>=1)if(Q&1&&J.dyn_ltree[W*2]!==0)return 0;if(J.dyn_ltree[18]!==0||J.dyn_ltree[20]!==0||J.dyn_ltree[26]!==0)return 1;for(W=32;W<D1;W++)if(J.dyn_ltree[W*2]!==0)return 1;return 0},T6=!1,UW=(J)=>{if(!T6)VW(),T6=!0;J.l_desc=new A8(J.dyn_ltree,B5),J.d_desc=new A8(J.dyn_dtree,M5),J.bl_desc=new A8(J.bl_tree,j5),J.bi_buf=0,J.bi_valid=0,O5(J)},N5=(J,Q,W,G)=>{if(J0(J,(oJ<<1)+(G?1:0),3),I5(J),I1(J,W),I1(J,~W),W)J.pending_buf.set(J.window.subarray(Q,Q+W),J.pending);J.pending+=W},PW=(J)=>{J0(J,z5<<1,3),k0(J,s8,L0),QW(J)},KW=(J,Q,W,G)=>{let V,q,Y=0;if(J.level>0){if(J.strm.data_type===2)J.strm.data_type=XW(J);if(m8(J,J.l_desc),m8(J,J.d_desc),Y=qW(J),V=J.opt_len+3+7>>>3,q=J.static_len+3+7>>>3,q<=V)V=q}else V=q=W+5;if(W+4<=V&&Q!==-1)N5(J,Q,W,G);else if(J.strategy===4||q===V)J0(J,(z5<<1)+(G?1:0),3),v6(J,L0,M1);else J0(J,(aJ<<1)+(G?1:0),3),YW(J,J.l_desc.max_code+1,J.d_desc.max_code+1,Y+1),v6(J,J.dyn_ltree,J.dyn_dtree);if(O5(J),G)I5(J)},FW=(J,Q,W)=>{if(J.pending_buf[J.sym_buf+J.sym_next++]=Q,J.pending_buf[J.sym_buf+J.sym_next++]=Q>>8,J.pending_buf[J.sym_buf+J.sym_next++]=W,Q===0)J.dyn_ltree[W*2]++;else J.matches++,Q--,J.dyn_ltree[(O1[W]+D1+1)*2]++,J.dyn_dtree[L5(Q)*2]++;return J.sym_next===J.sym_end},zW=UW,ZW=N5,kW=KW,HW=FW,$W=PW,CW={_tr_init:zW,_tr_stored_block:ZW,_tr_flush_block:kW,_tr_tally:HW,_tr_align:$W},BW=(J,Q,W,G)=>{let V=J&65535|0,q=J>>>16&65535|0,Y=0;while(W!==0){Y=W>2000?2000:W,W-=Y;do V=V+Q[G++]|0,q=q+V|0;while(--Y);V%=65521,q%=65521}return V|q<<16|0},N1=BW,MW=()=>{let J,Q=[];for(var W=0;W<256;W++){J=W;for(var G=0;G<8;G++)J=J&1?3988292384^J>>>1:J>>>1;Q[W]=J}return Q},jW=new Uint32Array(MW()),LW=(J,Q,W,G)=>{const V=jW,q=G+W;J^=-1;for(let Y=G;Y<q;Y++)J=J>>>8^V[(J^Q[Y])&255];return J^-1},r=LW,b0={2:"need dictionary",1:"stream end",0:"","-1":"file error","-2":"stream error","-3":"data error","-4":"insufficient memory","-5":"buffer error","-6":"incompatible version"},d0={Z_NO_FLUSH:0,Z_PARTIAL_FLUSH:1,Z_SYNC_FLUSH:2,Z_FULL_FLUSH:3,Z_FINISH:4,Z_BLOCK:5,Z_TREES:6,Z_OK:0,Z_STREAM_END:1,Z_NEED_DICT:2,Z_ERRNO:-1,Z_STREAM_ERROR:-2,Z_DATA_ERROR:-3,Z_MEM_ERROR:-4,Z_BUF_ERROR:-5,Z_NO_COMPRESSION:0,Z_BEST_SPEED:1,Z_BEST_COMPRESSION:9,Z_DEFAULT_COMPRESSION:-1,Z_FILTERED:1,Z_HUFFMAN_ONLY:2,Z_RLE:3,Z_FIXED:4,Z_DEFAULT_STRATEGY:0,Z_BINARY:0,Z_TEXT:1,Z_UNKNOWN:2,Z_DEFLATED:8},{_tr_init:RW,_tr_stored_block:d8,_tr_flush_block:xW,_tr_tally:A0,_tr_align:OW}=CW,{Z_NO_FLUSH:v0,Z_PARTIAL_FLUSH:IW,Z_FULL_FLUSH:NW,Z_FINISH:q0,Z_BLOCK:g6,Z_OK:a,Z_STREAM_END:y6,Z_STREAM_ERROR:H0,Z_DATA_ERROR:wW,Z_BUF_ERROR:D8,Z_DEFAULT_COMPRESSION:AW,Z_FILTERED:vW,Z_HUFFMAN_ONLY:o1,Z_RLE:DW,Z_FIXED:SW,Z_DEFAULT_STRATEGY:TW,Z_UNKNOWN:gW,Z_DEFLATED:V8}=d0,yW=9,EW=15,pW=8,fW=29,hW=256,c8=hW+1+fW,bW=30,uW=19,mW=2*c8+1,dW=15,T=3,w0=258,$0=w0+T+1,cW=32,G1=42,e8=57,_8=69,l8=73,i8=91,r8=103,f0=113,C1=666,t=1,Y1=2,u0=3,X1=4,_W=3,h0=(J,Q)=>{return J.msg=b0[Q],Q},E6=(J)=>{return J*2-(J>4?9:0)},N0=(J)=>{let Q=J.length;while(--Q>=0)J[Q]=0},lW=(J)=>{let Q,W,G,V=J.w_size;Q=J.hash_size,G=Q;do W=J.head[--G],J.head[G]=W>=V?W-V:0;while(--Q);Q=V,G=Q;do W=J.prev[--G],J.prev[G]=W>=V?W-V:0;while(--Q)},iW=(J,Q,W)=>(Q<<J.hash_shift^W)&J.hash_mask,D0=iW,W0=(J)=>{const Q=J.state;let W=Q.pending;if(W>J.avail_out)W=J.avail_out;if(W===0)return;if(J.output.set(Q.pending_buf.subarray(Q.pending_out,Q.pending_out+W),J.next_out),J.next_out+=W,Q.pending_out+=W,J.total_out+=W,J.avail_out-=W,Q.pending-=W,Q.pending===0)Q.pending_out=0},Q0=(J,Q)=>{xW(J,J.block_start>=0?J.block_start:-1,J.strstart-J.block_start,Q),J.block_start=J.strstart,W0(J.strm)},E=(J,Q)=>{J.pending_buf[J.pending++]=Q},$1=(J,Q)=>{J.pending_buf[J.pending++]=Q>>>8&255,J.pending_buf[J.pending++]=Q&255},n8=(J,Q,W,G)=>{let V=J.avail_in;if(V>G)V=G;if(V===0)return 0;if(J.avail_in-=V,Q.set(J.input.subarray(J.next_in,J.next_in+V),W),J.state.wrap===1)J.adler=N1(J.adler,Q,V,W);else if(J.state.wrap===2)J.adler=r(J.adler,Q,V,W);return J.next_in+=V,J.total_in+=V,V},w5=(J,Q)=>{let{max_chain_length:W,strstart:G}=J,V,q,Y=J.prev_length,X=J.nice_match;const K=J.strstart>J.w_size-$0?J.strstart-(J.w_size-$0):0,U=J.window,P=J.w_mask,Z=J.prev,z=J.strstart+w0;let F=U[G+Y-1],H=U[G+Y];if(J.prev_length>=J.good_match)W>>=2;if(X>J.lookahead)X=J.lookahead;do{if(V=Q,U[V+Y]!==H||U[V+Y-1]!==F||U[V]!==U[G]||U[++V]!==U[G+1])continue;G+=2,V++;do;while(U[++G]===U[++V]&&U[++G]===U[++V]&&U[++G]===U[++V]&&U[++G]===U[++V]&&U[++G]===U[++V]&&U[++G]===U[++V]&&U[++G]===U[++V]&&U[++G]===U[++V]&&G<z);if(q=w0-(z-G),G=z-w0,q>Y){if(J.match_start=Q,Y=q,q>=X)break;F=U[G+Y-1],H=U[G+Y]}}while((Q=Z[Q&P])>K&&--W!==0);if(Y<=J.lookahead)return Y;return J.lookahead},V1=(J)=>{const Q=J.w_size;let W,G,V;do{if(G=J.window_size-J.lookahead-J.strstart,J.strstart>=Q+(Q-$0)){if(J.window.set(J.window.subarray(Q,Q+Q-G),0),J.match_start-=Q,J.strstart-=Q,J.block_start-=Q,J.insert>J.strstart)J.insert=J.strstart;lW(J),G+=Q}if(J.strm.avail_in===0)break;if(W=n8(J.strm,J.window,J.strstart+J.lookahead,G),J.lookahead+=W,J.lookahead+J.insert>=T){V=J.strstart-J.insert,J.ins_h=J.window[V],J.ins_h=D0(J,J.ins_h,J.window[V+1]);while(J.insert)if(J.ins_h=D0(J,J.ins_h,J.window[V+T-1]),J.prev[V&J.w_mask]=J.head[J.ins_h],J.head[J.ins_h]=V,V++,J.insert--,J.lookahead+J.insert<T)break}}while(J.lookahead<$0&&J.strm.avail_in!==0)},A5=(J,Q)=>{let W=J.pending_buf_size-5>J.w_size?J.w_size:J.pending_buf_size-5,G,V,q,Y=0,X=J.strm.avail_in;do{if(G=65535,q=J.bi_valid+42>>3,J.strm.avail_out<q)break;if(q=J.strm.avail_out-q,V=J.strstart-J.block_start,G>V+J.strm.avail_in)G=V+J.strm.avail_in;if(G>q)G=q;if(G<W&&(G===0&&Q!==q0||Q===v0||G!==V+J.strm.avail_in))break;if(Y=Q===q0&&G===V+J.strm.avail_in?1:0,d8(J,0,0,Y),J.pending_buf[J.pending-4]=G,J.pending_buf[J.pending-3]=G>>8,J.pending_buf[J.pending-2]=~G,J.pending_buf[J.pending-1]=~G>>8,W0(J.strm),V){if(V>G)V=G;J.strm.output.set(J.window.subarray(J.block_start,J.block_start+V),J.strm.next_out),J.strm.next_out+=V,J.strm.avail_out-=V,J.strm.total_out+=V,J.block_start+=V,G-=V}if(G)n8(J.strm,J.strm.output,J.strm.next_out,G),J.strm.next_out+=G,J.strm.avail_out-=G,J.strm.total_out+=G}while(Y===0);if(X-=J.strm.avail_in,X){if(X>=J.w_size)J.matches=2,J.window.set(J.strm.input.subarray(J.strm.next_in-J.w_size,J.strm.next_in),0),J.strstart=J.w_size,J.insert=J.strstart;else{if(J.window_size-J.strstart<=X){if(J.strstart-=J.w_size,J.window.set(J.window.subarray(J.w_size,J.w_size+J.strstart),0),J.matches<2)J.matches++;if(J.insert>J.strstart)J.insert=J.strstart}J.window.set(J.strm.input.subarray(J.strm.next_in-X,J.strm.next_in),J.strstart),J.strstart+=X,J.insert+=X>J.w_size-J.insert?J.w_size-J.insert:X}J.block_start=J.strstart}if(J.high_water<J.strstart)J.high_water=J.strstart;if(Y)return X1;if(Q!==v0&&Q!==q0&&J.strm.avail_in===0&&J.strstart===J.block_start)return Y1;if(q=J.window_size-J.strstart,J.strm.avail_in>q&&J.block_start>=J.w_size){if(J.block_start-=J.w_size,J.strstart-=J.w_size,J.window.set(J.window.subarray(J.w_size,J.w_size+J.strstart),0),J.matches<2)J.matches++;if(q+=J.w_size,J.insert>J.strstart)J.insert=J.strstart}if(q>J.strm.avail_in)q=J.strm.avail_in;if(q)n8(J.strm,J.window,J.strstart,q),J.strstart+=q,J.insert+=q>J.w_size-J.insert?J.w_size-J.insert:q;if(J.high_water<J.strstart)J.high_water=J.strstart;if(q=J.bi_valid+42>>3,q=J.pending_buf_size-q>65535?65535:J.pending_buf_size-q,W=q>J.w_size?J.w_size:q,V=J.strstart-J.block_start,V>=W||(V||Q===q0)&&Q!==v0&&J.strm.avail_in===0&&V<=q)G=V>q?q:V,Y=Q===q0&&J.strm.avail_in===0&&G===V?1:0,d8(J,J.block_start,G,Y),J.block_start+=G,W0(J.strm);return Y?u0:t},S8=(J,Q)=>{let W,G;for(;;){if(J.lookahead<$0){if(V1(J),J.lookahead<$0&&Q===v0)return t;if(J.lookahead===0)break}if(W=0,J.lookahead>=T)J.ins_h=D0(J,J.ins_h,J.window[J.strstart+T-1]),W=J.prev[J.strstart&J.w_mask]=J.head[J.ins_h],J.head[J.ins_h]=J.strstart;if(W!==0&&J.strstart-W<=J.w_size-$0)J.match_length=w5(J,W);if(J.match_length>=T)if(G=A0(J,J.strstart-J.match_start,J.match_length-T),J.lookahead-=J.match_length,J.match_length<=J.max_lazy_match&&J.lookahead>=T){J.match_length--;do J.strstart++,J.ins_h=D0(J,J.ins_h,J.window[J.strstart+T-1]),W=J.prev[J.strstart&J.w_mask]=J.head[J.ins_h],J.head[J.ins_h]=J.strstart;while(--J.match_length!==0);J.strstart++}else J.strstart+=J.match_length,J.match_length=0,J.ins_h=J.window[J.strstart],J.ins_h=D0(J,J.ins_h,J.window[J.strstart+1]);else G=A0(J,0,J.window[J.strstart]),J.lookahead--,J.strstart++;if(G){if(Q0(J,!1),J.strm.avail_out===0)return t}}if(J.insert=J.strstart<T-1?J.strstart:T-1,Q===q0){if(Q0(J,!0),J.strm.avail_out===0)return u0;return X1}if(J.sym_next){if(Q0(J,!1),J.strm.avail_out===0)return t}return Y1},J1=(J,Q)=>{let W,G,V;for(;;){if(J.lookahead<$0){if(V1(J),J.lookahead<$0&&Q===v0)return t;if(J.lookahead===0)break}if(W=0,J.lookahead>=T)J.ins_h=D0(J,J.ins_h,J.window[J.strstart+T-1]),W=J.prev[J.strstart&J.w_mask]=J.head[J.ins_h],J.head[J.ins_h]=J.strstart;if(J.prev_length=J.match_length,J.prev_match=J.match_start,J.match_length=T-1,W!==0&&J.prev_length<J.max_lazy_match&&J.strstart-W<=J.w_size-$0){if(J.match_length=w5(J,W),J.match_length<=5&&(J.strategy===vW||J.match_length===T&&J.strstart-J.match_start>4096))J.match_length=T-1}if(J.prev_length>=T&&J.match_length<=J.prev_length){V=J.strstart+J.lookahead-T,G=A0(J,J.strstart-1-J.prev_match,J.prev_length-T),J.lookahead-=J.prev_length-1,J.prev_length-=2;do if(++J.strstart<=V)J.ins_h=D0(J,J.ins_h,J.window[J.strstart+T-1]),W=J.prev[J.strstart&J.w_mask]=J.head[J.ins_h],J.head[J.ins_h]=J.strstart;while(--J.prev_length!==0);if(J.match_available=0,J.match_length=T-1,J.strstart++,G){if(Q0(J,!1),J.strm.avail_out===0)return t}}else if(J.match_available){if(G=A0(J,0,J.window[J.strstart-1]),G)Q0(J,!1);if(J.strstart++,J.lookahead--,J.strm.avail_out===0)return t}else J.match_available=1,J.strstart++,J.lookahead--}if(J.match_available)G=A0(J,0,J.window[J.strstart-1]),J.match_available=0;if(J.insert=J.strstart<T-1?J.strstart:T-1,Q===q0){if(Q0(J,!0),J.strm.avail_out===0)return u0;return X1}if(J.sym_next){if(Q0(J,!1),J.strm.avail_out===0)return t}return Y1},rW=(J,Q)=>{let W,G,V,q;const Y=J.window;for(;;){if(J.lookahead<=w0){if(V1(J),J.lookahead<=w0&&Q===v0)return t;if(J.lookahead===0)break}if(J.match_length=0,J.lookahead>=T&&J.strstart>0){if(V=J.strstart-1,G=Y[V],G===Y[++V]&&G===Y[++V]&&G===Y[++V]){q=J.strstart+w0;do;while(G===Y[++V]&&G===Y[++V]&&G===Y[++V]&&G===Y[++V]&&G===Y[++V]&&G===Y[++V]&&G===Y[++V]&&G===Y[++V]&&V<q);if(J.match_length=w0-(q-V),J.match_length>J.lookahead)J.match_length=J.lookahead}}if(J.match_length>=T)W=A0(J,1,J.match_length-T),J.lookahead-=J.match_length,J.strstart+=J.match_length,J.match_length=0;else W=A0(J,0,J.window[J.strstart]),J.lookahead--,J.strstart++;if(W){if(Q0(J,!1),J.strm.avail_out===0)return t}}if(J.insert=0,Q===q0){if(Q0(J,!0),J.strm.avail_out===0)return u0;return X1}if(J.sym_next){if(Q0(J,!1),J.strm.avail_out===0)return t}return Y1},nW=(J,Q)=>{let W;for(;;){if(J.lookahead===0){if(V1(J),J.lookahead===0){if(Q===v0)return t;break}}if(J.match_length=0,W=A0(J,0,J.window[J.strstart]),J.lookahead--,J.strstart++,W){if(Q0(J,!1),J.strm.avail_out===0)return t}}if(J.insert=0,Q===q0){if(Q0(J,!0),J.strm.avail_out===0)return u0;return X1}if(J.sym_next){if(Q0(J,!1),J.strm.avail_out===0)return t}return Y1},B1=[new Z0(0,0,0,0,A5),new Z0(4,4,8,4,S8),new Z0(4,5,16,8,S8),new Z0(4,6,32,32,S8),new Z0(4,4,16,16,J1),new Z0(8,16,32,32,J1),new Z0(8,16,128,128,J1),new Z0(8,32,128,256,J1),new Z0(32,128,258,1024,J1),new Z0(32,258,258,4096,J1)],oW=(J)=>{J.window_size=2*J.w_size,N0(J.head),J.max_lazy_match=B1[J.level].max_lazy,J.good_match=B1[J.level].good_length,J.nice_match=B1[J.level].nice_length,J.max_chain_length=B1[J.level].max_chain,J.strstart=0,J.block_start=0,J.lookahead=0,J.insert=0,J.match_length=J.prev_length=T-1,J.match_available=0,J.ins_h=0},S1=(J)=>{if(!J)return 1;const Q=J.state;if(!Q||Q.strm!==J||Q.status!==G1&&Q.status!==e8&&Q.status!==_8&&Q.status!==l8&&Q.status!==i8&&Q.status!==r8&&Q.status!==f0&&Q.status!==C1)return 1;return 0},v5=(J)=>{if(S1(J))return h0(J,H0);J.total_in=J.total_out=0,J.data_type=gW;const Q=J.state;if(Q.pending=0,Q.pending_out=0,Q.wrap<0)Q.wrap=-Q.wrap;return Q.status=Q.wrap===2?e8:Q.wrap?G1:f0,J.adler=Q.wrap===2?0:1,Q.last_flush=-2,RW(Q),a},D5=(J)=>{const Q=v5(J);if(Q===a)oW(J.state);return Q},sW=(J,Q)=>{if(S1(J)||J.state.wrap!==2)return H0;return J.state.gzhead=Q,a},S5=(J,Q,W,G,V,q)=>{if(!J)return H0;let Y=1;if(Q===AW)Q=6;if(G<0)Y=0,G=-G;else if(G>15)Y=2,G-=16;if(V<1||V>yW||W!==V8||G<8||G>15||Q<0||Q>9||q<0||q>SW||G===8&&Y!==1)return h0(J,H0);if(G===8)G=9;const X=new aW;return J.state=X,X.strm=J,X.status=G1,X.wrap=Y,X.gzhead=null,X.w_bits=G,X.w_size=1<<X.w_bits,X.w_mask=X.w_size-1,X.hash_bits=V+7,X.hash_size=1<<X.hash_bits,X.hash_mask=X.hash_size-1,X.hash_shift=~~((X.hash_bits+T-1)/T),X.window=new Uint8Array(X.w_size*2),X.head=new Uint16Array(X.hash_size),X.prev=new Uint16Array(X.w_size),X.lit_bufsize=1<<V+6,X.pending_buf_size=X.lit_bufsize*4,X.pending_buf=new Uint8Array(X.pending_buf_size),X.sym_buf=X.lit_bufsize,X.sym_end=(X.lit_bufsize-1)*3,X.level=Q,X.strategy=q,X.method=W,D5(J)},tW=(J,Q)=>{return S5(J,Q,V8,EW,pW,TW)},eW=(J,Q)=>{if(S1(J)||Q>g6||Q<0)return J?h0(J,H0):H0;const W=J.state;if(!J.output||J.avail_in!==0&&!J.input||W.status===C1&&Q!==q0)return h0(J,J.avail_out===0?D8:H0);const G=W.last_flush;if(W.last_flush=Q,W.pending!==0){if(W0(J),J.avail_out===0)return W.last_flush=-1,a}else if(J.avail_in===0&&E6(Q)<=E6(G)&&Q!==q0)return h0(J,D8);if(W.status===C1&&J.avail_in!==0)return h0(J,D8);if(W.status===G1&&W.wrap===0)W.status=f0;if(W.status===G1){let V=V8+(W.w_bits-8<<4)<<8,q=-1;if(W.strategy>=o1||W.level<2)q=0;else if(W.level<6)q=1;else if(W.level===6)q=2;else q=3;if(V|=q<<6,W.strstart!==0)V|=cW;if(V+=31-V%31,$1(W,V),W.strstart!==0)$1(W,J.adler>>>16),$1(W,J.adler&65535);if(J.adler=1,W.status=f0,W0(J),W.pending!==0)return W.last_flush=-1,a}if(W.status===e8)if(J.adler=0,E(W,31),E(W,139),E(W,8),!W.gzhead){if(E(W,0),E(W,0),E(W,0),E(W,0),E(W,0),E(W,W.level===9?2:W.strategy>=o1||W.level<2?4:0),E(W,_W),W.status=f0,W0(J),W.pending!==0)return W.last_flush=-1,a}else{if(E(W,(W.gzhead.text?1:0)+(W.gzhead.hcrc?2:0)+(!W.gzhead.extra?0:4)+(!W.gzhead.name?0:8)+(!W.gzhead.comment?0:16)),E(W,W.gzhead.time&255),E(W,W.gzhead.time>>8&255),E(W,W.gzhead.time>>16&255),E(W,W.gzhead.time>>24&255),E(W,W.level===9?2:W.strategy>=o1||W.level<2?4:0),E(W,W.gzhead.os&255),W.gzhead.extra&&W.gzhead.extra.length)E(W,W.gzhead.extra.length&255),E(W,W.gzhead.extra.length>>8&255);if(W.gzhead.hcrc)J.adler=r(J.adler,W.pending_buf,W.pending,0);W.gzindex=0,W.status=_8}if(W.status===_8){if(W.gzhead.extra){let V=W.pending,q=(W.gzhead.extra.length&65535)-W.gzindex;while(W.pending+q>W.pending_buf_size){let X=W.pending_buf_size-W.pending;if(W.pending_buf.set(W.gzhead.extra.subarray(W.gzindex,W.gzindex+X),W.pending),W.pending=W.pending_buf_size,W.gzhead.hcrc&&W.pending>V)J.adler=r(J.adler,W.pending_buf,W.pending-V,V);if(W.gzindex+=X,W0(J),W.pending!==0)return W.last_flush=-1,a;V=0,q-=X}let Y=new Uint8Array(W.gzhead.extra);if(W.pending_buf.set(Y.subarray(W.gzindex,W.gzindex+q),W.pending),W.pending+=q,W.gzhead.hcrc&&W.pending>V)J.adler=r(J.adler,W.pending_buf,W.pending-V,V);W.gzindex=0}W.status=l8}if(W.status===l8){if(W.gzhead.name){let V=W.pending,q;do{if(W.pending===W.pending_buf_size){if(W.gzhead.hcrc&&W.pending>V)J.adler=r(J.adler,W.pending_buf,W.pending-V,V);if(W0(J),W.pending!==0)return W.last_flush=-1,a;V=0}if(W.gzindex<W.gzhead.name.length)q=W.gzhead.name.charCodeAt(W.gzindex++)&255;else q=0;E(W,q)}while(q!==0);if(W.gzhead.hcrc&&W.pending>V)J.adler=r(J.adler,W.pending_buf,W.pending-V,V);W.gzindex=0}W.status=i8}if(W.status===i8){if(W.gzhead.comment){let V=W.pending,q;do{if(W.pending===W.pending_buf_size){if(W.gzhead.hcrc&&W.pending>V)J.adler=r(J.adler,W.pending_buf,W.pending-V,V);if(W0(J),W.pending!==0)return W.last_flush=-1,a;V=0}if(W.gzindex<W.gzhead.comment.length)q=W.gzhead.comment.charCodeAt(W.gzindex++)&255;else q=0;E(W,q)}while(q!==0);if(W.gzhead.hcrc&&W.pending>V)J.adler=r(J.adler,W.pending_buf,W.pending-V,V)}W.status=r8}if(W.status===r8){if(W.gzhead.hcrc){if(W.pending+2>W.pending_buf_size){if(W0(J),W.pending!==0)return W.last_flush=-1,a}E(W,J.adler&255),E(W,J.adler>>8&255),J.adler=0}if(W.status=f0,W0(J),W.pending!==0)return W.last_flush=-1,a}if(J.avail_in!==0||W.lookahead!==0||Q!==v0&&W.status!==C1){let V=W.level===0?A5(W,Q):W.strategy===o1?nW(W,Q):W.strategy===DW?rW(W,Q):B1[W.level].func(W,Q);if(V===u0||V===X1)W.status=C1;if(V===t||V===u0){if(J.avail_out===0)W.last_flush=-1;return a}if(V===Y1){if(Q===IW)OW(W);else if(Q!==g6){if(d8(W,0,0,!1),Q===NW){if(N0(W.head),W.lookahead===0)W.strstart=0,W.block_start=0,W.insert=0}}if(W0(J),J.avail_out===0)return W.last_flush=-1,a}}if(Q!==q0)return a;if(W.wrap<=0)return y6;if(W.wrap===2)E(W,J.adler&255),E(W,J.adler>>8&255),E(W,J.adler>>16&255),E(W,J.adler>>24&255),E(W,J.total_in&255),E(W,J.total_in>>8&255),E(W,J.total_in>>16&255),E(W,J.total_in>>24&255);else $1(W,J.adler>>>16),$1(W,J.adler&65535);if(W0(J),W.wrap>0)W.wrap=-W.wrap;return W.pending!==0?a:y6},J7=(J)=>{if(S1(J))return H0;const Q=J.state.status;return J.state=null,Q===f0?h0(J,wW):a},W7=(J,Q)=>{let W=Q.length;if(S1(J))return H0;const G=J.state,V=G.wrap;if(V===2||V===1&&G.status!==G1||G.lookahead)return H0;if(V===1)J.adler=N1(J.adler,Q,W,0);if(G.wrap=0,W>=G.w_size){if(V===0)N0(G.head),G.strstart=0,G.block_start=0,G.insert=0;let K=new Uint8Array(G.w_size);K.set(Q.subarray(W-G.w_size,W),0),Q=K,W=G.w_size}const{avail_in:q,next_in:Y,input:X}=J;J.avail_in=W,J.next_in=0,J.input=Q,V1(G);while(G.lookahead>=T){let K=G.strstart,U=G.lookahead-(T-1);do G.ins_h=D0(G,G.ins_h,G.window[K+T-1]),G.prev[K&G.w_mask]=G.head[G.ins_h],G.head[G.ins_h]=K,K++;while(--U);G.strstart=K,G.lookahead=T-1,V1(G)}return G.strstart+=G.lookahead,G.block_start=G.strstart,G.insert=G.lookahead,G.lookahead=0,G.match_length=G.prev_length=T-1,G.match_available=0,J.next_in=Y,J.input=X,J.avail_in=q,G.wrap=V,a},Q7=tW,G7=S5,V7=D5,q7=v5,Y7=sW,X7=eW,U7=J7,P7=W7,K7="pako deflate (from Nodeca project)",j1={deflateInit:Q7,deflateInit2:G7,deflateReset:V7,deflateResetKeep:q7,deflateSetHeader:Y7,deflate:X7,deflateEnd:U7,deflateSetDictionary:P7,deflateInfo:K7},F7=(J,Q)=>{return Object.prototype.hasOwnProperty.call(J,Q)},z7=function(J){const Q=Array.prototype.slice.call(arguments,1);while(Q.length){const W=Q.shift();if(!W)continue;if(typeof W!=="object")throw new TypeError(W+"must be non-object");for(let G in W)if(F7(W,G))J[G]=W[G]}return J},Z7=(J)=>{let Q=0;for(let G=0,V=J.length;G<V;G++)Q+=J[G].length;const W=new Uint8Array(Q);for(let G=0,V=0,q=J.length;G<q;G++){let Y=J[G];W.set(Y,V),V+=Y.length}return W},q8={assign:z7,flattenChunks:Z7},T5=!0;try{String.fromCharCode.apply(null,new Uint8Array(1))}catch(J){T5=!1}var w1=new Uint8Array(256);for(let J=0;J<256;J++)w1[J]=J>=252?6:J>=248?5:J>=240?4:J>=224?3:J>=192?2:1;w1[254]=w1[254]=1;var k7=(J)=>{if(typeof TextEncoder==="function"&&TextEncoder.prototype.encode)return(new TextEncoder()).encode(J);let Q,W,G,V,q,Y=J.length,X=0;for(V=0;V<Y;V++){if(W=J.charCodeAt(V),(W&64512)===55296&&V+1<Y){if(G=J.charCodeAt(V+1),(G&64512)===56320)W=65536+(W-55296<<10)+(G-56320),V++}X+=W<128?1:W<2048?2:W<65536?3:4}Q=new Uint8Array(X);for(q=0,V=0;q<X;V++){if(W=J.charCodeAt(V),(W&64512)===55296&&V+1<Y){if(G=J.charCodeAt(V+1),(G&64512)===56320)W=65536+(W-55296<<10)+(G-56320),V++}if(W<128)Q[q++]=W;else if(W<2048)Q[q++]=192|W>>>6,Q[q++]=128|W&63;else if(W<65536)Q[q++]=224|W>>>12,Q[q++]=128|W>>>6&63,Q[q++]=128|W&63;else Q[q++]=240|W>>>18,Q[q++]=128|W>>>12&63,Q[q++]=128|W>>>6&63,Q[q++]=128|W&63}return Q},H7=(J,Q)=>{if(Q<65534){if(J.subarray&&T5)return String.fromCharCode.apply(null,J.length===Q?J:J.subarray(0,Q))}let W="";for(let G=0;G<Q;G++)W+=String.fromCharCode(J[G]);return W},$7=(J,Q)=>{const W=Q||J.length;if(typeof TextDecoder==="function"&&TextDecoder.prototype.decode)return(new TextDecoder()).decode(J.subarray(0,Q));let G,V;const q=new Array(W*2);for(V=0,G=0;G<W;){let Y=J[G++];if(Y<128){q[V++]=Y;continue}let X=w1[Y];if(X>4){q[V++]=65533,G+=X-1;continue}Y&=X===2?31:X===3?15:7;while(X>1&&G<W)Y=Y<<6|J[G++]&63,X--;if(X>1){q[V++]=65533;continue}if(Y<65536)q[V++]=Y;else Y-=65536,q[V++]=55296|Y>>10&1023,q[V++]=56320|Y&1023}return H7(q,V)},C7=(J,Q)=>{if(Q=Q||J.length,Q>J.length)Q=J.length;let W=Q-1;while(W>=0&&(J[W]&192)===128)W--;if(W<0)return Q;if(W===0)return Q;return W+w1[J[W]]>Q?W:Q},A1={string2buf:k7,buf2string:$7,utf8border:C7},g5=B7,y5=Object.prototype.toString,{Z_NO_FLUSH:M7,Z_SYNC_FLUSH:j7,Z_FULL_FLUSH:L7,Z_FINISH:R7,Z_OK:Q8,Z_STREAM_END:x7,Z_DEFAULT_COMPRESSION:O7,Z_DEFAULT_STRATEGY:I7,Z_DEFLATED:N7}=d0;T1.prototype.push=function(J,Q){const W=this.strm,G=this.options.chunkSize;let V,q;if(this.ended)return!1;if(Q===~~Q)q=Q;else q=Q===!0?R7:M7;if(typeof J==="string")W.input=A1.string2buf(J);else if(y5.call(J)==="[object ArrayBuffer]")W.input=new Uint8Array(J);else W.input=J;W.next_in=0,W.avail_in=W.input.length;for(;;){if(W.avail_out===0)W.output=new Uint8Array(G),W.next_out=0,W.avail_out=G;if((q===j7||q===L7)&&W.avail_out<=6){this.onData(W.output.subarray(0,W.next_out)),W.avail_out=0;continue}if(V=j1.deflate(W,q),V===x7){if(W.next_out>0)this.onData(W.output.subarray(0,W.next_out));return V=j1.deflateEnd(this.strm),this.onEnd(V),this.ended=!0,V===Q8}if(W.avail_out===0){this.onData(W.output);continue}if(q>0&&W.next_out>0){this.onData(W.output.subarray(0,W.next_out)),W.avail_out=0;continue}if(W.avail_in===0)break}return!0};T1.prototype.onData=function(J){this.chunks.push(J)};T1.prototype.onEnd=function(J){if(J===Q8)this.result=q8.flattenChunks(this.chunks);this.chunks=[],this.err=J,this.msg=this.strm.msg};var v7=T1,D7=J6,S7=w7,T7=A7,g7=d0,y7={Deflate:v7,deflate:D7,deflateRaw:S7,gzip:T7,constants:g7},a1=16209,E7=16191,p7=function J(Q,W){let G,V,q,Y,X,K,U,P,Z,z,F,H,R,M,x,N,O,$,v,h,j,g,w,I;const k=Q.state;G=Q.next_in,w=Q.input,V=G+(Q.avail_in-5),q=Q.next_out,I=Q.output,Y=q-(W-Q.avail_out),X=q+(Q.avail_out-257),K=k.dmax,U=k.wsize,P=k.whave,Z=k.wnext,z=k.window,F=k.hold,H=k.bits,R=k.lencode,M=k.distcode,x=(1<<k.lenbits)-1,N=(1<<k.distbits)-1;J:do{if(H<15)F+=w[G++]<<H,H+=8,F+=w[G++]<<H,H+=8;O=R[F&x];W:for(;;){if($=O>>>24,F>>>=$,H-=$,$=O>>>16&255,$===0)I[q++]=O&65535;else if($&16){if(v=O&65535,$&=15,$){if(H<$)F+=w[G++]<<H,H+=8;v+=F&(1<<$)-1,F>>>=$,H-=$}if(H<15)F+=w[G++]<<H,H+=8,F+=w[G++]<<H,H+=8;O=M[F&N];Q:for(;;){if($=O>>>24,F>>>=$,H-=$,$=O>>>16&255,$&16){if(h=O&65535,$&=15,H<$){if(F+=w[G++]<<H,H+=8,H<$)F+=w[G++]<<H,H+=8}if(h+=F&(1<<$)-1,h>K){Q.msg="invalid distance too far back",k.mode=a1;break J}if(F>>>=$,H-=$,$=q-Y,h>$){if($=h-$,$>P){if(k.sane){Q.msg="invalid distance too far back",k.mode=a1;break J}}if(j=0,g=z,Z===0){if(j+=U-$,$<v){v-=$;do I[q++]=z[j++];while(--$);j=q-h,g=I}}else if(Z<$){if(j+=U+Z-$,$-=Z,$<v){v-=$;do I[q++]=z[j++];while(--$);if(j=0,Z<v){$=Z,v-=$;do I[q++]=z[j++];while(--$);j=q-h,g=I}}}else if(j+=Z-$,$<v){v-=$;do I[q++]=z[j++];while(--$);j=q-h,g=I}while(v>2)I[q++]=g[j++],I[q++]=g[j++],I[q++]=g[j++],v-=3;if(v){if(I[q++]=g[j++],v>1)I[q++]=g[j++]}}else{j=q-h;do I[q++]=I[j++],I[q++]=I[j++],I[q++]=I[j++],v-=3;while(v>2);if(v){if(I[q++]=I[j++],v>1)I[q++]=I[j++]}}}else if(($&64)===0){O=M[(O&65535)+(F&(1<<$)-1)];continue Q}else{Q.msg="invalid distance code",k.mode=a1;break J}break}}else if(($&64)===0){O=R[(O&65535)+(F&(1<<$)-1)];continue W}else if($&32){k.mode=E7;break J}else{Q.msg="invalid literal/length code",k.mode=a1;break J}break}}while(G<V&&q<X);v=H>>3,G-=v,H-=v<<3,F&=(1<<H)-1,Q.next_in=G,Q.next_out=q,Q.avail_in=G<V?5+(V-G):5-(G-V),Q.avail_out=q<X?257+(X-q):257-(q-X),k.hold=F,k.bits=H;return},W1=15,p6=852,f6=592,h6=0,T8=1,b6=2,f7=new Uint16Array([3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,0,0]),h7=new Uint8Array([16,16,16,16,16,16,16,16,17,17,17,17,18,18,18,18,19,19,19,19,20,20,20,20,21,21,21,21,16,72,78]),b7=new Uint16Array([1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,0,0]),u7=new Uint8Array([16,16,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,64,64]),m7=(J,Q,W,G,V,q,Y,X)=>{const K=X.bits;let U=0,P=0,Z=0,z=0,F=0,H=0,R=0,M=0,x=0,N=0,O,$,v,h,j,g=null,w;const I=new Uint16Array(W1+1),k=new Uint16Array(W1+1);let L=null,y,D,B;for(U=0;U<=W1;U++)I[U]=0;for(P=0;P<G;P++)I[Q[W+P]]++;F=K;for(z=W1;z>=1;z--)if(I[z]!==0)break;if(F>z)F=z;if(z===0)return V[q++]=1<<24|64<<16|0,V[q++]=1<<24|64<<16|0,X.bits=1,0;for(Z=1;Z<z;Z++)if(I[Z]!==0)break;if(F<Z)F=Z;M=1;for(U=1;U<=W1;U++)if(M<<=1,M-=I[U],M<0)return-1;if(M>0&&(J===h6||z!==1))return-1;k[1]=0;for(U=1;U<W1;U++)k[U+1]=k[U]+I[U];for(P=0;P<G;P++)if(Q[W+P]!==0)Y[k[Q[W+P]]++]=P;if(J===h6)g=L=Y,w=20;else if(J===T8)g=f7,L=h7,w=257;else g=b7,L=u7,w=0;if(N=0,P=0,U=Z,j=q,H=F,R=0,v=-1,x=1<<F,h=x-1,J===T8&&x>p6||J===b6&&x>f6)return 1;for(;;){if(y=U-R,Y[P]+1<w)D=0,B=Y[P];else if(Y[P]>=w)D=L[Y[P]-w],B=g[Y[P]-w];else D=96,B=0;O=1<<U-R,$=1<<H,Z=$;do $-=O,V[j+(N>>R)+$]=y<<24|D<<16|B|0;while($!==0);O=1<<U-1;while(N&O)O>>=1;if(O!==0)N&=O-1,N+=O;else N=0;if(P++,--I[U]===0){if(U===z)break;U=Q[W+Y[P]]}if(U>F&&(N&h)!==v){if(R===0)R=F;j+=Z,H=U-R,M=1<<H;while(H+R<z){if(M-=I[H+R],M<=0)break;H++,M<<=1}if(x+=1<<H,J===T8&&x>p6||J===b6&&x>f6)return 1;v=N&h,V[v]=F<<24|H<<16|j-q|0}}if(N!==0)V[j+N]=U-R<<24|64<<16|0;return X.bits=F,0},L1=m7,d7=0,E5=1,p5=2,{Z_FINISH:u6,Z_BLOCK:c7,Z_TREES:s1,Z_OK:m0,Z_STREAM_END:_7,Z_NEED_DICT:l7,Z_STREAM_ERROR:Y0,Z_DATA_ERROR:f5,Z_MEM_ERROR:h5,Z_BUF_ERROR:i7,Z_DEFLATED:m6}=d0,Y8=16180,d6=16181,c6=16182,_6=16183,l6=16184,i6=16185,r6=16186,n6=16187,o6=16188,a6=16189,G8=16190,j0=16191,g8=16192,s6=16193,y8=16194,t6=16195,e6=16196,J5=16197,W5=16198,t1=16199,e1=16200,Q5=16201,G5=16202,V5=16203,q5=16204,Y5=16205,E8=16206,X5=16207,U5=16208,d=16209,b5=16210,u5=16211,r7=852,n7=592,o7=15,a7=o7,P5=(J)=>{return(J>>>24&255)+(J>>>8&65280)+((J&65280)<<8)+((J&255)<<24)},c0=(J)=>{if(!J)return 1;const Q=J.state;if(!Q||Q.strm!==J||Q.mode<Y8||Q.mode>u5)return 1;return 0},m5=(J)=>{if(c0(J))return Y0;const Q=J.state;if(J.total_in=J.total_out=Q.total=0,J.msg="",Q.wrap)J.adler=Q.wrap&1;return Q.mode=Y8,Q.last=0,Q.havedict=0,Q.flags=-1,Q.dmax=32768,Q.head=null,Q.hold=0,Q.bits=0,Q.lencode=Q.lendyn=new Int32Array(r7),Q.distcode=Q.distdyn=new Int32Array(n7),Q.sane=1,Q.back=-1,m0},d5=(J)=>{if(c0(J))return Y0;const Q=J.state;return Q.wsize=0,Q.whave=0,Q.wnext=0,m5(J)},c5=(J,Q)=>{let W;if(c0(J))return Y0;const G=J.state;if(Q<0)W=0,Q=-Q;else if(W=(Q>>4)+5,Q<48)Q&=15;if(Q&&(Q<8||Q>15))return Y0;if(G.window!==null&&G.wbits!==Q)G.window=null;return G.wrap=W,G.wbits=Q,d5(J)},_5=(J,Q)=>{if(!J)return Y0;const W=new s7;J.state=W,W.strm=J,W.window=null,W.mode=Y8;const G=c5(J,Q);if(G!==m0)J.state=null;return G},t7=(J)=>{return _5(J,a7)},K5=!0,p8,f8,e7=(J)=>{if(K5){p8=new Int32Array(512),f8=new Int32Array(32);let Q=0;while(Q<144)J.lens[Q++]=8;while(Q<256)J.lens[Q++]=9;while(Q<280)J.lens[Q++]=7;while(Q<288)J.lens[Q++]=8;L1(E5,J.lens,0,288,p8,0,J.work,{bits:9}),Q=0;while(Q<32)J.lens[Q++]=5;L1(p5,J.lens,0,32,f8,0,J.work,{bits:5}),K5=!1}J.lencode=p8,J.lenbits=9,J.distcode=f8,J.distbits=5},l5=(J,Q,W,G)=>{let V;const q=J.state;if(q.window===null)q.wsize=1<<q.wbits,q.wnext=0,q.whave=0,q.window=new Uint8Array(q.wsize);if(G>=q.wsize)q.window.set(Q.subarray(W-q.wsize,W),0),q.wnext=0,q.whave=q.wsize;else{if(V=q.wsize-q.wnext,V>G)V=G;if(q.window.set(Q.subarray(W-G,W-G+V),q.wnext),G-=V,G)q.window.set(Q.subarray(W-G,W),0),q.wnext=G,q.whave=q.wsize;else{if(q.wnext+=V,q.wnext===q.wsize)q.wnext=0;if(q.whave<q.wsize)q.whave+=V}}return 0},JQ=(J,Q)=>{let W,G,V,q,Y,X,K,U,P,Z,z,F,H,R,M=0,x,N,O,$,v,h,j,g;const w=new Uint8Array(4);let I,k;const L=new Uint8Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]);if(c0(J)||!J.output||!J.input&&J.avail_in!==0)return Y0;if(W=J.state,W.mode===j0)W.mode=g8;Y=J.next_out,V=J.output,K=J.avail_out,q=J.next_in,G=J.input,X=J.avail_in,U=W.hold,P=W.bits,Z=X,z=K,g=m0;J:for(;;)switch(W.mode){case Y8:if(W.wrap===0){W.mode=g8;break}while(P<16){if(X===0)break J;X--,U+=G[q++]<<P,P+=8}if(W.wrap&2&&U===35615){if(W.wbits===0)W.wbits=15;W.check=0,w[0]=U&255,w[1]=U>>>8&255,W.check=r(W.check,w,2,0),U=0,P=0,W.mode=d6;break}if(W.head)W.head.done=!1;if(!(W.wrap&1)||(((U&255)<<8)+(U>>8))%31){J.msg="incorrect header check",W.mode=d;break}if((U&15)!==m6){J.msg="unknown compression method",W.mode=d;break}if(U>>>=4,P-=4,j=(U&15)+8,W.wbits===0)W.wbits=j;if(j>15||j>W.wbits){J.msg="invalid window size",W.mode=d;break}W.dmax=1<<W.wbits,W.flags=0,J.adler=W.check=1,W.mode=U&512?a6:j0,U=0,P=0;break;case d6:while(P<16){if(X===0)break J;X--,U+=G[q++]<<P,P+=8}if(W.flags=U,(W.flags&255)!==m6){J.msg="unknown compression method",W.mode=d;break}if(W.flags&57344){J.msg="unknown header flags set",W.mode=d;break}if(W.head)W.head.text=U>>8&1;if(W.flags&512&&W.wrap&4)w[0]=U&255,w[1]=U>>>8&255,W.check=r(W.check,w,2,0);U=0,P=0,W.mode=c6;case c6:while(P<32){if(X===0)break J;X--,U+=G[q++]<<P,P+=8}if(W.head)W.head.time=U;if(W.flags&512&&W.wrap&4)w[0]=U&255,w[1]=U>>>8&255,w[2]=U>>>16&255,w[3]=U>>>24&255,W.check=r(W.check,w,4,0);U=0,P=0,W.mode=_6;case _6:while(P<16){if(X===0)break J;X--,U+=G[q++]<<P,P+=8}if(W.head)W.head.xflags=U&255,W.head.os=U>>8;if(W.flags&512&&W.wrap&4)w[0]=U&255,w[1]=U>>>8&255,W.check=r(W.check,w,2,0);U=0,P=0,W.mode=l6;case l6:if(W.flags&1024){while(P<16){if(X===0)break J;X--,U+=G[q++]<<P,P+=8}if(W.length=U,W.head)W.head.extra_len=U;if(W.flags&512&&W.wrap&4)w[0]=U&255,w[1]=U>>>8&255,W.check=r(W.check,w,2,0);U=0,P=0}else if(W.head)W.head.extra=null;W.mode=i6;case i6:if(W.flags&1024){if(F=W.length,F>X)F=X;if(F){if(W.head){if(j=W.head.extra_len-W.length,!W.head.extra)W.head.extra=new Uint8Array(W.head.extra_len);W.head.extra.set(G.subarray(q,q+F),j)}if(W.flags&512&&W.wrap&4)W.check=r(W.check,G,F,q);X-=F,q+=F,W.length-=F}if(W.length)break J}W.length=0,W.mode=r6;case r6:if(W.flags&2048){if(X===0)break J;F=0;do if(j=G[q+F++],W.head&&j&&W.length<65536)W.head.name+=String.fromCharCode(j);while(j&&F<X);if(W.flags&512&&W.wrap&4)W.check=r(W.check,G,F,q);if(X-=F,q+=F,j)break J}else if(W.head)W.head.name=null;W.length=0,W.mode=n6;case n6:if(W.flags&4096){if(X===0)break J;F=0;do if(j=G[q+F++],W.head&&j&&W.length<65536)W.head.comment+=String.fromCharCode(j);while(j&&F<X);if(W.flags&512&&W.wrap&4)W.check=r(W.check,G,F,q);if(X-=F,q+=F,j)break J}else if(W.head)W.head.comment=null;W.mode=o6;case o6:if(W.flags&512){while(P<16){if(X===0)break J;X--,U+=G[q++]<<P,P+=8}if(W.wrap&4&&U!==(W.check&65535)){J.msg="header crc mismatch",W.mode=d;break}U=0,P=0}if(W.head)W.head.hcrc=W.flags>>9&1,W.head.done=!0;J.adler=W.check=0,W.mode=j0;break;case a6:while(P<32){if(X===0)break J;X--,U+=G[q++]<<P,P+=8}J.adler=W.check=P5(U),U=0,P=0,W.mode=G8;case G8:if(W.havedict===0)return J.next_out=Y,J.avail_out=K,J.next_in=q,J.avail_in=X,W.hold=U,W.bits=P,l7;J.adler=W.check=1,W.mode=j0;case j0:if(Q===c7||Q===s1)break J;case g8:if(W.last){U>>>=P&7,P-=P&7,W.mode=E8;break}while(P<3){if(X===0)break J;X--,U+=G[q++]<<P,P+=8}switch(W.last=U&1,U>>>=1,P-=1,U&3){case 0:W.mode=s6;break;case 1:if(e7(W),W.mode=t1,Q===s1){U>>>=2,P-=2;break J}break;case 2:W.mode=e6;break;case 3:J.msg="invalid block type",W.mode=d}U>>>=2,P-=2;break;case s6:U>>>=P&7,P-=P&7;while(P<32){if(X===0)break J;X--,U+=G[q++]<<P,P+=8}if((U&65535)!==(U>>>16^65535)){J.msg="invalid stored block lengths",W.mode=d;break}if(W.length=U&65535,U=0,P=0,W.mode=y8,Q===s1)break J;case y8:W.mode=t6;case t6:if(F=W.length,F){if(F>X)F=X;if(F>K)F=K;if(F===0)break J;V.set(G.subarray(q,q+F),Y),X-=F,q+=F,K-=F,Y+=F,W.length-=F;break}W.mode=j0;break;case e6:while(P<14){if(X===0)break J;X--,U+=G[q++]<<P,P+=8}if(W.nlen=(U&31)+257,U>>>=5,P-=5,W.ndist=(U&31)+1,U>>>=5,P-=5,W.ncode=(U&15)+4,U>>>=4,P-=4,W.nlen>286||W.ndist>30){J.msg="too many length or distance symbols",W.mode=d;break}W.have=0,W.mode=J5;case J5:while(W.have<W.ncode){while(P<3){if(X===0)break J;X--,U+=G[q++]<<P,P+=8}W.lens[L[W.have++]]=U&7,U>>>=3,P-=3}while(W.have<19)W.lens[L[W.have++]]=0;if(W.lencode=W.lendyn,W.lenbits=7,I={bits:W.lenbits},g=L1(d7,W.lens,0,19,W.lencode,0,W.work,I),W.lenbits=I.bits,g){J.msg="invalid code lengths set",W.mode=d;break}W.have=0,W.mode=W5;case W5:while(W.have<W.nlen+W.ndist){for(;;){if(M=W.lencode[U&(1<<W.lenbits)-1],x=M>>>24,N=M>>>16&255,O=M&65535,x<=P)break;if(X===0)break J;X--,U+=G[q++]<<P,P+=8}if(O<16)U>>>=x,P-=x,W.lens[W.have++]=O;else{if(O===16){k=x+2;while(P<k){if(X===0)break J;X--,U+=G[q++]<<P,P+=8}if(U>>>=x,P-=x,W.have===0){J.msg="invalid bit length repeat",W.mode=d;break}j=W.lens[W.have-1],F=3+(U&3),U>>>=2,P-=2}else if(O===17){k=x+3;while(P<k){if(X===0)break J;X--,U+=G[q++]<<P,P+=8}U>>>=x,P-=x,j=0,F=3+(U&7),U>>>=3,P-=3}else{k=x+7;while(P<k){if(X===0)break J;X--,U+=G[q++]<<P,P+=8}U>>>=x,P-=x,j=0,F=11+(U&127),U>>>=7,P-=7}if(W.have+F>W.nlen+W.ndist){J.msg="invalid bit length repeat",W.mode=d;break}while(F--)W.lens[W.have++]=j}}if(W.mode===d)break;if(W.lens[256]===0){J.msg="invalid code -- missing end-of-block",W.mode=d;break}if(W.lenbits=9,I={bits:W.lenbits},g=L1(E5,W.lens,0,W.nlen,W.lencode,0,W.work,I),W.lenbits=I.bits,g){J.msg="invalid literal/lengths set",W.mode=d;break}if(W.distbits=6,W.distcode=W.distdyn,I={bits:W.distbits},g=L1(p5,W.lens,W.nlen,W.ndist,W.distcode,0,W.work,I),W.distbits=I.bits,g){J.msg="invalid distances set",W.mode=d;break}if(W.mode=t1,Q===s1)break J;case t1:W.mode=e1;case e1:if(X>=6&&K>=258){if(J.next_out=Y,J.avail_out=K,J.next_in=q,J.avail_in=X,W.hold=U,W.bits=P,p7(J,z),Y=J.next_out,V=J.output,K=J.avail_out,q=J.next_in,G=J.input,X=J.avail_in,U=W.hold,P=W.bits,W.mode===j0)W.back=-1;break}W.back=0;for(;;){if(M=W.lencode[U&(1<<W.lenbits)-1],x=M>>>24,N=M>>>16&255,O=M&65535,x<=P)break;if(X===0)break J;X--,U+=G[q++]<<P,P+=8}if(N&&(N&240)===0){$=x,v=N,h=O;for(;;){if(M=W.lencode[h+((U&(1<<$+v)-1)>>$)],x=M>>>24,N=M>>>16&255,O=M&65535,$+x<=P)break;if(X===0)break J;X--,U+=G[q++]<<P,P+=8}U>>>=$,P-=$,W.back+=$}if(U>>>=x,P-=x,W.back+=x,W.length=O,N===0){W.mode=Y5;break}if(N&32){W.back=-1,W.mode=j0;break}if(N&64){J.msg="invalid literal/length code",W.mode=d;break}W.extra=N&15,W.mode=Q5;case Q5:if(W.extra){k=W.extra;while(P<k){if(X===0)break J;X--,U+=G[q++]<<P,P+=8}W.length+=U&(1<<W.extra)-1,U>>>=W.extra,P-=W.extra,W.back+=W.extra}W.was=W.length,W.mode=G5;case G5:for(;;){if(M=W.distcode[U&(1<<W.distbits)-1],x=M>>>24,N=M>>>16&255,O=M&65535,x<=P)break;if(X===0)break J;X--,U+=G[q++]<<P,P+=8}if((N&240)===0){$=x,v=N,h=O;for(;;){if(M=W.distcode[h+((U&(1<<$+v)-1)>>$)],x=M>>>24,N=M>>>16&255,O=M&65535,$+x<=P)break;if(X===0)break J;X--,U+=G[q++]<<P,P+=8}U>>>=$,P-=$,W.back+=$}if(U>>>=x,P-=x,W.back+=x,N&64){J.msg="invalid distance code",W.mode=d;break}W.offset=O,W.extra=N&15,W.mode=V5;case V5:if(W.extra){k=W.extra;while(P<k){if(X===0)break J;X--,U+=G[q++]<<P,P+=8}W.offset+=U&(1<<W.extra)-1,U>>>=W.extra,P-=W.extra,W.back+=W.extra}if(W.offset>W.dmax){J.msg="invalid distance too far back",W.mode=d;break}W.mode=q5;case q5:if(K===0)break J;if(F=z-K,W.offset>F){if(F=W.offset-F,F>W.whave){if(W.sane){J.msg="invalid distance too far back",W.mode=d;break}}if(F>W.wnext)F-=W.wnext,H=W.wsize-F;else H=W.wnext-F;if(F>W.length)F=W.length;R=W.window}else R=V,H=Y-W.offset,F=W.length;if(F>K)F=K;K-=F,W.length-=F;do V[Y++]=R[H++];while(--F);if(W.length===0)W.mode=e1;break;case Y5:if(K===0)break J;V[Y++]=W.length,K--,W.mode=e1;break;case E8:if(W.wrap){while(P<32){if(X===0)break J;X--,U|=G[q++]<<P,P+=8}if(z-=K,J.total_out+=z,W.total+=z,W.wrap&4&&z)J.adler=W.check=W.flags?r(W.check,V,z,Y-z):N1(W.check,V,z,Y-z);if(z=K,W.wrap&4&&(W.flags?U:P5(U))!==W.check){J.msg="incorrect data check",W.mode=d;break}U=0,P=0}W.mode=X5;case X5:if(W.wrap&&W.flags){while(P<32){if(X===0)break J;X--,U+=G[q++]<<P,P+=8}if(W.wrap&4&&U!==(W.total&4294967295)){J.msg="incorrect length check",W.mode=d;break}U=0,P=0}W.mode=U5;case U5:g=_7;break J;case d:g=f5;break J;case b5:return h5;case u5:default:return Y0}if(J.next_out=Y,J.avail_out=K,J.next_in=q,J.avail_in=X,W.hold=U,W.bits=P,W.wsize||z!==J.avail_out&&W.mode<d&&(W.mode<E8||Q!==u6)){if(l5(J,J.output,J.next_out,z-J.avail_out));}if(Z-=J.avail_in,z-=J.avail_out,J.total_in+=Z,J.total_out+=z,W.total+=z,W.wrap&4&&z)J.adler=W.check=W.flags?r(W.check,V,z,J.next_out-z):N1(W.check,V,z,J.next_out-z);if(J.data_type=W.bits+(W.last?64:0)+(W.mode===j0?128:0)+(W.mode===t1||W.mode===y8?256:0),(Z===0&&z===0||Q===u6)&&g===m0)g=i7;return g},WQ=(J)=>{if(c0(J))return Y0;let Q=J.state;if(Q.window)Q.window=null;return J.state=null,m0},QQ=(J,Q)=>{if(c0(J))return Y0;const W=J.state;if((W.wrap&2)===0)return Y0;return W.head=Q,Q.done=!1,m0},GQ=(J,Q)=>{const W=Q.length;let G,V,q;if(c0(J))return Y0;if(G=J.state,G.wrap!==0&&G.mode!==G8)return Y0;if(G.mode===G8){if(V=1,V=N1(V,Q,W,0),V!==G.check)return f5}if(q=l5(J,Q,W,W),q)return G.mode=b5,h5;return G.havedict=1,m0},VQ=d5,qQ=c5,YQ=m5,XQ=t7,UQ=_5,PQ=JQ,KQ=WQ,FQ=QQ,zQ=GQ,ZQ="pako inflate (from Nodeca project)",R0={inflateReset:VQ,inflateReset2:qQ,inflateResetKeep:YQ,inflateInit:XQ,inflateInit2:UQ,inflate:PQ,inflateEnd:KQ,inflateGetHeader:FQ,inflateSetDictionary:zQ,inflateInfo:ZQ},HQ=kQ,i5=Object.prototype.toString,{Z_NO_FLUSH:$Q,Z_FINISH:CQ,Z_OK:v1,Z_STREAM_END:h8,Z_NEED_DICT:b8,Z_STREAM_ERROR:BQ,Z_DATA_ERROR:F5,Z_MEM_ERROR:MQ}=d0;g1.prototype.push=function(J,Q){const W=this.strm,G=this.options.chunkSize,V=this.options.dictionary;let q,Y,X;if(this.ended)return!1;if(Q===~~Q)Y=Q;else Y=Q===!0?CQ:$Q;if(i5.call(J)==="[object ArrayBuffer]")W.input=new Uint8Array(J);else W.input=J;W.next_in=0,W.avail_in=W.input.length;for(;;){if(W.avail_out===0)W.output=new Uint8Array(G),W.next_out=0,W.avail_out=G;if(q=R0.inflate(W,Y),q===b8&&V){if(q=R0.inflateSetDictionary(W,V),q===v1)q=R0.inflate(W,Y);else if(q===F5)q=b8}while(W.avail_in>0&&q===h8&&W.state.wrap>0&&J[W.next_in]!==0)R0.inflateReset(W),q=R0.inflate(W,Y);switch(q){case BQ:case F5:case b8:case MQ:return this.onEnd(q),this.ended=!0,!1}if(X=W.avail_out,W.next_out){if(W.avail_out===0||q===h8)if(this.options.to==="string"){let K=A1.utf8border(W.output,W.next_out),U=W.next_out-K,P=A1.buf2string(W.output,K);if(W.next_out=U,W.avail_out=G-U,U)W.output.set(W.output.subarray(K,K+U),0);this.onData(P)}else this.onData(W.output.length===W.next_out?W.output:W.output.subarray(0,W.next_out))}if(q===v1&&X===0)continue;if(q===h8)return q=R0.inflateEnd(this.strm),this.onEnd(q),this.ended=!0,!0;if(W.avail_in===0)break}return!0};g1.prototype.onData=function(J){this.chunks.push(J)};g1.prototype.onEnd=function(J){if(J===v1)if(this.options.to==="string")this.result=this.chunks.join("");else this.result=q8.flattenChunks(this.chunks);this.chunks=[],this.err=J,this.msg=this.strm.msg};var LQ=g1,RQ=W6,xQ=jQ,OQ=W6,IQ=d0,NQ={Inflate:LQ,inflate:RQ,inflateRaw:xQ,ungzip:OQ,constants:IQ},{Deflate:wQ,deflate:AQ,deflateRaw:vQ,gzip:DQ}=y7,{Inflate:SQ,inflate:TQ,inflateRaw:gQ,ungzip:yQ}=NQ,EQ=wQ,pQ=AQ,fQ=vQ,hQ=DQ,bQ=SQ,uQ=TQ,mQ=gQ,dQ=yQ,cQ=d0,_0={Deflate:EQ,deflate:pQ,deflateRaw:fQ,gzip:hQ,Inflate:bQ,inflate:uQ,inflateRaw:mQ,ungzip:dQ,constants:cQ};var o5=function(J){const{a:Q,b:W}=c,G=C(J*J),V=C(G*J);return C(V+Q*J+W)},a5=function(J){if(!(J instanceof p))throw new TypeError("JacobianPoint expected")},P8=function(J,Q){const W=Q.negate();return J?W:Q},s5=function(J){return Number.parseInt(J[0],16)>=8?"00"+J:J},t5=function(J){if(J.length<2||J[0]!==2)throw Error("Invalid signature integer tag: "+K1(J));const Q=J[1],W=J.subarray(2,Q+2);if(!Q||W.length!==Q)throw Error("Invalid signature integer: wrong length");if(W[0]===0&&W[1]<=127)throw Error("Invalid signature integer: trailing length");return{data:U0(W),left:J.subarray(Q+2)}},y1=function(...J){if(!J.every((G)=>G instanceof Uint8Array))throw Error("Uint8Array list expected");if(J.length===1)return J[0];const Q=J.reduce((G,V)=>G+V.length,0),W=new Uint8Array(Q);for(let G=0,V=0;G<J.length;G++){const q=J[G];W.set(q,V),V+=q.length}return W},K1=function(J){if(!(J instanceof Uint8Array))throw Error("Expected Uint8Array");let Q="";for(let W=0;W<J.length;W++)Q+=rQ[J[W]];return Q},g0=function(J){if(typeof J!="bigint")throw Error("Expected bigint");if(!(f<=J&&J<nQ))throw Error("Expected number 0 <= n < 2^256");return J.toString(16).padStart(64,"0")},h1=function(J){const Q=y0(g0(J));if(Q.length!==32)throw Error("Error: expected 32 bytes");return Q},E1=function(J){const Q=J.toString(16);return 1&Q.length?"0"+Q:Q},C8=function(J){if(typeof J!="string")throw new TypeError("hexToNumber: expected string, got "+typeof J);return BigInt("0x"+J)},y0=function(J){if(typeof J!="string")throw new TypeError("hexToBytes: expected string, got "+typeof J);if(J.length%2)throw Error("hexToBytes: received invalid unpadded hex"+J.length);const Q=new Uint8Array(J.length/2);for(let W=0;W<Q.length;W++){const G=2*W,V=J.slice(G,G+2),q=Number.parseInt(V,16);if(Number.isNaN(q)||q<0)throw Error("Invalid byte sequence");Q[W]=q}return Q},U0=function(J){return C8(K1(J))},a0=function(J){return J instanceof Uint8Array?Uint8Array.from(J):y0(J)},e5=function(J){if(typeof J=="number"&&Number.isSafeInteger(J)&&J>0)return BigInt(J);if(typeof J=="bigint"&&b1(J))return J;throw new TypeError("Expected valid private scalar: 0 < scalar < curve.n")},C=function(J,Q=c.P){const W=J%Q;return W>=f?W:Q+W},X0=function(J,Q){const{P:W}=c;let G=J;for(;Q-- >f;)G*=G,G%=W;return G},B8=function(J,Q=c.P){if(J===f||Q<=f)throw Error(`invert: expected positive integers, got n=${J} mod=${Q}`);let W=C(J,Q),G=Q,V=f,q=_;for(;W!==f;){const Y=G%W,X=V-q*(G/W);G=W,W=Y,V=q,q=X}if(G!==_)throw Error("invert: does not exist");return C(V,Q)},b1=function(J){return f<J&&J<c.n},H8=function(J){return f<J&&J<c.P},u1=function(J){let Q;if(typeof J=="bigint")Q=J;else if(typeof J=="number"&&Number.isSafeInteger(J)&&J>0)Q=BigInt(J);else if(typeof J=="string"){if(J.length!==64)throw Error("Expected 32 bytes of private key");Q=C8(J)}else{if(!(J instanceof Uint8Array))throw new TypeError("Expected valid private key");if(J.length!==iQ)throw Error("Expected 32 bytes of private key");Q=U0(J)}if(!b1(Q))throw Error("Expected private key: 0 < key < n");return Q},oQ=function(J){return J instanceof u?(J.assertValidity(),J):u.fromHex(J)},M8=function(J){return C(U0(J),c.n)},UJ=function(J,Q,W){const G=J instanceof z1,V=G?J:z1.fromHex(J);return G&&V.assertValidity(),{...V,m:a0(Q),P:oQ(W)}},PJ=function(J,Q,W,G){const V=u.BASE.multiplyAndAddUnsafe(Q,u1(W),C(-G,c.n));return!(!V||!V.hasEvenY()||V.x!==J)};async function KJ(J,Q,W){try{const{r:G,s:V,m:q,P:Y}=UJ(J,Q,W),X=M8(await P0.taggedHash(S0.challenge,h1(G),Y.toRawX(),q));return PJ(G,Y,V,X)}catch(G){return!1}}var FJ=function(J,Q,W){try{const{r:G,s:V,m:q,P:Y}=UJ(J,Q,W),X=M8(P0.taggedHashSync(S0.challenge,h1(G),Y.toRawX(),q));return PJ(G,Y,V,X)}catch(G){if(G instanceof P6)throw G;return!1}},_Q=Object.freeze({__proto__:null,default:{}}),f=BigInt(0),_=BigInt(1),T0=BigInt(2),f1=BigInt(3),r5=BigInt(8),c=Object.freeze({a:f,b:BigInt(7),P:BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),n:BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),h:_,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee")}),n5=(J,Q)=>(J+Q/T0)/Q,X8={beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar(J){const{n:Q}=c,W=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),G=-_*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),V=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),q=W,Y=BigInt("0x100000000000000000000000000000000"),X=n5(q*J,Q),K=n5(-G*J,Q);let U=C(J-X*W-K*V,Q),P=C(-X*G-K*q,Q);const Z=U>Y,z=P>Y;if(Z&&(U=Q-U),z&&(P=Q-P),U>Y||P>Y)throw Error("splitScalarEndo: Endomorphism failed, k="+J);return{k1neg:Z,k1:U,k2neg:z,k2:P}}},lQ=32,iQ=32,U8=c.a===f;class P6 extends Error{constructor(J){super(J)}}class p{constructor(J,Q,W){this.x=J,this.y=Q,this.z=W}static fromAffine(J){if(!(J instanceof u))throw new TypeError("JacobianPoint#fromAffine: expected Point");return J.equals(u.ZERO)?p.ZERO:new p(J.x,J.y,_)}static toAffineBatch(J){const Q=function(W,G=c.P){const V=Array(W.length),q=B8(W.reduce((Y,X,K)=>X===f?Y:(V[K]=Y,C(Y*X,G)),_),G);return W.reduceRight((Y,X,K)=>X===f?Y:(V[K]=C(Y*V[K],G),C(Y*X,G)),q),V}(J.map((W)=>W.z));return J.map((W,G)=>W.toAffine(Q[G]))}static normalizeZ(J){return p.toAffineBatch(J).map(p.fromAffine)}equals(J){a5(J);const{x:Q,y:W,z:G}=this,{x:V,y:q,z:Y}=J,X=C(G*G),K=C(Y*Y),U=C(Q*K),P=C(V*X),Z=C(C(W*Y)*K),z=C(C(q*G)*X);return U===P&&Z===z}negate(){return new p(this.x,C(-this.y),this.z)}double(){const{x:J,y:Q,z:W}=this,G=C(J*J),V=C(Q*Q),q=C(V*V),Y=J+V,X=C(T0*(C(Y*Y)-G-q)),K=C(f1*G),U=C(K*K),P=C(U-T0*X),Z=C(K*(X-P)-r5*q),z=C(T0*Q*W);return new p(P,Z,z)}add(J){a5(J);const{x:Q,y:W,z:G}=this,{x:V,y:q,z:Y}=J;if(V===f||q===f)return this;if(Q===f||W===f)return J;const X=C(G*G),K=C(Y*Y),U=C(Q*K),P=C(V*X),Z=C(C(W*Y)*K),z=C(C(q*G)*X),F=C(P-U),H=C(z-Z);if(F===f)return H===f?this.double():p.ZERO;const R=C(F*F),M=C(F*R),x=C(U*R),N=C(H*H-M-T0*x),O=C(H*(x-N)-Z*M),$=C(G*Y*F);return new p(N,O,$)}subtract(J){return this.add(J.negate())}multiplyUnsafe(J){const Q=p.ZERO;if(typeof J=="bigint"&&J===f)return Q;let W=e5(J);if(W===_)return this;if(!U8){let P=Q,Z=this;for(;W>f;)W&_&&(P=P.add(Z)),Z=Z.double(),W>>=_;return P}let{k1neg:G,k1:V,k2neg:q,k2:Y}=X8.splitScalar(W),X=Q,K=Q,U=this;for(;V>f||Y>f;)V&_&&(X=X.add(U)),Y&_&&(K=K.add(U)),U=U.double(),V>>=_,Y>>=_;return G&&(X=X.negate()),q&&(K=K.negate()),K=new p(C(K.x*X8.beta),K.y,K.z),X.add(K)}precomputeWindow(J){const Q=U8?128/J+1:256/J+1,W=[];let G=this,V=G;for(let q=0;q<Q;q++){V=G,W.push(V);for(let Y=1;Y<2**(J-1);Y++)V=V.add(G),W.push(V);G=V.double()}return W}wNAF(J,Q){!Q&&this.equals(p.BASE)&&(Q=u.BASE);const W=Q&&Q._WINDOW_SIZE||1;if(256%W)throw Error("Point#wNAF: Invalid precomputation window, must be power of 2");let G=Q&&G6.get(Q);G||(G=this.precomputeWindow(W),Q&&W!==1&&(G=p.normalizeZ(G),G6.set(Q,G)));let{ZERO:V,BASE:q}=p;const Y=1+(U8?128/W:256/W),X=2**(W-1),K=BigInt(2**W-1),U=2**W,P=BigInt(W);for(let Z=0;Z<Y;Z++){const z=Z*X;let F=Number(J&K);J>>=P,F>X&&(F-=U,J+=_);const H=z,R=z+Math.abs(F)-1,M=Z%2!=0,x=F<0;F===0?q=q.add(P8(M,G[H])):V=V.add(P8(x,G[R]))}return{p:V,f:q}}multiply(J,Q){let W,G,V=e5(J);if(U8){const{k1neg:q,k1:Y,k2neg:X,k2:K}=X8.splitScalar(V);let{p:U,f:P}=this.wNAF(Y,Q),{p:Z,f:z}=this.wNAF(K,Q);U=P8(q,U),Z=P8(X,Z),Z=new p(C(Z.x*X8.beta),Z.y,Z.z),W=U.add(Z),G=P.add(z)}else{const{p:q,f:Y}=this.wNAF(V,Q);W=q,G=Y}return p.normalizeZ([W,G])[0]}toAffine(J){const{x:Q,y:W,z:G}=this,V=this.equals(p.ZERO);J==null&&(J=V?r5:B8(G));const q=J,Y=C(q*q),X=C(Y*q),K=C(Q*Y),U=C(W*X),P=C(G*q);if(V)return u.ZERO;if(P!==_)throw Error("invZ was invalid");return new u(K,U)}}p.BASE=new p(c.Gx,c.Gy,_),p.ZERO=new p(f,_,f);var G6=new WeakMap;class u{constructor(J,Q){this.x=J,this.y=Q}_setWindowSize(J){this._WINDOW_SIZE=J,G6.delete(this)}hasEvenY(){return this.y%T0===f}static fromCompressedHex(J){const Q=J.length===32,W=U0(Q?J:J.subarray(1));if(!H8(W))throw Error("Point is not on curve");let G=function(Y){const{P:X}=c,K=BigInt(6),U=BigInt(11),P=BigInt(22),Z=BigInt(23),z=BigInt(44),F=BigInt(88),H=Y*Y*Y%X,R=H*H*Y%X,M=X0(R,f1)*R%X,x=X0(M,f1)*R%X,N=X0(x,T0)*H%X,O=X0(N,U)*N%X,$=X0(O,P)*O%X,v=X0($,z)*$%X,h=X0(v,F)*v%X,j=X0(h,z)*$%X,g=X0(j,f1)*R%X,w=X0(g,Z)*O%X,I=X0(w,K)*H%X,k=X0(I,T0);if(k*k%X!==Y)throw Error("Cannot find square root");return k}(o5(W));const V=(G&_)===_;if(Q)V&&(G=C(-G));else!(1&~J[0])!==V&&(G=C(-G));const q=new u(W,G);return q.assertValidity(),q}static fromUncompressedHex(J){const Q=U0(J.subarray(1,33)),W=U0(J.subarray(33,65)),G=new u(Q,W);return G.assertValidity(),G}static fromHex(J){const Q=a0(J),W=Q.length,G=Q[0];if(W===lQ)return this.fromCompressedHex(Q);if(W===33&&(G===2||G===3))return this.fromCompressedHex(Q);if(W===65&&G===4)return this.fromUncompressedHex(Q);throw Error("Point.fromHex: received invalid point. Expected 32-33 compressed bytes or 65 uncompressed bytes, not "+W)}static fromPrivateKey(J){return u.BASE.multiply(u1(J))}static fromSignature(J,Q,W){const{r:G,s:V}=function(H){if(H instanceof n0)return H.assertValidity(),H;try{return n0.fromDER(H)}catch(R){return n0.fromCompact(H)}}(Q);if(![0,1,2,3].includes(W))throw Error("Cannot recover: invalid recovery bit");const q=function(H,R=!1){const M=function(N){const O=8*N.length-256,$=U0(N);return O>0?$>>BigInt(O):$}(H);if(R)return M;const{n:x}=c;return M>=x?M-x:M}(a0(J)),{n:Y}=c,X=W===2||W===3?G+Y:G,K=B8(X,Y),U=C(-q*K,Y),P=C(V*K,Y),Z=1&W?"03":"02",z=u.fromHex(Z+g0(X)),F=u.BASE.multiplyAndAddUnsafe(z,U,P);if(!F)throw Error("Cannot recover signature: point at infinify");return F.assertValidity(),F}toRawBytes(J=!1){return y0(this.toHex(J))}toHex(J=!1){const Q=g0(this.x);if(J)return`${this.hasEvenY()?"02":"03"}${Q}`;return`04${Q}${g0(this.y)}`}toHexX(){return this.toHex(!0).slice(2)}toRawX(){return this.toRawBytes(!0).slice(1)}assertValidity(){const{x:Q,y:W}=this;if(!H8(Q)||!H8(W))throw Error("Point is not on elliptic curve");const G=C(W*W);if(C(G-o5(Q))!==f)throw Error("Point is not on elliptic curve")}equals(J){return this.x===J.x&&this.y===J.y}negate(){return new u(this.x,C(-this.y))}double(){return p.fromAffine(this).double().toAffine()}add(J){return p.fromAffine(this).add(p.fromAffine(J)).toAffine()}subtract(J){return this.add(J.negate())}multiply(J){return p.fromAffine(this).multiply(J,this).toAffine()}multiplyAndAddUnsafe(J,Q,W){const G=p.fromAffine(this),V=Q===f||Q===_||this!==u.BASE?G.multiplyUnsafe(Q):G.multiply(Q),q=p.fromAffine(J).multiplyUnsafe(W),Y=V.add(q);return Y.equals(p.ZERO)?void 0:Y.toAffine()}}u.BASE=new u(c.Gx,c.Gy),u.ZERO=new u(f,f);class n0{constructor(J,Q){this.r=J,this.s=Q,this.assertValidity()}static fromCompact(J){const Q=J instanceof Uint8Array;if(typeof J!="string"&&!Q)throw new TypeError("Signature.fromCompact: Expected string or Uint8Array");const G=Q?K1(J):J;if(G.length!==128)throw Error("Signature.fromCompact: Expected 64-byte hex");return new n0(C8(G.slice(0,64)),C8(G.slice(64,128)))}static fromDER(J){const Q=J instanceof Uint8Array;if(typeof J!="string"&&!Q)throw new TypeError("Signature.fromDER: Expected string or Uint8Array");const{r:W,s:G}=function(V){if(V.length<2||V[0]!=48)throw Error("Invalid signature tag: "+K1(V));if(V[1]!==V.length-2)throw Error("Invalid signature: incorrect length");const{data:q,left:Y}=t5(V.subarray(2)),{data:X,left:K}=t5(Y);if(K.length)throw Error("Invalid signature: left bytes after parsing: "+K1(K));return{r:q,s:X}}(Q?J:y0(J));return new n0(W,G)}static fromHex(J){return this.fromDER(J)}assertValidity(){const{r:J,s:Q}=this;if(!b1(J))throw Error("Invalid Signature: r must be 0 < r < n");if(!b1(Q))throw Error("Invalid Signature: s must be 0 < s < n")}hasHighS(){const J=c.n>>_;return this.s>J}normalizeS(){return this.hasHighS()?new n0(this.r,C(-this.s,c.n)):this}toDERRawBytes(){return y0(this.toDERHex())}toDERHex(){const J=s5(E1(this.s)),Q=s5(E1(this.r)),W=J.length/2,G=Q.length/2,V=E1(W),q=E1(G);return`30${E1(G+W+4)}02${q}${Q}02${V}${J}`}toRawBytes(){return this.toDERRawBytes()}toHex(){return this.toDERHex()}toCompactRawBytes(){return y0(this.toCompactHex())}toCompactHex(){return g0(this.r)+g0(this.s)}}var rQ=Array.from({length:256},(J,Q)=>Q.toString(16).padStart(2,"0")),nQ=BigInt("0x10000000000000000000000000000000000000000000000000000000000000000"),F1,Q6;class z1{constructor(J,Q){this.r=J,this.s=Q,this.assertValidity()}static fromHex(J){const Q=a0(J);if(Q.length!==64)throw new TypeError("SchnorrSignature.fromHex: expected 64 bytes, not "+Q.length);const W=U0(Q.subarray(0,32)),G=U0(Q.subarray(32,64));return new z1(W,G)}assertValidity(){const{r:J,s:Q}=this;if(!H8(J)||!b1(Q))throw Error("Invalid signature")}toHex(){return g0(this.r)+g0(this.s)}toRawBytes(){return y0(this.toHex())}}class V6{constructor(J,Q,W=P0.randomBytes()){if(J==null)throw new TypeError(`sign: Expected valid message, not "${J}"`);this.m=a0(J);const{x:G,scalar:V}=this.getScalar(u1(Q));if(this.px=G,this.d=V,this.rand=a0(W),this.rand.length!==32)throw new TypeError("sign: Expected 32 bytes of aux randomness")}getScalar(J){const Q=u.fromPrivateKey(J),W=Q.hasEvenY()?J:c.n-J;return{point:Q,scalar:W,x:Q.toRawX()}}initNonce(J,Q){return h1(J^U0(Q))}finalizeNonce(J){const Q=C(U0(J),c.n);if(Q===f)throw Error("sign: Creation of signature failed. k is zero");const{point:W,x:G,scalar:V}=this.getScalar(Q);return{R:W,rx:G,k:V}}finalizeSig(J,Q,W,G){return new z1(J.x,C(Q+W*G,c.n)).toRawBytes()}error(){throw Error("sign: Invalid signature produced")}async calc(){const{m:J,d:Q,px:W,rand:G}=this,V=P0.taggedHash,q=this.initNonce(Q,await V(S0.aux,G)),{R:Y,rx:X,k:K}=this.finalizeNonce(await V(S0.nonce,q,W,J)),U=M8(await V(S0.challenge,X,W,J)),P=this.finalizeSig(Y,K,U,Q);return await KJ(P,J,W)||this.error(),P}calcSync(){const{m:J,d:Q,px:W,rand:G}=this,V=P0.taggedHashSync,q=this.initNonce(Q,V(S0.aux,G)),{R:Y,rx:X,k:K}=this.finalizeNonce(V(S0.nonce,q,W,J)),U=M8(V(S0.challenge,X,W,J)),P=this.finalizeSig(Y,K,U,Q);return FJ(P,J,W)||this.error(),P}}var zJ={Signature:z1,getPublicKey(J){return u.fromPrivateKey(J).toRawX()},async sign(J,Q,W){return new V6(J,Q,W).calc()},verify:KJ,signSync(J,Q,W){return new V6(J,Q,W).calcSync()},verifySync:FJ};u.BASE._setWindowSize(8);var G0={node:_Q,web:typeof self=="object"&&("crypto"in self)?self.crypto:void 0},S0={challenge:"BIP0340/challenge",aux:"BIP0340/aux",nonce:"BIP0340/nonce"},K8={},P0={bytesToHex:K1,hexToBytes:y0,concatBytes:y1,mod:C,invert:B8,isValidPrivateKey(J){try{return u1(J),!0}catch(Q){return!1}},_bigintTo32Bytes:h1,_normalizePrivateKey:u1,hashToPrivateKey(J){if((J=a0(J)).length<40||J.length>1024)throw Error("Expected valid bytes of private key as per FIPS 186");return h1(C(U0(J),c.n-_)+_)},randomBytes(J=32){if(G0.web)return G0.web.getRandomValues(new Uint8Array(J));if(G0.node){const{randomBytes:Q}=G0.node;return Uint8Array.from(Q(J))}throw Error("The environment doesn't have randomBytes function")},randomPrivateKey(){return P0.hashToPrivateKey(P0.randomBytes(40))},precompute(J=8,Q=u.BASE){const W=Q===u.BASE?Q:new u(Q.x,Q.y);return W._setWindowSize(J),W.multiply(f1),W},async sha256(...J){if(G0.web){const Q=await G0.web.subtle.digest("SHA-256",y1(...J));return new Uint8Array(Q)}if(G0.node){const{createHash:Q}=G0.node,W=Q("sha256");return J.forEach((G)=>W.update(G)),Uint8Array.from(W.digest())}throw Error("The environment doesn't have sha256 function")},async hmacSha256(J,...Q){if(G0.web){const W=await G0.web.subtle.importKey("raw",J,{name:"HMAC",hash:{name:"SHA-256"}},!1,["sign"]),G=y1(...Q),V=await G0.web.subtle.sign("HMAC",W,G);return new Uint8Array(V)}if(G0.node){const{createHmac:W}=G0.node,G=W("sha256",J);return Q.forEach((V)=>G.update(V)),Uint8Array.from(G.digest())}throw Error("The environment doesn't have hmac-sha256 function")},sha256Sync:void 0,hmacSha256Sync:void 0,async taggedHash(J,...Q){let W=K8[J];if(W===void 0){const G=await P0.sha256(Uint8Array.from(J,(V)=>V.charCodeAt(0)));W=y1(G,G),K8[J]=W}return P0.sha256(W,...Q)},taggedHashSync(J,...Q){if(typeof F1!="function")throw new P6("sha256Sync is undefined, you need to set it");let W=K8[J];if(W===void 0){const G=F1(Uint8Array.from(J,(V)=>V.charCodeAt(0)));W=y1(G,G),K8[J]=W}return F1(W,...Q)},_JacobianPoint:p};Object.defineProperties(P0,{sha256Sync:{configurable:!1,get:()=>F1,set(J){F1||(F1=J)}},hmacSha256Sync:{configurable:!1,get:()=>Q6,set(J){Q6||(Q6=J)}}});var{floor:q6,random:aQ,sin:sQ}=Math,m1="GenosRTC",d1=(J,Q)=>Array(J).fill().map(Q),tQ="0123456789AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz",Y6=(J)=>d1(J,()=>tQ[q6(62*aQ())]).join(""),U1=Y6(20),r0=Promise.all.bind(Promise),eQ=typeof window!="undefined",{entries:X6,fromEntries:ZJ,keys:J9}=Object,i0=()=>{},x0=(J)=>Error(`${m1}: ${J}`),W9=new TextEncoder,Q9=new TextDecoder,o0=(J)=>W9.encode(J),$8=(J)=>Q9.decode(J),U6=(J)=>J.reduce((Q,W)=>Q+W.toString(16).padStart(2,"0"),""),F8=(...J)=>J.join("@"),G9=(J,Q,W)=>(J.relayUrls||((G,V)=>{const q=[...G],Y=()=>{const K=1e4*sQ(V++);return K-q6(K)};let X=q.length;for(;X;){const K=q6(Y()*X--);[q[X],q[K]]=[q[K],q[X]]}return q})(Q,kJ(J.appId))).slice(0,J.relayUrls?J.relayUrls.length:J.relayRedundancy||W),O0=JSON.stringify,j8=JSON.parse,kJ=(J,Q=Number.MAX_SAFE_INTEGER)=>J.split("").reduce((W,G)=>W+G.charCodeAt(0),0)%Q,z8={},K6="AES-GCM",V9={},Z8=async(J)=>V9[J]||=Array.from(new Uint8Array(await crypto.subtle.digest("SHA-1",o0(J)))).map((Q)=>Q.toString(36)).join(""),q9=async(J,Q)=>{const W=crypto.getRandomValues(new Uint8Array(16));return W.join(",")+"$"+(G=await crypto.subtle.encrypt({name:K6,iv:W},await J,o0(Q)),btoa(String.fromCharCode.apply(null,new Uint8Array(G))));var G},Y9=async(J,Q)=>{const[W,G]=Q.split("$");return $8(await crypto.subtle.decrypt({name:K6,iv:new Uint8Array(W.split(","))},await J,((V)=>{const q=atob(V);return new Uint8Array(q.length).map((Y,X)=>q.charCodeAt(X)).buffer})(G)))},JJ="icegatheringstatechange",WJ="offer",QJ=(J,{rtcConfig:Q,rtcPolyfill:W,turnConfig:G})=>{const V=new(W||RTCPeerConnection)({iceServers:X9.concat(G||[]),...Q}),q={};let Y=!1,X=!1,K=null;const U=(Z)=>{Z.binaryType="arraybuffer",Z.bufferedAmountLowThreshold=65535,Z.onmessage=(z)=>q.data?.(z.data),Z.onopen=()=>q.connect?.(),Z.onclose=()=>q.close?.(),Z.onerror=(z)=>{z?.error?.message?.includes("User-Initiated Abort")||q.error?.(z)}},P=(Z)=>Promise.race([new Promise((z)=>{const F=()=>{Z.iceGatheringState==="complete"&&(Z.removeEventListener(JJ,F),z())};Z.addEventListener(JJ,F),F()}),new Promise((z)=>setTimeout(z,5000))]).then(()=>({type:Z.localDescription.type,sdp:Z.localDescription.sdp.replace(/a=ice-options:trickle\s\n/g,"")}));return J?(K=V.createDataChannel("data"),U(K)):V.ondatachannel=({channel:Z})=>{K=Z,U(Z)},V.onnegotiationneeded=async()=>{try{Y=!0,await V.setLocalDescription();const Z=await P(V);q.signal?.(Z)}catch(Z){q.error?.(Z)}finally{Y=!1}},V.onconnectionstatechange=()=>{["disconnected","failed","closed"].includes(V.connectionState)&&q.close?.()},V.ontrack=(Z)=>{q.track?.(Z.track,Z.streams[0]),q.stream?.(Z.streams[0])},V.onremovestream=(Z)=>q.stream?.(Z.stream),J&&(V.canTrickleIceCandidates||V.onnegotiationneeded()),{created:Date.now(),connection:V,get channel(){return K},get isDead(){return V.connectionState==="closed"},async signal(Z){if(K?.readyState!=="open"||Z.sdp?.includes("a=rtpmap"))try{if(Z.type===WJ){if(Y||V.signalingState!=="stable"&&!X){if(J)return;await r0([V.setLocalDescription({type:"rollback"}),V.setRemoteDescription(Z)])}else await V.setRemoteDescription(Z);await V.setLocalDescription();const z=await P(V);return q.signal?.(z),z}if(Z.type==="answer"){X=!0;try{await V.setRemoteDescription(Z)}finally{X=!1}}}catch(z){q.error?.(z)}},sendData(Z){return K.send(Z)},destroy(){K?.close(),V.close(),Y=!1,X=!1},setHandlers(Z){return Object.assign(q,Z)},offerPromise:J?new Promise((Z)=>q.signal=(z)=>{z.type===WJ&&Z(z)}):Promise.resolve(),addStream(Z){return Z.getTracks().forEach((z)=>V.addTrack(z,Z))},removeStream(Z){return V.getSenders().filter((z)=>Z.getTracks().includes(z.track)).forEach((z)=>V.removeTrack(z))},addTrack(Z,z){return V.addTrack(Z,z)},removeTrack(Z){const z=V.getSenders().find((F)=>F.track===Z);z&&V.removeTrack(z)},replaceTrack(Z,z){const F=V.getSenders().find((H)=>H.track===Z);if(F)return F.replaceTrack(z)}}},X9=[...d1(3,(J,Q)=>`stun:stun${Q||""}.l.google.com:19302`),"stun:stun.cloudflare.com:3478"].map((J)=>({urls:J})),U9=Object.getPrototypeOf(Uint8Array),l0=16369,k8=255,GJ="bufferedamountlow",P1=(J)=>"@_"+J,P9=(J,Q,W)=>{const G={},V={},q={},Y={},X={},K={},U={},P={onPeerJoin:i0,onPeerLeave:i0,onPeerStream:i0,onPeerTrack:i0},Z=(k,L)=>(k?Array.isArray(k)?k:[k]:J9(G)).flatMap((y)=>{const D=G[y];return D?L(y,D):(console.warn(`${m1}: no peer with id ${y} found`),[])}),z=(k)=>{G[k]&&(delete G[k],delete Y[k],delete X[k],P.onPeerLeave(k),Q(k))},F=(k)=>{if(V[k])return q[k];if(!k)throw x0("action type argument is required");const L=o0(k);if(L.byteLength>12)throw x0(`action type string "${k}" (${L.byteLength}b) exceeds byte limit (12). Hint: choose a shorter name.`);const y=new Uint8Array(12);y.set(L);let D=0;return V[k]={onComplete:i0,onProgress:i0,setOnComplete(B){return V[k]={...V[k],onComplete:B}},setOnProgress(B){return V[k]={...V[k],onProgress:B}},async send(B,A,S,e){if(S&&typeof S!="object")throw x0("action meta argument must be an object");const i=typeof B;if(i==="undefined")throw x0("action data cannot be undefined");const C0=i!=="string",b=B instanceof Blob,B0=b||B instanceof ArrayBuffer||B instanceof U9;if(S&&!B0)throw x0("action meta argument can only be used with binary data");const K0=B0?new Uint8Array(b?await B.arrayBuffer():B):o0(C0?O0(B):B),F0=S?o0(O0(S)):null,n=Math.ceil(K0.byteLength/l0)+(S?1:0)||1,l=d1(n,(V0,m)=>{const o=m===n-1,z0=S&&m===0,M0=new Uint8Array(15+(z0?F0.byteLength:o?K0.byteLength-l0*(n-(S?2:1)):l0));return M0.set(y),M0.set([D],12),M0.set([o|z0<<1|B0<<2|C0<<3],13),M0.set([Math.round((m+1)/n*k8)],14),M0.set(S?z0?F0:K0.subarray((m-1)*l0,m*l0):K0.subarray(m*l0,(m+1)*l0),15),M0});return D=D+1&k8,r0(Z(A,async(V0,m)=>{const{channel:o}=m;let z0=0;for(;z0<n;){const M0=l[z0];if(o.bufferedAmount>o.bufferedAmountLowThreshold&&await new Promise((OJ)=>{const B6=()=>{o.removeEventListener(GJ,B6),OJ()};o.addEventListener(GJ,B6)}),!G[V0])break;m.sendData(M0),z0++,e?.(M0[14]/k8,V0,S)}}))}},q[k]||=[V[k].send,V[k].setOnComplete,V[k].setOnProgress]},H=async()=>{await w(""),await new Promise((k)=>setTimeout(k,99)),X6(G).forEach(([k,L])=>{L.destroy(),delete G[k]}),W()},[R,M]=F(P1("ping")),[x,N]=F(P1("pong")),[O,$]=F(P1("signal")),[v,h]=F(P1("stream")),[j,g]=F(P1("track")),[w,I]=F(P1("leave"));return J((k,L)=>{G[L]||(G[L]=k,k.setHandlers({data(y){return((D,B)=>{const A=new Uint8Array(B),S=$8(A.subarray(0,12)).replaceAll("\0",""),[e]=A.subarray(12,13),[i]=A.subarray(13,14),[C0]=A.subarray(14,15),b=A.subarray(15),B0=!!(1&i),K0=!!(2&i),F0=!!(4&i),n=!!(8&i);if(!V[S])return void console.warn(`${m1}: received message with unregistered type (${S})`);Y[D]||={},Y[D][S]||={};const l=Y[D][S][e]||={chunks:[]};if(K0?l.meta=j8($8(b)):l.chunks.push(b),V[S].onProgress(C0/k8,D,l.meta),!B0)return;const V0=new Uint8Array(l.chunks.reduce((m,o)=>m+o.byteLength,0));if(l.chunks.reduce((m,o)=>(V0.set(o,m),m+o.byteLength),0),delete Y[D][S][e],F0)V[S].onComplete(V0,D,l.meta);else{const m=$8(V0);V[S].onComplete(n?j8(m):m,D)}})(L,y)},stream(y){P.onPeerStream(y,L,K[L]),delete K[L]},track(y,D){P.onPeerTrack(y,D,L,U[L]),delete U[L]},signal(y){return O(y,L)},close(){return z(L)},error(y){console.error(y),z(L)}}),P.onPeerJoin(L))}),M((k,L)=>x("",L)),N((k,L)=>{X[L]?.(),delete X[L]}),$((k,L)=>G[L]?.signal(k)),h((k,L)=>K[L]=k),g((k,L)=>U[L]=k),I((k,L)=>z(L)),eQ&&addEventListener("beforeunload",H),{makeAction:F,leave:H,async ping(k){if(!k)throw x0("ping() must be called with target peer ID");const L=Date.now();return R("",k),await new Promise((y)=>X[k]=y),Date.now()-L},getPeers(){return ZJ(X6(G).map(([k,L])=>[k,L.connection]))},addStream(k,L,y){return Z(L,async(D,B)=>{y&&await v(y,D),B.addStream(k)})},removeStream(k,L){return Z(L,(y,D)=>D.removeStream(k))},addTrack(k,L,y,D){return Z(y,async(B,A)=>{D&&await j(D,B),A.addTrack(k,L)})},removeTrack(k,L){return Z(L,(y,D)=>D.removeTrack(k))},replaceTrack(k,L,y,D){return Z(y,async(B,A)=>{D&&await j(D,B),A.replaceTrack(k,L)})},onPeerJoin(k){return P.onPeerJoin=k},onPeerLeave(k){return P.onPeerLeave=k},onPeerStream(k){return P.onPeerStream=k},onPeerTrack(k){return P.onPeerTrack=k}}},HJ={},$J="EVENT",CJ=P0.randomPrivateKey(),K9=U6(zJ.getPublicKey(CJ)),F6={},p1={},F9={},BJ=()=>Math.floor(Date.now()/1000),MJ=(J)=>F9[J]??=kJ(J,1e4)+20000,VJ=async(J,Q)=>{const W={kind:MJ(J),content:Q,pubkey:K9,created_at:BJ(),tags:[["x",J]]},G=U6(new Uint8Array(await crypto.subtle.digest("SHA-256",o0(O0([0,W.pubkey,W.created_at,W.kind,W.tags,W.content])))));return O0([$J,{...W,id:G,sig:U6(await zJ.sign(G,CJ))}])},qJ=(J,Q)=>(F6[J]=Q,O0(["REQ",J,{kinds:[MJ(Q)],since:BJ(),"#x":[Q]}])),YJ=(J)=>(delete F6[J],O0(["CLOSE",J])),z6=(({init:J,subscribe:Q,announce:W})=>{const G={};let V,q,Y,X=!1;return(K,U,P)=>{const{appId:Z}=K;if(G[Z]?.[U])return G[Z][U];const z={},F={},H=F8(m1,Z,U),R=Z8(H),M=Z8(F8(H,U1)),x=(async(B,A,S)=>crypto.subtle.importKey("raw",await crypto.subtle.digest({name:"SHA-256"},o0(`${B}:${A}:${S}`)),{name:K6},!1,["encrypt","decrypt"]))(K.password||"",Z,U),N=(B)=>async(A)=>({type:A.type,sdp:await B(x,A.sdp)}),O=N(Y9),$=N(q9),v=()=>QJ(!0,K),h=(B,A,S)=>{F[A]?F[A]!==B&&B.destroy():(F[A]=B,D(B,A),z[A]?.forEach((e,i)=>{i!==S&&e.destroy()}),delete z[A])},j=(B,A)=>{F[A]===B&&delete F[A]},g=(B)=>(q.push(...d1(B,v)),r0(q.splice(0,B).map((A)=>A.offerPromise.then($).then((S)=>({peer:A,offer:S}))))),w=(B,A)=>P?.({error:`incorrect password (${K.password}) when decrypting ${A}`,appId:Z,peerId:B,roomId:U}),I=(B)=>async(A,S,e)=>{const[i,C0]=await r0([R,M]);if(A!==i&&A!==C0)return;const{peerId:b,offer:B0,answer:K0,peer:F0}=typeof S=="string"?j8(S):S;if(b!==U1&&!F[b])if(!b||B0||K0){if(B0){if(z[b]?.[B]&&U1>b)return;const l=QJ(!1,K);let V0;l.setHandlers({connect(){return h(l,b,B)},close(){return j(l,b)}});try{V0=await O(B0)}catch{return void w(b,"offer")}if(l.isDead)return;const[m,o]=await r0([Z8(F8(H,b)),l.signal(V0)]);e(m,O0({peerId:U1,answer:await $(o)}))}else if(K0){let n;try{n=await O(K0)}catch(l){return void w(b,"answer")}if(F0)F0.setHandlers({connect(){return h(F0,b,B)},close(){return j(F0,b)}}),F0.signal(n);else{const l=z[b]?.[B];l&&!l.isDead&&l.signal(n)}}}else{if(z[b]?.[B])return;const[[{peer:n,offer:l}],V0]=await r0([g(1),Z8(F8(H,b))]);z[b]||=[],z[b][B]=n,setTimeout(()=>((m,o)=>{if(F[m])return;const z0=z[m]?.[o];z0&&(delete z[m][o],z0.destroy())})(b,B),0.9*k[B]),n.setHandlers({connect(){return h(n,b,B)},close(){return j(n,b)}}),e(V0,O0({peerId:U1,offer:l}))}};if(!K)throw x0("requires a config map as the first argument");if(!Z&&!K.firebaseApp)throw x0("config map is missing appId field");if(!U)throw x0("roomId argument required");if(!X){const B=J(K);q=d1(20,v),V=Array.isArray(B)?B:[B],X=!0,Y=setInterval(()=>q=q.filter((A)=>{const S=Date.now()-A.created<57333;return S||A.destroy(),S}),59052.99)}const k=V.map(()=>5333),L=[],y=V.map(async(B,A)=>Q(await B,await R,await M,I(A),g));r0([R,M]).then(([B,A])=>{const S=async(e,i)=>{const C0=await W(e,B,A);typeof C0=="number"&&(k[i]=C0),L[i]=setTimeout(()=>S(e,i),k[i])};y.forEach(async(e,i)=>{await e,S(await V[i],i)})});let D=i0;return G[Z]||={},G[Z][U]=P9((B)=>D=B,(B)=>delete F[B],()=>{delete G[Z][U],L.forEach(clearTimeout),y.forEach(async(B)=>(await B)()),clearInterval(Y)})}})({init(J){return G9(J,z9,5).map((Q)=>{const W=((G,V)=>{const q={},Y=()=>{const X=new WebSocket(G);X.onclose=()=>{z8[G]??=3333,setTimeout(Y,z8[G]),z8[G]*=2},X.onmessage=(K)=>V(K.data),q.socket=X,q.url=X.url,q.ready=new Promise((K)=>X.onopen=()=>{K(q),z8[G]=3333}),q.send=(K)=>{X.readyState===1&&X.send(K)}};return Y(),q})(Q,(G)=>{const[V,q,Y,X]=j8(G);if(V===$J)p1[q]?.(F6[q],Y.content);else{const K=`${m1}: relay failure from ${W.url} - `;V==="NOTICE"?console.warn(K+q):V!=="OK"||Y||console.warn(K+X)}});return HJ[Q]=W,W.ready})},subscribe(J,Q,W,G){const V=Y6(64),q=Y6(64);return p1[V]=p1[q]=(Y,X)=>G(Y,X,async(K,U)=>J.send(await VJ(K,U))),J.send(qJ(V,Q)),J.send(qJ(q,W)),()=>{J.send(YJ(V)),J.send(YJ(q)),delete p1[V],delete p1[q]}},async announce(J,Q){return J.send(await VJ(Q,O0({peerId:U1})))}}),s9=(XJ=HJ,()=>ZJ(X6(XJ).map(([J,Q])=>[J,Q.socket]))),XJ,z9=["black.nostrcity.club","eu.purplerelay.com","ftp.halifax.rwth-aachen.de/nostr","nostr.cool110.xyz","nostr.data.haus","nostr.mom","nostr.oxtr.dev","nostr.sathoarder.com","nostr.vulpem.com","playground.nostrcheck.me/relay","relay.agorist.space","relay.binaryrobot.com","relay.fountain.fm","relay.mostro.network","relay.nostraddress.com","relay.nostrdice.com","relay.nostromo.social","relay.oldenburg.cool","relay.snort.social","relay.verified-nostr.com","sendit.nosflare.com","yabu.me/v2","relay.damus.io"].map((J)=>"wss://"+J);var jJ=(J,Q,W)=>{let G=Q.timestamp;if(Q.timestamp&&typeof Q.timestamp.physical==="number"){const Y=Date.now()+7200000;if(Q.timestamp.physical>Y)G={physical:Y,logical:Q.timestamp.logical}}if(!J||!J.timestamp)return{resolved:!0,value:Q.value,timestamp:G};const V=J.timestamp;if(W.compare(V,G)<0)return{resolved:!0,value:Q.value,timestamp:G};return{resolved:!1}};class Z6{constructor(J,Q=50){this.key=`gdb_oplog_${J}`,this.maxSize=Q,this.log=this._load()}_load(){try{const J=localStorage.getItem(this.key);return J?JSON.parse(J):[]}catch(J){return console.error("Failed to load oplog from localStorage:",J),[]}}_save(){try{localStorage.setItem(this.key,JSON.stringify(this.log))}catch(J){console.error("Failed to save oplog to localStorage:",J)}}add(J){if(this.log.push(J),this.log.length>this.maxSize)this.log.shift();this._save()}getDelta(J,Q){if(!J)return[...this.log];return this.log.filter((W)=>Q(W.timestamp,J)>0)}getOldest(){return this.log[0]}clear(){this.log=[],localStorage.removeItem(this.key)}}var Z9=()=>{const J=new Map,Q=async()=>{try{const K=await navigator.storage.getDirectory(),P=await(await K.getFileHandle("~opfs-sync-test",{create:!0})).createSyncAccessHandle?.();return await P?.close(),await K.removeEntry("~opfs-sync-test"),!!P}catch{return!1}};let W="idb";const G=(async()=>{if(await Q())W="sync";else try{const K=await navigator.storage.getDirectory(),P=await(await K.getFileHandle("~opfs-async-test",{create:!0})).createWritable?.();if(await P?.close(),await K.removeEntry("~opfs-async-test"),P)W="async";else W="idb"}catch{W="idb"}})(),V=async(K,U)=>{if(!J.has(K))J.set(K,[]);const P=J.get(K),Z=P[P.length-1]||Promise.resolve();let z;const F=new Promise((H)=>z=H);P.push(F);try{return await Z,await U()}finally{if(P.shift(),z(),P.length===0)J.delete(K)}},q=(()=>{let K;const U=async()=>{if(!K)K=new Promise((P,Z)=>{const z=indexedDB.open("opfs-fallback-db",1);z.onupgradeneeded=()=>z.result.createObjectStore("files"),z.onsuccess=()=>P(z.result),z.onerror=()=>Z(z.error)});return K};return{getDB:U,get:async(P)=>{const Z=await U();return new Promise((z,F)=>{const R=Z.transaction("files","readonly").objectStore("files").get(P);R.onsuccess=()=>z(R.result||new Uint8Array),R.onerror=()=>F(R.error)})},set:async(P,Z)=>{const z=await U();return new Promise((F,H)=>{const M=z.transaction("files","readwrite").objectStore("files").put(Z,P);M.onsuccess=()=>F(),M.onerror=()=>H(M.error)})}}})(),Y=async(K)=>{await G;try{if(W==="idb"){const F=await q.get(K);return{type:"loaded",name:K,data:F}}const P=await(await navigator.storage.getDirectory()).getFileHandle(K);if(W==="sync"){let F;try{F=await P.createSyncAccessHandle();const H=F.getSize(),R=new Uint8Array(H),M=F.read(R,{at:0});return{type:"loaded",name:K,data:R.slice(0,M)}}finally{F?.close()}}const Z=await P.getFile(),z=new Uint8Array(await Z.arrayBuffer());return{type:"loaded",name:K,data:z}}catch(U){const P=U.name==="NotFoundError"?"File not found":U.message||"Error reading file";return{type:"error",name:K,message:P}}},X=async(K,U)=>{if(await G,!(U instanceof Uint8Array))return{type:"error",name:K,message:"Content must be a Uint8Array"};return V(K,async()=>{try{if(W==="idb")return await q.set(K,U),{type:"saved",name:K};const Z=await(await navigator.storage.getDirectory()).getFileHandle(K,{create:!0});if(W==="sync"){let z;try{z=await Z.createSyncAccessHandle(),z.truncate(0),z.write(U,{at:0}),z.flush()}finally{z?.close()}}else{let z;try{z=await Z.createWritable(),await z.write(U)}finally{await z?.close()}}return{type:"saved",name:K}}catch(P){return{type:"error",name:K,message:P.message||"Error saving file"}}})};self.onmessage=async({data:K})=>{const{type:U,name:P,content:Z}=K;await G;const z={load:()=>Y(P),save:()=>X(P,Z)};try{const F=z[U],H=F?await F():{type:"error",message:`Unrecognized action type: ${U}`};self.postMessage(H)}catch(F){console.error("Worker unexpected error:",F),self.postMessage({type:"error",name:P,message:F.message||"Unexpected worker error"})}}},LJ=Z9;var s0={$eq:(J,Q)=>J===Q,$ne:(J,Q)=>J!==Q,$gt:(J,Q)=>J>Q,$gte:(J,Q)=>J>=Q,$lt:(J,Q)=>J<Q,$lte:(J,Q)=>J<=Q,$in:(J,Q)=>Array.isArray(Q)&&Q.includes(J),$between:(J,[Q,W])=>J>=Q&&J<=W,$exists:(J,Q)=>Q?J!==void 0:J===void 0,$text:{global:(J,Q)=>{const W=(V)=>String(V).normalize("NFD").replace(/[\u0300-\u036f]/g,"").toLowerCase().replace(/[^\w\s]/g,""),G=W(Q);return Object.values(J).some((V)=>{if(typeof V==="object")return null.fieldSearch(V,G);return W(V).includes(G)})},field:(J,Q)=>{const W=(G)=>String(G).normalize("NFD").replace(/[\u0300-\u036f]/g,"").toLowerCase().replace(/[^\w\s]/g,"");return Array.isArray(J)?J.some((G)=>W(G).includes(W(Q))):W(J).includes(W(Q))}},$like:(J,Q)=>{if(typeof J!=="string"||typeof Q!=="string")return!1;return new RegExp(`^${Q.replace(/%/g,".*").replace(/_/g,".")}\$`,"i").test(J)},$regex:(J,Q)=>typeof J==="string"&&new RegExp(Q.$regex||Q,"i").test(J),$and:(J,Q,W)=>Q.every((G)=>{return W.createFilter(G)(J)}),$or:(J,Q,W)=>Q.some((G)=>{return W.createFilter(G)(J)}),$not:(J,Q,W)=>{return!W.createFilter(Q)(J)}},k6=(J,Q)=>{const W=Q.split(".");let G=J;for(let V of W)if(G&&typeof G==="object"&&(V in G))G=G[V];else return;return G},H6=(J)=>{const Q=(W)=>{return Object.entries(J).every(([G,V])=>{if(G.startsWith("$"))return s0[G](W,V,{filterNode:Q,createFilter:H6});const q=k6(W.value,G);if(typeof V!=="object"||V===null)return s0.$eq(q,V);return Object.entries(V).every(([Y,X])=>{if(Y==="$text")return s0.$text.field(q,X);if(Y==="$between"&&X.every((K)=>K instanceof Date)){const K=new Date(q);return s0.$between(K,X)}return s0[Y]?.(q,X,{filterNode:Q,createFilter:H6})??!1})})};return Q},$6=(J,Q)=>{const W=H6(Q.query);let G=Object.values(J).filter(W);if(Q.field)G.sort((V,q)=>{const Y=k6(V.value,Q.field),X=k6(q.value,Q.field),K=Q.order==="asc"?1:-1;if(typeof Y==="string"&&typeof X==="string")return Y.localeCompare(X)*K;return((Y??0)-(X??0))*K});if(Q.$after){const V=G.findIndex((q)=>q.id===Q.$after);G=V>=0?G.slice(V+1):[]}if(Q.$before){const V=G.findIndex((q)=>q.id===Q.$before);G=V>=0?G.slice(0,V):[]}return Q.$limit?G.slice(0,Q.$limit):G};class C6{constructor(){this.physical=Date.now(),this.logical=0}now(){const J=Date.now();return this.physical=Math.max(this.physical,J),this.logical++,{physical:this.physical,logical:this.logical}}update(J){if(!J||typeof J.physical!=="number"||typeof J.logical!=="number")return;this.physical=Math.max(this.physical,J.physical),this.logical=Math.max(this.logical,J.logical)+1}compare(J,Q){if(!J&&!Q)return 0;if(!J)return-1;if(!Q)return 1;if(J.physical>Q.physical)return 1;if(J.physical<Q.physical)return-1;if(J.logical>Q.logical)return 1;if(J.logical<Q.logical)return-1;return 0}}var RJ=function(J,Q){return J.length===Q.length&&J.every((W,G)=>W===Q[G])};async function k9(){console.log("\u26A1 GenosDB: Empowering distributed graph databases with real-time synchronization and scalability. Learn more: https://github.com/estebanrfp/gdb \u26A1"),console.log(navigator?.storage?.getDirectory?"OPFS is enabled.":"OPFS is not available."),navigator?.storage?.getDirectory&&await navigator.storage.getDirectory()}if(Symbol.dispose===void 0)Object.defineProperty(Symbol,"dispose",{value:Symbol.for("Symbol.dispose")});class xJ{constructor(){this.nodes={}}upsert(J,Q,W){this.nodes[J]={id:J,value:Q,edges:[],timestamp:W}}get(J){return this.nodes[J]||null}link(J,Q,W){const G=this.nodes[J],V=this.nodes[Q];if(G&&V&&!G.edges.includes(Q))G.edges.push(Q),G.timestamp=W}getAllNodes(){return Object.values(this.nodes)}serialize(){return _0.deflate(I0(this.nodes))}deserialize(J){this.nodes=n1(_0.inflate(new Uint8Array(J)))}}class L8{static _listenersInitialized=!1;constructor(J,{password:Q,securityManager:W=null,relayUrls:G=null}={}){this.oplog=new Z6(J,20),this.hybridClock=new C6,this.name=J,this.password=Q,this.globalTimestamp=null,this.graph=new xJ,this.securityManager=W,this.eventListeners=[],this.operators=s0,this.initWorker(),this.ready=this.loadGraphFromOPFS(),this.loadGlobalTimestamp();const V=`graph-sync-room-${this.name}`,q={appId:"1234",...this.password&&{password:this.password}};if(G)q.relayUrls=G;const Y=z6(q,V),[X,K]=Y.makeAction("syncGraph");this.sendData=X;const U=z6(q,`app-sync-${this.name}`);if(this.room=U,!L8._listenersInitialized)L8._listenersInitialized=!0,window.addEventListener("online",async()=>{console.log("\u2705 Reconnected to the network."),this.sendData([{type:"sync",timestamp:this.globalTimestamp}])}),window.addEventListener("offline",async()=>{console.log("\u274C Disconnected from the network.")}),document.addEventListener("visibilitychange",()=>{if(document.visibilityState==="visible")console.log("The tab is visible again."),this.sendData([{type:"sync",timestamp:this.globalTimestamp}]);else if(document.visibilityState==="hidden")console.log("The tab is no longer visible.")});k9(),Y.onPeerJoin(async(P)=>{console.log("\u26A1 New pair connected:",P),this.sendData([{type:"sync",timestamp:this.globalTimestamp}])}),Y.onPeerLeave((P)=>{console.log("\u26A1 Pair disconnected:",P)}),K(async(P)=>{if(this.securityManager&&typeof this.securityManager.verifyIncomingOperations==="function"){const{validatedOperations:Z}=await this.securityManager.verifyIncomingOperations(P);if(Z&&Z.length>0)await this.receiveChanges(Z)}else console.log("GDB: No SecurityManager configured or verifyIncomingOperations missing. Processing P2P data directly."),await this.receiveChanges(P),this.emit()}),this.channel=new BroadcastChannel(`graphdb_sync_${this.name}`),this.channel.onmessage=async(P)=>{if(P.data==="update")console.log("\uD83D\uDD04 Update received from another tab..."),await this.loadGraphFromOPFS(),this.loadGlobalTimestamp(),this.emit()}}loadGlobalTimestamp(){const J=localStorage.getItem(`${this.name}_time`);this.globalTimestamp=J?JSON.parse(J):null}saveGlobalTimestamp(J){this.globalTimestamp=J,localStorage.setItem(`${this.name}_time`,JSON.stringify(J))}initWorker(){try{const J=URL.createObjectURL(new Blob([`(${LJ.toString()})()`],{type:"application/javascript"}));this.worker=new Worker(J),this.worker.addEventListener("message",({data:Q})=>{console.log("Worker message:",`${Q.name} ${Q.type}`),URL.revokeObjectURL(J)}),console.log("Worker initialized successfully.")}catch({message:J}){console.error("Failed to initialize worker:",J)}}getWorker(){return this.worker}emit(){this.eventListeners.forEach((J)=>J(this.graph.nodes))}compress(J){return _0.deflate(J)}decompress(J){return _0.inflate(J)}async getAllNodes(){return await this.ready,this.graph.getAllNodes()}async generateHash(){return crypto.randomUUID()}async hashValue(J){const Q=(new TextEncoder()).encode(J),W=await crypto.subtle.digest("SHA-256",Q);return Array.from(new Uint8Array(W)).map((G)=>G.toString(16).padStart(2,"0")).join("")}async loadGraphFromOPFS(){try{const Q=await((W)=>new Promise((G,V)=>{const q=async({data:Y})=>{if(Y.type==="loaded"&&Y.name===W)this.worker.removeEventListener("message",q),G(new Uint8Array(Y.data));else if(Y.type==="error")this.worker.removeEventListener("message",q),V(new Error(Y.message||"Unknown error"))};this.worker.addEventListener("message",q),this.worker.postMessage({type:"load",name:W})}))(`${this.name}_graph.msgpack`).catch(()=>new Uint8Array);Q.byteLength>0?this.graph.deserialize(Q):console.warn("The file '_graph.msgpack' is empty or could not be loaded."),console.log(`Graph loaded from OPFS: [ ${this.graph.getAllNodes().length} nodes ]`)}catch({message:J}){console.error("General error loading the graph from OPFS:",J)}}async saveGraphToOPFS(){try{const J=this.graph.serialize();return await((W,G)=>new Promise((V,q)=>{const Y=({data:X})=>{if(X.type==="saved"&&X.name===W)this.worker.removeEventListener("message",Y),V();else if(X.type==="error")this.worker.removeEventListener("message",Y),q(new Error(X.message||"Save error"))};this.worker.addEventListener("message",Y),this.worker.postMessage({type:"save",name:W,content:G})}))(`${this.name}_graph.msgpack`,J),this.channel.postMessage("update"),!0}catch({message:J}){throw console.error("Save error:",J),new Error("Save failed")}}async put(J,Q){await this.ready;const W=this.hybridClock.now();return this.saveGlobalTimestamp(W),Q??=await this.generateHash(),this.graph.upsert(Q,J,W),this.oplog.add({type:"upsert",id:Q,timestamp:W}),await this.saveGraphToOPFS(),await this.sendData([{type:"upsert",id:Q,value:J,timestamp:W}]),this.emit(),Q}async get(J,Q=null){if(await this.ready,typeof J!=="string")return{result:null};const W=this.graph.get(J);if(!W){if(Q)Q(null);return{result:null}}const G=(Y)=>{if(!Y)return null;const X=Y.value!==null&&typeof Y.value==="object"?{...Y.value}:Y.value;return{...Y,value:X}};if(!Q)return{result:G(W)};let V=W.timestamp;Q(G(W));const q=(Y)=>{const X=Y[J];if(X){if(this.hybridClock.compare(X.timestamp,V)>0)V=X.timestamp,Q(G(X))}else Q(null),this.eventListeners.splice(this.eventListeners.indexOf(q),1)};return this.eventListeners.push(q),{result:G(W),unsubscribe:()=>{const Y=this.eventListeners.indexOf(q);if(Y>-1)this.eventListeners.splice(Y,1)}}}async map(...J){await this.ready;let W={...{realtime:!1,query:{},field:null,order:"asc",$limit:null,$after:null,$before:null}},G=null,V=!1;J.forEach((K)=>typeof K==="function"?G=K:K&&typeof K==="object"&&(V||=("realtime"in K),Object.assign(W,K))),G&&!V&&(W.realtime=!0);let q=$6(this.graph.nodes,W),Y=null;const X=(K)=>{const U=K.filter((F)=>!q.some((H)=>H.id===F.id)),P=q.filter((F)=>!K.some((H)=>H.id===F.id)),Z=K.filter((F)=>{const H=q.find((R)=>R.id===F.id);return H&&!RJ(I0(F.value),I0(H.value))}),z=(F,H)=>{const R=H==="removed"?null:F.value,M={id:F.id,value:R,edges:F.edges||[],timestamp:F.timestamp||null,action:H};G(M)};U.forEach((F)=>z(F,"added")),P.forEach((F)=>z(F,"removed")),Z.forEach((F)=>z(F,"updated"))};if(G){if(q.forEach((K)=>{if(K.value)G({id:K.id,value:K.value,edges:K.edges,timestamp:K.timestamp,action:"initial"})}),W.realtime)Y=(K)=>{const U=$6(K,W);if(!RJ(I0(U),I0(q)))X(U),q=U},this.eventListeners.push(Y)}return{results:q,...W.realtime&&G&&Y&&{unsubscribe:()=>{const K=this.eventListeners.indexOf(Y);K>-1&&this.eventListeners.splice(K,1)}}}}async remove(J){await this.ready;const Q=this.hybridClock.now(),W=this.graph.get(J);if(!W)return console.error(`Node with ID '${J}' not found.`);delete this.graph.nodes[J],this.oplog.add({type:"remove",id:J,timestamp:Q}),Object.values(this.graph.nodes).forEach((G)=>G.edges=G.edges.filter((V)=>V!==J)),await this.saveGraphToOPFS(),this.saveGlobalTimestamp(Q),await this.sendData([{type:"remove",id:J,value:W.value,timestamp:Q}]),this.emit()}async clear(){await this.ready,this.graph.nodes={};try{await(await navigator.storage.getDirectory()).removeEntry(`${this.name}_graph.msgpack`)}catch({message:J}){console.warn(`Error deleting _graph.msgpack: ${J}`)}this.emit(),console.log("All data has been deleted.")}async link(J,Q){await this.ready;const W=this.hybridClock.now();if(!this.graph.nodes[J]||!this.graph.nodes[Q]){console.error(`One or both nodes (${J}, ${Q}) do not exist.`);return}this.graph.link(J,Q,W),this.oplog.add({type:"link",sourceId:J,targetId:Q,timestamp:W}),await this.saveGraphToOPFS(),this.saveGlobalTimestamp(W),await this.sendData([{type:"link",sourceId:J,targetId:Q,timestamp:W}]),this.emit()}async applyFullGraph(J){try{console.log("Applying full graph from remote..."),this.graph.nodes={...J.nodes},await this.saveGraphToOPFS()}catch({message:Q}){console.error(`Error applying the full graph: ${Q}`)}}async receiveChanges(J){let Q=!1,W=null;const G={upsert:(V)=>{const q=this.graph.get(V.id),Y=jJ(q,V,this.hybridClock);if(Y.resolved){if(this.graph.upsert(V.id,Y.value,Y.timestamp),this.hybridClock.update(Y.timestamp),this.oplog.add({type:"upsert",id:V.id,timestamp:Y.timestamp}),Q=!0,!W||this.hybridClock.compare(Y.timestamp,W)>0)W=Y.timestamp}},remove:(V)=>{const q=this.graph.get(V.id);if(q&&this.hybridClock.compare(q.timestamp,V.timestamp)<0){if(delete this.graph.nodes[V.id],this.hybridClock.update(V.timestamp),this.oplog.add({type:"remove",id:V.id,timestamp:V.timestamp}),Q=!0,!W||this.hybridClock.compare(V.timestamp,W)>0)W=V.timestamp}},link:(V)=>{const q=this.graph.get(V.sourceId),Y=this.graph.get(V.targetId);if(q&&Y&&this.hybridClock.compare(q.timestamp,V.timestamp)<0){if(this.graph.link(V.sourceId,V.targetId,V.timestamp),this.hybridClock.update(V.timestamp),this.oplog.add({type:"link",sourceId:V.sourceId,targetId:V.targetId,timestamp:V.timestamp}),Q=!0,!W||this.hybridClock.compare(V.timestamp,W)>0)W=V.timestamp}},sync:async(V)=>{const q=V.timestamp;console.log("\uD83D\uDCEC [SYNC REQUEST RECEIVED] A peer is asking for changes since timestamp:",q);const Y=this.oplog.getOldest();if(Y&&q&&this.hybridClock.compare(q,Y.timestamp)<0){console.error("\uD83D\uDCA5 [FALLBACK TRIGGERED] Peer is too far behind. Sending FULL graph state."),await this.sendData([{type:"syncReceive",graph:this.graph}]);return}const X=this.oplog.getDelta(q,this.hybridClock.compare);if(X.length>0){const K=X.map((P)=>{if(P.type==="upsert"){const Z=this.graph.get(P.id);return{...P,value:Z?Z.value:null}}return P}),U=_0.deflate(I0(K));console.log("\uD83D\uDCE6 Delta compressed for transport."),console.log(`\uD83D\uDE80 [SENDING DELTA] Found ${X.length} new operations to send.`),await this.sendData([{type:"deltaSync",operations:U}])}else console.log("\u2705 [ALREADY SYNCED] Peer is up-to-date. Nothing to send.")},deltaSync:(V)=>{console.log("\uD83D\uDEF0\uFE0F [DECOMPRESSING DELTA] Received compressed delta sync.");let q=n1(_0.inflate(V.operations));console.log(`\uD83D\uDEF0\uFE0F [DELTA SYNC RECEIVED] Applying ${q.length} operations from a peer.`);for(let Y of q)G[Y.type]?.(Y)},syncReceive:async(V)=>{if(console.log("\uD83D\uDCE6 [FULL SYNC RECEIVED] Overwriting local state with full graph from a peer."),V.graph)await this.applyFullGraph(V.graph),this.oplog.clear(),console.warn("\uD83D\uDD12 Oplog has been cleared due to full sync."),Q=!0;else console.error("Full sync failed: received graph data is invalid.",V.graph)}};for(let V of J)if(G[V.type])await G[V.type](V);else console.warn(`\uD83E\uDD37\u200D\u2640\uFE0F [UNKNOWN MESSAGE TYPE] Received unhandled message type: "${V.type}"`);if(W)console.log("\uD83D\uDCC8 [UPDATING GLOBAL TIMESTAMP] Advancing local knowledge to the latest received timestamp."),this.saveGlobalTimestamp(W);if(Q)console.log("\uD83D\uDCBE [STATE CHANGED] Saving new state to OPFS and emitting update."),await this.saveGraphToOPFS(),this.emit()}}export{L8 as default};
