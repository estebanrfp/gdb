var X7=Object.create;var{defineProperty:G1,getPrototypeOf:V7,getOwnPropertyNames:yQ,getOwnPropertyDescriptor:Y7}=Object,EQ=Object.prototype.hasOwnProperty;var i1=(J,q,Q)=>{Q=J!=null?X7(V7(J)):{};const G=q||!J||!J.__esModule?G1(Q,"default",{value:J,enumerable:!0}):Q;for(let X of yQ(J))if(!EQ.call(G,X))G1(G,X,{get:()=>J[X],enumerable:!0});return G},hQ=(J)=>{const q=hQ.moduleCache??=new WeakMap;var Q=q.get(J);if(Q)return Q;var G=G1({},"__esModule",{value:!0}),X={enumerable:!1};if(J&&typeof J==="object"||typeof J==="function"){for(let V of yQ(J))if(!EQ.call(G,V))G1(G,V,{get:()=>J[V],enumerable:!(X=Y7(J,V))||X.enumerable})}return q.set(J,G),G};var K0=(J,q)=>()=>(q||J((q={exports:{}}).exports,q),q.exports);var mQ=(J,q)=>{for(var Q in q)G1(J,Q,{get:q[Q],enumerable:!0,configurable:!0,set:(G)=>q[Q]=()=>G})};var K7=(J,q)=>()=>(J&&(q=J(J=0)),q);var Q5=K0((A$,J5)=>{var MK=function(J){if(J=String(J),J.length>100)return;var q=/^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(J);if(!q)return;var Q=parseFloat(q[1]),G=(q[2]||"ms").toLowerCase();switch(G){case"years":case"year":case"yrs":case"yr":case"y":return Q*jK;case"weeks":case"week":case"w":return Q*HK;case"days":case"day":case"d":return Q*O8;case"hours":case"hour":case"hrs":case"hr":case"h":return Q*a8;case"minutes":case"minute":case"mins":case"min":case"m":return Q*r8;case"seconds":case"second":case"secs":case"sec":case"s":return Q*n8;case"milliseconds":case"millisecond":case"msecs":case"msec":case"ms":return Q;default:return}},BK=function(J){var q=Math.abs(J);if(q>=O8)return Math.round(J/O8)+"d";if(q>=a8)return Math.round(J/a8)+"h";if(q>=r8)return Math.round(J/r8)+"m";if(q>=n8)return Math.round(J/n8)+"s";return J+"ms"},LK=function(J){var q=Math.abs(J);if(q>=O8)return gJ(J,q,O8,"day");if(q>=a8)return gJ(J,q,a8,"hour");if(q>=r8)return gJ(J,q,r8,"minute");if(q>=n8)return gJ(J,q,n8,"second");return J+" ms"},gJ=function(J,q,Q,G){var X=q>=Q*1.5;return Math.round(J/Q)+" "+G+(X?"s":"")},n8=1000,r8=n8*60,a8=r8*60,O8=a8*24,HK=O8*7,jK=O8*365.25;J5.exports=function(J,q){q=q||{};var Q=typeof J;if(Q==="string"&&J.length>0)return MK(J);else if(Q==="number"&&isFinite(J))return q.long?LK(J):BK(J);throw new Error("val is not a non-empty string or a valid number. val="+JSON.stringify(J))}});var G5=K0((R$,q5)=>{var PK=function(J){Q.debug=Q,Q.default=Q,Q.coerce=W,Q.disable=Y,Q.enable=X,Q.enabled=K,Q.humanize=Q5(),Q.destroy=Z,Object.keys(J).forEach(($)=>{Q[$]=J[$]}),Q.names=[],Q.skips=[],Q.formatters={};function q($){let j=0;for(let z=0;z<$.length;z++)j=(j<<5)-j+$.charCodeAt(z),j|=0;return Q.colors[Math.abs(j)%Q.colors.length]}Q.selectColor=q;function Q($){let j,z=null,U,k;function H(...M){if(!H.enabled)return;const N=H,O=Number(new Date),F=O-(j||O);if(N.diff=F,N.prev=j,N.curr=O,j=O,M[0]=Q.coerce(M[0]),typeof M[0]!=="string")M.unshift("%O");let B=0;M[0]=M[0].replace(/%([a-zA-Z%])/g,(D,x)=>{if(D==="%%")return"%";B++;const S=Q.formatters[x];if(typeof S==="function"){const y=M[B];D=S.call(N,y),M.splice(B,1),B--}return D}),Q.formatArgs.call(N,M),(N.log||Q.log).apply(N,M)}if(H.namespace=$,H.useColors=Q.useColors(),H.color=Q.selectColor($),H.extend=G,H.destroy=Q.destroy,Object.defineProperty(H,"enabled",{enumerable:!0,configurable:!1,get:()=>{if(z!==null)return z;if(U!==Q.namespaces)U=Q.namespaces,k=Q.enabled($);return k},set:(M)=>{z=M}}),typeof Q.init==="function")Q.init(H);return H}function G($,j){const z=Q(this.namespace+(typeof j==="undefined"?":":j)+$);return z.log=this.log,z}function X($){Q.save($),Q.namespaces=$,Q.names=[],Q.skips=[];const j=(typeof $==="string"?$:"").trim().replace(" ",",").split(",").filter(Boolean);for(let z of j)if(z[0]==="-")Q.skips.push(z.slice(1));else Q.names.push(z)}function V($,j){let z=0,U=0,k=-1,H=0;while(z<$.length)if(U<j.length&&(j[U]===$[z]||j[U]==="*"))if(j[U]==="*")k=U,H=z,U++;else z++,U++;else if(k!==-1)U=k+1,H++,z=H;else return!1;while(U<j.length&&j[U]==="*")U++;return U===j.length}function Y(){const $=[...Q.names,...Q.skips.map((j)=>"-"+j)].join(",");return Q.enable(""),$}function K($){for(let j of Q.skips)if(V($,j))return!1;for(let j of Q.names)if(V($,j))return!0;return!1}function W($){if($ instanceof Error)return $.stack||$.message;return $}function Z(){console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.")}return Q.enable(Q.load()),Q};q5.exports=PK});var V5=K0((X5,yJ)=>{var kK=function(){if(typeof window!=="undefined"&&window.process&&(window.process.type==="renderer"||window.process.__nwjs))return!0;if(typeof navigator!=="undefined"&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/))return!1;let J;return typeof document!=="undefined"&&document.documentElement&&document.documentElement.style&&document.documentElement.style.WebkitAppearance||typeof window!=="undefined"&&window.console&&(window.console.firebug||window.console.exception&&window.console.table)||typeof navigator!=="undefined"&&navigator.userAgent&&(J=navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/))&&parseInt(J[1],10)>=31||typeof navigator!=="undefined"&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/)},CK=function(J){if(J[0]=(this.useColors?"%c":"")+this.namespace+(this.useColors?" %c":" ")+J[0]+(this.useColors?"%c ":" ")+"+"+X5.humanize(this.diff),!this.useColors)return;const q="color: "+this.color;J.splice(1,0,q,"color: inherit");let Q=0,G=0;J[0].replace(/%[a-zA-Z%]/g,(X)=>{if(X==="%%")return;if(Q++,X==="%c")G=Q}),J.splice(G,0,q)},NK=function(J){try{if(J)X5.storage.setItem("debug",J);else X5.storage.removeItem("debug")}catch(q){}},wK=function(){let J;try{J=X5.storage.getItem("debug")}catch(q){}if(!J&&typeof process!=="undefined"&&("env"in process))J=process.env.DEBUG;return J},xK=function(){try{return localStorage}catch(J){}};X5.formatArgs=CK;X5.save=NK;X5.load=wK;X5.useColors=kK;X5.storage=xK();X5.destroy=(()=>{let J=!1;return()=>{if(!J)J=!0,console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.")}})();X5.colors=["#0000CC","#0000FF","#0033CC","#0033FF","#0066CC","#0066FF","#0099CC","#0099FF","#00CC00","#00CC33","#00CC66","#00CC99","#00CCCC","#00CCFF","#3300CC","#3300FF","#3333CC","#3333FF","#3366CC","#3366FF","#3399CC","#3399FF","#33CC00","#33CC33","#33CC66","#33CC99","#33CCCC","#33CCFF","#6600CC","#6600FF","#6633CC","#6633FF","#66CC00","#66CC33","#9900CC","#9900FF","#9933CC","#9933FF","#99CC00","#99CC33","#CC0000","#CC0033","#CC0066","#CC0099","#CC00CC","#CC00FF","#CC3300","#CC3333","#CC3366","#CC3399","#CC33CC","#CC33FF","#CC6600","#CC6633","#CC9900","#CC9933","#CCCC00","#CCCC33","#FF0000","#FF0033","#FF0066","#FF0099","#FF00CC","#FF00FF","#FF3300","#FF3333","#FF3366","#FF3399","#FF33CC","#FF33FF","#FF6600","#FF6633","#FF9900","#FF9933","#FFCC00","#FFCC33"];X5.log=console.debug||console.log||(()=>{});yJ.exports=G5()(X5);var{formatters:OK}=yJ.exports;OK.j=function(J){try{return JSON.stringify(J)}catch(q){return"[UnexpectedJSONParseError]: "+q.message}}});var P5={};mQ(P5,{prototype:()=>{{return uK}},once:()=>{{return mK}},default:()=>{{return bK}},EventEmitter:()=>{{return u}}});var vK,u,mJ,z5,U5,yK,H5,j5,M5,B5,EK,hK,mK,_K,L5,s8,Z5,hJ,$5,W5,bK,uK;var k5=K7(()=>{vK=function(J){console&&console.warn&&console.warn(J)},u=function(){u.init.call(this)},mJ=function(J){if(typeof J!="function")throw new TypeError('The "listener" argument must be of type Function. Received type '+typeof J)},z5=function(J){return J._maxListeners===void 0?u.defaultMaxListeners:J._maxListeners},U5=function(J,q,Q,G){var X,V,Y;if(mJ(Q),V=J._events,V===void 0?(V=J._events=Object.create(null),J._eventsCount=0):(V.newListener!==void 0&&(J.emit("newListener",q,Q.listener?Q.listener:Q),V=J._events),Y=V[q]),Y===void 0)Y=V[q]=Q,++J._eventsCount;else if(typeof Y=="function"?Y=V[q]=G?[Q,Y]:[Y,Q]:G?Y.unshift(Q):Y.push(Q),X=z5(J),X>0&&Y.length>X&&!Y.warned){Y.warned=!0;var K=new Error("Possible EventEmitter memory leak detected. "+Y.length+" "+String(q)+" listeners added. Use emitter.setMaxListeners() to increase limit");K.name="MaxListenersExceededWarning",K.emitter=J,K.type=q,K.count=Y.length,vK(K)}return J},yK=function(){if(!this.fired)return this.target.removeListener(this.type,this.wrapFn),this.fired=!0,arguments.length===0?this.listener.call(this.target):this.listener.apply(this.target,arguments)},H5=function(J,q,Q){var G={fired:!1,wrapFn:void 0,target:J,type:q,listener:Q},X=yK.bind(G);return X.listener=Q,G.wrapFn=X,X},j5=function(J,q,Q){var G=J._events;if(G===void 0)return[];var X=G[q];return X===void 0?[]:typeof X=="function"?Q?[X.listener||X]:[X]:Q?hK(X):B5(X,X.length)},M5=function(J){var q=this._events;if(q!==void 0){var Q=q[J];if(typeof Q=="function")return 1;if(Q!==void 0)return Q.length}return 0},B5=function(J,q){for(var Q=new Array(q),G=0;G<q;++G)Q[G]=J[G];return Q},EK=function(J,q){for(;q+1<J.length;q++)J[q]=J[q+1];J.pop()},hK=function(J){for(var q=new Array(J.length),Q=0;Q<q.length;++Q)q[Q]=J[Q].listener||J[Q];return q},mK=function(J,q){return new Promise(function(Q,G){function X(Y){J.removeListener(q,V),G(Y)}function V(){typeof J.removeListener=="function"&&J.removeListener("error",X),Q([].slice.call(arguments))}L5(J,q,V,{once:!0}),q!=="error"&&_K(J,X,{once:!0})})},_K=function(J,q,Q){typeof J.on=="function"&&L5(J,"error",q,Q)},L5=function(J,q,Q,G){if(typeof J.on=="function")G.once?J.once(q,Q):J.on(q,Q);else if(typeof J.addEventListener=="function")J.addEventListener(q,function X(V){G.once&&J.removeEventListener(q,X),Q(V)});else throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type '+typeof J)},s8=typeof Reflect=="object"?Reflect:null,Z5=s8&&typeof s8.apply=="function"?s8.apply:function(J,q,Q){return Function.prototype.apply.call(J,q,Q)};s8&&typeof s8.ownKeys=="function"?hJ=s8.ownKeys:Object.getOwnPropertySymbols?hJ=function(J){return Object.getOwnPropertyNames(J).concat(Object.getOwnPropertySymbols(J))}:hJ=function(J){return Object.getOwnPropertyNames(J)};$5=Number.isNaN||function(J){return J!==J};u.EventEmitter=u;u.prototype._events=void 0;u.prototype._eventsCount=0;u.prototype._maxListeners=void 0;W5=10;Object.defineProperty(u,"defaultMaxListeners",{enumerable:!0,get:function(){return W5},set:function(J){if(typeof J!="number"||J<0||$5(J))throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received '+J+".");W5=J}});u.init=function(){(this._events===void 0||this._events===Object.getPrototypeOf(this)._events)&&(this._events=Object.create(null),this._eventsCount=0),this._maxListeners=this._maxListeners||void 0};u.prototype.setMaxListeners=function(J){if(typeof J!="number"||J<0||$5(J))throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received '+J+".");return this._maxListeners=J,this};u.prototype.getMaxListeners=function(){return z5(this)};u.prototype.emit=function(J){for(var q=[],Q=1;Q<arguments.length;Q++)q.push(arguments[Q]);var G=J==="error",X=this._events;if(X!==void 0)G=G&&X.error===void 0;else if(!G)return!1;if(G){var V;if(q.length>0&&(V=q[0]),V instanceof Error)throw V;var Y=new Error("Unhandled error."+(V?" ("+V.message+")":""));throw Y.context=V,Y}var K=X[J];if(K===void 0)return!1;if(typeof K=="function")Z5(K,this,q);else for(var W=K.length,Z=B5(K,W),Q=0;Q<W;++Q)Z5(Z[Q],this,q);return!0};u.prototype.addListener=function(J,q){return U5(this,J,q,!1)};u.prototype.on=u.prototype.addListener;u.prototype.prependListener=function(J,q){return U5(this,J,q,!0)};u.prototype.once=function(J,q){return mJ(q),this.on(J,H5(this,J,q)),this};u.prototype.prependOnceListener=function(J,q){return mJ(q),this.prependListener(J,H5(this,J,q)),this};u.prototype.removeListener=function(J,q){var Q,G,X,V,Y;if(mJ(q),G=this._events,G===void 0)return this;if(Q=G[J],Q===void 0)return this;if(Q===q||Q.listener===q)--this._eventsCount===0?this._events=Object.create(null):(delete G[J],G.removeListener&&this.emit("removeListener",J,Q.listener||q));else if(typeof Q!="function"){for(X=-1,V=Q.length-1;V>=0;V--)if(Q[V]===q||Q[V].listener===q){Y=Q[V].listener,X=V;break}if(X<0)return this;X===0?Q.shift():EK(Q,X),Q.length===1&&(G[J]=Q[0]),G.removeListener!==void 0&&this.emit("removeListener",J,Y||q)}return this};u.prototype.off=u.prototype.removeListener;u.prototype.removeAllListeners=function(J){var q,Q,G;if(Q=this._events,Q===void 0)return this;if(Q.removeListener===void 0)return arguments.length===0?(this._events=Object.create(null),this._eventsCount=0):Q[J]!==void 0&&(--this._eventsCount===0?this._events=Object.create(null):delete Q[J]),this;if(arguments.length===0){var X=Object.keys(Q),V;for(G=0;G<X.length;++G)V=X[G],V!=="removeListener"&&this.removeAllListeners(V);return this.removeAllListeners("removeListener"),this._events=Object.create(null),this._eventsCount=0,this}if(q=Q[J],typeof q=="function")this.removeListener(J,q);else if(q!==void 0)for(G=q.length-1;G>=0;G--)this.removeListener(J,q[G]);return this};u.prototype.listeners=function(J){return j5(this,J,!0)};u.prototype.rawListeners=function(J){return j5(this,J,!1)};u.listenerCount=function(J,q){return typeof J.listenerCount=="function"?J.listenerCount(q):M5.call(J,q)};u.prototype.listenerCount=M5;u.prototype.eventNames=function(){return this._eventsCount>0?hJ(this._events):[]};bK=u,uK=u.prototype});var N5=K0((n$,C5)=>{C5.exports=class J{constructor(q){if(!(q>0)||(q-1&q)!==0)throw new Error("Max size for a FixedFIFO should be a power of two");this.buffer=new Array(q),this.mask=q-1,this.top=0,this.btm=0,this.next=null}clear(){this.top=this.btm=0,this.next=null,this.buffer.fill(void 0)}push(q){if(this.buffer[this.top]!==void 0)return!1;return this.buffer[this.top]=q,this.top=this.top+1&this.mask,!0}shift(){const q=this.buffer[this.btm];if(q===void 0)return;return this.buffer[this.btm]=void 0,this.btm=this.btm+1&this.mask,q}peek(){return this.buffer[this.btm]}isEmpty(){return this.buffer[this.btm]===void 0}}});var O5=K0((r$,x5)=>{var w5=N5();x5.exports=class J{constructor(q){this.hwm=q||16,this.head=new w5(this.hwm),this.tail=this.head,this.length=0}clear(){this.head=this.tail,this.head.clear(),this.length=0}push(q){if(this.length++,!this.head.push(q)){const Q=this.head;this.head=Q.next=new w5(2*this.head.buffer.length),this.head.push(q)}}shift(){if(this.length!==0)this.length--;const q=this.tail.shift();if(q===void 0&&this.tail.next){const Q=this.tail.next;return this.tail.next=null,this.tail=Q,this.tail.shift()}return q}peek(){const q=this.tail.peek();if(q===void 0&&this.tail.next)return this.tail.next.peek();return q}isEmpty(){return this.length===0}}});var D5=K0((a$,S5)=>{var F5=function(J){return J.length},cK=function(J){const q=J.byteLength;let Q="";for(let G=0;G<q;G++)Q+=String.fromCharCode(J[G]);return Q},pK=function(J,q,Q=0,G=F5(q)){const X=Math.min(G,J.byteLength-Q);for(let V=0;V<X;V++)J[Q+V]=q.charCodeAt(V);return X};S5.exports={byteLength:F5,toString:cK,write:pK}});var R5=K0((s$,A5)=>{var I5=function(J){let q=J.length;if(J.charCodeAt(q-1)===61)q--;if(q>1&&J.charCodeAt(q-1)===61)q--;return q*3>>>2},fK=function(J){const q=J.byteLength;let Q="";for(let G=0;G<q;G+=3)Q+="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"[J[G]>>2]+"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"[(J[G]&3)<<4|J[G+1]>>4]+"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"[(J[G+1]&15)<<2|J[G+2]>>6]+"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"[J[G+2]&63];if(q%3===2)Q=Q.substring(0,Q.length-1)+"=";else if(q%3===1)Q=Q.substring(0,Q.length-2)+"==";return Q},lK=function(J,q,Q=0,G=I5(q)){const X=Math.min(G,J.byteLength-Q);for(let V=0,Y=0;Y<X;V+=4){const K=F8[q.charCodeAt(V)],W=F8[q.charCodeAt(V+1)],Z=F8[q.charCodeAt(V+2)],$=F8[q.charCodeAt(V+3)];J[Y++]=K<<2|W>>4,J[Y++]=(W&15)<<4|Z>>2,J[Y++]=(Z&3)<<6|$&63}return X},F8=new Uint8Array(256);for(let J=0;J<"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".length;J++)F8["ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".charCodeAt(J)]=J;F8[45]=62;F8[95]=63;A5.exports={byteLength:I5,toString:fK,write:lK}});var y5=K0((t$,v5)=>{var g5=function(J){return J.length>>>1},dK=function(J){const q=J.byteLength;J=new DataView(J.buffer,J.byteOffset,q);let Q="",G=0;for(let X=q-q%4;G<X;G+=4)Q+=J.getUint32(G).toString(16).padStart(8,"0");for(;G<q;G++)Q+=J.getUint8(G).toString(16).padStart(2,"0");return Q},iK=function(J,q,Q=0,G=g5(q)){const X=Math.min(G,J.byteLength-Q);for(let V=0;V<X;V++){const Y=T5(q.charCodeAt(V*2)),K=T5(q.charCodeAt(V*2+1));if(Y===void 0||K===void 0)return J.subarray(0,V);J[Q+V]=Y<<4|K}return X},T5=function(J){if(J>=48&&J<=57)return J-48;if(J>=65&&J<=70)return J-65+10;if(J>=97&&J<=102)return J-97+10};v5.exports={byteLength:g5,toString:dK,write:iK}});var h5=K0((e$,E5)=>{var ZQ=function(J){let q=0;for(let Q=0,G=J.length;Q<G;Q++){const X=J.charCodeAt(Q);if(X>=55296&&X<=56319&&Q+1<G){const V=J.charCodeAt(Q+1);if(V>=56320&&V<=57343){q+=4,Q++;continue}}if(X<=127)q+=1;else if(X<=2047)q+=2;else q+=3}return q},WQ;if(typeof TextDecoder!=="undefined"){const J=new TextDecoder;WQ=function q(Q){return J.decode(Q)}}else WQ=function J(q){const Q=q.byteLength;let G="",X=0;while(X<Q){let V=q[X];if(V<=127){G+=String.fromCharCode(V),X++;continue}let Y=0,K=0;if(V<=223)Y=1,K=V&31;else if(V<=239)Y=2,K=V&15;else if(V<=244)Y=3,K=V&7;if(Q-X-Y>0){let W=0;while(W<Y)V=q[X+W+1],K=K<<6|V&63,W+=1}else K=65533,Y=Q-X;G+=String.fromCodePoint(K),X+=Y+1}return G};var $Q;if(typeof TextEncoder!=="undefined"){const J=new TextEncoder;$Q=function q(Q,G,X=0,V=ZQ(G)){const Y=Math.min(V,Q.byteLength-X);return J.encodeInto(G,Q.subarray(X,X+Y)),Y}}else $Q=function J(q,Q,G=0,X=ZQ(Q)){const V=Math.min(X,q.byteLength-G);q=q.subarray(G,G+V);let Y=0,K=0;while(Y<Q.length){const W=Q.codePointAt(Y);if(W<=127){q[K++]=W,Y++;continue}let Z=0,$=0;if(W<=2047)Z=6,$=192;else if(W<=65535)Z=12,$=224;else if(W<=2097151)Z=18,$=240;q[K++]=$|W>>Z,Z-=6;while(Z>=0)q[K++]=128|W>>Z&63,Z-=6;Y+=W>=65536?2:1}return V};E5.exports={byteLength:ZQ,toString:WQ,write:$Q}});var b5=K0((Jz,_5)=>{var m5=function(J){return J.length*2},oK=function(J){const q=J.byteLength;let Q="";for(let G=0;G<q-1;G+=2)Q+=String.fromCharCode(J[G]+J[G+1]*256);return Q},nK=function(J,q,Q=0,G=m5(q)){const X=Math.min(G,J.byteLength-Q);let V=X;for(let Y=0;Y<q.length;++Y){if((V-=2)<0)break;const K=q.charCodeAt(Y),W=K>>8,Z=K%256;J[Q+Y*2]=Z,J[Q+Y*2+1]=W}return X};_5.exports={byteLength:m5,toString:oK,write:nK}});var UQ=K0((f5,l5)=>{var y1=function(J){switch(J){case"ascii":return rK;case"base64":return aK;case"hex":return sK;case"utf8":case"utf-8":case void 0:case null:return tK;case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return eK;default:throw new Error(`Unknown encoding: ${J}`)}},u5=function(J){return J instanceof Uint8Array},J4=function(J){try{return y1(J),!0}catch{return!1}},Q4=function(J,q,Q){const G=new Uint8Array(J);if(q!==void 0)f5.fill(G,q,0,G.byteLength,Q);return G},q4=function(J){return new Uint8Array(J)},G4=function(J){return new Uint8Array(J)},X4=function(J,q){return y1(q).byteLength(J)},V4=function(J,q){if(J===q)return 0;const Q=Math.min(J.byteLength,q.byteLength);J=new DataView(J.buffer,J.byteOffset,J.byteLength),q=new DataView(q.buffer,q.byteOffset,q.byteLength);let G=0;for(let X=Q-Q%4;G<X;G+=4){const V=J.getUint32(G,_J),Y=q.getUint32(G,_J);if(V!==Y)break}for(;G<Q;G++){const X=J.getUint8(G),V=q.getUint8(G);if(X<V)return-1;if(X>V)return 1}return J.byteLength>q.byteLength?1:J.byteLength<q.byteLength?-1:0},Y4=function(J,q){if(q===void 0)q=J.reduce((X,V)=>X+V.byteLength,0);const Q=new Uint8Array(q);let G=0;for(let X of J){if(G+X.byteLength>Q.byteLength){const V=X.subarray(0,Q.byteLength-G);return Q.set(V,G),Q}Q.set(X,G),G+=X.byteLength}return Q},K4=function(J,q,Q=0,G=0,X=J.byteLength){if(X>0&&X<G)return 0;if(X===G)return 0;if(J.byteLength===0||q.byteLength===0)return 0;if(Q<0)throw new RangeError("targetStart is out of range");if(G<0||G>=J.byteLength)throw new RangeError("sourceStart is out of range");if(X<0)throw new RangeError("sourceEnd is out of range");if(Q>=q.byteLength)Q=q.byteLength;if(X>J.byteLength)X=J.byteLength;if(q.byteLength-Q<X-G)X=q.length-Q+G;const V=X-G;if(J===q)q.copyWithin(Q,G,X);else q.set(J.subarray(G,X),Q);return V},Z4=function(J,q){if(J===q)return!0;if(J.byteLength!==q.byteLength)return!1;const Q=J.byteLength;J=new DataView(J.buffer,J.byteOffset,J.byteLength),q=new DataView(q.buffer,q.byteOffset,q.byteLength);let G=0;for(let X=Q-Q%4;G<X;G+=4)if(J.getUint32(G,_J)!==q.getUint32(G,_J))return!1;for(;G<Q;G++)if(J.getUint8(G)!==q.getUint8(G))return!1;return!0},W4=function(J,q,Q,G,X){if(typeof q==="string"){if(typeof Q==="string")X=Q,Q=0,G=J.byteLength;else if(typeof G==="string")X=G,G=J.byteLength}else if(typeof q==="number")q=q&255;else if(typeof q==="boolean")q=+q;if(Q<0||J.byteLength<Q||J.byteLength<G)throw new RangeError("Out of range index");if(Q===void 0)Q=0;if(G===void 0)G=J.byteLength;if(G<=Q)return J;if(!q)q=0;if(typeof q==="number")for(let V=Q;V<G;++V)J[V]=q;else{q=u5(q)?q:zQ(q,X);const V=q.byteLength;for(let Y=0;Y<G-Q;++Y)J[Y+Q]=q[Y%V]}return J},zQ=function(J,q,Q){if(typeof J==="string")return $4(J,q);if(Array.isArray(J))return z4(J);if(ArrayBuffer.isView(J))return U4(J);return H4(J,q,Q)},$4=function(J,q){const Q=y1(q),G=new Uint8Array(Q.byteLength(J));return Q.write(G,J,0,G.byteLength),G},z4=function(J){const q=new Uint8Array(J.length);return q.set(J),q},U4=function(J){const q=new Uint8Array(J.byteLength);return q.set(J),q},H4=function(J,q,Q){return new Uint8Array(J,q,Q)},j4=function(J,q,Q,G){return p5(J,q,Q,G)!==-1},c5=function(J,q,Q,G,X){if(J.byteLength===0)return-1;if(typeof Q==="string")G=Q,Q=0;else if(Q===void 0)Q=X?0:J.length-1;else if(Q<0)Q+=J.byteLength;if(Q>=J.byteLength)if(X)return-1;else Q=J.byteLength-1;else if(Q<0)if(X)Q=0;else return-1;if(typeof q==="string")q=zQ(q,G);else if(typeof q==="number")if(q=q&255,X)return J.indexOf(q,Q);else return J.lastIndexOf(q,Q);if(q.byteLength===0)return-1;if(X){let V=-1;for(let Y=Q;Y<J.byteLength;Y++)if(J[Y]===q[V===-1?0:Y-V]){if(V===-1)V=Y;if(Y-V+1===q.byteLength)return V}else{if(V!==-1)Y-=Y-V;V=-1}}else{if(Q+q.byteLength>J.byteLength)Q=J.byteLength-q.byteLength;for(let V=Q;V>=0;V--){let Y=!0;for(let K=0;K<q.byteLength;K++)if(J[V+K]!==q[K]){Y=!1;break}if(Y)return V}}return-1},p5=function(J,q,Q,G){return c5(J,q,Q,G,!0)},M4=function(J,q,Q,G){return c5(J,q,Q,G,!1)},S8=function(J,q,Q){const G=J[q];J[q]=J[Q],J[Q]=G},B4=function(J){const q=J.byteLength;if(q%2!==0)throw new RangeError("Buffer size must be a multiple of 16-bits");for(let Q=0;Q<q;Q+=2)S8(J,Q,Q+1);return J},L4=function(J){const q=J.byteLength;if(q%4!==0)throw new RangeError("Buffer size must be a multiple of 32-bits");for(let Q=0;Q<q;Q+=4)S8(J,Q,Q+3),S8(J,Q+1,Q+2);return J},P4=function(J){const q=J.byteLength;if(q%8!==0)throw new RangeError("Buffer size must be a multiple of 64-bits");for(let Q=0;Q<q;Q+=8)S8(J,Q,Q+7),S8(J,Q+1,Q+6),S8(J,Q+2,Q+5),S8(J,Q+3,Q+4);return J},k4=function(J){return J},C4=function(J,q,Q=0,G=J.byteLength){const X=J.byteLength;if(Q>=X)return"";if(G<=Q)return"";if(Q<0)Q=0;if(G>X)G=X;if(Q!==0||G<X)J=J.subarray(Q,G);return y1(q).toString(J)},N4=function(J,q,Q,G,X){if(Q===void 0)X="utf8";else if(G===void 0&&typeof Q==="string")X=Q,Q=void 0;else if(X===void 0&&typeof G==="string")X=G,G=void 0;return y1(X).write(J,q,Q,G)},w4=function(J,q,Q){if(Q===void 0)Q=0;return new DataView(J.buffer,J.byteOffset,J.byteLength).setFloat64(Q,q,!0),Q+8},x4=function(J,q,Q){if(Q===void 0)Q=0;return new DataView(J.buffer,J.byteOffset,J.byteLength).setFloat32(Q,q,!0),Q+4},O4=function(J,q,Q){if(Q===void 0)Q=0;return new DataView(J.buffer,J.byteOffset,J.byteLength).setUint32(Q,q,!0),Q+4},F4=function(J,q,Q){if(Q===void 0)Q=0;return new DataView(J.buffer,J.byteOffset,J.byteLength).setInt32(Q,q,!0),Q+4},S4=function(J,q){if(q===void 0)q=0;return new DataView(J.buffer,J.byteOffset,J.byteLength).getFloat64(q,!0)},D4=function(J,q){if(q===void 0)q=0;return new DataView(J.buffer,J.byteOffset,J.byteLength).getFloat32(q,!0)},I4=function(J,q){if(q===void 0)q=0;return new DataView(J.buffer,J.byteOffset,J.byteLength).getUint32(q,!0)},A4=function(J,q){if(q===void 0)q=0;return new DataView(J.buffer,J.byteOffset,J.byteLength).getInt32(q,!0)},R4=function(J,q,Q){if(Q===void 0)Q=0;return new DataView(J.buffer,J.byteOffset,J.byteLength).setFloat64(Q,q,!1),Q+8},T4=function(J,q,Q){if(Q===void 0)Q=0;return new DataView(J.buffer,J.byteOffset,J.byteLength).setFloat32(Q,q,!1),Q+4},g4=function(J,q,Q){if(Q===void 0)Q=0;return new DataView(J.buffer,J.byteOffset,J.byteLength).setUint32(Q,q,!1),Q+4},v4=function(J,q,Q){if(Q===void 0)Q=0;return new DataView(J.buffer,J.byteOffset,J.byteLength).setInt32(Q,q,!1),Q+4},y4=function(J,q){if(q===void 0)q=0;return new DataView(J.buffer,J.byteOffset,J.byteLength).getFloat64(q,!1)},E4=function(J,q){if(q===void 0)q=0;return new DataView(J.buffer,J.byteOffset,J.byteLength).getFloat32(q,!1)},h4=function(J,q){if(q===void 0)q=0;return new DataView(J.buffer,J.byteOffset,J.byteLength).getUint32(q,!1)},m4=function(J,q){if(q===void 0)q=0;return new DataView(J.buffer,J.byteOffset,J.byteLength).getInt32(q,!1)},rK=D5(),aK=R5(),sK=y5(),tK=h5(),eK=b5(),_J=new Uint8Array(Uint16Array.of(255).buffer)[0]===255;l5.exports=f5={isBuffer:u5,isEncoding:J4,alloc:Q4,allocUnsafe:q4,allocUnsafeSlow:G4,byteLength:X4,compare:V4,concat:Y4,copy:K4,equals:Z4,fill:W4,from:zQ,includes:j4,indexOf:p5,lastIndexOf:M4,swap16:B4,swap32:L4,swap64:P4,toBuffer:k4,toString:C4,write:N4,writeDoubleLE:w4,writeFloatLE:x4,writeUInt32LE:O4,writeInt32LE:F4,readDoubleLE:S4,readFloatLE:D4,readUInt32LE:I4,readInt32LE:A4,writeDoubleBE:R4,writeFloatBE:T4,writeUInt32BE:g4,writeInt32BE:v4,readDoubleBE:y4,readFloatBE:E4,readUInt32BE:h4,readInt32BE:m4}});var i5=K0((qz,d5)=>{var _4=UQ();d5.exports=class J{constructor(q){this.encoding=q}decode(q){return _4.toString(q,this.encoding)}flush(){return""}}});var n5=K0((Gz,o5)=>{var b4=UQ();o5.exports=class J{constructor(){this.codePoint=0,this.bytesSeen=0,this.bytesNeeded=0,this.lowerBoundary=128,this.upperBoundary=191}decode(q){if(this.bytesNeeded===0){let G=!0;for(let X=Math.max(0,q.byteLength-4),V=q.byteLength;X<V&&G;X++)G=q[X]<=127;if(G)return b4.toString(q,"utf8")}let Q="";for(let G=0,X=q.byteLength;G<X;G++){const V=q[G];if(this.bytesNeeded===0){if(V<=127)Q+=String.fromCharCode(V);else if(V>=194&&V<=223)this.bytesNeeded=1,this.codePoint=V&31;else if(V>=224&&V<=239){if(V===224)this.lowerBoundary=160;else if(V===237)this.upperBoundary=159;this.bytesNeeded=2,this.codePoint=V&15}else if(V>=240&&V<=244){if(V===240)this.lowerBoundary=144;if(V===244)this.upperBoundary=143;this.bytesNeeded=3,this.codePoint=V&7}else Q+="\uFFFD";continue}if(V<this.lowerBoundary||V>this.upperBoundary){this.codePoint=0,this.bytesNeeded=0,this.bytesSeen=0,this.lowerBoundary=128,this.upperBoundary=191,Q+="\uFFFD";continue}if(this.lowerBoundary=128,this.upperBoundary=191,this.codePoint=this.codePoint<<6|V&63,this.bytesSeen++,this.bytesSeen!==this.bytesNeeded)continue;Q+=String.fromCodePoint(this.codePoint),this.codePoint=0,this.bytesNeeded=0,this.bytesSeen=0}return Q}flush(){const q=this.bytesNeeded>0?"\uFFFD":"";return this.codePoint=0,this.bytesNeeded=0,this.bytesSeen=0,this.lowerBoundary=128,this.upperBoundary=191,q}}});var a5=K0((Xz,r5)=>{var p4=function(J){switch(J=J.toLowerCase(),J){case"utf8":case"utf-8":return"utf8";case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return"utf16le";case"latin1":case"binary":return"latin1";case"base64":case"ascii":case"hex":return J;default:throw new Error("Unknown encoding: "+J)}},u4=i5(),c4=n5();r5.exports=class J{constructor(q="utf8"){switch(this.encoding=p4(q),this.encoding){case"utf8":this.decoder=new c4;break;case"utf16le":case"base64":throw new Error("Unsupported encoding: "+this.encoding);default:this.decoder=new u4(this.encoding)}}push(q){if(typeof q==="string")return q;return this.decoder.decode(q)}write(q){return this.push(q)}end(q){let Q="";if(q)Q=this.push(q);return Q+=this.decoder.flush(),Q}}});var OG=K0((Vz,xG)=>{var SZ=function(){this.stream._duplexState|=BQ,this.updateCallback()},DZ=function(J){const q=this.stream;if(J)q.destroy(J);if((q._duplexState&v0)===0)q._duplexState|=V8,q.emit("finish");if((q._duplexState&zG)===NQ)q._duplexState|=4;if(q._duplexState&=XZ,(q._duplexState&J1)===0)this.update();else this.updateNextTick()},LG=function(J){const q=this.stream;if(!J&&this.error!==uJ)J=this.error;if(J)q.emit("error",J);q._duplexState|=8,q.emit("close");const{_readableState:Q,_writableState:G}=q;if(Q!==null&&Q.pipeline!==null)Q.pipeline.done(q,J);if(G!==null){while(G.drains!==null&&G.drains.length>0)G.drains.shift().resolve(!1);if(G.pipeline!==null)G.pipeline.done(q,J)}},IZ=function(J){const q=this.stream;if(J)q.destroy(J);if(q._duplexState&=GZ,this.drains!==null)gZ(this.drains);if((q._duplexState&kZ)===c1){if(q._duplexState&=VZ,(q._duplexState&MQ)===MQ)q.emit("drain")}this.updateCallback()},AZ=function(J){if(J)this.stream.destroy(J);if(this.stream._duplexState&=r4,this.readAhead===!1&&(this.stream._duplexState&b1)===0)this.stream._duplexState&=YG;this.updateCallback()},RZ=function(){if((this.stream._duplexState&t8)===0)this.stream._duplexState&=VG,this.update()},TZ=function(){if((this.stream._duplexState&J1)===0)this.stream._duplexState&=ZG,this.update()},gZ=function(J){for(let q=0;q<J.length;q++)if(--J[q].writes===0)J.shift().resolve(!0),q--},PG=function(J){const q=this.stream;if(J)q.destroy(J);if((q._duplexState&4)===0){if((q._duplexState&$Z)===0)q._duplexState|=Q1;if((q._duplexState&LZ)===0)q._duplexState|=u1;q.emit("open")}if(q._duplexState&=$G,q._writableState!==null)q._writableState.updateCallback();if(q._readableState!==null)q._readableState.updateCallback()},vZ=function(J,q){if(q!==void 0&&q!==null)this.push(q);this._writableState.afterWrite(J)},yZ=function(J){if(this._readableState!==null){if(J==="data")this._duplexState|=jQ|kQ,this._readableState.updateNextTick();if(J==="readable")this._duplexState|=LQ,this._readableState.updateNextTick()}if(this._writableState!==null){if(J==="drain")this._duplexState|=MQ,this._writableState.updateNextTick()}},EZ=function(J,q){const Q=this._transformState.afterFinal;if(J)return Q(J);if(q!==null&&q!==void 0)this.push(q);this.push(null),Q(null)},hZ=function(...J){return new Promise((q,Q)=>{return CG(...J,(G)=>{if(G)return Q(G);q()})})},CG=function(J,...q){const Q=Array.isArray(J)?[...J,...q]:[J,...q],G=Q.length&&typeof Q[Q.length-1]==="function"?Q.pop():null;if(Q.length<2)throw new Error("Pipeline requires at least 2 streams");let X=Q[0],V=null,Y=null;for(let Z=1;Z<Q.length;Z++){if(V=Q[Z],m1(X))X.pipe(V,W);else K(X,!0,Z>1,W),X.pipe(V);X=V}if(G){let Z=!1;const $=m1(V)||!!(V._writableState&&V._writableState.autoDestroy);if(V.on("error",(j)=>{if(Y===null)Y=j}),V.on("finish",()=>{if(Z=!0,!$)G(Y)}),$)V.on("close",()=>G(Y||(Z?null:HQ)))}return V;function K(Z,$,j,z){Z.on("error",z),Z.on("close",U);function U(){if($&&Z._readableState&&!Z._readableState.ended)return z(HQ);if(j&&Z._writableState&&!Z._writableState.ended)return z(HQ)}}function W(Z){if(!Z||Y)return;Y=Z;for(let $ of Q)$.destroy(Z)}},mZ=function(J){return J},NG=function(J){return!!J._readableState||!!J._writableState},m1=function(J){return typeof J._duplexState==="number"&&NG(J)},_Z=function(J){return!!J._readableState&&J._readableState.ended},bZ=function(J){return!!J._writableState&&J._writableState.ended},uZ=function(J,q={}){const Q=J._readableState&&J._readableState.error||J._writableState&&J._writableState.error;return!q.all&&Q===uJ?null:Q},cZ=function(J){return m1(J)&&J.readable},pZ=function(J){return(J._duplexState&1)!==1||(J._duplexState&fJ)!==0},fZ=function(J){return typeof J==="object"&&J!==null&&typeof J.byteLength==="number"},wG=function(J){return fZ(J)?J.byteLength:1024},QG=function(){},lZ=function(){this.destroy(new Error("Stream aborted."))},dZ=function(J){return J._writev!==xQ.prototype._writev&&J._writev!==dJ.prototype._writev},{EventEmitter:f4}=(k5(),hQ(P5)),uJ=new Error("Stream was destroyed"),HQ=new Error("Premature close"),qG=O5(),l4=a5(),o=(1<<29)-1,GG=o^1,d4=o^2,_1=1<<4,t8=2<<4,Q1=4<<4,X8=8<<4,b1=16<<4,BQ=32<<4,D8=64<<4,jQ=128<<4,LQ=256<<4,PQ=512<<4,F0=1024<<4,G8=2048<<4,cJ=4096<<4,I8=8192<<4,XG=b1|BQ,i4=_1|cJ,o4=Q1|_1,n4=LQ|X8,kQ=b1|I8,r4=o^_1,a4=o^Q1,s4=o^(Q1|cJ),s5=o^cJ,t4=o^b1,e4=o^(X8|PQ),JZ=o^D8,t5=o^XG,VG=o^G8,QZ=o^t8,YG=o^I8,qZ=o^kQ,l0=1<<18,J1=2<<18,u1=4<<18,A8=8<<18,c1=16<<18,V8=32<<18,MQ=64<<18,e8=128<<18,CQ=256<<18,R8=512<<18,pJ=1024<<18,GZ=o^(l0|CQ),KG=o^u1,XZ=o^(l0|R8),VZ=o^c1,YZ=o^A8,ZG=o^e8,KZ=o^J1,WG=o^pJ,E1=_1|l0,$G=o^E1,NQ=F0|V8,v0=4|8|2,L0=v0|1,zG=v0|NQ,ZZ=KG&a4,fJ=e8|G8,WZ=fJ&$G,UG=L0|WZ,$Z=L0|D8|F0,e5=L0|F0|X8,zZ=L0|D8|X8,UZ=L0|LQ|X8|PQ,HZ=L0|_1|D8|F0|cJ|I8,jZ=v0|D8|F0,MZ=t8|L0|G8|Q1,BZ=G8|1,LZ=L0|R8|V8,PZ=A8|c1,HG=A8|l0,kZ=A8|c1|L0|l0,JG=L0|l0|A8|pJ,CZ=u1|l0,NZ=l0|CQ,wZ=L0|R8|HG|V8,xZ=c1|v0|R8|V8,OZ=J1|L0|e8|u1,FZ=R8|V8|v0,bJ=Symbol.asyncIterator||Symbol("asyncIterator");class wQ{constructor(J,{highWaterMark:q=16384,map:Q=null,mapWritable:G,byteLength:X,byteLengthWritable:V}={}){this.stream=J,this.queue=new qG,this.highWaterMark=q,this.buffered=0,this.error=null,this.pipeline=null,this.drains=null,this.byteLength=V||X||wG,this.map=G||Q,this.afterWrite=IZ.bind(this),this.afterUpdateNextTick=TZ.bind(this)}get ended(){return(this.stream._duplexState&V8)!==0}push(J){if((this.stream._duplexState&FZ)!==0)return!1;if(this.map!==null)J=this.map(J);if(this.buffered+=this.byteLength(J),this.queue.push(J),this.buffered<this.highWaterMark)return this.stream._duplexState|=A8,!0;return this.stream._duplexState|=PZ,!1}shift(){const J=this.queue.shift();if(this.buffered-=this.byteLength(J),this.buffered===0)this.stream._duplexState&=YZ;return J}end(J){if(typeof J==="function")this.stream.once("finish",J);else if(J!==void 0&&J!==null)this.push(J);this.stream._duplexState=(this.stream._duplexState|R8)&KG}autoBatch(J,q){const Q=[],G=this.stream;Q.push(J);while((G._duplexState&JG)===HG)Q.push(G._writableState.shift());if((G._duplexState&L0)!==0)return q(null);G._writev(Q,q)}update(){const J=this.stream;J._duplexState|=J1;do{while((J._duplexState&JG)===A8){const q=this.shift();J._duplexState|=NZ,J._write(q,this.afterWrite)}if((J._duplexState&CZ)===0)this.updateNonPrimary()}while(this.continueUpdate()===!0);J._duplexState&=KZ}updateNonPrimary(){const J=this.stream;if((J._duplexState&wZ)===R8){J._duplexState=J._duplexState|l0,J._final(DZ.bind(this));return}if((J._duplexState&v0)===4){if((J._duplexState&fJ)===0)J._duplexState|=E1,J._destroy(LG.bind(this));return}if((J._duplexState&UG)===1)J._duplexState=(J._duplexState|E1)&GG,J._open(PG.bind(this))}continueUpdate(){if((this.stream._duplexState&e8)===0)return!1;return this.stream._duplexState&=ZG,!0}updateCallback(){if((this.stream._duplexState&OZ)===u1)this.update();else this.updateNextTick()}updateNextTick(){if((this.stream._duplexState&e8)!==0)return;if(this.stream._duplexState|=e8,(this.stream._duplexState&J1)===0)queueMicrotask(this.afterUpdateNextTick)}}class jG{constructor(J,{highWaterMark:q=16384,map:Q=null,mapReadable:G,byteLength:X,byteLengthReadable:V}={}){this.stream=J,this.queue=new qG,this.highWaterMark=q===0?1:q,this.buffered=0,this.readAhead=q>0,this.error=null,this.pipeline=null,this.byteLength=V||X||wG,this.map=G||Q,this.pipeTo=null,this.afterRead=AZ.bind(this),this.afterUpdateNextTick=RZ.bind(this)}get ended(){return(this.stream._duplexState&F0)!==0}pipe(J,q){if(this.pipeTo!==null)throw new Error("Can only pipe to one destination");if(typeof q!=="function")q=null;if(this.stream._duplexState|=BQ,this.pipeTo=J,this.pipeline=new BG(this.stream,J,q),q)this.stream.on("error",QG);if(m1(J)){if(J._writableState.pipeline=this.pipeline,q)J.on("error",QG);J.on("finish",this.pipeline.finished.bind(this.pipeline))}else{const Q=this.pipeline.done.bind(this.pipeline,J),G=this.pipeline.done.bind(this.pipeline,J,null);J.on("error",Q),J.on("close",G),J.on("finish",this.pipeline.finished.bind(this.pipeline))}J.on("drain",SZ.bind(this)),this.stream.emit("piping",J),J.emit("pipe",this.stream)}push(J){const q=this.stream;if(J===null)return this.highWaterMark=0,q._duplexState=(q._duplexState|D8)&s4,!1;if(this.map!==null){if(J=this.map(J),J===null)return q._duplexState&=s5,this.buffered<this.highWaterMark}return this.buffered+=this.byteLength(J),this.queue.push(J),q._duplexState=(q._duplexState|X8)&s5,this.buffered<this.highWaterMark}shift(){const J=this.queue.shift();if(this.buffered-=this.byteLength(J),this.buffered===0)this.stream._duplexState&=e4;return J}unshift(J){const q=[this.map!==null?this.map(J):J];while(this.buffered>0)q.push(this.shift());for(let Q=0;Q<q.length-1;Q++){const G=q[Q];this.buffered+=this.byteLength(G),this.queue.push(G)}this.push(q[q.length-1])}read(){const J=this.stream;if((J._duplexState&e5)===X8){const q=this.shift();if(this.pipeTo!==null&&this.pipeTo.write(q)===!1)J._duplexState&=t5;if((J._duplexState&jQ)!==0)J.emit("data",q);return q}if(this.readAhead===!1)J._duplexState|=I8,this.updateNextTick();return null}drain(){const J=this.stream;while((J._duplexState&e5)===X8&&(J._duplexState&XG)!==0){const q=this.shift();if(this.pipeTo!==null&&this.pipeTo.write(q)===!1)J._duplexState&=t5;if((J._duplexState&jQ)!==0)J.emit("data",q)}}update(){const J=this.stream;J._duplexState|=t8;do{this.drain();while(this.buffered<this.highWaterMark&&(J._duplexState&HZ)===I8)J._duplexState|=i4,J._read(this.afterRead),this.drain();if((J._duplexState&UZ)===n4)J._duplexState|=PQ,J.emit("readable");if((J._duplexState&o4)===0)this.updateNonPrimary()}while(this.continueUpdate()===!0);J._duplexState&=QZ}updateNonPrimary(){const J=this.stream;if((J._duplexState&zZ)===D8){if(J._duplexState=(J._duplexState|F0)&JZ,J.emit("end"),(J._duplexState&zG)===NQ)J._duplexState|=4;if(this.pipeTo!==null)this.pipeTo.end()}if((J._duplexState&v0)===4){if((J._duplexState&fJ)===0)J._duplexState|=E1,J._destroy(LG.bind(this));return}if((J._duplexState&UG)===1)J._duplexState=(J._duplexState|E1)&GG,J._open(PG.bind(this))}continueUpdate(){if((this.stream._duplexState&G8)===0)return!1;return this.stream._duplexState&=VG,!0}updateCallback(){if((this.stream._duplexState&MZ)===Q1)this.update();else this.updateNextTick()}updateNextTickIfOpen(){if((this.stream._duplexState&BZ)!==0)return;if(this.stream._duplexState|=G8,(this.stream._duplexState&t8)===0)queueMicrotask(this.afterUpdateNextTick)}updateNextTick(){if((this.stream._duplexState&G8)!==0)return;if(this.stream._duplexState|=G8,(this.stream._duplexState&t8)===0)queueMicrotask(this.afterUpdateNextTick)}}class MG{constructor(J){this.data=null,this.afterTransform=vZ.bind(J),this.afterFinal=null}}class BG{constructor(J,q,Q){this.from=J,this.to=q,this.afterPipe=Q,this.error=null,this.pipeToFinished=!1}finished(){this.pipeToFinished=!0}done(J,q){if(q)this.error=q;if(J===this.to){if(this.to=null,this.from!==null){if((this.from._duplexState&F0)===0||!this.pipeToFinished)this.from.destroy(this.error||new Error("Writable stream closed prematurely"));return}}if(J===this.from){if(this.from=null,this.to!==null){if((J._duplexState&F0)===0)this.to.destroy(this.error||new Error("Readable stream closed before ending"));return}}if(this.afterPipe!==null)this.afterPipe(this.error);this.to=this.from=this.afterPipe=null}}class lJ extends f4{constructor(J){super();if(this._duplexState=0,this._readableState=null,this._writableState=null,J){if(J.open)this._open=J.open;if(J.destroy)this._destroy=J.destroy;if(J.predestroy)this._predestroy=J.predestroy;if(J.signal)J.signal.addEventListener("abort",lZ.bind(this))}this.on("newListener",yZ)}_open(J){J(null)}_destroy(J){J(null)}_predestroy(){}get readable(){return this._readableState!==null?!0:void 0}get writable(){return this._writableState!==null?!0:void 0}get destroyed(){return(this._duplexState&8)!==0}get destroying(){return(this._duplexState&v0)!==0}destroy(J){if((this._duplexState&v0)===0){if(!J)J=uJ;if(this._duplexState=(this._duplexState|4)&ZZ,this._readableState!==null)this._readableState.highWaterMark=0,this._readableState.error=J;if(this._writableState!==null)this._writableState.highWaterMark=0,this._writableState.error=J;if(this._duplexState|=2,this._predestroy(),this._duplexState&=d4,this._readableState!==null)this._readableState.updateNextTick();if(this._writableState!==null)this._writableState.updateNextTick()}}}class h1 extends lJ{constructor(J){super(J);if(this._duplexState|=1|V8|I8,this._readableState=new jG(this,J),J){if(this._readableState.readAhead===!1)this._duplexState&=YG;if(J.read)this._read=J.read;if(J.eagerOpen)this._readableState.updateNextTick();if(J.encoding)this.setEncoding(J.encoding)}}setEncoding(J){const q=new l4(J),Q=this._readableState.map||mZ;return this._readableState.map=G,this;function G(X){const V=q.push(X);return V===""&&(X.byteLength!==0||q.remaining>0)?null:Q(V)}}_read(J){J(null)}pipe(J,q){return this._readableState.updateNextTick(),this._readableState.pipe(J,q),J}read(){return this._readableState.updateNextTick(),this._readableState.read()}push(J){return this._readableState.updateNextTickIfOpen(),this._readableState.push(J)}unshift(J){return this._readableState.updateNextTickIfOpen(),this._readableState.unshift(J)}resume(){return this._duplexState|=kQ,this._readableState.updateNextTick(),this}pause(){return this._duplexState&=this._readableState.readAhead===!1?qZ:t4,this}static _fromAsyncIterator(J,q){let Q;const G=new h1({...q,read(V){J.next().then(X).then(V.bind(null,null)).catch(V)},predestroy(){Q=J.return()},destroy(V){if(!Q)return V(null);Q.then(V.bind(null,null)).catch(V)}});return G;function X(V){if(V.done)G.push(null);else G.push(V.value)}}static from(J,q){if(cZ(J))return J;if(J[bJ])return this._fromAsyncIterator(J[bJ](),q);if(!Array.isArray(J))J=J===void 0?[]:[J];let Q=0;return new h1({...q,read(G){this.push(Q===J.length?null:J[Q++]),G(null)}})}static isBackpressured(J){return(J._duplexState&jZ)!==0||J._readableState.buffered>=J._readableState.highWaterMark}static isPaused(J){return(J._duplexState&b1)===0}[bJ](){const J=this;let q=null,Q=null,G=null;return this.on("error",(W)=>{q=W}),this.on("readable",X),this.on("close",V),{[bJ](){return this},next(){return new Promise(function(W,Z){Q=W,G=Z;const $=J.read();if($!==null)Y($);else if((J._duplexState&8)!==0)Y(null)})},return(){return K(null)},throw(W){return K(W)}};function X(){if(Q!==null)Y(J.read())}function V(){if(Q!==null)Y(null)}function Y(W){if(G===null)return;if(q)G(q);else if(W===null&&(J._duplexState&F0)===0)G(uJ);else Q({value:W,done:W===null});G=Q=null}function K(W){return J.destroy(W),new Promise((Z,$)=>{if(J._duplexState&8)return Z({value:void 0,done:!0});J.once("close",function(){if(W)$(W);else Z({value:void 0,done:!0})})})}}}class xQ extends lJ{constructor(J){super(J);if(this._duplexState|=1|F0,this._writableState=new wQ(this,J),J){if(J.writev)this._writev=J.writev;if(J.write)this._write=J.write;if(J.final)this._final=J.final;if(J.eagerOpen)this._writableState.updateNextTick()}}cork(){this._duplexState|=pJ}uncork(){this._duplexState&=WG,this._writableState.updateNextTick()}_writev(J,q){q(null)}_write(J,q){this._writableState.autoBatch(J,q)}_final(J){J(null)}static isBackpressured(J){return(J._duplexState&xZ)!==0}static drained(J){if(J.destroyed)return Promise.resolve(!1);const q=J._writableState,G=(dZ(J)?Math.min(1,q.queue.length):q.queue.length)+(J._duplexState&CQ?1:0);if(G===0)return Promise.resolve(!0);if(q.drains===null)q.drains=[];return new Promise((X)=>{q.drains.push({writes:G,resolve:X})})}write(J){return this._writableState.updateNextTick(),this._writableState.push(J)}end(J){return this._writableState.updateNextTick(),this._writableState.end(J),this}}class dJ extends h1{constructor(J){super(J);if(this._duplexState=1|this._duplexState&I8,this._writableState=new wQ(this,J),J){if(J.writev)this._writev=J.writev;if(J.write)this._write=J.write;if(J.final)this._final=J.final}}cork(){this._duplexState|=pJ}uncork(){this._duplexState&=WG,this._writableState.updateNextTick()}_writev(J,q){q(null)}_write(J,q){this._writableState.autoBatch(J,q)}_final(J){J(null)}write(J){return this._writableState.updateNextTick(),this._writableState.push(J)}end(J){return this._writableState.updateNextTick(),this._writableState.end(J),this}}class OQ extends dJ{constructor(J){super(J);if(this._transformState=new MG(this),J){if(J.transform)this._transform=J.transform;if(J.flush)this._flush=J.flush}}_write(J,q){if(this._readableState.buffered>=this._readableState.highWaterMark)this._transformState.data=J;else this._transform(J,this._transformState.afterTransform)}_read(J){if(this._transformState.data!==null){const q=this._transformState.data;this._transformState.data=null,J(null),this._transform(q,this._transformState.afterTransform)}else J(null)}destroy(J){if(super.destroy(J),this._transformState.data!==null)this._transformState.data=null,this._transformState.afterTransform()}_transform(J,q){q(null,J)}_flush(J){J(null)}_final(J){this._transformState.afterFinal=J,this._flush(EZ.bind(this))}}class kG extends OQ{}xG.exports={pipeline:CG,pipelinePromise:hZ,isStream:NG,isStreamx:m1,isEnded:_Z,isFinished:bZ,isDisturbed:pZ,getStreamError:uZ,Stream:lJ,Writable:xQ,Readable:h1,Duplex:dJ,Transform:OQ,PassThrough:kG}});var FQ=K0((Yz,SG)=>{var FG=function(J,q){for(let Q in q)Object.defineProperty(J,Q,{value:q[Q],enumerable:!0,configurable:!0});return J},iZ=function(J,q,Q){if(!J||typeof J==="string")throw new TypeError("Please pass an Error to err-code");if(!Q)Q={};if(typeof q==="object")Q=q,q="";if(q)Q.code=q;try{return FG(J,Q)}catch(G){Q.message=J.message,Q.stack=J.stack;const X=function(){};return X.prototype=Object.create(Object.getPrototypeOf(J)),FG(new X,Q)}};SG.exports=iZ});function _Q(J){const q=J.length;let Q=0,G=0;while(G<q){let X=J.charCodeAt(G++);if((X&4294967168)===0){Q++;continue}else if((X&4294965248)===0)Q+=2;else{if(X>=55296&&X<=56319){if(G<q){const V=J.charCodeAt(G);if((V&64512)===56320)++G,X=((X&1023)<<10)+(V&1023)+65536}}if((X&4294901760)===0)Q+=3;else Q+=4}}return Q}function Z7(J,q,Q){const G=J.length;let X=Q,V=0;while(V<G){let Y=J.charCodeAt(V++);if((Y&4294967168)===0){q[X++]=Y;continue}else if((Y&4294965248)===0)q[X++]=Y>>6&31|192;else{if(Y>=55296&&Y<=56319){if(V<G){const K=J.charCodeAt(V);if((K&64512)===56320)++V,Y=((Y&1023)<<10)+(K&1023)+65536}}if((Y&4294901760)===0)q[X++]=Y>>12&15|224,q[X++]=Y>>6&63|128;else q[X++]=Y>>18&7|240,q[X++]=Y>>12&63|128,q[X++]=Y>>6&63|128}q[X++]=Y&63|128}}function z7(J,q,Q){W7.encodeInto(J,q.subarray(Q))}function bQ(J,q,Q){if(J.length>$7)z7(J,q,Q);else Z7(J,q,Q)}function sJ(J,q,Q){let G=q;const X=G+Q,V=[];let Y="";while(G<X){const K=J[G++];if((K&128)===0)V.push(K);else if((K&224)===192){const W=J[G++]&63;V.push((K&31)<<6|W)}else if((K&240)===224){const W=J[G++]&63,Z=J[G++]&63;V.push((K&31)<<12|W<<6|Z)}else if((K&248)===240){const W=J[G++]&63,Z=J[G++]&63,$=J[G++]&63;let j=(K&7)<<18|W<<12|Z<<6|$;if(j>65535)j-=65536,V.push(j>>>10&1023|55296),j=56320|j&1023;V.push(j)}else V.push(K);if(V.length>=U7)Y+=String.fromCharCode(...V),V.length=0}if(V.length>0)Y+=String.fromCharCode(...V);return Y}function M7(J,q,Q){const G=J.subarray(q,q+Q);return H7.decode(G)}function uQ(J,q,Q){if(Q>j7)return M7(J,q,Q);else return sJ(J,q,Q)}var W7=new TextEncoder,$7=50,U7=4096,H7=new TextDecoder,j7=200;class v8{constructor(J,q){this.type=J,this.data=q}}class Z0 extends Error{constructor(J){super(J);const q=Object.create(Z0.prototype);Object.setPrototypeOf(this,q),Object.defineProperty(this,"name",{configurable:!0,enumerable:!1,value:Z0.name})}}function cQ(J,q,Q){const G=Q/4294967296,X=Q;J.setUint32(q,G),J.setUint32(q+4,X)}function o1(J,q,Q){const G=Math.floor(Q/4294967296),X=Q;J.setUint32(q,G),J.setUint32(q+4,X)}function n1(J,q){const Q=J.getInt32(q),G=J.getUint32(q+4);return Q*4294967296+G}function pQ(J,q){const Q=J.getUint32(q),G=J.getUint32(q+4);return Q*4294967296+G}var y8=4294967295;function k7({sec:J,nsec:q}){if(J>=0&&q>=0&&J<=P7)if(q===0&&J<=L7){const Q=new Uint8Array(4);return new DataView(Q.buffer).setUint32(0,J),Q}else{const Q=J/4294967296,G=J&4294967295,X=new Uint8Array(8),V=new DataView(X.buffer);return V.setUint32(0,q<<2|Q&3),V.setUint32(4,G),X}else{const Q=new Uint8Array(12),G=new DataView(Q.buffer);return G.setUint32(0,q),o1(G,4,J),Q}}function C7(J){const q=J.getTime(),Q=Math.floor(q/1000),G=(q-Q*1000)*1e6,X=Math.floor(G/1e9);return{sec:Q+X,nsec:G-X*1e9}}function N7(J){if(J instanceof Date){const q=C7(J);return k7(q)}else return null}function w7(J){const q=new DataView(J.buffer,J.byteOffset,J.byteLength);switch(J.byteLength){case 4:return{sec:q.getUint32(0),nsec:0};case 8:{const Q=q.getUint32(0),G=q.getUint32(4),X=(Q&3)*4294967296+G,V=Q>>>2;return{sec:X,nsec:V}}case 12:{const Q=n1(q,4),G=q.getUint32(0);return{sec:Q,nsec:G}}default:throw new Z0(`Unrecognized data size for timestamp (expected 4, 8, or 12): ${J.length}`)}}function x7(J){const q=w7(J);return new Date(q.sec*1000+q.nsec/1e6)}var B7=-1,L7=4294967295,P7=17179869183,fQ={type:B7,encode:N7,decode:x7};class K8{constructor(){this.builtInEncoders=[],this.builtInDecoders=[],this.encoders=[],this.decoders=[],this.register(fQ)}register({type:J,encode:q,decode:Q}){if(J>=0)this.encoders[J]=q,this.decoders[J]=Q;else{const G=-1-J;this.builtInEncoders[G]=q,this.builtInDecoders[G]=Q}}tryToEncode(J,q){for(let Q=0;Q<this.builtInEncoders.length;Q++){const G=this.builtInEncoders[Q];if(G!=null){const X=G(J,q);if(X!=null){const V=-1-Q;return new v8(V,X)}}}for(let Q=0;Q<this.encoders.length;Q++){const G=this.encoders[Q];if(G!=null){const X=G(J,q);if(X!=null)return new v8(Q,X)}}if(J instanceof v8)return J;return null}decode(J,q,Q){const G=q<0?this.builtInDecoders[-1-q]:this.decoders[q];if(G)return G(J,q,Q);else return new v8(q,J)}}K8.defaultCodec=new K8;var O7=function(J){return J instanceof ArrayBuffer||typeof SharedArrayBuffer!=="undefined"&&J instanceof SharedArrayBuffer};function X1(J){if(J instanceof Uint8Array)return J;else if(ArrayBuffer.isView(J))return new Uint8Array(J.buffer,J.byteOffset,J.byteLength);else if(O7(J))return new Uint8Array(J);else return Uint8Array.from(J)}var lQ=function(J,q,Q){if(q!==null&&q!==void 0){if(typeof q!=="object"&&typeof q!=="function")throw new TypeError("Object expected.");var G,X;if(Q){if(!Symbol.asyncDispose)throw new TypeError("Symbol.asyncDispose is not defined.");G=q[Symbol.asyncDispose]}if(G===void 0){if(!Symbol.dispose)throw new TypeError("Symbol.dispose is not defined.");if(G=q[Symbol.dispose],Q)X=G}if(typeof G!=="function")throw new TypeError("Object not disposable.");if(X)G=function(){try{X.call(this)}catch(V){return Promise.reject(V)}};J.stack.push({value:q,dispose:G,async:Q})}else if(Q)J.stack.push({async:!0});return q},dQ=function(J){return function(q){function Q(Y){q.error=q.hasError?new J(Y,q.error,"An error was suppressed during disposal."):Y,q.hasError=!0}var G,X=0;function V(){while(G=q.stack.pop())try{if(!G.async&&X===1)return X=0,q.stack.push(G),Promise.resolve().then(V);if(G.dispose){var Y=G.dispose.call(G.value);if(G.async)return X|=2,Promise.resolve(Y).then(V,function(K){return Q(K),V()})}else X|=1}catch(K){Q(K)}if(X===1)return q.hasError?Promise.reject(q.error):Promise.resolve();if(q.hasError)throw q.error}return V()}}(typeof SuppressedError==="function"?SuppressedError:function(J,q,Q){var G=new Error(Q);return G.name="SuppressedError",G.error=J,G.suppressed=q,G}),F7=100,S7=2048;class r1{constructor(J){this.entered=!1,this.extensionCodec=J?.extensionCodec??K8.defaultCodec,this.context=J?.context,this.useBigInt64=J?.useBigInt64??!1,this.maxDepth=J?.maxDepth??F7,this.initialBufferSize=J?.initialBufferSize??S7,this.sortKeys=J?.sortKeys??!1,this.forceFloat32=J?.forceFloat32??!1,this.ignoreUndefined=J?.ignoreUndefined??!1,this.forceIntegerToFloat=J?.forceIntegerToFloat??!1,this.pos=0,this.view=new DataView(new ArrayBuffer(this.initialBufferSize)),this.bytes=new Uint8Array(this.view.buffer)}clone(){return new r1({extensionCodec:this.extensionCodec,context:this.context,useBigInt64:this.useBigInt64,maxDepth:this.maxDepth,initialBufferSize:this.initialBufferSize,sortKeys:this.sortKeys,forceFloat32:this.forceFloat32,ignoreUndefined:this.ignoreUndefined,forceIntegerToFloat:this.forceIntegerToFloat})}reinitializeState(){this.pos=0}enteringGuard(){return this.entered=!0,{[Symbol.dispose]:()=>{this.entered=!1}}}encodeSharedRef(J){const q={stack:[],error:void 0,hasError:!1};try{if(this.entered)return this.clone().encodeSharedRef(J);const Q=lQ(q,this.enteringGuard(),!1);return this.reinitializeState(),this.doEncode(J,1),this.bytes.subarray(0,this.pos)}catch(Q){q.error=Q,q.hasError=!0}finally{dQ(q)}}encode(J){const q={stack:[],error:void 0,hasError:!1};try{if(this.entered)return this.clone().encode(J);const Q=lQ(q,this.enteringGuard(),!1);return this.reinitializeState(),this.doEncode(J,1),this.bytes.slice(0,this.pos)}catch(Q){q.error=Q,q.hasError=!0}finally{dQ(q)}}doEncode(J,q){if(q>this.maxDepth)throw new Error(`Too deep objects in depth ${q}`);if(J==null)this.encodeNil();else if(typeof J==="boolean")this.encodeBoolean(J);else if(typeof J==="number")if(!this.forceIntegerToFloat)this.encodeNumber(J);else this.encodeNumberAsFloat(J);else if(typeof J==="string")this.encodeString(J);else if(this.useBigInt64&&typeof J==="bigint")this.encodeBigInt64(J);else this.encodeObject(J,q)}ensureBufferSizeToWrite(J){const q=this.pos+J;if(this.view.byteLength<q)this.resizeBuffer(q*2)}resizeBuffer(J){const q=new ArrayBuffer(J),Q=new Uint8Array(q),G=new DataView(q);Q.set(this.bytes),this.view=G,this.bytes=Q}encodeNil(){this.writeU8(192)}encodeBoolean(J){if(J===!1)this.writeU8(194);else this.writeU8(195)}encodeNumber(J){if(!this.forceIntegerToFloat&&Number.isSafeInteger(J))if(J>=0)if(J<128)this.writeU8(J);else if(J<256)this.writeU8(204),this.writeU8(J);else if(J<65536)this.writeU8(205),this.writeU16(J);else if(J<4294967296)this.writeU8(206),this.writeU32(J);else if(!this.useBigInt64)this.writeU8(207),this.writeU64(J);else this.encodeNumberAsFloat(J);else if(J>=-32)this.writeU8(224|J+32);else if(J>=-128)this.writeU8(208),this.writeI8(J);else if(J>=-32768)this.writeU8(209),this.writeI16(J);else if(J>=-2147483648)this.writeU8(210),this.writeI32(J);else if(!this.useBigInt64)this.writeU8(211),this.writeI64(J);else this.encodeNumberAsFloat(J);else this.encodeNumberAsFloat(J)}encodeNumberAsFloat(J){if(this.forceFloat32)this.writeU8(202),this.writeF32(J);else this.writeU8(203),this.writeF64(J)}encodeBigInt64(J){if(J>=BigInt(0))this.writeU8(207),this.writeBigUint64(J);else this.writeU8(211),this.writeBigInt64(J)}writeStringHeader(J){if(J<32)this.writeU8(160+J);else if(J<256)this.writeU8(217),this.writeU8(J);else if(J<65536)this.writeU8(218),this.writeU16(J);else if(J<4294967296)this.writeU8(219),this.writeU32(J);else throw new Error(`Too long string: ${J} bytes in UTF-8`)}encodeString(J){const Q=_Q(J);this.ensureBufferSizeToWrite(5+Q),this.writeStringHeader(Q),bQ(J,this.bytes,this.pos),this.pos+=Q}encodeObject(J,q){const Q=this.extensionCodec.tryToEncode(J,this.context);if(Q!=null)this.encodeExtension(Q);else if(Array.isArray(J))this.encodeArray(J,q);else if(ArrayBuffer.isView(J))this.encodeBinary(J);else if(typeof J==="object")this.encodeMap(J,q);else throw new Error(`Unrecognized object: ${Object.prototype.toString.apply(J)}`)}encodeBinary(J){const q=J.byteLength;if(q<256)this.writeU8(196),this.writeU8(q);else if(q<65536)this.writeU8(197),this.writeU16(q);else if(q<4294967296)this.writeU8(198),this.writeU32(q);else throw new Error(`Too large binary: ${q}`);const Q=X1(J);this.writeU8a(Q)}encodeArray(J,q){const Q=J.length;if(Q<16)this.writeU8(144+Q);else if(Q<65536)this.writeU8(220),this.writeU16(Q);else if(Q<4294967296)this.writeU8(221),this.writeU32(Q);else throw new Error(`Too large array: ${Q}`);for(let G of J)this.doEncode(G,q+1)}countWithoutUndefined(J,q){let Q=0;for(let G of q)if(J[G]!==void 0)Q++;return Q}encodeMap(J,q){const Q=Object.keys(J);if(this.sortKeys)Q.sort();const G=this.ignoreUndefined?this.countWithoutUndefined(J,Q):Q.length;if(G<16)this.writeU8(128+G);else if(G<65536)this.writeU8(222),this.writeU16(G);else if(G<4294967296)this.writeU8(223),this.writeU32(G);else throw new Error(`Too large map object: ${G}`);for(let X of Q){const V=J[X];if(!(this.ignoreUndefined&&V===void 0))this.encodeString(X),this.doEncode(V,q+1)}}encodeExtension(J){if(typeof J.data==="function"){const Q=J.data(this.pos+6),G=Q.length;if(G>=4294967296)throw new Error(`Too large extension object: ${G}`);this.writeU8(201),this.writeU32(G),this.writeI8(J.type),this.writeU8a(Q);return}const q=J.data.length;if(q===1)this.writeU8(212);else if(q===2)this.writeU8(213);else if(q===4)this.writeU8(214);else if(q===8)this.writeU8(215);else if(q===16)this.writeU8(216);else if(q<256)this.writeU8(199),this.writeU8(q);else if(q<65536)this.writeU8(200),this.writeU16(q);else if(q<4294967296)this.writeU8(201),this.writeU32(q);else throw new Error(`Too large extension object: ${q}`);this.writeI8(J.type),this.writeU8a(J.data)}writeU8(J){this.ensureBufferSizeToWrite(1),this.view.setUint8(this.pos,J),this.pos++}writeU8a(J){const q=J.length;this.ensureBufferSizeToWrite(q),this.bytes.set(J,this.pos),this.pos+=q}writeI8(J){this.ensureBufferSizeToWrite(1),this.view.setInt8(this.pos,J),this.pos++}writeU16(J){this.ensureBufferSizeToWrite(2),this.view.setUint16(this.pos,J),this.pos+=2}writeI16(J){this.ensureBufferSizeToWrite(2),this.view.setInt16(this.pos,J),this.pos+=2}writeU32(J){this.ensureBufferSizeToWrite(4),this.view.setUint32(this.pos,J),this.pos+=4}writeI32(J){this.ensureBufferSizeToWrite(4),this.view.setInt32(this.pos,J),this.pos+=4}writeF32(J){this.ensureBufferSizeToWrite(4),this.view.setFloat32(this.pos,J),this.pos+=4}writeF64(J){this.ensureBufferSizeToWrite(8),this.view.setFloat64(this.pos,J),this.pos+=8}writeU64(J){this.ensureBufferSizeToWrite(8),cQ(this.view,this.pos,J),this.pos+=8}writeI64(J){this.ensureBufferSizeToWrite(8),o1(this.view,this.pos,J),this.pos+=8}writeBigUint64(J){this.ensureBufferSizeToWrite(8),this.view.setBigUint64(this.pos,J),this.pos+=8}writeBigInt64(J){this.ensureBufferSizeToWrite(8),this.view.setBigInt64(this.pos,J),this.pos+=8}}function E0(J,q){return new r1(q).encodeSharedRef(J)}function a1(J){return`${J<0?"-":""}0x${Math.abs(J).toString(16).padStart(2,"0")}`}var D7=16,I7=16;class tJ{constructor(J=D7,q=I7){this.hit=0,this.miss=0,this.maxKeyLength=J,this.maxLengthPerKey=q,this.caches=[];for(let Q=0;Q<this.maxKeyLength;Q++)this.caches.push([])}canBeCached(J){return J>0&&J<=this.maxKeyLength}find(J,q,Q){const G=this.caches[Q-1];J:for(let X of G){const V=X.bytes;for(let Y=0;Y<Q;Y++)if(V[Y]!==J[q+Y])continue J;return X.str}return null}store(J,q){const Q=this.caches[J.length-1],G={bytes:J,str:q};if(Q.length>=this.maxLengthPerKey)Q[Math.random()*Q.length|0]=G;else Q.push(G)}decode(J,q,Q){const G=this.find(J,q,Q);if(G!=null)return this.hit++,G;this.miss++;const X=sJ(J,q,Q),V=Uint8Array.prototype.slice.call(J,q,q+Q);return this.store(V,X),X}}var s1=function(J,q,Q){if(q!==null&&q!==void 0){if(typeof q!=="object"&&typeof q!=="function")throw new TypeError("Object expected.");var G,X;if(Q){if(!Symbol.asyncDispose)throw new TypeError("Symbol.asyncDispose is not defined.");G=q[Symbol.asyncDispose]}if(G===void 0){if(!Symbol.dispose)throw new TypeError("Symbol.dispose is not defined.");if(G=q[Symbol.dispose],Q)X=G}if(typeof G!=="function")throw new TypeError("Object not disposable.");if(X)G=function(){try{X.call(this)}catch(V){return Promise.reject(V)}};J.stack.push({value:q,dispose:G,async:Q})}else if(Q)J.stack.push({async:!0});return q},t1=function(J){return function(q){function Q(Y){q.error=q.hasError?new J(Y,q.error,"An error was suppressed during disposal."):Y,q.hasError=!0}var G,X=0;function V(){while(G=q.stack.pop())try{if(!G.async&&X===1)return X=0,q.stack.push(G),Promise.resolve().then(V);if(G.dispose){var Y=G.dispose.call(G.value);if(G.async)return X|=2,Promise.resolve(Y).then(V,function(K){return Q(K),V()})}else X|=1}catch(K){Q(K)}if(X===1)return q.hasError?Promise.reject(q.error):Promise.resolve();if(q.hasError)throw q.error}return V()}}(typeof SuppressedError==="function"?SuppressedError:function(J,q,Q){var G=new Error(Q);return G.name="SuppressedError",G.error=J,G.suppressed=q,G}),eJ="array",Y1="map_key",oQ="map_value",A7=(J)=>{if(typeof J==="string"||typeof J==="number")return J;throw new Z0("The type of key must be string or number but "+typeof J)};class nQ{constructor(){this.stack=[],this.stackHeadPosition=-1}get length(){return this.stackHeadPosition+1}top(){return this.stack[this.stackHeadPosition]}pushArrayState(J){const q=this.getUninitializedStateFromPool();q.type=eJ,q.position=0,q.size=J,q.array=new Array(J)}pushMapState(J){const q=this.getUninitializedStateFromPool();q.type=Y1,q.readCount=0,q.size=J,q.map={}}getUninitializedStateFromPool(){if(this.stackHeadPosition++,this.stackHeadPosition===this.stack.length){const J={type:void 0,size:0,array:void 0,position:0,readCount:0,map:void 0,key:null};this.stack.push(J)}return this.stack[this.stackHeadPosition]}release(J){if(this.stack[this.stackHeadPosition]!==J)throw new Error("Invalid stack state. Released state is not on top of the stack.");if(J.type===eJ){const Q=J;Q.size=0,Q.array=void 0,Q.position=0,Q.type=void 0}if(J.type===Y1||J.type===oQ){const Q=J;Q.size=0,Q.map=void 0,Q.readCount=0,Q.type=void 0}this.stackHeadPosition--}reset(){this.stack.length=0,this.stackHeadPosition=-1}}var V1=-1,J9=new DataView(new ArrayBuffer(0)),R7=new Uint8Array(J9.buffer);try{J9.getInt8(0)}catch(J){if(!(J instanceof RangeError))throw new Error("This module is not supported in the current JavaScript engine because DataView does not throw RangeError on out-of-bounds access")}var iQ=new RangeError("Insufficient data"),T7=new tJ;class e1{constructor(J){this.totalPos=0,this.pos=0,this.view=J9,this.bytes=R7,this.headByte=V1,this.stack=new nQ,this.entered=!1,this.extensionCodec=J?.extensionCodec??K8.defaultCodec,this.context=J?.context,this.useBigInt64=J?.useBigInt64??!1,this.rawStrings=J?.rawStrings??!1,this.maxStrLength=J?.maxStrLength??y8,this.maxBinLength=J?.maxBinLength??y8,this.maxArrayLength=J?.maxArrayLength??y8,this.maxMapLength=J?.maxMapLength??y8,this.maxExtLength=J?.maxExtLength??y8,this.keyDecoder=J?.keyDecoder!==void 0?J.keyDecoder:T7,this.mapKeyConverter=J?.mapKeyConverter??A7}clone(){return new e1({extensionCodec:this.extensionCodec,context:this.context,useBigInt64:this.useBigInt64,rawStrings:this.rawStrings,maxStrLength:this.maxStrLength,maxBinLength:this.maxBinLength,maxArrayLength:this.maxArrayLength,maxMapLength:this.maxMapLength,maxExtLength:this.maxExtLength,keyDecoder:this.keyDecoder})}reinitializeState(){this.totalPos=0,this.headByte=V1,this.stack.reset()}setBuffer(J){const q=X1(J);this.bytes=q,this.view=new DataView(q.buffer,q.byteOffset,q.byteLength),this.pos=0}appendBuffer(J){if(this.headByte===V1&&!this.hasRemaining(1))this.setBuffer(J);else{const q=this.bytes.subarray(this.pos),Q=X1(J),G=new Uint8Array(q.length+Q.length);G.set(q),G.set(Q,q.length),this.setBuffer(G)}}hasRemaining(J){return this.view.byteLength-this.pos>=J}createExtraByteError(J){const{view:q,pos:Q}=this;return new RangeError(`Extra ${q.byteLength-Q} of ${q.byteLength} byte(s) found at buffer[${J}]`)}enteringGuard(){return this.entered=!0,{[Symbol.dispose]:()=>{this.entered=!1}}}decode(J){const q={stack:[],error:void 0,hasError:!1};try{if(this.entered)return this.clone().decode(J);const Q=s1(q,this.enteringGuard(),!1);this.reinitializeState(),this.setBuffer(J);const G=this.doDecodeSync();if(this.hasRemaining(1))throw this.createExtraByteError(this.pos);return G}catch(Q){q.error=Q,q.hasError=!0}finally{t1(q)}}*decodeMulti(J){const q={stack:[],error:void 0,hasError:!1};try{if(this.entered){yield*this.clone().decodeMulti(J);return}const Q=s1(q,this.enteringGuard(),!1);this.reinitializeState(),this.setBuffer(J);while(this.hasRemaining(1))yield this.doDecodeSync()}catch(Q){q.error=Q,q.hasError=!0}finally{t1(q)}}async decodeAsync(J){const q={stack:[],error:void 0,hasError:!1};try{if(this.entered)return this.clone().decodeAsync(J);const Q=s1(q,this.enteringGuard(),!1);let G=!1,X;for await(let W of J){if(G)throw this.entered=!1,this.createExtraByteError(this.totalPos);this.appendBuffer(W);try{X=this.doDecodeSync(),G=!0}catch(Z){if(!(Z instanceof RangeError))throw Z}this.totalPos+=this.pos}if(G){if(this.hasRemaining(1))throw this.createExtraByteError(this.totalPos);return X}const{headByte:V,pos:Y,totalPos:K}=this;throw new RangeError(`Insufficient data in parsing ${a1(V)} at ${K} (${Y} in the current buffer)`)}catch(Q){q.error=Q,q.hasError=!0}finally{t1(q)}}decodeArrayStream(J){return this.decodeMultiAsync(J,!0)}decodeStream(J){return this.decodeMultiAsync(J,!1)}async*decodeMultiAsync(J,q){const Q={stack:[],error:void 0,hasError:!1};try{if(this.entered){yield*this.clone().decodeMultiAsync(J,q);return}const G=s1(Q,this.enteringGuard(),!1);let X=q,V=-1;for await(let Y of J){if(q&&V===0)throw this.createExtraByteError(this.totalPos);if(this.appendBuffer(Y),X)V=this.readArraySize(),X=!1,this.complete();try{while(!0)if(yield this.doDecodeSync(),--V===0)break}catch(K){if(!(K instanceof RangeError))throw K}this.totalPos+=this.pos}}catch(G){Q.error=G,Q.hasError=!0}finally{t1(Q)}}doDecodeSync(){J:while(!0){const J=this.readHeadByte();let q;if(J>=224)q=J-256;else if(J<192)if(J<128)q=J;else if(J<144){const G=J-128;if(G!==0){this.pushMapState(G),this.complete();continue J}else q={}}else if(J<160){const G=J-144;if(G!==0){this.pushArrayState(G),this.complete();continue J}else q=[]}else{const G=J-160;q=this.decodeString(G,0)}else if(J===192)q=null;else if(J===194)q=!1;else if(J===195)q=!0;else if(J===202)q=this.readF32();else if(J===203)q=this.readF64();else if(J===204)q=this.readU8();else if(J===205)q=this.readU16();else if(J===206)q=this.readU32();else if(J===207)if(this.useBigInt64)q=this.readU64AsBigInt();else q=this.readU64();else if(J===208)q=this.readI8();else if(J===209)q=this.readI16();else if(J===210)q=this.readI32();else if(J===211)if(this.useBigInt64)q=this.readI64AsBigInt();else q=this.readI64();else if(J===217){const G=this.lookU8();q=this.decodeString(G,1)}else if(J===218){const G=this.lookU16();q=this.decodeString(G,2)}else if(J===219){const G=this.lookU32();q=this.decodeString(G,4)}else if(J===220){const G=this.readU16();if(G!==0){this.pushArrayState(G),this.complete();continue J}else q=[]}else if(J===221){const G=this.readU32();if(G!==0){this.pushArrayState(G),this.complete();continue J}else q=[]}else if(J===222){const G=this.readU16();if(G!==0){this.pushMapState(G),this.complete();continue J}else q={}}else if(J===223){const G=this.readU32();if(G!==0){this.pushMapState(G),this.complete();continue J}else q={}}else if(J===196){const G=this.lookU8();q=this.decodeBinary(G,1)}else if(J===197){const G=this.lookU16();q=this.decodeBinary(G,2)}else if(J===198){const G=this.lookU32();q=this.decodeBinary(G,4)}else if(J===212)q=this.decodeExtension(1,0);else if(J===213)q=this.decodeExtension(2,0);else if(J===214)q=this.decodeExtension(4,0);else if(J===215)q=this.decodeExtension(8,0);else if(J===216)q=this.decodeExtension(16,0);else if(J===199){const G=this.lookU8();q=this.decodeExtension(G,1)}else if(J===200){const G=this.lookU16();q=this.decodeExtension(G,2)}else if(J===201){const G=this.lookU32();q=this.decodeExtension(G,4)}else throw new Z0(`Unrecognized type byte: ${a1(J)}`);this.complete();const Q=this.stack;while(Q.length>0){const G=Q.top();if(G.type===eJ)if(G.array[G.position]=q,G.position++,G.position===G.size)q=G.array,Q.release(G);else continue J;else if(G.type===Y1){if(q==="__proto__")throw new Z0("The key __proto__ is not allowed");G.key=this.mapKeyConverter(q),G.type=oQ;continue J}else if(G.map[G.key]=q,G.readCount++,G.readCount===G.size)q=G.map,Q.release(G);else{G.key=null,G.type=Y1;continue J}}return q}}readHeadByte(){if(this.headByte===V1)this.headByte=this.readU8();return this.headByte}complete(){this.headByte=V1}readArraySize(){const J=this.readHeadByte();switch(J){case 220:return this.readU16();case 221:return this.readU32();default:if(J<160)return J-144;else throw new Z0(`Unrecognized array type byte: ${a1(J)}`)}}pushMapState(J){if(J>this.maxMapLength)throw new Z0(`Max length exceeded: map length (${J}) > maxMapLengthLength (${this.maxMapLength})`);this.stack.pushMapState(J)}pushArrayState(J){if(J>this.maxArrayLength)throw new Z0(`Max length exceeded: array length (${J}) > maxArrayLength (${this.maxArrayLength})`);this.stack.pushArrayState(J)}decodeString(J,q){if(!this.rawStrings||this.stateIsMapKey())return this.decodeUtf8String(J,q);return this.decodeBinary(J,q)}decodeUtf8String(J,q){if(J>this.maxStrLength)throw new Z0(`Max length exceeded: UTF-8 byte length (${J}) > maxStrLength (${this.maxStrLength})`);if(this.bytes.byteLength<this.pos+q+J)throw iQ;const Q=this.pos+q;let G;if(this.stateIsMapKey()&&this.keyDecoder?.canBeCached(J))G=this.keyDecoder.decode(this.bytes,Q,J);else G=uQ(this.bytes,Q,J);return this.pos+=q+J,G}stateIsMapKey(){if(this.stack.length>0)return this.stack.top().type===Y1;return!1}decodeBinary(J,q){if(J>this.maxBinLength)throw new Z0(`Max length exceeded: bin length (${J}) > maxBinLength (${this.maxBinLength})`);if(!this.hasRemaining(J+q))throw iQ;const Q=this.pos+q,G=this.bytes.subarray(Q,Q+J);return this.pos+=q+J,G}decodeExtension(J,q){if(J>this.maxExtLength)throw new Z0(`Max length exceeded: ext length (${J}) > maxExtLength (${this.maxExtLength})`);const Q=this.view.getInt8(this.pos+q),G=this.decodeBinary(J,q+1);return this.extensionCodec.decode(G,Q,this.context)}lookU8(){return this.view.getUint8(this.pos)}lookU16(){return this.view.getUint16(this.pos)}lookU32(){return this.view.getUint32(this.pos)}readU8(){const J=this.view.getUint8(this.pos);return this.pos++,J}readI8(){const J=this.view.getInt8(this.pos);return this.pos++,J}readU16(){const J=this.view.getUint16(this.pos);return this.pos+=2,J}readI16(){const J=this.view.getInt16(this.pos);return this.pos+=2,J}readU32(){const J=this.view.getUint32(this.pos);return this.pos+=4,J}readI32(){const J=this.view.getInt32(this.pos);return this.pos+=4,J}readU64(){const J=pQ(this.view,this.pos);return this.pos+=8,J}readI64(){const J=n1(this.view,this.pos);return this.pos+=8,J}readU64AsBigInt(){const J=this.view.getBigUint64(this.pos);return this.pos+=8,J}readI64AsBigInt(){const J=this.view.getBigInt64(this.pos);return this.pos+=8,J}readF32(){const J=this.view.getFloat32(this.pos);return this.pos+=4,J}readF64(){const J=this.view.getFloat64(this.pos);return this.pos+=8,J}}function JJ(J,q){return new e1(q).decode(J)}var u8=function(J){let q=J.length;while(--q>=0)J[q]=0},q9=function(J,q,Q,G,X){this.static_tree=J,this.extra_bits=q,this.extra_base=Q,this.elems=G,this.max_length=X,this.has_stree=J&&J.length},G9=function(J,q){this.dyn_tree=J,this.max_code=0,this.stat_desc=q},S0=function(J,q,Q,G,X){this.good_length=J,this.max_lazy=q,this.nice_length=Q,this.max_chain=G,this.func=X},vX=function(){this.strm=null,this.status=0,this.pending_buf=null,this.pending_buf_size=0,this.pending_out=0,this.pending=0,this.wrap=0,this.gzhead=null,this.gzindex=0,this.method=$J,this.last_flush=-1,this.w_size=0,this.w_bits=0,this.w_mask=0,this.window=null,this.window_size=0,this.prev=null,this.head=null,this.ins_h=0,this.hash_size=0,this.hash_bits=0,this.hash_mask=0,this.hash_shift=0,this.block_start=0,this.match_length=0,this.prev_match=0,this.match_available=0,this.strstart=0,this.match_start=0,this.lookahead=0,this.prev_length=0,this.max_chain_length=0,this.max_lazy_match=0,this.level=0,this.strategy=0,this.good_match=0,this.nice_match=0,this.dyn_ltree=new Uint16Array(OX*2),this.dyn_dtree=new Uint16Array((2*wX+1)*2),this.bl_tree=new Uint16Array((2*xX+1)*2),d0(this.dyn_ltree),d0(this.dyn_dtree),d0(this.bl_tree),this.l_desc=null,this.d_desc=null,this.bl_desc=null,this.bl_count=new Uint16Array(FX+1),this.heap=new Uint16Array(2*P9+1),d0(this.heap),this.heap_len=0,this.heap_max=0,this.depth=new Uint16Array(2*P9+1),d0(this.depth),this.sym_buf=0,this.lit_bufsize=0,this.sym_next=0,this.sym_end=0,this.opt_len=0,this.static_len=0,this.matches=0,this.insert=0,this.bi_buf=0,this.bi_valid=0},QV=function(){this.input=null,this.next_in=0,this.avail_in=0,this.total_in=0,this.output=null,this.next_out=0,this.avail_out=0,this.total_out=0,this.msg="",this.state=null,this.data_type=2,this.adler=0},x1=function(J){this.options=zJ.assign({level:KV,method:WV,chunkSize:16384,windowBits:15,memLevel:8,strategy:ZV},J||{});let q=this.options;if(q.raw&&q.windowBits>0)q.windowBits=-q.windowBits;else if(q.gzip&&q.windowBits>0&&q.windowBits<16)q.windowBits+=16;this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new J6,this.strm.avail_out=0;let Q=z1.deflateInit2(this.strm,q.level,q.method,q.windowBits,q.memLevel,q.strategy);if(Q!==ZJ)throw new Error(z8[Q]);if(q.header)z1.deflateSetHeader(this.strm,q.header);if(q.dictionary){let G;if(typeof q.dictionary==="string")G=k1.string2buf(q.dictionary);else if(Q6.call(q.dictionary)==="[object ArrayBuffer]")G=new Uint8Array(q.dictionary);else G=q.dictionary;if(Q=z1.deflateSetDictionary(this.strm,G),Q!==ZJ)throw new Error(z8[Q]);this._dict_set=!0}},A9=function(J,q){const Q=new x1(q);if(Q.push(J,!0),Q.err)throw Q.msg||z8[Q.err];return Q.result},$V=function(J,q){return q=q||{},q.raw=!0,A9(J,q)},zV=function(J,q){return q=q||{},q.gzip=!0,A9(J,q)},yV=function(){this.strm=null,this.mode=0,this.last=!1,this.wrap=0,this.havedict=!1,this.flags=0,this.dmax=0,this.check=0,this.total=0,this.head=null,this.wbits=0,this.wsize=0,this.whave=0,this.wnext=0,this.window=null,this.hold=0,this.bits=0,this.length=0,this.offset=0,this.extra=0,this.lencode=null,this.distcode=null,this.lenbits=0,this.distbits=0,this.ncode=0,this.nlen=0,this.ndist=0,this.have=0,this.next=null,this.lens=new Uint16Array(320),this.work=new Uint16Array(288),this.lendyn=null,this.distdyn=null,this.sane=0,this.back=0,this.was=0},sV=function(){this.text=0,this.time=0,this.xflags=0,this.os=0,this.extra=null,this.extra_len=0,this.name="",this.comment="",this.hcrc=0,this.done=!1},O1=function(J){this.options=zJ.assign({chunkSize:65536,windowBits:15,to:""},J||{});const q=this.options;if(q.raw&&q.windowBits>=0&&q.windowBits<16){if(q.windowBits=-q.windowBits,q.windowBits===0)q.windowBits=-15}if(q.windowBits>=0&&q.windowBits<16&&!(J&&J.windowBits))q.windowBits+=32;if(q.windowBits>15&&q.windowBits<48){if((q.windowBits&15)===0)q.windowBits|=15}this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new J6,this.strm.avail_out=0;let Q=_0.inflateInit2(this.strm,q.windowBits);if(Q!==C1)throw new Error(z8[Q]);if(this.header=new tV,_0.inflateGetHeader(this.strm,this.header),q.dictionary){if(typeof q.dictionary==="string")q.dictionary=k1.string2buf(q.dictionary);else if(H6.call(q.dictionary)==="[object ArrayBuffer]")q.dictionary=new Uint8Array(q.dictionary);if(q.raw){if(Q=_0.inflateSetDictionary(this.strm,q.dictionary),Q!==C1)throw new Error(z8[Q])}}},R9=function(J,q){const Q=new O1(q);if(Q.push(J),Q.err)throw Q.msg||z8[Q.err];return Q.result},GY=function(J,q){return q=q||{},q.raw=!0,R9(J,q)};/*! pako 2.1.0 https://github.com/nodeca/pako @license (MIT AND Zlib) */var g7=0,vq=1,v7=2,y7=3,E7=258,O9=29,N1=256,H1=N1+1+O9,m8=30,F9=19,yq=2*H1+1,Z8=15,Q9=16,h7=7,S9=256,Eq=16,hq=17,mq=18,M9=new Uint8Array([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0]),YJ=new Uint8Array([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13]),m7=new Uint8Array([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7]),_q=new Uint8Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),_7=512,m0=new Array((H1+2)*2);u8(m0);var $1=new Array(m8*2);u8($1);var j1=new Array(_7);u8(j1);var M1=new Array(E7-y7+1);u8(M1);var D9=new Array(O9);u8(D9);var KJ=new Array(m8);u8(KJ);var bq,uq,cq,pq=(J)=>{return J<256?j1[J]:j1[256+(J>>>7)]},B1=(J,q)=>{J.pending_buf[J.pending++]=q&255,J.pending_buf[J.pending++]=q>>>8&255},$0=(J,q,Q)=>{if(J.bi_valid>Q9-Q)J.bi_buf|=q<<J.bi_valid&65535,B1(J,J.bi_buf),J.bi_buf=q>>Q9-J.bi_valid,J.bi_valid+=Q-Q9;else J.bi_buf|=q<<J.bi_valid&65535,J.bi_valid+=Q},D0=(J,q,Q)=>{$0(J,Q[q*2],Q[q*2+1])},fq=(J,q)=>{let Q=0;do Q|=J&1,J>>>=1,Q<<=1;while(--q>0);return Q>>>1},b7=(J)=>{if(J.bi_valid===16)B1(J,J.bi_buf),J.bi_buf=0,J.bi_valid=0;else if(J.bi_valid>=8)J.pending_buf[J.pending++]=J.bi_buf&255,J.bi_buf>>=8,J.bi_valid-=8},u7=(J,q)=>{const{dyn_tree:Q,max_code:G}=q,X=q.stat_desc.static_tree,V=q.stat_desc.has_stree,Y=q.stat_desc.extra_bits,K=q.stat_desc.extra_base,W=q.stat_desc.max_length;let Z,$,j,z,U,k,H=0;for(z=0;z<=Z8;z++)J.bl_count[z]=0;Q[J.heap[J.heap_max]*2+1]=0;for(Z=J.heap_max+1;Z<yq;Z++){if($=J.heap[Z],z=Q[Q[$*2+1]*2+1]+1,z>W)z=W,H++;if(Q[$*2+1]=z,$>G)continue;if(J.bl_count[z]++,U=0,$>=K)U=Y[$-K];if(k=Q[$*2],J.opt_len+=k*(z+U),V)J.static_len+=k*(X[$*2+1]+U)}if(H===0)return;do{z=W-1;while(J.bl_count[z]===0)z--;J.bl_count[z]--,J.bl_count[z+1]+=2,J.bl_count[W]--,H-=2}while(H>0);for(z=W;z!==0;z--){$=J.bl_count[z];while($!==0){if(j=J.heap[--Z],j>G)continue;if(Q[j*2+1]!==z)J.opt_len+=(z-Q[j*2+1])*Q[j*2],Q[j*2+1]=z;$--}}},lq=(J,q,Q)=>{const G=new Array(Z8+1);let X=0,V,Y;for(V=1;V<=Z8;V++)X=X+Q[V-1]<<1,G[V]=X;for(Y=0;Y<=q;Y++){let K=J[Y*2+1];if(K===0)continue;J[Y*2]=fq(G[K]++,K)}},c7=()=>{let J,q,Q,G,X;const V=new Array(Z8+1);Q=0;for(G=0;G<O9-1;G++){D9[G]=Q;for(J=0;J<1<<M9[G];J++)M1[Q++]=G}M1[Q-1]=G,X=0;for(G=0;G<16;G++){KJ[G]=X;for(J=0;J<1<<YJ[G];J++)j1[X++]=G}X>>=7;for(;G<m8;G++){KJ[G]=X<<7;for(J=0;J<1<<YJ[G]-7;J++)j1[256+X++]=G}for(q=0;q<=Z8;q++)V[q]=0;J=0;while(J<=143)m0[J*2+1]=8,J++,V[8]++;while(J<=255)m0[J*2+1]=9,J++,V[9]++;while(J<=279)m0[J*2+1]=7,J++,V[7]++;while(J<=287)m0[J*2+1]=8,J++,V[8]++;lq(m0,H1+1,V);for(J=0;J<m8;J++)$1[J*2+1]=5,$1[J*2]=fq(J,5);bq=new q9(m0,M9,N1+1,H1,Z8),uq=new q9($1,YJ,0,m8,Z8),cq=new q9(new Array(0),m7,0,F9,h7)},dq=(J)=>{let q;for(q=0;q<H1;q++)J.dyn_ltree[q*2]=0;for(q=0;q<m8;q++)J.dyn_dtree[q*2]=0;for(q=0;q<F9;q++)J.bl_tree[q*2]=0;J.dyn_ltree[S9*2]=1,J.opt_len=J.static_len=0,J.sym_next=J.matches=0},iq=(J)=>{if(J.bi_valid>8)B1(J,J.bi_buf);else if(J.bi_valid>0)J.pending_buf[J.pending++]=J.bi_buf;J.bi_buf=0,J.bi_valid=0},rQ=(J,q,Q,G)=>{const X=q*2,V=Q*2;return J[X]<J[V]||J[X]===J[V]&&G[q]<=G[Q]},X9=(J,q,Q)=>{const G=J.heap[Q];let X=Q<<1;while(X<=J.heap_len){if(X<J.heap_len&&rQ(q,J.heap[X+1],J.heap[X],J.depth))X++;if(rQ(q,G,J.heap[X],J.depth))break;J.heap[Q]=J.heap[X],Q=X,X<<=1}J.heap[Q]=G},aQ=(J,q,Q)=>{let G,X,V=0,Y,K;if(J.sym_next!==0)do if(G=J.pending_buf[J.sym_buf+V++]&255,G+=(J.pending_buf[J.sym_buf+V++]&255)<<8,X=J.pending_buf[J.sym_buf+V++],G===0)D0(J,X,q);else{if(Y=M1[X],D0(J,Y+N1+1,q),K=M9[Y],K!==0)X-=D9[Y],$0(J,X,K);if(G--,Y=pq(G),D0(J,Y,Q),K=YJ[Y],K!==0)G-=KJ[Y],$0(J,G,K)}while(V<J.sym_next);D0(J,S9,q)},B9=(J,q)=>{const Q=q.dyn_tree,G=q.stat_desc.static_tree,X=q.stat_desc.has_stree,V=q.stat_desc.elems;let Y,K,W=-1,Z;J.heap_len=0,J.heap_max=yq;for(Y=0;Y<V;Y++)if(Q[Y*2]!==0)J.heap[++J.heap_len]=W=Y,J.depth[Y]=0;else Q[Y*2+1]=0;while(J.heap_len<2)if(Z=J.heap[++J.heap_len]=W<2?++W:0,Q[Z*2]=1,J.depth[Z]=0,J.opt_len--,X)J.static_len-=G[Z*2+1];q.max_code=W;for(Y=J.heap_len>>1;Y>=1;Y--)X9(J,Q,Y);Z=V;do Y=J.heap[1],J.heap[1]=J.heap[J.heap_len--],X9(J,Q,1),K=J.heap[1],J.heap[--J.heap_max]=Y,J.heap[--J.heap_max]=K,Q[Z*2]=Q[Y*2]+Q[K*2],J.depth[Z]=(J.depth[Y]>=J.depth[K]?J.depth[Y]:J.depth[K])+1,Q[Y*2+1]=Q[K*2+1]=Z,J.heap[1]=Z++,X9(J,Q,1);while(J.heap_len>=2);J.heap[--J.heap_max]=J.heap[1],u7(J,q),lq(Q,W,J.bl_count)},sQ=(J,q,Q)=>{let G,X=-1,V,Y=q[1],K=0,W=7,Z=4;if(Y===0)W=138,Z=3;q[(Q+1)*2+1]=65535;for(G=0;G<=Q;G++){if(V=Y,Y=q[(G+1)*2+1],++K<W&&V===Y)continue;else if(K<Z)J.bl_tree[V*2]+=K;else if(V!==0){if(V!==X)J.bl_tree[V*2]++;J.bl_tree[Eq*2]++}else if(K<=10)J.bl_tree[hq*2]++;else J.bl_tree[mq*2]++;if(K=0,X=V,Y===0)W=138,Z=3;else if(V===Y)W=6,Z=3;else W=7,Z=4}},tQ=(J,q,Q)=>{let G,X=-1,V,Y=q[1],K=0,W=7,Z=4;if(Y===0)W=138,Z=3;for(G=0;G<=Q;G++){if(V=Y,Y=q[(G+1)*2+1],++K<W&&V===Y)continue;else if(K<Z)do D0(J,V,J.bl_tree);while(--K!==0);else if(V!==0){if(V!==X)D0(J,V,J.bl_tree),K--;D0(J,Eq,J.bl_tree),$0(J,K-3,2)}else if(K<=10)D0(J,hq,J.bl_tree),$0(J,K-3,3);else D0(J,mq,J.bl_tree),$0(J,K-11,7);if(K=0,X=V,Y===0)W=138,Z=3;else if(V===Y)W=6,Z=3;else W=7,Z=4}},p7=(J)=>{let q;sQ(J,J.dyn_ltree,J.l_desc.max_code),sQ(J,J.dyn_dtree,J.d_desc.max_code),B9(J,J.bl_desc);for(q=F9-1;q>=3;q--)if(J.bl_tree[_q[q]*2+1]!==0)break;return J.opt_len+=3*(q+1)+5+5+4,q},f7=(J,q,Q,G)=>{let X;$0(J,q-257,5),$0(J,Q-1,5),$0(J,G-4,4);for(X=0;X<G;X++)$0(J,J.bl_tree[_q[X]*2+1],3);tQ(J,J.dyn_ltree,q-1),tQ(J,J.dyn_dtree,Q-1)},l7=(J)=>{let q=4093624447,Q;for(Q=0;Q<=31;Q++,q>>>=1)if(q&1&&J.dyn_ltree[Q*2]!==0)return 0;if(J.dyn_ltree[18]!==0||J.dyn_ltree[20]!==0||J.dyn_ltree[26]!==0)return 1;for(Q=32;Q<N1;Q++)if(J.dyn_ltree[Q*2]!==0)return 1;return 0},eQ=!1,d7=(J)=>{if(!eQ)c7(),eQ=!0;J.l_desc=new G9(J.dyn_ltree,bq),J.d_desc=new G9(J.dyn_dtree,uq),J.bl_desc=new G9(J.bl_tree,cq),J.bi_buf=0,J.bi_valid=0,dq(J)},oq=(J,q,Q,G)=>{if($0(J,(g7<<1)+(G?1:0),3),iq(J),B1(J,Q),B1(J,~Q),Q)J.pending_buf.set(J.window.subarray(q,q+Q),J.pending);J.pending+=Q},i7=(J)=>{$0(J,vq<<1,3),D0(J,S9,m0),b7(J)},o7=(J,q,Q,G)=>{let X,V,Y=0;if(J.level>0){if(J.strm.data_type===2)J.strm.data_type=l7(J);if(B9(J,J.l_desc),B9(J,J.d_desc),Y=p7(J),X=J.opt_len+3+7>>>3,V=J.static_len+3+7>>>3,V<=X)X=V}else X=V=Q+5;if(Q+4<=X&&q!==-1)oq(J,q,Q,G);else if(J.strategy===4||V===X)$0(J,(vq<<1)+(G?1:0),3),aQ(J,m0,$1);else $0(J,(v7<<1)+(G?1:0),3),f7(J,J.l_desc.max_code+1,J.d_desc.max_code+1,Y+1),aQ(J,J.dyn_ltree,J.dyn_dtree);if(dq(J),G)iq(J)},n7=(J,q,Q)=>{if(J.pending_buf[J.sym_buf+J.sym_next++]=q,J.pending_buf[J.sym_buf+J.sym_next++]=q>>8,J.pending_buf[J.sym_buf+J.sym_next++]=Q,q===0)J.dyn_ltree[Q*2]++;else J.matches++,q--,J.dyn_ltree[(M1[Q]+N1+1)*2]++,J.dyn_dtree[pq(q)*2]++;return J.sym_next===J.sym_end},r7=d7,a7=oq,s7=o7,t7=n7,e7=i7,JX={_tr_init:r7,_tr_stored_block:a7,_tr_flush_block:s7,_tr_tally:t7,_tr_align:e7},QX=(J,q,Q,G)=>{let X=J&65535|0,V=J>>>16&65535|0,Y=0;while(Q!==0){Y=Q>2000?2000:Q,Q-=Y;do X=X+q[G++]|0,V=V+X|0;while(--Y);X%=65521,V%=65521}return X|V<<16|0},L1=QX,qX=()=>{let J,q=[];for(var Q=0;Q<256;Q++){J=Q;for(var G=0;G<8;G++)J=J&1?3988292384^J>>>1:J>>>1;q[Q]=J}return q},GX=new Uint32Array(qX()),XX=(J,q,Q,G)=>{const X=GX,V=G+Q;J^=-1;for(let Y=G;Y<V;Y++)J=J>>>8^X[(J^q[Y])&255];return J^-1},q0=XX,z8={2:"need dictionary",1:"stream end",0:"","-1":"file error","-2":"stream error","-3":"data error","-4":"insufficient memory","-5":"buffer error","-6":"incompatible version"},j8={Z_NO_FLUSH:0,Z_PARTIAL_FLUSH:1,Z_SYNC_FLUSH:2,Z_FULL_FLUSH:3,Z_FINISH:4,Z_BLOCK:5,Z_TREES:6,Z_OK:0,Z_STREAM_END:1,Z_NEED_DICT:2,Z_ERRNO:-1,Z_STREAM_ERROR:-2,Z_DATA_ERROR:-3,Z_MEM_ERROR:-4,Z_BUF_ERROR:-5,Z_NO_COMPRESSION:0,Z_BEST_SPEED:1,Z_BEST_COMPRESSION:9,Z_DEFAULT_COMPRESSION:-1,Z_FILTERED:1,Z_HUFFMAN_ONLY:2,Z_RLE:3,Z_FIXED:4,Z_DEFAULT_STRATEGY:0,Z_BINARY:0,Z_TEXT:1,Z_UNKNOWN:2,Z_DEFLATED:8},{_tr_init:VX,_tr_stored_block:L9,_tr_flush_block:YX,_tr_tally:o0,_tr_align:KX}=JX,{Z_NO_FLUSH:n0,Z_PARTIAL_FLUSH:ZX,Z_FULL_FLUSH:WX,Z_FINISH:P0,Z_BLOCK:Jq,Z_OK:V0,Z_STREAM_END:Qq,Z_STREAM_ERROR:I0,Z_DATA_ERROR:$X,Z_BUF_ERROR:V9,Z_DEFAULT_COMPRESSION:zX,Z_FILTERED:UX,Z_HUFFMAN_ONLY:QJ,Z_RLE:HX,Z_FIXED:jX,Z_DEFAULT_STRATEGY:MX,Z_UNKNOWN:BX,Z_DEFLATED:$J}=j8,LX=9,PX=15,kX=8,CX=29,NX=256,P9=NX+1+CX,wX=30,xX=19,OX=2*P9+1,FX=15,m=3,i0=258,A0=i0+m+1,SX=32,_8=42,I9=57,k9=69,C9=73,N9=91,w9=103,W8=113,Z1=666,W0=1,c8=2,U8=3,p8=4,DX=3,$8=(J,q)=>{return J.msg=z8[q],q},qq=(J)=>{return J*2-(J>4?9:0)},d0=(J)=>{let q=J.length;while(--q>=0)J[q]=0},IX=(J)=>{let q,Q,G,X=J.w_size;q=J.hash_size,G=q;do Q=J.head[--G],J.head[G]=Q>=X?Q-X:0;while(--q);q=X,G=q;do Q=J.prev[--G],J.prev[G]=Q>=X?Q-X:0;while(--q)},AX=(J,q,Q)=>(q<<J.hash_shift^Q)&J.hash_mask,r0=AX,j0=(J)=>{const q=J.state;let Q=q.pending;if(Q>J.avail_out)Q=J.avail_out;if(Q===0)return;if(J.output.set(q.pending_buf.subarray(q.pending_out,q.pending_out+Q),J.next_out),J.next_out+=Q,q.pending_out+=Q,J.total_out+=Q,J.avail_out-=Q,q.pending-=Q,q.pending===0)q.pending_out=0},M0=(J,q)=>{YX(J,J.block_start>=0?J.block_start:-1,J.strstart-J.block_start,q),J.block_start=J.strstart,j0(J.strm)},_=(J,q)=>{J.pending_buf[J.pending++]=q},K1=(J,q)=>{J.pending_buf[J.pending++]=q>>>8&255,J.pending_buf[J.pending++]=q&255},x9=(J,q,Q,G)=>{let X=J.avail_in;if(X>G)X=G;if(X===0)return 0;if(J.avail_in-=X,q.set(J.input.subarray(J.next_in,J.next_in+X),Q),J.state.wrap===1)J.adler=L1(J.adler,q,X,Q);else if(J.state.wrap===2)J.adler=q0(J.adler,q,X,Q);return J.next_in+=X,J.total_in+=X,X},nq=(J,q)=>{let{max_chain_length:Q,strstart:G}=J,X,V,Y=J.prev_length,K=J.nice_match;const W=J.strstart>J.w_size-A0?J.strstart-(J.w_size-A0):0,Z=J.window,$=J.w_mask,j=J.prev,z=J.strstart+i0;let U=Z[G+Y-1],k=Z[G+Y];if(J.prev_length>=J.good_match)Q>>=2;if(K>J.lookahead)K=J.lookahead;do{if(X=q,Z[X+Y]!==k||Z[X+Y-1]!==U||Z[X]!==Z[G]||Z[++X]!==Z[G+1])continue;G+=2,X++;do;while(Z[++G]===Z[++X]&&Z[++G]===Z[++X]&&Z[++G]===Z[++X]&&Z[++G]===Z[++X]&&Z[++G]===Z[++X]&&Z[++G]===Z[++X]&&Z[++G]===Z[++X]&&Z[++G]===Z[++X]&&G<z);if(V=i0-(z-G),G=z-i0,V>Y){if(J.match_start=q,Y=V,V>=K)break;U=Z[G+Y-1],k=Z[G+Y]}}while((q=j[q&$])>W&&--Q!==0);if(Y<=J.lookahead)return Y;return J.lookahead},b8=(J)=>{const q=J.w_size;let Q,G,X;do{if(G=J.window_size-J.lookahead-J.strstart,J.strstart>=q+(q-A0)){if(J.window.set(J.window.subarray(q,q+q-G),0),J.match_start-=q,J.strstart-=q,J.block_start-=q,J.insert>J.strstart)J.insert=J.strstart;IX(J),G+=q}if(J.strm.avail_in===0)break;if(Q=x9(J.strm,J.window,J.strstart+J.lookahead,G),J.lookahead+=Q,J.lookahead+J.insert>=m){X=J.strstart-J.insert,J.ins_h=J.window[X],J.ins_h=r0(J,J.ins_h,J.window[X+1]);while(J.insert)if(J.ins_h=r0(J,J.ins_h,J.window[X+m-1]),J.prev[X&J.w_mask]=J.head[J.ins_h],J.head[J.ins_h]=X,X++,J.insert--,J.lookahead+J.insert<m)break}}while(J.lookahead<A0&&J.strm.avail_in!==0)},rq=(J,q)=>{let Q=J.pending_buf_size-5>J.w_size?J.w_size:J.pending_buf_size-5,G,X,V,Y=0,K=J.strm.avail_in;do{if(G=65535,V=J.bi_valid+42>>3,J.strm.avail_out<V)break;if(V=J.strm.avail_out-V,X=J.strstart-J.block_start,G>X+J.strm.avail_in)G=X+J.strm.avail_in;if(G>V)G=V;if(G<Q&&(G===0&&q!==P0||q===n0||G!==X+J.strm.avail_in))break;if(Y=q===P0&&G===X+J.strm.avail_in?1:0,L9(J,0,0,Y),J.pending_buf[J.pending-4]=G,J.pending_buf[J.pending-3]=G>>8,J.pending_buf[J.pending-2]=~G,J.pending_buf[J.pending-1]=~G>>8,j0(J.strm),X){if(X>G)X=G;J.strm.output.set(J.window.subarray(J.block_start,J.block_start+X),J.strm.next_out),J.strm.next_out+=X,J.strm.avail_out-=X,J.strm.total_out+=X,J.block_start+=X,G-=X}if(G)x9(J.strm,J.strm.output,J.strm.next_out,G),J.strm.next_out+=G,J.strm.avail_out-=G,J.strm.total_out+=G}while(Y===0);if(K-=J.strm.avail_in,K){if(K>=J.w_size)J.matches=2,J.window.set(J.strm.input.subarray(J.strm.next_in-J.w_size,J.strm.next_in),0),J.strstart=J.w_size,J.insert=J.strstart;else{if(J.window_size-J.strstart<=K){if(J.strstart-=J.w_size,J.window.set(J.window.subarray(J.w_size,J.w_size+J.strstart),0),J.matches<2)J.matches++;if(J.insert>J.strstart)J.insert=J.strstart}J.window.set(J.strm.input.subarray(J.strm.next_in-K,J.strm.next_in),J.strstart),J.strstart+=K,J.insert+=K>J.w_size-J.insert?J.w_size-J.insert:K}J.block_start=J.strstart}if(J.high_water<J.strstart)J.high_water=J.strstart;if(Y)return p8;if(q!==n0&&q!==P0&&J.strm.avail_in===0&&J.strstart===J.block_start)return c8;if(V=J.window_size-J.strstart,J.strm.avail_in>V&&J.block_start>=J.w_size){if(J.block_start-=J.w_size,J.strstart-=J.w_size,J.window.set(J.window.subarray(J.w_size,J.w_size+J.strstart),0),J.matches<2)J.matches++;if(V+=J.w_size,J.insert>J.strstart)J.insert=J.strstart}if(V>J.strm.avail_in)V=J.strm.avail_in;if(V)x9(J.strm,J.window,J.strstart,V),J.strstart+=V,J.insert+=V>J.w_size-J.insert?J.w_size-J.insert:V;if(J.high_water<J.strstart)J.high_water=J.strstart;if(V=J.bi_valid+42>>3,V=J.pending_buf_size-V>65535?65535:J.pending_buf_size-V,Q=V>J.w_size?J.w_size:V,X=J.strstart-J.block_start,X>=Q||(X||q===P0)&&q!==n0&&J.strm.avail_in===0&&X<=V)G=X>V?V:X,Y=q===P0&&J.strm.avail_in===0&&G===X?1:0,L9(J,J.block_start,G,Y),J.block_start+=G,j0(J.strm);return Y?U8:W0},Y9=(J,q)=>{let Q,G;for(;;){if(J.lookahead<A0){if(b8(J),J.lookahead<A0&&q===n0)return W0;if(J.lookahead===0)break}if(Q=0,J.lookahead>=m)J.ins_h=r0(J,J.ins_h,J.window[J.strstart+m-1]),Q=J.prev[J.strstart&J.w_mask]=J.head[J.ins_h],J.head[J.ins_h]=J.strstart;if(Q!==0&&J.strstart-Q<=J.w_size-A0)J.match_length=nq(J,Q);if(J.match_length>=m)if(G=o0(J,J.strstart-J.match_start,J.match_length-m),J.lookahead-=J.match_length,J.match_length<=J.max_lazy_match&&J.lookahead>=m){J.match_length--;do J.strstart++,J.ins_h=r0(J,J.ins_h,J.window[J.strstart+m-1]),Q=J.prev[J.strstart&J.w_mask]=J.head[J.ins_h],J.head[J.ins_h]=J.strstart;while(--J.match_length!==0);J.strstart++}else J.strstart+=J.match_length,J.match_length=0,J.ins_h=J.window[J.strstart],J.ins_h=r0(J,J.ins_h,J.window[J.strstart+1]);else G=o0(J,0,J.window[J.strstart]),J.lookahead--,J.strstart++;if(G){if(M0(J,!1),J.strm.avail_out===0)return W0}}if(J.insert=J.strstart<m-1?J.strstart:m-1,q===P0){if(M0(J,!0),J.strm.avail_out===0)return U8;return p8}if(J.sym_next){if(M0(J,!1),J.strm.avail_out===0)return W0}return c8},E8=(J,q)=>{let Q,G,X;for(;;){if(J.lookahead<A0){if(b8(J),J.lookahead<A0&&q===n0)return W0;if(J.lookahead===0)break}if(Q=0,J.lookahead>=m)J.ins_h=r0(J,J.ins_h,J.window[J.strstart+m-1]),Q=J.prev[J.strstart&J.w_mask]=J.head[J.ins_h],J.head[J.ins_h]=J.strstart;if(J.prev_length=J.match_length,J.prev_match=J.match_start,J.match_length=m-1,Q!==0&&J.prev_length<J.max_lazy_match&&J.strstart-Q<=J.w_size-A0){if(J.match_length=nq(J,Q),J.match_length<=5&&(J.strategy===UX||J.match_length===m&&J.strstart-J.match_start>4096))J.match_length=m-1}if(J.prev_length>=m&&J.match_length<=J.prev_length){X=J.strstart+J.lookahead-m,G=o0(J,J.strstart-1-J.prev_match,J.prev_length-m),J.lookahead-=J.prev_length-1,J.prev_length-=2;do if(++J.strstart<=X)J.ins_h=r0(J,J.ins_h,J.window[J.strstart+m-1]),Q=J.prev[J.strstart&J.w_mask]=J.head[J.ins_h],J.head[J.ins_h]=J.strstart;while(--J.prev_length!==0);if(J.match_available=0,J.match_length=m-1,J.strstart++,G){if(M0(J,!1),J.strm.avail_out===0)return W0}}else if(J.match_available){if(G=o0(J,0,J.window[J.strstart-1]),G)M0(J,!1);if(J.strstart++,J.lookahead--,J.strm.avail_out===0)return W0}else J.match_available=1,J.strstart++,J.lookahead--}if(J.match_available)G=o0(J,0,J.window[J.strstart-1]),J.match_available=0;if(J.insert=J.strstart<m-1?J.strstart:m-1,q===P0){if(M0(J,!0),J.strm.avail_out===0)return U8;return p8}if(J.sym_next){if(M0(J,!1),J.strm.avail_out===0)return W0}return c8},RX=(J,q)=>{let Q,G,X,V;const Y=J.window;for(;;){if(J.lookahead<=i0){if(b8(J),J.lookahead<=i0&&q===n0)return W0;if(J.lookahead===0)break}if(J.match_length=0,J.lookahead>=m&&J.strstart>0){if(X=J.strstart-1,G=Y[X],G===Y[++X]&&G===Y[++X]&&G===Y[++X]){V=J.strstart+i0;do;while(G===Y[++X]&&G===Y[++X]&&G===Y[++X]&&G===Y[++X]&&G===Y[++X]&&G===Y[++X]&&G===Y[++X]&&G===Y[++X]&&X<V);if(J.match_length=i0-(V-X),J.match_length>J.lookahead)J.match_length=J.lookahead}}if(J.match_length>=m)Q=o0(J,1,J.match_length-m),J.lookahead-=J.match_length,J.strstart+=J.match_length,J.match_length=0;else Q=o0(J,0,J.window[J.strstart]),J.lookahead--,J.strstart++;if(Q){if(M0(J,!1),J.strm.avail_out===0)return W0}}if(J.insert=0,q===P0){if(M0(J,!0),J.strm.avail_out===0)return U8;return p8}if(J.sym_next){if(M0(J,!1),J.strm.avail_out===0)return W0}return c8},TX=(J,q)=>{let Q;for(;;){if(J.lookahead===0){if(b8(J),J.lookahead===0){if(q===n0)return W0;break}}if(J.match_length=0,Q=o0(J,0,J.window[J.strstart]),J.lookahead--,J.strstart++,Q){if(M0(J,!1),J.strm.avail_out===0)return W0}}if(J.insert=0,q===P0){if(M0(J,!0),J.strm.avail_out===0)return U8;return p8}if(J.sym_next){if(M0(J,!1),J.strm.avail_out===0)return W0}return c8},W1=[new S0(0,0,0,0,rq),new S0(4,4,8,4,Y9),new S0(4,5,16,8,Y9),new S0(4,6,32,32,Y9),new S0(4,4,16,16,E8),new S0(8,16,32,32,E8),new S0(8,16,128,128,E8),new S0(8,32,128,256,E8),new S0(32,128,258,1024,E8),new S0(32,258,258,4096,E8)],gX=(J)=>{J.window_size=2*J.w_size,d0(J.head),J.max_lazy_match=W1[J.level].max_lazy,J.good_match=W1[J.level].good_length,J.nice_match=W1[J.level].nice_length,J.max_chain_length=W1[J.level].max_chain,J.strstart=0,J.block_start=0,J.lookahead=0,J.insert=0,J.match_length=J.prev_length=m-1,J.match_available=0,J.ins_h=0},w1=(J)=>{if(!J)return 1;const q=J.state;if(!q||q.strm!==J||q.status!==_8&&q.status!==I9&&q.status!==k9&&q.status!==C9&&q.status!==N9&&q.status!==w9&&q.status!==W8&&q.status!==Z1)return 1;return 0},aq=(J)=>{if(w1(J))return $8(J,I0);J.total_in=J.total_out=0,J.data_type=BX;const q=J.state;if(q.pending=0,q.pending_out=0,q.wrap<0)q.wrap=-q.wrap;return q.status=q.wrap===2?I9:q.wrap?_8:W8,J.adler=q.wrap===2?0:1,q.last_flush=-2,VX(q),V0},sq=(J)=>{const q=aq(J);if(q===V0)gX(J.state);return q},yX=(J,q)=>{if(w1(J)||J.state.wrap!==2)return I0;return J.state.gzhead=q,V0},tq=(J,q,Q,G,X,V)=>{if(!J)return I0;let Y=1;if(q===zX)q=6;if(G<0)Y=0,G=-G;else if(G>15)Y=2,G-=16;if(X<1||X>LX||Q!==$J||G<8||G>15||q<0||q>9||V<0||V>jX||G===8&&Y!==1)return $8(J,I0);if(G===8)G=9;const K=new vX;return J.state=K,K.strm=J,K.status=_8,K.wrap=Y,K.gzhead=null,K.w_bits=G,K.w_size=1<<K.w_bits,K.w_mask=K.w_size-1,K.hash_bits=X+7,K.hash_size=1<<K.hash_bits,K.hash_mask=K.hash_size-1,K.hash_shift=~~((K.hash_bits+m-1)/m),K.window=new Uint8Array(K.w_size*2),K.head=new Uint16Array(K.hash_size),K.prev=new Uint16Array(K.w_size),K.lit_bufsize=1<<X+6,K.pending_buf_size=K.lit_bufsize*4,K.pending_buf=new Uint8Array(K.pending_buf_size),K.sym_buf=K.lit_bufsize,K.sym_end=(K.lit_bufsize-1)*3,K.level=q,K.strategy=V,K.method=Q,sq(J)},EX=(J,q)=>{return tq(J,q,$J,PX,kX,MX)},hX=(J,q)=>{if(w1(J)||q>Jq||q<0)return J?$8(J,I0):I0;const Q=J.state;if(!J.output||J.avail_in!==0&&!J.input||Q.status===Z1&&q!==P0)return $8(J,J.avail_out===0?V9:I0);const G=Q.last_flush;if(Q.last_flush=q,Q.pending!==0){if(j0(J),J.avail_out===0)return Q.last_flush=-1,V0}else if(J.avail_in===0&&qq(q)<=qq(G)&&q!==P0)return $8(J,V9);if(Q.status===Z1&&J.avail_in!==0)return $8(J,V9);if(Q.status===_8&&Q.wrap===0)Q.status=W8;if(Q.status===_8){let X=$J+(Q.w_bits-8<<4)<<8,V=-1;if(Q.strategy>=QJ||Q.level<2)V=0;else if(Q.level<6)V=1;else if(Q.level===6)V=2;else V=3;if(X|=V<<6,Q.strstart!==0)X|=SX;if(X+=31-X%31,K1(Q,X),Q.strstart!==0)K1(Q,J.adler>>>16),K1(Q,J.adler&65535);if(J.adler=1,Q.status=W8,j0(J),Q.pending!==0)return Q.last_flush=-1,V0}if(Q.status===I9)if(J.adler=0,_(Q,31),_(Q,139),_(Q,8),!Q.gzhead){if(_(Q,0),_(Q,0),_(Q,0),_(Q,0),_(Q,0),_(Q,Q.level===9?2:Q.strategy>=QJ||Q.level<2?4:0),_(Q,DX),Q.status=W8,j0(J),Q.pending!==0)return Q.last_flush=-1,V0}else{if(_(Q,(Q.gzhead.text?1:0)+(Q.gzhead.hcrc?2:0)+(!Q.gzhead.extra?0:4)+(!Q.gzhead.name?0:8)+(!Q.gzhead.comment?0:16)),_(Q,Q.gzhead.time&255),_(Q,Q.gzhead.time>>8&255),_(Q,Q.gzhead.time>>16&255),_(Q,Q.gzhead.time>>24&255),_(Q,Q.level===9?2:Q.strategy>=QJ||Q.level<2?4:0),_(Q,Q.gzhead.os&255),Q.gzhead.extra&&Q.gzhead.extra.length)_(Q,Q.gzhead.extra.length&255),_(Q,Q.gzhead.extra.length>>8&255);if(Q.gzhead.hcrc)J.adler=q0(J.adler,Q.pending_buf,Q.pending,0);Q.gzindex=0,Q.status=k9}if(Q.status===k9){if(Q.gzhead.extra){let X=Q.pending,V=(Q.gzhead.extra.length&65535)-Q.gzindex;while(Q.pending+V>Q.pending_buf_size){let K=Q.pending_buf_size-Q.pending;if(Q.pending_buf.set(Q.gzhead.extra.subarray(Q.gzindex,Q.gzindex+K),Q.pending),Q.pending=Q.pending_buf_size,Q.gzhead.hcrc&&Q.pending>X)J.adler=q0(J.adler,Q.pending_buf,Q.pending-X,X);if(Q.gzindex+=K,j0(J),Q.pending!==0)return Q.last_flush=-1,V0;X=0,V-=K}let Y=new Uint8Array(Q.gzhead.extra);if(Q.pending_buf.set(Y.subarray(Q.gzindex,Q.gzindex+V),Q.pending),Q.pending+=V,Q.gzhead.hcrc&&Q.pending>X)J.adler=q0(J.adler,Q.pending_buf,Q.pending-X,X);Q.gzindex=0}Q.status=C9}if(Q.status===C9){if(Q.gzhead.name){let X=Q.pending,V;do{if(Q.pending===Q.pending_buf_size){if(Q.gzhead.hcrc&&Q.pending>X)J.adler=q0(J.adler,Q.pending_buf,Q.pending-X,X);if(j0(J),Q.pending!==0)return Q.last_flush=-1,V0;X=0}if(Q.gzindex<Q.gzhead.name.length)V=Q.gzhead.name.charCodeAt(Q.gzindex++)&255;else V=0;_(Q,V)}while(V!==0);if(Q.gzhead.hcrc&&Q.pending>X)J.adler=q0(J.adler,Q.pending_buf,Q.pending-X,X);Q.gzindex=0}Q.status=N9}if(Q.status===N9){if(Q.gzhead.comment){let X=Q.pending,V;do{if(Q.pending===Q.pending_buf_size){if(Q.gzhead.hcrc&&Q.pending>X)J.adler=q0(J.adler,Q.pending_buf,Q.pending-X,X);if(j0(J),Q.pending!==0)return Q.last_flush=-1,V0;X=0}if(Q.gzindex<Q.gzhead.comment.length)V=Q.gzhead.comment.charCodeAt(Q.gzindex++)&255;else V=0;_(Q,V)}while(V!==0);if(Q.gzhead.hcrc&&Q.pending>X)J.adler=q0(J.adler,Q.pending_buf,Q.pending-X,X)}Q.status=w9}if(Q.status===w9){if(Q.gzhead.hcrc){if(Q.pending+2>Q.pending_buf_size){if(j0(J),Q.pending!==0)return Q.last_flush=-1,V0}_(Q,J.adler&255),_(Q,J.adler>>8&255),J.adler=0}if(Q.status=W8,j0(J),Q.pending!==0)return Q.last_flush=-1,V0}if(J.avail_in!==0||Q.lookahead!==0||q!==n0&&Q.status!==Z1){let X=Q.level===0?rq(Q,q):Q.strategy===QJ?TX(Q,q):Q.strategy===HX?RX(Q,q):W1[Q.level].func(Q,q);if(X===U8||X===p8)Q.status=Z1;if(X===W0||X===U8){if(J.avail_out===0)Q.last_flush=-1;return V0}if(X===c8){if(q===ZX)KX(Q);else if(q!==Jq){if(L9(Q,0,0,!1),q===WX){if(d0(Q.head),Q.lookahead===0)Q.strstart=0,Q.block_start=0,Q.insert=0}}if(j0(J),J.avail_out===0)return Q.last_flush=-1,V0}}if(q!==P0)return V0;if(Q.wrap<=0)return Qq;if(Q.wrap===2)_(Q,J.adler&255),_(Q,J.adler>>8&255),_(Q,J.adler>>16&255),_(Q,J.adler>>24&255),_(Q,J.total_in&255),_(Q,J.total_in>>8&255),_(Q,J.total_in>>16&255),_(Q,J.total_in>>24&255);else K1(Q,J.adler>>>16),K1(Q,J.adler&65535);if(j0(J),Q.wrap>0)Q.wrap=-Q.wrap;return Q.pending!==0?V0:Qq},mX=(J)=>{if(w1(J))return I0;const q=J.state.status;return J.state=null,q===W8?$8(J,$X):V0},_X=(J,q)=>{let Q=q.length;if(w1(J))return I0;const G=J.state,X=G.wrap;if(X===2||X===1&&G.status!==_8||G.lookahead)return I0;if(X===1)J.adler=L1(J.adler,q,Q,0);if(G.wrap=0,Q>=G.w_size){if(X===0)d0(G.head),G.strstart=0,G.block_start=0,G.insert=0;let W=new Uint8Array(G.w_size);W.set(q.subarray(Q-G.w_size,Q),0),q=W,Q=G.w_size}const{avail_in:V,next_in:Y,input:K}=J;J.avail_in=Q,J.next_in=0,J.input=q,b8(G);while(G.lookahead>=m){let W=G.strstart,Z=G.lookahead-(m-1);do G.ins_h=r0(G,G.ins_h,G.window[W+m-1]),G.prev[W&G.w_mask]=G.head[G.ins_h],G.head[G.ins_h]=W,W++;while(--Z);G.strstart=W,G.lookahead=m-1,b8(G)}return G.strstart+=G.lookahead,G.block_start=G.strstart,G.insert=G.lookahead,G.lookahead=0,G.match_length=G.prev_length=m-1,G.match_available=0,J.next_in=Y,J.input=K,J.avail_in=V,G.wrap=X,V0},bX=EX,uX=tq,cX=sq,pX=aq,fX=yX,lX=hX,dX=mX,iX=_X,oX="pako deflate (from Nodeca project)",z1={deflateInit:bX,deflateInit2:uX,deflateReset:cX,deflateResetKeep:pX,deflateSetHeader:fX,deflate:lX,deflateEnd:dX,deflateSetDictionary:iX,deflateInfo:oX},nX=(J,q)=>{return Object.prototype.hasOwnProperty.call(J,q)},rX=function(J){const q=Array.prototype.slice.call(arguments,1);while(q.length){const Q=q.shift();if(!Q)continue;if(typeof Q!=="object")throw new TypeError(Q+"must be non-object");for(let G in Q)if(nX(Q,G))J[G]=Q[G]}return J},aX=(J)=>{let q=0;for(let G=0,X=J.length;G<X;G++)q+=J[G].length;const Q=new Uint8Array(q);for(let G=0,X=0,V=J.length;G<V;G++){let Y=J[G];Q.set(Y,X),X+=Y.length}return Q},zJ={assign:rX,flattenChunks:aX},eq=!0;try{String.fromCharCode.apply(null,new Uint8Array(1))}catch(J){eq=!1}var P1=new Uint8Array(256);for(let J=0;J<256;J++)P1[J]=J>=252?6:J>=248?5:J>=240?4:J>=224?3:J>=192?2:1;P1[254]=P1[254]=1;var sX=(J)=>{if(typeof TextEncoder==="function"&&TextEncoder.prototype.encode)return(new TextEncoder()).encode(J);let q,Q,G,X,V,Y=J.length,K=0;for(X=0;X<Y;X++){if(Q=J.charCodeAt(X),(Q&64512)===55296&&X+1<Y){if(G=J.charCodeAt(X+1),(G&64512)===56320)Q=65536+(Q-55296<<10)+(G-56320),X++}K+=Q<128?1:Q<2048?2:Q<65536?3:4}q=new Uint8Array(K);for(V=0,X=0;V<K;X++){if(Q=J.charCodeAt(X),(Q&64512)===55296&&X+1<Y){if(G=J.charCodeAt(X+1),(G&64512)===56320)Q=65536+(Q-55296<<10)+(G-56320),X++}if(Q<128)q[V++]=Q;else if(Q<2048)q[V++]=192|Q>>>6,q[V++]=128|Q&63;else if(Q<65536)q[V++]=224|Q>>>12,q[V++]=128|Q>>>6&63,q[V++]=128|Q&63;else q[V++]=240|Q>>>18,q[V++]=128|Q>>>12&63,q[V++]=128|Q>>>6&63,q[V++]=128|Q&63}return q},tX=(J,q)=>{if(q<65534){if(J.subarray&&eq)return String.fromCharCode.apply(null,J.length===q?J:J.subarray(0,q))}let Q="";for(let G=0;G<q;G++)Q+=String.fromCharCode(J[G]);return Q},eX=(J,q)=>{const Q=q||J.length;if(typeof TextDecoder==="function"&&TextDecoder.prototype.decode)return(new TextDecoder()).decode(J.subarray(0,q));let G,X;const V=new Array(Q*2);for(X=0,G=0;G<Q;){let Y=J[G++];if(Y<128){V[X++]=Y;continue}let K=P1[Y];if(K>4){V[X++]=65533,G+=K-1;continue}Y&=K===2?31:K===3?15:7;while(K>1&&G<Q)Y=Y<<6|J[G++]&63,K--;if(K>1){V[X++]=65533;continue}if(Y<65536)V[X++]=Y;else Y-=65536,V[X++]=55296|Y>>10&1023,V[X++]=56320|Y&1023}return tX(V,X)},JV=(J,q)=>{if(q=q||J.length,q>J.length)q=J.length;let Q=q-1;while(Q>=0&&(J[Q]&192)===128)Q--;if(Q<0)return q;if(Q===0)return q;return Q+P1[J[Q]]>q?Q:q},k1={string2buf:sX,buf2string:eX,utf8border:JV},J6=QV,Q6=Object.prototype.toString,{Z_NO_FLUSH:qV,Z_SYNC_FLUSH:GV,Z_FULL_FLUSH:XV,Z_FINISH:VV,Z_OK:ZJ,Z_STREAM_END:YV,Z_DEFAULT_COMPRESSION:KV,Z_DEFAULT_STRATEGY:ZV,Z_DEFLATED:WV}=j8;x1.prototype.push=function(J,q){const Q=this.strm,G=this.options.chunkSize;let X,V;if(this.ended)return!1;if(q===~~q)V=q;else V=q===!0?VV:qV;if(typeof J==="string")Q.input=k1.string2buf(J);else if(Q6.call(J)==="[object ArrayBuffer]")Q.input=new Uint8Array(J);else Q.input=J;Q.next_in=0,Q.avail_in=Q.input.length;for(;;){if(Q.avail_out===0)Q.output=new Uint8Array(G),Q.next_out=0,Q.avail_out=G;if((V===GV||V===XV)&&Q.avail_out<=6){this.onData(Q.output.subarray(0,Q.next_out)),Q.avail_out=0;continue}if(X=z1.deflate(Q,V),X===YV){if(Q.next_out>0)this.onData(Q.output.subarray(0,Q.next_out));return X=z1.deflateEnd(this.strm),this.onEnd(X),this.ended=!0,X===ZJ}if(Q.avail_out===0){this.onData(Q.output);continue}if(V>0&&Q.next_out>0){this.onData(Q.output.subarray(0,Q.next_out)),Q.avail_out=0;continue}if(Q.avail_in===0)break}return!0};x1.prototype.onData=function(J){this.chunks.push(J)};x1.prototype.onEnd=function(J){if(J===ZJ)this.result=zJ.flattenChunks(this.chunks);this.chunks=[],this.err=J,this.msg=this.strm.msg};var UV=x1,HV=A9,jV=$V,MV=zV,BV=j8,LV={Deflate:UV,deflate:HV,deflateRaw:jV,gzip:MV,constants:BV},qJ=16209,PV=16191,kV=function J(q,Q){let G,X,V,Y,K,W,Z,$,j,z,U,k,H,M,N,O,F,B,A,D,x,S,y,I;const T=q.state;G=q.next_in,y=q.input,X=G+(q.avail_in-5),V=q.next_out,I=q.output,Y=V-(Q-q.avail_out),K=V+(q.avail_out-257),W=T.dmax,Z=T.wsize,$=T.whave,j=T.wnext,z=T.window,U=T.hold,k=T.bits,H=T.lencode,M=T.distcode,N=(1<<T.lenbits)-1,O=(1<<T.distbits)-1;J:do{if(k<15)U+=y[G++]<<k,k+=8,U+=y[G++]<<k,k+=8;F=H[U&N];Q:for(;;){if(B=F>>>24,U>>>=B,k-=B,B=F>>>16&255,B===0)I[V++]=F&65535;else if(B&16){if(A=F&65535,B&=15,B){if(k<B)U+=y[G++]<<k,k+=8;A+=U&(1<<B)-1,U>>>=B,k-=B}if(k<15)U+=y[G++]<<k,k+=8,U+=y[G++]<<k,k+=8;F=M[U&O];q:for(;;){if(B=F>>>24,U>>>=B,k-=B,B=F>>>16&255,B&16){if(D=F&65535,B&=15,k<B){if(U+=y[G++]<<k,k+=8,k<B)U+=y[G++]<<k,k+=8}if(D+=U&(1<<B)-1,D>W){q.msg="invalid distance too far back",T.mode=qJ;break J}if(U>>>=B,k-=B,B=V-Y,D>B){if(B=D-B,B>$){if(T.sane){q.msg="invalid distance too far back",T.mode=qJ;break J}}if(x=0,S=z,j===0){if(x+=Z-B,B<A){A-=B;do I[V++]=z[x++];while(--B);x=V-D,S=I}}else if(j<B){if(x+=Z+j-B,B-=j,B<A){A-=B;do I[V++]=z[x++];while(--B);if(x=0,j<A){B=j,A-=B;do I[V++]=z[x++];while(--B);x=V-D,S=I}}}else if(x+=j-B,B<A){A-=B;do I[V++]=z[x++];while(--B);x=V-D,S=I}while(A>2)I[V++]=S[x++],I[V++]=S[x++],I[V++]=S[x++],A-=3;if(A){if(I[V++]=S[x++],A>1)I[V++]=S[x++]}}else{x=V-D;do I[V++]=I[x++],I[V++]=I[x++],I[V++]=I[x++],A-=3;while(A>2);if(A){if(I[V++]=I[x++],A>1)I[V++]=I[x++]}}}else if((B&64)===0){F=M[(F&65535)+(U&(1<<B)-1)];continue q}else{q.msg="invalid distance code",T.mode=qJ;break J}break}}else if((B&64)===0){F=H[(F&65535)+(U&(1<<B)-1)];continue Q}else if(B&32){T.mode=PV;break J}else{q.msg="invalid literal/length code",T.mode=qJ;break J}break}}while(G<X&&V<K);A=k>>3,G-=A,k-=A<<3,U&=(1<<k)-1,q.next_in=G,q.next_out=V,q.avail_in=G<X?5+(X-G):5-(G-X),q.avail_out=V<K?257+(K-V):257-(V-K),T.hold=U,T.bits=k;return},h8=15,Gq=852,Xq=592,Vq=0,K9=1,Yq=2,CV=new Uint16Array([3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,0,0]),NV=new Uint8Array([16,16,16,16,16,16,16,16,17,17,17,17,18,18,18,18,19,19,19,19,20,20,20,20,21,21,21,21,16,72,78]),wV=new Uint16Array([1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,0,0]),xV=new Uint8Array([16,16,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,64,64]),OV=(J,q,Q,G,X,V,Y,K)=>{const W=K.bits;let Z=0,$=0,j=0,z=0,U=0,k=0,H=0,M=0,N=0,O=0,F,B,A,D,x,S=null,y;const I=new Uint16Array(h8+1),T=new Uint16Array(h8+1);let C=null,R,L,w;for(Z=0;Z<=h8;Z++)I[Z]=0;for($=0;$<G;$++)I[q[Q+$]]++;U=W;for(z=h8;z>=1;z--)if(I[z]!==0)break;if(U>z)U=z;if(z===0)return X[V++]=1<<24|64<<16|0,X[V++]=1<<24|64<<16|0,K.bits=1,0;for(j=1;j<z;j++)if(I[j]!==0)break;if(U<j)U=j;M=1;for(Z=1;Z<=h8;Z++)if(M<<=1,M-=I[Z],M<0)return-1;if(M>0&&(J===Vq||z!==1))return-1;T[1]=0;for(Z=1;Z<h8;Z++)T[Z+1]=T[Z]+I[Z];for($=0;$<G;$++)if(q[Q+$]!==0)Y[T[q[Q+$]]++]=$;if(J===Vq)S=C=Y,y=20;else if(J===K9)S=CV,C=NV,y=257;else S=wV,C=xV,y=0;if(O=0,$=0,Z=j,x=V,k=U,H=0,A=-1,N=1<<U,D=N-1,J===K9&&N>Gq||J===Yq&&N>Xq)return 1;for(;;){if(R=Z-H,Y[$]+1<y)L=0,w=Y[$];else if(Y[$]>=y)L=C[Y[$]-y],w=S[Y[$]-y];else L=96,w=0;F=1<<Z-H,B=1<<k,j=B;do B-=F,X[x+(O>>H)+B]=R<<24|L<<16|w|0;while(B!==0);F=1<<Z-1;while(O&F)F>>=1;if(F!==0)O&=F-1,O+=F;else O=0;if($++,--I[Z]===0){if(Z===z)break;Z=q[Q+Y[$]]}if(Z>U&&(O&D)!==A){if(H===0)H=U;x+=j,k=Z-H,M=1<<k;while(k+H<z){if(M-=I[k+H],M<=0)break;k++,M<<=1}if(N+=1<<k,J===K9&&N>Gq||J===Yq&&N>Xq)return 1;A=O&D,X[A]=U<<24|k<<16|x-V|0}}if(O!==0)X[x+O]=Z-H<<24|64<<16|0;return K.bits=U,0},U1=OV,FV=0,q6=1,G6=2,{Z_FINISH:Kq,Z_BLOCK:SV,Z_TREES:GJ,Z_OK:H8,Z_STREAM_END:DV,Z_NEED_DICT:IV,Z_STREAM_ERROR:k0,Z_DATA_ERROR:X6,Z_MEM_ERROR:V6,Z_BUF_ERROR:AV,Z_DEFLATED:Zq}=j8,UJ=16180,Wq=16181,$q=16182,zq=16183,Uq=16184,Hq=16185,jq=16186,Mq=16187,Bq=16188,Lq=16189,WJ=16190,h0=16191,Z9=16192,Pq=16193,W9=16194,kq=16195,Cq=16196,Nq=16197,wq=16198,XJ=16199,VJ=16200,xq=16201,Oq=16202,Fq=16203,Sq=16204,Dq=16205,$9=16206,Iq=16207,Aq=16208,d=16209,Y6=16210,K6=16211,RV=852,TV=592,gV=15,vV=gV,Rq=(J)=>{return(J>>>24&255)+(J>>>8&65280)+((J&65280)<<8)+((J&255)<<24)},M8=(J)=>{if(!J)return 1;const q=J.state;if(!q||q.strm!==J||q.mode<UJ||q.mode>K6)return 1;return 0},Z6=(J)=>{if(M8(J))return k0;const q=J.state;if(J.total_in=J.total_out=q.total=0,J.msg="",q.wrap)J.adler=q.wrap&1;return q.mode=UJ,q.last=0,q.havedict=0,q.flags=-1,q.dmax=32768,q.head=null,q.hold=0,q.bits=0,q.lencode=q.lendyn=new Int32Array(RV),q.distcode=q.distdyn=new Int32Array(TV),q.sane=1,q.back=-1,H8},W6=(J)=>{if(M8(J))return k0;const q=J.state;return q.wsize=0,q.whave=0,q.wnext=0,Z6(J)},$6=(J,q)=>{let Q;if(M8(J))return k0;const G=J.state;if(q<0)Q=0,q=-q;else if(Q=(q>>4)+5,q<48)q&=15;if(q&&(q<8||q>15))return k0;if(G.window!==null&&G.wbits!==q)G.window=null;return G.wrap=Q,G.wbits=q,W6(J)},z6=(J,q)=>{if(!J)return k0;const Q=new yV;J.state=Q,Q.strm=J,Q.window=null,Q.mode=UJ;const G=$6(J,q);if(G!==H8)J.state=null;return G},EV=(J)=>{return z6(J,vV)},Tq=!0,z9,U9,hV=(J)=>{if(Tq){z9=new Int32Array(512),U9=new Int32Array(32);let q=0;while(q<144)J.lens[q++]=8;while(q<256)J.lens[q++]=9;while(q<280)J.lens[q++]=7;while(q<288)J.lens[q++]=8;U1(q6,J.lens,0,288,z9,0,J.work,{bits:9}),q=0;while(q<32)J.lens[q++]=5;U1(G6,J.lens,0,32,U9,0,J.work,{bits:5}),Tq=!1}J.lencode=z9,J.lenbits=9,J.distcode=U9,J.distbits=5},U6=(J,q,Q,G)=>{let X;const V=J.state;if(V.window===null)V.wsize=1<<V.wbits,V.wnext=0,V.whave=0,V.window=new Uint8Array(V.wsize);if(G>=V.wsize)V.window.set(q.subarray(Q-V.wsize,Q),0),V.wnext=0,V.whave=V.wsize;else{if(X=V.wsize-V.wnext,X>G)X=G;if(V.window.set(q.subarray(Q-G,Q-G+X),V.wnext),G-=X,G)V.window.set(q.subarray(Q-G,Q),0),V.wnext=G,V.whave=V.wsize;else{if(V.wnext+=X,V.wnext===V.wsize)V.wnext=0;if(V.whave<V.wsize)V.whave+=X}}return 0},mV=(J,q)=>{let Q,G,X,V,Y,K,W,Z,$,j,z,U,k,H,M=0,N,O,F,B,A,D,x,S;const y=new Uint8Array(4);let I,T;const C=new Uint8Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]);if(M8(J)||!J.output||!J.input&&J.avail_in!==0)return k0;if(Q=J.state,Q.mode===h0)Q.mode=Z9;Y=J.next_out,X=J.output,W=J.avail_out,V=J.next_in,G=J.input,K=J.avail_in,Z=Q.hold,$=Q.bits,j=K,z=W,S=H8;J:for(;;)switch(Q.mode){case UJ:if(Q.wrap===0){Q.mode=Z9;break}while($<16){if(K===0)break J;K--,Z+=G[V++]<<$,$+=8}if(Q.wrap&2&&Z===35615){if(Q.wbits===0)Q.wbits=15;Q.check=0,y[0]=Z&255,y[1]=Z>>>8&255,Q.check=q0(Q.check,y,2,0),Z=0,$=0,Q.mode=Wq;break}if(Q.head)Q.head.done=!1;if(!(Q.wrap&1)||(((Z&255)<<8)+(Z>>8))%31){J.msg="incorrect header check",Q.mode=d;break}if((Z&15)!==Zq){J.msg="unknown compression method",Q.mode=d;break}if(Z>>>=4,$-=4,x=(Z&15)+8,Q.wbits===0)Q.wbits=x;if(x>15||x>Q.wbits){J.msg="invalid window size",Q.mode=d;break}Q.dmax=1<<Q.wbits,Q.flags=0,J.adler=Q.check=1,Q.mode=Z&512?Lq:h0,Z=0,$=0;break;case Wq:while($<16){if(K===0)break J;K--,Z+=G[V++]<<$,$+=8}if(Q.flags=Z,(Q.flags&255)!==Zq){J.msg="unknown compression method",Q.mode=d;break}if(Q.flags&57344){J.msg="unknown header flags set",Q.mode=d;break}if(Q.head)Q.head.text=Z>>8&1;if(Q.flags&512&&Q.wrap&4)y[0]=Z&255,y[1]=Z>>>8&255,Q.check=q0(Q.check,y,2,0);Z=0,$=0,Q.mode=$q;case $q:while($<32){if(K===0)break J;K--,Z+=G[V++]<<$,$+=8}if(Q.head)Q.head.time=Z;if(Q.flags&512&&Q.wrap&4)y[0]=Z&255,y[1]=Z>>>8&255,y[2]=Z>>>16&255,y[3]=Z>>>24&255,Q.check=q0(Q.check,y,4,0);Z=0,$=0,Q.mode=zq;case zq:while($<16){if(K===0)break J;K--,Z+=G[V++]<<$,$+=8}if(Q.head)Q.head.xflags=Z&255,Q.head.os=Z>>8;if(Q.flags&512&&Q.wrap&4)y[0]=Z&255,y[1]=Z>>>8&255,Q.check=q0(Q.check,y,2,0);Z=0,$=0,Q.mode=Uq;case Uq:if(Q.flags&1024){while($<16){if(K===0)break J;K--,Z+=G[V++]<<$,$+=8}if(Q.length=Z,Q.head)Q.head.extra_len=Z;if(Q.flags&512&&Q.wrap&4)y[0]=Z&255,y[1]=Z>>>8&255,Q.check=q0(Q.check,y,2,0);Z=0,$=0}else if(Q.head)Q.head.extra=null;Q.mode=Hq;case Hq:if(Q.flags&1024){if(U=Q.length,U>K)U=K;if(U){if(Q.head){if(x=Q.head.extra_len-Q.length,!Q.head.extra)Q.head.extra=new Uint8Array(Q.head.extra_len);Q.head.extra.set(G.subarray(V,V+U),x)}if(Q.flags&512&&Q.wrap&4)Q.check=q0(Q.check,G,U,V);K-=U,V+=U,Q.length-=U}if(Q.length)break J}Q.length=0,Q.mode=jq;case jq:if(Q.flags&2048){if(K===0)break J;U=0;do if(x=G[V+U++],Q.head&&x&&Q.length<65536)Q.head.name+=String.fromCharCode(x);while(x&&U<K);if(Q.flags&512&&Q.wrap&4)Q.check=q0(Q.check,G,U,V);if(K-=U,V+=U,x)break J}else if(Q.head)Q.head.name=null;Q.length=0,Q.mode=Mq;case Mq:if(Q.flags&4096){if(K===0)break J;U=0;do if(x=G[V+U++],Q.head&&x&&Q.length<65536)Q.head.comment+=String.fromCharCode(x);while(x&&U<K);if(Q.flags&512&&Q.wrap&4)Q.check=q0(Q.check,G,U,V);if(K-=U,V+=U,x)break J}else if(Q.head)Q.head.comment=null;Q.mode=Bq;case Bq:if(Q.flags&512){while($<16){if(K===0)break J;K--,Z+=G[V++]<<$,$+=8}if(Q.wrap&4&&Z!==(Q.check&65535)){J.msg="header crc mismatch",Q.mode=d;break}Z=0,$=0}if(Q.head)Q.head.hcrc=Q.flags>>9&1,Q.head.done=!0;J.adler=Q.check=0,Q.mode=h0;break;case Lq:while($<32){if(K===0)break J;K--,Z+=G[V++]<<$,$+=8}J.adler=Q.check=Rq(Z),Z=0,$=0,Q.mode=WJ;case WJ:if(Q.havedict===0)return J.next_out=Y,J.avail_out=W,J.next_in=V,J.avail_in=K,Q.hold=Z,Q.bits=$,IV;J.adler=Q.check=1,Q.mode=h0;case h0:if(q===SV||q===GJ)break J;case Z9:if(Q.last){Z>>>=$&7,$-=$&7,Q.mode=$9;break}while($<3){if(K===0)break J;K--,Z+=G[V++]<<$,$+=8}switch(Q.last=Z&1,Z>>>=1,$-=1,Z&3){case 0:Q.mode=Pq;break;case 1:if(hV(Q),Q.mode=XJ,q===GJ){Z>>>=2,$-=2;break J}break;case 2:Q.mode=Cq;break;case 3:J.msg="invalid block type",Q.mode=d}Z>>>=2,$-=2;break;case Pq:Z>>>=$&7,$-=$&7;while($<32){if(K===0)break J;K--,Z+=G[V++]<<$,$+=8}if((Z&65535)!==(Z>>>16^65535)){J.msg="invalid stored block lengths",Q.mode=d;break}if(Q.length=Z&65535,Z=0,$=0,Q.mode=W9,q===GJ)break J;case W9:Q.mode=kq;case kq:if(U=Q.length,U){if(U>K)U=K;if(U>W)U=W;if(U===0)break J;X.set(G.subarray(V,V+U),Y),K-=U,V+=U,W-=U,Y+=U,Q.length-=U;break}Q.mode=h0;break;case Cq:while($<14){if(K===0)break J;K--,Z+=G[V++]<<$,$+=8}if(Q.nlen=(Z&31)+257,Z>>>=5,$-=5,Q.ndist=(Z&31)+1,Z>>>=5,$-=5,Q.ncode=(Z&15)+4,Z>>>=4,$-=4,Q.nlen>286||Q.ndist>30){J.msg="too many length or distance symbols",Q.mode=d;break}Q.have=0,Q.mode=Nq;case Nq:while(Q.have<Q.ncode){while($<3){if(K===0)break J;K--,Z+=G[V++]<<$,$+=8}Q.lens[C[Q.have++]]=Z&7,Z>>>=3,$-=3}while(Q.have<19)Q.lens[C[Q.have++]]=0;if(Q.lencode=Q.lendyn,Q.lenbits=7,I={bits:Q.lenbits},S=U1(FV,Q.lens,0,19,Q.lencode,0,Q.work,I),Q.lenbits=I.bits,S){J.msg="invalid code lengths set",Q.mode=d;break}Q.have=0,Q.mode=wq;case wq:while(Q.have<Q.nlen+Q.ndist){for(;;){if(M=Q.lencode[Z&(1<<Q.lenbits)-1],N=M>>>24,O=M>>>16&255,F=M&65535,N<=$)break;if(K===0)break J;K--,Z+=G[V++]<<$,$+=8}if(F<16)Z>>>=N,$-=N,Q.lens[Q.have++]=F;else{if(F===16){T=N+2;while($<T){if(K===0)break J;K--,Z+=G[V++]<<$,$+=8}if(Z>>>=N,$-=N,Q.have===0){J.msg="invalid bit length repeat",Q.mode=d;break}x=Q.lens[Q.have-1],U=3+(Z&3),Z>>>=2,$-=2}else if(F===17){T=N+3;while($<T){if(K===0)break J;K--,Z+=G[V++]<<$,$+=8}Z>>>=N,$-=N,x=0,U=3+(Z&7),Z>>>=3,$-=3}else{T=N+7;while($<T){if(K===0)break J;K--,Z+=G[V++]<<$,$+=8}Z>>>=N,$-=N,x=0,U=11+(Z&127),Z>>>=7,$-=7}if(Q.have+U>Q.nlen+Q.ndist){J.msg="invalid bit length repeat",Q.mode=d;break}while(U--)Q.lens[Q.have++]=x}}if(Q.mode===d)break;if(Q.lens[256]===0){J.msg="invalid code -- missing end-of-block",Q.mode=d;break}if(Q.lenbits=9,I={bits:Q.lenbits},S=U1(q6,Q.lens,0,Q.nlen,Q.lencode,0,Q.work,I),Q.lenbits=I.bits,S){J.msg="invalid literal/lengths set",Q.mode=d;break}if(Q.distbits=6,Q.distcode=Q.distdyn,I={bits:Q.distbits},S=U1(G6,Q.lens,Q.nlen,Q.ndist,Q.distcode,0,Q.work,I),Q.distbits=I.bits,S){J.msg="invalid distances set",Q.mode=d;break}if(Q.mode=XJ,q===GJ)break J;case XJ:Q.mode=VJ;case VJ:if(K>=6&&W>=258){if(J.next_out=Y,J.avail_out=W,J.next_in=V,J.avail_in=K,Q.hold=Z,Q.bits=$,kV(J,z),Y=J.next_out,X=J.output,W=J.avail_out,V=J.next_in,G=J.input,K=J.avail_in,Z=Q.hold,$=Q.bits,Q.mode===h0)Q.back=-1;break}Q.back=0;for(;;){if(M=Q.lencode[Z&(1<<Q.lenbits)-1],N=M>>>24,O=M>>>16&255,F=M&65535,N<=$)break;if(K===0)break J;K--,Z+=G[V++]<<$,$+=8}if(O&&(O&240)===0){B=N,A=O,D=F;for(;;){if(M=Q.lencode[D+((Z&(1<<B+A)-1)>>B)],N=M>>>24,O=M>>>16&255,F=M&65535,B+N<=$)break;if(K===0)break J;K--,Z+=G[V++]<<$,$+=8}Z>>>=B,$-=B,Q.back+=B}if(Z>>>=N,$-=N,Q.back+=N,Q.length=F,O===0){Q.mode=Dq;break}if(O&32){Q.back=-1,Q.mode=h0;break}if(O&64){J.msg="invalid literal/length code",Q.mode=d;break}Q.extra=O&15,Q.mode=xq;case xq:if(Q.extra){T=Q.extra;while($<T){if(K===0)break J;K--,Z+=G[V++]<<$,$+=8}Q.length+=Z&(1<<Q.extra)-1,Z>>>=Q.extra,$-=Q.extra,Q.back+=Q.extra}Q.was=Q.length,Q.mode=Oq;case Oq:for(;;){if(M=Q.distcode[Z&(1<<Q.distbits)-1],N=M>>>24,O=M>>>16&255,F=M&65535,N<=$)break;if(K===0)break J;K--,Z+=G[V++]<<$,$+=8}if((O&240)===0){B=N,A=O,D=F;for(;;){if(M=Q.distcode[D+((Z&(1<<B+A)-1)>>B)],N=M>>>24,O=M>>>16&255,F=M&65535,B+N<=$)break;if(K===0)break J;K--,Z+=G[V++]<<$,$+=8}Z>>>=B,$-=B,Q.back+=B}if(Z>>>=N,$-=N,Q.back+=N,O&64){J.msg="invalid distance code",Q.mode=d;break}Q.offset=F,Q.extra=O&15,Q.mode=Fq;case Fq:if(Q.extra){T=Q.extra;while($<T){if(K===0)break J;K--,Z+=G[V++]<<$,$+=8}Q.offset+=Z&(1<<Q.extra)-1,Z>>>=Q.extra,$-=Q.extra,Q.back+=Q.extra}if(Q.offset>Q.dmax){J.msg="invalid distance too far back",Q.mode=d;break}Q.mode=Sq;case Sq:if(W===0)break J;if(U=z-W,Q.offset>U){if(U=Q.offset-U,U>Q.whave){if(Q.sane){J.msg="invalid distance too far back",Q.mode=d;break}}if(U>Q.wnext)U-=Q.wnext,k=Q.wsize-U;else k=Q.wnext-U;if(U>Q.length)U=Q.length;H=Q.window}else H=X,k=Y-Q.offset,U=Q.length;if(U>W)U=W;W-=U,Q.length-=U;do X[Y++]=H[k++];while(--U);if(Q.length===0)Q.mode=VJ;break;case Dq:if(W===0)break J;X[Y++]=Q.length,W--,Q.mode=VJ;break;case $9:if(Q.wrap){while($<32){if(K===0)break J;K--,Z|=G[V++]<<$,$+=8}if(z-=W,J.total_out+=z,Q.total+=z,Q.wrap&4&&z)J.adler=Q.check=Q.flags?q0(Q.check,X,z,Y-z):L1(Q.check,X,z,Y-z);if(z=W,Q.wrap&4&&(Q.flags?Z:Rq(Z))!==Q.check){J.msg="incorrect data check",Q.mode=d;break}Z=0,$=0}Q.mode=Iq;case Iq:if(Q.wrap&&Q.flags){while($<32){if(K===0)break J;K--,Z+=G[V++]<<$,$+=8}if(Q.wrap&4&&Z!==(Q.total&4294967295)){J.msg="incorrect length check",Q.mode=d;break}Z=0,$=0}Q.mode=Aq;case Aq:S=DV;break J;case d:S=X6;break J;case Y6:return V6;case K6:default:return k0}if(J.next_out=Y,J.avail_out=W,J.next_in=V,J.avail_in=K,Q.hold=Z,Q.bits=$,Q.wsize||z!==J.avail_out&&Q.mode<d&&(Q.mode<$9||q!==Kq)){if(U6(J,J.output,J.next_out,z-J.avail_out));}if(j-=J.avail_in,z-=J.avail_out,J.total_in+=j,J.total_out+=z,Q.total+=z,Q.wrap&4&&z)J.adler=Q.check=Q.flags?q0(Q.check,X,z,J.next_out-z):L1(Q.check,X,z,J.next_out-z);if(J.data_type=Q.bits+(Q.last?64:0)+(Q.mode===h0?128:0)+(Q.mode===XJ||Q.mode===W9?256:0),(j===0&&z===0||q===Kq)&&S===H8)S=AV;return S},_V=(J)=>{if(M8(J))return k0;let q=J.state;if(q.window)q.window=null;return J.state=null,H8},bV=(J,q)=>{if(M8(J))return k0;const Q=J.state;if((Q.wrap&2)===0)return k0;return Q.head=q,q.done=!1,H8},uV=(J,q)=>{const Q=q.length;let G,X,V;if(M8(J))return k0;if(G=J.state,G.wrap!==0&&G.mode!==WJ)return k0;if(G.mode===WJ){if(X=1,X=L1(X,q,Q,0),X!==G.check)return X6}if(V=U6(J,q,Q,Q),V)return G.mode=Y6,V6;return G.havedict=1,H8},cV=W6,pV=$6,fV=Z6,lV=EV,dV=z6,iV=mV,oV=_V,nV=bV,rV=uV,aV="pako inflate (from Nodeca project)",_0={inflateReset:cV,inflateReset2:pV,inflateResetKeep:fV,inflateInit:lV,inflateInit2:dV,inflate:iV,inflateEnd:oV,inflateGetHeader:nV,inflateSetDictionary:rV,inflateInfo:aV},tV=sV,H6=Object.prototype.toString,{Z_NO_FLUSH:eV,Z_FINISH:JY,Z_OK:C1,Z_STREAM_END:H9,Z_NEED_DICT:j9,Z_STREAM_ERROR:QY,Z_DATA_ERROR:gq,Z_MEM_ERROR:qY}=j8;O1.prototype.push=function(J,q){const Q=this.strm,G=this.options.chunkSize,X=this.options.dictionary;let V,Y,K;if(this.ended)return!1;if(q===~~q)Y=q;else Y=q===!0?JY:eV;if(H6.call(J)==="[object ArrayBuffer]")Q.input=new Uint8Array(J);else Q.input=J;Q.next_in=0,Q.avail_in=Q.input.length;for(;;){if(Q.avail_out===0)Q.output=new Uint8Array(G),Q.next_out=0,Q.avail_out=G;if(V=_0.inflate(Q,Y),V===j9&&X){if(V=_0.inflateSetDictionary(Q,X),V===C1)V=_0.inflate(Q,Y);else if(V===gq)V=j9}while(Q.avail_in>0&&V===H9&&Q.state.wrap>0&&J[Q.next_in]!==0)_0.inflateReset(Q),V=_0.inflate(Q,Y);switch(V){case QY:case gq:case j9:case qY:return this.onEnd(V),this.ended=!0,!1}if(K=Q.avail_out,Q.next_out){if(Q.avail_out===0||V===H9)if(this.options.to==="string"){let W=k1.utf8border(Q.output,Q.next_out),Z=Q.next_out-W,$=k1.buf2string(Q.output,W);if(Q.next_out=Z,Q.avail_out=G-Z,Z)Q.output.set(Q.output.subarray(W,W+Z),0);this.onData($)}else this.onData(Q.output.length===Q.next_out?Q.output:Q.output.subarray(0,Q.next_out))}if(V===C1&&K===0)continue;if(V===H9)return V=_0.inflateEnd(this.strm),this.onEnd(V),this.ended=!0,!0;if(Q.avail_in===0)break}return!0};O1.prototype.onData=function(J){this.chunks.push(J)};O1.prototype.onEnd=function(J){if(J===C1)if(this.options.to==="string")this.result=this.chunks.join("");else this.result=zJ.flattenChunks(this.chunks);this.chunks=[],this.err=J,this.msg=this.strm.msg};var XY=O1,VY=R9,YY=GY,KY=R9,ZY=j8,WY={Inflate:XY,inflate:VY,inflateRaw:YY,ungzip:KY,constants:ZY},{Deflate:$Y,deflate:zY,deflateRaw:UY,gzip:HY}=LV,{Inflate:jY,inflate:MY,inflateRaw:BY,ungzip:LY}=WY,PY=$Y,kY=zY,CY=UY,NY=HY,wY=jY,xY=MY,OY=BY,FY=LY,SY=j8,T9={Deflate:PY,deflate:kY,deflateRaw:CY,gzip:NY,Inflate:wY,inflate:xY,inflateRaw:OY,ungzip:FY,constants:SY};var j6=function(J){if(!Number.isSafeInteger(J)||J<0)throw new Error("positive integer expected, got "+J)},DY=function(J){return J instanceof Uint8Array||ArrayBuffer.isView(J)&&J.constructor.name==="Uint8Array"},f8=function(J,...q){if(!DY(J))throw new Error("Uint8Array expected");if(q.length>0&&!q.includes(J.length))throw new Error("Uint8Array expected of length "+q+", got length="+J.length)},M6=function(J){if(typeof J!=="function"||typeof J.create!=="function")throw new Error("Hash should be wrapped by utils.wrapConstructor");j6(J.outputLen),j6(J.blockLen)},l8=function(J,q=!0){if(J.destroyed)throw new Error("Hash instance has been destroyed");if(q&&J.finished)throw new Error("Hash#digest() has already been called")},B6=function(J,q){f8(J);const Q=q.outputLen;if(J.length<Q)throw new Error("digestInto() expects output buffer of length at least "+Q)};var B8=typeof globalThis==="object"&&("crypto"in globalThis)?globalThis.crypto:void 0;function HJ(J){return new DataView(J.buffer,J.byteOffset,J.byteLength)}function w0(J,q){return J<<32-q|J>>>q}function IY(J){if(typeof J!=="string")throw new Error("utf8ToBytes expected string, got "+typeof J);return new Uint8Array((new TextEncoder()).encode(J))}function F1(J){if(typeof J==="string")J=IY(J);return f8(J),J}function L6(...J){let q=0;for(let G=0;G<J.length;G++){const X=J[G];f8(X),q+=X.length}const Q=new Uint8Array(q);for(let G=0,X=0;G<J.length;G++){const V=J[G];Q.set(V,X),X+=V.length}return Q}function P6(J){const q=(G)=>J().update(F1(G)).digest(),Q=J();return q.outputLen=Q.outputLen,q.blockLen=Q.blockLen,q.create=()=>J(),q}function jJ(J=32){if(B8&&typeof B8.getRandomValues==="function")return B8.getRandomValues(new Uint8Array(J));if(B8&&typeof B8.randomBytes==="function")return B8.randomBytes(J);throw new Error("crypto.getRandomValues must be defined")}/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */class S1{clone(){return this._cloneInto()}}function AY(J,q,Q,G){if(typeof J.setBigUint64==="function")return J.setBigUint64(q,Q,G);const X=BigInt(32),V=BigInt(4294967295),Y=Number(Q>>X&V),K=Number(Q&V),W=G?4:0,Z=G?0:4;J.setUint32(q+W,Y,G),J.setUint32(q+Z,K,G)}function k6(J,q,Q){return J&q^~J&Q}function C6(J,q,Q){return J&q^J&Q^q&Q}class g9 extends S1{constructor(J,q,Q,G){super();this.blockLen=J,this.outputLen=q,this.padOffset=Q,this.isLE=G,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(J),this.view=HJ(this.buffer)}update(J){l8(this);const{view:q,buffer:Q,blockLen:G}=this;J=F1(J);const X=J.length;for(let V=0;V<X;){const Y=Math.min(G-this.pos,X-V);if(Y===G){const K=HJ(J);for(;G<=X-V;V+=G)this.process(K,V);continue}if(Q.set(J.subarray(V,V+Y),this.pos),this.pos+=Y,V+=Y,this.pos===G)this.process(q,0),this.pos=0}return this.length+=J.length,this.roundClean(),this}digestInto(J){l8(this),B6(J,this),this.finished=!0;const{buffer:q,view:Q,blockLen:G,isLE:X}=this;let{pos:V}=this;if(q[V++]=128,this.buffer.subarray(V).fill(0),this.padOffset>G-V)this.process(Q,0),V=0;for(let $=V;$<G;$++)q[$]=0;AY(Q,G-8,BigInt(this.length*8),X),this.process(Q,0);const Y=HJ(J),K=this.outputLen;if(K%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const W=K/4,Z=this.get();if(W>Z.length)throw new Error("_sha2: outputLen bigger than state");for(let $=0;$<W;$++)Y.setUint32(4*$,Z[$],X)}digest(){const{buffer:J,outputLen:q}=this;this.digestInto(J);const Q=J.slice(0,q);return this.destroy(),Q}_cloneInto(J){J||(J=new this.constructor),J.set(...this.get());const{blockLen:q,buffer:Q,length:G,finished:X,destroyed:V,pos:Y}=this;if(J.length=G,J.pos=Y,J.finished=X,J.destroyed=V,G%q)J.buffer.set(Q);return J}}var RY=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),a0=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),s0=new Uint32Array(64);class N6 extends g9{constructor(){super(64,32,8,!1);this.A=a0[0]|0,this.B=a0[1]|0,this.C=a0[2]|0,this.D=a0[3]|0,this.E=a0[4]|0,this.F=a0[5]|0,this.G=a0[6]|0,this.H=a0[7]|0}get(){const{A:J,B:q,C:Q,D:G,E:X,F:V,G:Y,H:K}=this;return[J,q,Q,G,X,V,Y,K]}set(J,q,Q,G,X,V,Y,K){this.A=J|0,this.B=q|0,this.C=Q|0,this.D=G|0,this.E=X|0,this.F=V|0,this.G=Y|0,this.H=K|0}process(J,q){for(let $=0;$<16;$++,q+=4)s0[$]=J.getUint32(q,!1);for(let $=16;$<64;$++){const j=s0[$-15],z=s0[$-2],U=w0(j,7)^w0(j,18)^j>>>3,k=w0(z,17)^w0(z,19)^z>>>10;s0[$]=k+s0[$-7]+U+s0[$-16]|0}let{A:Q,B:G,C:X,D:V,E:Y,F:K,G:W,H:Z}=this;for(let $=0;$<64;$++){const j=w0(Y,6)^w0(Y,11)^w0(Y,25),z=Z+j+k6(Y,K,W)+RY[$]+s0[$]|0,k=(w0(Q,2)^w0(Q,13)^w0(Q,22))+C6(Q,G,X)|0;Z=W,W=K,K=Y,Y=V+z|0,V=X,X=G,G=Q,Q=z+k|0}Q=Q+this.A|0,G=G+this.B|0,X=X+this.C|0,V=V+this.D|0,Y=Y+this.E|0,K=K+this.F|0,W=W+this.G|0,Z=Z+this.H|0,this.set(Q,G,X,V,Y,K,W,Z)}roundClean(){s0.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}}var MJ=P6(()=>new N6);class v9 extends S1{constructor(J,q){super();this.finished=!1,this.destroyed=!1,M6(J);const Q=F1(q);if(this.iHash=J.create(),typeof this.iHash.update!=="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const G=this.blockLen,X=new Uint8Array(G);X.set(Q.length>G?J.create().update(Q).digest():Q);for(let V=0;V<X.length;V++)X[V]^=54;this.iHash.update(X),this.oHash=J.create();for(let V=0;V<X.length;V++)X[V]^=54^92;this.oHash.update(X),X.fill(0)}update(J){return l8(this),this.iHash.update(J),this}digestInto(J){l8(this),f8(J,this.outputLen),this.finished=!0,this.iHash.digestInto(J),this.oHash.update(J),this.oHash.digestInto(J),this.destroy()}digest(){const J=new Uint8Array(this.oHash.outputLen);return this.digestInto(J),J}_cloneInto(J){J||(J=Object.create(Object.getPrototypeOf(this),{}));const{oHash:q,iHash:Q,finished:G,destroyed:X,blockLen:V,outputLen:Y}=this;return J=J,J.finished=G,J.destroyed=X,J.blockLen=V,J.outputLen=Y,J.oHash=q._cloneInto(J.oHash),J.iHash=Q._cloneInto(J.iHash),J}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}var y9=(J,q,Q)=>new v9(J,q).update(Q).digest();y9.create=(J,q)=>new v9(J,q);var u9={};mQ(u9,{validateObject:()=>{{return J8}},utf8ToBytes:()=>{{return EY}},numberToVarBytesBE:()=>{{return vY}},numberToHexUnpadded:()=>{{return k8}},numberToBytesLE:()=>{{return kJ}},numberToBytesBE:()=>{{return x0}},notImplemented:()=>{{return bY}},memoized:()=>{{return CJ}},isBytes:()=>{{return t0}},inRange:()=>{{return e0}},hexToNumber:()=>{{return m9}},hexToBytes:()=>{{return C8}},equalBytes:()=>{{return yY}},ensureBytes:()=>{{return e}},createHmacDrbg:()=>{{return b9}},concatBytes:()=>{{return u0}},bytesToNumberLE:()=>{{return PJ}},bytesToNumberBE:()=>{{return C0}},bytesToHex:()=>{{return P8}},bitSet:()=>{{return mY}},bitMask:()=>{{return D1}},bitLen:()=>{{return _9}},bitGet:()=>{{return hY}},abytes:()=>{{return d8}},abool:()=>{{return L8}},aInRange:()=>{{return R0}}});function t0(J){return J instanceof Uint8Array||ArrayBuffer.isView(J)&&J.constructor.name==="Uint8Array"}function d8(J){if(!t0(J))throw new Error("Uint8Array expected")}function L8(J,q){if(typeof q!=="boolean")throw new Error(J+" boolean expected, got "+q)}function P8(J){d8(J);let q="";for(let Q=0;Q<J.length;Q++)q+=gY[J[Q]];return q}function k8(J){const q=J.toString(16);return q.length&1?"0"+q:q}function m9(J){if(typeof J!=="string")throw new Error("hex string expected, got "+typeof J);return J===""?BJ:BigInt("0x"+J)}var w6=function(J){if(J>=b0._0&&J<=b0._9)return J-b0._0;if(J>=b0.A&&J<=b0.F)return J-(b0.A-10);if(J>=b0.a&&J<=b0.f)return J-(b0.a-10);return};function C8(J){if(typeof J!=="string")throw new Error("hex string expected, got "+typeof J);const q=J.length,Q=q/2;if(q%2)throw new Error("hex string expected, got unpadded hex of length "+q);const G=new Uint8Array(Q);for(let X=0,V=0;X<Q;X++,V+=2){const Y=w6(J.charCodeAt(V)),K=w6(J.charCodeAt(V+1));if(Y===void 0||K===void 0){const W=J[V]+J[V+1];throw new Error('hex string expected, got non-hex character "'+W+'" at index '+V)}G[X]=Y*16+K}return G}function C0(J){return m9(P8(J))}function PJ(J){return d8(J),m9(P8(Uint8Array.from(J).reverse()))}function x0(J,q){return C8(J.toString(16).padStart(q*2,"0"))}function kJ(J,q){return x0(J,q).reverse()}function vY(J){return C8(k8(J))}function e(J,q,Q){let G;if(typeof q==="string")try{G=C8(q)}catch(V){throw new Error(J+" must be hex string or Uint8Array, cause: "+V)}else if(t0(q))G=Uint8Array.from(q);else throw new Error(J+" must be hex string or Uint8Array");const X=G.length;if(typeof Q==="number"&&X!==Q)throw new Error(J+" of length "+Q+" expected, got "+X);return G}function u0(...J){let q=0;for(let G=0;G<J.length;G++){const X=J[G];d8(X),q+=X.length}const Q=new Uint8Array(q);for(let G=0,X=0;G<J.length;G++){const V=J[G];Q.set(V,X),X+=V.length}return Q}function yY(J,q){if(J.length!==q.length)return!1;let Q=0;for(let G=0;G<J.length;G++)Q|=J[G]^q[G];return Q===0}function EY(J){if(typeof J!=="string")throw new Error("string expected");return new Uint8Array((new TextEncoder()).encode(J))}function e0(J,q,Q){return E9(J)&&E9(q)&&E9(Q)&&q<=J&&J<Q}function R0(J,q,Q,G){if(!e0(q,Q,G))throw new Error("expected valid "+J+": "+Q+" <= n < "+G+", got "+q)}function _9(J){let q;for(q=0;J>BJ;J>>=LJ,q+=1);return q}function hY(J,q){return J>>BigInt(q)&LJ}function mY(J,q,Q){return J|(Q?LJ:BJ)<<BigInt(q)}function b9(J,q,Q){if(typeof J!=="number"||J<2)throw new Error("hashLen must be a number");if(typeof q!=="number"||q<2)throw new Error("qByteLen must be a number");if(typeof Q!=="function")throw new Error("hmacFn must be a function");let G=h9(J),X=h9(J),V=0;const Y=()=>{G.fill(1),X.fill(0),V=0},K=(...j)=>Q(X,G,...j),W=(j=h9())=>{if(X=K(x6([0]),j),G=K(),j.length===0)return;X=K(x6([1]),j),G=K()},Z=()=>{if(V++>=1000)throw new Error("drbg: tried 1000 values");let j=0;const z=[];while(j<q){G=K();const U=G.slice();z.push(U),j+=G.length}return u0(...z)};return(j,z)=>{Y(),W(j);let U=void 0;while(!(U=z(Z())))W();return Y(),U}}function J8(J,q,Q={}){const G=(X,V,Y)=>{const K=_Y[V];if(typeof K!=="function")throw new Error("invalid validator function");const W=J[X];if(Y&&W===void 0)return;if(!K(W,J))throw new Error("param "+String(X)+" is invalid. Expected "+V+", got "+W)};for(let[X,V]of Object.entries(q))G(X,V,!1);for(let[X,V]of Object.entries(Q))G(X,V,!0);return J}function CJ(J){const q=new WeakMap;return(Q,...G)=>{const X=q.get(Q);if(X!==void 0)return X;const V=J(Q,...G);return q.set(Q,V),V}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */var BJ=BigInt(0),LJ=BigInt(1),TY=BigInt(2),gY=Array.from({length:256},(J,q)=>q.toString(16).padStart(2,"0")),b0={_0:48,_9:57,A:65,F:70,a:97,f:102},E9=(J)=>typeof J==="bigint"&&BJ<=J,D1=(J)=>(TY<<BigInt(J-1))-LJ,h9=(J)=>new Uint8Array(J),x6=(J)=>Uint8Array.from(J),_Y={bigint:(J)=>typeof J==="bigint",function:(J)=>typeof J==="function",boolean:(J)=>typeof J==="boolean",string:(J)=>typeof J==="string",stringOrUint8Array:(J)=>typeof J==="string"||t0(J),isSafeInteger:(J)=>Number.isSafeInteger(J),array:(J)=>Array.isArray(J),field:(J,q)=>q.Fp.isValid(J),hash:(J)=>typeof J==="function"&&Number.isSafeInteger(J.outputLen)},bY=()=>{throw new Error("not implemented")};function J0(J,q){const Q=J%q;return Q>=Q0?Q:q+Q}function fY(J,q,Q){if(q<Q0)throw new Error("invalid exponent, negatives unsupported");if(Q<=Q0)throw new Error("invalid modulus");if(Q===r)return Q0;let G=r;while(q>Q0){if(q&r)G=G*J%Q;J=J*J%Q,q>>=r}return G}function B0(J,q,Q){let G=J;while(q-- >Q0)G*=G,G%=Q;return G}function NJ(J,q){if(J===Q0)throw new Error("invert: expected non-zero number");if(q<=Q0)throw new Error("invert: expected positive modulus, got "+q);let Q=J0(J,q),G=q,X=Q0,V=r,Y=r,K=Q0;while(Q!==Q0){const Z=G/Q,$=G%Q,j=X-Y*Z,z=V-K*Z;G=Q,Q=$,X=Y,V=K,Y=j,K=z}if(G!==r)throw new Error("invert: does not exist");return J0(X,q)}function lY(J){const q=(J-r)/N8;let Q,G,X;for(Q=J-r,G=0;Q%N8===Q0;Q/=N8,G++);for(X=N8;X<J&&fY(X,q,J)!==J-r;X++)if(X>1000)throw new Error("Cannot find square root: likely non-prime P");if(G===1){const Y=(J+r)/c9;return function K(W,Z){const $=W.pow(Z,Y);if(!W.eql(W.sqr($),Z))throw new Error("Cannot find square root");return $}}const V=(Q+r)/N8;return function Y(K,W){if(K.pow(W,q)===K.neg(K.ONE))throw new Error("Cannot find square root");let Z=G,$=K.pow(K.mul(K.ONE,X),Q),j=K.pow(W,V),z=K.pow(W,Q);while(!K.eql(z,K.ONE)){if(K.eql(z,K.ZERO))return K.ZERO;let U=1;for(let H=K.sqr(z);U<Z;U++){if(K.eql(H,K.ONE))break;H=K.sqr(H)}const k=K.pow($,r<<BigInt(Z-U-1));$=K.sqr(k),j=K.mul(j,k),z=K.mul(z,$),Z=U}return j}}function dY(J){if(J%c9===uY){const q=(J+r)/c9;return function Q(G,X){const V=G.pow(X,q);if(!G.eql(G.sqr(V),X))throw new Error("Cannot find square root");return V}}if(J%F6===O6){const q=(J-O6)/F6;return function Q(G,X){const V=G.mul(X,N8),Y=G.pow(V,q),K=G.mul(X,Y),W=G.mul(G.mul(K,N8),Y),Z=G.mul(K,G.sub(W,G.ONE));if(!G.eql(G.sqr(Z),X))throw new Error("Cannot find square root");return Z}}if(J%pY===cY);return lY(J)}function p9(J){const q={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},Q=iY.reduce((G,X)=>{return G[X]="function",G},q);return J8(J,Q)}function oY(J,q,Q){if(Q<Q0)throw new Error("invalid exponent, negatives unsupported");if(Q===Q0)return J.ONE;if(Q===r)return q;let G=J.ONE,X=q;while(Q>Q0){if(Q&r)G=J.mul(G,X);X=J.sqr(X),Q>>=r}return G}function nY(J,q){const Q=new Array(q.length),G=q.reduce((V,Y,K)=>{if(J.is0(Y))return V;return Q[K]=V,J.mul(V,Y)},J.ONE),X=J.inv(G);return q.reduceRight((V,Y,K)=>{if(J.is0(Y))return V;return Q[K]=J.mul(V,Q[K]),J.mul(V,Y)},X),Q}function f9(J,q){const Q=q!==void 0?q:J.toString(2).length,G=Math.ceil(Q/8);return{nBitLength:Q,nByteLength:G}}function wJ(J,q,Q=!1,G={}){if(J<=Q0)throw new Error("invalid field: expected ORDER > 0, got "+J);const{nBitLength:X,nByteLength:V}=f9(J,q);if(V>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let Y;const K=Object.freeze({ORDER:J,isLE:Q,BITS:X,BYTES:V,MASK:D1(X),ZERO:Q0,ONE:r,create:(W)=>J0(W,J),isValid:(W)=>{if(typeof W!=="bigint")throw new Error("invalid field element: expected bigint, got "+typeof W);return Q0<=W&&W<J},is0:(W)=>W===Q0,isOdd:(W)=>(W&r)===r,neg:(W)=>J0(-W,J),eql:(W,Z)=>W===Z,sqr:(W)=>J0(W*W,J),add:(W,Z)=>J0(W+Z,J),sub:(W,Z)=>J0(W-Z,J),mul:(W,Z)=>J0(W*Z,J),pow:(W,Z)=>oY(K,W,Z),div:(W,Z)=>J0(W*NJ(Z,J),J),sqrN:(W)=>W*W,addN:(W,Z)=>W+Z,subN:(W,Z)=>W-Z,mulN:(W,Z)=>W*Z,inv:(W)=>NJ(W,J),sqrt:G.sqrt||((W)=>{if(!Y)Y=dY(J);return Y(K,W)}),invertBatch:(W)=>nY(K,W),cmov:(W,Z,$)=>$?Z:W,toBytes:(W)=>Q?kJ(W,V):x0(W,V),fromBytes:(W)=>{if(W.length!==V)throw new Error("Field.fromBytes: expected "+V+" bytes, got "+W.length);return Q?PJ(W):C0(W)}});return Object.freeze(K)}function S6(J){if(typeof J!=="bigint")throw new Error("field order must be bigint");const q=J.toString(2).length;return Math.ceil(q/8)}function l9(J){const q=S6(J);return q+Math.ceil(q/2)}function D6(J,q,Q=!1){const G=J.length,X=S6(q),V=l9(q);if(G<16||G<V||G>1024)throw new Error("expected "+V+"-1024 bytes of input, got "+G);const Y=Q?PJ(J):C0(J),K=J0(Y,q-r)+r;return Q?kJ(K,X):x0(K,X)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */var Q0=BigInt(0),r=BigInt(1),N8=BigInt(2),uY=BigInt(3),c9=BigInt(4),O6=BigInt(5),F6=BigInt(8),cY=BigInt(9),pY=BigInt(16);var iY=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];var d9=function(J,q){const Q=q.negate();return J?Q:q},A6=function(J,q){if(!Number.isSafeInteger(J)||J<=0||J>q)throw new Error("invalid window size, expected [1.."+q+"], got W="+J)},i9=function(J,q){A6(J,q);const Q=Math.ceil(q/J)+1,G=2**(J-1);return{windows:Q,windowSize:G}},rY=function(J,q){if(!Array.isArray(J))throw new Error("array expected");J.forEach((Q,G)=>{if(!(Q instanceof q))throw new Error("invalid point at index "+G)})},aY=function(J,q){if(!Array.isArray(J))throw new Error("array of scalars expected");J.forEach((Q,G)=>{if(!q.isValid(Q))throw new Error("invalid scalar at index "+G)})},n9=function(J){return R6.get(J)||1};function T6(J,q){return{constTimeNegate:d9,hasPrecomputes(Q){return n9(Q)!==1},unsafeLadder(Q,G,X=J.ZERO){let V=Q;while(G>I6){if(G&xJ)X=X.add(V);V=V.double(),G>>=xJ}return X},precomputeWindow(Q,G){const{windows:X,windowSize:V}=i9(G,q),Y=[];let K=Q,W=K;for(let Z=0;Z<X;Z++){W=K,Y.push(W);for(let $=1;$<V;$++)W=W.add(K),Y.push(W);K=W.double()}return Y},wNAF(Q,G,X){const{windows:V,windowSize:Y}=i9(Q,q);let{ZERO:K,BASE:W}=J;const Z=BigInt(2**Q-1),$=2**Q,j=BigInt(Q);for(let z=0;z<V;z++){const U=z*Y;let k=Number(X&Z);if(X>>=j,k>Y)k-=$,X+=xJ;const H=U,M=U+Math.abs(k)-1,N=z%2!==0,O=k<0;if(k===0)W=W.add(d9(N,G[H]));else K=K.add(d9(O,G[M]))}return{p:K,f:W}},wNAFUnsafe(Q,G,X,V=J.ZERO){const{windows:Y,windowSize:K}=i9(Q,q),W=BigInt(2**Q-1),Z=2**Q,$=BigInt(Q);for(let j=0;j<Y;j++){const z=j*K;if(X===I6)break;let U=Number(X&W);if(X>>=$,U>K)U-=Z,X+=xJ;if(U===0)continue;let k=G[z+Math.abs(U)-1];if(U<0)k=k.negate();V=V.add(k)}return V},getPrecomputes(Q,G,X){let V=o9.get(G);if(!V){if(V=this.precomputeWindow(G,Q),Q!==1)o9.set(G,X(V))}return V},wNAFCached(Q,G,X){const V=n9(Q);return this.wNAF(V,this.getPrecomputes(V,Q,X),G)},wNAFCachedUnsafe(Q,G,X,V){const Y=n9(Q);if(Y===1)return this.unsafeLadder(Q,G,V);return this.wNAFUnsafe(Y,this.getPrecomputes(Y,Q,X),G,V)},setWindowSize(Q,G){A6(G,q),R6.set(Q,G),o9.delete(Q)}}}function g6(J,q,Q,G){if(rY(Q,J),aY(G,q),Q.length!==G.length)throw new Error("arrays of points and scalars must have equal length");const X=J.ZERO,V=_9(BigInt(Q.length)),Y=V>12?V-3:V>4?V-2:V?2:1,K=(1<<Y)-1,W=new Array(K+1).fill(X),Z=Math.floor((q.BITS-1)/Y)*Y;let $=X;for(let j=Z;j>=0;j-=Y){W.fill(X);for(let U=0;U<G.length;U++){const k=G[U],H=Number(k>>BigInt(j)&BigInt(K));W[H]=W[H].add(Q[U])}let z=X;for(let U=W.length-1,k=X;U>0;U--)k=k.add(W[U]),z=z.add(k);if($=$.add(z),j!==0)for(let U=0;U<Y;U++)$=$.double()}return $}function r9(J){return p9(J.Fp),J8(J,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...f9(J.n,J.nBitLength),...J,...{p:J.Fp.ORDER}})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */var I6=BigInt(0),xJ=BigInt(1),o9=new WeakMap,R6=new WeakMap;var v6=function(J){if(J.lowS!==void 0)L8("lowS",J.lowS);if(J.prehash!==void 0)L8("prehash",J.prehash)},sY=function(J){const q=r9(J);J8(q,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});const{endo:Q,Fp:G,a:X}=q;if(Q){if(!G.eql(X,G.ZERO))throw new Error("invalid endomorphism, can only be defined for Koblitz curves that have a=0");if(typeof Q!=="object"||typeof Q.beta!=="bigint"||typeof Q.splitScalar!=="function")throw new Error("invalid endomorphism, expected beta: bigint and splitScalar: function")}return Object.freeze({...q})};function JK(J){const q=sY(J),{Fp:Q}=q,G=wJ(q.n,q.nBitLength),X=q.toBytes||((H,M,N)=>{const O=M.toAffine();return u0(Uint8Array.from([4]),Q.toBytes(O.x),Q.toBytes(O.y))}),V=q.fromBytes||((H)=>{const M=H.subarray(1),N=Q.fromBytes(M.subarray(0,Q.BYTES)),O=Q.fromBytes(M.subarray(Q.BYTES,2*Q.BYTES));return{x:N,y:O}});function Y(H){const{a:M,b:N}=q,O=Q.sqr(H),F=Q.mul(O,H);return Q.add(Q.add(F,Q.mul(H,M)),N)}if(!Q.eql(Q.sqr(q.Gy),Y(q.Gx)))throw new Error("bad generator point: equation left != right");function K(H){return e0(H,G0,q.n)}function W(H){const{allowedPrivateKeyLengths:M,nByteLength:N,wrapPrivateKey:O,n:F}=q;if(M&&typeof H!=="bigint"){if(t0(H))H=P8(H);if(typeof H!=="string"||!M.includes(H.length))throw new Error("invalid private key");H=H.padStart(N*2,"0")}let B;try{B=typeof H==="bigint"?H:C0(e("private key",H,N))}catch(A){throw new Error("invalid private key, expected hex or "+N+" bytes, got "+typeof H)}if(O)B=J0(B,F);return R0("private key",B,G0,F),B}function Z(H){if(!(H instanceof z))throw new Error("ProjectivePoint expected")}const $=CJ((H,M)=>{const{px:N,py:O,pz:F}=H;if(Q.eql(F,Q.ONE))return{x:N,y:O};const B=H.is0();if(M==null)M=B?Q.ONE:Q.inv(F);const A=Q.mul(N,M),D=Q.mul(O,M),x=Q.mul(F,M);if(B)return{x:Q.ZERO,y:Q.ZERO};if(!Q.eql(x,Q.ONE))throw new Error("invZ was invalid");return{x:A,y:D}}),j=CJ((H)=>{if(H.is0()){if(q.allowInfinityPoint&&!Q.is0(H.py))return;throw new Error("bad point: ZERO")}const{x:M,y:N}=H.toAffine();if(!Q.isValid(M)||!Q.isValid(N))throw new Error("bad point: x or y not FE");const O=Q.sqr(N),F=Y(M);if(!Q.eql(O,F))throw new Error("bad point: equation left != right");if(!H.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});class z{constructor(H,M,N){if(this.px=H,this.py=M,this.pz=N,H==null||!Q.isValid(H))throw new Error("x required");if(M==null||!Q.isValid(M))throw new Error("y required");if(N==null||!Q.isValid(N))throw new Error("z required");Object.freeze(this)}static fromAffine(H){const{x:M,y:N}=H||{};if(!H||!Q.isValid(M)||!Q.isValid(N))throw new Error("invalid affine point");if(H instanceof z)throw new Error("projective point not allowed");const O=(F)=>Q.eql(F,Q.ZERO);if(O(M)&&O(N))return z.ZERO;return new z(M,N,Q.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(H){const M=Q.invertBatch(H.map((N)=>N.pz));return H.map((N,O)=>N.toAffine(M[O])).map(z.fromAffine)}static fromHex(H){const M=z.fromAffine(V(e("pointHex",H)));return M.assertValidity(),M}static fromPrivateKey(H){return z.BASE.multiply(W(H))}static msm(H,M){return g6(z,G,H,M)}_setWindowSize(H){k.setWindowSize(this,H)}assertValidity(){j(this)}hasEvenY(){const{y:H}=this.toAffine();if(Q.isOdd)return!Q.isOdd(H);throw new Error("Field doesn't support isOdd")}equals(H){Z(H);const{px:M,py:N,pz:O}=this,{px:F,py:B,pz:A}=H,D=Q.eql(Q.mul(M,A),Q.mul(F,O)),x=Q.eql(Q.mul(N,A),Q.mul(B,O));return D&&x}negate(){return new z(this.px,Q.neg(this.py),this.pz)}double(){const{a:H,b:M}=q,N=Q.mul(M,y6),{px:O,py:F,pz:B}=this;let{ZERO:A,ZERO:D,ZERO:x}=Q,S=Q.mul(O,O),y=Q.mul(F,F),I=Q.mul(B,B),T=Q.mul(O,F);return T=Q.add(T,T),x=Q.mul(O,B),x=Q.add(x,x),A=Q.mul(H,x),D=Q.mul(N,I),D=Q.add(A,D),A=Q.sub(y,D),D=Q.add(y,D),D=Q.mul(A,D),A=Q.mul(T,A),x=Q.mul(N,x),I=Q.mul(H,I),T=Q.sub(S,I),T=Q.mul(H,T),T=Q.add(T,x),x=Q.add(S,S),S=Q.add(x,S),S=Q.add(S,I),S=Q.mul(S,T),D=Q.add(D,S),I=Q.mul(F,B),I=Q.add(I,I),S=Q.mul(I,T),A=Q.sub(A,S),x=Q.mul(I,y),x=Q.add(x,x),x=Q.add(x,x),new z(A,D,x)}add(H){Z(H);const{px:M,py:N,pz:O}=this,{px:F,py:B,pz:A}=H;let{ZERO:D,ZERO:x,ZERO:S}=Q;const y=q.a,I=Q.mul(q.b,y6);let T=Q.mul(M,F),C=Q.mul(N,B),R=Q.mul(O,A),L=Q.add(M,N),w=Q.add(F,B);L=Q.mul(L,w),w=Q.add(T,C),L=Q.sub(L,w),w=Q.add(M,O);let P=Q.add(F,A);return w=Q.mul(w,P),P=Q.add(T,R),w=Q.sub(w,P),P=Q.add(N,O),D=Q.add(B,A),P=Q.mul(P,D),D=Q.add(C,R),P=Q.sub(P,D),S=Q.mul(y,w),D=Q.mul(I,R),S=Q.add(D,S),D=Q.sub(C,S),S=Q.add(C,S),x=Q.mul(D,S),C=Q.add(T,T),C=Q.add(C,T),R=Q.mul(y,R),w=Q.mul(I,w),C=Q.add(C,R),R=Q.sub(T,R),R=Q.mul(y,R),w=Q.add(w,R),T=Q.mul(C,w),x=Q.add(x,T),T=Q.mul(P,w),D=Q.mul(L,D),D=Q.sub(D,T),T=Q.mul(L,C),S=Q.mul(P,S),S=Q.add(S,T),new z(D,x,S)}subtract(H){return this.add(H.negate())}is0(){return this.equals(z.ZERO)}wNAF(H){return k.wNAFCached(this,H,z.normalizeZ)}multiplyUnsafe(H){const{endo:M,n:N}=q;R0("scalar",H,p0,N);const O=z.ZERO;if(H===p0)return O;if(this.is0()||H===G0)return this;if(!M||k.hasPrecomputes(this))return k.wNAFCachedUnsafe(this,H,z.normalizeZ);let{k1neg:F,k1:B,k2neg:A,k2:D}=M.splitScalar(H),x=O,S=O,y=this;while(B>p0||D>p0){if(B&G0)x=x.add(y);if(D&G0)S=S.add(y);y=y.double(),B>>=G0,D>>=G0}if(F)x=x.negate();if(A)S=S.negate();return S=new z(Q.mul(S.px,M.beta),S.py,S.pz),x.add(S)}multiply(H){const{endo:M,n:N}=q;R0("scalar",H,G0,N);let O,F;if(M){const{k1neg:B,k1:A,k2neg:D,k2:x}=M.splitScalar(H);let{p:S,f:y}=this.wNAF(A),{p:I,f:T}=this.wNAF(x);S=k.constTimeNegate(B,S),I=k.constTimeNegate(D,I),I=new z(Q.mul(I.px,M.beta),I.py,I.pz),O=S.add(I),F=y.add(T)}else{const{p:B,f:A}=this.wNAF(H);O=B,F=A}return z.normalizeZ([O,F])[0]}multiplyAndAddUnsafe(H,M,N){const O=z.BASE,F=(A,D)=>D===p0||D===G0||!A.equals(O)?A.multiplyUnsafe(D):A.multiply(D),B=F(this,M).add(F(H,N));return B.is0()?void 0:B}toAffine(H){return $(this,H)}isTorsionFree(){const{h:H,isTorsionFree:M}=q;if(H===G0)return!0;if(M)return M(z,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:H,clearCofactor:M}=q;if(H===G0)return this;if(M)return M(z,this);return this.multiplyUnsafe(q.h)}toRawBytes(H=!0){return L8("isCompressed",H),this.assertValidity(),X(z,this,H)}toHex(H=!0){return L8("isCompressed",H),P8(this.toRawBytes(H))}}z.BASE=new z(q.Gx,q.Gy,Q.ONE),z.ZERO=new z(Q.ZERO,Q.ONE,Q.ZERO);const U=q.nBitLength,k=T6(z,q.endo?Math.ceil(U/2):U);return{CURVE:q,ProjectivePoint:z,normPrivateKeyToScalar:W,weierstrassEquation:Y,isWithinCurveOrder:K}}var QK=function(J){const q=r9(J);return J8(q,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...q})};function h6(J){const q=QK(J),{Fp:Q,n:G}=q,X=Q.BYTES+1,V=2*Q.BYTES+1;function Y(L){return J0(L,G)}function K(L){return NJ(L,G)}const{ProjectivePoint:W,normPrivateKeyToScalar:Z,weierstrassEquation:$,isWithinCurveOrder:j}=JK({...q,toBytes(L,w,P){const g=w.toAffine(),v=Q.toBytes(g.x),E=u0;if(L8("isCompressed",P),P)return E(Uint8Array.from([w.hasEvenY()?2:3]),v);else return E(Uint8Array.from([4]),v,Q.toBytes(g.y))},fromBytes(L){const w=L.length,P=L[0],g=L.subarray(1);if(w===X&&(P===2||P===3)){const v=C0(g);if(!e0(v,G0,Q.ORDER))throw new Error("Point is not on curve");const E=$(v);let c;try{c=Q.sqrt(E)}catch(s){const b=s instanceof Error?": "+s.message:"";throw new Error("Point is not on curve"+b)}const f=(c&G0)===G0;if((P&1)===1!==f)c=Q.neg(c);return{x:v,y:c}}else if(w===V&&P===4){const v=Q.fromBytes(g.subarray(0,Q.BYTES)),E=Q.fromBytes(g.subarray(Q.BYTES,2*Q.BYTES));return{x:v,y:E}}else{const v=X,E=V;throw new Error("invalid Point, expected length of "+v+", or uncompressed "+E+", got "+w)}}}),z=(L)=>P8(x0(L,q.nByteLength));function U(L){const w=G>>G0;return L>w}function k(L){return U(L)?Y(-L):L}const H=(L,w,P)=>C0(L.slice(w,P));class M{constructor(L,w,P){this.r=L,this.s=w,this.recovery=P,this.assertValidity()}static fromCompact(L){const w=q.nByteLength;return L=e("compactSignature",L,w*2),new M(H(L,0,w),H(L,w,2*w))}static fromDER(L){const{r:w,s:P}=c0.toSig(e("DER",L));return new M(w,P)}assertValidity(){R0("r",this.r,G0,G),R0("s",this.s,G0,G)}addRecoveryBit(L){return new M(this.r,this.s,L)}recoverPublicKey(L){const{r:w,s:P,recovery:g}=this,v=D(e("msgHash",L));if(g==null||![0,1,2,3].includes(g))throw new Error("recovery id invalid");const E=g===2||g===3?w+q.n:w;if(E>=Q.ORDER)throw new Error("recovery id 2 or 3 invalid");const c=(g&1)===0?"02":"03",f=W.fromHex(c+z(E)),h=K(E),s=Y(-v*h),b=Y(P*h),a=W.BASE.multiplyAndAddUnsafe(f,s,b);if(!a)throw new Error("point at infinify");return a.assertValidity(),a}hasHighS(){return U(this.s)}normalizeS(){return this.hasHighS()?new M(this.r,Y(-this.s),this.recovery):this}toDERRawBytes(){return C8(this.toDERHex())}toDERHex(){return c0.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return C8(this.toCompactHex())}toCompactHex(){return z(this.r)+z(this.s)}}const N={isValidPrivateKey(L){try{return Z(L),!0}catch(w){return!1}},normPrivateKeyToScalar:Z,randomPrivateKey:()=>{const L=l9(q.n);return D6(q.randomBytes(L),q.n)},precompute(L=8,w=W.BASE){return w._setWindowSize(L),w.multiply(BigInt(3)),w}};function O(L,w=!0){return W.fromPrivateKey(L).toRawBytes(w)}function F(L){const w=t0(L),P=typeof L==="string",g=(w||P)&&L.length;if(w)return g===X||g===V;if(P)return g===2*X||g===2*V;if(L instanceof W)return!0;return!1}function B(L,w,P=!0){if(F(L))throw new Error("first arg must be private key");if(!F(w))throw new Error("second arg must be public key");return W.fromHex(w).multiply(Z(L)).toRawBytes(P)}const A=q.bits2int||function(L){if(L.length>8192)throw new Error("input is too large");const w=C0(L),P=L.length*8-q.nBitLength;return P>0?w>>BigInt(P):w},D=q.bits2int_modN||function(L){return Y(A(L))},x=D1(q.nBitLength);function S(L){return R0("num < 2^"+q.nBitLength,L,p0,x),x0(L,q.nByteLength)}function y(L,w,P=I){if(["recovered","canonical"].some((Y0)=>(Y0 in P)))throw new Error("sign() legacy options not supported");const{hash:g,randomBytes:v}=q;let{lowS:E,prehash:c,extraEntropy:f}=P;if(E==null)E=!0;if(L=e("msgHash",L),v6(P),c)L=e("prehashed msgHash",g(L));const h=D(L),s=Z(w),b=[S(s),S(h)];if(f!=null&&f!==!1){const Y0=f===!0?v(Q.BYTES):f;b.push(e("extraEntropy",Y0))}const a=u0(...b),p=h;function i(Y0){const t=A(Y0);if(!j(t))return;const U0=K(t),H0=W.BASE.multiply(t).toAffine(),X0=Y(H0.x);if(X0===p0)return;const Y8=Y(U0*Y(p+X0*s));if(Y8===p0)return;let y0=(H0.x===X0?0:2)|Number(H0.y&G0),vQ=Y8;if(E&&U(Y8))vQ=k(Y8),y0^=1;return new M(X0,vQ,y0)}return{seed:a,k2sig:i}}const I={lowS:q.lowS,prehash:!1},T={lowS:q.lowS,prehash:!1};function C(L,w,P=I){const{seed:g,k2sig:v}=y(L,w,P),E=q;return b9(E.hash.outputLen,E.nByteLength,E.hmac)(g,v)}W.BASE._setWindowSize(8);function R(L,w,P,g=T){const v=L;w=e("msgHash",w),P=e("publicKey",P);const{lowS:E,prehash:c,format:f}=g;if(v6(g),("strict"in g))throw new Error("options.strict was renamed to lowS");if(f!==void 0&&f!=="compact"&&f!=="der")throw new Error("format must be compact or der");const h=typeof v==="string"||t0(v),s=!h&&!f&&typeof v==="object"&&v!==null&&typeof v.r==="bigint"&&typeof v.s==="bigint";if(!h&&!s)throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");let b=void 0,a;try{if(s)b=new M(v.r,v.s);if(h){try{if(f!=="compact")b=M.fromDER(v)}catch(y0){if(!(y0 instanceof c0.Err))throw y0}if(!b&&f!=="der")b=M.fromCompact(v)}a=W.fromHex(P)}catch(y0){return!1}if(!b)return!1;if(E&&b.hasHighS())return!1;if(c)w=q.hash(w);const{r:p,s:i}=b,Y0=D(w),t=K(i),U0=Y(Y0*t),H0=Y(p*t),X0=W.BASE.multiplyAndAddUnsafe(a,U0,H0)?.toAffine();if(!X0)return!1;return Y(X0.x)===p}return{CURVE:q,getPublicKey:O,getSharedSecret:B,sign:C,verify:R,ProjectivePoint:W,Signature:M,utils:N}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */var{bytesToNumberBE:tY,hexToBytes:eY}=u9;class E6 extends Error{constructor(J=""){super(J)}}var c0={Err:E6,_tlv:{encode:(J,q)=>{const{Err:Q}=c0;if(J<0||J>256)throw new Q("tlv.encode: wrong tag");if(q.length&1)throw new Q("tlv.encode: unpadded data");const G=q.length/2,X=k8(G);if(X.length/2&128)throw new Q("tlv.encode: long form length too big");const V=G>127?k8(X.length/2|128):"";return k8(J)+V+X+q},decode(J,q){const{Err:Q}=c0;let G=0;if(J<0||J>256)throw new Q("tlv.encode: wrong tag");if(q.length<2||q[G++]!==J)throw new Q("tlv.decode: wrong tlv");const X=q[G++],V=!!(X&128);let Y=0;if(!V)Y=X;else{const W=X&127;if(!W)throw new Q("tlv.decode(long): indefinite length not supported");if(W>4)throw new Q("tlv.decode(long): byte length is too big");const Z=q.subarray(G,G+W);if(Z.length!==W)throw new Q("tlv.decode: length bytes not complete");if(Z[0]===0)throw new Q("tlv.decode(long): zero leftmost byte");for(let $ of Z)Y=Y<<8|$;if(G+=W,Y<128)throw new Q("tlv.decode(long): not minimal encoding")}const K=q.subarray(G,G+Y);if(K.length!==Y)throw new Q("tlv.decode: wrong value length");return{v:K,l:q.subarray(G+Y)}}},_int:{encode(J){const{Err:q}=c0;if(J<p0)throw new q("integer: negative integers are not allowed");let Q=k8(J);if(Number.parseInt(Q[0],16)&8)Q="00"+Q;if(Q.length&1)throw new q("unexpected DER parsing assertion: unpadded hex");return Q},decode(J){const{Err:q}=c0;if(J[0]&128)throw new q("invalid signature integer: negative");if(J[0]===0&&!(J[1]&128))throw new q("invalid signature integer: unnecessary leading zero");return tY(J)}},toSig(J){const{Err:q,_int:Q,_tlv:G}=c0,X=typeof J==="string"?eY(J):J;d8(X);const{v:V,l:Y}=G.decode(48,X);if(Y.length)throw new q("invalid signature: left bytes after parsing");const{v:K,l:W}=G.decode(2,V),{v:Z,l:$}=G.decode(2,W);if($.length)throw new q("invalid signature: left bytes after parsing");return{r:Q.decode(K),s:Q.decode(Z)}},hexFromSig(J){const{_tlv:q,_int:Q}=c0,G=q.encode(2,Q.encode(J.r)),X=q.encode(2,Q.encode(J.s)),V=G+X;return q.encode(48,V)}},p0=BigInt(0),G0=BigInt(1),H$=BigInt(2),y6=BigInt(3),j$=BigInt(4);function qK(J){return{hash:J,hmac:(q,...Q)=>y9(J,q,L6(...Q)),randomBytes:jJ}}function m6(J,q){const Q=(G)=>h6({...J,...qK(G)});return{...Q(q),create:Q}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */var u6=function(J){const q=R1,Q=BigInt(3),G=BigInt(6),X=BigInt(11),V=BigInt(22),Y=BigInt(23),K=BigInt(44),W=BigInt(88),Z=J*J*J%q,$=Z*Z*J%q,j=B0($,Q,q)*$%q,z=B0(j,Q,q)*$%q,U=B0(z,FJ,q)*Z%q,k=B0(U,X,q)*U%q,H=B0(k,V,q)*k%q,M=B0(H,K,q)*H%q,N=B0(M,W,q)*M%q,O=B0(N,K,q)*H%q,F=B0(O,Q,q)*$%q,B=B0(F,Y,q)*k%q,A=B0(B,G,q)*Z%q,D=B0(A,FJ,q);if(!s9.eql(s9.sqr(D),J))throw new Error("Cannot find square root");return D},SJ=function(J,...q){let Q=b6[J];if(Q===void 0){const G=MJ(Uint8Array.from(J,(X)=>X.charCodeAt(0)));Q=u0(G,G),b6[J]=Q}return MJ(u0(Q,...q))},e9=function(J){let q=JQ.utils.normPrivateKeyToScalar(J),Q=qQ.fromPrivateKey(q);return{scalar:Q.hasEvenY()?q:A1(-q),bytes:QQ(Q)}},p6=function(J){R0("x",J,I1,R1);const q=a9(J*J),Q=a9(q*J+BigInt(7));let G=u6(Q);if(G%FJ!==c6)G=a9(-G);const X=new qQ(J,G,I1);return X.assertValidity(),X},f6=function(...J){return A1(i8(SJ("BIP0340/challenge",...J)))},XK=function(J){return e9(J).bytes},VK=function(J,q,Q=jJ(32)){const G=e("message",J),{bytes:X,scalar:V}=e9(q),Y=e("auxRand",Q,32),K=t9(V^i8(SJ("BIP0340/aux",Y))),W=SJ("BIP0340/nonce",K,X,G),Z=A1(i8(W));if(Z===c6)throw new Error("sign failed: k is zero");const{bytes:$,scalar:j}=e9(Z),z=f6($,X,G),U=new Uint8Array(64);if(U.set($,0),U.set(t9(A1(j+z*V)),32),!l6(U,G,X))throw new Error("sign: Invalid signature produced");return U},l6=function(J,q,Q){const G=e("signature",J,64),X=e("message",q),V=e("publicKey",Q,32);try{const Y=p6(i8(V)),K=i8(G.subarray(0,32));if(!e0(K,I1,R1))return!1;const W=i8(G.subarray(32,64));if(!e0(W,I1,OJ))return!1;const Z=f6(t9(K),QQ(Y),X),$=GK(Y,W,A1(-Z));if(!$||!$.hasEvenY()||$.toAffine().x!==K)return!1;return!0}catch(Y){return!1}};/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */var R1=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),OJ=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),I1=BigInt(1),FJ=BigInt(2),_6=(J,q)=>(J+q/FJ)/q,s9=wJ(R1,void 0,void 0,{sqrt:u6}),JQ=m6({a:BigInt(0),b:BigInt(7),Fp:s9,n:OJ,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:(J)=>{const q=OJ,Q=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),G=-I1*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),X=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),V=Q,Y=BigInt("0x100000000000000000000000000000000"),K=_6(V*J,q),W=_6(-G*J,q);let Z=J0(J-K*Q-W*X,q),$=J0(-K*G-W*V,q);const j=Z>Y,z=$>Y;if(j)Z=q-Z;if(z)$=q-$;if(Z>Y||$>Y)throw new Error("splitScalar: Endomorphism failed, k="+J);return{k1neg:j,k1:Z,k2neg:z,k2:$}}}},MJ),c6=BigInt(0),b6={},QQ=(J)=>J.toRawBytes(!0).slice(1),t9=(J)=>x0(J,32),a9=(J)=>J0(J,R1),A1=(J)=>J0(J,OJ),qQ=JQ.ProjectivePoint,GK=(J,q,Q)=>qQ.BASE.multiplyAndAddUnsafe(J,q,Q),i8=C0,DJ=(()=>({getPublicKey:XK,sign:VK,verify:l6,utils:{randomPrivateKey:JQ.utils.randomPrivateKey,lift_x:p6,pointToBytes:QQ,numberToBytesBE:x0,bytesToNumberBE:C0,taggedHash:SJ,mod:J0}}))();var{floor:GQ,random:YK,sin:KK}=Math,w8="Trystero",Q8=(J,q)=>Array(J).fill().map(q);var AJ=(J)=>Q8(J,()=>"0123456789AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz"[GQ(YK()*"0123456789AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz".length)]).join(""),T0=AJ(20),q8=Promise.all.bind(Promise),T1=typeof window!=="undefined",{entries:RJ,fromEntries:XQ,keys:d6}=Object,f0=()=>{},O0=(J)=>new Error(`Trystero: ${J}`),ZK=new TextEncoder,WK=new TextDecoder,g0=(J)=>ZK.encode(J),o8=(J)=>WK.decode(J),TJ=(J)=>J.reduce((q,Q)=>q+Q.toString(16).padStart(2,"0"),""),g1=(...J)=>J.join("@"),$K=(J,q)=>{const Q=[...J],G=()=>{const V=KK(q++)*1e4;return V-GQ(V)};let X=Q.length;while(X){const V=GQ(G()*X--);[Q[X],Q[V]]=[Q[V],Q[X]]}return Q},i6=(J,q,Q,G)=>{return(J.relayUrls||(G?$K(q,VQ(J.appId)):q)).slice(0,J.relayUrls?J.relayUrls.length:J.relayRedundancy||Q)},N0=JSON.stringify,x8=JSON.parse,VQ=(J,q=Number.MAX_SAFE_INTEGER)=>J.split("").reduce((Q,G)=>Q+G.charCodeAt(0),0)%q;var IJ={},o6=(J,q)=>{const Q={},G=()=>{const X=new WebSocket(J);X.onclose=()=>{IJ[J]??=3333,setTimeout(G,IJ[J]),IJ[J]*=2},X.onmessage=(V)=>q(V.data),Q.socket=X,Q.url=X.url,Q.ready=new Promise((V)=>X.onopen=()=>{V(Q),IJ[J]=3333}),Q.send=(V)=>{if(X.readyState===1)X.send(V)}};return G(),Q},n6=(J)=>()=>XQ(RJ(J).map(([q,Q])=>[q,Q.socket]));var KQ="AES-GCM",YQ={},zK=(J)=>btoa(String.fromCharCode.apply(null,new Uint8Array(J))),UK=(J)=>{const q=atob(J);return new Uint8Array(q.length).map((Q,G)=>q.charCodeAt(G)).buffer},v1=async(J)=>{if(YQ[J])return YQ[J];const q=Array.from(new Uint8Array(await crypto.subtle.digest("SHA-1",g0(J)))).map((Q)=>Q.toString(36)).join("");return YQ[J]=q,q},r6=async(J,q,Q)=>crypto.subtle.importKey("raw",await crypto.subtle.digest({name:"SHA-256"},g0(`${J}:${q}:${Q}`)),{name:KQ},!1,["encrypt","decrypt"]),a6="$",s6=",",t6=async(J,q)=>{const Q=crypto.getRandomValues(new Uint8Array(16));return Q.join(s6)+a6+zK(await crypto.subtle.encrypt({name:KQ,iv:Q},await J,g0(q)))},e6=async(J,q)=>{const[Q,G]=q.split(a6);return o8(await crypto.subtle.decrypt({name:KQ,iv:new Uint8Array(Q.split(s6))},await J,UK(G)))};var vG=i1(V5(),1);var l=typeof window!=="undefined"?window:self,EJ=l.RTCPeerConnection||l.mozRTCPeerConnection||l.webkitRTCPeerConnection,Y5=l.RTCSessionDescription||l.mozRTCSessionDescription||l.webkitRTCSessionDescription,K5=l.RTCIceCandidate||l.mozRTCIceCandidate||l.webkitRTCIceCandidate,g$=l.RTCIceTransport,v$=l.RTCDataChannel,y$=l.RTCSctpTransport,E$=l.RTCDtlsTransport,h$=l.RTCCertificate,m$=l.MediaStream,_$=l.MediaStreamTrack,b$=l.MediaStreamTrackEvent,u$=l.RTCPeerConnectionIceEvent,c$=l.RTCDataChannelEvent,p$=l.RTCTrackEvent,f$=l.RTCError,l$=l.RTCErrorEvent,d$=l.RTCRtpTransceiver,i$=l.RTCRtpReceiver,o$=l.RTCRtpSender;var yG=i1(OG(),1),n=i1(FQ(),1);var IG=[],DG=[];for(let J=0;J<256;J++)if(IG[J]="0123456789abcdef"[J>>4&15]+"0123456789abcdef"[J&15],J<16)if(J<10)DG[48+J]=J;else DG[87+J]=J;var iJ=(J)=>{const q=J.length;let Q="",G=0;while(G<q)Q+=IG[J[G++]];return Q};var AG="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",oZ=typeof Uint8Array==="undefined"?[]:new Uint8Array(256);for(p1=0;p1<AG.length;p1++)oZ[AG.charCodeAt(p1)]=p1;var p1;var nZ=new TextEncoder,TG=(J)=>nZ.encode(J);var RG=typeof window!=="undefined"?window:self,SQ=RG.crypto||RG.msCrypto||{},Mz=SQ.subtle||SQ.webkitSubtle;var DQ=(J)=>{const q=new Uint8Array(J);return SQ.getRandomValues(q)};var gG=function(J){return J.replace(/a=ice-options:trickle\s\n/g,"")},tZ=function(J){console.warn(J)};/*! simple-peer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */var rZ=vG.default("simple-peer"),IQ=65536,aZ=5000,sZ=5000;class T8 extends yG.Duplex{_pc;constructor(J){J=Object.assign({allowHalfOpen:!1},J);super(J);if(this.__objectMode=!!J.objectMode,this._id=iJ(DQ(4)).slice(0,7),this._debug("new peer %o",J),this.channelName=J.initiator?J.channelName||iJ(DQ(20)):null,this.initiator=J.initiator||!1,this.channelConfig=J.channelConfig||T8.channelConfig,this.channelNegotiated=this.channelConfig.negotiated,this.config=Object.assign({},T8.config,J.config),this.offerOptions=J.offerOptions||{},this.answerOptions=J.answerOptions||{},this.sdpTransform=J.sdpTransform||((q)=>q),this.trickle=J.trickle!==void 0?J.trickle:!0,this.allowHalfTrickle=J.allowHalfTrickle!==void 0?J.allowHalfTrickle:!1,this.iceCompleteTimeout=J.iceCompleteTimeout||aZ,this._destroying=!1,this._connected=!1,this.remoteAddress=void 0,this.remoteFamily=void 0,this.remotePort=void 0,this.localAddress=void 0,this.localFamily=void 0,this.localPort=void 0,!EJ)if(typeof window==="undefined")throw n.default(new Error("No WebRTC support: Specify `opts.wrtc` option in this environment"),"ERR_WEBRTC_SUPPORT");else throw n.default(new Error("No WebRTC support: Not a supported browser"),"ERR_WEBRTC_SUPPORT");this._pcReady=!1,this._channelReady=!1,this._iceComplete=!1,this._iceCompleteTimer=null,this._channel=null,this._pendingCandidates=[],this._isNegotiating=!1,this._firstNegotiation=!0,this._batchedNegotiation=!1,this._queuedNegotiation=!1,this._sendersAwaitingStable=[],this._closingInterval=null,this._remoteTracks=[],this._remoteStreams=[],this._chunk=null,this._cb=null,this._interval=null;try{this._pc=new EJ(this.config)}catch(q){this.__destroy(n.default(q,"ERR_PC_CONSTRUCTOR"));return}if(this._isReactNativeWebrtc=typeof this._pc._peerConnectionId==="number",this._pc.oniceconnectionstatechange=()=>{this._onIceStateChange()},this._pc.onicegatheringstatechange=()=>{this._onIceStateChange()},this._pc.onconnectionstatechange=()=>{this._onConnectionStateChange()},this._pc.onsignalingstatechange=()=>{this._onSignalingStateChange()},this._pc.onicecandidate=(q)=>{this._onIceCandidate(q)},typeof this._pc.peerIdentity==="object")this._pc.peerIdentity.catch((q)=>{this.__destroy(n.default(q,"ERR_PC_PEER_IDENTITY"))});if(this.initiator||this.channelNegotiated)this._setupData({channel:this._pc.createDataChannel(this.channelName,this.channelConfig)});else this._pc.ondatachannel=(q)=>{this._setupData(q)};this._debug("initial negotiation"),this._needsNegotiation(),this._onFinishBound=()=>{this._onFinish()},this.once("finish",this._onFinishBound)}get bufferSize(){return this._channel&&this._channel.bufferedAmount||0}get connected(){return this._connected&&this._channel.readyState==="open"}address(){return{port:this.localPort,family:this.localFamily,address:this.localAddress}}signal(J){if(this._destroying)return;if(this.destroyed)throw n.default(new Error("cannot signal after peer is destroyed"),"ERR_DESTROYED");if(typeof J==="string")try{J=JSON.parse(J)}catch(q){J={}}if(this._debug("signal()"),J.renegotiate&&this.initiator)this._debug("got request to renegotiate"),this._needsNegotiation();if(J.transceiverRequest&&this.initiator)this._debug("got request for transceiver"),this.addTransceiver(J.transceiverRequest.kind,J.transceiverRequest.init);if(J.candidate)if(this._pc.remoteDescription&&this._pc.remoteDescription.type)this._addIceCandidate(J.candidate);else this._pendingCandidates.push(J.candidate);if(J.sdp)this._pc.setRemoteDescription(new Y5(J)).then(()=>{if(this.destroyed)return;if(this._pendingCandidates.forEach((q)=>{this._addIceCandidate(q)}),this._pendingCandidates=[],this._pc.remoteDescription.type==="offer")this._createAnswer()}).catch((q)=>{this.__destroy(n.default(q,"ERR_SET_REMOTE_DESCRIPTION"))});if(!J.sdp&&!J.candidate&&!J.renegotiate&&!J.transceiverRequest)this.__destroy(n.default(new Error("signal() called with invalid signal data"),"ERR_SIGNALING"))}_addIceCandidate(J){const q=new K5(J);this._pc.addIceCandidate(q).catch((Q)=>{if(!q.address||q.address.endsWith(".local"))tZ("Ignoring unsupported ICE candidate.");else this.__destroy(n.default(Q,"ERR_ADD_ICE_CANDIDATE"))})}send(J){if(this._destroying)return;if(this.destroyed)throw n.default(new Error("cannot send after peer is destroyed"),"ERR_DESTROYED");this._channel.send(J)}_needsNegotiation(){if(this._debug("_needsNegotiation"),this._batchedNegotiation)return;this._batchedNegotiation=!0,queueMicrotask(()=>{if(this._batchedNegotiation=!1,this.initiator||!this._firstNegotiation)this._debug("starting batched negotiation"),this.negotiate();else this._debug("non-initiator initial negotiation request discarded");this._firstNegotiation=!1})}negotiate(){if(this._destroying)return;if(this.destroyed)throw n.default(new Error("cannot negotiate after peer is destroyed"),"ERR_DESTROYED");if(this.initiator)if(this._isNegotiating)this._queuedNegotiation=!0,this._debug("already negotiating, queueing");else this._debug("start negotiation"),setTimeout(()=>{this._createOffer()},0);else if(this._isNegotiating)this._queuedNegotiation=!0,this._debug("already negotiating, queueing");else this._debug("requesting negotiation from initiator"),this.emit("signal",{type:"renegotiate",renegotiate:!0});this._isNegotiating=!0}_final(J){if(!this._readableState.ended)this.push(null);J(null)}__destroy(J){this.end(),this._destroy(()=>{},J)}_destroy(J,q){if(this.destroyed||this._destroying)return;this._destroying=!0,this._debug("destroying (error: %s)",q&&(q.message||q)),setTimeout(()=>{if(this._connected=!1,this._pcReady=!1,this._channelReady=!1,this._remoteTracks=null,this._remoteStreams=null,this._senderMap=null,clearInterval(this._closingInterval),this._closingInterval=null,clearInterval(this._interval),this._interval=null,this._chunk=null,this._cb=null,this._onFinishBound)this.removeListener("finish",this._onFinishBound);if(this._onFinishBound=null,this._channel){try{this._channel.close()}catch(Q){}this._channel.onmessage=null,this._channel.onopen=null,this._channel.onclose=null,this._channel.onerror=null}if(this._pc){try{this._pc.close()}catch(Q){}this._pc.oniceconnectionstatechange=null,this._pc.onicegatheringstatechange=null,this._pc.onsignalingstatechange=null,this._pc.onicecandidate=null,this._pc.ontrack=null,this._pc.ondatachannel=null}if(this._pc=null,this._channel=null,q)this.emit("error",q);J()},0)}_setupData(J){if(!J.channel)return this.__destroy(n.default(new Error("Data channel event is missing `channel` property"),"ERR_DATA_CHANNEL"));if(this._channel=J.channel,this._channel.binaryType="arraybuffer",typeof this._channel.bufferedAmountLowThreshold==="number")this._channel.bufferedAmountLowThreshold=IQ;this.channelName=this._channel.label,this._channel.onmessage=(Q)=>{this._onChannelMessage(Q)},this._channel.onbufferedamountlow=()=>{this._onChannelBufferedAmountLow()},this._channel.onopen=()=>{this._onChannelOpen()},this._channel.onclose=()=>{this._onChannelClose()},this._channel.onerror=(Q)=>{const G=Q.error instanceof Error?Q.error:new Error(`Datachannel error: ${Q.message} ${Q.filename}:${Q.lineno}:${Q.colno}`);this.__destroy(n.default(G,"ERR_DATA_CHANNEL"))};let q=!1;this._closingInterval=setInterval(()=>{if(this._channel&&this._channel.readyState==="closing"){if(q)this._onChannelClose();q=!0}else q=!1},sZ)}_write(J,q){if(this.destroyed)return q(n.default(new Error("cannot write after peer is destroyed"),"ERR_DATA_CHANNEL"));if(this._connected){try{this.send(J)}catch(Q){return this.__destroy(n.default(Q,"ERR_DATA_CHANNEL"))}if(this._channel.bufferedAmount>IQ)this._debug("start backpressure: bufferedAmount %d",this._channel.bufferedAmount),this._cb=q;else q(null)}else this._debug("write before connect"),this._chunk=J,this._cb=q}_onFinish(){if(this.destroyed)return;const J=()=>{setTimeout(()=>this.__destroy(),1000)};if(this._connected)J();else this.once("connect",J)}_startIceCompleteTimeout(){if(this.destroyed)return;if(this._iceCompleteTimer)return;this._debug("started iceComplete timeout"),this._iceCompleteTimer=setTimeout(()=>{if(!this._iceComplete)this._iceComplete=!0,this._debug("iceComplete timeout completed"),this.emit("iceTimeout"),this.emit("_iceComplete")},this.iceCompleteTimeout)}_createOffer(){if(this.destroyed)return;this._pc.createOffer(this.offerOptions).then((J)=>{if(this.destroyed)return;if(!this.trickle&&!this.allowHalfTrickle)J.sdp=gG(J.sdp);J.sdp=this.sdpTransform(J.sdp);const q=()=>{if(this.destroyed)return;const X=this._pc.localDescription||J;this._debug("signal"),this.emit("signal",{type:X.type,sdp:X.sdp})},Q=()=>{if(this._debug("createOffer success"),this.destroyed)return;if(this.trickle||this._iceComplete)q();else this.once("_iceComplete",q)},G=(X)=>{this.__destroy(n.default(X,"ERR_SET_LOCAL_DESCRIPTION"))};this._pc.setLocalDescription(J).then(Q).catch(G)}).catch((J)=>{this.__destroy(n.default(J,"ERR_CREATE_OFFER"))})}_createAnswer(){if(this.destroyed)return;this._pc.createAnswer(this.answerOptions).then((J)=>{if(this.destroyed)return;if(!this.trickle&&!this.allowHalfTrickle)J.sdp=gG(J.sdp);J.sdp=this.sdpTransform(J.sdp);const q=()=>{if(this.destroyed)return;const X=this._pc.localDescription||J;if(this._debug("signal"),this.emit("signal",{type:X.type,sdp:X.sdp}),!this.initiator)this._requestMissingTransceivers?.()},Q=()=>{if(this.destroyed)return;if(this.trickle||this._iceComplete)q();else this.once("_iceComplete",q)},G=(X)=>{this.__destroy(n.default(X,"ERR_SET_LOCAL_DESCRIPTION"))};this._pc.setLocalDescription(J).then(Q).catch(G)}).catch((J)=>{this.__destroy(n.default(J,"ERR_CREATE_ANSWER"))})}_onConnectionStateChange(){if(this.destroyed||this._destroying)return;if(this._pc.connectionState==="failed")this.__destroy(n.default(new Error("Connection failed."),"ERR_CONNECTION_FAILURE"))}_onIceStateChange(){if(this.destroyed)return;const J=this._pc.iceConnectionState,q=this._pc.iceGatheringState;if(this._debug("iceStateChange (connection: %s) (gathering: %s)",J,q),this.emit("iceStateChange",J,q),J==="connected"||J==="completed")this._pcReady=!0,this._maybeReady();if(J==="failed")this.__destroy(n.default(new Error("Ice connection failed."),"ERR_ICE_CONNECTION_FAILURE"));if(J==="closed")this.__destroy(n.default(new Error("Ice connection closed."),"ERR_ICE_CONNECTION_CLOSED"))}getStats(J){const q=(Q)=>{if(Object.prototype.toString.call(Q.values)==="[object Array]")Q.values.forEach((G)=>{Object.assign(Q,G)});return Q};if(this._pc.getStats.length===0||this._isReactNativeWebrtc)this._pc.getStats().then((Q)=>{const G=[];Q.forEach((X)=>{G.push(q(X))}),J(null,G)},(Q)=>J(Q));else if(this._pc.getStats.length>0)this._pc.getStats((Q)=>{if(this.destroyed)return;const G=[];Q.result().forEach((X)=>{const V={};X.names().forEach((Y)=>{V[Y]=X.stat(Y)}),V.id=X.id,V.type=X.type,V.timestamp=X.timestamp,G.push(q(V))}),J(null,G)},(Q)=>J(Q));else J(null,[])}_maybeReady(){if(this._debug("maybeReady pc %s channel %s",this._pcReady,this._channelReady),this._connected||this._connecting||!this._pcReady||!this._channelReady)return;this._connecting=!0;const J=()=>{if(this.destroyed||this._destroying)return;this.getStats((q,Q)=>{if(this.destroyed||this._destroying)return;if(q)Q=[];const G={},X={},V={};let Y=!1;Q.forEach((W)=>{if(W.type==="remotecandidate"||W.type==="remote-candidate")G[W.id]=W;if(W.type==="localcandidate"||W.type==="local-candidate")X[W.id]=W;if(W.type==="candidatepair"||W.type==="candidate-pair")V[W.id]=W});const K=(W)=>{Y=!0;let Z=X[W.localCandidateId];if(Z&&(Z.ip||Z.address))this.localAddress=Z.ip||Z.address,this.localPort=Number(Z.port);else if(Z&&Z.ipAddress)this.localAddress=Z.ipAddress,this.localPort=Number(Z.portNumber);else if(typeof W.googLocalAddress==="string")Z=W.googLocalAddress.split(":"),this.localAddress=Z[0],this.localPort=Number(Z[1]);if(this.localAddress)this.localFamily=this.localAddress.includes(":")?"IPv6":"IPv4";let $=G[W.remoteCandidateId];if($&&($.ip||$.address))this.remoteAddress=$.ip||$.address,this.remotePort=Number($.port);else if($&&$.ipAddress)this.remoteAddress=$.ipAddress,this.remotePort=Number($.portNumber);else if(typeof W.googRemoteAddress==="string")$=W.googRemoteAddress.split(":"),this.remoteAddress=$[0],this.remotePort=Number($[1]);if(this.remoteAddress)this.remoteFamily=this.remoteAddress.includes(":")?"IPv6":"IPv4";this._debug("connect local: %s:%s remote: %s:%s",this.localAddress,this.localPort,this.remoteAddress,this.remotePort)};if(Q.forEach((W)=>{if(W.type==="transport"&&W.selectedCandidatePairId)K(V[W.selectedCandidatePairId]);if(W.type==="googCandidatePair"&&W.googActiveConnection==="true"||(W.type==="candidatepair"||W.type==="candidate-pair")&&W.selected)K(W)}),!Y&&(!Object.keys(V).length||Object.keys(X).length)){setTimeout(J,100);return}else this._connecting=!1,this._connected=!0;if(this._chunk){try{this.send(this._chunk)}catch(Z){return this.__destroy(n.default(Z,"ERR_DATA_CHANNEL"))}this._chunk=null,this._debug('sent chunk from "write before connect"');const W=this._cb;this._cb=null,W(null)}if(typeof this._channel.bufferedAmountLowThreshold!=="number"){if(this._interval=setInterval(()=>this._onInterval(),150),this._interval.unref)this._interval.unref()}this._debug("connect"),this.emit("connect")})};J()}_onInterval(){if(!this._cb||!this._channel||this._channel.bufferedAmount>IQ)return;this._onChannelBufferedAmountLow()}_onSignalingStateChange(){if(this.destroyed)return;if(this._pc.signalingState==="stable")if(this._isNegotiating=!1,this._debug("flushing sender queue",this._sendersAwaitingStable),this._sendersAwaitingStable.forEach((J)=>{this._pc.removeTrack(J),this._queuedNegotiation=!0}),this._sendersAwaitingStable=[],this._queuedNegotiation)this._debug("flushing negotiation queue"),this._queuedNegotiation=!1,this._needsNegotiation();else this._debug("negotiated"),this.emit("negotiated");this._debug("signalingStateChange %s",this._pc.signalingState),this.emit("signalingStateChange",this._pc.signalingState)}_onIceCandidate(J){if(this.destroyed)return;if(J.candidate&&this.trickle)this.emit("signal",{type:"candidate",candidate:{candidate:J.candidate.candidate,sdpMLineIndex:J.candidate.sdpMLineIndex,sdpMid:J.candidate.sdpMid}});else if(!J.candidate&&!this._iceComplete)this._iceComplete=!0,this.emit("_iceComplete");if(J.candidate)this._startIceCompleteTimeout()}_onChannelMessage(J){if(this.destroyed)return;let q=J.data;if(q instanceof ArrayBuffer)q=new Uint8Array(q);else if(this.__objectMode===!1)q=TG(q);this.push(q)}_onChannelBufferedAmountLow(){if(this.destroyed||!this._cb)return;this._debug("ending backpressure: bufferedAmount %d",this._channel.bufferedAmount);const J=this._cb;this._cb=null,J(null)}_onChannelOpen(){if(this._connected||this.destroyed)return;this._debug("on channel open"),this._channelReady=!0,this._maybeReady()}_onChannelClose(){if(this.destroyed)return;this._debug("on channel close"),this.__destroy()}_debug(){const J=[].slice.call(arguments);J[0]="["+this._id+"] "+J[0],rZ.apply(null,J)}}T8.WEBRTC_SUPPORT=!!EJ;T8.config={iceServers:[{urls:["stun:stun.l.google.com:19302","stun:global.stun.twilio.com:3478"]}],sdpSemantics:"unified-plan"};T8.channelConfig={};var EG=T8;var z0=i1(FQ(),1);/*! simple-peer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */class hG extends EG{constructor(J={}){super(J);if(!this._pc)return;if(this.streams=J.streams||(J.stream?[J.stream]:[]),this._senderMap=new Map,this.streams)this.streams.forEach((q)=>{this.addStream(q)});this._pc.ontrack=(q)=>{this._onTrack(q)}}addTransceiver(J,q){if(this._destroying)return;if(this.destroyed)throw z0.default(new Error("cannot addTransceiver after peer is destroyed"),"ERR_DESTROYED");if(this._debug("addTransceiver()"),this.initiator)try{this._pc.addTransceiver(J,q),this._needsNegotiation()}catch(Q){this.__destroy(z0.default(Q,"ERR_ADD_TRANSCEIVER"))}else this.emit("signal",{type:"transceiverRequest",transceiverRequest:{kind:J,init:q}})}addStream(J){if(this._destroying)return;if(this.destroyed)throw z0.default(new Error("cannot addStream after peer is destroyed"),"ERR_DESTROYED");this._debug("addStream()"),J.getTracks().forEach((q)=>{this.addTrack(q,J)})}addTrack(J,q){if(this._destroying)return;if(this.destroyed)throw z0.default(new Error("cannot addTrack after peer is destroyed"),"ERR_DESTROYED");this._debug("addTrack()");const Q=this._senderMap.get(J)||new Map;let G=Q.get(q);if(!G)G=this._pc.addTrack(J,q),Q.set(q,G),this._senderMap.set(J,Q),this._needsNegotiation();else if(G.removed)throw z0.default(new Error("Track has been removed. You should enable/disable tracks that you want to re-add."),"ERR_SENDER_REMOVED");else throw z0.default(new Error("Track has already been added to that stream."),"ERR_SENDER_ALREADY_ADDED")}replaceTrack(J,q,Q){if(this._destroying)return;if(this.destroyed)throw z0.default(new Error("cannot replaceTrack after peer is destroyed"),"ERR_DESTROYED");this._debug("replaceTrack()");const G=this._senderMap.get(J),X=G?G.get(Q):null;if(!X)throw z0.default(new Error("Cannot replace track that was never added."),"ERR_TRACK_NOT_ADDED");if(q)this._senderMap.set(q,G);if(X.replaceTrack!=null)X.replaceTrack(q);else this.__destroy(z0.default(new Error("replaceTrack is not supported in this browser"),"ERR_UNSUPPORTED_REPLACETRACK"))}removeTrack(J,q){if(this._destroying)return;if(this.destroyed)throw z0.default(new Error("cannot removeTrack after peer is destroyed"),"ERR_DESTROYED");this._debug("removeSender()");const Q=this._senderMap.get(J),G=Q?Q.get(q):null;if(!G)throw z0.default(new Error("Cannot remove track that was never added."),"ERR_TRACK_NOT_ADDED");try{G.removed=!0,this._pc.removeTrack(G)}catch(X){if(X.name==="NS_ERROR_UNEXPECTED")this._sendersAwaitingStable.push(G);else this.__destroy(z0.default(X,"ERR_REMOVE_TRACK"))}this._needsNegotiation()}removeStream(J){if(this._destroying)return;if(this.destroyed)throw z0.default(new Error("cannot removeStream after peer is destroyed"),"ERR_DESTROYED");this._debug("removeSenders()"),J.getTracks().forEach((q)=>{this.removeTrack(q,J)})}_requestMissingTransceivers(){if(this._pc.getTransceivers)this._pc.getTransceivers().forEach((J)=>{if(!J.mid&&J.sender.track&&!J.requested)J.requested=!0,this.addTransceiver(J.sender.track.kind)})}_onTrack(J){if(this.destroyed)return;J.streams.forEach((q)=>{if(this._debug("on track"),this.emit("track",J.track,q),this._remoteTracks.push({track:J.track,stream:q}),this._remoteStreams.some((Q)=>{return Q.id===q.id}))return;this._remoteStreams.push(q),queueMicrotask(()=>{this._debug("on stream"),this.emit("stream",q)})})}}var mG=hG;var _G="data",bG="signal",AQ=(J,q)=>{const Q=new mG({...{iceServers:[{urls:eZ}]},...q,initiator:J,trickle:!1}),G=(V)=>X.push(V);let X=[];return Q.on(_G,G),{id:Q._id,created:Date.now(),connection:Q._pc,get channel(){return Q._channel},get isDead(){return Q.destroyed},signal:(V)=>new Promise((Y)=>{if(!J)Q.on(bG,Y);Q.signal(V)}),sendData:(V)=>Q.send(V),destroy:()=>Q.destroy(),setHandlers:(V)=>Object.entries(V).forEach(([Y,K])=>Q.on(Y,K)),offerPromise:J?new Promise((V)=>Q.on(bG,V)):Promise.resolve(),addStream:(V)=>Q.addStream(V),removeStream:(V)=>Q.removeStream(V),addTrack:(V,Y)=>Q.addTrack(V,Y),removeTrack:(V,Y)=>Q.removeTrack(V,Y),replaceTrack:(V,Y,K)=>Q.replaceTrack(V,Y,K),drainEarlyData:(V)=>{Q.off(_G,G),X.forEach(V),X=null}}},eZ=[...Q8(5,(J,q)=>`stun:stun${q||""}.l.google.com:19302`),"stun:global.stun.twilio.com:3478"];var JW=Object.getPrototypeOf(Uint8Array),nJ=12,cG=0,rJ=cG+nJ,aJ=rJ+1,f1=aJ+1,l1=f1+1,g8=16384-l1,oJ=255,uG="bufferedamountlow",q1=(J)=>"@_"+J,pG=(J,q,Q)=>{const G={},X={},V={},Y={},K={},W={},Z={},$={onPeerJoin:f0,onPeerLeave:f0,onPeerStream:f0,onPeerTrack:f0},j=(C,R)=>(C?Array.isArray(C)?C:[C]:d6(G)).flatMap((L)=>{const w=G[L];if(!w)return console.warn(`${w8}: no peer with id ${L} found`),[];return R(L,w)}),z=(C)=>{if(!G[C])return;delete G[C],delete Y[C],delete K[C],$.onPeerLeave(C),q(C)},U=(C)=>{if(X[C])return V[C];if(!C)throw O0("action type argument is required");const R=g0(C);if(R.byteLength>nJ)throw O0(`action type string "${C}" (${R.byteLength}b) exceeds `+`byte limit (${nJ}). Hint: choose a shorter name.`);const L=new Uint8Array(nJ);L.set(R);let w=0;return X[C]={onComplete:f0,onProgress:f0,setOnComplete:(P)=>X[C]={...X[C],onComplete:P},setOnProgress:(P)=>X[C]={...X[C],onProgress:P},send:async(P,g,v,E)=>{if(v&&typeof v!=="object")throw O0("action meta argument must be an object");const c=typeof P;if(c==="undefined")throw O0("action data cannot be undefined");const f=c!=="string",h=P instanceof Blob,s=h||P instanceof ArrayBuffer||P instanceof JW;if(v&&!s)throw O0("action meta argument can only be used with binary data");const b=s?new Uint8Array(h?await P.arrayBuffer():P):g0(f?N0(P):P),a=v?g0(N0(v)):null,p=Math.ceil(b.byteLength/g8)+(v?1:0)||1,i=Q8(p,(Y0,t)=>{const U0=t===p-1,H0=v&&t===0,X0=new Uint8Array(l1+(H0?a.byteLength:U0?b.byteLength-g8*(p-(v?2:1)):g8));return X0.set(L),X0.set([w],rJ),X0.set([U0|H0<<1|s<<2|f<<3],aJ),X0.set([Math.round((t+1)/p*oJ)],f1),X0.set(v?H0?a:b.subarray((t-1)*g8,t*g8):b.subarray(t*g8,(t+1)*g8),l1),X0});return w=w+1&oJ,q8(j(g,async(Y0,t)=>{const{channel:U0}=t;let H0=0;while(H0<p){const X0=i[H0];if(U0.bufferedAmount>U0.bufferedAmountLowThreshold)await new Promise((Y8)=>{const y0=()=>{U0.removeEventListener(uG,y0),Y8()};U0.addEventListener(uG,y0)});if(!G[Y0])break;t.sendData(X0),H0++,E?.(X0[f1]/oJ,Y0,v)}}))}},V[C]||=[X[C].send,X[C].setOnComplete,X[C].setOnProgress]},k=(C,R)=>{const L=new Uint8Array(R),w=o8(L.subarray(cG,rJ)).replaceAll("\0",""),[P]=L.subarray(rJ,aJ),[g]=L.subarray(aJ,f1),[v]=L.subarray(f1,l1),E=L.subarray(l1),c=!!(g&1),f=!!(g&1<<1),h=!!(g&1<<2),s=!!(g&1<<3);if(!X[w]){console.warn(`${w8}: received message with unregistered type (${w})`);return}Y[C]||={},Y[C][w]||={};const b=Y[C][w][P]||={chunks:[]};if(f)b.meta=x8(o8(E));else b.chunks.push(E);if(X[w].onProgress(v/oJ,C,b.meta),!c)return;const a=new Uint8Array(b.chunks.reduce((p,i)=>p+i.byteLength,0));if(b.chunks.reduce((p,i)=>{return a.set(i,p),p+i.byteLength},0),delete Y[C][w][P],h)X[w].onComplete(a,C,b.meta);else{const p=o8(a);X[w].onComplete(s?x8(p):p,C)}},H=async()=>{await I(""),await new Promise((C)=>setTimeout(C,99)),RJ(G).forEach(([C,R])=>{R.destroy(),delete G[C]}),Q()},[M,N]=U(q1("ping")),[O,F]=U(q1("pong")),[B,A]=U(q1("signal")),[D,x]=U(q1("stream")),[S,y]=U(q1("track")),[I,T]=U(q1("leave"));if(J((C,R)=>{if(G[R])return;G[R]=C,C.setHandlers({data:(L)=>k(R,L),stream:(L)=>{$.onPeerStream(L,R,W[R]),delete W[R]},track:(L,w)=>{$.onPeerTrack(L,w,R,Z[R]),delete Z[R]},signal:(L)=>B(L,R),close:()=>z(R),error:()=>z(R)}),$.onPeerJoin(R),C.drainEarlyData?.((L)=>k(R,L))}),N((C,R)=>O("",R)),F((C,R)=>{K[R]?.(),delete K[R]}),A((C,R)=>G[R]?.signal(C)),x((C,R)=>W[R]=C),y((C,R)=>Z[R]=C),T((C,R)=>z(R)),T1)addEventListener("beforeunload",H);return{makeAction:U,leave:H,ping:async(C)=>{if(!C)throw O0("ping() must be called with target peer ID");const R=Date.now();return M("",C),await new Promise((L)=>K[C]=L),Date.now()-R},getPeers:()=>XQ(RJ(G).map(([C,R])=>[C,R.connection])),addStream:(C,R,L)=>j(R,async(w,P)=>{if(L)await D(L,w);P.addStream(C)}),removeStream:(C,R)=>j(R,(L,w)=>w.removeStream(C)),addTrack:(C,R,L,w)=>j(L,async(P,g)=>{if(w)await S(w,P);g.addTrack(C,R)}),removeTrack:(C,R,L)=>j(L,(w,P)=>P.removeTrack(C,R)),replaceTrack:(C,R,L,w,P)=>j(w,async(g,v)=>{if(P)await S(P,g);v.replaceTrack(C,R,L)}),onPeerJoin:(C)=>$.onPeerJoin=C,onPeerLeave:(C)=>$.onPeerLeave=C,onPeerStream:(C)=>$.onPeerStream=C,onPeerTrack:(C)=>$.onPeerTrack=C}};var QW=20,qW=5333,fG=57333,lG=({init:J,subscribe:q,announce:Q})=>{const G={};let X=!1,V,Y,K;return(W,Z,$)=>{const{appId:j}=W;if(G[j]?.[Z])return G[j][Z];const z={},U={},k=g1(w8,j,Z),H=v1(k),M=v1(g1(k,T0)),N=r6(W.password||"",j,Z),O=(P)=>async(g)=>({type:g.type,sdp:await P(N,g.sdp)}),F=O(e6),B=O(t6),A=()=>AQ(!0,W.rtcConfig),D=(P,g,v)=>{if(U[g]){if(U[g]!==P)P.destroy();return}U[g]=P,w(P,g),z[g]?.forEach((E,c)=>{if(c!==v)E.destroy()}),delete z[g]},x=(P,g)=>{if(U[g]===P)delete U[g]},S=(P,g)=>{if(U[P])return;const v=z[P]?.[g];if(v)delete z[P][g],v.destroy()},y=(P)=>{return Y.push(...Q8(P,A)),q8(Y.splice(0,P).map((g)=>g.offerPromise.then(B).then((v)=>({peer:g,offer:v}))))},I=(P,g)=>$?.({error:`incorrect password (${W.password}) when decrypting ${g}`,appId:j,peerId:P,roomId:Z}),T=(P)=>async(g,v,E)=>{const[c,f]=await q8([H,M]);if(g!==c&&g!==f)return;const{peerId:h,offer:s,answer:b,peer:a}=typeof v==="string"?x8(v):v;if(h===T0||U[h])return;if(h&&!s&&!b){if(z[h]?.[P])return;const[[{peer:p,offer:i}],Y0]=await q8([y(1),v1(g1(k,h))]);z[h]||=[],z[h][P]=p,setTimeout(()=>S(h,P),C[P]*0.9),p.setHandlers({connect:()=>D(p,h,P),close:()=>x(p,h)}),E(Y0,N0({peerId:T0,offer:i}))}else if(s){if(z[h]?.[P]&&T0>h)return;const i=AQ(!1,W.rtcConfig);i.setHandlers({connect:()=>D(i,h,P),close:()=>x(i,h)});let Y0;try{Y0=await F(s)}catch{I(h,"offer");return}if(i.isDead)return;const[t,U0]=await q8([v1(g1(k,h)),i.signal(Y0)]);E(t,N0({peerId:T0,answer:await B(U0)}))}else if(b){let p;try{p=await F(b)}catch(i){I(h,"answer");return}if(a)a.setHandlers({connect:()=>D(a,h,P),close:()=>x(a,h)}),a.signal(p);else{const i=z[h]?.[P];if(i&&!i.isDead)i.signal(p)}}};if(!W)throw O0("requires a config map as the first argument");if(!j&&!W.firebaseApp)throw O0("config map is missing appId field");if(!Z)throw O0("roomId argument required");if(!X){const P=J(W);Y=Q8(QW,A),V=Array.isArray(P)?P:[P],X=!0,K=setInterval(()=>Y=Y.filter((g)=>{const v=Date.now()-g.created<fG;if(!v)g.destroy();return v}),fG*1.03)}const C=V.map(()=>qW),R=[],L=V.map(async(P,g)=>q(await P,await H,await M,T(g),y));q8([H,M]).then(([P,g])=>{const v=async(E,c)=>{const f=await Q(E,P,g);if(typeof f==="number")C[c]=f;R[c]=setTimeout(()=>v(E,c),C[c])};L.forEach(async(E,c)=>{await E,v(await V[c],c)})});let w=f0;return G[j]||={},G[j][Z]=pG((P)=>w=P,(P)=>delete U[P],()=>{delete G[j][Z],R.forEach(clearTimeout),L.forEach(async(P)=>(await P)()),clearInterval(K)})}};var rG={},GW=5,aG="x",sG="EVENT",tG=T1&&DJ.utils.randomPrivateKey(),XW=T1&&TJ(DJ.getPublicKey(tG)),RQ={},d1={},dG={},eG=()=>Math.floor(Date.now()/1000),J7=(J)=>dG[J]??(dG[J]=VQ(J,1e4)+20000),iG=async(J,q)=>{const Q={kind:J7(J),content:q,pubkey:XW,created_at:eG(),tags:[[aG,J]]},G=TJ(new Uint8Array(await crypto.subtle.digest("SHA-256",g0(N0([0,Q.pubkey,Q.created_at,Q.kind,Q.tags,Q.content])))));return N0([sG,{...Q,id:G,sig:TJ(await DJ.sign(G,tG))}])},oG=(J,q)=>{return RQ[J]=q,N0(["REQ",J,{kinds:[J7(q)],since:eG(),["#"+aG]:[q]}])},nG=(J)=>{return delete RQ[J],N0(["CLOSE",J])},TQ=lG({init:(J)=>i6(J,YW,GW,!0).map((q)=>{const Q=o6(q,(G)=>{const[X,V,Y,K]=x8(G);if(X!==sG){const W=`${w8}: relay failure from ${Q.url} - `;if(X==="NOTICE")console.warn(W+V);else if(X==="OK"&&!Y)console.warn(W+K);return}d1[V]?.(RQ[V],Y.content)});return rG[q]=Q,Q.ready}),subscribe:(J,q,Q,G)=>{const X=AJ(64),V=AJ(64);return d1[X]=d1[V]=(Y,K)=>G(Y,K,async(W,Z)=>J.send(await iG(W,Z))),J.send(oG(X,q)),J.send(oG(V,Q)),()=>{J.send(nG(X)),J.send(nG(V)),delete d1[X],delete d1[V]}},announce:async(J,q)=>J.send(await iG(q,N0({peerId:T0})))}),VW=n6(rG),YW=["eu.purplerelay.com","ftp.halifax.rwth-aachen.de/nostr","longhorn.bgp.rodeo","multiplexer.huszonegy.world","nfdb.noswhere.com","nostr-verified.wellorder.net","nostr.cool110.xyz","nostr.data.haus","nostr.grooveix.com","nostr.huszonegy.world","nostr.mom","nostr.openhoofd.nl","nostr.petrkr.net/strfry","nostr.sathoarder.com","nostr.stakey.net","nostr.vulpem.com","nostr2.sanhauf.com","nostrelay.circum.space","relay.fountain.fm","relay.nostraddress.com","relay.nostromo.social","relay.snort.social","relay.verified-nostr.com","strfry.openhoofd.nl","yabu.me/v2"].map((J)=>"wss://"+J);var gQ=(J,q)=>{if(!J||!J.timestamp)return{resolved:!0,value:q.newValue,timestamp:q.timestamp};if(J.timestamp<q.timestamp)return{resolved:!0,value:q.newValue,timestamp:q.timestamp};return{resolved:!1}};var Q7=()=>{const J={},q=async({data:Q})=>{const{type:G,name:X,content:V}=Q;if(!X){self.postMessage({type:"error",message:"Invalid file name"});return}try{const Y=await navigator.storage.getDirectory();switch(G){case"save":if(!V||J[X]){self.postMessage({type:"error",message:J[X]?"File already open":"Invalid content"});return}J[X]=!0;const W=await(await Y.getFileHandle(X,{create:!0})).createSyncAccessHandle();W.write(V,{at:0}),W.flush(),W.close(),self.postMessage({type:"saved",name:X});break;case"load":if(J[X]){self.postMessage({type:"error",message:"File already open"});return}J[X]=!0;const $=await(await Y.getFileHandle(X,{create:!1})).createSyncAccessHandle(),j=$.getSize(),z=new ArrayBuffer(j);$.read(z,{at:0}),$.close(),self.postMessage({type:"loaded",name:X,data:Array.from(new Uint8Array(z))});break;case"delete":await Y.removeEntry(X),self.postMessage({type:"deleted",name:X});break;default:self.postMessage({type:"error",message:"Unknown operation"})}}catch(Y){if(Y.name==="NotFoundError")self.postMessage({type:"loaded",name:X,data:[]});else console.error(`Error processing '${G}' for file '${X}':`,Y.message),self.postMessage({type:"error",message:`Error processing '${G}' for file '${X}'`})}finally{delete J[X]}};self.addEventListener("message",q)};async function KW(){if(console.log("\u26A1 GDB-P2P: Empowering distributed graph databases with real-time synchronization and scalability. Learn more: https://github.com/estebanrfp/gdb \u26A1"),navigator?.storage?.getDirectory){const J=await navigator.storage.getDirectory();console.log("OPFS is enabled.")}else console.log("OPFS is not available.")}if(Symbol.dispose===void 0)Object.defineProperty(Symbol,"dispose",{value:Symbol.for("Symbol.dispose")});class q7{constructor(){this.nodes={}}insert(J,q){const Q=Date.now();if(!this.nodes[J]||this.nodes[J].timestamp<Q)this.nodes[J]={id:J,value:q,edges:[],timestamp:Q}}get(J){return this.nodes[J]||null}link(J,q){const Q=this.nodes[J],G=this.nodes[q];if(Q&&G&&!Q.edges.includes(q))Q.edges.push(q)}getAllNodes(){return Object.values(this.nodes)}serialize(){return T9.deflate(E0(this.nodes))}deserialize(J){this.nodes=JJ(T9.inflate(new Uint8Array(J)))}}class G7{constructor(J,{password:q}={}){this.name=J,this.password=q,this.graph=new q7,this.index={},this.eventListeners=[],this.localHash,this.localTime=Date.now(),this.initWorker(),this.ready=(async()=>{await this.loadGraphFromOPFS()})();const Q=`graph-sync-room-${this.name}`,G={appId:"1234",...this.password&&{password:this.password}},X=TQ(G,Q);this.room=X,window.addEventListener("online",async()=>{console.log("\u2705 Reconnected to the network."),this.sendData([{type:"sync",hash:this.localHash,ts:this.localTime}])}),window.addEventListener("offline",async()=>{console.log("\u274C Disconnected from the network.")}),KW(),X.onPeerJoin(async(K)=>{console.log("\u26A1 New pair connected:",K),this.sendData([{type:"sync",hash:this.localHash,ts:this.localTime}])}),X.onPeerLeave((K)=>{console.log("\u26A1 Pair disconnected:",K)});const[V,Y]=X.makeAction("syncGraph");this.sendData=V,Y((K)=>this.receiveChanges(K)),this.channel=new BroadcastChannel(`graphdb_sync_${this.name}`),this.channel.onmessage=async(K)=>{if(K.data==="update")console.log("\uD83D\uDD04 Update received from another tab..."),await this.loadGraphFromOPFS(),this.emit()}}initWorker=async()=>{try{const J=new Blob([`(${Q7.toString()})()`],{type:"application/javascript"}),q=URL.createObjectURL(J);this.worker=new Worker(q),URL.revokeObjectURL(q),this.worker.addEventListener("message",(Q)=>{console.log("Worker message:",Q.data)}),console.log("Worker inicializado correctamente.")}catch(J){console.error("Error al inicializar el worker:",J.message)}};emit(){const J=this.graph.getAllNodes();this.eventListeners.forEach((q)=>q(J))}on(J){this.eventListeners.push(J)}off(J){if(J)this.eventListeners=this.eventListeners.filter((q)=>q!==J);else this.eventListeners=[]}async generateHash(J){const q=new TextEncoder,Q=await crypto.subtle.digest("SHA-256",q.encode(J));return`0x${Array.from(new Uint8Array(Q)).map((G)=>G.toString(16).padStart(2,"0")).join("")}`}async generateGraphHash(){const J=this.graph.serialize();return await this.generateHash(J)}async loadGraphFromOPFS(){try{const J=(G)=>{return new Promise((X,V)=>{this.worker.postMessage({type:"load",name:G});const Y=(K)=>{if(K.data.type==="loaded"&&K.data.name===G)this.worker.removeEventListener("message",Y),X(new Uint8Array(K.data.data));else if(K.data.type==="error")this.worker.removeEventListener("message",Y),V(new Error(K.data.message||"Error desconocido al cargar el archivo."))};this.worker.addEventListener("message",Y)})},[q,Q]=await Promise.all([J(`${this.name}_graph.msgpack`).catch(()=>new Uint8Array),J(`${this.name}_index.msgpack`).catch(()=>new Uint8Array)]);if(q.byteLength>0)this.graph.deserialize(q);else console.warn("The file '_graph.msgpack' is empty or could not be loaded.");if(Q.byteLength>0)this.index=JJ(Q);else console.warn("The file '_index.msgpack' is empty or could not be loaded.");this.localHash=await this.generateGraphHash(),this.localTime=Date.now(),console.log(`Graph loaded from OPFS: [ ${this.graph.getAllNodes().length} nodes ]`)}catch(J){console.error("General error loading the graph from OPFS:",J.message)}}async saveGraphToOPFS(){try{const J=this.graph.serialize(),q=E0(this.index),Q=(G,X)=>new Promise((V,Y)=>{this.worker.postMessage({type:"save",name:G,content:X});const K=({data:W})=>{if(W.type==="saved"&&W.name===G)this.worker.removeEventListener("message",K),V();else if(W.type==="error")this.worker.removeEventListener("message",K),Y(new Error(W.message||"Error al guardar"))};this.worker.addEventListener("message",K)});return await Promise.all([Q(`${this.name}_graph.msgpack`,J),Q(`${this.name}_index.msgpack`,q)]),this.localHash=await this.generateGraphHash(),this.localTime=Date.now(),this.channel.postMessage("update"),!0}catch(J){throw console.error("Error guardando:",J),new Error("Guardado fallido")}}async put(J,q){await this.ready,q??=await this.generateHash(E0(J));const Q=this.graph.get(q);if(!Q)this.graph.insert(q,J);else{const X={id:q,newValue:J,timestamp:Date.now()},V=gQ(Q,X);if(V.resolved){Q.value=V.value,Q.timestamp=V.timestamp;const Y=E0(Q.value);if(this.index[Y]){if(this.index[Y]=this.index[Y].filter((K)=>K!==q),this.index[Y].length===0)delete this.index[Y]}}}const G=E0(J);if(!this.index[G])this.index[G]=[];if(this.index[G].push(q),await this.saveGraphToOPFS(),!Q)this.sendData([{type:"insert",id:q,value:J,timestamp:Date.now()}]);else this.sendData([{type:"update",id:q,newValue:J,timestamp:Date.now()}]);return this.emit(),q}async find(J){await this.ready;const q=E0(J);return(this.index[q]||[]).map((G)=>this.graph.get(G)).reduce((G,X)=>X.timestamp>G.timestamp?X:G,null)}async get(J,q=null){await this.ready;const Q=this.graph.get(J);if(!Q)return console.error(`Nodo con ID '${J}' no encontrado.`),null;if(!q)return Q;q(Q);const G=(X)=>{const V=X.find((Y)=>Y.id===J);if(V)q(V)};this.eventListeners.push(G)}async map(J,q=!1,Q=!0){if(await this.ready,Q){const G=(X)=>{X.forEach((V)=>{J(V.id,V.value,V.edges,V.timestamp)})};if(G(this.graph.getAllNodes()),q)this.eventListeners.push(()=>{G(this.graph.getAllNodes())})}else if(J(this.graph.getAllNodes()),q)this.eventListeners.push(()=>{J(this.graph.getAllNodes())})}async remove(J){await this.ready;const q=this.graph.get(J);if(!q)return console.error(`Nodo con ID '${J}' no encontrado.`);delete this.graph.nodes[J];const Q=E0(q.value);if(this.index[Q]){if(this.index[Q]=this.index[Q].filter((G)=>G!==J),this.index[Q].length===0)delete this.index[Q]}for(let G of Object.values(this.graph.nodes))G.edges=G.edges.filter((X)=>X!==J);await this.saveGraphToOPFS(),this.sendData([{type:"remove",id:J,value:q.value,timestamp:Date.now()}]),this.emit()}async clear(){await this.ready,this.graph.nodes={},this.index={};const J=await navigator.storage.getDirectory();try{await J.removeEntry(`${this.name}_graph.msgpack`),await J.removeEntry(`${this.name}_index.msgpack`)}catch(q){console.warn(`Error al eliminar archivos: ${q.message}`)}console.log("All data has been deleted.")}async link(J,q){if(await this.ready,!this.graph.nodes[J]||!this.graph.nodes[q]){console.error(`Uno o ambos nodos (${J}, ${q}) no existen.`);return}this.graph.link(J,q),await this.saveGraphToOPFS(),this.sendData([{type:"link",sourceId:J,targetId:q,timestamp:Date.now()}]),this.emit()}async applyFullGraph(J){try{this.graph.nodes={};for(let[q,Q]of Object.entries(J.nodes))this.graph.nodes[q]=Q;await this.saveGraphToOPFS()}catch(q){console.error("Error applying the full graph:",q.message)}}async receiveChanges(J){for(let q of J)if(q.type==="insert")this.graph.insert(q.id,q.value);else if(q.type==="update"){const Q=this.graph.get(q.id),G=gQ(Q,q);if(G.resolved)Q.value=G.value,Q.timestamp=G.timestamp}else if(q.type==="remove")delete this.graph.nodes[q.id];else if(q.type==="link")this.graph.link(q.sourceId,q.targetId);else if(q.type==="sync"){if(this.localHash!==q.hash){if(this.localTime>q.ts)console.log("Sending recent data to remote node."),this.sendData([{type:"syncReceive",graph:this.graph}])}}else if(q.type==="syncReceive")await this.applyFullGraph(q.graph);await this.saveGraphToOPFS(),this.emit()}}export{G7 as default};
