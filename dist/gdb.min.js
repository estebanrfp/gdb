function c6(W){const Q=W.length;let J=0,G=0;while(G<Q){let V=W.charCodeAt(G++);if((V&4294967168)===0){J++;continue}else if((V&4294965248)===0)J+=2;else{if(V>=55296&&V<=56319){if(G<Q){const q=W.charCodeAt(G);if((q&64512)===56320)++G,V=((V&1023)<<10)+(q&1023)+65536}}if((V&4294901760)===0)J+=3;else J+=4}}return J}function vW(W,Q,J){const G=W.length;let V=J,q=0;while(q<G){let X=W.charCodeAt(q++);if((X&4294967168)===0){Q[V++]=X;continue}else if((X&4294965248)===0)Q[V++]=X>>6&31|192;else{if(X>=55296&&X<=56319){if(q<G){const Y=W.charCodeAt(q);if((Y&64512)===56320)++q,X=((X&1023)<<10)+(Y&1023)+65536}}if((X&4294901760)===0)Q[V++]=X>>12&15|224,Q[V++]=X>>6&63|128;else Q[V++]=X>>18&7|240,Q[V++]=X>>12&63|128,Q[V++]=X>>6&63|128}Q[V++]=X&63|128}}function TW(W,Q,J){gW.encodeInto(W,Q.subarray(J))}function _6(W,Q,J){if(W.length>SW)TW(W,Q,J);else vW(W,Q,J)}function D8(W,Q,J){let G=Q;const V=G+J,q=[];let X="";while(G<V){const Y=W[G++];if((Y&128)===0)q.push(Y);else if((Y&224)===192){const F=W[G++]&63;q.push((Y&31)<<6|F)}else if((Y&240)===224){const F=W[G++]&63,P=W[G++]&63;q.push((Y&31)<<12|F<<6|P)}else if((Y&248)===240){const F=W[G++]&63,P=W[G++]&63,U=W[G++]&63;let k=(Y&7)<<18|F<<12|P<<6|U;if(k>65535)k-=65536,q.push(k>>>10&1023|55296),k=56320|k&1023;q.push(k)}else q.push(Y);if(q.length>=AW)X+=String.fromCharCode(...q),q.length=0}if(q.length>0)X+=String.fromCharCode(...q);return X}function pW(W,Q,J){const G=W.subarray(Q,Q+J);return yW.decode(G)}function l6(W,Q,J){if(J>EW)return pW(W,Q,J);else return D8(W,Q,J)}var gW=new TextEncoder,SW=50,AW=4096,yW=new TextDecoder,EW=200;class e0{constructor(W,Q){this.type=W,this.data=Q}}class e extends Error{constructor(W){super(W);const Q=Object.create(e.prototype);Object.setPrototypeOf(this,Q),Object.defineProperty(this,"name",{configurable:!0,enumerable:!1,value:e.name})}}function i6(W,Q,J){const G=J/4294967296,V=J;W.setUint32(Q,G),W.setUint32(Q+4,V)}function _1(W,Q,J){const G=Math.floor(J/4294967296),V=J;W.setUint32(Q,G),W.setUint32(Q+4,V)}function l1(W,Q){const J=W.getInt32(Q),G=W.getUint32(Q+4);return J*4294967296+G}function o6(W,Q){const J=W.getUint32(Q),G=W.getUint32(Q+4);return J*4294967296+G}var t0=4294967295;function mW({sec:W,nsec:Q}){if(W>=0&&Q>=0&&W<=bW)if(Q===0&&W<=hW){const J=new Uint8Array(4);return new DataView(J.buffer).setUint32(0,W),J}else{const J=W/4294967296,G=W&4294967295,V=new Uint8Array(8),q=new DataView(V.buffer);return q.setUint32(0,Q<<2|J&3),q.setUint32(4,G),V}else{const J=new Uint8Array(12),G=new DataView(J.buffer);return G.setUint32(0,Q),_1(G,4,W),J}}function uW(W){const Q=W.getTime(),J=Math.floor(Q/1000),G=(Q-J*1000)*1e6,V=Math.floor(G/1e9);return{sec:J+V,nsec:G-V*1e9}}function dW(W){if(W instanceof Date){const Q=uW(W);return mW(Q)}else return null}function cW(W){const Q=new DataView(W.buffer,W.byteOffset,W.byteLength);switch(W.byteLength){case 4:return{sec:Q.getUint32(0),nsec:0};case 8:{const J=Q.getUint32(0),G=Q.getUint32(4),V=(J&3)*4294967296+G,q=J>>>2;return{sec:V,nsec:q}}case 12:{const J=l1(Q,4),G=Q.getUint32(0);return{sec:J,nsec:G}}default:throw new e(`Unrecognized data size for timestamp (expected 4, 8, or 12): ${W.length}`)}}function _W(W){const Q=cW(W);return new Date(Q.sec*1000+Q.nsec/1e6)}var fW=-1,hW=4294967295,bW=17179869183,r6={type:fW,encode:dW,decode:_W};class T0{constructor(){this.builtInEncoders=[],this.builtInDecoders=[],this.encoders=[],this.decoders=[],this.register(r6)}register({type:W,encode:Q,decode:J}){if(W>=0)this.encoders[W]=Q,this.decoders[W]=J;else{const G=-1-W;this.builtInEncoders[G]=Q,this.builtInDecoders[G]=J}}tryToEncode(W,Q){for(let J=0;J<this.builtInEncoders.length;J++){const G=this.builtInEncoders[J];if(G!=null){const V=G(W,Q);if(V!=null){const q=-1-J;return new e0(q,V)}}}for(let J=0;J<this.encoders.length;J++){const G=this.encoders[J];if(G!=null){const V=G(W,Q);if(V!=null)return new e0(J,V)}}if(W instanceof e0)return W;return null}decode(W,Q,J){const G=Q<0?this.builtInDecoders[-1-Q]:this.decoders[Q];if(G)return G(W,Q,J);else return new e0(Q,W)}}T0.defaultCodec=new T0;var lW=function(W){return W instanceof ArrayBuffer||typeof SharedArrayBuffer!=="undefined"&&W instanceof SharedArrayBuffer};function C1(W){if(W instanceof Uint8Array)return W;else if(ArrayBuffer.isView(W))return new Uint8Array(W.buffer,W.byteOffset,W.byteLength);else if(lW(W))return new Uint8Array(W);else return Uint8Array.from(W)}var iW=100,oW=2048;class i1{constructor(W){this.entered=!1,this.extensionCodec=W?.extensionCodec??T0.defaultCodec,this.context=W?.context,this.useBigInt64=W?.useBigInt64??!1,this.maxDepth=W?.maxDepth??iW,this.initialBufferSize=W?.initialBufferSize??oW,this.sortKeys=W?.sortKeys??!1,this.forceFloat32=W?.forceFloat32??!1,this.ignoreUndefined=W?.ignoreUndefined??!1,this.forceIntegerToFloat=W?.forceIntegerToFloat??!1,this.pos=0,this.view=new DataView(new ArrayBuffer(this.initialBufferSize)),this.bytes=new Uint8Array(this.view.buffer)}clone(){return new i1({extensionCodec:this.extensionCodec,context:this.context,useBigInt64:this.useBigInt64,maxDepth:this.maxDepth,initialBufferSize:this.initialBufferSize,sortKeys:this.sortKeys,forceFloat32:this.forceFloat32,ignoreUndefined:this.ignoreUndefined,forceIntegerToFloat:this.forceIntegerToFloat})}reinitializeState(){this.pos=0}encodeSharedRef(W){if(this.entered)return this.clone().encodeSharedRef(W);try{return this.entered=!0,this.reinitializeState(),this.doEncode(W,1),this.bytes.subarray(0,this.pos)}finally{this.entered=!1}}encode(W){if(this.entered)return this.clone().encode(W);try{return this.entered=!0,this.reinitializeState(),this.doEncode(W,1),this.bytes.slice(0,this.pos)}finally{this.entered=!1}}doEncode(W,Q){if(Q>this.maxDepth)throw new Error(`Too deep objects in depth ${Q}`);if(W==null)this.encodeNil();else if(typeof W==="boolean")this.encodeBoolean(W);else if(typeof W==="number")if(!this.forceIntegerToFloat)this.encodeNumber(W);else this.encodeNumberAsFloat(W);else if(typeof W==="string")this.encodeString(W);else if(this.useBigInt64&&typeof W==="bigint")this.encodeBigInt64(W);else this.encodeObject(W,Q)}ensureBufferSizeToWrite(W){const Q=this.pos+W;if(this.view.byteLength<Q)this.resizeBuffer(Q*2)}resizeBuffer(W){const Q=new ArrayBuffer(W),J=new Uint8Array(Q),G=new DataView(Q);J.set(this.bytes),this.view=G,this.bytes=J}encodeNil(){this.writeU8(192)}encodeBoolean(W){if(W===!1)this.writeU8(194);else this.writeU8(195)}encodeNumber(W){if(!this.forceIntegerToFloat&&Number.isSafeInteger(W))if(W>=0)if(W<128)this.writeU8(W);else if(W<256)this.writeU8(204),this.writeU8(W);else if(W<65536)this.writeU8(205),this.writeU16(W);else if(W<4294967296)this.writeU8(206),this.writeU32(W);else if(!this.useBigInt64)this.writeU8(207),this.writeU64(W);else this.encodeNumberAsFloat(W);else if(W>=-32)this.writeU8(224|W+32);else if(W>=-128)this.writeU8(208),this.writeI8(W);else if(W>=-32768)this.writeU8(209),this.writeI16(W);else if(W>=-2147483648)this.writeU8(210),this.writeI32(W);else if(!this.useBigInt64)this.writeU8(211),this.writeI64(W);else this.encodeNumberAsFloat(W);else this.encodeNumberAsFloat(W)}encodeNumberAsFloat(W){if(this.forceFloat32)this.writeU8(202),this.writeF32(W);else this.writeU8(203),this.writeF64(W)}encodeBigInt64(W){if(W>=BigInt(0))this.writeU8(207),this.writeBigUint64(W);else this.writeU8(211),this.writeBigInt64(W)}writeStringHeader(W){if(W<32)this.writeU8(160+W);else if(W<256)this.writeU8(217),this.writeU8(W);else if(W<65536)this.writeU8(218),this.writeU16(W);else if(W<4294967296)this.writeU8(219),this.writeU32(W);else throw new Error(`Too long string: ${W} bytes in UTF-8`)}encodeString(W){const J=c6(W);this.ensureBufferSizeToWrite(5+J),this.writeStringHeader(J),_6(W,this.bytes,this.pos),this.pos+=J}encodeObject(W,Q){const J=this.extensionCodec.tryToEncode(W,this.context);if(J!=null)this.encodeExtension(J);else if(Array.isArray(W))this.encodeArray(W,Q);else if(ArrayBuffer.isView(W))this.encodeBinary(W);else if(typeof W==="object")this.encodeMap(W,Q);else throw new Error(`Unrecognized object: ${Object.prototype.toString.apply(W)}`)}encodeBinary(W){const Q=W.byteLength;if(Q<256)this.writeU8(196),this.writeU8(Q);else if(Q<65536)this.writeU8(197),this.writeU16(Q);else if(Q<4294967296)this.writeU8(198),this.writeU32(Q);else throw new Error(`Too large binary: ${Q}`);const J=C1(W);this.writeU8a(J)}encodeArray(W,Q){const J=W.length;if(J<16)this.writeU8(144+J);else if(J<65536)this.writeU8(220),this.writeU16(J);else if(J<4294967296)this.writeU8(221),this.writeU32(J);else throw new Error(`Too large array: ${J}`);for(let G of W)this.doEncode(G,Q+1)}countWithoutUndefined(W,Q){let J=0;for(let G of Q)if(W[G]!==void 0)J++;return J}encodeMap(W,Q){const J=Object.keys(W);if(this.sortKeys)J.sort();const G=this.ignoreUndefined?this.countWithoutUndefined(W,J):J.length;if(G<16)this.writeU8(128+G);else if(G<65536)this.writeU8(222),this.writeU16(G);else if(G<4294967296)this.writeU8(223),this.writeU32(G);else throw new Error(`Too large map object: ${G}`);for(let V of J){const q=W[V];if(!(this.ignoreUndefined&&q===void 0))this.encodeString(V),this.doEncode(q,Q+1)}}encodeExtension(W){if(typeof W.data==="function"){const J=W.data(this.pos+6),G=J.length;if(G>=4294967296)throw new Error(`Too large extension object: ${G}`);this.writeU8(201),this.writeU32(G),this.writeI8(W.type),this.writeU8a(J);return}const Q=W.data.length;if(Q===1)this.writeU8(212);else if(Q===2)this.writeU8(213);else if(Q===4)this.writeU8(214);else if(Q===8)this.writeU8(215);else if(Q===16)this.writeU8(216);else if(Q<256)this.writeU8(199),this.writeU8(Q);else if(Q<65536)this.writeU8(200),this.writeU16(Q);else if(Q<4294967296)this.writeU8(201),this.writeU32(Q);else throw new Error(`Too large extension object: ${Q}`);this.writeI8(W.type),this.writeU8a(W.data)}writeU8(W){this.ensureBufferSizeToWrite(1),this.view.setUint8(this.pos,W),this.pos++}writeU8a(W){const Q=W.length;this.ensureBufferSizeToWrite(Q),this.bytes.set(W,this.pos),this.pos+=Q}writeI8(W){this.ensureBufferSizeToWrite(1),this.view.setInt8(this.pos,W),this.pos++}writeU16(W){this.ensureBufferSizeToWrite(2),this.view.setUint16(this.pos,W),this.pos+=2}writeI16(W){this.ensureBufferSizeToWrite(2),this.view.setInt16(this.pos,W),this.pos+=2}writeU32(W){this.ensureBufferSizeToWrite(4),this.view.setUint32(this.pos,W),this.pos+=4}writeI32(W){this.ensureBufferSizeToWrite(4),this.view.setInt32(this.pos,W),this.pos+=4}writeF32(W){this.ensureBufferSizeToWrite(4),this.view.setFloat32(this.pos,W),this.pos+=4}writeF64(W){this.ensureBufferSizeToWrite(8),this.view.setFloat64(this.pos,W),this.pos+=8}writeU64(W){this.ensureBufferSizeToWrite(8),i6(this.view,this.pos,W),this.pos+=8}writeI64(W){this.ensureBufferSizeToWrite(8),_1(this.view,this.pos,W),this.pos+=8}writeBigUint64(W){this.ensureBufferSizeToWrite(8),this.view.setBigUint64(this.pos,W),this.pos+=8}writeBigInt64(W){this.ensureBufferSizeToWrite(8),this.view.setBigInt64(this.pos,W),this.pos+=8}}function I0(W,Q){return new i1(Q).encodeSharedRef(W)}function o1(W){return`${W<0?"-":""}0x${Math.abs(W).toString(16).padStart(2,"0")}`}var rW=16,aW=16;class N8{constructor(W=rW,Q=aW){this.hit=0,this.miss=0,this.maxKeyLength=W,this.maxLengthPerKey=Q,this.caches=[];for(let J=0;J<this.maxKeyLength;J++)this.caches.push([])}canBeCached(W){return W>0&&W<=this.maxKeyLength}find(W,Q,J){const G=this.caches[J-1];W:for(let V of G){const q=V.bytes;for(let X=0;X<J;X++)if(q[X]!==W[Q+X])continue W;return V.str}return null}store(W,Q){const J=this.caches[W.length-1],G={bytes:W,str:Q};if(J.length>=this.maxLengthPerKey)J[Math.random()*J.length|0]=G;else J.push(G)}decode(W,Q,J){const G=this.find(W,Q,J);if(G!=null)return this.hit++,G;this.miss++;const V=D8(W,Q,J),q=Uint8Array.prototype.slice.call(W,Q,Q+J);return this.store(q,V),V}}var v8="array",B1="map_key",n6="map_value",nW=(W)=>{if(typeof W==="string"||typeof W==="number")return W;throw new e("The type of key must be string or number but "+typeof W)};class s6{constructor(){this.stack=[],this.stackHeadPosition=-1}get length(){return this.stackHeadPosition+1}top(){return this.stack[this.stackHeadPosition]}pushArrayState(W){const Q=this.getUninitializedStateFromPool();Q.type=v8,Q.position=0,Q.size=W,Q.array=new Array(W)}pushMapState(W){const Q=this.getUninitializedStateFromPool();Q.type=B1,Q.readCount=0,Q.size=W,Q.map={}}getUninitializedStateFromPool(){if(this.stackHeadPosition++,this.stackHeadPosition===this.stack.length){const W={type:void 0,size:0,array:void 0,position:0,readCount:0,map:void 0,key:null};this.stack.push(W)}return this.stack[this.stackHeadPosition]}release(W){if(this.stack[this.stackHeadPosition]!==W)throw new Error("Invalid stack state. Released state is not on top of the stack.");if(W.type===v8){const J=W;J.size=0,J.array=void 0,J.position=0,J.type=void 0}if(W.type===B1||W.type===n6){const J=W;J.size=0,J.map=void 0,J.readCount=0,J.type=void 0}this.stackHeadPosition--}reset(){this.stack.length=0,this.stackHeadPosition=-1}}var M1=-1,g8=new DataView(new ArrayBuffer(0)),sW=new Uint8Array(g8.buffer);try{g8.getInt8(0)}catch(W){if(!(W instanceof RangeError))throw new Error("This module is not supported in the current JavaScript engine because DataView does not throw RangeError on out-of-bounds access")}var a6=new RangeError("Insufficient data"),eW=new N8;class r1{constructor(W){this.totalPos=0,this.pos=0,this.view=g8,this.bytes=sW,this.headByte=M1,this.stack=new s6,this.entered=!1,this.extensionCodec=W?.extensionCodec??T0.defaultCodec,this.context=W?.context,this.useBigInt64=W?.useBigInt64??!1,this.rawStrings=W?.rawStrings??!1,this.maxStrLength=W?.maxStrLength??t0,this.maxBinLength=W?.maxBinLength??t0,this.maxArrayLength=W?.maxArrayLength??t0,this.maxMapLength=W?.maxMapLength??t0,this.maxExtLength=W?.maxExtLength??t0,this.keyDecoder=W?.keyDecoder!==void 0?W.keyDecoder:eW,this.mapKeyConverter=W?.mapKeyConverter??nW}clone(){return new r1({extensionCodec:this.extensionCodec,context:this.context,useBigInt64:this.useBigInt64,rawStrings:this.rawStrings,maxStrLength:this.maxStrLength,maxBinLength:this.maxBinLength,maxArrayLength:this.maxArrayLength,maxMapLength:this.maxMapLength,maxExtLength:this.maxExtLength,keyDecoder:this.keyDecoder})}reinitializeState(){this.totalPos=0,this.headByte=M1,this.stack.reset()}setBuffer(W){const Q=C1(W);this.bytes=Q,this.view=new DataView(Q.buffer,Q.byteOffset,Q.byteLength),this.pos=0}appendBuffer(W){if(this.headByte===M1&&!this.hasRemaining(1))this.setBuffer(W);else{const Q=this.bytes.subarray(this.pos),J=C1(W),G=new Uint8Array(Q.length+J.length);G.set(Q),G.set(J,Q.length),this.setBuffer(G)}}hasRemaining(W){return this.view.byteLength-this.pos>=W}createExtraByteError(W){const{view:Q,pos:J}=this;return new RangeError(`Extra ${Q.byteLength-J} of ${Q.byteLength} byte(s) found at buffer[${W}]`)}decode(W){if(this.entered)return this.clone().decode(W);try{this.entered=!0,this.reinitializeState(),this.setBuffer(W);const Q=this.doDecodeSync();if(this.hasRemaining(1))throw this.createExtraByteError(this.pos);return Q}finally{this.entered=!1}}*decodeMulti(W){if(this.entered){yield*this.clone().decodeMulti(W);return}try{this.entered=!0,this.reinitializeState(),this.setBuffer(W);while(this.hasRemaining(1))yield this.doDecodeSync()}finally{this.entered=!1}}async decodeAsync(W){if(this.entered)return this.clone().decodeAsync(W);try{this.entered=!0;let Q=!1,J;for await(let X of W){if(Q)throw this.entered=!1,this.createExtraByteError(this.totalPos);this.appendBuffer(X);try{J=this.doDecodeSync(),Q=!0}catch(Y){if(!(Y instanceof RangeError))throw Y}this.totalPos+=this.pos}if(Q){if(this.hasRemaining(1))throw this.createExtraByteError(this.totalPos);return J}const{headByte:G,pos:V,totalPos:q}=this;throw new RangeError(`Insufficient data in parsing ${o1(G)} at ${q} (${V} in the current buffer)`)}finally{this.entered=!1}}decodeArrayStream(W){return this.decodeMultiAsync(W,!0)}decodeStream(W){return this.decodeMultiAsync(W,!1)}async*decodeMultiAsync(W,Q){if(this.entered){yield*this.clone().decodeMultiAsync(W,Q);return}try{this.entered=!0;let J=Q,G=-1;for await(let V of W){if(Q&&G===0)throw this.createExtraByteError(this.totalPos);if(this.appendBuffer(V),J)G=this.readArraySize(),J=!1,this.complete();try{while(!0)if(yield this.doDecodeSync(),--G===0)break}catch(q){if(!(q instanceof RangeError))throw q}this.totalPos+=this.pos}}finally{this.entered=!1}}doDecodeSync(){W:while(!0){const W=this.readHeadByte();let Q;if(W>=224)Q=W-256;else if(W<192)if(W<128)Q=W;else if(W<144){const G=W-128;if(G!==0){this.pushMapState(G),this.complete();continue W}else Q={}}else if(W<160){const G=W-144;if(G!==0){this.pushArrayState(G),this.complete();continue W}else Q=[]}else{const G=W-160;Q=this.decodeString(G,0)}else if(W===192)Q=null;else if(W===194)Q=!1;else if(W===195)Q=!0;else if(W===202)Q=this.readF32();else if(W===203)Q=this.readF64();else if(W===204)Q=this.readU8();else if(W===205)Q=this.readU16();else if(W===206)Q=this.readU32();else if(W===207)if(this.useBigInt64)Q=this.readU64AsBigInt();else Q=this.readU64();else if(W===208)Q=this.readI8();else if(W===209)Q=this.readI16();else if(W===210)Q=this.readI32();else if(W===211)if(this.useBigInt64)Q=this.readI64AsBigInt();else Q=this.readI64();else if(W===217){const G=this.lookU8();Q=this.decodeString(G,1)}else if(W===218){const G=this.lookU16();Q=this.decodeString(G,2)}else if(W===219){const G=this.lookU32();Q=this.decodeString(G,4)}else if(W===220){const G=this.readU16();if(G!==0){this.pushArrayState(G),this.complete();continue W}else Q=[]}else if(W===221){const G=this.readU32();if(G!==0){this.pushArrayState(G),this.complete();continue W}else Q=[]}else if(W===222){const G=this.readU16();if(G!==0){this.pushMapState(G),this.complete();continue W}else Q={}}else if(W===223){const G=this.readU32();if(G!==0){this.pushMapState(G),this.complete();continue W}else Q={}}else if(W===196){const G=this.lookU8();Q=this.decodeBinary(G,1)}else if(W===197){const G=this.lookU16();Q=this.decodeBinary(G,2)}else if(W===198){const G=this.lookU32();Q=this.decodeBinary(G,4)}else if(W===212)Q=this.decodeExtension(1,0);else if(W===213)Q=this.decodeExtension(2,0);else if(W===214)Q=this.decodeExtension(4,0);else if(W===215)Q=this.decodeExtension(8,0);else if(W===216)Q=this.decodeExtension(16,0);else if(W===199){const G=this.lookU8();Q=this.decodeExtension(G,1)}else if(W===200){const G=this.lookU16();Q=this.decodeExtension(G,2)}else if(W===201){const G=this.lookU32();Q=this.decodeExtension(G,4)}else throw new e(`Unrecognized type byte: ${o1(W)}`);this.complete();const J=this.stack;while(J.length>0){const G=J.top();if(G.type===v8)if(G.array[G.position]=Q,G.position++,G.position===G.size)Q=G.array,J.release(G);else continue W;else if(G.type===B1){if(Q==="__proto__")throw new e("The key __proto__ is not allowed");G.key=this.mapKeyConverter(Q),G.type=n6;continue W}else if(G.map[G.key]=Q,G.readCount++,G.readCount===G.size)Q=G.map,J.release(G);else{G.key=null,G.type=B1;continue W}}return Q}}readHeadByte(){if(this.headByte===M1)this.headByte=this.readU8();return this.headByte}complete(){this.headByte=M1}readArraySize(){const W=this.readHeadByte();switch(W){case 220:return this.readU16();case 221:return this.readU32();default:if(W<160)return W-144;else throw new e(`Unrecognized array type byte: ${o1(W)}`)}}pushMapState(W){if(W>this.maxMapLength)throw new e(`Max length exceeded: map length (${W}) > maxMapLengthLength (${this.maxMapLength})`);this.stack.pushMapState(W)}pushArrayState(W){if(W>this.maxArrayLength)throw new e(`Max length exceeded: array length (${W}) > maxArrayLength (${this.maxArrayLength})`);this.stack.pushArrayState(W)}decodeString(W,Q){if(!this.rawStrings||this.stateIsMapKey())return this.decodeUtf8String(W,Q);return this.decodeBinary(W,Q)}decodeUtf8String(W,Q){if(W>this.maxStrLength)throw new e(`Max length exceeded: UTF-8 byte length (${W}) > maxStrLength (${this.maxStrLength})`);if(this.bytes.byteLength<this.pos+Q+W)throw a6;const J=this.pos+Q;let G;if(this.stateIsMapKey()&&this.keyDecoder?.canBeCached(W))G=this.keyDecoder.decode(this.bytes,J,W);else G=l6(this.bytes,J,W);return this.pos+=Q+W,G}stateIsMapKey(){if(this.stack.length>0)return this.stack.top().type===B1;return!1}decodeBinary(W,Q){if(W>this.maxBinLength)throw new e(`Max length exceeded: bin length (${W}) > maxBinLength (${this.maxBinLength})`);if(!this.hasRemaining(W+Q))throw a6;const J=this.pos+Q,G=this.bytes.subarray(J,J+W);return this.pos+=Q+W,G}decodeExtension(W,Q){if(W>this.maxExtLength)throw new e(`Max length exceeded: ext length (${W}) > maxExtLength (${this.maxExtLength})`);const J=this.view.getInt8(this.pos+Q),G=this.decodeBinary(W,Q+1);return this.extensionCodec.decode(G,J,this.context)}lookU8(){return this.view.getUint8(this.pos)}lookU16(){return this.view.getUint16(this.pos)}lookU32(){return this.view.getUint32(this.pos)}readU8(){const W=this.view.getUint8(this.pos);return this.pos++,W}readI8(){const W=this.view.getInt8(this.pos);return this.pos++,W}readU16(){const W=this.view.getUint16(this.pos);return this.pos+=2,W}readI16(){const W=this.view.getInt16(this.pos);return this.pos+=2,W}readU32(){const W=this.view.getUint32(this.pos);return this.pos+=4,W}readI32(){const W=this.view.getInt32(this.pos);return this.pos+=4,W}readU64(){const W=o6(this.view,this.pos);return this.pos+=8,W}readI64(){const W=l1(this.view,this.pos);return this.pos+=8,W}readU64AsBigInt(){const W=this.view.getBigUint64(this.pos);return this.pos+=8,W}readI64AsBigInt(){const W=this.view.getBigInt64(this.pos);return this.pos+=8,W}readF32(){const W=this.view.getFloat32(this.pos);return this.pos+=4,W}readF64(){const W=this.view.getFloat64(this.pos);return this.pos+=8,W}}function a1(W,Q){return new r1(Q).decode(W)}var q1=function(W){let Q=W.length;while(--Q>=0)W[Q]=0},T8=function(W,Q,J,G,V){this.static_tree=W,this.extra_bits=Q,this.extra_base=J,this.elems=G,this.max_length=V,this.has_stree=W&&W.length},A8=function(W,Q){this.dyn_tree=W,this.max_code=0,this.stat_desc=Q},K0=function(W,Q,J,G,V){this.good_length=W,this.max_lazy=Q,this.nice_length=J,this.max_chain=G,this.func=V},WQ=function(){this.strm=null,this.status=0,this.pending_buf=null,this.pending_buf_size=0,this.pending_out=0,this.pending=0,this.wrap=0,this.gzhead=null,this.gzindex=0,this.method=q8,this.last_flush=-1,this.w_size=0,this.w_bits=0,this.w_mask=0,this.window=null,this.window_size=0,this.prev=null,this.head=null,this.ins_h=0,this.hash_size=0,this.hash_bits=0,this.hash_mask=0,this.hash_shift=0,this.block_start=0,this.match_length=0,this.prev_match=0,this.match_available=0,this.strstart=0,this.match_start=0,this.lookahead=0,this.prev_length=0,this.max_chain_length=0,this.max_lazy_match=0,this.level=0,this.strategy=0,this.good_match=0,this.nice_match=0,this.dyn_ltree=new Uint16Array(lJ*2),this.dyn_dtree=new Uint16Array((2*cJ+1)*2),this.bl_tree=new Uint16Array((2*_J+1)*2),x0(this.dyn_ltree),x0(this.dyn_dtree),x0(this.bl_tree),this.l_desc=null,this.d_desc=null,this.bl_desc=null,this.bl_count=new Uint16Array(iJ+1),this.heap=new Uint16Array(2*r8+1),x0(this.heap),this.heap_len=0,this.heap_max=0,this.depth=new Uint16Array(2*r8+1),x0(this.depth),this.sym_buf=0,this.lit_bufsize=0,this.sym_next=0,this.sym_end=0,this.opt_len=0,this.static_len=0,this.matches=0,this.insert=0,this.bi_buf=0,this.bi_valid=0},RQ=function(){this.input=null,this.next_in=0,this.avail_in=0,this.total_in=0,this.output=null,this.next_out=0,this.avail_out=0,this.total_out=0,this.msg="",this.state=null,this.data_type=2,this.adler=0},p1=function(W){this.options=X8.assign({level:NQ,method:gQ,chunkSize:16384,windowBits:15,memLevel:8,strategy:vQ},W||{});let Q=this.options;if(Q.raw&&Q.windowBits>0)Q.windowBits=-Q.windowBits;else if(Q.gzip&&Q.windowBits>0&&Q.windowBits<16)Q.windowBits+=16;this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new G7,this.strm.avail_out=0;let J=I1.deflateInit2(this.strm,Q.level,Q.method,Q.windowBits,Q.memLevel,Q.strategy);if(J!==G8)throw new Error(p0[J]);if(Q.header)I1.deflateSetHeader(this.strm,Q.header);if(Q.dictionary){let G;if(typeof Q.dictionary==="string")G=T1.string2buf(Q.dictionary);else if(V7.call(Q.dictionary)==="[object ArrayBuffer]")G=new Uint8Array(Q.dictionary);else G=Q.dictionary;if(J=I1.deflateSetDictionary(this.strm,G),J!==G8)throw new Error(p0[J]);this._dict_set=!0}},q6=function(W,Q){const J=new p1(Q);if(J.push(W,!0),J.err)throw J.msg||p0[J.err];return J.result},SQ=function(W,Q){return Q=Q||{},Q.raw=!0,q6(W,Q)},TQ=function(W,Q){return Q=Q||{},Q.gzip=!0,q6(W,Q)},J9=function(){this.strm=null,this.mode=0,this.last=!1,this.wrap=0,this.havedict=!1,this.flags=0,this.dmax=0,this.check=0,this.total=0,this.head=null,this.wbits=0,this.wsize=0,this.whave=0,this.wnext=0,this.window=null,this.hold=0,this.bits=0,this.length=0,this.offset=0,this.extra=0,this.lencode=null,this.distcode=null,this.lenbits=0,this.distbits=0,this.ncode=0,this.nlen=0,this.ndist=0,this.have=0,this.next=null,this.lens=new Uint16Array(320),this.work=new Uint16Array(288),this.lendyn=null,this.distdyn=null,this.sane=0,this.back=0,this.was=0},M9=function(){this.text=0,this.time=0,this.xflags=0,this.os=0,this.extra=null,this.extra_len=0,this.name="",this.comment="",this.hcrc=0,this.done=!1},f1=function(W){this.options=X8.assign({chunkSize:65536,windowBits:15,to:""},W||{});const Q=this.options;if(Q.raw&&Q.windowBits>=0&&Q.windowBits<16){if(Q.windowBits=-Q.windowBits,Q.windowBits===0)Q.windowBits=-15}if(Q.windowBits>=0&&Q.windowBits<16&&!(W&&W.windowBits))Q.windowBits+=32;if(Q.windowBits>15&&Q.windowBits<48){if((Q.windowBits&15)===0)Q.windowBits|=15}this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new G7,this.strm.avail_out=0;let J=B0.inflateInit2(this.strm,Q.windowBits);if(J!==A1)throw new Error(p0[J]);if(this.header=new B9,B0.inflateGetHeader(this.strm,this.header),Q.dictionary){if(typeof Q.dictionary==="string")Q.dictionary=T1.string2buf(Q.dictionary);else if($7.call(Q.dictionary)==="[object ArrayBuffer]")Q.dictionary=new Uint8Array(Q.dictionary);if(Q.raw){if(J=B0.inflateSetDictionary(this.strm,Q.dictionary),J!==A1)throw new Error(p0[J])}}},X6=function(W,Q){const J=new f1(Q);if(J.push(W),J.err)throw J.msg||p0[J.err];return J.result},I9=function(W,Q){return Q=Q||{},Q.raw=!0,X6(W,Q)};/*! pako 2.1.0 https://github.com/nodeca/pako @license (MIT AND Zlib) */var tW=0,p5=1,WJ=2,JJ=3,QJ=258,W6=29,y1=256,w1=y1+1+W6,Q1=30,J6=19,f5=2*w1+1,A0=15,S8=16,GJ=7,Q6=256,h5=16,b5=17,m5=18,l8=new Uint8Array([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0]),J8=new Uint8Array([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13]),VJ=new Uint8Array([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7]),u5=new Uint8Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),qJ=512,M0=new Array((w1+2)*2);q1(M0);var O1=new Array(Q1*2);q1(O1);var D1=new Array(qJ);q1(D1);var N1=new Array(QJ-JJ+1);q1(N1);var G6=new Array(W6);q1(G6);var Q8=new Array(Q1);q1(Q8);var d5,c5,_5,l5=(W)=>{return W<256?D1[W]:D1[256+(W>>>7)]},v1=(W,Q)=>{W.pending_buf[W.pending++]=Q&255,W.pending_buf[W.pending++]=Q>>>8&255},J0=(W,Q,J)=>{if(W.bi_valid>S8-J)W.bi_buf|=Q<<W.bi_valid&65535,v1(W,W.bi_buf),W.bi_buf=Q>>S8-W.bi_valid,W.bi_valid+=J-S8;else W.bi_buf|=Q<<W.bi_valid&65535,W.bi_valid+=J},z0=(W,Q,J)=>{J0(W,J[Q*2],J[Q*2+1])},i5=(W,Q)=>{let J=0;do J|=W&1,W>>>=1,J<<=1;while(--Q>0);return J>>>1},XJ=(W)=>{if(W.bi_valid===16)v1(W,W.bi_buf),W.bi_buf=0,W.bi_valid=0;else if(W.bi_valid>=8)W.pending_buf[W.pending++]=W.bi_buf&255,W.bi_buf>>=8,W.bi_valid-=8},YJ=(W,Q)=>{const{dyn_tree:J,max_code:G}=Q,V=Q.stat_desc.static_tree,q=Q.stat_desc.has_stree,X=Q.stat_desc.extra_bits,Y=Q.stat_desc.extra_base,F=Q.stat_desc.max_length;let P,U,k,K,z,C,v=0;for(K=0;K<=A0;K++)W.bl_count[K]=0;J[W.heap[W.heap_max]*2+1]=0;for(P=W.heap_max+1;P<f5;P++){if(U=W.heap[P],K=J[J[U*2+1]*2+1]+1,K>F)K=F,v++;if(J[U*2+1]=K,U>G)continue;if(W.bl_count[K]++,z=0,U>=Y)z=X[U-Y];if(C=J[U*2],W.opt_len+=C*(K+z),q)W.static_len+=C*(V[U*2+1]+z)}if(v===0)return;do{K=F-1;while(W.bl_count[K]===0)K--;W.bl_count[K]--,W.bl_count[K+1]+=2,W.bl_count[F]--,v-=2}while(v>0);for(K=F;K!==0;K--){U=W.bl_count[K];while(U!==0){if(k=W.heap[--P],k>G)continue;if(J[k*2+1]!==K)W.opt_len+=(K-J[k*2+1])*J[k*2],J[k*2+1]=K;U--}}},o5=(W,Q,J)=>{const G=new Array(A0+1);let V=0,q,X;for(q=1;q<=A0;q++)V=V+J[q-1]<<1,G[q]=V;for(X=0;X<=Q;X++){let Y=W[X*2+1];if(Y===0)continue;W[X*2]=i5(G[Y]++,Y)}},PJ=()=>{let W,Q,J,G,V;const q=new Array(A0+1);J=0;for(G=0;G<W6-1;G++){G6[G]=J;for(W=0;W<1<<l8[G];W++)N1[J++]=G}N1[J-1]=G,V=0;for(G=0;G<16;G++){Q8[G]=V;for(W=0;W<1<<J8[G];W++)D1[V++]=G}V>>=7;for(;G<Q1;G++){Q8[G]=V<<7;for(W=0;W<1<<J8[G]-7;W++)D1[256+V++]=G}for(Q=0;Q<=A0;Q++)q[Q]=0;W=0;while(W<=143)M0[W*2+1]=8,W++,q[8]++;while(W<=255)M0[W*2+1]=9,W++,q[9]++;while(W<=279)M0[W*2+1]=7,W++,q[7]++;while(W<=287)M0[W*2+1]=8,W++,q[8]++;o5(M0,w1+1,q);for(W=0;W<Q1;W++)O1[W*2+1]=5,O1[W*2]=i5(W,5);d5=new T8(M0,l8,y1+1,w1,A0),c5=new T8(O1,J8,0,Q1,A0),_5=new T8(new Array(0),VJ,0,J6,GJ)},r5=(W)=>{let Q;for(Q=0;Q<w1;Q++)W.dyn_ltree[Q*2]=0;for(Q=0;Q<Q1;Q++)W.dyn_dtree[Q*2]=0;for(Q=0;Q<J6;Q++)W.bl_tree[Q*2]=0;W.dyn_ltree[Q6*2]=1,W.opt_len=W.static_len=0,W.sym_next=W.matches=0},a5=(W)=>{if(W.bi_valid>8)v1(W,W.bi_buf);else if(W.bi_valid>0)W.pending_buf[W.pending++]=W.bi_buf;W.bi_buf=0,W.bi_valid=0},e6=(W,Q,J,G)=>{const V=Q*2,q=J*2;return W[V]<W[q]||W[V]===W[q]&&G[Q]<=G[J]},y8=(W,Q,J)=>{const G=W.heap[J];let V=J<<1;while(V<=W.heap_len){if(V<W.heap_len&&e6(Q,W.heap[V+1],W.heap[V],W.depth))V++;if(e6(Q,G,W.heap[V],W.depth))break;W.heap[J]=W.heap[V],J=V,V<<=1}W.heap[J]=G},t6=(W,Q,J)=>{let G,V,q=0,X,Y;if(W.sym_next!==0)do if(G=W.pending_buf[W.sym_buf+q++]&255,G+=(W.pending_buf[W.sym_buf+q++]&255)<<8,V=W.pending_buf[W.sym_buf+q++],G===0)z0(W,V,Q);else{if(X=N1[V],z0(W,X+y1+1,Q),Y=l8[X],Y!==0)V-=G6[X],J0(W,V,Y);if(G--,X=l5(G),z0(W,X,J),Y=J8[X],Y!==0)G-=Q8[X],J0(W,G,Y)}while(q<W.sym_next);z0(W,Q6,Q)},i8=(W,Q)=>{const J=Q.dyn_tree,G=Q.stat_desc.static_tree,V=Q.stat_desc.has_stree,q=Q.stat_desc.elems;let X,Y,F=-1,P;W.heap_len=0,W.heap_max=f5;for(X=0;X<q;X++)if(J[X*2]!==0)W.heap[++W.heap_len]=F=X,W.depth[X]=0;else J[X*2+1]=0;while(W.heap_len<2)if(P=W.heap[++W.heap_len]=F<2?++F:0,J[P*2]=1,W.depth[P]=0,W.opt_len--,V)W.static_len-=G[P*2+1];Q.max_code=F;for(X=W.heap_len>>1;X>=1;X--)y8(W,J,X);P=q;do X=W.heap[1],W.heap[1]=W.heap[W.heap_len--],y8(W,J,1),Y=W.heap[1],W.heap[--W.heap_max]=X,W.heap[--W.heap_max]=Y,J[P*2]=J[X*2]+J[Y*2],W.depth[P]=(W.depth[X]>=W.depth[Y]?W.depth[X]:W.depth[Y])+1,J[X*2+1]=J[Y*2+1]=P,W.heap[1]=P++,y8(W,J,1);while(W.heap_len>=2);W.heap[--W.heap_max]=W.heap[1],YJ(W,Q),o5(J,F,W.bl_count)},W5=(W,Q,J)=>{let G,V=-1,q,X=Q[1],Y=0,F=7,P=4;if(X===0)F=138,P=3;Q[(J+1)*2+1]=65535;for(G=0;G<=J;G++){if(q=X,X=Q[(G+1)*2+1],++Y<F&&q===X)continue;else if(Y<P)W.bl_tree[q*2]+=Y;else if(q!==0){if(q!==V)W.bl_tree[q*2]++;W.bl_tree[h5*2]++}else if(Y<=10)W.bl_tree[b5*2]++;else W.bl_tree[m5*2]++;if(Y=0,V=q,X===0)F=138,P=3;else if(q===X)F=6,P=3;else F=7,P=4}},J5=(W,Q,J)=>{let G,V=-1,q,X=Q[1],Y=0,F=7,P=4;if(X===0)F=138,P=3;for(G=0;G<=J;G++){if(q=X,X=Q[(G+1)*2+1],++Y<F&&q===X)continue;else if(Y<P)do z0(W,q,W.bl_tree);while(--Y!==0);else if(q!==0){if(q!==V)z0(W,q,W.bl_tree),Y--;z0(W,h5,W.bl_tree),J0(W,Y-3,2)}else if(Y<=10)z0(W,b5,W.bl_tree),J0(W,Y-3,3);else z0(W,m5,W.bl_tree),J0(W,Y-11,7);if(Y=0,V=q,X===0)F=138,P=3;else if(q===X)F=6,P=3;else F=7,P=4}},UJ=(W)=>{let Q;W5(W,W.dyn_ltree,W.l_desc.max_code),W5(W,W.dyn_dtree,W.d_desc.max_code),i8(W,W.bl_desc);for(Q=J6-1;Q>=3;Q--)if(W.bl_tree[u5[Q]*2+1]!==0)break;return W.opt_len+=3*(Q+1)+5+5+4,Q},FJ=(W,Q,J,G)=>{let V;J0(W,Q-257,5),J0(W,J-1,5),J0(W,G-4,4);for(V=0;V<G;V++)J0(W,W.bl_tree[u5[V]*2+1],3);J5(W,W.dyn_ltree,Q-1),J5(W,W.dyn_dtree,J-1)},KJ=(W)=>{let Q=4093624447,J;for(J=0;J<=31;J++,Q>>>=1)if(Q&1&&W.dyn_ltree[J*2]!==0)return 0;if(W.dyn_ltree[18]!==0||W.dyn_ltree[20]!==0||W.dyn_ltree[26]!==0)return 1;for(J=32;J<y1;J++)if(W.dyn_ltree[J*2]!==0)return 1;return 0},Q5=!1,zJ=(W)=>{if(!Q5)PJ(),Q5=!0;W.l_desc=new A8(W.dyn_ltree,d5),W.d_desc=new A8(W.dyn_dtree,c5),W.bl_desc=new A8(W.bl_tree,_5),W.bi_buf=0,W.bi_valid=0,r5(W)},n5=(W,Q,J,G)=>{if(J0(W,(tW<<1)+(G?1:0),3),a5(W),v1(W,J),v1(W,~J),J)W.pending_buf.set(W.window.subarray(Q,Q+J),W.pending);W.pending+=J},ZJ=(W)=>{J0(W,p5<<1,3),z0(W,Q6,M0),XJ(W)},kJ=(W,Q,J,G)=>{let V,q,X=0;if(W.level>0){if(W.strm.data_type===2)W.strm.data_type=KJ(W);if(i8(W,W.l_desc),i8(W,W.d_desc),X=UJ(W),V=W.opt_len+3+7>>>3,q=W.static_len+3+7>>>3,q<=V)V=q}else V=q=J+5;if(J+4<=V&&Q!==-1)n5(W,Q,J,G);else if(W.strategy===4||q===V)J0(W,(p5<<1)+(G?1:0),3),t6(W,M0,O1);else J0(W,(WJ<<1)+(G?1:0),3),FJ(W,W.l_desc.max_code+1,W.d_desc.max_code+1,X+1),t6(W,W.dyn_ltree,W.dyn_dtree);if(r5(W),G)a5(W)},HJ=(W,Q,J)=>{if(W.pending_buf[W.sym_buf+W.sym_next++]=Q,W.pending_buf[W.sym_buf+W.sym_next++]=Q>>8,W.pending_buf[W.sym_buf+W.sym_next++]=J,Q===0)W.dyn_ltree[J*2]++;else W.matches++,Q--,W.dyn_ltree[(N1[J]+y1+1)*2]++,W.dyn_dtree[l5(Q)*2]++;return W.sym_next===W.sym_end},$J=zJ,CJ=n5,MJ=kJ,BJ=HJ,jJ=ZJ,LJ={_tr_init:$J,_tr_stored_block:CJ,_tr_flush_block:MJ,_tr_tally:BJ,_tr_align:jJ},RJ=(W,Q,J,G)=>{let V=W&65535|0,q=W>>>16&65535|0,X=0;while(J!==0){X=J>2000?2000:J,J-=X;do V=V+Q[G++]|0,q=q+V|0;while(--X);V%=65521,q%=65521}return V|q<<16|0},g1=RJ,OJ=()=>{let W,Q=[];for(var J=0;J<256;J++){W=J;for(var G=0;G<8;G++)W=W&1?3988292384^W>>>1:W>>>1;Q[J]=W}return Q},IJ=new Uint32Array(OJ()),xJ=(W,Q,J,G)=>{const V=IJ,q=G+J;W^=-1;for(let X=G;X<q;X++)W=W>>>8^V[(W^Q[X])&255];return W^-1},n=xJ,p0={2:"need dictionary",1:"stream end",0:"","-1":"file error","-2":"stream error","-3":"data error","-4":"insufficient memory","-5":"buffer error","-6":"incompatible version"},b0={Z_NO_FLUSH:0,Z_PARTIAL_FLUSH:1,Z_SYNC_FLUSH:2,Z_FULL_FLUSH:3,Z_FINISH:4,Z_BLOCK:5,Z_TREES:6,Z_OK:0,Z_STREAM_END:1,Z_NEED_DICT:2,Z_ERRNO:-1,Z_STREAM_ERROR:-2,Z_DATA_ERROR:-3,Z_MEM_ERROR:-4,Z_BUF_ERROR:-5,Z_NO_COMPRESSION:0,Z_BEST_SPEED:1,Z_BEST_COMPRESSION:9,Z_DEFAULT_COMPRESSION:-1,Z_FILTERED:1,Z_HUFFMAN_ONLY:2,Z_RLE:3,Z_FIXED:4,Z_DEFAULT_STRATEGY:0,Z_BINARY:0,Z_TEXT:1,Z_UNKNOWN:2,Z_DEFLATED:8},{_tr_init:wJ,_tr_stored_block:o8,_tr_flush_block:DJ,_tr_tally:D0,_tr_align:NJ}=LJ,{Z_NO_FLUSH:N0,Z_PARTIAL_FLUSH:vJ,Z_FULL_FLUSH:gJ,Z_FINISH:Y0,Z_BLOCK:G5,Z_OK:s,Z_STREAM_END:V5,Z_STREAM_ERROR:Z0,Z_DATA_ERROR:SJ,Z_BUF_ERROR:E8,Z_DEFAULT_COMPRESSION:TJ,Z_FILTERED:AJ,Z_HUFFMAN_ONLY:n1,Z_RLE:yJ,Z_FIXED:EJ,Z_DEFAULT_STRATEGY:pJ,Z_UNKNOWN:fJ,Z_DEFLATED:q8}=b0,hJ=9,bJ=15,mJ=8,uJ=29,dJ=256,r8=dJ+1+uJ,cJ=30,_J=19,lJ=2*r8+1,iJ=15,d=3,w0=258,k0=w0+d+1,oJ=32,G1=42,V6=57,a8=69,n8=73,s8=91,e8=103,y0=113,L1=666,t=1,X1=2,f0=3,Y1=4,rJ=3,E0=(W,Q)=>{return W.msg=p0[Q],Q},q5=(W)=>{return W*2-(W>4?9:0)},x0=(W)=>{let Q=W.length;while(--Q>=0)W[Q]=0},aJ=(W)=>{let Q,J,G,V=W.w_size;Q=W.hash_size,G=Q;do J=W.head[--G],W.head[G]=J>=V?J-V:0;while(--Q);Q=V,G=Q;do J=W.prev[--G],W.prev[G]=J>=V?J-V:0;while(--Q)},nJ=(W,Q,J)=>(Q<<W.hash_shift^J)&W.hash_mask,v0=nJ,V0=(W)=>{const Q=W.state;let J=Q.pending;if(J>W.avail_out)J=W.avail_out;if(J===0)return;if(W.output.set(Q.pending_buf.subarray(Q.pending_out,Q.pending_out+J),W.next_out),W.next_out+=J,Q.pending_out+=J,W.total_out+=J,W.avail_out-=J,Q.pending-=J,Q.pending===0)Q.pending_out=0},q0=(W,Q)=>{DJ(W,W.block_start>=0?W.block_start:-1,W.strstart-W.block_start,Q),W.block_start=W.strstart,V0(W.strm)},l=(W,Q)=>{W.pending_buf[W.pending++]=Q},j1=(W,Q)=>{W.pending_buf[W.pending++]=Q>>>8&255,W.pending_buf[W.pending++]=Q&255},t8=(W,Q,J,G)=>{let V=W.avail_in;if(V>G)V=G;if(V===0)return 0;if(W.avail_in-=V,Q.set(W.input.subarray(W.next_in,W.next_in+V),J),W.state.wrap===1)W.adler=g1(W.adler,Q,V,J);else if(W.state.wrap===2)W.adler=n(W.adler,Q,V,J);return W.next_in+=V,W.total_in+=V,V},s5=(W,Q)=>{let{max_chain_length:J,strstart:G}=W,V,q,X=W.prev_length,Y=W.nice_match;const F=W.strstart>W.w_size-k0?W.strstart-(W.w_size-k0):0,P=W.window,U=W.w_mask,k=W.prev,K=W.strstart+w0;let z=P[G+X-1],C=P[G+X];if(W.prev_length>=W.good_match)J>>=2;if(Y>W.lookahead)Y=W.lookahead;do{if(V=Q,P[V+X]!==C||P[V+X-1]!==z||P[V]!==P[G]||P[++V]!==P[G+1])continue;G+=2,V++;do;while(P[++G]===P[++V]&&P[++G]===P[++V]&&P[++G]===P[++V]&&P[++G]===P[++V]&&P[++G]===P[++V]&&P[++G]===P[++V]&&P[++G]===P[++V]&&P[++G]===P[++V]&&G<K);if(q=w0-(K-G),G=K-w0,q>X){if(W.match_start=Q,X=q,q>=Y)break;z=P[G+X-1],C=P[G+X]}}while((Q=k[Q&U])>F&&--J!==0);if(X<=W.lookahead)return X;return W.lookahead},V1=(W)=>{const Q=W.w_size;let J,G,V;do{if(G=W.window_size-W.lookahead-W.strstart,W.strstart>=Q+(Q-k0)){if(W.window.set(W.window.subarray(Q,Q+Q-G),0),W.match_start-=Q,W.strstart-=Q,W.block_start-=Q,W.insert>W.strstart)W.insert=W.strstart;aJ(W),G+=Q}if(W.strm.avail_in===0)break;if(J=t8(W.strm,W.window,W.strstart+W.lookahead,G),W.lookahead+=J,W.lookahead+W.insert>=d){V=W.strstart-W.insert,W.ins_h=W.window[V],W.ins_h=v0(W,W.ins_h,W.window[V+1]);while(W.insert)if(W.ins_h=v0(W,W.ins_h,W.window[V+d-1]),W.prev[V&W.w_mask]=W.head[W.ins_h],W.head[W.ins_h]=V,V++,W.insert--,W.lookahead+W.insert<d)break}}while(W.lookahead<k0&&W.strm.avail_in!==0)},e5=(W,Q)=>{let J=W.pending_buf_size-5>W.w_size?W.w_size:W.pending_buf_size-5,G,V,q,X=0,Y=W.strm.avail_in;do{if(G=65535,q=W.bi_valid+42>>3,W.strm.avail_out<q)break;if(q=W.strm.avail_out-q,V=W.strstart-W.block_start,G>V+W.strm.avail_in)G=V+W.strm.avail_in;if(G>q)G=q;if(G<J&&(G===0&&Q!==Y0||Q===N0||G!==V+W.strm.avail_in))break;if(X=Q===Y0&&G===V+W.strm.avail_in?1:0,o8(W,0,0,X),W.pending_buf[W.pending-4]=G,W.pending_buf[W.pending-3]=G>>8,W.pending_buf[W.pending-2]=~G,W.pending_buf[W.pending-1]=~G>>8,V0(W.strm),V){if(V>G)V=G;W.strm.output.set(W.window.subarray(W.block_start,W.block_start+V),W.strm.next_out),W.strm.next_out+=V,W.strm.avail_out-=V,W.strm.total_out+=V,W.block_start+=V,G-=V}if(G)t8(W.strm,W.strm.output,W.strm.next_out,G),W.strm.next_out+=G,W.strm.avail_out-=G,W.strm.total_out+=G}while(X===0);if(Y-=W.strm.avail_in,Y){if(Y>=W.w_size)W.matches=2,W.window.set(W.strm.input.subarray(W.strm.next_in-W.w_size,W.strm.next_in),0),W.strstart=W.w_size,W.insert=W.strstart;else{if(W.window_size-W.strstart<=Y){if(W.strstart-=W.w_size,W.window.set(W.window.subarray(W.w_size,W.w_size+W.strstart),0),W.matches<2)W.matches++;if(W.insert>W.strstart)W.insert=W.strstart}W.window.set(W.strm.input.subarray(W.strm.next_in-Y,W.strm.next_in),W.strstart),W.strstart+=Y,W.insert+=Y>W.w_size-W.insert?W.w_size-W.insert:Y}W.block_start=W.strstart}if(W.high_water<W.strstart)W.high_water=W.strstart;if(X)return Y1;if(Q!==N0&&Q!==Y0&&W.strm.avail_in===0&&W.strstart===W.block_start)return X1;if(q=W.window_size-W.strstart,W.strm.avail_in>q&&W.block_start>=W.w_size){if(W.block_start-=W.w_size,W.strstart-=W.w_size,W.window.set(W.window.subarray(W.w_size,W.w_size+W.strstart),0),W.matches<2)W.matches++;if(q+=W.w_size,W.insert>W.strstart)W.insert=W.strstart}if(q>W.strm.avail_in)q=W.strm.avail_in;if(q)t8(W.strm,W.window,W.strstart,q),W.strstart+=q,W.insert+=q>W.w_size-W.insert?W.w_size-W.insert:q;if(W.high_water<W.strstart)W.high_water=W.strstart;if(q=W.bi_valid+42>>3,q=W.pending_buf_size-q>65535?65535:W.pending_buf_size-q,J=q>W.w_size?W.w_size:q,V=W.strstart-W.block_start,V>=J||(V||Q===Y0)&&Q!==N0&&W.strm.avail_in===0&&V<=q)G=V>q?q:V,X=Q===Y0&&W.strm.avail_in===0&&G===V?1:0,o8(W,W.block_start,G,X),W.block_start+=G,V0(W.strm);return X?f0:t},p8=(W,Q)=>{let J,G;for(;;){if(W.lookahead<k0){if(V1(W),W.lookahead<k0&&Q===N0)return t;if(W.lookahead===0)break}if(J=0,W.lookahead>=d)W.ins_h=v0(W,W.ins_h,W.window[W.strstart+d-1]),J=W.prev[W.strstart&W.w_mask]=W.head[W.ins_h],W.head[W.ins_h]=W.strstart;if(J!==0&&W.strstart-J<=W.w_size-k0)W.match_length=s5(W,J);if(W.match_length>=d)if(G=D0(W,W.strstart-W.match_start,W.match_length-d),W.lookahead-=W.match_length,W.match_length<=W.max_lazy_match&&W.lookahead>=d){W.match_length--;do W.strstart++,W.ins_h=v0(W,W.ins_h,W.window[W.strstart+d-1]),J=W.prev[W.strstart&W.w_mask]=W.head[W.ins_h],W.head[W.ins_h]=W.strstart;while(--W.match_length!==0);W.strstart++}else W.strstart+=W.match_length,W.match_length=0,W.ins_h=W.window[W.strstart],W.ins_h=v0(W,W.ins_h,W.window[W.strstart+1]);else G=D0(W,0,W.window[W.strstart]),W.lookahead--,W.strstart++;if(G){if(q0(W,!1),W.strm.avail_out===0)return t}}if(W.insert=W.strstart<d-1?W.strstart:d-1,Q===Y0){if(q0(W,!0),W.strm.avail_out===0)return f0;return Y1}if(W.sym_next){if(q0(W,!1),W.strm.avail_out===0)return t}return X1},W1=(W,Q)=>{let J,G,V;for(;;){if(W.lookahead<k0){if(V1(W),W.lookahead<k0&&Q===N0)return t;if(W.lookahead===0)break}if(J=0,W.lookahead>=d)W.ins_h=v0(W,W.ins_h,W.window[W.strstart+d-1]),J=W.prev[W.strstart&W.w_mask]=W.head[W.ins_h],W.head[W.ins_h]=W.strstart;if(W.prev_length=W.match_length,W.prev_match=W.match_start,W.match_length=d-1,J!==0&&W.prev_length<W.max_lazy_match&&W.strstart-J<=W.w_size-k0){if(W.match_length=s5(W,J),W.match_length<=5&&(W.strategy===AJ||W.match_length===d&&W.strstart-W.match_start>4096))W.match_length=d-1}if(W.prev_length>=d&&W.match_length<=W.prev_length){V=W.strstart+W.lookahead-d,G=D0(W,W.strstart-1-W.prev_match,W.prev_length-d),W.lookahead-=W.prev_length-1,W.prev_length-=2;do if(++W.strstart<=V)W.ins_h=v0(W,W.ins_h,W.window[W.strstart+d-1]),J=W.prev[W.strstart&W.w_mask]=W.head[W.ins_h],W.head[W.ins_h]=W.strstart;while(--W.prev_length!==0);if(W.match_available=0,W.match_length=d-1,W.strstart++,G){if(q0(W,!1),W.strm.avail_out===0)return t}}else if(W.match_available){if(G=D0(W,0,W.window[W.strstart-1]),G)q0(W,!1);if(W.strstart++,W.lookahead--,W.strm.avail_out===0)return t}else W.match_available=1,W.strstart++,W.lookahead--}if(W.match_available)G=D0(W,0,W.window[W.strstart-1]),W.match_available=0;if(W.insert=W.strstart<d-1?W.strstart:d-1,Q===Y0){if(q0(W,!0),W.strm.avail_out===0)return f0;return Y1}if(W.sym_next){if(q0(W,!1),W.strm.avail_out===0)return t}return X1},sJ=(W,Q)=>{let J,G,V,q;const X=W.window;for(;;){if(W.lookahead<=w0){if(V1(W),W.lookahead<=w0&&Q===N0)return t;if(W.lookahead===0)break}if(W.match_length=0,W.lookahead>=d&&W.strstart>0){if(V=W.strstart-1,G=X[V],G===X[++V]&&G===X[++V]&&G===X[++V]){q=W.strstart+w0;do;while(G===X[++V]&&G===X[++V]&&G===X[++V]&&G===X[++V]&&G===X[++V]&&G===X[++V]&&G===X[++V]&&G===X[++V]&&V<q);if(W.match_length=w0-(q-V),W.match_length>W.lookahead)W.match_length=W.lookahead}}if(W.match_length>=d)J=D0(W,1,W.match_length-d),W.lookahead-=W.match_length,W.strstart+=W.match_length,W.match_length=0;else J=D0(W,0,W.window[W.strstart]),W.lookahead--,W.strstart++;if(J){if(q0(W,!1),W.strm.avail_out===0)return t}}if(W.insert=0,Q===Y0){if(q0(W,!0),W.strm.avail_out===0)return f0;return Y1}if(W.sym_next){if(q0(W,!1),W.strm.avail_out===0)return t}return X1},eJ=(W,Q)=>{let J;for(;;){if(W.lookahead===0){if(V1(W),W.lookahead===0){if(Q===N0)return t;break}}if(W.match_length=0,J=D0(W,0,W.window[W.strstart]),W.lookahead--,W.strstart++,J){if(q0(W,!1),W.strm.avail_out===0)return t}}if(W.insert=0,Q===Y0){if(q0(W,!0),W.strm.avail_out===0)return f0;return Y1}if(W.sym_next){if(q0(W,!1),W.strm.avail_out===0)return t}return X1},R1=[new K0(0,0,0,0,e5),new K0(4,4,8,4,p8),new K0(4,5,16,8,p8),new K0(4,6,32,32,p8),new K0(4,4,16,16,W1),new K0(8,16,32,32,W1),new K0(8,16,128,128,W1),new K0(8,32,128,256,W1),new K0(32,128,258,1024,W1),new K0(32,258,258,4096,W1)],tJ=(W)=>{W.window_size=2*W.w_size,x0(W.head),W.max_lazy_match=R1[W.level].max_lazy,W.good_match=R1[W.level].good_length,W.nice_match=R1[W.level].nice_length,W.max_chain_length=R1[W.level].max_chain,W.strstart=0,W.block_start=0,W.lookahead=0,W.insert=0,W.match_length=W.prev_length=d-1,W.match_available=0,W.ins_h=0},E1=(W)=>{if(!W)return 1;const Q=W.state;if(!Q||Q.strm!==W||Q.status!==G1&&Q.status!==V6&&Q.status!==a8&&Q.status!==n8&&Q.status!==s8&&Q.status!==e8&&Q.status!==y0&&Q.status!==L1)return 1;return 0},t5=(W)=>{if(E1(W))return E0(W,Z0);W.total_in=W.total_out=0,W.data_type=fJ;const Q=W.state;if(Q.pending=0,Q.pending_out=0,Q.wrap<0)Q.wrap=-Q.wrap;return Q.status=Q.wrap===2?V6:Q.wrap?G1:y0,W.adler=Q.wrap===2?0:1,Q.last_flush=-2,wJ(Q),s},W7=(W)=>{const Q=t5(W);if(Q===s)tJ(W.state);return Q},JQ=(W,Q)=>{if(E1(W)||W.state.wrap!==2)return Z0;return W.state.gzhead=Q,s},J7=(W,Q,J,G,V,q)=>{if(!W)return Z0;let X=1;if(Q===TJ)Q=6;if(G<0)X=0,G=-G;else if(G>15)X=2,G-=16;if(V<1||V>hJ||J!==q8||G<8||G>15||Q<0||Q>9||q<0||q>EJ||G===8&&X!==1)return E0(W,Z0);if(G===8)G=9;const Y=new WQ;return W.state=Y,Y.strm=W,Y.status=G1,Y.wrap=X,Y.gzhead=null,Y.w_bits=G,Y.w_size=1<<Y.w_bits,Y.w_mask=Y.w_size-1,Y.hash_bits=V+7,Y.hash_size=1<<Y.hash_bits,Y.hash_mask=Y.hash_size-1,Y.hash_shift=~~((Y.hash_bits+d-1)/d),Y.window=new Uint8Array(Y.w_size*2),Y.head=new Uint16Array(Y.hash_size),Y.prev=new Uint16Array(Y.w_size),Y.lit_bufsize=1<<V+6,Y.pending_buf_size=Y.lit_bufsize*4,Y.pending_buf=new Uint8Array(Y.pending_buf_size),Y.sym_buf=Y.lit_bufsize,Y.sym_end=(Y.lit_bufsize-1)*3,Y.level=Q,Y.strategy=q,Y.method=J,W7(W)},QQ=(W,Q)=>{return J7(W,Q,q8,bJ,mJ,pJ)},GQ=(W,Q)=>{if(E1(W)||Q>G5||Q<0)return W?E0(W,Z0):Z0;const J=W.state;if(!W.output||W.avail_in!==0&&!W.input||J.status===L1&&Q!==Y0)return E0(W,W.avail_out===0?E8:Z0);const G=J.last_flush;if(J.last_flush=Q,J.pending!==0){if(V0(W),W.avail_out===0)return J.last_flush=-1,s}else if(W.avail_in===0&&q5(Q)<=q5(G)&&Q!==Y0)return E0(W,E8);if(J.status===L1&&W.avail_in!==0)return E0(W,E8);if(J.status===G1&&J.wrap===0)J.status=y0;if(J.status===G1){let V=q8+(J.w_bits-8<<4)<<8,q=-1;if(J.strategy>=n1||J.level<2)q=0;else if(J.level<6)q=1;else if(J.level===6)q=2;else q=3;if(V|=q<<6,J.strstart!==0)V|=oJ;if(V+=31-V%31,j1(J,V),J.strstart!==0)j1(J,W.adler>>>16),j1(J,W.adler&65535);if(W.adler=1,J.status=y0,V0(W),J.pending!==0)return J.last_flush=-1,s}if(J.status===V6)if(W.adler=0,l(J,31),l(J,139),l(J,8),!J.gzhead){if(l(J,0),l(J,0),l(J,0),l(J,0),l(J,0),l(J,J.level===9?2:J.strategy>=n1||J.level<2?4:0),l(J,rJ),J.status=y0,V0(W),J.pending!==0)return J.last_flush=-1,s}else{if(l(J,(J.gzhead.text?1:0)+(J.gzhead.hcrc?2:0)+(!J.gzhead.extra?0:4)+(!J.gzhead.name?0:8)+(!J.gzhead.comment?0:16)),l(J,J.gzhead.time&255),l(J,J.gzhead.time>>8&255),l(J,J.gzhead.time>>16&255),l(J,J.gzhead.time>>24&255),l(J,J.level===9?2:J.strategy>=n1||J.level<2?4:0),l(J,J.gzhead.os&255),J.gzhead.extra&&J.gzhead.extra.length)l(J,J.gzhead.extra.length&255),l(J,J.gzhead.extra.length>>8&255);if(J.gzhead.hcrc)W.adler=n(W.adler,J.pending_buf,J.pending,0);J.gzindex=0,J.status=a8}if(J.status===a8){if(J.gzhead.extra){let V=J.pending,q=(J.gzhead.extra.length&65535)-J.gzindex;while(J.pending+q>J.pending_buf_size){let Y=J.pending_buf_size-J.pending;if(J.pending_buf.set(J.gzhead.extra.subarray(J.gzindex,J.gzindex+Y),J.pending),J.pending=J.pending_buf_size,J.gzhead.hcrc&&J.pending>V)W.adler=n(W.adler,J.pending_buf,J.pending-V,V);if(J.gzindex+=Y,V0(W),J.pending!==0)return J.last_flush=-1,s;V=0,q-=Y}let X=new Uint8Array(J.gzhead.extra);if(J.pending_buf.set(X.subarray(J.gzindex,J.gzindex+q),J.pending),J.pending+=q,J.gzhead.hcrc&&J.pending>V)W.adler=n(W.adler,J.pending_buf,J.pending-V,V);J.gzindex=0}J.status=n8}if(J.status===n8){if(J.gzhead.name){let V=J.pending,q;do{if(J.pending===J.pending_buf_size){if(J.gzhead.hcrc&&J.pending>V)W.adler=n(W.adler,J.pending_buf,J.pending-V,V);if(V0(W),J.pending!==0)return J.last_flush=-1,s;V=0}if(J.gzindex<J.gzhead.name.length)q=J.gzhead.name.charCodeAt(J.gzindex++)&255;else q=0;l(J,q)}while(q!==0);if(J.gzhead.hcrc&&J.pending>V)W.adler=n(W.adler,J.pending_buf,J.pending-V,V);J.gzindex=0}J.status=s8}if(J.status===s8){if(J.gzhead.comment){let V=J.pending,q;do{if(J.pending===J.pending_buf_size){if(J.gzhead.hcrc&&J.pending>V)W.adler=n(W.adler,J.pending_buf,J.pending-V,V);if(V0(W),J.pending!==0)return J.last_flush=-1,s;V=0}if(J.gzindex<J.gzhead.comment.length)q=J.gzhead.comment.charCodeAt(J.gzindex++)&255;else q=0;l(J,q)}while(q!==0);if(J.gzhead.hcrc&&J.pending>V)W.adler=n(W.adler,J.pending_buf,J.pending-V,V)}J.status=e8}if(J.status===e8){if(J.gzhead.hcrc){if(J.pending+2>J.pending_buf_size){if(V0(W),J.pending!==0)return J.last_flush=-1,s}l(J,W.adler&255),l(J,W.adler>>8&255),W.adler=0}if(J.status=y0,V0(W),J.pending!==0)return J.last_flush=-1,s}if(W.avail_in!==0||J.lookahead!==0||Q!==N0&&J.status!==L1){let V=J.level===0?e5(J,Q):J.strategy===n1?eJ(J,Q):J.strategy===yJ?sJ(J,Q):R1[J.level].func(J,Q);if(V===f0||V===Y1)J.status=L1;if(V===t||V===f0){if(W.avail_out===0)J.last_flush=-1;return s}if(V===X1){if(Q===vJ)NJ(J);else if(Q!==G5){if(o8(J,0,0,!1),Q===gJ){if(x0(J.head),J.lookahead===0)J.strstart=0,J.block_start=0,J.insert=0}}if(V0(W),W.avail_out===0)return J.last_flush=-1,s}}if(Q!==Y0)return s;if(J.wrap<=0)return V5;if(J.wrap===2)l(J,W.adler&255),l(J,W.adler>>8&255),l(J,W.adler>>16&255),l(J,W.adler>>24&255),l(J,W.total_in&255),l(J,W.total_in>>8&255),l(J,W.total_in>>16&255),l(J,W.total_in>>24&255);else j1(J,W.adler>>>16),j1(J,W.adler&65535);if(V0(W),J.wrap>0)J.wrap=-J.wrap;return J.pending!==0?s:V5},VQ=(W)=>{if(E1(W))return Z0;const Q=W.state.status;return W.state=null,Q===y0?E0(W,SJ):s},qQ=(W,Q)=>{let J=Q.length;if(E1(W))return Z0;const G=W.state,V=G.wrap;if(V===2||V===1&&G.status!==G1||G.lookahead)return Z0;if(V===1)W.adler=g1(W.adler,Q,J,0);if(G.wrap=0,J>=G.w_size){if(V===0)x0(G.head),G.strstart=0,G.block_start=0,G.insert=0;let F=new Uint8Array(G.w_size);F.set(Q.subarray(J-G.w_size,J),0),Q=F,J=G.w_size}const{avail_in:q,next_in:X,input:Y}=W;W.avail_in=J,W.next_in=0,W.input=Q,V1(G);while(G.lookahead>=d){let F=G.strstart,P=G.lookahead-(d-1);do G.ins_h=v0(G,G.ins_h,G.window[F+d-1]),G.prev[F&G.w_mask]=G.head[G.ins_h],G.head[G.ins_h]=F,F++;while(--P);G.strstart=F,G.lookahead=d-1,V1(G)}return G.strstart+=G.lookahead,G.block_start=G.strstart,G.insert=G.lookahead,G.lookahead=0,G.match_length=G.prev_length=d-1,G.match_available=0,W.next_in=X,W.input=Y,W.avail_in=q,G.wrap=V,s},XQ=QQ,YQ=J7,PQ=W7,UQ=t5,FQ=JQ,KQ=GQ,zQ=VQ,ZQ=qQ,kQ="pako deflate (from Nodeca project)",I1={deflateInit:XQ,deflateInit2:YQ,deflateReset:PQ,deflateResetKeep:UQ,deflateSetHeader:FQ,deflate:KQ,deflateEnd:zQ,deflateSetDictionary:ZQ,deflateInfo:kQ},HQ=(W,Q)=>{return Object.prototype.hasOwnProperty.call(W,Q)},$Q=function(W){const Q=Array.prototype.slice.call(arguments,1);while(Q.length){const J=Q.shift();if(!J)continue;if(typeof J!=="object")throw new TypeError(J+"must be non-object");for(let G in J)if(HQ(J,G))W[G]=J[G]}return W},CQ=(W)=>{let Q=0;for(let G=0,V=W.length;G<V;G++)Q+=W[G].length;const J=new Uint8Array(Q);for(let G=0,V=0,q=W.length;G<q;G++){let X=W[G];J.set(X,V),V+=X.length}return J},X8={assign:$Q,flattenChunks:CQ},Q7=!0;try{String.fromCharCode.apply(null,new Uint8Array(1))}catch(W){Q7=!1}var S1=new Uint8Array(256);for(let W=0;W<256;W++)S1[W]=W>=252?6:W>=248?5:W>=240?4:W>=224?3:W>=192?2:1;S1[254]=S1[254]=1;var MQ=(W)=>{if(typeof TextEncoder==="function"&&TextEncoder.prototype.encode)return(new TextEncoder()).encode(W);let Q,J,G,V,q,X=W.length,Y=0;for(V=0;V<X;V++){if(J=W.charCodeAt(V),(J&64512)===55296&&V+1<X){if(G=W.charCodeAt(V+1),(G&64512)===56320)J=65536+(J-55296<<10)+(G-56320),V++}Y+=J<128?1:J<2048?2:J<65536?3:4}Q=new Uint8Array(Y);for(q=0,V=0;q<Y;V++){if(J=W.charCodeAt(V),(J&64512)===55296&&V+1<X){if(G=W.charCodeAt(V+1),(G&64512)===56320)J=65536+(J-55296<<10)+(G-56320),V++}if(J<128)Q[q++]=J;else if(J<2048)Q[q++]=192|J>>>6,Q[q++]=128|J&63;else if(J<65536)Q[q++]=224|J>>>12,Q[q++]=128|J>>>6&63,Q[q++]=128|J&63;else Q[q++]=240|J>>>18,Q[q++]=128|J>>>12&63,Q[q++]=128|J>>>6&63,Q[q++]=128|J&63}return Q},BQ=(W,Q)=>{if(Q<65534){if(W.subarray&&Q7)return String.fromCharCode.apply(null,W.length===Q?W:W.subarray(0,Q))}let J="";for(let G=0;G<Q;G++)J+=String.fromCharCode(W[G]);return J},jQ=(W,Q)=>{const J=Q||W.length;if(typeof TextDecoder==="function"&&TextDecoder.prototype.decode)return(new TextDecoder()).decode(W.subarray(0,Q));let G,V;const q=new Array(J*2);for(V=0,G=0;G<J;){let X=W[G++];if(X<128){q[V++]=X;continue}let Y=S1[X];if(Y>4){q[V++]=65533,G+=Y-1;continue}X&=Y===2?31:Y===3?15:7;while(Y>1&&G<J)X=X<<6|W[G++]&63,Y--;if(Y>1){q[V++]=65533;continue}if(X<65536)q[V++]=X;else X-=65536,q[V++]=55296|X>>10&1023,q[V++]=56320|X&1023}return BQ(q,V)},LQ=(W,Q)=>{if(Q=Q||W.length,Q>W.length)Q=W.length;let J=Q-1;while(J>=0&&(W[J]&192)===128)J--;if(J<0)return Q;if(J===0)return Q;return J+S1[W[J]]>Q?J:Q},T1={string2buf:MQ,buf2string:jQ,utf8border:LQ},G7=RQ,V7=Object.prototype.toString,{Z_NO_FLUSH:OQ,Z_SYNC_FLUSH:IQ,Z_FULL_FLUSH:xQ,Z_FINISH:wQ,Z_OK:G8,Z_STREAM_END:DQ,Z_DEFAULT_COMPRESSION:NQ,Z_DEFAULT_STRATEGY:vQ,Z_DEFLATED:gQ}=b0;p1.prototype.push=function(W,Q){const J=this.strm,G=this.options.chunkSize;let V,q;if(this.ended)return!1;if(Q===~~Q)q=Q;else q=Q===!0?wQ:OQ;if(typeof W==="string")J.input=T1.string2buf(W);else if(V7.call(W)==="[object ArrayBuffer]")J.input=new Uint8Array(W);else J.input=W;J.next_in=0,J.avail_in=J.input.length;for(;;){if(J.avail_out===0)J.output=new Uint8Array(G),J.next_out=0,J.avail_out=G;if((q===IQ||q===xQ)&&J.avail_out<=6){this.onData(J.output.subarray(0,J.next_out)),J.avail_out=0;continue}if(V=I1.deflate(J,q),V===DQ){if(J.next_out>0)this.onData(J.output.subarray(0,J.next_out));return V=I1.deflateEnd(this.strm),this.onEnd(V),this.ended=!0,V===G8}if(J.avail_out===0){this.onData(J.output);continue}if(q>0&&J.next_out>0){this.onData(J.output.subarray(0,J.next_out)),J.avail_out=0;continue}if(J.avail_in===0)break}return!0};p1.prototype.onData=function(W){this.chunks.push(W)};p1.prototype.onEnd=function(W){if(W===G8)this.result=X8.flattenChunks(this.chunks);this.chunks=[],this.err=W,this.msg=this.strm.msg};var AQ=p1,yQ=q6,EQ=SQ,pQ=TQ,fQ=b0,hQ={Deflate:AQ,deflate:yQ,deflateRaw:EQ,gzip:pQ,constants:fQ},s1=16209,bQ=16191,mQ=function W(Q,J){let G,V,q,X,Y,F,P,U,k,K,z,C,v,g,T,A,p,D,b,c,I,R,N,H;const Z=Q.state;G=Q.next_in,N=Q.input,V=G+(Q.avail_in-5),q=Q.next_out,H=Q.output,X=q-(J-Q.avail_out),Y=q+(Q.avail_out-257),F=Z.dmax,P=Z.wsize,U=Z.whave,k=Z.wnext,K=Z.window,z=Z.hold,C=Z.bits,v=Z.lencode,g=Z.distcode,T=(1<<Z.lenbits)-1,A=(1<<Z.distbits)-1;W:do{if(C<15)z+=N[G++]<<C,C+=8,z+=N[G++]<<C,C+=8;p=v[z&T];J:for(;;){if(D=p>>>24,z>>>=D,C-=D,D=p>>>16&255,D===0)H[q++]=p&65535;else if(D&16){if(b=p&65535,D&=15,D){if(C<D)z+=N[G++]<<C,C+=8;b+=z&(1<<D)-1,z>>>=D,C-=D}if(C<15)z+=N[G++]<<C,C+=8,z+=N[G++]<<C,C+=8;p=g[z&A];Q:for(;;){if(D=p>>>24,z>>>=D,C-=D,D=p>>>16&255,D&16){if(c=p&65535,D&=15,C<D){if(z+=N[G++]<<C,C+=8,C<D)z+=N[G++]<<C,C+=8}if(c+=z&(1<<D)-1,c>F){Q.msg="invalid distance too far back",Z.mode=s1;break W}if(z>>>=D,C-=D,D=q-X,c>D){if(D=c-D,D>U){if(Z.sane){Q.msg="invalid distance too far back",Z.mode=s1;break W}}if(I=0,R=K,k===0){if(I+=P-D,D<b){b-=D;do H[q++]=K[I++];while(--D);I=q-c,R=H}}else if(k<D){if(I+=P+k-D,D-=k,D<b){b-=D;do H[q++]=K[I++];while(--D);if(I=0,k<b){D=k,b-=D;do H[q++]=K[I++];while(--D);I=q-c,R=H}}}else if(I+=k-D,D<b){b-=D;do H[q++]=K[I++];while(--D);I=q-c,R=H}while(b>2)H[q++]=R[I++],H[q++]=R[I++],H[q++]=R[I++],b-=3;if(b){if(H[q++]=R[I++],b>1)H[q++]=R[I++]}}else{I=q-c;do H[q++]=H[I++],H[q++]=H[I++],H[q++]=H[I++],b-=3;while(b>2);if(b){if(H[q++]=H[I++],b>1)H[q++]=H[I++]}}}else if((D&64)===0){p=g[(p&65535)+(z&(1<<D)-1)];continue Q}else{Q.msg="invalid distance code",Z.mode=s1;break W}break}}else if((D&64)===0){p=v[(p&65535)+(z&(1<<D)-1)];continue J}else if(D&32){Z.mode=bQ;break W}else{Q.msg="invalid literal/length code",Z.mode=s1;break W}break}}while(G<V&&q<Y);b=C>>3,G-=b,C-=b<<3,z&=(1<<C)-1,Q.next_in=G,Q.next_out=q,Q.avail_in=G<V?5+(V-G):5-(G-V),Q.avail_out=q<Y?257+(Y-q):257-(q-Y),Z.hold=z,Z.bits=C;return},J1=15,X5=852,Y5=592,P5=0,f8=1,U5=2,uQ=new Uint16Array([3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,0,0]),dQ=new Uint8Array([16,16,16,16,16,16,16,16,17,17,17,17,18,18,18,18,19,19,19,19,20,20,20,20,21,21,21,21,16,72,78]),cQ=new Uint16Array([1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,0,0]),_Q=new Uint8Array([16,16,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,64,64]),lQ=(W,Q,J,G,V,q,X,Y)=>{const F=Y.bits;let P=0,U=0,k=0,K=0,z=0,C=0,v=0,g=0,T=0,A=0,p,D,b,c,I,R=null,N;const H=new Uint16Array(J1+1),Z=new Uint16Array(J1+1);let $=null,O,x,M;for(P=0;P<=J1;P++)H[P]=0;for(U=0;U<G;U++)H[Q[J+U]]++;z=F;for(K=J1;K>=1;K--)if(H[K]!==0)break;if(z>K)z=K;if(K===0)return V[q++]=1<<24|64<<16|0,V[q++]=1<<24|64<<16|0,Y.bits=1,0;for(k=1;k<K;k++)if(H[k]!==0)break;if(z<k)z=k;g=1;for(P=1;P<=J1;P++)if(g<<=1,g-=H[P],g<0)return-1;if(g>0&&(W===P5||K!==1))return-1;Z[1]=0;for(P=1;P<J1;P++)Z[P+1]=Z[P]+H[P];for(U=0;U<G;U++)if(Q[J+U]!==0)X[Z[Q[J+U]]++]=U;if(W===P5)R=$=X,N=20;else if(W===f8)R=uQ,$=dQ,N=257;else R=cQ,$=_Q,N=0;if(A=0,U=0,P=k,I=q,C=z,v=0,b=-1,T=1<<z,c=T-1,W===f8&&T>X5||W===U5&&T>Y5)return 1;for(;;){if(O=P-v,X[U]+1<N)x=0,M=X[U];else if(X[U]>=N)x=$[X[U]-N],M=R[X[U]-N];else x=96,M=0;p=1<<P-v,D=1<<C,k=D;do D-=p,V[I+(A>>v)+D]=O<<24|x<<16|M|0;while(D!==0);p=1<<P-1;while(A&p)p>>=1;if(p!==0)A&=p-1,A+=p;else A=0;if(U++,--H[P]===0){if(P===K)break;P=Q[J+X[U]]}if(P>z&&(A&c)!==b){if(v===0)v=z;I+=k,C=P-v,g=1<<C;while(C+v<K){if(g-=H[C+v],g<=0)break;C++,g<<=1}if(T+=1<<C,W===f8&&T>X5||W===U5&&T>Y5)return 1;b=A&c,V[b]=z<<24|C<<16|I-q|0}}if(A!==0)V[I+A]=P-v<<24|64<<16|0;return Y.bits=z,0},x1=lQ,iQ=0,q7=1,X7=2,{Z_FINISH:F5,Z_BLOCK:oQ,Z_TREES:e1,Z_OK:h0,Z_STREAM_END:rQ,Z_NEED_DICT:aQ,Z_STREAM_ERROR:P0,Z_DATA_ERROR:Y7,Z_MEM_ERROR:P7,Z_BUF_ERROR:nQ,Z_DEFLATED:K5}=b0,Y8=16180,z5=16181,Z5=16182,k5=16183,H5=16184,$5=16185,C5=16186,M5=16187,B5=16188,j5=16189,V8=16190,C0=16191,h8=16192,L5=16193,b8=16194,R5=16195,O5=16196,I5=16197,x5=16198,t1=16199,W8=16200,w5=16201,D5=16202,N5=16203,v5=16204,g5=16205,m8=16206,S5=16207,T5=16208,o=16209,U7=16210,F7=16211,sQ=852,eQ=592,tQ=15,W9=tQ,A5=(W)=>{return(W>>>24&255)+(W>>>8&65280)+((W&65280)<<8)+((W&255)<<24)},m0=(W)=>{if(!W)return 1;const Q=W.state;if(!Q||Q.strm!==W||Q.mode<Y8||Q.mode>F7)return 1;return 0},K7=(W)=>{if(m0(W))return P0;const Q=W.state;if(W.total_in=W.total_out=Q.total=0,W.msg="",Q.wrap)W.adler=Q.wrap&1;return Q.mode=Y8,Q.last=0,Q.havedict=0,Q.flags=-1,Q.dmax=32768,Q.head=null,Q.hold=0,Q.bits=0,Q.lencode=Q.lendyn=new Int32Array(sQ),Q.distcode=Q.distdyn=new Int32Array(eQ),Q.sane=1,Q.back=-1,h0},z7=(W)=>{if(m0(W))return P0;const Q=W.state;return Q.wsize=0,Q.whave=0,Q.wnext=0,K7(W)},Z7=(W,Q)=>{let J;if(m0(W))return P0;const G=W.state;if(Q<0)J=0,Q=-Q;else if(J=(Q>>4)+5,Q<48)Q&=15;if(Q&&(Q<8||Q>15))return P0;if(G.window!==null&&G.wbits!==Q)G.window=null;return G.wrap=J,G.wbits=Q,z7(W)},k7=(W,Q)=>{if(!W)return P0;const J=new J9;W.state=J,J.strm=W,J.window=null,J.mode=Y8;const G=Z7(W,Q);if(G!==h0)W.state=null;return G},Q9=(W)=>{return k7(W,W9)},y5=!0,u8,d8,G9=(W)=>{if(y5){u8=new Int32Array(512),d8=new Int32Array(32);let Q=0;while(Q<144)W.lens[Q++]=8;while(Q<256)W.lens[Q++]=9;while(Q<280)W.lens[Q++]=7;while(Q<288)W.lens[Q++]=8;x1(q7,W.lens,0,288,u8,0,W.work,{bits:9}),Q=0;while(Q<32)W.lens[Q++]=5;x1(X7,W.lens,0,32,d8,0,W.work,{bits:5}),y5=!1}W.lencode=u8,W.lenbits=9,W.distcode=d8,W.distbits=5},H7=(W,Q,J,G)=>{let V;const q=W.state;if(q.window===null)q.wsize=1<<q.wbits,q.wnext=0,q.whave=0,q.window=new Uint8Array(q.wsize);if(G>=q.wsize)q.window.set(Q.subarray(J-q.wsize,J),0),q.wnext=0,q.whave=q.wsize;else{if(V=q.wsize-q.wnext,V>G)V=G;if(q.window.set(Q.subarray(J-G,J-G+V),q.wnext),G-=V,G)q.window.set(Q.subarray(J-G,J),0),q.wnext=G,q.whave=q.wsize;else{if(q.wnext+=V,q.wnext===q.wsize)q.wnext=0;if(q.whave<q.wsize)q.whave+=V}}return 0},V9=(W,Q)=>{let J,G,V,q,X,Y,F,P,U,k,K,z,C,v,g=0,T,A,p,D,b,c,I,R;const N=new Uint8Array(4);let H,Z;const $=new Uint8Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]);if(m0(W)||!W.output||!W.input&&W.avail_in!==0)return P0;if(J=W.state,J.mode===C0)J.mode=h8;X=W.next_out,V=W.output,F=W.avail_out,q=W.next_in,G=W.input,Y=W.avail_in,P=J.hold,U=J.bits,k=Y,K=F,R=h0;W:for(;;)switch(J.mode){case Y8:if(J.wrap===0){J.mode=h8;break}while(U<16){if(Y===0)break W;Y--,P+=G[q++]<<U,U+=8}if(J.wrap&2&&P===35615){if(J.wbits===0)J.wbits=15;J.check=0,N[0]=P&255,N[1]=P>>>8&255,J.check=n(J.check,N,2,0),P=0,U=0,J.mode=z5;break}if(J.head)J.head.done=!1;if(!(J.wrap&1)||(((P&255)<<8)+(P>>8))%31){W.msg="incorrect header check",J.mode=o;break}if((P&15)!==K5){W.msg="unknown compression method",J.mode=o;break}if(P>>>=4,U-=4,I=(P&15)+8,J.wbits===0)J.wbits=I;if(I>15||I>J.wbits){W.msg="invalid window size",J.mode=o;break}J.dmax=1<<J.wbits,J.flags=0,W.adler=J.check=1,J.mode=P&512?j5:C0,P=0,U=0;break;case z5:while(U<16){if(Y===0)break W;Y--,P+=G[q++]<<U,U+=8}if(J.flags=P,(J.flags&255)!==K5){W.msg="unknown compression method",J.mode=o;break}if(J.flags&57344){W.msg="unknown header flags set",J.mode=o;break}if(J.head)J.head.text=P>>8&1;if(J.flags&512&&J.wrap&4)N[0]=P&255,N[1]=P>>>8&255,J.check=n(J.check,N,2,0);P=0,U=0,J.mode=Z5;case Z5:while(U<32){if(Y===0)break W;Y--,P+=G[q++]<<U,U+=8}if(J.head)J.head.time=P;if(J.flags&512&&J.wrap&4)N[0]=P&255,N[1]=P>>>8&255,N[2]=P>>>16&255,N[3]=P>>>24&255,J.check=n(J.check,N,4,0);P=0,U=0,J.mode=k5;case k5:while(U<16){if(Y===0)break W;Y--,P+=G[q++]<<U,U+=8}if(J.head)J.head.xflags=P&255,J.head.os=P>>8;if(J.flags&512&&J.wrap&4)N[0]=P&255,N[1]=P>>>8&255,J.check=n(J.check,N,2,0);P=0,U=0,J.mode=H5;case H5:if(J.flags&1024){while(U<16){if(Y===0)break W;Y--,P+=G[q++]<<U,U+=8}if(J.length=P,J.head)J.head.extra_len=P;if(J.flags&512&&J.wrap&4)N[0]=P&255,N[1]=P>>>8&255,J.check=n(J.check,N,2,0);P=0,U=0}else if(J.head)J.head.extra=null;J.mode=$5;case $5:if(J.flags&1024){if(z=J.length,z>Y)z=Y;if(z){if(J.head){if(I=J.head.extra_len-J.length,!J.head.extra)J.head.extra=new Uint8Array(J.head.extra_len);J.head.extra.set(G.subarray(q,q+z),I)}if(J.flags&512&&J.wrap&4)J.check=n(J.check,G,z,q);Y-=z,q+=z,J.length-=z}if(J.length)break W}J.length=0,J.mode=C5;case C5:if(J.flags&2048){if(Y===0)break W;z=0;do if(I=G[q+z++],J.head&&I&&J.length<65536)J.head.name+=String.fromCharCode(I);while(I&&z<Y);if(J.flags&512&&J.wrap&4)J.check=n(J.check,G,z,q);if(Y-=z,q+=z,I)break W}else if(J.head)J.head.name=null;J.length=0,J.mode=M5;case M5:if(J.flags&4096){if(Y===0)break W;z=0;do if(I=G[q+z++],J.head&&I&&J.length<65536)J.head.comment+=String.fromCharCode(I);while(I&&z<Y);if(J.flags&512&&J.wrap&4)J.check=n(J.check,G,z,q);if(Y-=z,q+=z,I)break W}else if(J.head)J.head.comment=null;J.mode=B5;case B5:if(J.flags&512){while(U<16){if(Y===0)break W;Y--,P+=G[q++]<<U,U+=8}if(J.wrap&4&&P!==(J.check&65535)){W.msg="header crc mismatch",J.mode=o;break}P=0,U=0}if(J.head)J.head.hcrc=J.flags>>9&1,J.head.done=!0;W.adler=J.check=0,J.mode=C0;break;case j5:while(U<32){if(Y===0)break W;Y--,P+=G[q++]<<U,U+=8}W.adler=J.check=A5(P),P=0,U=0,J.mode=V8;case V8:if(J.havedict===0)return W.next_out=X,W.avail_out=F,W.next_in=q,W.avail_in=Y,J.hold=P,J.bits=U,aQ;W.adler=J.check=1,J.mode=C0;case C0:if(Q===oQ||Q===e1)break W;case h8:if(J.last){P>>>=U&7,U-=U&7,J.mode=m8;break}while(U<3){if(Y===0)break W;Y--,P+=G[q++]<<U,U+=8}switch(J.last=P&1,P>>>=1,U-=1,P&3){case 0:J.mode=L5;break;case 1:if(G9(J),J.mode=t1,Q===e1){P>>>=2,U-=2;break W}break;case 2:J.mode=O5;break;case 3:W.msg="invalid block type",J.mode=o}P>>>=2,U-=2;break;case L5:P>>>=U&7,U-=U&7;while(U<32){if(Y===0)break W;Y--,P+=G[q++]<<U,U+=8}if((P&65535)!==(P>>>16^65535)){W.msg="invalid stored block lengths",J.mode=o;break}if(J.length=P&65535,P=0,U=0,J.mode=b8,Q===e1)break W;case b8:J.mode=R5;case R5:if(z=J.length,z){if(z>Y)z=Y;if(z>F)z=F;if(z===0)break W;V.set(G.subarray(q,q+z),X),Y-=z,q+=z,F-=z,X+=z,J.length-=z;break}J.mode=C0;break;case O5:while(U<14){if(Y===0)break W;Y--,P+=G[q++]<<U,U+=8}if(J.nlen=(P&31)+257,P>>>=5,U-=5,J.ndist=(P&31)+1,P>>>=5,U-=5,J.ncode=(P&15)+4,P>>>=4,U-=4,J.nlen>286||J.ndist>30){W.msg="too many length or distance symbols",J.mode=o;break}J.have=0,J.mode=I5;case I5:while(J.have<J.ncode){while(U<3){if(Y===0)break W;Y--,P+=G[q++]<<U,U+=8}J.lens[$[J.have++]]=P&7,P>>>=3,U-=3}while(J.have<19)J.lens[$[J.have++]]=0;if(J.lencode=J.lendyn,J.lenbits=7,H={bits:J.lenbits},R=x1(iQ,J.lens,0,19,J.lencode,0,J.work,H),J.lenbits=H.bits,R){W.msg="invalid code lengths set",J.mode=o;break}J.have=0,J.mode=x5;case x5:while(J.have<J.nlen+J.ndist){for(;;){if(g=J.lencode[P&(1<<J.lenbits)-1],T=g>>>24,A=g>>>16&255,p=g&65535,T<=U)break;if(Y===0)break W;Y--,P+=G[q++]<<U,U+=8}if(p<16)P>>>=T,U-=T,J.lens[J.have++]=p;else{if(p===16){Z=T+2;while(U<Z){if(Y===0)break W;Y--,P+=G[q++]<<U,U+=8}if(P>>>=T,U-=T,J.have===0){W.msg="invalid bit length repeat",J.mode=o;break}I=J.lens[J.have-1],z=3+(P&3),P>>>=2,U-=2}else if(p===17){Z=T+3;while(U<Z){if(Y===0)break W;Y--,P+=G[q++]<<U,U+=8}P>>>=T,U-=T,I=0,z=3+(P&7),P>>>=3,U-=3}else{Z=T+7;while(U<Z){if(Y===0)break W;Y--,P+=G[q++]<<U,U+=8}P>>>=T,U-=T,I=0,z=11+(P&127),P>>>=7,U-=7}if(J.have+z>J.nlen+J.ndist){W.msg="invalid bit length repeat",J.mode=o;break}while(z--)J.lens[J.have++]=I}}if(J.mode===o)break;if(J.lens[256]===0){W.msg="invalid code -- missing end-of-block",J.mode=o;break}if(J.lenbits=9,H={bits:J.lenbits},R=x1(q7,J.lens,0,J.nlen,J.lencode,0,J.work,H),J.lenbits=H.bits,R){W.msg="invalid literal/lengths set",J.mode=o;break}if(J.distbits=6,J.distcode=J.distdyn,H={bits:J.distbits},R=x1(X7,J.lens,J.nlen,J.ndist,J.distcode,0,J.work,H),J.distbits=H.bits,R){W.msg="invalid distances set",J.mode=o;break}if(J.mode=t1,Q===e1)break W;case t1:J.mode=W8;case W8:if(Y>=6&&F>=258){if(W.next_out=X,W.avail_out=F,W.next_in=q,W.avail_in=Y,J.hold=P,J.bits=U,mQ(W,K),X=W.next_out,V=W.output,F=W.avail_out,q=W.next_in,G=W.input,Y=W.avail_in,P=J.hold,U=J.bits,J.mode===C0)J.back=-1;break}J.back=0;for(;;){if(g=J.lencode[P&(1<<J.lenbits)-1],T=g>>>24,A=g>>>16&255,p=g&65535,T<=U)break;if(Y===0)break W;Y--,P+=G[q++]<<U,U+=8}if(A&&(A&240)===0){D=T,b=A,c=p;for(;;){if(g=J.lencode[c+((P&(1<<D+b)-1)>>D)],T=g>>>24,A=g>>>16&255,p=g&65535,D+T<=U)break;if(Y===0)break W;Y--,P+=G[q++]<<U,U+=8}P>>>=D,U-=D,J.back+=D}if(P>>>=T,U-=T,J.back+=T,J.length=p,A===0){J.mode=g5;break}if(A&32){J.back=-1,J.mode=C0;break}if(A&64){W.msg="invalid literal/length code",J.mode=o;break}J.extra=A&15,J.mode=w5;case w5:if(J.extra){Z=J.extra;while(U<Z){if(Y===0)break W;Y--,P+=G[q++]<<U,U+=8}J.length+=P&(1<<J.extra)-1,P>>>=J.extra,U-=J.extra,J.back+=J.extra}J.was=J.length,J.mode=D5;case D5:for(;;){if(g=J.distcode[P&(1<<J.distbits)-1],T=g>>>24,A=g>>>16&255,p=g&65535,T<=U)break;if(Y===0)break W;Y--,P+=G[q++]<<U,U+=8}if((A&240)===0){D=T,b=A,c=p;for(;;){if(g=J.distcode[c+((P&(1<<D+b)-1)>>D)],T=g>>>24,A=g>>>16&255,p=g&65535,D+T<=U)break;if(Y===0)break W;Y--,P+=G[q++]<<U,U+=8}P>>>=D,U-=D,J.back+=D}if(P>>>=T,U-=T,J.back+=T,A&64){W.msg="invalid distance code",J.mode=o;break}J.offset=p,J.extra=A&15,J.mode=N5;case N5:if(J.extra){Z=J.extra;while(U<Z){if(Y===0)break W;Y--,P+=G[q++]<<U,U+=8}J.offset+=P&(1<<J.extra)-1,P>>>=J.extra,U-=J.extra,J.back+=J.extra}if(J.offset>J.dmax){W.msg="invalid distance too far back",J.mode=o;break}J.mode=v5;case v5:if(F===0)break W;if(z=K-F,J.offset>z){if(z=J.offset-z,z>J.whave){if(J.sane){W.msg="invalid distance too far back",J.mode=o;break}}if(z>J.wnext)z-=J.wnext,C=J.wsize-z;else C=J.wnext-z;if(z>J.length)z=J.length;v=J.window}else v=V,C=X-J.offset,z=J.length;if(z>F)z=F;F-=z,J.length-=z;do V[X++]=v[C++];while(--z);if(J.length===0)J.mode=W8;break;case g5:if(F===0)break W;V[X++]=J.length,F--,J.mode=W8;break;case m8:if(J.wrap){while(U<32){if(Y===0)break W;Y--,P|=G[q++]<<U,U+=8}if(K-=F,W.total_out+=K,J.total+=K,J.wrap&4&&K)W.adler=J.check=J.flags?n(J.check,V,K,X-K):g1(J.check,V,K,X-K);if(K=F,J.wrap&4&&(J.flags?P:A5(P))!==J.check){W.msg="incorrect data check",J.mode=o;break}P=0,U=0}J.mode=S5;case S5:if(J.wrap&&J.flags){while(U<32){if(Y===0)break W;Y--,P+=G[q++]<<U,U+=8}if(J.wrap&4&&P!==(J.total&4294967295)){W.msg="incorrect length check",J.mode=o;break}P=0,U=0}J.mode=T5;case T5:R=rQ;break W;case o:R=Y7;break W;case U7:return P7;case F7:default:return P0}if(W.next_out=X,W.avail_out=F,W.next_in=q,W.avail_in=Y,J.hold=P,J.bits=U,J.wsize||K!==W.avail_out&&J.mode<o&&(J.mode<m8||Q!==F5)){if(H7(W,W.output,W.next_out,K-W.avail_out));}if(k-=W.avail_in,K-=W.avail_out,W.total_in+=k,W.total_out+=K,J.total+=K,J.wrap&4&&K)W.adler=J.check=J.flags?n(J.check,V,K,W.next_out-K):g1(J.check,V,K,W.next_out-K);if(W.data_type=J.bits+(J.last?64:0)+(J.mode===C0?128:0)+(J.mode===t1||J.mode===b8?256:0),(k===0&&K===0||Q===F5)&&R===h0)R=nQ;return R},q9=(W)=>{if(m0(W))return P0;let Q=W.state;if(Q.window)Q.window=null;return W.state=null,h0},X9=(W,Q)=>{if(m0(W))return P0;const J=W.state;if((J.wrap&2)===0)return P0;return J.head=Q,Q.done=!1,h0},Y9=(W,Q)=>{const J=Q.length;let G,V,q;if(m0(W))return P0;if(G=W.state,G.wrap!==0&&G.mode!==V8)return P0;if(G.mode===V8){if(V=1,V=g1(V,Q,J,0),V!==G.check)return Y7}if(q=H7(W,Q,J,J),q)return G.mode=U7,P7;return G.havedict=1,h0},P9=z7,U9=Z7,F9=K7,K9=Q9,z9=k7,Z9=V9,k9=q9,H9=X9,$9=Y9,C9="pako inflate (from Nodeca project)",B0={inflateReset:P9,inflateReset2:U9,inflateResetKeep:F9,inflateInit:K9,inflateInit2:z9,inflate:Z9,inflateEnd:k9,inflateGetHeader:H9,inflateSetDictionary:$9,inflateInfo:C9},B9=M9,$7=Object.prototype.toString,{Z_NO_FLUSH:j9,Z_FINISH:L9,Z_OK:A1,Z_STREAM_END:c8,Z_NEED_DICT:_8,Z_STREAM_ERROR:R9,Z_DATA_ERROR:E5,Z_MEM_ERROR:O9}=b0;f1.prototype.push=function(W,Q){const J=this.strm,G=this.options.chunkSize,V=this.options.dictionary;let q,X,Y;if(this.ended)return!1;if(Q===~~Q)X=Q;else X=Q===!0?L9:j9;if($7.call(W)==="[object ArrayBuffer]")J.input=new Uint8Array(W);else J.input=W;J.next_in=0,J.avail_in=J.input.length;for(;;){if(J.avail_out===0)J.output=new Uint8Array(G),J.next_out=0,J.avail_out=G;if(q=B0.inflate(J,X),q===_8&&V){if(q=B0.inflateSetDictionary(J,V),q===A1)q=B0.inflate(J,X);else if(q===E5)q=_8}while(J.avail_in>0&&q===c8&&J.state.wrap>0&&W[J.next_in]!==0)B0.inflateReset(J),q=B0.inflate(J,X);switch(q){case R9:case E5:case _8:case O9:return this.onEnd(q),this.ended=!0,!1}if(Y=J.avail_out,J.next_out){if(J.avail_out===0||q===c8)if(this.options.to==="string"){let F=T1.utf8border(J.output,J.next_out),P=J.next_out-F,U=T1.buf2string(J.output,F);if(J.next_out=P,J.avail_out=G-P,P)J.output.set(J.output.subarray(F,F+P),0);this.onData(U)}else this.onData(J.output.length===J.next_out?J.output:J.output.subarray(0,J.next_out))}if(q===A1&&Y===0)continue;if(q===c8)return q=B0.inflateEnd(this.strm),this.onEnd(q),this.ended=!0,!0;if(J.avail_in===0)break}return!0};f1.prototype.onData=function(W){this.chunks.push(W)};f1.prototype.onEnd=function(W){if(W===A1)if(this.options.to==="string")this.result=this.chunks.join("");else this.result=X8.flattenChunks(this.chunks);this.chunks=[],this.err=W,this.msg=this.strm.msg};var x9=f1,w9=X6,D9=I9,N9=X6,v9=b0,g9={Inflate:x9,inflate:w9,inflateRaw:D9,ungzip:N9,constants:v9},{Deflate:S9,deflate:T9,deflateRaw:A9,gzip:y9}=hQ,{Inflate:E9,inflate:p9,inflateRaw:f9,ungzip:h9}=g9,b9=S9,m9=T9,u9=A9,d9=y9,c9=E9,_9=p9,l9=f9,i9=h9,o9=b0,u0={Deflate:b9,deflate:m9,deflateRaw:u9,gzip:d9,Inflate:c9,inflate:_9,inflateRaw:l9,ungzip:i9,constants:o9};var I8=function(W){return W instanceof Uint8Array||ArrayBuffer.isView(W)&&W.constructor.name==="Uint8Array"},k6=function(W){if(!Number.isSafeInteger(W)||W<0)throw Error("positive integer expected, got "+W)},n0=function(W,...Q){if(!I8(W))throw Error("Uint8Array expected");if(Q.length>0&&!Q.includes(W.length))throw Error("Uint8Array expected of length "+Q+", got length="+W.length)},u7=function(W){if(typeof W!="function"||typeof W.create!="function")throw Error("Hash should be wrapped by utils.createHasher");k6(W.outputLen),k6(W.blockLen)},H8=function(W,Q=!0){if(W.destroyed)throw Error("Hash instance has been destroyed");if(Q&&W.finished)throw Error("Hash#digest() has already been called")},$8=function(...W){for(let Q=0;Q<W.length;Q++)W[Q].fill(0)},Y6=function(W){return new DataView(W.buffer,W.byteOffset,W.byteLength)},H0=function(W,Q){return W<<32-Q|W>>>Q},z1=function(W){if(n0(W),d7)return W.toHex();let Q="";for(let J=0;J<W.length;J++)Q+=r9[W[J]];return Q},j7=function(W){return W>=C7&&W<=a9?W-C7:W>=M7&&W<=n9?W-(M7-10):W>=B7&&W<=s9?W-(B7-10):void 0},C8=function(W){if(typeof W!="string")throw Error("hex string expected, got "+typeof W);if(d7)return Uint8Array.fromHex(W);const Q=W.length,J=Q/2;if(Q%2)throw Error("hex string expected, got unpadded hex of length "+Q);const G=new Uint8Array(J);for(let V=0,q=0;V<J;V++,q+=2){const X=j7(W.charCodeAt(q)),Y=j7(W.charCodeAt(q+1));if(X===void 0||Y===void 0){const F=W[q]+W[q+1];throw Error('hex string expected, got non-hex character "'+F+'" at index '+q)}G[V]=16*X+Y}return G},c7=function(W){if(typeof W!="string")throw Error("string expected");return new Uint8Array((new TextEncoder()).encode(W))},x6=function(W){return typeof W=="string"&&(W=c7(W)),n0(W),W},$0=function(...W){let Q=0;for(let G=0;G<W.length;G++){const V=W[G];n0(V),Q+=V.length}const J=new Uint8Array(Q);for(let G=0,V=0;G<W.length;G++){const q=W[G];J.set(q,V),V+=q.length}return J},e9=function(W){const Q=(G)=>W().update(x6(G)).digest(),J=W();return Q.outputLen=J.outputLen,Q.blockLen=J.blockLen,Q.create=()=>W(),Q},M8=function(W=32){if(P1&&typeof P1.getRandomValues=="function")return P1.getRandomValues(new Uint8Array(W));if(P1&&typeof P1.randomBytes=="function")return Uint8Array.from(P1.randomBytes(W));throw Error("crypto.getRandomValues must be defined")},t9=function(W,Q,J){return W&Q^W&J^Q&J},B8=function(W,Q=""){if(typeof W!="boolean")throw Error((Q&&`"${Q}"`)+"expected boolean, got type="+typeof W);return W},_0=function(W,Q,J=""){const G=I8(W),V=W?.length,q=Q!==void 0;if(!G||q&&V!==Q)throw Error((J&&`"${J}" `)+"expected Uint8Array"+(q?" of length "+Q:"")+", got "+(G?"length="+V:"type="+typeof W));return W},P8=function(W){const Q=W.toString(16);return 1&Q.length?"0"+Q:Q},o7=function(W){if(typeof W!="string")throw Error("hex string expected, got "+typeof W);return W===""?N6:BigInt("0x"+W)},H1=function(W){return o7(z1(W))},r7=function(W){return n0(W),o7(z1(Uint8Array.from(W).reverse()))},x8=function(W,Q){return C8(W.toString(16).padStart(2*Q,"0"))},a7=function(W,Q){return x8(W,Q).reverse()},a=function(W,Q,J){let G;if(typeof Q=="string")try{G=C8(Q)}catch(q){throw Error(W+" must be hex string or Uint8Array, cause: "+q)}else{if(!I8(Q))throw Error(W+" must be hex string or Uint8Array");G=Uint8Array.from(Q)}const V=G.length;if(typeof J=="number"&&V!==J)throw Error(W+" of length "+J+" expected, got "+V);return G},C6=function(W,Q,J){return P6(W)&&P6(Q)&&P6(J)&&Q<=W&&W<J},n7=function(W){let Q;for(Q=0;W>N6;W>>=$6,Q+=1);return Q},v6=function(W,Q,J={}){if(!W||typeof W!="object")throw Error("expected valid options object");function G(V,q,X){const Y=W[V];if(X&&Y===void 0)return;const F=typeof Y;if(F!==q||Y===null)throw Error(`param "${V}" is invalid: expected ${q}, got ${F}`)}Object.entries(Q).forEach(([V,q])=>G(V,q,!1)),Object.entries(J).forEach(([V,q])=>G(V,q,!0))},L7=function(W){const Q=new WeakMap;return(J,...G)=>{const V=Q.get(J);if(V!==void 0)return V;const q=W(J,...G);return Q.set(J,q),q}},F0=function(W,Q){const J=W%Q;return J>=Q0?J:Q+J},U0=function(W,Q,J){let G=W;for(;Q-- >Q0;)G*=G,G%=J;return G},O7=function(W,Q){if(W===Q0)throw Error("invert: expected non-zero number");if(Q<=Q0)throw Error("invert: expected positive modulus, got "+Q);let J=F0(W,Q),G=Q,V=Q0,q=W0;for(;J!==Q0;){const X=G%J,Y=V-q*(G/J);G=J,J=X,V=q,q=Y}if(G!==W0)throw Error("invert: does not exist");return F0(V,Q)},g6=function(W,Q,J){if(!W.eql(W.sqr(Q),J))throw Error("Cannot find square root")},JW=function(W,Q){const J=(W.ORDER+W0)/e7,G=W.pow(Q,J);return g6(W,G,Q),G},GG=function(W,Q){const J=(W.ORDER-t7)/WW,G=W.mul(Q,o0),V=W.pow(G,J),q=W.mul(Q,V),X=W.mul(W.mul(q,o0),V),Y=W.mul(q,W.sub(X,W.ONE));return g6(W,Y,Q),Y},I7=function(W){if(W<s7)throw Error("sqrt is not defined for small field");let Q=W-W0,J=0;for(;Q%o0===Q0;)Q/=o0,J++;let G=o0;const V=c1(W);for(;x7(V,G)===1;)if(G++>1000)throw Error("Cannot find square root: probably non-prime P");if(J===1)return JW;let q=V.pow(G,Q);const X=(Q+W0)/o0;return function(Y,F){if(Y.is0(F))return F;if(x7(Y,F)!==1)throw Error("Cannot find square root");let P=J,U=Y.mul(Y.ONE,q),k=Y.pow(F,Q),K=Y.pow(F,X);for(;!Y.eql(k,Y.ONE);){if(Y.is0(k))return Y.ZERO;let z=1,C=Y.sqr(k);for(;!Y.eql(C,Y.ONE);)if(z++,C=Y.sqr(C),z===P)throw Error("Cannot find square root");const v=W0<<BigInt(P-z-1),g=Y.pow(U,v);P=z,U=Y.sqr(g),k=Y.mul(k,U),K=Y.mul(K,g)}return K}},VG=function(W){return W%e7===s7?JW:W%WW===t7?GG:W%R7===QG?function(Q){const J=c1(Q),G=I7(Q),V=G(J,J.neg(J.ONE)),q=G(J,V),X=G(J,J.neg(V)),Y=(Q+JG)/R7;return(F,P)=>{let U=F.pow(P,Y),k=F.mul(U,V);const K=F.mul(U,q),z=F.mul(U,X),C=F.eql(F.sqr(k),P),v=F.eql(F.sqr(K),P);U=F.cmov(U,k,C),k=F.cmov(z,K,v);const g=F.eql(F.sqr(k),P),T=F.cmov(U,k,g);return g6(F,T,P),T}}(W):I7(W)},QW=function(W,Q,J=!1){const G=Array(Q.length).fill(J?W.ZERO:void 0),V=Q.reduce((X,Y,F)=>W.is0(Y)?X:(G[F]=X,W.mul(X,Y)),W.ONE),q=W.inv(V);return Q.reduceRight((X,Y,F)=>W.is0(Y)?X:(G[F]=W.mul(X,G[F]),W.mul(X,Y)),q),G},x7=function(W,Q){const J=(W.ORDER-W0)/o0,G=W.pow(Q,J),V=W.eql(G,W.ONE),q=W.eql(G,W.ZERO),X=W.eql(G,W.neg(W.ONE));if(!V&&!q&&!X)throw Error("invalid Legendre symbol result");return V?1:q?0:-1},GW=function(W,Q){Q!==void 0&&k6(Q);const J=Q!==void 0?Q:W.toString(2).length;return{nBitLength:J,nByteLength:Math.ceil(J/8)}},c1=function(W,Q,J=!1,G={}){if(W<=Q0)throw Error("invalid field: expected ORDER > 0, got "+W);let V,q,X,Y=!1;if(typeof Q=="object"&&Q!=null){if(G.sqrt||J)throw Error("cannot specify opts in two arguments");const K=Q;K.BITS&&(V=K.BITS),K.sqrt&&(q=K.sqrt),typeof K.isLE=="boolean"&&(J=K.isLE),typeof K.modFromBytes=="boolean"&&(Y=K.modFromBytes),X=K.allowedLengths}else typeof Q=="number"&&(V=Q),G.sqrt&&(q=G.sqrt);const{nBitLength:F,nByteLength:P}=GW(W,V);if(P>2048)throw Error("invalid field: expected ORDER of <= 2048 bytes");let U;const k=Object.freeze({ORDER:W,isLE:J,BITS:F,BYTES:P,MASK:d1(F),ZERO:Q0,ONE:W0,allowedLengths:X,create(K){return F0(K,W)},isValid(K){if(typeof K!="bigint")throw Error("invalid field element: expected bigint, got "+typeof K);return Q0<=K&&K<W},is0(K){return K===Q0},isValidNot0(K){return!k.is0(K)&&k.isValid(K)},isOdd(K){return(K&W0)===W0},neg(K){return F0(-K,W)},eql(K,z){return K===z},sqr(K){return F0(K*K,W)},add(K,z){return F0(K+z,W)},sub(K,z){return F0(K-z,W)},mul(K,z){return F0(K*z,W)},pow(K,z){return function(C,v,g){if(g<Q0)throw Error("invalid exponent, negatives unsupported");if(g===Q0)return C.ONE;if(g===W0)return v;let T=C.ONE,A=v;for(;g>Q0;)g&W0&&(T=C.mul(T,A)),A=C.sqr(A),g>>=W0;return T}(k,K,z)},div(K,z){return F0(K*O7(z,W),W)},sqrN(K){return K*K},addN(K,z){return K+z},subN(K,z){return K-z},mulN(K,z){return K*z},inv(K){return O7(K,W)},sqrt:q||((K)=>(U||(U=VG(W)),U(k,K))),toBytes(K){return J?a7(K,P):x8(K,P)},fromBytes(K,z=!0){if(X){if(!X.includes(K.length)||K.length>P)throw Error("Field.fromBytes: expected "+X+" bytes, got "+K.length);const v=new Uint8Array(P);v.set(K,J?0:v.length-K.length),K=v}if(K.length!==P)throw Error("Field.fromBytes: expected "+P+" bytes, got "+K.length);let C=J?r7(K):H1(K);if(Y&&(C=F0(C,W)),!z&&!k.isValid(C))throw Error("invalid field element: outside of range 0..ORDER");return C},invertBatch(K){return QW(k,K)},cmov(K,z,C){return C?z:K}});return Object.freeze(k)},VW=function(W){if(typeof W!="bigint")throw Error("field order must be bigint");const Q=W.toString(2).length;return Math.ceil(Q/8)},qW=function(W){const Q=VW(W);return Q+Math.ceil(Q/2)},XW=function(W,Q,J=!1){const G=W.length,V=VW(Q),q=qW(Q);if(G<16||G<q||G>1024)throw Error("expected "+q+"-1024 bytes of input, got "+G);const X=F0(J?r7(W):H1(W),Q-W0)+W0;return J?a7(X,V):x8(X,V)},j8=function(W,Q){const J=Q.negate();return W?J:Q},U6=function(W,Q){const J=QW(W.Fp,Q.map((G)=>G.Z));return Q.map((G,V)=>W.fromAffine(G.toAffine(J[V])))},YW=function(W,Q){if(!Number.isSafeInteger(W)||W<=0||W>Q)throw Error("invalid window size, expected [1.."+Q+"], got W="+W)},F6=function(W,Q){YW(W,Q);const J=2**W;return{windows:Math.ceil(Q/W)+1,windowSize:2**(W-1),mask:d1(W),maxNumber:J,shiftBy:BigInt(W)}},w7=function(W,Q,J){const{windowSize:G,mask:V,maxNumber:q,shiftBy:X}=J;let Y=Number(W&V),F=W>>X;Y>G&&(Y-=q,F+=r0);const P=Q*G;return{nextN:F,offset:P+Math.abs(Y)-1,isZero:Y===0,isNeg:Y<0,isNegF:Q%2!=0,offsetF:P}},z6=function(W){return PW.get(W)||1},D7=function(W){if(W!==Z1)throw Error("invalid wNAF")},XG=function(W,Q,J,G){(function(K,z){if(!Array.isArray(K))throw Error("array expected");K.forEach((C,v)=>{if(!(C instanceof z))throw Error("invalid point at index "+v)})})(J,W),function(K,z){if(!Array.isArray(K))throw Error("array of scalars expected");K.forEach((C,v)=>{if(!z.isValid(C))throw Error("invalid scalar at index "+v)})}(G,Q);const V=J.length,q=G.length;if(V!==q)throw Error("arrays of points and scalars must have equal length");const X=W.ZERO,Y=n7(BigInt(V));let F=1;Y>12?F=Y-3:Y>4?F=Y-2:Y>0&&(F=2);const P=d1(F),U=Array(Number(P)+1).fill(X);let k=X;for(let K=Math.floor((Q.BITS-1)/F)*F;K>=0;K-=F){U.fill(X);for(let C=0;C<q;C++){const v=G[C],g=Number(v>>BigInt(K)&P);U[g]=U[g].add(J[C])}let z=X;for(let C=U.length-1,v=X;C>0;C--)v=v.add(U[C]),z=z.add(v);if(k=k.add(z),K!==0)for(let C=0;C<F;C++)k=k.double()}return k},N7=function(W,Q,J){if(Q){if(Q.ORDER!==W)throw Error("Field.ORDER must match order: Fp == p, Fn == n");return function(G){v6(G,qG.reduce((V,q)=>(V[q]="function",V),{ORDER:"bigint",MASK:"bigint",BYTES:"number",BITS:"number"}))}(Q),Q}return c1(W,{isLE:J})},M6=function(W){if(!["compact","recovered","der"].includes(W))throw Error('Signature format must be "compact", "recovered", or "der"');return W},Z6=function(W,Q){const J={};for(let G of Object.keys(Q))J[G]=W[G]===void 0?Q[G]:W[G];return B8(J.lowS,"lowS"),B8(J.prehash,"prehash"),J.format!==void 0&&M6(J.format),J},l0=function(W,Q){const{BYTES:J}=W;let G;if(typeof Q=="bigint")G=Q;else{let V=a("private key",Q);try{G=W.fromBytes(V)}catch(q){throw Error(`invalid private key: expected ui8a of size ${J}, got ${typeof Q}`)}}if(!W.isValidNot0(G))throw Error("invalid private key: out of range [1..N-1]");return G},PG=function(W,Q={}){const J=function(H,Z,$={},O){if(O===void 0&&(O=H==="edwards"),!Z||typeof Z!="object")throw Error(`expected valid ${H} CURVE object`);for(let L of["p","n","h"]){const j=Z[L];if(!(typeof j=="bigint"&&j>Z1))throw Error(`CURVE.${L} must be positive bigint`)}const x=N7(Z.p,$.Fp,O),M=N7(Z.n,$.Fn,O),B=["Gx","Gy","a","b"];for(let L of B)if(!x.isValid(Z[L]))throw Error(`CURVE.${L} must be valid field element of CURVE.Fp`);return{CURVE:Z=Object.freeze(Object.assign({},Z)),Fp:x,Fn:M}}("weierstrass",W,Q),{Fp:G,Fn:V}=J;let q=J.CURVE;const{h:X,n:Y}=q;v6(Q,{},{allowInfinityPoint:"boolean",clearCofactor:"function",isTorsionFree:"function",fromBytes:"function",toBytes:"function",endo:"object",wrapPrivateKey:"boolean"});const{endo:F}=Q;if(F&&(!G.is0(q.a)||typeof F.beta!="bigint"||!Array.isArray(F.basises)))throw Error('invalid endo: expected "beta": bigint and "basises": array');const P=zW(G,V);function U(){if(!G.isOdd)throw Error("compression is not supported: Field does not have .isOdd()")}const k=Q.toBytes||function(H,Z,$){const{x:O,y:x}=Z.toAffine(),M=G.toBytes(O);if(B8($,"isCompressed"),$)return U(),$0(KW(!G.isOdd(x)),M);return $0(Uint8Array.of(4),M,G.toBytes(x))},K=Q.fromBytes||function(H){_0(H,void 0,"Point");const{publicKey:Z,publicKeyUncompressed:$}=P,O=H.length,x=H[0],M=H.subarray(1);if(O!==Z||x!==2&&x!==3){if(O===$&&x===4){const B=G.BYTES,L=G.fromBytes(M.subarray(0,B)),j=G.fromBytes(M.subarray(B,2*B));if(!C(L,j))throw Error("bad point: is not on curve");return{x:L,y:j}}throw Error(`bad point: got length ${O}, expected compressed=${Z} or uncompressed=${$}`)}{const B=G.fromBytes(M);if(!G.isValid(B))throw Error("bad point: is not on curve, wrong x");const L=z(B);let j;try{j=G.sqrt(L)}catch(w){const E=w instanceof Error?": "+w.message:"";throw Error("bad point: is not on curve, sqrt error"+E)}return U(),!(1&~x)!==G.isOdd(j)&&(j=G.neg(j)),{x:B,y:j}}};function z(H){const Z=G.sqr(H),$=G.mul(Z,H);return G.add(G.add($,G.mul(H,q.a)),q.b)}function C(H,Z){const $=G.sqr(Z),O=z(H);return G.eql($,O)}if(!C(q.Gx,q.Gy))throw Error("bad curve params: generator point");const v=G.mul(G.pow(q.a,U8),YG),g=G.mul(G.sqr(q.b),BigInt(27));if(G.is0(G.add(v,g)))throw Error("bad curve params: a or b");function T(H,Z,$=!1){if(!G.isValid(Z)||$&&G.is0(Z))throw Error("bad point coordinate "+H);return Z}function A(H){if(!(H instanceof I))throw Error("ProjectivePoint expected")}function p(H){if(!F||!F.basises)throw Error("no endo");return function(Z,$,O){const[[x,M],[B,L]]=$,j=v7(L*Z,O),w=v7(-M*Z,O);let E=Z-j*x-w*B,S=-j*M-w*L;const y=E<R0,m=S<R0;y&&(E=-E),m&&(S=-S);const u=d1(Math.ceil(n7(O)/2))+K1;if(E<R0||E>=u||S<R0||S>=u)throw Error("splitScalar (endomorphism): failed, k="+Z);return{k1neg:y,k1:E,k2neg:m,k2:S}}(H,F.basises,V.ORDER)}const D=L7((H,Z)=>{const{X:$,Y:O,Z:x}=H;if(G.eql(x,G.ONE))return{x:$,y:O};const M=H.is0();Z==null&&(Z=M?G.ONE:G.inv(x));const B=G.mul($,Z),L=G.mul(O,Z),j=G.mul(x,Z);if(M)return{x:G.ZERO,y:G.ZERO};if(!G.eql(j,G.ONE))throw Error("invZ was invalid");return{x:B,y:L}}),b=L7((H)=>{if(H.is0()){if(Q.allowInfinityPoint&&!G.is0(H.Y))return;throw Error("bad point: ZERO")}const{x:Z,y:$}=H.toAffine();if(!G.isValid(Z)||!G.isValid($))throw Error("bad point: x or y not field elements");if(!C(Z,$))throw Error("bad point: equation left != right");if(!H.isTorsionFree())throw Error("bad point: not in prime-order subgroup");return!0});function c(H,Z,$,O,x){return $=new I(G.mul($.X,H),$.Y,$.Z),Z=j8(O,Z),$=j8(x,$),Z.add($)}class I{constructor(H,Z,$){this.X=T("x",H),this.Y=T("y",Z,!0),this.Z=T("z",$),Object.freeze(this)}static CURVE(){return q}static fromAffine(H){const{x:Z,y:$}=H||{};if(!H||!G.isValid(Z)||!G.isValid($))throw Error("invalid affine point");if(H instanceof I)throw Error("projective point not allowed");return G.is0(Z)&&G.is0($)?I.ZERO:new I(Z,$,G.ONE)}static fromBytes(H){const Z=I.fromAffine(K(_0(H,void 0,"point")));return Z.assertValidity(),Z}static fromHex(H){return I.fromBytes(a("pointHex",H))}get x(){return this.toAffine().x}get y(){return this.toAffine().y}precompute(H=8,Z=!0){return N.createCache(this,H),Z||this.multiply(U8),this}assertValidity(){b(this)}hasEvenY(){const{y:H}=this.toAffine();if(!G.isOdd)throw Error("Field doesn't support isOdd");return!G.isOdd(H)}equals(H){A(H);const{X:Z,Y:$,Z:O}=this,{X:x,Y:M,Z:B}=H,L=G.eql(G.mul(Z,B),G.mul(x,O)),j=G.eql(G.mul($,B),G.mul(M,O));return L&&j}negate(){return new I(this.X,G.neg(this.Y),this.Z)}double(){const{a:H,b:Z}=q,$=G.mul(Z,U8),{X:O,Y:x,Z:M}=this;let{ZERO:B,ZERO:L,ZERO:j}=G,w=G.mul(O,O),E=G.mul(x,x),S=G.mul(M,M),y=G.mul(O,x);return y=G.add(y,y),j=G.mul(O,M),j=G.add(j,j),B=G.mul(H,j),L=G.mul($,S),L=G.add(B,L),B=G.sub(E,L),L=G.add(E,L),L=G.mul(B,L),B=G.mul(y,B),j=G.mul($,j),S=G.mul(H,S),y=G.sub(w,S),y=G.mul(H,y),y=G.add(y,j),j=G.add(w,w),w=G.add(j,w),w=G.add(w,S),w=G.mul(w,y),L=G.add(L,w),S=G.mul(x,M),S=G.add(S,S),w=G.mul(S,y),B=G.sub(B,w),j=G.mul(S,E),j=G.add(j,j),j=G.add(j,j),new I(B,L,j)}add(H){A(H);const{X:Z,Y:$,Z:O}=this,{X:x,Y:M,Z:B}=H;let{ZERO:L,ZERO:j,ZERO:w}=G;const E=q.a,S=G.mul(q.b,U8);let y=G.mul(Z,x),m=G.mul($,M),u=G.mul(O,B),f=G.add(Z,$),h=G.add(x,M);f=G.mul(f,h),h=G.add(y,m),f=G.sub(f,h),h=G.add(Z,O);let _=G.add(x,B);return h=G.mul(h,_),_=G.add(y,u),h=G.sub(h,_),_=G.add($,O),L=G.add(M,B),_=G.mul(_,L),L=G.add(m,u),_=G.sub(_,L),w=G.mul(E,h),L=G.mul(S,u),w=G.add(L,w),L=G.sub(m,w),w=G.add(m,w),j=G.mul(L,w),m=G.add(y,y),m=G.add(m,y),u=G.mul(E,u),h=G.mul(S,h),m=G.add(m,u),u=G.sub(y,u),u=G.mul(E,u),h=G.add(h,u),y=G.mul(m,h),j=G.add(j,y),y=G.mul(_,h),L=G.mul(f,L),L=G.sub(L,y),y=G.mul(f,m),w=G.mul(_,w),w=G.add(w,y),new I(L,j,w)}subtract(H){return this.add(H.negate())}is0(){return this.equals(I.ZERO)}multiply(H){const{endo:Z}=Q;if(!V.isValidNot0(H))throw Error("invalid scalar: out of range");let $,O;const x=(M)=>N.cached(this,M,(B)=>U6(I,B));if(Z){const{k1neg:M,k1:B,k2neg:L,k2:j}=p(H),{p:w,f:E}=x(B),{p:S,f:y}=x(j);O=E.add(y),$=c(Z.beta,w,S,M,L)}else{const{p:M,f:B}=x(H);$=M,O=B}return U6(I,[$,O])[0]}multiplyUnsafe(H){const{endo:Z}=Q,$=this;if(!V.isValid(H))throw Error("invalid scalar: out of range");if(H===R0||$.is0())return I.ZERO;if(H===K1)return $;if(N.hasCache(this))return this.multiply(H);if(Z){const{k1neg:O,k1:x,k2neg:M,k2:B}=p(H),{p1:L,p2:j}=function(w,E,S,y){let m=E,u=w.ZERO,f=w.ZERO;for(;S>Z1||y>Z1;)S&r0&&(u=u.add(m)),y&r0&&(f=f.add(m)),m=m.double(),S>>=r0,y>>=r0;return{p1:u,p2:f}}(I,$,x,B);return c(Z.beta,L,j,O,M)}return N.unsafe($,H)}multiplyAndAddUnsafe(H,Z,$){const O=this.multiplyUnsafe(Z).add(H.multiplyUnsafe($));return O.is0()?void 0:O}toAffine(H){return D(this,H)}isTorsionFree(){const{isTorsionFree:H}=Q;return X===K1||(H?H(I,this):N.unsafe(this,Y).is0())}clearCofactor(){const{clearCofactor:H}=Q;return X===K1?this:H?H(I,this):this.multiplyUnsafe(X)}isSmallOrder(){return this.multiplyUnsafe(X).is0()}toBytes(H=!0){return B8(H,"isCompressed"),this.assertValidity(),k(I,this,H)}toHex(H=!0){return z1(this.toBytes(H))}toString(){return`<Point ${this.is0()?"ZERO":this.toHex()}>`}get px(){return this.X}get py(){return this.X}get pz(){return this.Z}toRawBytes(H=!0){return this.toBytes(H)}_setWindowSize(H){this.precompute(H)}static normalizeZ(H){return U6(I,H)}static msm(H,Z){return XG(I,V,H,Z)}static fromPrivateKey(H){return I.BASE.multiply(l0(V,H))}}I.BASE=new I(q.Gx,q.Gy,G.ONE),I.ZERO=new I(G.ZERO,G.ONE,G.ZERO),I.Fp=G,I.Fn=V;const R=V.BITS,N=new UW(I,Q.endo?Math.ceil(R/2):R);return I.BASE.precompute(8),I},KW=function(W){return Uint8Array.of(W?2:3)},zW=function(W,Q){return{secretKey:Q.BYTES,publicKey:1+W.BYTES,publicKeyUncompressed:1+2*W.BYTES,publicKeyHasPrefix:!0,signature:2*Q.BYTES}},UG=function(W,Q,J={}){u7(Q),v6(J,{},{hmac:"function",lowS:"boolean",randomBytes:"function",bits2int:"function",bits2int_modN:"function"});const G=J.randomBytes||M8,V=J.hmac||((R,...N)=>i7(Q,R,$0(...N))),{Fp:q,Fn:X}=W,{ORDER:Y,BITS:F}=X,{keygen:P,getPublicKey:U,getSharedSecret:k,utils:K,lengths:z}=function(R,N={}){const{Fn:H}=R,Z=N.randomBytes||M8,$=Object.assign(zW(R.Fp,H),{seed:qW(H.ORDER)});function O(j){try{return!!l0(H,j)}catch(w){return!1}}function x(j=Z($.seed)){return XW(_0(j,$.seed,"seed"),H.ORDER)}function M(j,w=!0){return R.BASE.multiply(l0(H,j)).toBytes(w)}function B(j){if(typeof j=="bigint")return!1;if(j instanceof R)return!0;const{secretKey:w,publicKey:E,publicKeyUncompressed:S}=$;if(H.allowedLengths||w===E)return;const y=a("key",j).length;return y===E||y===S}return Object.freeze({getPublicKey:M,getSharedSecret(j,w,E=!0){if(B(j)===!0)throw Error("first arg must be private key");if(B(w)===!1)throw Error("second arg must be public key");const S=l0(H,j);return R.fromHex(w).multiply(S).toBytes(E)},keygen(j){const w=x(j);return{secretKey:w,publicKey:M(w)}},Point:R,utils:{isValidSecretKey:O,isValidPublicKey(j,w){const{publicKey:E,publicKeyUncompressed:S}=$;try{const y=j.length;return!(w===!0&&y!==E||w===!1&&y!==S||!R.fromBytes(j))}catch(y){return!1}},randomSecretKey:x,isValidPrivateKey:O,randomPrivateKey:x,normPrivateKeyToScalar:(j)=>l0(H,j),precompute(j=8,w=R.BASE){return w.precompute(j,!1)}},lengths:$})}(W,J),C={prehash:!1,lowS:typeof J.lowS=="boolean"&&J.lowS,format:void 0,extraEntropy:!1},v="compact";function g(R){return R>Y>>K1}function T(R,N){if(!X.isValidNot0(N))throw Error(`invalid signature ${R}: out of range 1..Point.Fn.ORDER`);return N}class A{constructor(R,N,H){this.r=T("r",R),this.s=T("s",N),H!=null&&(this.recovery=H),Object.freeze(this)}static fromBytes(R,N=v){let H;if(function(x,M){M6(M);const B=z.signature;_0(x,M==="compact"?B:M==="recovered"?B+1:void 0,M+" signature")}(R,N),N==="der"){const{r:x,s:M}=j0.toSig(_0(R));return new A(x,M)}N==="recovered"&&(H=R[0],N="compact",R=R.subarray(1));const Z=X.BYTES,$=R.subarray(0,Z),O=R.subarray(Z,2*Z);return new A(X.fromBytes($),X.fromBytes(O),H)}static fromHex(R,N){return this.fromBytes(C8(R),N)}addRecoveryBit(R){return new A(this.r,this.s,R)}recoverPublicKey(R){const N=q.ORDER,{r:H,s:Z,recovery:$}=this;if($==null||![0,1,2,3].includes($))throw Error("recovery id invalid");if(Y*FW<N&&$>1)throw Error("recovery id is ambiguous for h>1 curve");const O=$===2||$===3?H+Y:H;if(!q.isValid(O))throw Error("recovery id 2 or 3 invalid");const x=q.toBytes(O),M=W.fromBytes($0(KW(!(1&$)),x)),B=X.inv(O),L=D(a("msgHash",R)),j=X.create(-L*B),w=X.create(Z*B),E=W.BASE.multiplyUnsafe(j).add(M.multiplyUnsafe(w));if(E.is0())throw Error("point at infinify");return E.assertValidity(),E}hasHighS(){return g(this.s)}toBytes(R=v){if(M6(R),R==="der")return C8(j0.hexFromSig(this));const N=X.toBytes(this.r),H=X.toBytes(this.s);if(R==="recovered"){if(this.recovery==null)throw Error("recovery bit must be present");return $0(Uint8Array.of(this.recovery),N,H)}return $0(N,H)}toHex(R){return z1(this.toBytes(R))}assertValidity(){}static fromCompact(R){return A.fromBytes(a("sig",R),"compact")}static fromDER(R){return A.fromBytes(a("sig",R),"der")}normalizeS(){return this.hasHighS()?new A(this.r,X.neg(this.s),this.recovery):this}toDERRawBytes(){return this.toBytes("der")}toDERHex(){return z1(this.toBytes("der"))}toCompactRawBytes(){return this.toBytes("compact")}toCompactHex(){return z1(this.toBytes("compact"))}}const p=J.bits2int||function(R){if(R.length>8192)throw Error("input is too large");const N=H1(R),H=8*R.length-F;return H>0?N>>BigInt(H):N},D=J.bits2int_modN||function(R){return X.create(p(R))},b=d1(F);function c(R){return function(N,H,Z,$){if(!C6(H,Z,$))throw Error("expected valid "+N+": "+Z+" <= n < "+$+", got "+H)}("num < 2^"+F,R,R0,b),X.toBytes(R)}function I(R,N){return _0(R,void 0,"message"),N?_0(Q(R),void 0,"prehashed message"):R}return Object.freeze({keygen:P,getPublicKey:U,getSharedSecret:k,utils:K,lengths:z,Point:W,sign(R,N,H={}){R=a("message",R);const{seed:Z,k2sig:$}=function(O,x,M){if(["recovered","canonical"].some((u)=>(u in M)))throw Error("sign() legacy options not supported");const{lowS:B,prehash:L,extraEntropy:j}=Z6(M,C);O=I(O,L);const w=D(O),E=l0(X,x),S=[c(E),c(w)];if(j!=null&&j!==!1){const u=j===!0?G(z.secretKey):j;S.push(a("extraEntropy",u))}const y=$0(...S),m=w;return{seed:y,k2sig(u){const f=p(u);if(!X.isValidNot0(f))return;const h=X.inv(f),_=W.BASE.multiply(f).toAffine(),i=X.create(_.x);if(i===R0)return;const r=X.create(h*X.create(m+i*E));if(r===R0)return;let G0=(_.x===i?0:2)|Number(_.y&K1),X0=r;return B&&g(r)&&(X0=X.neg(r),G0^=1),new A(i,X0,G0)}}}(R,N,H);return function(O,x,M){if(typeof O!="number"||O<2)throw Error("hashLen must be a number");if(typeof x!="number"||x<2)throw Error("qByteLen must be a number");if(typeof M!="function")throw Error("hmacFn must be a function");const B=(f)=>new Uint8Array(f),L=(f)=>Uint8Array.of(f);let j=B(O),w=B(O),E=0;const S=()=>{j.fill(1),w.fill(0),E=0},y=(...f)=>M(w,j,...f),m=(f=B(0))=>{w=y(L(0),f),j=y(),f.length!==0&&(w=y(L(1),f),j=y())},u=()=>{if(E++>=1000)throw Error("drbg: tried 1000 values");let f=0;const h=[];for(;f<x;){j=y();const _=j.slice();h.push(_),f+=j.length}return $0(...h)};return(f,h)=>{let _;for(S(),m(f);!(_=h(u()));)m();return S(),_}}(Q.outputLen,X.BYTES,V)(Z,$)},verify(R,N,H,Z={}){const{lowS:$,prehash:O,format:x}=Z6(Z,C);if(H=a("publicKey",H),N=I(a("message",N),O),("strict"in Z))throw Error("options.strict was renamed to lowS");const M=x===void 0?function(B){let L;const j=typeof B=="string"||I8(B),w=!j&&B!==null&&typeof B=="object"&&typeof B.r=="bigint"&&typeof B.s=="bigint";if(!j&&!w)throw Error("invalid signature, expected Uint8Array, hex string or Signature instance");if(w)L=new A(B.r,B.s);else if(j){try{L=A.fromBytes(a("sig",B),"der")}catch(E){if(!(E instanceof j0.Err))throw E}if(!L)try{L=A.fromBytes(a("sig",B),"compact")}catch(E){return!1}}return L||!1}(R):A.fromBytes(a("sig",R),x);if(M===!1)return!1;try{const B=W.fromBytes(H);if($&&M.hasHighS())return!1;const{r:L,s:j}=M,w=D(N),E=X.inv(j),S=X.create(w*E),y=X.create(L*E),m=W.BASE.multiplyUnsafe(S).add(B.multiplyUnsafe(y));if(m.is0())return!1;return X.create(m.x)===L}catch(B){return!1}},recoverPublicKey(R,N,H={}){const{prehash:Z}=Z6(H,C);return N=I(N,Z),A.fromBytes(R,"recovered").recoverPublicKey(N).toBytes()},Signature:A,hash:Q})},FG=function(W){const{CURVE:Q,curveOpts:J}=function(V){const q={a:V.a,b:V.b,p:V.Fp.ORDER,n:V.n,h:V.h,Gx:V.Gx,Gy:V.Gy},X=V.Fp;let Y=V.allowedPrivateKeyLengths?Array.from(new Set(V.allowedPrivateKeyLengths.map((F)=>Math.ceil(F/2)))):void 0;return{CURVE:q,curveOpts:{Fp:X,Fn:c1(q.n,{BITS:V.nBitLength,allowedLengths:Y,modFromBytes:V.wrapPrivateKey}),allowInfinityPoint:V.allowInfinityPoint,endo:V.endo,isTorsionFree:V.isTorsionFree,clearCofactor:V.clearCofactor,fromBytes:V.fromBytes,toBytes:V.toBytes}}}(W),G={hmac:W.hmac,randomBytes:W.randomBytes,lowS:W.lowS,bits2int:W.bits2int,bits2int_modN:W.bits2int_modN};return{CURVE:Q,curveOpts:J,hash:W.hash,ecdsaOpts:G}},KG=function(W){const{CURVE:Q,curveOpts:J,hash:G,ecdsaOpts:V}=FG(W);return function(q,X){const Y=X.Point;return Object.assign({},X,{ProjectivePoint:Y,CURVE:Object.assign({},q,GW(Y.Fn.ORDER,Y.Fn.BITS))})}(W,UG(PG(Q,J),G,V))},R8=function(W,...Q){let J=S7[W];if(J===void 0){const G=H6(c7(W));J=$0(G,G),S7[W]=J}return H6($0(J,...Q))},j6=function(W){const{Fn:Q,BASE:J}=$1,G=l0(Q,W),V=J.multiply(G);return{scalar:T6(V.y)?G:Q.neg(G),bytes:S6(V)}},kW=function(W){const Q=L8;if(!Q.isValidNot0(W))throw Error("invalid x: Fail if x \u2265 p");const J=Q.create(W*W),G=Q.create(J*W+BigInt(7));let V=Q.sqrt(G);T6(V)||(V=Q.neg(V));const q=$1.fromAffine({x:W,y:V});return q.assertValidity(),q},HW=function(...W){return $1.Fn.create(b1(R8("BIP0340/challenge",...W)))},T7=function(W){return j6(W).bytes},kG=function(W,Q,J=M8(32)){const{Fn:G}=$1,V=a("message",W),{bytes:q,scalar:X}=j6(Q),Y=a("auxRand",J,32),F=G.toBytes(X^b1(R8("BIP0340/aux",Y))),P=R8("BIP0340/nonce",F,q,V),{bytes:U,scalar:k}=j6(P),K=HW(U,q,V),z=new Uint8Array(64);if(z.set(U,0),z.set(G.toBytes(G.create(k+K*X)),32),!$W(z,V,q))throw Error("sign: Invalid signature produced");return z},$W=function(W,Q,J){const{Fn:G,BASE:V}=$1,q=a("signature",W,64),X=a("message",Q),Y=a("publicKey",J,32);try{const F=kW(b1(Y)),P=b1(q.subarray(0,32));if(!C6(P,g7,k1.p))return!1;const U=b1(q.subarray(32,64));if(!C6(U,g7,k1.n))return!1;const k=HW(G.toBytes(P),S6(F),X),K=V.multiplyUnsafe(U).add(F.multiplyUnsafe(G.neg(k))),{x:z,y:C}=K.toAffine();return!(K.is0()||!T6(C)||z!==P)}catch(F){return!1}},P1=typeof globalThis=="object"&&("crypto"in globalThis)?globalThis.crypto:void 0,d7=(()=>typeof Uint8Array.from([]).toHex=="function"&&typeof Uint8Array.fromHex=="function")(),r9=Array.from({length:256},(W,Q)=>Q.toString(16).padStart(2,"0")),C7=48,a9=57,M7=65,n9=70,B7=97,s9=102;class w6{}class _7 extends w6{constructor(W,Q,J,G){super(),this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.blockLen=W,this.outputLen=Q,this.padOffset=J,this.isLE=G,this.buffer=new Uint8Array(W),this.view=Y6(this.buffer)}update(W){H8(this),n0(W=x6(W));const{view:Q,buffer:J,blockLen:G}=this,V=W.length;for(let q=0;q<V;){const X=Math.min(G-this.pos,V-q);if(X!==G)J.set(W.subarray(q,q+X),this.pos),this.pos+=X,q+=X,this.pos===G&&(this.process(Q,0),this.pos=0);else{const Y=Y6(W);for(;G<=V-q;q+=G)this.process(Y,q)}}return this.length+=W.length,this.roundClean(),this}digestInto(W){H8(this),function(U,k){n0(U);const K=k.outputLen;if(U.length<K)throw Error("digestInto() expects output buffer of length at least "+K)}(W,this),this.finished=!0;const{buffer:Q,view:J,blockLen:G,isLE:V}=this;let{pos:q}=this;Q[q++]=128,$8(this.buffer.subarray(q)),this.padOffset>G-q&&(this.process(J,0),q=0);for(let U=q;U<G;U++)Q[U]=0;(function(U,k,K,z){if(typeof U.setBigUint64=="function")return U.setBigUint64(k,K,z);const C=BigInt(32),v=BigInt(4294967295),g=Number(K>>C&v),T=Number(K&v),A=z?4:0,p=z?0:4;U.setUint32(k+A,g,z),U.setUint32(k+p,T,z)})(J,G-8,BigInt(8*this.length),V),this.process(J,0);const X=Y6(W),Y=this.outputLen;if(Y%4)throw Error("_sha2: outputLen should be aligned to 32bit");const F=Y/4,P=this.get();if(F>P.length)throw Error("_sha2: outputLen bigger than state");for(let U=0;U<F;U++)X.setUint32(4*U,P[U],V)}digest(){const{buffer:W,outputLen:Q}=this;this.digestInto(W);const J=W.slice(0,Q);return this.destroy(),J}_cloneInto(W){W||(W=new this.constructor),W.set(...this.get());const{blockLen:Q,buffer:J,length:G,finished:V,destroyed:q,pos:X}=this;return W.destroyed=q,W.finished=V,W.length=G,W.pos=X,G%Q&&W.buffer.set(J),W}clone(){return this._cloneInto()}}var g0=Uint32Array.from([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),WG=Uint32Array.from([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),S0=new Uint32Array(64);class l7 extends _7{constructor(W=32){super(64,W,8,!1),this.A=0|g0[0],this.B=0|g0[1],this.C=0|g0[2],this.D=0|g0[3],this.E=0|g0[4],this.F=0|g0[5],this.G=0|g0[6],this.H=0|g0[7]}get(){const{A:W,B:Q,C:J,D:G,E:V,F:q,G:X,H:Y}=this;return[W,Q,J,G,V,q,X,Y]}set(W,Q,J,G,V,q,X,Y){this.A=0|W,this.B=0|Q,this.C=0|J,this.D=0|G,this.E=0|V,this.F=0|q,this.G=0|X,this.H=0|Y}process(W,Q){for(let k=0;k<16;k++,Q+=4)S0[k]=W.getUint32(Q,!1);for(let k=16;k<64;k++){const K=S0[k-15],z=S0[k-2],C=H0(K,7)^H0(K,18)^K>>>3,v=H0(z,17)^H0(z,19)^z>>>10;S0[k]=v+S0[k-7]+C+S0[k-16]|0}let{A:J,B:G,C:V,D:q,E:X,F:Y,G:F,H:P}=this;for(let k=0;k<64;k++){const K=P+(H0(X,6)^H0(X,11)^H0(X,25))+((U=X)&Y^~U&F)+WG[k]+S0[k]|0,z=(H0(J,2)^H0(J,13)^H0(J,22))+t9(J,G,V)|0;P=F,F=Y,Y=X,X=q+K|0,q=V,V=G,G=J,J=K+z|0}var U;J=J+this.A|0,G=G+this.B|0,V=V+this.C|0,q=q+this.D|0,X=X+this.E|0,Y=Y+this.F|0,F=F+this.G|0,P=P+this.H|0,this.set(J,G,V,q,X,Y,F,P)}roundClean(){$8(S0)}destroy(){this.set(0,0,0,0,0,0,0,0),$8(this.buffer)}}var H6=e9(()=>new l7);class D6 extends w6{constructor(W,Q){super(),this.finished=!1,this.destroyed=!1,u7(W);const J=x6(Q);if(this.iHash=W.create(),typeof this.iHash.update!="function")throw Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const G=this.blockLen,V=new Uint8Array(G);V.set(J.length>G?W.create().update(J).digest():J);for(let q=0;q<V.length;q++)V[q]^=54;this.iHash.update(V),this.oHash=W.create();for(let q=0;q<V.length;q++)V[q]^=106;this.oHash.update(V),$8(V)}update(W){return H8(this),this.iHash.update(W),this}digestInto(W){H8(this),n0(W,this.outputLen),this.finished=!0,this.iHash.digestInto(W),this.oHash.update(W),this.oHash.digestInto(W),this.destroy()}digest(){const W=new Uint8Array(this.oHash.outputLen);return this.digestInto(W),W}_cloneInto(W){W||(W=Object.create(Object.getPrototypeOf(this),{}));const{oHash:Q,iHash:J,finished:G,destroyed:V,blockLen:q,outputLen:X}=this;return W.finished=G,W.destroyed=V,W.blockLen=q,W.outputLen=X,W.oHash=Q._cloneInto(W.oHash),W.iHash=J._cloneInto(W.iHash),W}clone(){return this._cloneInto()}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}var i7=(W,Q,J)=>new D6(W,Q).update(J).digest();i7.create=(W,Q)=>new D6(W,Q);var N6=BigInt(0),$6=BigInt(1),P6=(W)=>typeof W=="bigint"&&N6<=W,d1=(W)=>($6<<BigInt(W))-$6,Q0=BigInt(0),W0=BigInt(1),o0=BigInt(2),s7=BigInt(3),e7=BigInt(4),t7=BigInt(5),JG=BigInt(7),WW=BigInt(8),QG=BigInt(9),R7=BigInt(16),qG=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"],Z1=BigInt(0),r0=BigInt(1),K6=new WeakMap,PW=new WeakMap;class UW{constructor(W,Q){this.BASE=W.BASE,this.ZERO=W.ZERO,this.Fn=W.Fn,this.bits=Q}_unsafeLadder(W,Q,J=this.ZERO){let G=W;for(;Q>Z1;)Q&r0&&(J=J.add(G)),G=G.double(),Q>>=r0;return J}precomputeWindow(W,Q){const{windows:J,windowSize:G}=F6(Q,this.bits),V=[];let q=W,X=q;for(let Y=0;Y<J;Y++){X=q,V.push(X);for(let F=1;F<G;F++)X=X.add(q),V.push(X);q=X.double()}return V}wNAF(W,Q,J){if(!this.Fn.isValid(J))throw Error("invalid scalar");let G=this.ZERO,V=this.BASE;const q=F6(W,this.bits);for(let X=0;X<q.windows;X++){const{nextN:Y,offset:F,isZero:P,isNeg:U,isNegF:k,offsetF:K}=w7(J,X,q);J=Y,P?V=V.add(j8(k,Q[K])):G=G.add(j8(U,Q[F]))}return D7(J),{p:G,f:V}}wNAFUnsafe(W,Q,J,G=this.ZERO){const V=F6(W,this.bits);for(let q=0;q<V.windows&&J!==Z1;q++){const{nextN:X,offset:Y,isZero:F,isNeg:P}=w7(J,q,V);if(J=X,!F){const U=Q[Y];G=G.add(P?U.negate():U)}}return D7(J),G}getPrecomputes(W,Q,J){let G=K6.get(Q);return G||(G=this.precomputeWindow(Q,W),W!==1&&(typeof J=="function"&&(G=J(G)),K6.set(Q,G))),G}cached(W,Q,J){const G=z6(W);return this.wNAF(G,this.getPrecomputes(G,W,J),Q)}unsafe(W,Q,J,G){const V=z6(W);return V===1?this._unsafeLadder(W,Q,G):this.wNAFUnsafe(V,this.getPrecomputes(V,W,J),Q,G)}createCache(W,Q){YW(Q,this.bits),PW.set(W,Q),K6.delete(W)}hasCache(W){return z6(W)!==1}}var v7=(W,Q)=>(W+(W>=0?Q:-Q)/FW)/Q,j0={Err:class extends Error{constructor(W=""){super(W)}},_tlv:{encode(W,Q){const{Err:J}=j0;if(W<0||W>256)throw new J("tlv.encode: wrong tag");if(1&Q.length)throw new J("tlv.encode: unpadded data");const G=Q.length/2,V=P8(G);if(V.length/2&128)throw new J("tlv.encode: long form length too big");const q=G>127?P8(V.length/2|128):"";return P8(W)+q+V+Q},decode(W,Q){const{Err:J}=j0;let G=0;if(W<0||W>256)throw new J("tlv.encode: wrong tag");if(Q.length<2||Q[G++]!==W)throw new J("tlv.decode: wrong tlv");const V=Q[G++];let q=0;if(128&V){const Y=127&V;if(!Y)throw new J("tlv.decode(long): indefinite length not supported");if(Y>4)throw new J("tlv.decode(long): byte length is too big");const F=Q.subarray(G,G+Y);if(F.length!==Y)throw new J("tlv.decode: length bytes not complete");if(F[0]===0)throw new J("tlv.decode(long): zero leftmost byte");for(let P of F)q=q<<8|P;if(G+=Y,q<128)throw new J("tlv.decode(long): not minimal encoding")}else q=V;const X=Q.subarray(G,G+q);if(X.length!==q)throw new J("tlv.decode: wrong value length");return{v:X,l:Q.subarray(G+q)}}},_int:{encode(W){const{Err:Q}=j0;if(W<R0)throw new Q("integer: negative integers are not allowed");let J=P8(W);if(8&Number.parseInt(J[0],16)&&(J="00"+J),1&J.length)throw new Q("unexpected DER parsing assertion: unpadded hex");return J},decode(W){const{Err:Q}=j0;if(128&W[0])throw new Q("invalid signature integer: negative");if(W[0]===0&&!(128&W[1]))throw new Q("invalid signature integer: unnecessary leading zero");return H1(W)}},toSig(W){const{Err:Q,_int:J,_tlv:G}=j0,V=a("signature",W),{v:q,l:X}=G.decode(48,V);if(X.length)throw new Q("invalid signature: left bytes after parsing");const{v:Y,l:F}=G.decode(2,q),{v:P,l:U}=G.decode(2,F);if(U.length)throw new Q("invalid signature: left bytes after parsing");return{r:J.decode(Y),s:J.decode(P)}},hexFromSig(W){const{_tlv:Q,_int:J}=j0,G=Q.encode(2,J.encode(W.r))+Q.encode(2,J.encode(W.s));return Q.encode(48,G)}},R0=BigInt(0),K1=BigInt(1),FW=BigInt(2),U8=BigInt(3),YG=BigInt(4),k1={p:BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),n:BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),h:BigInt(1),a:BigInt(0),b:BigInt(7),Gx:BigInt("0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),Gy:BigInt("0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8")},zG={beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),basises:[[BigInt("0x3086d221a7d46bcde86c90e49284eb15"),-BigInt("0xe4437ed6010e88286f547fa90abfe4c3")],[BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),BigInt("0x3086d221a7d46bcde86c90e49284eb15")]]},ZG=BigInt(0),g7=BigInt(1),B6=BigInt(2),L8=c1(k1.p,{sqrt(W){const Q=k1.p,J=BigInt(3),G=BigInt(6),V=BigInt(11),q=BigInt(22),X=BigInt(23),Y=BigInt(44),F=BigInt(88),P=W*W*W%Q,U=P*P*W%Q,k=U0(U,J,Q)*U%Q,K=U0(k,J,Q)*U%Q,z=U0(K,B6,Q)*P%Q,C=U0(z,V,Q)*z%Q,v=U0(C,q,Q)*C%Q,g=U0(v,Y,Q)*v%Q,T=U0(g,F,Q)*g%Q,A=U0(T,Y,Q)*v%Q,p=U0(A,J,Q)*U%Q,D=U0(p,X,Q)*C%Q,b=U0(D,G,Q)*P%Q,c=U0(b,B6,Q);if(!L8.eql(L8.sqr(c),W))throw Error("Cannot find square root");return c}}),ZW=function(W,Q){const J=(G)=>KG({...W,hash:G});return{...J(Q),create:J}}({...k1,Fp:L8,lowS:!0,endo:zG},H6),S7={},S6=(W)=>W.toBytes(!0).slice(1),$1=(()=>ZW.Point)(),T6=(W)=>W%B6===ZG,b1=H1,A6=(()=>{const W=(Q=M8(48))=>XW(Q,k1.n);return ZW.utils.randomSecretKey,{keygen(Q){const J=W(Q);return{secretKey:J,publicKey:T7(J)}},getPublicKey:T7,sign:kG,verify:$W,Point:$1,utils:{randomSecretKey:W,randomPrivateKey:W,taggedHash:R8,lift_x:kW,pointToBytes:S6,numberToBytesBE:x8,bytesToNumberBE:H1,mod:F0},lengths:{secretKey:32,publicKey:32,publicKeyHasPrefix:!1,signature:64,seed:48}}})(),{floor:L6,random:HG,sin:$G}=Math,m1="GenosRTC",u1=(W,Q)=>Array(W).fill().map(Q),CG="0123456789AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz",R6=(W)=>u1(W,()=>CG[L6(62*HG())]).join(""),U1=R6(20),i0=Promise.all.bind(Promise),MG=typeof window!="undefined",{entries:O6,fromEntries:CW,keys:BG}=Object,c0=()=>{},L0=(W)=>Error(`${m1}: ${W}`),jG=new TextEncoder,LG=new TextDecoder,a0=(W)=>jG.encode(W),k8=(W)=>LG.decode(W),I6=(W)=>W.reduce((Q,J)=>Q+J.toString(16).padStart(2,"0"),""),F8=(...W)=>W.join("@"),RG=(W,Q,J)=>(W.relayUrls||((G,V)=>{const q=[...G],X=()=>{const F=1e4*$G(V++);return F-L6(F)};let Y=q.length;for(;Y;){const F=L6(X()*Y--);[q[Y],q[F]]=[q[F],q[Y]]}return q})(Q,MW(W.appId))).slice(0,W.relayUrls?W.relayUrls.length:W.relayRedundancy||J),O0=JSON.stringify,O8=JSON.parse,MW=(W,Q=Number.MAX_SAFE_INTEGER)=>W.split("").reduce((J,G)=>J+G.charCodeAt(0),0)%Q,K8={},y6="AES-GCM",OG={},z8=async(W)=>OG[W]||=Array.from(new Uint8Array(await crypto.subtle.digest("SHA-1",a0(W)))).map((Q)=>Q.toString(36)).join(""),IG=async(W,Q)=>{const J=crypto.getRandomValues(new Uint8Array(16));return J.join(",")+"$"+(G=await crypto.subtle.encrypt({name:y6,iv:J},await W,a0(Q)),btoa(String.fromCharCode.apply(null,new Uint8Array(G))));var G},xG=async(W,Q)=>{const[J,G]=Q.split("$");return k8(await crypto.subtle.decrypt({name:y6,iv:new Uint8Array(J.split(","))},await W,((V)=>{const q=atob(V);return new Uint8Array(q.length).map((X,Y)=>q.charCodeAt(Y)).buffer})(G)))},A7="icegatheringstatechange",y7="offer",E7=(W,{rtcConfig:Q,rtcPolyfill:J,turnConfig:G})=>{const V=new(J||RTCPeerConnection)({iceServers:wG.concat(G||[]),...Q}),q={};let X=!1,Y=!1,F=null;const P=(k)=>{k.binaryType="arraybuffer",k.bufferedAmountLowThreshold=65535,k.onmessage=(K)=>q.data?.(K.data),k.onopen=()=>q.connect?.(),k.onclose=()=>q.close?.(),k.onerror=(K)=>{K?.error?.message?.includes("User-Initiated Abort")||q.error?.(K)}},U=(k)=>Promise.race([new Promise((K)=>{const z=()=>{k.iceGatheringState==="complete"&&(k.removeEventListener(A7,z),K())};k.addEventListener(A7,z),z()}),new Promise((K)=>setTimeout(K,5000))]).then(()=>({type:k.localDescription.type,sdp:k.localDescription.sdp.replace(/a=ice-options:trickle\s\n/g,"")}));return W?(F=V.createDataChannel("data"),P(F)):V.ondatachannel=({channel:k})=>{F=k,P(k)},V.onnegotiationneeded=async()=>{try{X=!0,await V.setLocalDescription();const k=await U(V);q.signal?.(k)}catch(k){q.error?.(k)}finally{X=!1}},V.onconnectionstatechange=()=>{["disconnected","failed","closed"].includes(V.connectionState)&&q.close?.()},V.ontrack=(k)=>{q.track?.(k.track,k.streams[0]),q.stream?.(k.streams[0])},V.onremovestream=(k)=>q.stream?.(k.stream),W&&(V.canTrickleIceCandidates||V.onnegotiationneeded()),{created:Date.now(),connection:V,get channel(){return F},get isDead(){return V.connectionState==="closed"},async signal(k){if(F?.readyState!=="open"||k.sdp?.includes("a=rtpmap"))try{if(k.type===y7){if(X||V.signalingState!=="stable"&&!Y){if(W)return;await i0([V.setLocalDescription({type:"rollback"}),V.setRemoteDescription(k)])}else await V.setRemoteDescription(k);await V.setLocalDescription();const K=await U(V);return q.signal?.(K),K}if(k.type==="answer"){Y=!0;try{await V.setRemoteDescription(k)}finally{Y=!1}}}catch(K){q.error?.(K)}},sendData(k){return F.send(k)},destroy(){F?.close(),V.close(),X=!1,Y=!1},setHandlers(k){return Object.assign(q,k)},offerPromise:W?new Promise((k)=>q.signal=(K)=>{K.type===y7&&k(K)}):Promise.resolve(),addStream(k){return k.getTracks().forEach((K)=>V.addTrack(K,k))},removeStream(k){return V.getSenders().filter((K)=>k.getTracks().includes(K.track)).forEach((K)=>V.removeTrack(K))},addTrack(k,K){return V.addTrack(k,K)},removeTrack(k){const K=V.getSenders().find((z)=>z.track===k);K&&V.removeTrack(K)},replaceTrack(k,K){const z=V.getSenders().find((C)=>C.track===k);if(z)return z.replaceTrack(K)}}},wG=[...u1(3,(W,Q)=>`stun:stun${Q||""}.l.google.com:19302`),"stun:stun.cloudflare.com:3478"].map((W)=>({urls:W})),DG=Object.getPrototypeOf(Uint8Array),d0=16369,Z8=255,p7="bufferedamountlow",F1=(W)=>"@_"+W,NG=(W,Q,J)=>{const G={},V={},q={},X={},Y={},F={},P={},U={onPeerJoin:c0,onPeerLeave:c0,onPeerStream:c0,onPeerTrack:c0},k=(Z,$)=>(Z?Array.isArray(Z)?Z:[Z]:BG(G)).flatMap((O)=>{const x=G[O];return x?$(O,x):(console.warn(`${m1}: no peer with id ${O} found`),[])}),K=(Z)=>{G[Z]&&(delete G[Z],delete X[Z],delete Y[Z],U.onPeerLeave(Z),Q(Z))},z=(Z)=>{if(V[Z])return q[Z];if(!Z)throw L0("action type argument is required");const $=a0(Z);if($.byteLength>12)throw L0(`action type string "${Z}" (${$.byteLength}b) exceeds byte limit (12). Hint: choose a shorter name.`);const O=new Uint8Array(12);O.set($);let x=0;return V[Z]={onComplete:c0,onProgress:c0,setOnComplete(M){return V[Z]={...V[Z],onComplete:M}},setOnProgress(M){return V[Z]={...V[Z],onProgress:M}},async send(M,B,L,j){if(L&&typeof L!="object")throw L0("action meta argument must be an object");const w=typeof M;if(w==="undefined")throw L0("action data cannot be undefined");const E=w!=="string",S=M instanceof Blob,y=S||M instanceof ArrayBuffer||M instanceof DG;if(L&&!y)throw L0("action meta argument can only be used with binary data");const m=y?new Uint8Array(S?await M.arrayBuffer():M):a0(E?O0(M):M),u=L?a0(O0(L)):null,f=Math.ceil(m.byteLength/d0)+(L?1:0)||1,h=u1(f,(_,i)=>{const r=i===f-1,G0=L&&i===0,X0=new Uint8Array(15+(G0?u.byteLength:r?m.byteLength-d0*(f-(L?2:1)):d0));return X0.set(O),X0.set([x],12),X0.set([r|G0<<1|y<<2|E<<3],13),X0.set([Math.round((i+1)/f*Z8)],14),X0.set(L?G0?u:m.subarray((i-1)*d0,i*d0):m.subarray(i*d0,(i+1)*d0),15),X0});return x=x+1&Z8,i0(k(B,async(_,i)=>{const{channel:r}=i;let G0=0;for(;G0<f;){const X0=h[G0];if(r.bufferedAmount>r.bufferedAmountLowThreshold&&await new Promise((NW)=>{const d6=()=>{r.removeEventListener(p7,d6),NW()};r.addEventListener(p7,d6)}),!G[_])break;i.sendData(X0),G0++,j?.(X0[14]/Z8,_,L)}}))}},q[Z]||=[V[Z].send,V[Z].setOnComplete,V[Z].setOnProgress]},C=async()=>{await N(""),await new Promise((Z)=>setTimeout(Z,99)),O6(G).forEach(([Z,$])=>{$.destroy(),delete G[Z]}),J()},[v,g]=z(F1("ping")),[T,A]=z(F1("pong")),[p,D]=z(F1("signal")),[b,c]=z(F1("stream")),[I,R]=z(F1("track")),[N,H]=z(F1("leave"));return W((Z,$)=>{G[$]||(G[$]=Z,Z.setHandlers({data(O){return((x,M)=>{const B=new Uint8Array(M),L=k8(B.subarray(0,12)).replaceAll("\0",""),[j]=B.subarray(12,13),[w]=B.subarray(13,14),[E]=B.subarray(14,15),S=B.subarray(15),y=!!(1&w),m=!!(2&w),u=!!(4&w),f=!!(8&w);if(!V[L])return void console.warn(`${m1}: received message with unregistered type (${L})`);X[x]||={},X[x][L]||={};const h=X[x][L][j]||={chunks:[]};if(m?h.meta=O8(k8(S)):h.chunks.push(S),V[L].onProgress(E/Z8,x,h.meta),!y)return;const _=new Uint8Array(h.chunks.reduce((i,r)=>i+r.byteLength,0));if(h.chunks.reduce((i,r)=>(_.set(r,i),i+r.byteLength),0),delete X[x][L][j],u)V[L].onComplete(_,x,h.meta);else{const i=k8(_);V[L].onComplete(f?O8(i):i,x)}})($,O)},stream(O){U.onPeerStream(O,$,F[$]),delete F[$]},track(O,x){U.onPeerTrack(O,x,$,P[$]),delete P[$]},signal(O){return p(O,$)},close(){return K($)},error(O){console.error(O),K($)}}),U.onPeerJoin($))}),g((Z,$)=>T("",$)),A((Z,$)=>{Y[$]?.(),delete Y[$]}),D((Z,$)=>G[$]?.signal(Z)),c((Z,$)=>F[$]=Z),R((Z,$)=>P[$]=Z),H((Z,$)=>K($)),MG&&addEventListener("beforeunload",C),{makeAction:z,leave:C,async ping(Z){if(!Z)throw L0("ping() must be called with target peer ID");const $=Date.now();return v("",Z),await new Promise((O)=>Y[Z]=O),Date.now()-$},getPeers(){return CW(O6(G).map(([Z,$])=>[Z,$.connection]))},addStream(Z,$,O){return k($,async(x,M)=>{O&&await b(O,x),M.addStream(Z)})},removeStream(Z,$){return k($,(O,x)=>x.removeStream(Z))},addTrack(Z,$,O,x){return k(O,async(M,B)=>{x&&await I(x,M),B.addTrack(Z,$)})},removeTrack(Z,$){return k($,(O,x)=>x.removeTrack(Z))},replaceTrack(Z,$,O,x){return k(O,async(M,B)=>{x&&await I(x,M),B.replaceTrack(Z,$)})},onPeerJoin(Z){return U.onPeerJoin=Z},onPeerLeave(Z){return U.onPeerLeave=Z},onPeerStream(Z){return U.onPeerStream=Z},onPeerTrack(Z){return U.onPeerTrack=Z}}},BW={},jW="EVENT",LW=A6.utils.randomSecretKey(),vG=I6(A6.getPublicKey(LW)),E6={},h1={},gG={},RW=()=>Math.floor(Date.now()/1000),OW=(W)=>gG[W]??=MW(W,1e4)+20000,f7=async(W,Q)=>{const J={kind:OW(W),content:Q,pubkey:vG,created_at:RW(),tags:[["x",W]]},G=new Uint8Array(await crypto.subtle.digest("SHA-256",a0(O0([0,J.pubkey,J.created_at,J.kind,J.tags,J.content])))),V=A6.sign(G,LW);return O0([jW,{...J,id:I6(G),sig:I6(V)}])},h7=(W,Q)=>(E6[W]=Q,O0(["REQ",W,{kinds:[OW(Q)],since:RW(),"#x":[Q]}])),b7=(W)=>(delete E6[W],O0(["CLOSE",W])),p6=(({init:W,subscribe:Q,announce:J})=>{const G={};let V,q,X,Y=!1;return(F,P,U)=>{const{appId:k}=F;if(G[k]?.[P])return G[k][P];const K={},z={},C=F8(m1,k,P),v=z8(C),g=z8(F8(C,U1)),T=(async(M,B,L)=>crypto.subtle.importKey("raw",await crypto.subtle.digest({name:"SHA-256"},a0(`${M}:${B}:${L}`)),{name:y6},!1,["encrypt","decrypt"]))(F.password||"",k,P),A=(M)=>async(B)=>({type:B.type,sdp:await M(T,B.sdp)}),p=A(xG),D=A(IG),b=()=>E7(!0,F),c=(M,B,L)=>{z[B]?z[B]!==M&&M.destroy():(z[B]=M,x(M,B),K[B]?.forEach((j,w)=>{w!==L&&j.destroy()}),delete K[B])},I=(M,B)=>{z[B]===M&&delete z[B]},R=(M)=>(q.push(...u1(M,b)),i0(q.splice(0,M).map((B)=>B.offerPromise.then(D).then((L)=>({peer:B,offer:L}))))),N=(M,B)=>U?.({error:`incorrect password (${F.password}) when decrypting ${B}`,appId:k,peerId:M,roomId:P}),H=(M)=>async(B,L,j)=>{const[w,E]=await i0([v,g]);if(B!==w&&B!==E)return;const{peerId:S,offer:y,answer:m,peer:u}=typeof L=="string"?O8(L):L;if(S!==U1&&!z[S])if(!S||y||m){if(y){if(K[S]?.[M]&&U1>S)return;const h=E7(!1,F);let _;h.setHandlers({connect(){return c(h,S,M)},close(){return I(h,S)}});try{_=await p(y)}catch{return void N(S,"offer")}if(h.isDead)return;const[i,r]=await i0([z8(F8(C,S)),h.signal(_)]);j(i,O0({peerId:U1,answer:await D(r)}))}else if(m){let f;try{f=await p(m)}catch(h){return void N(S,"answer")}if(u)u.setHandlers({connect(){return c(u,S,M)},close(){return I(u,S)}}),u.signal(f);else{const h=K[S]?.[M];h&&!h.isDead&&h.signal(f)}}}else{if(K[S]?.[M])return;const[[{peer:f,offer:h}],_]=await i0([R(1),z8(F8(C,S))]);K[S]||=[],K[S][M]=f,setTimeout(()=>((i,r)=>{if(z[i])return;const G0=K[i]?.[r];G0&&(delete K[i][r],G0.destroy())})(S,M),0.9*Z[M]),f.setHandlers({connect(){return c(f,S,M)},close(){return I(f,S)}}),j(_,O0({peerId:U1,offer:h}))}};if(!F)throw L0("requires a config map as the first argument");if(!k&&!F.firebaseApp)throw L0("config map is missing appId field");if(!P)throw L0("roomId argument required");if(!Y){const M=W(F);q=u1(20,b),V=Array.isArray(M)?M:[M],Y=!0,X=setInterval(()=>q=q.filter((B)=>{const L=Date.now()-B.created<57333;return L||B.destroy(),L}),59052.99)}const Z=V.map(()=>5333),$=[],O=V.map(async(M,B)=>Q(await M,await v,await g,H(B),R));i0([v,g]).then(([M,B])=>{const L=async(j,w)=>{const E=await J(j,M,B);typeof E=="number"&&(Z[w]=E),$[w]=setTimeout(()=>L(j,w),Z[w])};O.forEach(async(j,w)=>{await j,L(await V[w],w)})});let x=c0;return G[k]||={},G[k][P]=NG((M)=>x=M,(M)=>delete z[M],()=>{delete G[k][P],$.forEach(clearTimeout),O.forEach(async(M)=>(await M)()),clearInterval(X)})}})({init(W){return RG(W,SG,5).map((Q)=>{const J=((G,V)=>{const q={},X=()=>{const Y=new WebSocket(G);Y.onclose=()=>{K8[G]??=3333,setTimeout(X,K8[G]),K8[G]*=2},Y.onmessage=(F)=>V(F.data),q.socket=Y,q.url=Y.url,q.ready=new Promise((F)=>Y.onopen=()=>{F(q),K8[G]=3333}),q.send=(F)=>{Y.readyState===1&&Y.send(F)}};return X(),q})(Q,(G)=>{const[V,q,X,Y]=O8(G);if(V===jW)h1[q]?.(E6[q],X.content);else{const F=`${m1}: relay failure from ${J.url} - `;V==="NOTICE"?console.warn(F+q):V!=="OK"||X||console.warn(F+Y)}});return BW[Q]=J,J.ready})},subscribe(W,Q,J,G){const V=R6(64),q=R6(64);return h1[V]=h1[q]=(X,Y)=>G(X,Y,async(F,P)=>W.send(await f7(F,P))),W.send(h7(V,Q)),W.send(h7(q,J)),()=>{W.send(b7(V)),W.send(b7(q)),delete h1[V],delete h1[q]}},async announce(W,Q){return W.send(await f7(Q,O0({peerId:U1})))}}),$V=(m7=BW,()=>CW(O6(m7).map(([W,Q])=>[W,Q.socket]))),m7,SG=["black.nostrcity.club","eu.purplerelay.com","ftp.halifax.rwth-aachen.de/nostr","nostr.cool110.xyz","nostr.data.haus","nostr.mom","nostr.oxtr.dev","nostr.sathoarder.com","nostr.vulpem.com","playground.nostrcheck.me/relay","relay.agorist.space","relay.binaryrobot.com","relay.fountain.fm","relay.mostro.network","relay.nostraddress.com","relay.nostrdice.com","relay.nostromo.social","relay.oldenburg.cool","relay.snort.social","relay.verified-nostr.com","sendit.nosflare.com","yabu.me/v2","relay.damus.io"].map((W)=>"wss://"+W);var IW=(W,Q,J)=>{let G=Q.timestamp;if(Q.timestamp&&typeof Q.timestamp.physical==="number"){const X=Date.now()+7200000;if(Q.timestamp.physical>X)G={physical:X,logical:Q.timestamp.logical}}if(!W||!W.timestamp)return{resolved:!0,value:Q.value,timestamp:G};const V=W.timestamp;if(J.compare(V,G)<0)return{resolved:!0,value:Q.value,timestamp:G};return{resolved:!1}};class f6{constructor(W,Q=50){this.key=`gdb_oplog_${W}`,this.maxSize=Q,this.log=this._load()}_load(){try{const W=localStorage.getItem(this.key);return W?JSON.parse(W):[]}catch(W){return console.error("Failed to load oplog from localStorage:",W),[]}}_save(){try{localStorage.setItem(this.key,JSON.stringify(this.log))}catch(W){console.error("Failed to save oplog to localStorage:",W)}}add(W){if(this.log.push(W),this.log.length>this.maxSize)this.log.shift();this._save()}getDelta(W,Q){if(!W)return[...this.log];return this.log.filter((J)=>Q(J.timestamp,W)>0)}getOldest(){return this.log[0]}clear(){this.log=[],localStorage.removeItem(this.key)}}var TG=()=>{const W=new Map,Q=async()=>{try{const F=await navigator.storage.getDirectory(),U=await(await F.getFileHandle("~opfs-sync-test",{create:!0})).createSyncAccessHandle?.();return await U?.close(),await F.removeEntry("~opfs-sync-test"),!!U}catch{return!1}};let J="idb";const G=(async()=>{if(await Q())J="sync";else try{const F=await navigator.storage.getDirectory(),U=await(await F.getFileHandle("~opfs-async-test",{create:!0})).createWritable?.();if(await U?.close(),await F.removeEntry("~opfs-async-test"),U)J="async";else J="idb"}catch{J="idb"}})(),V=async(F,P)=>{if(!W.has(F))W.set(F,[]);const U=W.get(F),k=U[U.length-1]||Promise.resolve();let K;const z=new Promise((C)=>K=C);U.push(z);try{return await k,await P()}finally{if(U.shift(),K(),U.length===0)W.delete(F)}},q=(()=>{let F;const P=async()=>{if(!F)F=new Promise((U,k)=>{const K=indexedDB.open("opfs-fallback-db",1);K.onupgradeneeded=()=>K.result.createObjectStore("files"),K.onsuccess=()=>U(K.result),K.onerror=()=>k(K.error)});return F};return{getDB:P,get:async(U)=>{const k=await P();return new Promise((K,z)=>{const v=k.transaction("files","readonly").objectStore("files").get(U);v.onsuccess=()=>K(v.result||new Uint8Array),v.onerror=()=>z(v.error)})},set:async(U,k)=>{const K=await P();return new Promise((z,C)=>{const g=K.transaction("files","readwrite").objectStore("files").put(k,U);g.onsuccess=()=>z(),g.onerror=()=>C(g.error)})}}})(),X=async(F)=>{await G;try{if(J==="idb"){const z=await q.get(F);return{type:"loaded",name:F,data:z}}const U=await(await navigator.storage.getDirectory()).getFileHandle(F);if(J==="sync"){let z;try{z=await U.createSyncAccessHandle();const C=z.getSize(),v=new Uint8Array(C),g=z.read(v,{at:0});return{type:"loaded",name:F,data:v.slice(0,g)}}finally{z?.close()}}const k=await U.getFile(),K=new Uint8Array(await k.arrayBuffer());return{type:"loaded",name:F,data:K}}catch(P){const U=P.name==="NotFoundError"?"File not found":P.message||"Error reading file";return{type:"error",name:F,message:U}}},Y=async(F,P)=>{if(await G,!(P instanceof Uint8Array))return{type:"error",name:F,message:"Content must be a Uint8Array"};return V(F,async()=>{try{if(J==="idb")return await q.set(F,P),{type:"saved",name:F};const k=await(await navigator.storage.getDirectory()).getFileHandle(F,{create:!0});if(J==="sync"){let K;try{K=await k.createSyncAccessHandle(),K.truncate(0),K.write(P,{at:0}),K.flush()}finally{K?.close()}}else{let K;try{K=await k.createWritable(),await K.write(P)}finally{await K?.close()}}return{type:"saved",name:F}}catch(U){return{type:"error",name:F,message:U.message||"Error saving file"}}})};self.onmessage=async({data:F})=>{const{type:P,name:U,content:k}=F;await G;const K={load:()=>X(U),save:()=>Y(U,k)};try{const z=K[P],C=z?await z():{type:"error",message:`Unrecognized action type: ${P}`};self.postMessage(C)}catch(z){console.error("Worker unexpected error:",z),self.postMessage({type:"error",name:U,message:z.message||"Unexpected worker error"})}}},xW=TG;var s0={$eq:(W,Q)=>W===Q,$ne:(W,Q)=>W!==Q,$gt:(W,Q)=>W>Q,$gte:(W,Q)=>W>=Q,$lt:(W,Q)=>W<Q,$lte:(W,Q)=>W<=Q,$in:(W,Q)=>Array.isArray(Q)&&Q.includes(W),$between:(W,[Q,J])=>W>=Q&&W<=J,$exists:(W,Q)=>Q?W!==void 0:W===void 0,$text:{global:(W,Q)=>{const J=(V)=>String(V).normalize("NFD").replace(/[\u0300-\u036f]/g,"").toLowerCase().replace(/[^\w\s]/g,""),G=J(Q);return Object.values(W).some((V)=>{if(typeof V==="object")return null.fieldSearch(V,G);return J(V).includes(G)})},field:(W,Q)=>{const J=(G)=>String(G).normalize("NFD").replace(/[\u0300-\u036f]/g,"").toLowerCase().replace(/[^\w\s]/g,"");return Array.isArray(W)?W.some((G)=>J(G).includes(J(Q))):J(W).includes(J(Q))}},$like:(W,Q)=>{if(typeof W!=="string"||typeof Q!=="string")return!1;return new RegExp(`^${Q.replace(/%/g,".*").replace(/_/g,".")}\$`,"i").test(W)},$regex:(W,Q)=>typeof W==="string"&&new RegExp(Q.$regex||Q,"i").test(W),$and:(W,Q,J)=>Q.every((G)=>{return J.createFilter(G)(W)}),$or:(W,Q,J)=>Q.some((G)=>{return J.createFilter(G)(W)}),$not:(W,Q,J)=>{return!J.createFilter(Q)(W)}},h6=(W,Q)=>{const J=Q.split(".");let G=W;for(let V of J)if(G&&typeof G==="object"&&(V in G))G=G[V];else return;return G},b6=(W)=>{const Q=(J)=>{return Object.entries(W).every(([G,V])=>{if(G.startsWith("$"))return s0[G](J,V,{filterNode:Q,createFilter:b6});const q=h6(J.value,G);if(typeof V!=="object"||V===null)return s0.$eq(q,V);return Object.entries(V).every(([X,Y])=>{if(X==="$text")return s0.$text.field(q,Y);if(X==="$between"&&Y.every((F)=>F instanceof Date)){const F=new Date(q);return s0.$between(F,Y)}return s0[X]?.(q,Y,{filterNode:Q,createFilter:b6})??!1})})};return Q},m6=(W,Q)=>{const J=b6(Q.query);let G=Object.values(W).filter(J);if(Q.field)G.sort((V,q)=>{const X=h6(V.value,Q.field),Y=h6(q.value,Q.field),F=Q.order==="asc"?1:-1;if(typeof X==="string"&&typeof Y==="string")return X.localeCompare(Y)*F;return((X??0)-(Y??0))*F});if(Q.$after){const V=G.findIndex((q)=>q.id===Q.$after);G=V>=0?G.slice(V+1):[]}if(Q.$before){const V=G.findIndex((q)=>q.id===Q.$before);G=V>=0?G.slice(0,V):[]}return Q.$limit?G.slice(0,Q.$limit):G};class u6{constructor(){this.physical=Date.now(),this.logical=0}now(){const W=Date.now();return this.physical=Math.max(this.physical,W),this.logical++,{physical:this.physical,logical:this.logical}}update(W){if(!W||typeof W.physical!=="number"||typeof W.logical!=="number")return;this.physical=Math.max(this.physical,W.physical),this.logical=Math.max(this.logical,W.logical)+1}compare(W,Q){if(!W&&!Q)return 0;if(!W)return-1;if(!Q)return 1;if(W.physical>Q.physical)return 1;if(W.physical<Q.physical)return-1;if(W.logical>Q.logical)return 1;if(W.logical<Q.logical)return-1;return 0}}var wW=function(W,Q){return W.length===Q.length&&W.every((J,G)=>J===Q[G])};async function AG(){console.log("\u26A1 GenosDB: Empowering distributed graph databases with real-time synchronization and scalability. Learn more: https://github.com/estebanrfp/gdb \u26A1"),console.log(navigator?.storage?.getDirectory?"OPFS is enabled.":"OPFS is not available."),navigator?.storage?.getDirectory&&await navigator.storage.getDirectory()}if(Symbol.dispose===void 0)Object.defineProperty(Symbol,"dispose",{value:Symbol.for("Symbol.dispose")});class DW{constructor(){this.nodes={}}upsert(W,Q,J){this.nodes[W]={id:W,value:Q,edges:[],timestamp:J}}get(W){return this.nodes[W]||null}link(W,Q,J){const G=this.nodes[W],V=this.nodes[Q];if(G&&V&&!G.edges.includes(Q))G.edges.push(Q),G.timestamp=J}getAllNodes(){return Object.values(this.nodes)}serialize(){return u0.deflate(I0(this.nodes))}deserialize(W){this.nodes=a1(u0.inflate(new Uint8Array(W)))}}class w8{static _listenersInitialized=!1;constructor(W,{password:Q,securityManager:J=null,relayUrls:G=null}={}){this.oplog=new f6(W,20),this.hybridClock=new u6,this.name=W,this.password=Q,this.globalTimestamp=null,this.graph=new DW,this.securityManager=J,this.eventListeners=[],this.operators=s0,this.initWorker(),this.ready=this.loadGraphFromOPFS(),this.loadGlobalTimestamp();const V=`graph-sync-room-${this.name}`,q={appId:"1234",...this.password&&{password:this.password}};if(G)q.relayUrls=G;const X=p6(q,V),[Y,F]=X.makeAction("syncGraph");this.sendData=Y;const P=p6(q,`app-sync-${this.name}`);if(this.room=P,!w8._listenersInitialized)w8._listenersInitialized=!0,window.addEventListener("online",async()=>{console.log("\u2705 Reconnected to the network."),this.sendData([{type:"sync",timestamp:this.globalTimestamp}])}),window.addEventListener("offline",async()=>{console.log("\u274C Disconnected from the network.")}),document.addEventListener("visibilitychange",()=>{if(document.visibilityState==="visible")console.log("The tab is visible again."),this.sendData([{type:"sync",timestamp:this.globalTimestamp}]);else if(document.visibilityState==="hidden")console.log("The tab is no longer visible.")});AG(),X.onPeerJoin(async(U)=>{console.log("\u26A1 New pair connected:",U),this.sendData([{type:"sync",timestamp:this.globalTimestamp}])}),X.onPeerLeave((U)=>{console.log("\u26A1 Pair disconnected:",U)}),F(async(U)=>{if(this.securityManager&&typeof this.securityManager.verifyIncomingOperations==="function"){const{validatedOperations:k}=await this.securityManager.verifyIncomingOperations(U);if(k&&k.length>0)await this.receiveChanges(k)}else console.log("GDB: No SecurityManager configured or verifyIncomingOperations missing. Processing P2P data directly."),await this.receiveChanges(U),this.emit()}),this.channel=new BroadcastChannel(`graphdb_sync_${this.name}`),this.channel.onmessage=async(U)=>{if(U.data==="update")console.log("\uD83D\uDD04 Update received from another tab..."),await this.loadGraphFromOPFS(),this.loadGlobalTimestamp(),this.emit()}}loadGlobalTimestamp(){const W=localStorage.getItem(`${this.name}_time`);this.globalTimestamp=W?JSON.parse(W):null}saveGlobalTimestamp(W){this.globalTimestamp=W,localStorage.setItem(`${this.name}_time`,JSON.stringify(W))}initWorker(){try{const W=URL.createObjectURL(new Blob([`(${xW.toString()})()`],{type:"application/javascript"}));this.worker=new Worker(W),this.worker.addEventListener("message",({data:Q})=>{console.log("Worker message:",`${Q.name} ${Q.type}`),URL.revokeObjectURL(W)}),console.log("Worker initialized successfully.")}catch({message:W}){console.error("Failed to initialize worker:",W)}}getWorker(){return this.worker}emit(){this.eventListeners.forEach((W)=>W(this.graph.nodes))}compress(W){return u0.deflate(W)}decompress(W){return u0.inflate(W)}async getAllNodes(){return await this.ready,this.graph.getAllNodes()}async generateHash(){return crypto.randomUUID()}async hashValue(W){const Q=(new TextEncoder()).encode(W),J=await crypto.subtle.digest("SHA-256",Q);return Array.from(new Uint8Array(J)).map((G)=>G.toString(16).padStart(2,"0")).join("")}async loadGraphFromOPFS(){try{const Q=await((J)=>new Promise((G,V)=>{const q=async({data:X})=>{if(X.type==="loaded"&&X.name===J)this.worker.removeEventListener("message",q),G(new Uint8Array(X.data));else if(X.type==="error")this.worker.removeEventListener("message",q),V(new Error(X.message||"Unknown error"))};this.worker.addEventListener("message",q),this.worker.postMessage({type:"load",name:J})}))(`${this.name}_graph.msgpack`).catch(()=>new Uint8Array);Q.byteLength>0?this.graph.deserialize(Q):console.warn("The file '_graph.msgpack' is empty or could not be loaded."),console.log(`Graph loaded from OPFS: [ ${this.graph.getAllNodes().length} nodes ]`)}catch({message:W}){console.error("General error loading the graph from OPFS:",W)}}async saveGraphToOPFS(){try{const W=this.graph.serialize();return await((J,G)=>new Promise((V,q)=>{const X=({data:Y})=>{if(Y.type==="saved"&&Y.name===J)this.worker.removeEventListener("message",X),V();else if(Y.type==="error")this.worker.removeEventListener("message",X),q(new Error(Y.message||"Save error"))};this.worker.addEventListener("message",X),this.worker.postMessage({type:"save",name:J,content:G})}))(`${this.name}_graph.msgpack`,W),this.channel.postMessage("update"),!0}catch({message:W}){throw console.error("Save error:",W),new Error("Save failed")}}async put(W,Q){await this.ready;const J=this.hybridClock.now();return this.saveGlobalTimestamp(J),Q??=await this.generateHash(),this.graph.upsert(Q,W,J),this.oplog.add({type:"upsert",id:Q,timestamp:J}),await this.saveGraphToOPFS(),await this.sendData([{type:"upsert",id:Q,value:W,timestamp:J}]),this.emit(),Q}async get(W,Q=null){if(await this.ready,typeof W!=="string")return{result:null};const J=this.graph.get(W);if(!J){if(Q)Q(null);return{result:null}}const G=(X)=>{if(!X)return null;const Y=X.value!==null&&typeof X.value==="object"?{...X.value}:X.value;return{...X,value:Y}};if(!Q)return{result:G(J)};let V=J.timestamp;Q(G(J));const q=(X)=>{const Y=X[W];if(Y){if(this.hybridClock.compare(Y.timestamp,V)>0)V=Y.timestamp,Q(G(Y))}else Q(null),this.eventListeners.splice(this.eventListeners.indexOf(q),1)};return this.eventListeners.push(q),{result:G(J),unsubscribe:()=>{const X=this.eventListeners.indexOf(q);if(X>-1)this.eventListeners.splice(X,1)}}}async map(...W){await this.ready;let J={...{realtime:!1,query:{},field:null,order:"asc",$limit:null,$after:null,$before:null}},G=null,V=!1;W.forEach((F)=>typeof F==="function"?G=F:F&&typeof F==="object"&&(V||=("realtime"in F),Object.assign(J,F))),G&&!V&&(J.realtime=!0);let q=m6(this.graph.nodes,J),X=null;const Y=(F)=>{const P=F.filter((z)=>!q.some((C)=>C.id===z.id)),U=q.filter((z)=>!F.some((C)=>C.id===z.id)),k=F.filter((z)=>{const C=q.find((v)=>v.id===z.id);return C&&!wW(I0(z.value),I0(C.value))}),K=(z,C)=>{const v=C==="removed"?null:z.value,g={id:z.id,value:v,edges:z.edges||[],timestamp:z.timestamp||null,action:C};G(g)};P.forEach((z)=>K(z,"added")),U.forEach((z)=>K(z,"removed")),k.forEach((z)=>K(z,"updated"))};if(G){if(q.forEach((F)=>{if(F.value)G({id:F.id,value:F.value,edges:F.edges,timestamp:F.timestamp,action:"initial"})}),J.realtime)X=(F)=>{const P=m6(F,J);if(!wW(I0(P),I0(q)))Y(P),q=P},this.eventListeners.push(X)}return{results:q,...J.realtime&&G&&X&&{unsubscribe:()=>{const F=this.eventListeners.indexOf(X);F>-1&&this.eventListeners.splice(F,1)}}}}async remove(W){await this.ready;const Q=this.hybridClock.now(),J=this.graph.get(W);if(!J)return console.error(`Node with ID '${W}' not found.`);delete this.graph.nodes[W],this.oplog.add({type:"remove",id:W,timestamp:Q}),Object.values(this.graph.nodes).forEach((G)=>G.edges=G.edges.filter((V)=>V!==W)),await this.saveGraphToOPFS(),this.saveGlobalTimestamp(Q),await this.sendData([{type:"remove",id:W,value:J.value,timestamp:Q}]),this.emit()}async clear(){await this.ready,this.graph.nodes={};try{await(await navigator.storage.getDirectory()).removeEntry(`${this.name}_graph.msgpack`)}catch({message:W}){console.warn(`Error deleting _graph.msgpack: ${W}`)}this.emit(),console.log("All data has been deleted.")}async link(W,Q){await this.ready;const J=this.hybridClock.now();if(!this.graph.nodes[W]||!this.graph.nodes[Q]){console.error(`One or both nodes (${W}, ${Q}) do not exist.`);return}this.graph.link(W,Q,J),this.oplog.add({type:"link",sourceId:W,targetId:Q,timestamp:J}),await this.saveGraphToOPFS(),this.saveGlobalTimestamp(J),await this.sendData([{type:"link",sourceId:W,targetId:Q,timestamp:J}]),this.emit()}async applyFullGraph(W){try{console.log("Applying full graph from remote..."),this.graph.nodes={...W.nodes},await this.saveGraphToOPFS()}catch({message:Q}){console.error(`Error applying the full graph: ${Q}`)}}async receiveChanges(W){let Q=!1,J=null;const G={upsert:(V)=>{const q=this.graph.get(V.id),X=IW(q,V,this.hybridClock);if(X.resolved){if(this.graph.upsert(V.id,X.value,X.timestamp),this.hybridClock.update(X.timestamp),this.oplog.add({type:"upsert",id:V.id,timestamp:X.timestamp}),Q=!0,!J||this.hybridClock.compare(X.timestamp,J)>0)J=X.timestamp}},remove:(V)=>{const q=this.graph.get(V.id);if(q&&this.hybridClock.compare(q.timestamp,V.timestamp)<0){if(delete this.graph.nodes[V.id],this.hybridClock.update(V.timestamp),this.oplog.add({type:"remove",id:V.id,timestamp:V.timestamp}),Q=!0,!J||this.hybridClock.compare(V.timestamp,J)>0)J=V.timestamp}},link:(V)=>{const q=this.graph.get(V.sourceId),X=this.graph.get(V.targetId);if(q&&X&&this.hybridClock.compare(q.timestamp,V.timestamp)<0){if(this.graph.link(V.sourceId,V.targetId,V.timestamp),this.hybridClock.update(V.timestamp),this.oplog.add({type:"link",sourceId:V.sourceId,targetId:V.targetId,timestamp:V.timestamp}),Q=!0,!J||this.hybridClock.compare(V.timestamp,J)>0)J=V.timestamp}},sync:async(V)=>{const q=V.timestamp;console.log("\uD83D\uDCEC [SYNC REQUEST RECEIVED] A peer is asking for changes since timestamp:",q);const X=this.oplog.getOldest();if(X&&q&&this.hybridClock.compare(q,X.timestamp)<0){console.error("\uD83D\uDCA5 [FALLBACK TRIGGERED] Peer is too far behind. Sending FULL graph state."),await this.sendData([{type:"syncReceive",graph:this.graph}]);return}const Y=this.oplog.getDelta(q,this.hybridClock.compare);if(Y.length>0){const F=Y.map((U)=>{if(U.type==="upsert"){const k=this.graph.get(U.id);return{...U,value:k?k.value:null}}return U}),P=u0.deflate(I0(F));console.log("\uD83D\uDCE6 Delta compressed for transport."),console.log(`\uD83D\uDE80 [SENDING DELTA] Found ${Y.length} new operations to send.`),await this.sendData([{type:"deltaSync",operations:P}])}else console.log("\u2705 [ALREADY SYNCED] Peer is up-to-date. Nothing to send.")},deltaSync:(V)=>{console.log("\uD83D\uDEF0\uFE0F [DECOMPRESSING DELTA] Received compressed delta sync.");let q=a1(u0.inflate(V.operations));console.log(`\uD83D\uDEF0\uFE0F [DELTA SYNC RECEIVED] Applying ${q.length} operations from a peer.`);for(let X of q)G[X.type]?.(X)},syncReceive:async(V)=>{if(console.log("\uD83D\uDCE6 [FULL SYNC RECEIVED] Overwriting local state with full graph from a peer."),V.graph)await this.applyFullGraph(V.graph),this.oplog.clear(),console.warn("\uD83D\uDD12 Oplog has been cleared due to full sync."),Q=!0;else console.error("Full sync failed: received graph data is invalid.",V.graph)}};for(let V of W)if(G[V.type])await G[V.type](V);else console.warn(`\uD83E\uDD37\u200D\u2640\uFE0F [UNKNOWN MESSAGE TYPE] Received unhandled message type: "${V.type}"`);if(J)console.log("\uD83D\uDCC8 [UPDATING GLOBAL TIMESTAMP] Advancing local knowledge to the latest received timestamp."),this.saveGlobalTimestamp(J);if(Q)console.log("\uD83D\uDCBE [STATE CHANGED] Saving new state to OPFS and emitting update."),await this.saveGraphToOPFS(),this.emit()}}export{w8 as default};
