function l6(W){const G=W.length;let J=0,Q=0;while(Q<G){let V=W.charCodeAt(Q++);if((V&4294967168)===0){J++;continue}else if((V&4294965248)===0)J+=2;else{if(V>=55296&&V<=56319){if(Q<G){const X=W.charCodeAt(Q);if((X&64512)===56320)++Q,V=((V&1023)<<10)+(X&1023)+65536}}if((V&4294901760)===0)J+=3;else J+=4}}return J}function SW(W,G,J){const Q=W.length;let V=J,X=0;while(X<Q){let Y=W.charCodeAt(X++);if((Y&4294967168)===0){G[V++]=Y;continue}else if((Y&4294965248)===0)G[V++]=Y>>6&31|192;else{if(Y>=55296&&Y<=56319){if(X<Q){const q=W.charCodeAt(X);if((q&64512)===56320)++X,Y=((Y&1023)<<10)+(q&1023)+65536}}if((Y&4294901760)===0)G[V++]=Y>>12&15|224,G[V++]=Y>>6&63|128;else G[V++]=Y>>18&7|240,G[V++]=Y>>12&63|128,G[V++]=Y>>6&63|128}G[V++]=Y&63|128}}function yW(W,G,J){TW.encodeInto(W,G.subarray(J))}function i6(W,G,J){if(W.length>AW)yW(W,G,J);else SW(W,G,J)}function g8(W,G,J){let Q=G;const V=Q+J,X=[];let Y="";while(Q<V){const q=W[Q++];if((q&128)===0)X.push(q);else if((q&224)===192){const F=W[Q++]&63;X.push((q&31)<<6|F)}else if((q&240)===224){const F=W[Q++]&63,P=W[Q++]&63;X.push((q&31)<<12|F<<6|P)}else if((q&248)===240){const F=W[Q++]&63,P=W[Q++]&63,U=W[Q++]&63;let C=(q&7)<<18|F<<12|P<<6|U;if(C>65535)C-=65536,X.push(C>>>10&1023|55296),C=56320|C&1023;X.push(C)}else X.push(q);if(X.length>=EW)Y+=String.fromCharCode(...X),X.length=0}if(X.length>0)Y+=String.fromCharCode(...X);return Y}function hW(W,G,J){const Q=W.subarray(G,G+J);return pW.decode(Q)}function r6(W,G,J){if(J>fW)return hW(W,G,J);else return g8(W,G,J)}var TW=new TextEncoder,AW=50,EW=4096,pW=new TextDecoder,fW=200;class W1{constructor(W,G){this.type=W,this.data=G}}class e extends Error{constructor(W){super(W);const G=Object.create(e.prototype);Object.setPrototypeOf(this,G),Object.defineProperty(this,"name",{configurable:!0,enumerable:!1,value:e.name})}}function o6(W,G,J){const Q=J/4294967296,V=J;W.setUint32(G,Q),W.setUint32(G+4,V)}function o1(W,G,J){const Q=Math.floor(J/4294967296),V=J;W.setUint32(G,Q),W.setUint32(G+4,V)}function a1(W,G){const J=W.getInt32(G),Q=W.getUint32(G+4);return J*4294967296+Q}function a6(W,G){const J=W.getUint32(G),Q=W.getUint32(G+4);return J*4294967296+Q}var J1=4294967295;function dW({sec:W,nsec:G}){if(W>=0&&G>=0&&W<=uW)if(G===0&&W<=mW){const J=new Uint8Array(4);return new DataView(J.buffer).setUint32(0,W),J}else{const J=W/4294967296,Q=W&4294967295,V=new Uint8Array(8),X=new DataView(V.buffer);return X.setUint32(0,G<<2|J&3),X.setUint32(4,Q),V}else{const J=new Uint8Array(12),Q=new DataView(J.buffer);return Q.setUint32(0,G),o1(Q,4,W),J}}function cW(W){const G=W.getTime(),J=Math.floor(G/1000),Q=(G-J*1000)*1e6,V=Math.floor(Q/1e9);return{sec:J+V,nsec:Q-V*1e9}}function _W(W){if(W instanceof Date){const G=cW(W);return dW(G)}else return null}function lW(W){const G=new DataView(W.buffer,W.byteOffset,W.byteLength);switch(W.byteLength){case 4:return{sec:G.getUint32(0),nsec:0};case 8:{const J=G.getUint32(0),Q=G.getUint32(4),V=(J&3)*4294967296+Q,X=J>>>2;return{sec:V,nsec:X}}case 12:{const J=a1(G,4),Q=G.getUint32(0);return{sec:J,nsec:Q}}default:throw new e(`Unrecognized data size for timestamp (expected 4, 8, or 12): ${W.length}`)}}function iW(W){const G=lW(W);return new Date(G.sec*1000+G.nsec/1e6)}var bW=-1,mW=4294967295,uW=17179869183,n6={type:bW,encode:_W,decode:iW};class f0{constructor(){this.builtInEncoders=[],this.builtInDecoders=[],this.encoders=[],this.decoders=[],this.register(n6)}register({type:W,encode:G,decode:J}){if(W>=0)this.encoders[W]=G,this.decoders[W]=J;else{const Q=-1-W;this.builtInEncoders[Q]=G,this.builtInDecoders[Q]=J}}tryToEncode(W,G){for(let J=0;J<this.builtInEncoders.length;J++){const Q=this.builtInEncoders[J];if(Q!=null){const V=Q(W,G);if(V!=null){const X=-1-J;return new W1(X,V)}}}for(let J=0;J<this.encoders.length;J++){const Q=this.encoders[J];if(Q!=null){const V=Q(W,G);if(V!=null)return new W1(J,V)}}if(W instanceof W1)return W;return null}decode(W,G,J){const Q=G<0?this.builtInDecoders[-1-G]:this.decoders[G];if(Q)return Q(W,G,J);else return new W1(G,W)}}f0.defaultCodec=new f0;var rW=function(W){return W instanceof ArrayBuffer||typeof SharedArrayBuffer!=="undefined"&&W instanceof SharedArrayBuffer};function M1(W){if(W instanceof Uint8Array)return W;else if(ArrayBuffer.isView(W))return new Uint8Array(W.buffer,W.byteOffset,W.byteLength);else if(rW(W))return new Uint8Array(W);else return Uint8Array.from(W)}var oW=100,aW=2048;class n1{constructor(W){this.entered=!1,this.extensionCodec=W?.extensionCodec??f0.defaultCodec,this.context=W?.context,this.useBigInt64=W?.useBigInt64??!1,this.maxDepth=W?.maxDepth??oW,this.initialBufferSize=W?.initialBufferSize??aW,this.sortKeys=W?.sortKeys??!1,this.forceFloat32=W?.forceFloat32??!1,this.ignoreUndefined=W?.ignoreUndefined??!1,this.forceIntegerToFloat=W?.forceIntegerToFloat??!1,this.pos=0,this.view=new DataView(new ArrayBuffer(this.initialBufferSize)),this.bytes=new Uint8Array(this.view.buffer)}clone(){return new n1({extensionCodec:this.extensionCodec,context:this.context,useBigInt64:this.useBigInt64,maxDepth:this.maxDepth,initialBufferSize:this.initialBufferSize,sortKeys:this.sortKeys,forceFloat32:this.forceFloat32,ignoreUndefined:this.ignoreUndefined,forceIntegerToFloat:this.forceIntegerToFloat})}reinitializeState(){this.pos=0}encodeSharedRef(W){if(this.entered)return this.clone().encodeSharedRef(W);try{return this.entered=!0,this.reinitializeState(),this.doEncode(W,1),this.bytes.subarray(0,this.pos)}finally{this.entered=!1}}encode(W){if(this.entered)return this.clone().encode(W);try{return this.entered=!0,this.reinitializeState(),this.doEncode(W,1),this.bytes.slice(0,this.pos)}finally{this.entered=!1}}doEncode(W,G){if(G>this.maxDepth)throw new Error(`Too deep objects in depth ${G}`);if(W==null)this.encodeNil();else if(typeof W==="boolean")this.encodeBoolean(W);else if(typeof W==="number")if(!this.forceIntegerToFloat)this.encodeNumber(W);else this.encodeNumberAsFloat(W);else if(typeof W==="string")this.encodeString(W);else if(this.useBigInt64&&typeof W==="bigint")this.encodeBigInt64(W);else this.encodeObject(W,G)}ensureBufferSizeToWrite(W){const G=this.pos+W;if(this.view.byteLength<G)this.resizeBuffer(G*2)}resizeBuffer(W){const G=new ArrayBuffer(W),J=new Uint8Array(G),Q=new DataView(G);J.set(this.bytes),this.view=Q,this.bytes=J}encodeNil(){this.writeU8(192)}encodeBoolean(W){if(W===!1)this.writeU8(194);else this.writeU8(195)}encodeNumber(W){if(!this.forceIntegerToFloat&&Number.isSafeInteger(W))if(W>=0)if(W<128)this.writeU8(W);else if(W<256)this.writeU8(204),this.writeU8(W);else if(W<65536)this.writeU8(205),this.writeU16(W);else if(W<4294967296)this.writeU8(206),this.writeU32(W);else if(!this.useBigInt64)this.writeU8(207),this.writeU64(W);else this.encodeNumberAsFloat(W);else if(W>=-32)this.writeU8(224|W+32);else if(W>=-128)this.writeU8(208),this.writeI8(W);else if(W>=-32768)this.writeU8(209),this.writeI16(W);else if(W>=-2147483648)this.writeU8(210),this.writeI32(W);else if(!this.useBigInt64)this.writeU8(211),this.writeI64(W);else this.encodeNumberAsFloat(W);else this.encodeNumberAsFloat(W)}encodeNumberAsFloat(W){if(this.forceFloat32)this.writeU8(202),this.writeF32(W);else this.writeU8(203),this.writeF64(W)}encodeBigInt64(W){if(W>=BigInt(0))this.writeU8(207),this.writeBigUint64(W);else this.writeU8(211),this.writeBigInt64(W)}writeStringHeader(W){if(W<32)this.writeU8(160+W);else if(W<256)this.writeU8(217),this.writeU8(W);else if(W<65536)this.writeU8(218),this.writeU16(W);else if(W<4294967296)this.writeU8(219),this.writeU32(W);else throw new Error(`Too long string: ${W} bytes in UTF-8`)}encodeString(W){const J=l6(W);this.ensureBufferSizeToWrite(5+J),this.writeStringHeader(J),i6(W,this.bytes,this.pos),this.pos+=J}encodeObject(W,G){const J=this.extensionCodec.tryToEncode(W,this.context);if(J!=null)this.encodeExtension(J);else if(Array.isArray(W))this.encodeArray(W,G);else if(ArrayBuffer.isView(W))this.encodeBinary(W);else if(typeof W==="object")this.encodeMap(W,G);else throw new Error(`Unrecognized object: ${Object.prototype.toString.apply(W)}`)}encodeBinary(W){const G=W.byteLength;if(G<256)this.writeU8(196),this.writeU8(G);else if(G<65536)this.writeU8(197),this.writeU16(G);else if(G<4294967296)this.writeU8(198),this.writeU32(G);else throw new Error(`Too large binary: ${G}`);const J=M1(W);this.writeU8a(J)}encodeArray(W,G){const J=W.length;if(J<16)this.writeU8(144+J);else if(J<65536)this.writeU8(220),this.writeU16(J);else if(J<4294967296)this.writeU8(221),this.writeU32(J);else throw new Error(`Too large array: ${J}`);for(let Q of W)this.doEncode(Q,G+1)}countWithoutUndefined(W,G){let J=0;for(let Q of G)if(W[Q]!==void 0)J++;return J}encodeMap(W,G){const J=Object.keys(W);if(this.sortKeys)J.sort();const Q=this.ignoreUndefined?this.countWithoutUndefined(W,J):J.length;if(Q<16)this.writeU8(128+Q);else if(Q<65536)this.writeU8(222),this.writeU16(Q);else if(Q<4294967296)this.writeU8(223),this.writeU32(Q);else throw new Error(`Too large map object: ${Q}`);for(let V of J){const X=W[V];if(!(this.ignoreUndefined&&X===void 0))this.encodeString(V),this.doEncode(X,G+1)}}encodeExtension(W){if(typeof W.data==="function"){const J=W.data(this.pos+6),Q=J.length;if(Q>=4294967296)throw new Error(`Too large extension object: ${Q}`);this.writeU8(201),this.writeU32(Q),this.writeI8(W.type),this.writeU8a(J);return}const G=W.data.length;if(G===1)this.writeU8(212);else if(G===2)this.writeU8(213);else if(G===4)this.writeU8(214);else if(G===8)this.writeU8(215);else if(G===16)this.writeU8(216);else if(G<256)this.writeU8(199),this.writeU8(G);else if(G<65536)this.writeU8(200),this.writeU16(G);else if(G<4294967296)this.writeU8(201),this.writeU32(G);else throw new Error(`Too large extension object: ${G}`);this.writeI8(W.type),this.writeU8a(W.data)}writeU8(W){this.ensureBufferSizeToWrite(1),this.view.setUint8(this.pos,W),this.pos++}writeU8a(W){const G=W.length;this.ensureBufferSizeToWrite(G),this.bytes.set(W,this.pos),this.pos+=G}writeI8(W){this.ensureBufferSizeToWrite(1),this.view.setInt8(this.pos,W),this.pos++}writeU16(W){this.ensureBufferSizeToWrite(2),this.view.setUint16(this.pos,W),this.pos+=2}writeI16(W){this.ensureBufferSizeToWrite(2),this.view.setInt16(this.pos,W),this.pos+=2}writeU32(W){this.ensureBufferSizeToWrite(4),this.view.setUint32(this.pos,W),this.pos+=4}writeI32(W){this.ensureBufferSizeToWrite(4),this.view.setInt32(this.pos,W),this.pos+=4}writeF32(W){this.ensureBufferSizeToWrite(4),this.view.setFloat32(this.pos,W),this.pos+=4}writeF64(W){this.ensureBufferSizeToWrite(8),this.view.setFloat64(this.pos,W),this.pos+=8}writeU64(W){this.ensureBufferSizeToWrite(8),o6(this.view,this.pos,W),this.pos+=8}writeI64(W){this.ensureBufferSizeToWrite(8),o1(this.view,this.pos,W),this.pos+=8}writeBigUint64(W){this.ensureBufferSizeToWrite(8),this.view.setBigUint64(this.pos,W),this.pos+=8}writeBigInt64(W){this.ensureBufferSizeToWrite(8),this.view.setBigInt64(this.pos,W),this.pos+=8}}function v0(W,G){return new n1(G).encodeSharedRef(W)}function s1(W){return`${W<0?"-":""}0x${Math.abs(W).toString(16).padStart(2,"0")}`}var nW=16,sW=16;class S8{constructor(W=nW,G=sW){this.hit=0,this.miss=0,this.maxKeyLength=W,this.maxLengthPerKey=G,this.caches=[];for(let J=0;J<this.maxKeyLength;J++)this.caches.push([])}canBeCached(W){return W>0&&W<=this.maxKeyLength}find(W,G,J){const Q=this.caches[J-1];W:for(let V of Q){const X=V.bytes;for(let Y=0;Y<J;Y++)if(X[Y]!==W[G+Y])continue W;return V.str}return null}store(W,G){const J=this.caches[W.length-1],Q={bytes:W,str:G};if(J.length>=this.maxLengthPerKey)J[Math.random()*J.length|0]=Q;else J.push(Q)}decode(W,G,J){const Q=this.find(W,G,J);if(Q!=null)return this.hit++,Q;this.miss++;const V=g8(W,G,J),X=Uint8Array.prototype.slice.call(W,G,G+J);return this.store(X,V),V}}var T8="array",L1="map_key",e6="map_value",eW=(W)=>{if(typeof W==="string"||typeof W==="number")return W;throw new e("The type of key must be string or number but "+typeof W)};class t6{constructor(){this.stack=[],this.stackHeadPosition=-1}get length(){return this.stackHeadPosition+1}top(){return this.stack[this.stackHeadPosition]}pushArrayState(W){const G=this.getUninitializedStateFromPool();G.type=T8,G.position=0,G.size=W,G.array=new Array(W)}pushMapState(W){const G=this.getUninitializedStateFromPool();G.type=L1,G.readCount=0,G.size=W,G.map={}}getUninitializedStateFromPool(){if(this.stackHeadPosition++,this.stackHeadPosition===this.stack.length){const W={type:void 0,size:0,array:void 0,position:0,readCount:0,map:void 0,key:null};this.stack.push(W)}return this.stack[this.stackHeadPosition]}release(W){if(this.stack[this.stackHeadPosition]!==W)throw new Error("Invalid stack state. Released state is not on top of the stack.");if(W.type===T8){const J=W;J.size=0,J.array=void 0,J.position=0,J.type=void 0}if(W.type===L1||W.type===e6){const J=W;J.size=0,J.map=void 0,J.readCount=0,J.type=void 0}this.stackHeadPosition--}reset(){this.stack.length=0,this.stackHeadPosition=-1}}var R1=-1,A8=new DataView(new ArrayBuffer(0)),tW=new Uint8Array(A8.buffer);try{A8.getInt8(0)}catch(W){if(!(W instanceof RangeError))throw new Error("This module is not supported in the current JavaScript engine because DataView does not throw RangeError on out-of-bounds access")}var s6=new RangeError("Insufficient data"),WJ=new S8;class e1{constructor(W){this.totalPos=0,this.pos=0,this.view=A8,this.bytes=tW,this.headByte=R1,this.stack=new t6,this.entered=!1,this.extensionCodec=W?.extensionCodec??f0.defaultCodec,this.context=W?.context,this.useBigInt64=W?.useBigInt64??!1,this.rawStrings=W?.rawStrings??!1,this.maxStrLength=W?.maxStrLength??J1,this.maxBinLength=W?.maxBinLength??J1,this.maxArrayLength=W?.maxArrayLength??J1,this.maxMapLength=W?.maxMapLength??J1,this.maxExtLength=W?.maxExtLength??J1,this.keyDecoder=W?.keyDecoder!==void 0?W.keyDecoder:WJ,this.mapKeyConverter=W?.mapKeyConverter??eW}clone(){return new e1({extensionCodec:this.extensionCodec,context:this.context,useBigInt64:this.useBigInt64,rawStrings:this.rawStrings,maxStrLength:this.maxStrLength,maxBinLength:this.maxBinLength,maxArrayLength:this.maxArrayLength,maxMapLength:this.maxMapLength,maxExtLength:this.maxExtLength,keyDecoder:this.keyDecoder})}reinitializeState(){this.totalPos=0,this.headByte=R1,this.stack.reset()}setBuffer(W){const G=M1(W);this.bytes=G,this.view=new DataView(G.buffer,G.byteOffset,G.byteLength),this.pos=0}appendBuffer(W){if(this.headByte===R1&&!this.hasRemaining(1))this.setBuffer(W);else{const G=this.bytes.subarray(this.pos),J=M1(W),Q=new Uint8Array(G.length+J.length);Q.set(G),Q.set(J,G.length),this.setBuffer(Q)}}hasRemaining(W){return this.view.byteLength-this.pos>=W}createExtraByteError(W){const{view:G,pos:J}=this;return new RangeError(`Extra ${G.byteLength-J} of ${G.byteLength} byte(s) found at buffer[${W}]`)}decode(W){if(this.entered)return this.clone().decode(W);try{this.entered=!0,this.reinitializeState(),this.setBuffer(W);const G=this.doDecodeSync();if(this.hasRemaining(1))throw this.createExtraByteError(this.pos);return G}finally{this.entered=!1}}*decodeMulti(W){if(this.entered){yield*this.clone().decodeMulti(W);return}try{this.entered=!0,this.reinitializeState(),this.setBuffer(W);while(this.hasRemaining(1))yield this.doDecodeSync()}finally{this.entered=!1}}async decodeAsync(W){if(this.entered)return this.clone().decodeAsync(W);try{this.entered=!0;let G=!1,J;for await(let Y of W){if(G)throw this.entered=!1,this.createExtraByteError(this.totalPos);this.appendBuffer(Y);try{J=this.doDecodeSync(),G=!0}catch(q){if(!(q instanceof RangeError))throw q}this.totalPos+=this.pos}if(G){if(this.hasRemaining(1))throw this.createExtraByteError(this.totalPos);return J}const{headByte:Q,pos:V,totalPos:X}=this;throw new RangeError(`Insufficient data in parsing ${s1(Q)} at ${X} (${V} in the current buffer)`)}finally{this.entered=!1}}decodeArrayStream(W){return this.decodeMultiAsync(W,!0)}decodeStream(W){return this.decodeMultiAsync(W,!1)}async*decodeMultiAsync(W,G){if(this.entered){yield*this.clone().decodeMultiAsync(W,G);return}try{this.entered=!0;let J=G,Q=-1;for await(let V of W){if(G&&Q===0)throw this.createExtraByteError(this.totalPos);if(this.appendBuffer(V),J)Q=this.readArraySize(),J=!1,this.complete();try{while(!0)if(yield this.doDecodeSync(),--Q===0)break}catch(X){if(!(X instanceof RangeError))throw X}this.totalPos+=this.pos}}finally{this.entered=!1}}doDecodeSync(){W:while(!0){const W=this.readHeadByte();let G;if(W>=224)G=W-256;else if(W<192)if(W<128)G=W;else if(W<144){const Q=W-128;if(Q!==0){this.pushMapState(Q),this.complete();continue W}else G={}}else if(W<160){const Q=W-144;if(Q!==0){this.pushArrayState(Q),this.complete();continue W}else G=[]}else{const Q=W-160;G=this.decodeString(Q,0)}else if(W===192)G=null;else if(W===194)G=!1;else if(W===195)G=!0;else if(W===202)G=this.readF32();else if(W===203)G=this.readF64();else if(W===204)G=this.readU8();else if(W===205)G=this.readU16();else if(W===206)G=this.readU32();else if(W===207)if(this.useBigInt64)G=this.readU64AsBigInt();else G=this.readU64();else if(W===208)G=this.readI8();else if(W===209)G=this.readI16();else if(W===210)G=this.readI32();else if(W===211)if(this.useBigInt64)G=this.readI64AsBigInt();else G=this.readI64();else if(W===217){const Q=this.lookU8();G=this.decodeString(Q,1)}else if(W===218){const Q=this.lookU16();G=this.decodeString(Q,2)}else if(W===219){const Q=this.lookU32();G=this.decodeString(Q,4)}else if(W===220){const Q=this.readU16();if(Q!==0){this.pushArrayState(Q),this.complete();continue W}else G=[]}else if(W===221){const Q=this.readU32();if(Q!==0){this.pushArrayState(Q),this.complete();continue W}else G=[]}else if(W===222){const Q=this.readU16();if(Q!==0){this.pushMapState(Q),this.complete();continue W}else G={}}else if(W===223){const Q=this.readU32();if(Q!==0){this.pushMapState(Q),this.complete();continue W}else G={}}else if(W===196){const Q=this.lookU8();G=this.decodeBinary(Q,1)}else if(W===197){const Q=this.lookU16();G=this.decodeBinary(Q,2)}else if(W===198){const Q=this.lookU32();G=this.decodeBinary(Q,4)}else if(W===212)G=this.decodeExtension(1,0);else if(W===213)G=this.decodeExtension(2,0);else if(W===214)G=this.decodeExtension(4,0);else if(W===215)G=this.decodeExtension(8,0);else if(W===216)G=this.decodeExtension(16,0);else if(W===199){const Q=this.lookU8();G=this.decodeExtension(Q,1)}else if(W===200){const Q=this.lookU16();G=this.decodeExtension(Q,2)}else if(W===201){const Q=this.lookU32();G=this.decodeExtension(Q,4)}else throw new e(`Unrecognized type byte: ${s1(W)}`);this.complete();const J=this.stack;while(J.length>0){const Q=J.top();if(Q.type===T8)if(Q.array[Q.position]=G,Q.position++,Q.position===Q.size)G=Q.array,J.release(Q);else continue W;else if(Q.type===L1){if(G==="__proto__")throw new e("The key __proto__ is not allowed");Q.key=this.mapKeyConverter(G),Q.type=e6;continue W}else if(Q.map[Q.key]=G,Q.readCount++,Q.readCount===Q.size)G=Q.map,J.release(Q);else{Q.key=null,Q.type=L1;continue W}}return G}}readHeadByte(){if(this.headByte===R1)this.headByte=this.readU8();return this.headByte}complete(){this.headByte=R1}readArraySize(){const W=this.readHeadByte();switch(W){case 220:return this.readU16();case 221:return this.readU32();default:if(W<160)return W-144;else throw new e(`Unrecognized array type byte: ${s1(W)}`)}}pushMapState(W){if(W>this.maxMapLength)throw new e(`Max length exceeded: map length (${W}) > maxMapLengthLength (${this.maxMapLength})`);this.stack.pushMapState(W)}pushArrayState(W){if(W>this.maxArrayLength)throw new e(`Max length exceeded: array length (${W}) > maxArrayLength (${this.maxArrayLength})`);this.stack.pushArrayState(W)}decodeString(W,G){if(!this.rawStrings||this.stateIsMapKey())return this.decodeUtf8String(W,G);return this.decodeBinary(W,G)}decodeUtf8String(W,G){if(W>this.maxStrLength)throw new e(`Max length exceeded: UTF-8 byte length (${W}) > maxStrLength (${this.maxStrLength})`);if(this.bytes.byteLength<this.pos+G+W)throw s6;const J=this.pos+G;let Q;if(this.stateIsMapKey()&&this.keyDecoder?.canBeCached(W))Q=this.keyDecoder.decode(this.bytes,J,W);else Q=r6(this.bytes,J,W);return this.pos+=G+W,Q}stateIsMapKey(){if(this.stack.length>0)return this.stack.top().type===L1;return!1}decodeBinary(W,G){if(W>this.maxBinLength)throw new e(`Max length exceeded: bin length (${W}) > maxBinLength (${this.maxBinLength})`);if(!this.hasRemaining(W+G))throw s6;const J=this.pos+G,Q=this.bytes.subarray(J,J+W);return this.pos+=G+W,Q}decodeExtension(W,G){if(W>this.maxExtLength)throw new e(`Max length exceeded: ext length (${W}) > maxExtLength (${this.maxExtLength})`);const J=this.view.getInt8(this.pos+G),Q=this.decodeBinary(W,G+1);return this.extensionCodec.decode(Q,J,this.context)}lookU8(){return this.view.getUint8(this.pos)}lookU16(){return this.view.getUint16(this.pos)}lookU32(){return this.view.getUint32(this.pos)}readU8(){const W=this.view.getUint8(this.pos);return this.pos++,W}readI8(){const W=this.view.getInt8(this.pos);return this.pos++,W}readU16(){const W=this.view.getUint16(this.pos);return this.pos+=2,W}readI16(){const W=this.view.getInt16(this.pos);return this.pos+=2,W}readU32(){const W=this.view.getUint32(this.pos);return this.pos+=4,W}readI32(){const W=this.view.getInt32(this.pos);return this.pos+=4,W}readU64(){const W=a6(this.view,this.pos);return this.pos+=8,W}readI64(){const W=a1(this.view,this.pos);return this.pos+=8,W}readU64AsBigInt(){const W=this.view.getBigUint64(this.pos);return this.pos+=8,W}readI64AsBigInt(){const W=this.view.getBigInt64(this.pos);return this.pos+=8,W}readF32(){const W=this.view.getFloat32(this.pos);return this.pos+=4,W}readF64(){const W=this.view.getFloat64(this.pos);return this.pos+=8,W}}function t1(W,G){return new e1(G).decode(W)}var q1=function(W){let G=W.length;while(--G>=0)W[G]=0},E8=function(W,G,J,Q,V){this.static_tree=W,this.extra_bits=G,this.extra_base=J,this.elems=Q,this.max_length=V,this.has_stree=W&&W.length},p8=function(W,G){this.dyn_tree=W,this.max_code=0,this.stat_desc=G},k0=function(W,G,J,Q,V){this.good_length=W,this.max_lazy=G,this.nice_length=J,this.max_chain=Q,this.func=V},G9=function(){this.strm=null,this.status=0,this.pending_buf=null,this.pending_buf_size=0,this.pending_out=0,this.pending=0,this.wrap=0,this.gzhead=null,this.gzindex=0,this.method=U8,this.last_flush=-1,this.w_size=0,this.w_bits=0,this.w_mask=0,this.window=null,this.window_size=0,this.prev=null,this.head=null,this.ins_h=0,this.hash_size=0,this.hash_bits=0,this.hash_mask=0,this.hash_shift=0,this.block_start=0,this.match_length=0,this.prev_match=0,this.match_available=0,this.strstart=0,this.match_start=0,this.lookahead=0,this.prev_length=0,this.max_chain_length=0,this.max_lazy_match=0,this.level=0,this.strategy=0,this.good_match=0,this.nice_match=0,this.dyn_ltree=new Uint16Array(rJ*2),this.dyn_dtree=new Uint16Array((2*lJ+1)*2),this.bl_tree=new Uint16Array((2*iJ+1)*2),g0(this.dyn_ltree),g0(this.dyn_dtree),g0(this.bl_tree),this.l_desc=null,this.d_desc=null,this.bl_desc=null,this.bl_count=new Uint16Array(oJ+1),this.heap=new Uint16Array(2*s8+1),g0(this.heap),this.heap_len=0,this.heap_max=0,this.depth=new Uint16Array(2*s8+1),g0(this.depth),this.sym_buf=0,this.lit_bufsize=0,this.sym_next=0,this.sym_end=0,this.opt_len=0,this.static_len=0,this.matches=0,this.insert=0,this.bi_buf=0,this.bi_valid=0},I9=function(){this.input=null,this.next_in=0,this.avail_in=0,this.total_in=0,this.output=null,this.next_out=0,this.avail_out=0,this.total_out=0,this.msg="",this.state=null,this.data_type=2,this.adler=0},b1=function(W){this.options=F8.assign({level:g9,method:T9,chunkSize:16384,windowBits:15,memLevel:8,strategy:S9},W||{});let G=this.options;if(G.raw&&G.windowBits>0)G.windowBits=-G.windowBits;else if(G.gzip&&G.windowBits>0&&G.windowBits<16)G.windowBits+=16;this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new X7,this.strm.avail_out=0;let J=w1.deflateInit2(this.strm,G.level,G.method,G.windowBits,G.memLevel,G.strategy);if(J!==q8)throw new Error(u0[J]);if(G.header)w1.deflateSetHeader(this.strm,G.header);if(G.dictionary){let Q;if(typeof G.dictionary==="string")Q=E1.string2buf(G.dictionary);else if(Y7.call(G.dictionary)==="[object ArrayBuffer]")Q=new Uint8Array(G.dictionary);else Q=G.dictionary;if(J=w1.deflateSetDictionary(this.strm,Q),J!==q8)throw new Error(u0[J]);this._dict_set=!0}},P6=function(W,G){const J=new b1(G);if(J.push(W,!0),J.err)throw J.msg||u0[J.err];return J.result},A9=function(W,G){return G=G||{},G.raw=!0,P6(W,G)},y9=function(W,G){return G=G||{},G.gzip=!0,P6(W,G)},QG=function(){this.strm=null,this.mode=0,this.last=!1,this.wrap=0,this.havedict=!1,this.flags=0,this.dmax=0,this.check=0,this.total=0,this.head=null,this.wbits=0,this.wsize=0,this.whave=0,this.wnext=0,this.window=null,this.hold=0,this.bits=0,this.length=0,this.offset=0,this.extra=0,this.lencode=null,this.distcode=null,this.lenbits=0,this.distbits=0,this.ncode=0,this.nlen=0,this.ndist=0,this.have=0,this.next=null,this.lens=new Uint16Array(320),this.work=new Uint16Array(288),this.lendyn=null,this.distdyn=null,this.sane=0,this.back=0,this.was=0},MG=function(){this.text=0,this.time=0,this.xflags=0,this.os=0,this.extra=null,this.extra_len=0,this.name="",this.comment="",this.hcrc=0,this.done=!1},m1=function(W){this.options=F8.assign({chunkSize:65536,windowBits:15,to:""},W||{});const G=this.options;if(G.raw&&G.windowBits>=0&&G.windowBits<16){if(G.windowBits=-G.windowBits,G.windowBits===0)G.windowBits=-15}if(G.windowBits>=0&&G.windowBits<16&&!(W&&W.windowBits))G.windowBits+=32;if(G.windowBits>15&&G.windowBits<48){if((G.windowBits&15)===0)G.windowBits|=15}this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new X7,this.strm.avail_out=0;let J=O0.inflateInit2(this.strm,G.windowBits);if(J!==p1)throw new Error(u0[J]);if(this.header=new RG,O0.inflateGetHeader(this.strm,this.header),G.dictionary){if(typeof G.dictionary==="string")G.dictionary=E1.string2buf(G.dictionary);else if(j7.call(G.dictionary)==="[object ArrayBuffer]")G.dictionary=new Uint8Array(G.dictionary);if(G.raw){if(J=O0.inflateSetDictionary(this.strm,G.dictionary),J!==p1)throw new Error(u0[J])}}},U6=function(W,G){const J=new m1(G);if(J.push(W),J.err)throw J.msg||u0[J.err];return J.result},xG=function(W,G){return G=G||{},G.raw=!0,U6(W,G)};/*! pako 2.1.0 https://github.com/nodeca/pako @license (MIT AND Zlib) */var JJ=0,h5=1,GJ=2,QJ=3,VJ=258,Q6=29,f1=256,v1=f1+1+Q6,V1=30,V6=19,b5=2*v1+1,h0=15,y8=16,XJ=7,X6=256,m5=16,u5=17,d5=18,o8=new Uint8Array([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0]),X8=new Uint8Array([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13]),YJ=new Uint8Array([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7]),c5=new Uint8Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),qJ=512,L0=new Array((v1+2)*2);q1(L0);var x1=new Array(V1*2);q1(x1);var g1=new Array(qJ);q1(g1);var S1=new Array(VJ-QJ+1);q1(S1);var Y6=new Array(Q6);q1(Y6);var Y8=new Array(V1);q1(Y8);var _5,l5,i5,r5=(W)=>{return W<256?g1[W]:g1[256+(W>>>7)]},T1=(W,G)=>{W.pending_buf[W.pending++]=G&255,W.pending_buf[W.pending++]=G>>>8&255},Q0=(W,G,J)=>{if(W.bi_valid>y8-J)W.bi_buf|=G<<W.bi_valid&65535,T1(W,W.bi_buf),W.bi_buf=G>>y8-W.bi_valid,W.bi_valid+=J-y8;else W.bi_buf|=G<<W.bi_valid&65535,W.bi_valid+=J},H0=(W,G,J)=>{Q0(W,J[G*2],J[G*2+1])},o5=(W,G)=>{let J=0;do J|=W&1,W>>>=1,J<<=1;while(--G>0);return J>>>1},PJ=(W)=>{if(W.bi_valid===16)T1(W,W.bi_buf),W.bi_buf=0,W.bi_valid=0;else if(W.bi_valid>=8)W.pending_buf[W.pending++]=W.bi_buf&255,W.bi_buf>>=8,W.bi_valid-=8},UJ=(W,G)=>{const{dyn_tree:J,max_code:Q}=G,V=G.stat_desc.static_tree,X=G.stat_desc.has_stree,Y=G.stat_desc.extra_bits,q=G.stat_desc.extra_base,F=G.stat_desc.max_length;let P,U,C,K,z,$,N=0;for(K=0;K<=h0;K++)W.bl_count[K]=0;J[W.heap[W.heap_max]*2+1]=0;for(P=W.heap_max+1;P<b5;P++){if(U=W.heap[P],K=J[J[U*2+1]*2+1]+1,K>F)K=F,N++;if(J[U*2+1]=K,U>Q)continue;if(W.bl_count[K]++,z=0,U>=q)z=Y[U-q];if($=J[U*2],W.opt_len+=$*(K+z),X)W.static_len+=$*(V[U*2+1]+z)}if(N===0)return;do{K=F-1;while(W.bl_count[K]===0)K--;W.bl_count[K]--,W.bl_count[K+1]+=2,W.bl_count[F]--,N-=2}while(N>0);for(K=F;K!==0;K--){U=W.bl_count[K];while(U!==0){if(C=W.heap[--P],C>Q)continue;if(J[C*2+1]!==K)W.opt_len+=(K-J[C*2+1])*J[C*2],J[C*2+1]=K;U--}}},a5=(W,G,J)=>{const Q=new Array(h0+1);let V=0,X,Y;for(X=1;X<=h0;X++)V=V+J[X-1]<<1,Q[X]=V;for(Y=0;Y<=G;Y++){let q=W[Y*2+1];if(q===0)continue;W[Y*2]=o5(Q[q]++,q)}},FJ=()=>{let W,G,J,Q,V;const X=new Array(h0+1);J=0;for(Q=0;Q<Q6-1;Q++){Y6[Q]=J;for(W=0;W<1<<o8[Q];W++)S1[J++]=Q}S1[J-1]=Q,V=0;for(Q=0;Q<16;Q++){Y8[Q]=V;for(W=0;W<1<<X8[Q];W++)g1[V++]=Q}V>>=7;for(;Q<V1;Q++){Y8[Q]=V<<7;for(W=0;W<1<<X8[Q]-7;W++)g1[256+V++]=Q}for(G=0;G<=h0;G++)X[G]=0;W=0;while(W<=143)L0[W*2+1]=8,W++,X[8]++;while(W<=255)L0[W*2+1]=9,W++,X[9]++;while(W<=279)L0[W*2+1]=7,W++,X[7]++;while(W<=287)L0[W*2+1]=8,W++,X[8]++;a5(L0,v1+1,X);for(W=0;W<V1;W++)x1[W*2+1]=5,x1[W*2]=o5(W,5);_5=new E8(L0,o8,f1+1,v1,h0),l5=new E8(x1,X8,0,V1,h0),i5=new E8(new Array(0),YJ,0,V6,XJ)},n5=(W)=>{let G;for(G=0;G<v1;G++)W.dyn_ltree[G*2]=0;for(G=0;G<V1;G++)W.dyn_dtree[G*2]=0;for(G=0;G<V6;G++)W.bl_tree[G*2]=0;W.dyn_ltree[X6*2]=1,W.opt_len=W.static_len=0,W.sym_next=W.matches=0},s5=(W)=>{if(W.bi_valid>8)T1(W,W.bi_buf);else if(W.bi_valid>0)W.pending_buf[W.pending++]=W.bi_buf;W.bi_buf=0,W.bi_valid=0},W5=(W,G,J,Q)=>{const V=G*2,X=J*2;return W[V]<W[X]||W[V]===W[X]&&Q[G]<=Q[J]},f8=(W,G,J)=>{const Q=W.heap[J];let V=J<<1;while(V<=W.heap_len){if(V<W.heap_len&&W5(G,W.heap[V+1],W.heap[V],W.depth))V++;if(W5(G,Q,W.heap[V],W.depth))break;W.heap[J]=W.heap[V],J=V,V<<=1}W.heap[J]=Q},J5=(W,G,J)=>{let Q,V,X=0,Y,q;if(W.sym_next!==0)do if(Q=W.pending_buf[W.sym_buf+X++]&255,Q+=(W.pending_buf[W.sym_buf+X++]&255)<<8,V=W.pending_buf[W.sym_buf+X++],Q===0)H0(W,V,G);else{if(Y=S1[V],H0(W,Y+f1+1,G),q=o8[Y],q!==0)V-=Y6[Y],Q0(W,V,q);if(Q--,Y=r5(Q),H0(W,Y,J),q=X8[Y],q!==0)Q-=Y8[Y],Q0(W,Q,q)}while(X<W.sym_next);H0(W,X6,G)},a8=(W,G)=>{const J=G.dyn_tree,Q=G.stat_desc.static_tree,V=G.stat_desc.has_stree,X=G.stat_desc.elems;let Y,q,F=-1,P;W.heap_len=0,W.heap_max=b5;for(Y=0;Y<X;Y++)if(J[Y*2]!==0)W.heap[++W.heap_len]=F=Y,W.depth[Y]=0;else J[Y*2+1]=0;while(W.heap_len<2)if(P=W.heap[++W.heap_len]=F<2?++F:0,J[P*2]=1,W.depth[P]=0,W.opt_len--,V)W.static_len-=Q[P*2+1];G.max_code=F;for(Y=W.heap_len>>1;Y>=1;Y--)f8(W,J,Y);P=X;do Y=W.heap[1],W.heap[1]=W.heap[W.heap_len--],f8(W,J,1),q=W.heap[1],W.heap[--W.heap_max]=Y,W.heap[--W.heap_max]=q,J[P*2]=J[Y*2]+J[q*2],W.depth[P]=(W.depth[Y]>=W.depth[q]?W.depth[Y]:W.depth[q])+1,J[Y*2+1]=J[q*2+1]=P,W.heap[1]=P++,f8(W,J,1);while(W.heap_len>=2);W.heap[--W.heap_max]=W.heap[1],UJ(W,G),a5(J,F,W.bl_count)},G5=(W,G,J)=>{let Q,V=-1,X,Y=G[1],q=0,F=7,P=4;if(Y===0)F=138,P=3;G[(J+1)*2+1]=65535;for(Q=0;Q<=J;Q++){if(X=Y,Y=G[(Q+1)*2+1],++q<F&&X===Y)continue;else if(q<P)W.bl_tree[X*2]+=q;else if(X!==0){if(X!==V)W.bl_tree[X*2]++;W.bl_tree[m5*2]++}else if(q<=10)W.bl_tree[u5*2]++;else W.bl_tree[d5*2]++;if(q=0,V=X,Y===0)F=138,P=3;else if(X===Y)F=6,P=3;else F=7,P=4}},Q5=(W,G,J)=>{let Q,V=-1,X,Y=G[1],q=0,F=7,P=4;if(Y===0)F=138,P=3;for(Q=0;Q<=J;Q++){if(X=Y,Y=G[(Q+1)*2+1],++q<F&&X===Y)continue;else if(q<P)do H0(W,X,W.bl_tree);while(--q!==0);else if(X!==0){if(X!==V)H0(W,X,W.bl_tree),q--;H0(W,m5,W.bl_tree),Q0(W,q-3,2)}else if(q<=10)H0(W,u5,W.bl_tree),Q0(W,q-3,3);else H0(W,d5,W.bl_tree),Q0(W,q-11,7);if(q=0,V=X,Y===0)F=138,P=3;else if(X===Y)F=6,P=3;else F=7,P=4}},KJ=(W)=>{let G;G5(W,W.dyn_ltree,W.l_desc.max_code),G5(W,W.dyn_dtree,W.d_desc.max_code),a8(W,W.bl_desc);for(G=V6-1;G>=3;G--)if(W.bl_tree[c5[G]*2+1]!==0)break;return W.opt_len+=3*(G+1)+5+5+4,G},zJ=(W,G,J,Q)=>{let V;Q0(W,G-257,5),Q0(W,J-1,5),Q0(W,Q-4,4);for(V=0;V<Q;V++)Q0(W,W.bl_tree[c5[V]*2+1],3);Q5(W,W.dyn_ltree,G-1),Q5(W,W.dyn_dtree,J-1)},ZJ=(W)=>{let G=4093624447,J;for(J=0;J<=31;J++,G>>>=1)if(G&1&&W.dyn_ltree[J*2]!==0)return 0;if(W.dyn_ltree[18]!==0||W.dyn_ltree[20]!==0||W.dyn_ltree[26]!==0)return 1;for(J=32;J<f1;J++)if(W.dyn_ltree[J*2]!==0)return 1;return 0},V5=!1,kJ=(W)=>{if(!V5)FJ(),V5=!0;W.l_desc=new p8(W.dyn_ltree,_5),W.d_desc=new p8(W.dyn_dtree,l5),W.bl_desc=new p8(W.bl_tree,i5),W.bi_buf=0,W.bi_valid=0,n5(W)},e5=(W,G,J,Q)=>{if(Q0(W,(JJ<<1)+(Q?1:0),3),s5(W),T1(W,J),T1(W,~J),J)W.pending_buf.set(W.window.subarray(G,G+J),W.pending);W.pending+=J},HJ=(W)=>{Q0(W,h5<<1,3),H0(W,X6,L0),PJ(W)},CJ=(W,G,J,Q)=>{let V,X,Y=0;if(W.level>0){if(W.strm.data_type===2)W.strm.data_type=ZJ(W);if(a8(W,W.l_desc),a8(W,W.d_desc),Y=KJ(W),V=W.opt_len+3+7>>>3,X=W.static_len+3+7>>>3,X<=V)V=X}else V=X=J+5;if(J+4<=V&&G!==-1)e5(W,G,J,Q);else if(W.strategy===4||X===V)Q0(W,(h5<<1)+(Q?1:0),3),J5(W,L0,x1);else Q0(W,(GJ<<1)+(Q?1:0),3),zJ(W,W.l_desc.max_code+1,W.d_desc.max_code+1,Y+1),J5(W,W.dyn_ltree,W.dyn_dtree);if(n5(W),Q)s5(W)},$J=(W,G,J)=>{if(W.pending_buf[W.sym_buf+W.sym_next++]=G,W.pending_buf[W.sym_buf+W.sym_next++]=G>>8,W.pending_buf[W.sym_buf+W.sym_next++]=J,G===0)W.dyn_ltree[J*2]++;else W.matches++,G--,W.dyn_ltree[(S1[J]+f1+1)*2]++,W.dyn_dtree[r5(G)*2]++;return W.sym_next===W.sym_end},jJ=kJ,BJ=e5,MJ=CJ,RJ=$J,LJ=HJ,OJ={_tr_init:jJ,_tr_stored_block:BJ,_tr_flush_block:MJ,_tr_tally:RJ,_tr_align:LJ},IJ=(W,G,J,Q)=>{let V=W&65535|0,X=W>>>16&65535|0,Y=0;while(J!==0){Y=J>2000?2000:J,J-=Y;do V=V+G[Q++]|0,X=X+V|0;while(--Y);V%=65521,X%=65521}return V|X<<16|0},A1=IJ,DJ=()=>{let W,G=[];for(var J=0;J<256;J++){W=J;for(var Q=0;Q<8;Q++)W=W&1?3988292384^W>>>1:W>>>1;G[J]=W}return G},xJ=new Uint32Array(DJ()),wJ=(W,G,J,Q)=>{const V=xJ,X=Q+J;W^=-1;for(let Y=Q;Y<X;Y++)W=W>>>8^V[(W^G[Y])&255];return W^-1},o=wJ,u0={2:"need dictionary",1:"stream end",0:"","-1":"file error","-2":"stream error","-3":"data error","-4":"insufficient memory","-5":"buffer error","-6":"incompatible version"},_0={Z_NO_FLUSH:0,Z_PARTIAL_FLUSH:1,Z_SYNC_FLUSH:2,Z_FULL_FLUSH:3,Z_FINISH:4,Z_BLOCK:5,Z_TREES:6,Z_OK:0,Z_STREAM_END:1,Z_NEED_DICT:2,Z_ERRNO:-1,Z_STREAM_ERROR:-2,Z_DATA_ERROR:-3,Z_MEM_ERROR:-4,Z_BUF_ERROR:-5,Z_NO_COMPRESSION:0,Z_BEST_SPEED:1,Z_BEST_COMPRESSION:9,Z_DEFAULT_COMPRESSION:-1,Z_FILTERED:1,Z_HUFFMAN_ONLY:2,Z_RLE:3,Z_FIXED:4,Z_DEFAULT_STRATEGY:0,Z_BINARY:0,Z_TEXT:1,Z_UNKNOWN:2,Z_DEFLATED:8},{_tr_init:NJ,_tr_stored_block:n8,_tr_flush_block:vJ,_tr_tally:T0,_tr_align:gJ}=OJ,{Z_NO_FLUSH:A0,Z_PARTIAL_FLUSH:SJ,Z_FULL_FLUSH:TJ,Z_FINISH:F0,Z_BLOCK:X5,Z_OK:a,Z_STREAM_END:Y5,Z_STREAM_ERROR:C0,Z_DATA_ERROR:AJ,Z_BUF_ERROR:h8,Z_DEFAULT_COMPRESSION:yJ,Z_FILTERED:EJ,Z_HUFFMAN_ONLY:W8,Z_RLE:pJ,Z_FIXED:fJ,Z_DEFAULT_STRATEGY:hJ,Z_UNKNOWN:bJ,Z_DEFLATED:U8}=_0,mJ=9,uJ=15,dJ=8,cJ=29,_J=256,s8=_J+1+cJ,lJ=30,iJ=19,rJ=2*s8+1,oJ=15,u=3,S0=258,$0=S0+u+1,aJ=32,X1=42,q6=57,e8=69,t8=73,W6=91,J6=103,b0=113,I1=666,t=1,P1=2,d0=3,U1=4,nJ=3,m0=(W,G)=>{return W.msg=u0[G],G},q5=(W)=>{return W*2-(W>4?9:0)},g0=(W)=>{let G=W.length;while(--G>=0)W[G]=0},sJ=(W)=>{let G,J,Q,V=W.w_size;G=W.hash_size,Q=G;do J=W.head[--Q],W.head[Q]=J>=V?J-V:0;while(--G);G=V,Q=G;do J=W.prev[--Q],W.prev[Q]=J>=V?J-V:0;while(--G)},eJ=(W,G,J)=>(G<<W.hash_shift^J)&W.hash_mask,y0=eJ,X0=(W)=>{const G=W.state;let J=G.pending;if(J>W.avail_out)J=W.avail_out;if(J===0)return;if(W.output.set(G.pending_buf.subarray(G.pending_out,G.pending_out+J),W.next_out),W.next_out+=J,G.pending_out+=J,W.total_out+=J,W.avail_out-=J,G.pending-=J,G.pending===0)G.pending_out=0},Y0=(W,G)=>{vJ(W,W.block_start>=0?W.block_start:-1,W.strstart-W.block_start,G),W.block_start=W.strstart,X0(W.strm)},c=(W,G)=>{W.pending_buf[W.pending++]=G},O1=(W,G)=>{W.pending_buf[W.pending++]=G>>>8&255,W.pending_buf[W.pending++]=G&255},G6=(W,G,J,Q)=>{let V=W.avail_in;if(V>Q)V=Q;if(V===0)return 0;if(W.avail_in-=V,G.set(W.input.subarray(W.next_in,W.next_in+V),J),W.state.wrap===1)W.adler=A1(W.adler,G,V,J);else if(W.state.wrap===2)W.adler=o(W.adler,G,V,J);return W.next_in+=V,W.total_in+=V,V},t5=(W,G)=>{let{max_chain_length:J,strstart:Q}=W,V,X,Y=W.prev_length,q=W.nice_match;const F=W.strstart>W.w_size-$0?W.strstart-(W.w_size-$0):0,P=W.window,U=W.w_mask,C=W.prev,K=W.strstart+S0;let z=P[Q+Y-1],$=P[Q+Y];if(W.prev_length>=W.good_match)J>>=2;if(q>W.lookahead)q=W.lookahead;do{if(V=G,P[V+Y]!==$||P[V+Y-1]!==z||P[V]!==P[Q]||P[++V]!==P[Q+1])continue;Q+=2,V++;do;while(P[++Q]===P[++V]&&P[++Q]===P[++V]&&P[++Q]===P[++V]&&P[++Q]===P[++V]&&P[++Q]===P[++V]&&P[++Q]===P[++V]&&P[++Q]===P[++V]&&P[++Q]===P[++V]&&Q<K);if(X=S0-(K-Q),Q=K-S0,X>Y){if(W.match_start=G,Y=X,X>=q)break;z=P[Q+Y-1],$=P[Q+Y]}}while((G=C[G&U])>F&&--J!==0);if(Y<=W.lookahead)return Y;return W.lookahead},Y1=(W)=>{const G=W.w_size;let J,Q,V;do{if(Q=W.window_size-W.lookahead-W.strstart,W.strstart>=G+(G-$0)){if(W.window.set(W.window.subarray(G,G+G-Q),0),W.match_start-=G,W.strstart-=G,W.block_start-=G,W.insert>W.strstart)W.insert=W.strstart;sJ(W),Q+=G}if(W.strm.avail_in===0)break;if(J=G6(W.strm,W.window,W.strstart+W.lookahead,Q),W.lookahead+=J,W.lookahead+W.insert>=u){V=W.strstart-W.insert,W.ins_h=W.window[V],W.ins_h=y0(W,W.ins_h,W.window[V+1]);while(W.insert)if(W.ins_h=y0(W,W.ins_h,W.window[V+u-1]),W.prev[V&W.w_mask]=W.head[W.ins_h],W.head[W.ins_h]=V,V++,W.insert--,W.lookahead+W.insert<u)break}}while(W.lookahead<$0&&W.strm.avail_in!==0)},W7=(W,G)=>{let J=W.pending_buf_size-5>W.w_size?W.w_size:W.pending_buf_size-5,Q,V,X,Y=0,q=W.strm.avail_in;do{if(Q=65535,X=W.bi_valid+42>>3,W.strm.avail_out<X)break;if(X=W.strm.avail_out-X,V=W.strstart-W.block_start,Q>V+W.strm.avail_in)Q=V+W.strm.avail_in;if(Q>X)Q=X;if(Q<J&&(Q===0&&G!==F0||G===A0||Q!==V+W.strm.avail_in))break;if(Y=G===F0&&Q===V+W.strm.avail_in?1:0,n8(W,0,0,Y),W.pending_buf[W.pending-4]=Q,W.pending_buf[W.pending-3]=Q>>8,W.pending_buf[W.pending-2]=~Q,W.pending_buf[W.pending-1]=~Q>>8,X0(W.strm),V){if(V>Q)V=Q;W.strm.output.set(W.window.subarray(W.block_start,W.block_start+V),W.strm.next_out),W.strm.next_out+=V,W.strm.avail_out-=V,W.strm.total_out+=V,W.block_start+=V,Q-=V}if(Q)G6(W.strm,W.strm.output,W.strm.next_out,Q),W.strm.next_out+=Q,W.strm.avail_out-=Q,W.strm.total_out+=Q}while(Y===0);if(q-=W.strm.avail_in,q){if(q>=W.w_size)W.matches=2,W.window.set(W.strm.input.subarray(W.strm.next_in-W.w_size,W.strm.next_in),0),W.strstart=W.w_size,W.insert=W.strstart;else{if(W.window_size-W.strstart<=q){if(W.strstart-=W.w_size,W.window.set(W.window.subarray(W.w_size,W.w_size+W.strstart),0),W.matches<2)W.matches++;if(W.insert>W.strstart)W.insert=W.strstart}W.window.set(W.strm.input.subarray(W.strm.next_in-q,W.strm.next_in),W.strstart),W.strstart+=q,W.insert+=q>W.w_size-W.insert?W.w_size-W.insert:q}W.block_start=W.strstart}if(W.high_water<W.strstart)W.high_water=W.strstart;if(Y)return U1;if(G!==A0&&G!==F0&&W.strm.avail_in===0&&W.strstart===W.block_start)return P1;if(X=W.window_size-W.strstart,W.strm.avail_in>X&&W.block_start>=W.w_size){if(W.block_start-=W.w_size,W.strstart-=W.w_size,W.window.set(W.window.subarray(W.w_size,W.w_size+W.strstart),0),W.matches<2)W.matches++;if(X+=W.w_size,W.insert>W.strstart)W.insert=W.strstart}if(X>W.strm.avail_in)X=W.strm.avail_in;if(X)G6(W.strm,W.window,W.strstart,X),W.strstart+=X,W.insert+=X>W.w_size-W.insert?W.w_size-W.insert:X;if(W.high_water<W.strstart)W.high_water=W.strstart;if(X=W.bi_valid+42>>3,X=W.pending_buf_size-X>65535?65535:W.pending_buf_size-X,J=X>W.w_size?W.w_size:X,V=W.strstart-W.block_start,V>=J||(V||G===F0)&&G!==A0&&W.strm.avail_in===0&&V<=X)Q=V>X?X:V,Y=G===F0&&W.strm.avail_in===0&&Q===V?1:0,n8(W,W.block_start,Q,Y),W.block_start+=Q,X0(W.strm);return Y?d0:t},b8=(W,G)=>{let J,Q;for(;;){if(W.lookahead<$0){if(Y1(W),W.lookahead<$0&&G===A0)return t;if(W.lookahead===0)break}if(J=0,W.lookahead>=u)W.ins_h=y0(W,W.ins_h,W.window[W.strstart+u-1]),J=W.prev[W.strstart&W.w_mask]=W.head[W.ins_h],W.head[W.ins_h]=W.strstart;if(J!==0&&W.strstart-J<=W.w_size-$0)W.match_length=t5(W,J);if(W.match_length>=u)if(Q=T0(W,W.strstart-W.match_start,W.match_length-u),W.lookahead-=W.match_length,W.match_length<=W.max_lazy_match&&W.lookahead>=u){W.match_length--;do W.strstart++,W.ins_h=y0(W,W.ins_h,W.window[W.strstart+u-1]),J=W.prev[W.strstart&W.w_mask]=W.head[W.ins_h],W.head[W.ins_h]=W.strstart;while(--W.match_length!==0);W.strstart++}else W.strstart+=W.match_length,W.match_length=0,W.ins_h=W.window[W.strstart],W.ins_h=y0(W,W.ins_h,W.window[W.strstart+1]);else Q=T0(W,0,W.window[W.strstart]),W.lookahead--,W.strstart++;if(Q){if(Y0(W,!1),W.strm.avail_out===0)return t}}if(W.insert=W.strstart<u-1?W.strstart:u-1,G===F0){if(Y0(W,!0),W.strm.avail_out===0)return d0;return U1}if(W.sym_next){if(Y0(W,!1),W.strm.avail_out===0)return t}return P1},G1=(W,G)=>{let J,Q,V;for(;;){if(W.lookahead<$0){if(Y1(W),W.lookahead<$0&&G===A0)return t;if(W.lookahead===0)break}if(J=0,W.lookahead>=u)W.ins_h=y0(W,W.ins_h,W.window[W.strstart+u-1]),J=W.prev[W.strstart&W.w_mask]=W.head[W.ins_h],W.head[W.ins_h]=W.strstart;if(W.prev_length=W.match_length,W.prev_match=W.match_start,W.match_length=u-1,J!==0&&W.prev_length<W.max_lazy_match&&W.strstart-J<=W.w_size-$0){if(W.match_length=t5(W,J),W.match_length<=5&&(W.strategy===EJ||W.match_length===u&&W.strstart-W.match_start>4096))W.match_length=u-1}if(W.prev_length>=u&&W.match_length<=W.prev_length){V=W.strstart+W.lookahead-u,Q=T0(W,W.strstart-1-W.prev_match,W.prev_length-u),W.lookahead-=W.prev_length-1,W.prev_length-=2;do if(++W.strstart<=V)W.ins_h=y0(W,W.ins_h,W.window[W.strstart+u-1]),J=W.prev[W.strstart&W.w_mask]=W.head[W.ins_h],W.head[W.ins_h]=W.strstart;while(--W.prev_length!==0);if(W.match_available=0,W.match_length=u-1,W.strstart++,Q){if(Y0(W,!1),W.strm.avail_out===0)return t}}else if(W.match_available){if(Q=T0(W,0,W.window[W.strstart-1]),Q)Y0(W,!1);if(W.strstart++,W.lookahead--,W.strm.avail_out===0)return t}else W.match_available=1,W.strstart++,W.lookahead--}if(W.match_available)Q=T0(W,0,W.window[W.strstart-1]),W.match_available=0;if(W.insert=W.strstart<u-1?W.strstart:u-1,G===F0){if(Y0(W,!0),W.strm.avail_out===0)return d0;return U1}if(W.sym_next){if(Y0(W,!1),W.strm.avail_out===0)return t}return P1},tJ=(W,G)=>{let J,Q,V,X;const Y=W.window;for(;;){if(W.lookahead<=S0){if(Y1(W),W.lookahead<=S0&&G===A0)return t;if(W.lookahead===0)break}if(W.match_length=0,W.lookahead>=u&&W.strstart>0){if(V=W.strstart-1,Q=Y[V],Q===Y[++V]&&Q===Y[++V]&&Q===Y[++V]){X=W.strstart+S0;do;while(Q===Y[++V]&&Q===Y[++V]&&Q===Y[++V]&&Q===Y[++V]&&Q===Y[++V]&&Q===Y[++V]&&Q===Y[++V]&&Q===Y[++V]&&V<X);if(W.match_length=S0-(X-V),W.match_length>W.lookahead)W.match_length=W.lookahead}}if(W.match_length>=u)J=T0(W,1,W.match_length-u),W.lookahead-=W.match_length,W.strstart+=W.match_length,W.match_length=0;else J=T0(W,0,W.window[W.strstart]),W.lookahead--,W.strstart++;if(J){if(Y0(W,!1),W.strm.avail_out===0)return t}}if(W.insert=0,G===F0){if(Y0(W,!0),W.strm.avail_out===0)return d0;return U1}if(W.sym_next){if(Y0(W,!1),W.strm.avail_out===0)return t}return P1},W9=(W,G)=>{let J;for(;;){if(W.lookahead===0){if(Y1(W),W.lookahead===0){if(G===A0)return t;break}}if(W.match_length=0,J=T0(W,0,W.window[W.strstart]),W.lookahead--,W.strstart++,J){if(Y0(W,!1),W.strm.avail_out===0)return t}}if(W.insert=0,G===F0){if(Y0(W,!0),W.strm.avail_out===0)return d0;return U1}if(W.sym_next){if(Y0(W,!1),W.strm.avail_out===0)return t}return P1},D1=[new k0(0,0,0,0,W7),new k0(4,4,8,4,b8),new k0(4,5,16,8,b8),new k0(4,6,32,32,b8),new k0(4,4,16,16,G1),new k0(8,16,32,32,G1),new k0(8,16,128,128,G1),new k0(8,32,128,256,G1),new k0(32,128,258,1024,G1),new k0(32,258,258,4096,G1)],J9=(W)=>{W.window_size=2*W.w_size,g0(W.head),W.max_lazy_match=D1[W.level].max_lazy,W.good_match=D1[W.level].good_length,W.nice_match=D1[W.level].nice_length,W.max_chain_length=D1[W.level].max_chain,W.strstart=0,W.block_start=0,W.lookahead=0,W.insert=0,W.match_length=W.prev_length=u-1,W.match_available=0,W.ins_h=0},h1=(W)=>{if(!W)return 1;const G=W.state;if(!G||G.strm!==W||G.status!==X1&&G.status!==q6&&G.status!==e8&&G.status!==t8&&G.status!==W6&&G.status!==J6&&G.status!==b0&&G.status!==I1)return 1;return 0},J7=(W)=>{if(h1(W))return m0(W,C0);W.total_in=W.total_out=0,W.data_type=bJ;const G=W.state;if(G.pending=0,G.pending_out=0,G.wrap<0)G.wrap=-G.wrap;return G.status=G.wrap===2?q6:G.wrap?X1:b0,W.adler=G.wrap===2?0:1,G.last_flush=-2,NJ(G),a},G7=(W)=>{const G=J7(W);if(G===a)J9(W.state);return G},Q9=(W,G)=>{if(h1(W)||W.state.wrap!==2)return C0;return W.state.gzhead=G,a},Q7=(W,G,J,Q,V,X)=>{if(!W)return C0;let Y=1;if(G===yJ)G=6;if(Q<0)Y=0,Q=-Q;else if(Q>15)Y=2,Q-=16;if(V<1||V>mJ||J!==U8||Q<8||Q>15||G<0||G>9||X<0||X>fJ||Q===8&&Y!==1)return m0(W,C0);if(Q===8)Q=9;const q=new G9;return W.state=q,q.strm=W,q.status=X1,q.wrap=Y,q.gzhead=null,q.w_bits=Q,q.w_size=1<<q.w_bits,q.w_mask=q.w_size-1,q.hash_bits=V+7,q.hash_size=1<<q.hash_bits,q.hash_mask=q.hash_size-1,q.hash_shift=~~((q.hash_bits+u-1)/u),q.window=new Uint8Array(q.w_size*2),q.head=new Uint16Array(q.hash_size),q.prev=new Uint16Array(q.w_size),q.lit_bufsize=1<<V+6,q.pending_buf_size=q.lit_bufsize*4,q.pending_buf=new Uint8Array(q.pending_buf_size),q.sym_buf=q.lit_bufsize,q.sym_end=(q.lit_bufsize-1)*3,q.level=G,q.strategy=X,q.method=J,G7(W)},V9=(W,G)=>{return Q7(W,G,U8,uJ,dJ,hJ)},X9=(W,G)=>{if(h1(W)||G>X5||G<0)return W?m0(W,C0):C0;const J=W.state;if(!W.output||W.avail_in!==0&&!W.input||J.status===I1&&G!==F0)return m0(W,W.avail_out===0?h8:C0);const Q=J.last_flush;if(J.last_flush=G,J.pending!==0){if(X0(W),W.avail_out===0)return J.last_flush=-1,a}else if(W.avail_in===0&&q5(G)<=q5(Q)&&G!==F0)return m0(W,h8);if(J.status===I1&&W.avail_in!==0)return m0(W,h8);if(J.status===X1&&J.wrap===0)J.status=b0;if(J.status===X1){let V=U8+(J.w_bits-8<<4)<<8,X=-1;if(J.strategy>=W8||J.level<2)X=0;else if(J.level<6)X=1;else if(J.level===6)X=2;else X=3;if(V|=X<<6,J.strstart!==0)V|=aJ;if(V+=31-V%31,O1(J,V),J.strstart!==0)O1(J,W.adler>>>16),O1(J,W.adler&65535);if(W.adler=1,J.status=b0,X0(W),J.pending!==0)return J.last_flush=-1,a}if(J.status===q6)if(W.adler=0,c(J,31),c(J,139),c(J,8),!J.gzhead){if(c(J,0),c(J,0),c(J,0),c(J,0),c(J,0),c(J,J.level===9?2:J.strategy>=W8||J.level<2?4:0),c(J,nJ),J.status=b0,X0(W),J.pending!==0)return J.last_flush=-1,a}else{if(c(J,(J.gzhead.text?1:0)+(J.gzhead.hcrc?2:0)+(!J.gzhead.extra?0:4)+(!J.gzhead.name?0:8)+(!J.gzhead.comment?0:16)),c(J,J.gzhead.time&255),c(J,J.gzhead.time>>8&255),c(J,J.gzhead.time>>16&255),c(J,J.gzhead.time>>24&255),c(J,J.level===9?2:J.strategy>=W8||J.level<2?4:0),c(J,J.gzhead.os&255),J.gzhead.extra&&J.gzhead.extra.length)c(J,J.gzhead.extra.length&255),c(J,J.gzhead.extra.length>>8&255);if(J.gzhead.hcrc)W.adler=o(W.adler,J.pending_buf,J.pending,0);J.gzindex=0,J.status=e8}if(J.status===e8){if(J.gzhead.extra){let V=J.pending,X=(J.gzhead.extra.length&65535)-J.gzindex;while(J.pending+X>J.pending_buf_size){let q=J.pending_buf_size-J.pending;if(J.pending_buf.set(J.gzhead.extra.subarray(J.gzindex,J.gzindex+q),J.pending),J.pending=J.pending_buf_size,J.gzhead.hcrc&&J.pending>V)W.adler=o(W.adler,J.pending_buf,J.pending-V,V);if(J.gzindex+=q,X0(W),J.pending!==0)return J.last_flush=-1,a;V=0,X-=q}let Y=new Uint8Array(J.gzhead.extra);if(J.pending_buf.set(Y.subarray(J.gzindex,J.gzindex+X),J.pending),J.pending+=X,J.gzhead.hcrc&&J.pending>V)W.adler=o(W.adler,J.pending_buf,J.pending-V,V);J.gzindex=0}J.status=t8}if(J.status===t8){if(J.gzhead.name){let V=J.pending,X;do{if(J.pending===J.pending_buf_size){if(J.gzhead.hcrc&&J.pending>V)W.adler=o(W.adler,J.pending_buf,J.pending-V,V);if(X0(W),J.pending!==0)return J.last_flush=-1,a;V=0}if(J.gzindex<J.gzhead.name.length)X=J.gzhead.name.charCodeAt(J.gzindex++)&255;else X=0;c(J,X)}while(X!==0);if(J.gzhead.hcrc&&J.pending>V)W.adler=o(W.adler,J.pending_buf,J.pending-V,V);J.gzindex=0}J.status=W6}if(J.status===W6){if(J.gzhead.comment){let V=J.pending,X;do{if(J.pending===J.pending_buf_size){if(J.gzhead.hcrc&&J.pending>V)W.adler=o(W.adler,J.pending_buf,J.pending-V,V);if(X0(W),J.pending!==0)return J.last_flush=-1,a;V=0}if(J.gzindex<J.gzhead.comment.length)X=J.gzhead.comment.charCodeAt(J.gzindex++)&255;else X=0;c(J,X)}while(X!==0);if(J.gzhead.hcrc&&J.pending>V)W.adler=o(W.adler,J.pending_buf,J.pending-V,V)}J.status=J6}if(J.status===J6){if(J.gzhead.hcrc){if(J.pending+2>J.pending_buf_size){if(X0(W),J.pending!==0)return J.last_flush=-1,a}c(J,W.adler&255),c(J,W.adler>>8&255),W.adler=0}if(J.status=b0,X0(W),J.pending!==0)return J.last_flush=-1,a}if(W.avail_in!==0||J.lookahead!==0||G!==A0&&J.status!==I1){let V=J.level===0?W7(J,G):J.strategy===W8?W9(J,G):J.strategy===pJ?tJ(J,G):D1[J.level].func(J,G);if(V===d0||V===U1)J.status=I1;if(V===t||V===d0){if(W.avail_out===0)J.last_flush=-1;return a}if(V===P1){if(G===SJ)gJ(J);else if(G!==X5){if(n8(J,0,0,!1),G===TJ){if(g0(J.head),J.lookahead===0)J.strstart=0,J.block_start=0,J.insert=0}}if(X0(W),W.avail_out===0)return J.last_flush=-1,a}}if(G!==F0)return a;if(J.wrap<=0)return Y5;if(J.wrap===2)c(J,W.adler&255),c(J,W.adler>>8&255),c(J,W.adler>>16&255),c(J,W.adler>>24&255),c(J,W.total_in&255),c(J,W.total_in>>8&255),c(J,W.total_in>>16&255),c(J,W.total_in>>24&255);else O1(J,W.adler>>>16),O1(J,W.adler&65535);if(X0(W),J.wrap>0)J.wrap=-J.wrap;return J.pending!==0?a:Y5},Y9=(W)=>{if(h1(W))return C0;const G=W.state.status;return W.state=null,G===b0?m0(W,AJ):a},q9=(W,G)=>{let J=G.length;if(h1(W))return C0;const Q=W.state,V=Q.wrap;if(V===2||V===1&&Q.status!==X1||Q.lookahead)return C0;if(V===1)W.adler=A1(W.adler,G,J,0);if(Q.wrap=0,J>=Q.w_size){if(V===0)g0(Q.head),Q.strstart=0,Q.block_start=0,Q.insert=0;let F=new Uint8Array(Q.w_size);F.set(G.subarray(J-Q.w_size,J),0),G=F,J=Q.w_size}const{avail_in:X,next_in:Y,input:q}=W;W.avail_in=J,W.next_in=0,W.input=G,Y1(Q);while(Q.lookahead>=u){let F=Q.strstart,P=Q.lookahead-(u-1);do Q.ins_h=y0(Q,Q.ins_h,Q.window[F+u-1]),Q.prev[F&Q.w_mask]=Q.head[Q.ins_h],Q.head[Q.ins_h]=F,F++;while(--P);Q.strstart=F,Q.lookahead=u-1,Y1(Q)}return Q.strstart+=Q.lookahead,Q.block_start=Q.strstart,Q.insert=Q.lookahead,Q.lookahead=0,Q.match_length=Q.prev_length=u-1,Q.match_available=0,W.next_in=Y,W.input=q,W.avail_in=X,Q.wrap=V,a},P9=V9,U9=Q7,F9=G7,K9=J7,z9=Q9,Z9=X9,k9=Y9,H9=q9,C9="pako deflate (from Nodeca project)",w1={deflateInit:P9,deflateInit2:U9,deflateReset:F9,deflateResetKeep:K9,deflateSetHeader:z9,deflate:Z9,deflateEnd:k9,deflateSetDictionary:H9,deflateInfo:C9},$9=(W,G)=>{return Object.prototype.hasOwnProperty.call(W,G)},j9=function(W){const G=Array.prototype.slice.call(arguments,1);while(G.length){const J=G.shift();if(!J)continue;if(typeof J!=="object")throw new TypeError(J+"must be non-object");for(let Q in J)if($9(J,Q))W[Q]=J[Q]}return W},B9=(W)=>{let G=0;for(let Q=0,V=W.length;Q<V;Q++)G+=W[Q].length;const J=new Uint8Array(G);for(let Q=0,V=0,X=W.length;Q<X;Q++){let Y=W[Q];J.set(Y,V),V+=Y.length}return J},F8={assign:j9,flattenChunks:B9},V7=!0;try{String.fromCharCode.apply(null,new Uint8Array(1))}catch(W){V7=!1}var y1=new Uint8Array(256);for(let W=0;W<256;W++)y1[W]=W>=252?6:W>=248?5:W>=240?4:W>=224?3:W>=192?2:1;y1[254]=y1[254]=1;var M9=(W)=>{if(typeof TextEncoder==="function"&&TextEncoder.prototype.encode)return(new TextEncoder()).encode(W);let G,J,Q,V,X,Y=W.length,q=0;for(V=0;V<Y;V++){if(J=W.charCodeAt(V),(J&64512)===55296&&V+1<Y){if(Q=W.charCodeAt(V+1),(Q&64512)===56320)J=65536+(J-55296<<10)+(Q-56320),V++}q+=J<128?1:J<2048?2:J<65536?3:4}G=new Uint8Array(q);for(X=0,V=0;X<q;V++){if(J=W.charCodeAt(V),(J&64512)===55296&&V+1<Y){if(Q=W.charCodeAt(V+1),(Q&64512)===56320)J=65536+(J-55296<<10)+(Q-56320),V++}if(J<128)G[X++]=J;else if(J<2048)G[X++]=192|J>>>6,G[X++]=128|J&63;else if(J<65536)G[X++]=224|J>>>12,G[X++]=128|J>>>6&63,G[X++]=128|J&63;else G[X++]=240|J>>>18,G[X++]=128|J>>>12&63,G[X++]=128|J>>>6&63,G[X++]=128|J&63}return G},R9=(W,G)=>{if(G<65534){if(W.subarray&&V7)return String.fromCharCode.apply(null,W.length===G?W:W.subarray(0,G))}let J="";for(let Q=0;Q<G;Q++)J+=String.fromCharCode(W[Q]);return J},L9=(W,G)=>{const J=G||W.length;if(typeof TextDecoder==="function"&&TextDecoder.prototype.decode)return(new TextDecoder()).decode(W.subarray(0,G));let Q,V;const X=new Array(J*2);for(V=0,Q=0;Q<J;){let Y=W[Q++];if(Y<128){X[V++]=Y;continue}let q=y1[Y];if(q>4){X[V++]=65533,Q+=q-1;continue}Y&=q===2?31:q===3?15:7;while(q>1&&Q<J)Y=Y<<6|W[Q++]&63,q--;if(q>1){X[V++]=65533;continue}if(Y<65536)X[V++]=Y;else Y-=65536,X[V++]=55296|Y>>10&1023,X[V++]=56320|Y&1023}return R9(X,V)},O9=(W,G)=>{if(G=G||W.length,G>W.length)G=W.length;let J=G-1;while(J>=0&&(W[J]&192)===128)J--;if(J<0)return G;if(J===0)return G;return J+y1[W[J]]>G?J:G},E1={string2buf:M9,buf2string:L9,utf8border:O9},X7=I9,Y7=Object.prototype.toString,{Z_NO_FLUSH:D9,Z_SYNC_FLUSH:x9,Z_FULL_FLUSH:w9,Z_FINISH:N9,Z_OK:q8,Z_STREAM_END:v9,Z_DEFAULT_COMPRESSION:g9,Z_DEFAULT_STRATEGY:S9,Z_DEFLATED:T9}=_0;b1.prototype.push=function(W,G){const J=this.strm,Q=this.options.chunkSize;let V,X;if(this.ended)return!1;if(G===~~G)X=G;else X=G===!0?N9:D9;if(typeof W==="string")J.input=E1.string2buf(W);else if(Y7.call(W)==="[object ArrayBuffer]")J.input=new Uint8Array(W);else J.input=W;J.next_in=0,J.avail_in=J.input.length;for(;;){if(J.avail_out===0)J.output=new Uint8Array(Q),J.next_out=0,J.avail_out=Q;if((X===x9||X===w9)&&J.avail_out<=6){this.onData(J.output.subarray(0,J.next_out)),J.avail_out=0;continue}if(V=w1.deflate(J,X),V===v9){if(J.next_out>0)this.onData(J.output.subarray(0,J.next_out));return V=w1.deflateEnd(this.strm),this.onEnd(V),this.ended=!0,V===q8}if(J.avail_out===0){this.onData(J.output);continue}if(X>0&&J.next_out>0){this.onData(J.output.subarray(0,J.next_out)),J.avail_out=0;continue}if(J.avail_in===0)break}return!0};b1.prototype.onData=function(W){this.chunks.push(W)};b1.prototype.onEnd=function(W){if(W===q8)this.result=F8.flattenChunks(this.chunks);this.chunks=[],this.err=W,this.msg=this.strm.msg};var E9=b1,p9=P6,f9=A9,h9=y9,b9=_0,m9={Deflate:E9,deflate:p9,deflateRaw:f9,gzip:h9,constants:b9},J8=16209,u9=16191,d9=function W(G,J){let Q,V,X,Y,q,F,P,U,C,K,z,$,N,g,y,E,p,x,f,d,I,L,w,Z;const k=G.state;Q=G.next_in,w=G.input,V=Q+(G.avail_in-5),X=G.next_out,Z=G.output,Y=X-(J-G.avail_out),q=X+(G.avail_out-257),F=k.dmax,P=k.wsize,U=k.whave,C=k.wnext,K=k.window,z=k.hold,$=k.bits,N=k.lencode,g=k.distcode,y=(1<<k.lenbits)-1,E=(1<<k.distbits)-1;W:do{if($<15)z+=w[Q++]<<$,$+=8,z+=w[Q++]<<$,$+=8;p=N[z&y];J:for(;;){if(x=p>>>24,z>>>=x,$-=x,x=p>>>16&255,x===0)Z[X++]=p&65535;else if(x&16){if(f=p&65535,x&=15,x){if($<x)z+=w[Q++]<<$,$+=8;f+=z&(1<<x)-1,z>>>=x,$-=x}if($<15)z+=w[Q++]<<$,$+=8,z+=w[Q++]<<$,$+=8;p=g[z&E];G:for(;;){if(x=p>>>24,z>>>=x,$-=x,x=p>>>16&255,x&16){if(d=p&65535,x&=15,$<x){if(z+=w[Q++]<<$,$+=8,$<x)z+=w[Q++]<<$,$+=8}if(d+=z&(1<<x)-1,d>F){G.msg="invalid distance too far back",k.mode=J8;break W}if(z>>>=x,$-=x,x=X-Y,d>x){if(x=d-x,x>U){if(k.sane){G.msg="invalid distance too far back",k.mode=J8;break W}}if(I=0,L=K,C===0){if(I+=P-x,x<f){f-=x;do Z[X++]=K[I++];while(--x);I=X-d,L=Z}}else if(C<x){if(I+=P+C-x,x-=C,x<f){f-=x;do Z[X++]=K[I++];while(--x);if(I=0,C<f){x=C,f-=x;do Z[X++]=K[I++];while(--x);I=X-d,L=Z}}}else if(I+=C-x,x<f){f-=x;do Z[X++]=K[I++];while(--x);I=X-d,L=Z}while(f>2)Z[X++]=L[I++],Z[X++]=L[I++],Z[X++]=L[I++],f-=3;if(f){if(Z[X++]=L[I++],f>1)Z[X++]=L[I++]}}else{I=X-d;do Z[X++]=Z[I++],Z[X++]=Z[I++],Z[X++]=Z[I++],f-=3;while(f>2);if(f){if(Z[X++]=Z[I++],f>1)Z[X++]=Z[I++]}}}else if((x&64)===0){p=g[(p&65535)+(z&(1<<x)-1)];continue G}else{G.msg="invalid distance code",k.mode=J8;break W}break}}else if((x&64)===0){p=N[(p&65535)+(z&(1<<x)-1)];continue J}else if(x&32){k.mode=u9;break W}else{G.msg="invalid literal/length code",k.mode=J8;break W}break}}while(Q<V&&X<q);f=$>>3,Q-=f,$-=f<<3,z&=(1<<$)-1,G.next_in=Q,G.next_out=X,G.avail_in=Q<V?5+(V-Q):5-(Q-V),G.avail_out=X<q?257+(q-X):257-(X-q),k.hold=z,k.bits=$;return},Q1=15,P5=852,U5=592,F5=0,m8=1,K5=2,c9=new Uint16Array([3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,0,0]),_9=new Uint8Array([16,16,16,16,16,16,16,16,17,17,17,17,18,18,18,18,19,19,19,19,20,20,20,20,21,21,21,21,16,72,78]),l9=new Uint16Array([1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,0,0]),i9=new Uint8Array([16,16,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,64,64]),r9=(W,G,J,Q,V,X,Y,q)=>{const F=q.bits;let P=0,U=0,C=0,K=0,z=0,$=0,N=0,g=0,y=0,E=0,p,x,f,d,I,L=null,w;const Z=new Uint16Array(Q1+1),k=new Uint16Array(Q1+1);let M=null,H,j,O;for(P=0;P<=Q1;P++)Z[P]=0;for(U=0;U<Q;U++)Z[G[J+U]]++;z=F;for(K=Q1;K>=1;K--)if(Z[K]!==0)break;if(z>K)z=K;if(K===0)return V[X++]=1<<24|64<<16|0,V[X++]=1<<24|64<<16|0,q.bits=1,0;for(C=1;C<K;C++)if(Z[C]!==0)break;if(z<C)z=C;g=1;for(P=1;P<=Q1;P++)if(g<<=1,g-=Z[P],g<0)return-1;if(g>0&&(W===F5||K!==1))return-1;k[1]=0;for(P=1;P<Q1;P++)k[P+1]=k[P]+Z[P];for(U=0;U<Q;U++)if(G[J+U]!==0)Y[k[G[J+U]]++]=U;if(W===F5)L=M=Y,w=20;else if(W===m8)L=c9,M=_9,w=257;else L=l9,M=i9,w=0;if(E=0,U=0,P=C,I=X,$=z,N=0,f=-1,y=1<<z,d=y-1,W===m8&&y>P5||W===K5&&y>U5)return 1;for(;;){if(H=P-N,Y[U]+1<w)j=0,O=Y[U];else if(Y[U]>=w)j=M[Y[U]-w],O=L[Y[U]-w];else j=96,O=0;p=1<<P-N,x=1<<$,C=x;do x-=p,V[I+(E>>N)+x]=H<<24|j<<16|O|0;while(x!==0);p=1<<P-1;while(E&p)p>>=1;if(p!==0)E&=p-1,E+=p;else E=0;if(U++,--Z[P]===0){if(P===K)break;P=G[J+Y[U]]}if(P>z&&(E&d)!==f){if(N===0)N=z;I+=C,$=P-N,g=1<<$;while($+N<K){if(g-=Z[$+N],g<=0)break;$++,g<<=1}if(y+=1<<$,W===m8&&y>P5||W===K5&&y>U5)return 1;f=E&d,V[f]=z<<24|$<<16|I-X|0}}if(E!==0)V[I+E]=P-N<<24|64<<16|0;return q.bits=z,0},N1=r9,o9=0,q7=1,P7=2,{Z_FINISH:z5,Z_BLOCK:a9,Z_TREES:G8,Z_OK:c0,Z_STREAM_END:n9,Z_NEED_DICT:s9,Z_STREAM_ERROR:K0,Z_DATA_ERROR:U7,Z_MEM_ERROR:F7,Z_BUF_ERROR:e9,Z_DEFLATED:Z5}=_0,K8=16180,k5=16181,H5=16182,C5=16183,$5=16184,j5=16185,B5=16186,M5=16187,R5=16188,L5=16189,P8=16190,R0=16191,u8=16192,O5=16193,d8=16194,I5=16195,D5=16196,x5=16197,w5=16198,Q8=16199,V8=16200,N5=16201,v5=16202,g5=16203,S5=16204,T5=16205,c8=16206,A5=16207,y5=16208,i=16209,K7=16210,z7=16211,t9=852,WG=592,JG=15,GG=JG,E5=(W)=>{return(W>>>24&255)+(W>>>8&65280)+((W&65280)<<8)+((W&255)<<24)},l0=(W)=>{if(!W)return 1;const G=W.state;if(!G||G.strm!==W||G.mode<K8||G.mode>z7)return 1;return 0},Z7=(W)=>{if(l0(W))return K0;const G=W.state;if(W.total_in=W.total_out=G.total=0,W.msg="",G.wrap)W.adler=G.wrap&1;return G.mode=K8,G.last=0,G.havedict=0,G.flags=-1,G.dmax=32768,G.head=null,G.hold=0,G.bits=0,G.lencode=G.lendyn=new Int32Array(t9),G.distcode=G.distdyn=new Int32Array(WG),G.sane=1,G.back=-1,c0},k7=(W)=>{if(l0(W))return K0;const G=W.state;return G.wsize=0,G.whave=0,G.wnext=0,Z7(W)},H7=(W,G)=>{let J;if(l0(W))return K0;const Q=W.state;if(G<0)J=0,G=-G;else if(J=(G>>4)+5,G<48)G&=15;if(G&&(G<8||G>15))return K0;if(Q.window!==null&&Q.wbits!==G)Q.window=null;return Q.wrap=J,Q.wbits=G,k7(W)},C7=(W,G)=>{if(!W)return K0;const J=new QG;W.state=J,J.strm=W,J.window=null,J.mode=K8;const Q=H7(W,G);if(Q!==c0)W.state=null;return Q},VG=(W)=>{return C7(W,GG)},p5=!0,_8,l8,XG=(W)=>{if(p5){_8=new Int32Array(512),l8=new Int32Array(32);let G=0;while(G<144)W.lens[G++]=8;while(G<256)W.lens[G++]=9;while(G<280)W.lens[G++]=7;while(G<288)W.lens[G++]=8;N1(q7,W.lens,0,288,_8,0,W.work,{bits:9}),G=0;while(G<32)W.lens[G++]=5;N1(P7,W.lens,0,32,l8,0,W.work,{bits:5}),p5=!1}W.lencode=_8,W.lenbits=9,W.distcode=l8,W.distbits=5},$7=(W,G,J,Q)=>{let V;const X=W.state;if(X.window===null)X.wsize=1<<X.wbits,X.wnext=0,X.whave=0,X.window=new Uint8Array(X.wsize);if(Q>=X.wsize)X.window.set(G.subarray(J-X.wsize,J),0),X.wnext=0,X.whave=X.wsize;else{if(V=X.wsize-X.wnext,V>Q)V=Q;if(X.window.set(G.subarray(J-Q,J-Q+V),X.wnext),Q-=V,Q)X.window.set(G.subarray(J-Q,J),0),X.wnext=Q,X.whave=X.wsize;else{if(X.wnext+=V,X.wnext===X.wsize)X.wnext=0;if(X.whave<X.wsize)X.whave+=V}}return 0},YG=(W,G)=>{let J,Q,V,X,Y,q,F,P,U,C,K,z,$,N,g=0,y,E,p,x,f,d,I,L;const w=new Uint8Array(4);let Z,k;const M=new Uint8Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]);if(l0(W)||!W.output||!W.input&&W.avail_in!==0)return K0;if(J=W.state,J.mode===R0)J.mode=u8;Y=W.next_out,V=W.output,F=W.avail_out,X=W.next_in,Q=W.input,q=W.avail_in,P=J.hold,U=J.bits,C=q,K=F,L=c0;W:for(;;)switch(J.mode){case K8:if(J.wrap===0){J.mode=u8;break}while(U<16){if(q===0)break W;q--,P+=Q[X++]<<U,U+=8}if(J.wrap&2&&P===35615){if(J.wbits===0)J.wbits=15;J.check=0,w[0]=P&255,w[1]=P>>>8&255,J.check=o(J.check,w,2,0),P=0,U=0,J.mode=k5;break}if(J.head)J.head.done=!1;if(!(J.wrap&1)||(((P&255)<<8)+(P>>8))%31){W.msg="incorrect header check",J.mode=i;break}if((P&15)!==Z5){W.msg="unknown compression method",J.mode=i;break}if(P>>>=4,U-=4,I=(P&15)+8,J.wbits===0)J.wbits=I;if(I>15||I>J.wbits){W.msg="invalid window size",J.mode=i;break}J.dmax=1<<J.wbits,J.flags=0,W.adler=J.check=1,J.mode=P&512?L5:R0,P=0,U=0;break;case k5:while(U<16){if(q===0)break W;q--,P+=Q[X++]<<U,U+=8}if(J.flags=P,(J.flags&255)!==Z5){W.msg="unknown compression method",J.mode=i;break}if(J.flags&57344){W.msg="unknown header flags set",J.mode=i;break}if(J.head)J.head.text=P>>8&1;if(J.flags&512&&J.wrap&4)w[0]=P&255,w[1]=P>>>8&255,J.check=o(J.check,w,2,0);P=0,U=0,J.mode=H5;case H5:while(U<32){if(q===0)break W;q--,P+=Q[X++]<<U,U+=8}if(J.head)J.head.time=P;if(J.flags&512&&J.wrap&4)w[0]=P&255,w[1]=P>>>8&255,w[2]=P>>>16&255,w[3]=P>>>24&255,J.check=o(J.check,w,4,0);P=0,U=0,J.mode=C5;case C5:while(U<16){if(q===0)break W;q--,P+=Q[X++]<<U,U+=8}if(J.head)J.head.xflags=P&255,J.head.os=P>>8;if(J.flags&512&&J.wrap&4)w[0]=P&255,w[1]=P>>>8&255,J.check=o(J.check,w,2,0);P=0,U=0,J.mode=$5;case $5:if(J.flags&1024){while(U<16){if(q===0)break W;q--,P+=Q[X++]<<U,U+=8}if(J.length=P,J.head)J.head.extra_len=P;if(J.flags&512&&J.wrap&4)w[0]=P&255,w[1]=P>>>8&255,J.check=o(J.check,w,2,0);P=0,U=0}else if(J.head)J.head.extra=null;J.mode=j5;case j5:if(J.flags&1024){if(z=J.length,z>q)z=q;if(z){if(J.head){if(I=J.head.extra_len-J.length,!J.head.extra)J.head.extra=new Uint8Array(J.head.extra_len);J.head.extra.set(Q.subarray(X,X+z),I)}if(J.flags&512&&J.wrap&4)J.check=o(J.check,Q,z,X);q-=z,X+=z,J.length-=z}if(J.length)break W}J.length=0,J.mode=B5;case B5:if(J.flags&2048){if(q===0)break W;z=0;do if(I=Q[X+z++],J.head&&I&&J.length<65536)J.head.name+=String.fromCharCode(I);while(I&&z<q);if(J.flags&512&&J.wrap&4)J.check=o(J.check,Q,z,X);if(q-=z,X+=z,I)break W}else if(J.head)J.head.name=null;J.length=0,J.mode=M5;case M5:if(J.flags&4096){if(q===0)break W;z=0;do if(I=Q[X+z++],J.head&&I&&J.length<65536)J.head.comment+=String.fromCharCode(I);while(I&&z<q);if(J.flags&512&&J.wrap&4)J.check=o(J.check,Q,z,X);if(q-=z,X+=z,I)break W}else if(J.head)J.head.comment=null;J.mode=R5;case R5:if(J.flags&512){while(U<16){if(q===0)break W;q--,P+=Q[X++]<<U,U+=8}if(J.wrap&4&&P!==(J.check&65535)){W.msg="header crc mismatch",J.mode=i;break}P=0,U=0}if(J.head)J.head.hcrc=J.flags>>9&1,J.head.done=!0;W.adler=J.check=0,J.mode=R0;break;case L5:while(U<32){if(q===0)break W;q--,P+=Q[X++]<<U,U+=8}W.adler=J.check=E5(P),P=0,U=0,J.mode=P8;case P8:if(J.havedict===0)return W.next_out=Y,W.avail_out=F,W.next_in=X,W.avail_in=q,J.hold=P,J.bits=U,s9;W.adler=J.check=1,J.mode=R0;case R0:if(G===a9||G===G8)break W;case u8:if(J.last){P>>>=U&7,U-=U&7,J.mode=c8;break}while(U<3){if(q===0)break W;q--,P+=Q[X++]<<U,U+=8}switch(J.last=P&1,P>>>=1,U-=1,P&3){case 0:J.mode=O5;break;case 1:if(XG(J),J.mode=Q8,G===G8){P>>>=2,U-=2;break W}break;case 2:J.mode=D5;break;case 3:W.msg="invalid block type",J.mode=i}P>>>=2,U-=2;break;case O5:P>>>=U&7,U-=U&7;while(U<32){if(q===0)break W;q--,P+=Q[X++]<<U,U+=8}if((P&65535)!==(P>>>16^65535)){W.msg="invalid stored block lengths",J.mode=i;break}if(J.length=P&65535,P=0,U=0,J.mode=d8,G===G8)break W;case d8:J.mode=I5;case I5:if(z=J.length,z){if(z>q)z=q;if(z>F)z=F;if(z===0)break W;V.set(Q.subarray(X,X+z),Y),q-=z,X+=z,F-=z,Y+=z,J.length-=z;break}J.mode=R0;break;case D5:while(U<14){if(q===0)break W;q--,P+=Q[X++]<<U,U+=8}if(J.nlen=(P&31)+257,P>>>=5,U-=5,J.ndist=(P&31)+1,P>>>=5,U-=5,J.ncode=(P&15)+4,P>>>=4,U-=4,J.nlen>286||J.ndist>30){W.msg="too many length or distance symbols",J.mode=i;break}J.have=0,J.mode=x5;case x5:while(J.have<J.ncode){while(U<3){if(q===0)break W;q--,P+=Q[X++]<<U,U+=8}J.lens[M[J.have++]]=P&7,P>>>=3,U-=3}while(J.have<19)J.lens[M[J.have++]]=0;if(J.lencode=J.lendyn,J.lenbits=7,Z={bits:J.lenbits},L=N1(o9,J.lens,0,19,J.lencode,0,J.work,Z),J.lenbits=Z.bits,L){W.msg="invalid code lengths set",J.mode=i;break}J.have=0,J.mode=w5;case w5:while(J.have<J.nlen+J.ndist){for(;;){if(g=J.lencode[P&(1<<J.lenbits)-1],y=g>>>24,E=g>>>16&255,p=g&65535,y<=U)break;if(q===0)break W;q--,P+=Q[X++]<<U,U+=8}if(p<16)P>>>=y,U-=y,J.lens[J.have++]=p;else{if(p===16){k=y+2;while(U<k){if(q===0)break W;q--,P+=Q[X++]<<U,U+=8}if(P>>>=y,U-=y,J.have===0){W.msg="invalid bit length repeat",J.mode=i;break}I=J.lens[J.have-1],z=3+(P&3),P>>>=2,U-=2}else if(p===17){k=y+3;while(U<k){if(q===0)break W;q--,P+=Q[X++]<<U,U+=8}P>>>=y,U-=y,I=0,z=3+(P&7),P>>>=3,U-=3}else{k=y+7;while(U<k){if(q===0)break W;q--,P+=Q[X++]<<U,U+=8}P>>>=y,U-=y,I=0,z=11+(P&127),P>>>=7,U-=7}if(J.have+z>J.nlen+J.ndist){W.msg="invalid bit length repeat",J.mode=i;break}while(z--)J.lens[J.have++]=I}}if(J.mode===i)break;if(J.lens[256]===0){W.msg="invalid code -- missing end-of-block",J.mode=i;break}if(J.lenbits=9,Z={bits:J.lenbits},L=N1(q7,J.lens,0,J.nlen,J.lencode,0,J.work,Z),J.lenbits=Z.bits,L){W.msg="invalid literal/lengths set",J.mode=i;break}if(J.distbits=6,J.distcode=J.distdyn,Z={bits:J.distbits},L=N1(P7,J.lens,J.nlen,J.ndist,J.distcode,0,J.work,Z),J.distbits=Z.bits,L){W.msg="invalid distances set",J.mode=i;break}if(J.mode=Q8,G===G8)break W;case Q8:J.mode=V8;case V8:if(q>=6&&F>=258){if(W.next_out=Y,W.avail_out=F,W.next_in=X,W.avail_in=q,J.hold=P,J.bits=U,d9(W,K),Y=W.next_out,V=W.output,F=W.avail_out,X=W.next_in,Q=W.input,q=W.avail_in,P=J.hold,U=J.bits,J.mode===R0)J.back=-1;break}J.back=0;for(;;){if(g=J.lencode[P&(1<<J.lenbits)-1],y=g>>>24,E=g>>>16&255,p=g&65535,y<=U)break;if(q===0)break W;q--,P+=Q[X++]<<U,U+=8}if(E&&(E&240)===0){x=y,f=E,d=p;for(;;){if(g=J.lencode[d+((P&(1<<x+f)-1)>>x)],y=g>>>24,E=g>>>16&255,p=g&65535,x+y<=U)break;if(q===0)break W;q--,P+=Q[X++]<<U,U+=8}P>>>=x,U-=x,J.back+=x}if(P>>>=y,U-=y,J.back+=y,J.length=p,E===0){J.mode=T5;break}if(E&32){J.back=-1,J.mode=R0;break}if(E&64){W.msg="invalid literal/length code",J.mode=i;break}J.extra=E&15,J.mode=N5;case N5:if(J.extra){k=J.extra;while(U<k){if(q===0)break W;q--,P+=Q[X++]<<U,U+=8}J.length+=P&(1<<J.extra)-1,P>>>=J.extra,U-=J.extra,J.back+=J.extra}J.was=J.length,J.mode=v5;case v5:for(;;){if(g=J.distcode[P&(1<<J.distbits)-1],y=g>>>24,E=g>>>16&255,p=g&65535,y<=U)break;if(q===0)break W;q--,P+=Q[X++]<<U,U+=8}if((E&240)===0){x=y,f=E,d=p;for(;;){if(g=J.distcode[d+((P&(1<<x+f)-1)>>x)],y=g>>>24,E=g>>>16&255,p=g&65535,x+y<=U)break;if(q===0)break W;q--,P+=Q[X++]<<U,U+=8}P>>>=x,U-=x,J.back+=x}if(P>>>=y,U-=y,J.back+=y,E&64){W.msg="invalid distance code",J.mode=i;break}J.offset=p,J.extra=E&15,J.mode=g5;case g5:if(J.extra){k=J.extra;while(U<k){if(q===0)break W;q--,P+=Q[X++]<<U,U+=8}J.offset+=P&(1<<J.extra)-1,P>>>=J.extra,U-=J.extra,J.back+=J.extra}if(J.offset>J.dmax){W.msg="invalid distance too far back",J.mode=i;break}J.mode=S5;case S5:if(F===0)break W;if(z=K-F,J.offset>z){if(z=J.offset-z,z>J.whave){if(J.sane){W.msg="invalid distance too far back",J.mode=i;break}}if(z>J.wnext)z-=J.wnext,$=J.wsize-z;else $=J.wnext-z;if(z>J.length)z=J.length;N=J.window}else N=V,$=Y-J.offset,z=J.length;if(z>F)z=F;F-=z,J.length-=z;do V[Y++]=N[$++];while(--z);if(J.length===0)J.mode=V8;break;case T5:if(F===0)break W;V[Y++]=J.length,F--,J.mode=V8;break;case c8:if(J.wrap){while(U<32){if(q===0)break W;q--,P|=Q[X++]<<U,U+=8}if(K-=F,W.total_out+=K,J.total+=K,J.wrap&4&&K)W.adler=J.check=J.flags?o(J.check,V,K,Y-K):A1(J.check,V,K,Y-K);if(K=F,J.wrap&4&&(J.flags?P:E5(P))!==J.check){W.msg="incorrect data check",J.mode=i;break}P=0,U=0}J.mode=A5;case A5:if(J.wrap&&J.flags){while(U<32){if(q===0)break W;q--,P+=Q[X++]<<U,U+=8}if(J.wrap&4&&P!==(J.total&4294967295)){W.msg="incorrect length check",J.mode=i;break}P=0,U=0}J.mode=y5;case y5:L=n9;break W;case i:L=U7;break W;case K7:return F7;case z7:default:return K0}if(W.next_out=Y,W.avail_out=F,W.next_in=X,W.avail_in=q,J.hold=P,J.bits=U,J.wsize||K!==W.avail_out&&J.mode<i&&(J.mode<c8||G!==z5)){if($7(W,W.output,W.next_out,K-W.avail_out));}if(C-=W.avail_in,K-=W.avail_out,W.total_in+=C,W.total_out+=K,J.total+=K,J.wrap&4&&K)W.adler=J.check=J.flags?o(J.check,V,K,W.next_out-K):A1(J.check,V,K,W.next_out-K);if(W.data_type=J.bits+(J.last?64:0)+(J.mode===R0?128:0)+(J.mode===Q8||J.mode===d8?256:0),(C===0&&K===0||G===z5)&&L===c0)L=e9;return L},qG=(W)=>{if(l0(W))return K0;let G=W.state;if(G.window)G.window=null;return W.state=null,c0},PG=(W,G)=>{if(l0(W))return K0;const J=W.state;if((J.wrap&2)===0)return K0;return J.head=G,G.done=!1,c0},UG=(W,G)=>{const J=G.length;let Q,V,X;if(l0(W))return K0;if(Q=W.state,Q.wrap!==0&&Q.mode!==P8)return K0;if(Q.mode===P8){if(V=1,V=A1(V,G,J,0),V!==Q.check)return U7}if(X=$7(W,G,J,J),X)return Q.mode=K7,F7;return Q.havedict=1,c0},FG=k7,KG=H7,zG=Z7,ZG=VG,kG=C7,HG=YG,CG=qG,$G=PG,jG=UG,BG="pako inflate (from Nodeca project)",O0={inflateReset:FG,inflateReset2:KG,inflateResetKeep:zG,inflateInit:ZG,inflateInit2:kG,inflate:HG,inflateEnd:CG,inflateGetHeader:$G,inflateSetDictionary:jG,inflateInfo:BG},RG=MG,j7=Object.prototype.toString,{Z_NO_FLUSH:LG,Z_FINISH:OG,Z_OK:p1,Z_STREAM_END:i8,Z_NEED_DICT:r8,Z_STREAM_ERROR:IG,Z_DATA_ERROR:f5,Z_MEM_ERROR:DG}=_0;m1.prototype.push=function(W,G){const J=this.strm,Q=this.options.chunkSize,V=this.options.dictionary;let X,Y,q;if(this.ended)return!1;if(G===~~G)Y=G;else Y=G===!0?OG:LG;if(j7.call(W)==="[object ArrayBuffer]")J.input=new Uint8Array(W);else J.input=W;J.next_in=0,J.avail_in=J.input.length;for(;;){if(J.avail_out===0)J.output=new Uint8Array(Q),J.next_out=0,J.avail_out=Q;if(X=O0.inflate(J,Y),X===r8&&V){if(X=O0.inflateSetDictionary(J,V),X===p1)X=O0.inflate(J,Y);else if(X===f5)X=r8}while(J.avail_in>0&&X===i8&&J.state.wrap>0&&W[J.next_in]!==0)O0.inflateReset(J),X=O0.inflate(J,Y);switch(X){case IG:case f5:case r8:case DG:return this.onEnd(X),this.ended=!0,!1}if(q=J.avail_out,J.next_out){if(J.avail_out===0||X===i8)if(this.options.to==="string"){let F=E1.utf8border(J.output,J.next_out),P=J.next_out-F,U=E1.buf2string(J.output,F);if(J.next_out=P,J.avail_out=Q-P,P)J.output.set(J.output.subarray(F,F+P),0);this.onData(U)}else this.onData(J.output.length===J.next_out?J.output:J.output.subarray(0,J.next_out))}if(X===p1&&q===0)continue;if(X===i8)return X=O0.inflateEnd(this.strm),this.onEnd(X),this.ended=!0,!0;if(J.avail_in===0)break}return!0};m1.prototype.onData=function(W){this.chunks.push(W)};m1.prototype.onEnd=function(W){if(W===p1)if(this.options.to==="string")this.result=this.chunks.join("");else this.result=F8.flattenChunks(this.chunks);this.chunks=[],this.err=W,this.msg=this.strm.msg};var wG=m1,NG=U6,vG=xG,gG=U6,SG=_0,TG={Inflate:wG,inflate:NG,inflateRaw:vG,ungzip:gG,constants:SG},{Deflate:AG,deflate:yG,deflateRaw:EG,gzip:pG}=m9,{Inflate:fG,inflate:hG,inflateRaw:bG,ungzip:mG}=TG,uG=AG,dG=yG,cG=EG,_G=pG,lG=fG,iG=hG,rG=bG,oG=mG,aG=_0,i0={Deflate:uG,deflate:dG,deflateRaw:cG,gzip:_G,Inflate:lG,inflate:iG,inflateRaw:rG,ungzip:oG,constants:aG};var w8=function(W){return W instanceof Uint8Array||ArrayBuffer.isView(W)&&W.constructor.name==="Uint8Array"},B6=function(W){if(!Number.isSafeInteger(W)||W<0)throw Error("positive integer expected, got "+W)},e0=function(W,...G){if(!w8(W))throw Error("Uint8Array expected");if(G.length>0&&!G.includes(W.length))throw Error("Uint8Array expected of length "+G+", got length="+W.length)},u7=function(W){if(typeof W!="function"||typeof W.create!="function")throw Error("Hash should be wrapped by utils.createHasher");B6(W.outputLen),B6(W.blockLen)},j8=function(W,G=!0){if(W.destroyed)throw Error("Hash instance has been destroyed");if(G&&W.finished)throw Error("Hash#digest() has already been called")},B8=function(...W){for(let G=0;G<W.length;G++)W[G].fill(0)},F6=function(W){return new DataView(W.buffer,W.byteOffset,W.byteLength)},j0=function(W,G){return W<<32-G|W>>>G},H1=function(W){if(e0(W),d7)return W.toHex();let G="";for(let J=0;J<W.length;J++)G+=nG[W[J]];return G},L7=function(W){return W>=B7&&W<=sG?W-B7:W>=M7&&W<=eG?W-(M7-10):W>=R7&&W<=tG?W-(R7-10):void 0},M8=function(W){if(typeof W!="string")throw Error("hex string expected, got "+typeof W);if(d7)return Uint8Array.fromHex(W);const G=W.length,J=G/2;if(G%2)throw Error("hex string expected, got unpadded hex of length "+G);const Q=new Uint8Array(J);for(let V=0,X=0;V<J;V++,X+=2){const Y=L7(W.charCodeAt(X)),q=L7(W.charCodeAt(X+1));if(Y===void 0||q===void 0){const F=W[X]+W[X+1];throw Error('hex string expected, got non-hex character "'+F+'" at index '+X)}Q[V]=16*Y+q}return Q},c7=function(W){if(typeof W!="string")throw Error("string expected");return new Uint8Array((new TextEncoder()).encode(W))},N6=function(W){return typeof W=="string"&&(W=c7(W)),e0(W),W},B0=function(...W){let G=0;for(let Q=0;Q<W.length;Q++){const V=W[Q];e0(V),G+=V.length}const J=new Uint8Array(G);for(let Q=0,V=0;Q<W.length;Q++){const X=W[Q];J.set(X,V),V+=X.length}return J},WQ=function(W){const G=(Q)=>W().update(N6(Q)).digest(),J=W();return G.outputLen=J.outputLen,G.blockLen=J.blockLen,G.create=()=>W(),G},R8=function(W=32){if(F1&&typeof F1.getRandomValues=="function")return F1.getRandomValues(new Uint8Array(W));if(F1&&typeof F1.randomBytes=="function")return Uint8Array.from(F1.randomBytes(W));throw Error("crypto.getRandomValues must be defined")},JQ=function(W,G,J){return W&G^W&J^G&J},L8=function(W,G=""){if(typeof W!="boolean")throw Error((G&&`"${G}"`)+"expected boolean, got type="+typeof W);return W},r0=function(W,G,J=""){const Q=w8(W),V=W?.length,X=G!==void 0;if(!Q||X&&V!==G)throw Error((J&&`"${J}" `)+"expected Uint8Array"+(X?" of length "+G:"")+", got "+(Q?"length="+V:"type="+typeof W));return W},z8=function(W){const G=W.toString(16);return 1&G.length?"0"+G:G},r7=function(W){if(typeof W!="string")throw Error("hex string expected, got "+typeof W);return W===""?S6:BigInt("0x"+W)},j1=function(W){return r7(H1(W))},o7=function(W){return e0(W),r7(H1(Uint8Array.from(W).reverse()))},N8=function(W,G){return M8(W.toString(16).padStart(2*G,"0"))},a7=function(W,G){return N8(W,G).reverse()},r=function(W,G,J){let Q;if(typeof G=="string")try{Q=M8(G)}catch(X){throw Error(W+" must be hex string or Uint8Array, cause: "+X)}else{if(!w8(G))throw Error(W+" must be hex string or Uint8Array");Q=Uint8Array.from(G)}const V=Q.length;if(typeof J=="number"&&V!==J)throw Error(W+" of length "+J+" expected, got "+V);return Q},L6=function(W,G,J){return K6(W)&&K6(G)&&K6(J)&&G<=W&&W<J},n7=function(W){let G;for(G=0;W>S6;W>>=R6,G+=1);return G},T6=function(W,G,J={}){if(!W||typeof W!="object")throw Error("expected valid options object");function Q(V,X,Y){const q=W[V];if(Y&&q===void 0)return;const F=typeof q;if(F!==X||q===null)throw Error(`param "${V}" is invalid: expected ${X}, got ${F}`)}Object.entries(G).forEach(([V,X])=>Q(V,X,!1)),Object.entries(J).forEach(([V,X])=>Q(V,X,!0))},O7=function(W){const G=new WeakMap;return(J,...Q)=>{const V=G.get(J);if(V!==void 0)return V;const X=W(J,...Q);return G.set(J,X),X}},Z0=function(W,G){const J=W%G;return J>=V0?J:G+J},z0=function(W,G,J){let Q=W;for(;G-- >V0;)Q*=Q,Q%=J;return Q},D7=function(W,G){if(W===V0)throw Error("invert: expected non-zero number");if(G<=V0)throw Error("invert: expected positive modulus, got "+G);let J=Z0(W,G),Q=G,V=V0,X=W0;for(;J!==V0;){const Y=Q%J,q=V-X*(Q/J);Q=J,J=Y,V=X,X=q}if(Q!==W0)throw Error("invert: does not exist");return Z0(V,G)},A6=function(W,G,J){if(!W.eql(W.sqr(G),J))throw Error("Cannot find square root")},JW=function(W,G){const J=(W.ORDER+W0)/e7,Q=W.pow(G,J);return A6(W,Q,G),Q},XQ=function(W,G){const J=(W.ORDER-t7)/WW,Q=W.mul(G,a0),V=W.pow(Q,J),X=W.mul(G,V),Y=W.mul(W.mul(X,a0),V),q=W.mul(X,W.sub(Y,W.ONE));return A6(W,q,G),q},x7=function(W){if(W<s7)throw Error("sqrt is not defined for small field");let G=W-W0,J=0;for(;G%a0===V0;)G/=a0,J++;let Q=a0;const V=i1(W);for(;w7(V,Q)===1;)if(Q++>1000)throw Error("Cannot find square root: probably non-prime P");if(J===1)return JW;let X=V.pow(Q,G);const Y=(G+W0)/a0;return function(q,F){if(q.is0(F))return F;if(w7(q,F)!==1)throw Error("Cannot find square root");let P=J,U=q.mul(q.ONE,X),C=q.pow(F,G),K=q.pow(F,Y);for(;!q.eql(C,q.ONE);){if(q.is0(C))return q.ZERO;let z=1,$=q.sqr(C);for(;!q.eql($,q.ONE);)if(z++,$=q.sqr($),z===P)throw Error("Cannot find square root");const N=W0<<BigInt(P-z-1),g=q.pow(U,N);P=z,U=q.sqr(g),C=q.mul(C,U),K=q.mul(K,g)}return K}},YQ=function(W){return W%e7===s7?JW:W%WW===t7?XQ:W%I7===VQ?function(G){const J=i1(G),Q=x7(G),V=Q(J,J.neg(J.ONE)),X=Q(J,V),Y=Q(J,J.neg(V)),q=(G+QQ)/I7;return(F,P)=>{let U=F.pow(P,q),C=F.mul(U,V);const K=F.mul(U,X),z=F.mul(U,Y),$=F.eql(F.sqr(C),P),N=F.eql(F.sqr(K),P);U=F.cmov(U,C,$),C=F.cmov(z,K,N);const g=F.eql(F.sqr(C),P),y=F.cmov(U,C,g);return A6(F,y,P),y}}(W):x7(W)},GW=function(W,G,J=!1){const Q=Array(G.length).fill(J?W.ZERO:void 0),V=G.reduce((Y,q,F)=>W.is0(q)?Y:(Q[F]=Y,W.mul(Y,q)),W.ONE),X=W.inv(V);return G.reduceRight((Y,q,F)=>W.is0(q)?Y:(Q[F]=W.mul(Y,Q[F]),W.mul(Y,q)),X),Q},w7=function(W,G){const J=(W.ORDER-W0)/a0,Q=W.pow(G,J),V=W.eql(Q,W.ONE),X=W.eql(Q,W.ZERO),Y=W.eql(Q,W.neg(W.ONE));if(!V&&!X&&!Y)throw Error("invalid Legendre symbol result");return V?1:X?0:-1},QW=function(W,G){G!==void 0&&B6(G);const J=G!==void 0?G:W.toString(2).length;return{nBitLength:J,nByteLength:Math.ceil(J/8)}},i1=function(W,G,J=!1,Q={}){if(W<=V0)throw Error("invalid field: expected ORDER > 0, got "+W);let V,X,Y,q=!1;if(typeof G=="object"&&G!=null){if(Q.sqrt||J)throw Error("cannot specify opts in two arguments");const K=G;K.BITS&&(V=K.BITS),K.sqrt&&(X=K.sqrt),typeof K.isLE=="boolean"&&(J=K.isLE),typeof K.modFromBytes=="boolean"&&(q=K.modFromBytes),Y=K.allowedLengths}else typeof G=="number"&&(V=G),Q.sqrt&&(X=Q.sqrt);const{nBitLength:F,nByteLength:P}=QW(W,V);if(P>2048)throw Error("invalid field: expected ORDER of <= 2048 bytes");let U;const C=Object.freeze({ORDER:W,isLE:J,BITS:F,BYTES:P,MASK:l1(F),ZERO:V0,ONE:W0,allowedLengths:Y,create(K){return Z0(K,W)},isValid(K){if(typeof K!="bigint")throw Error("invalid field element: expected bigint, got "+typeof K);return V0<=K&&K<W},is0(K){return K===V0},isValidNot0(K){return!C.is0(K)&&C.isValid(K)},isOdd(K){return(K&W0)===W0},neg(K){return Z0(-K,W)},eql(K,z){return K===z},sqr(K){return Z0(K*K,W)},add(K,z){return Z0(K+z,W)},sub(K,z){return Z0(K-z,W)},mul(K,z){return Z0(K*z,W)},pow(K,z){return function($,N,g){if(g<V0)throw Error("invalid exponent, negatives unsupported");if(g===V0)return $.ONE;if(g===W0)return N;let y=$.ONE,E=N;for(;g>V0;)g&W0&&(y=$.mul(y,E)),E=$.sqr(E),g>>=W0;return y}(C,K,z)},div(K,z){return Z0(K*D7(z,W),W)},sqrN(K){return K*K},addN(K,z){return K+z},subN(K,z){return K-z},mulN(K,z){return K*z},inv(K){return D7(K,W)},sqrt:X||((K)=>(U||(U=YQ(W)),U(C,K))),toBytes(K){return J?a7(K,P):N8(K,P)},fromBytes(K,z=!0){if(Y){if(!Y.includes(K.length)||K.length>P)throw Error("Field.fromBytes: expected "+Y+" bytes, got "+K.length);const N=new Uint8Array(P);N.set(K,J?0:N.length-K.length),K=N}if(K.length!==P)throw Error("Field.fromBytes: expected "+P+" bytes, got "+K.length);let $=J?o7(K):j1(K);if(q&&($=Z0($,W)),!z&&!C.isValid($))throw Error("invalid field element: outside of range 0..ORDER");return $},invertBatch(K){return GW(C,K)},cmov(K,z,$){return $?z:K}});return Object.freeze(C)},VW=function(W){if(typeof W!="bigint")throw Error("field order must be bigint");const G=W.toString(2).length;return Math.ceil(G/8)},XW=function(W){const G=VW(W);return G+Math.ceil(G/2)},YW=function(W,G,J=!1){const Q=W.length,V=VW(G),X=XW(G);if(Q<16||Q<X||Q>1024)throw Error("expected "+X+"-1024 bytes of input, got "+Q);const Y=Z0(J?o7(W):j1(W),G-W0)+W0;return J?a7(Y,V):N8(Y,V)},O8=function(W,G){const J=G.negate();return W?J:G},z6=function(W,G){const J=GW(W.Fp,G.map((Q)=>Q.Z));return G.map((Q,V)=>W.fromAffine(Q.toAffine(J[V])))},qW=function(W,G){if(!Number.isSafeInteger(W)||W<=0||W>G)throw Error("invalid window size, expected [1.."+G+"], got W="+W)},Z6=function(W,G){qW(W,G);const J=2**W;return{windows:Math.ceil(G/W)+1,windowSize:2**(W-1),mask:l1(W),maxNumber:J,shiftBy:BigInt(W)}},N7=function(W,G,J){const{windowSize:Q,mask:V,maxNumber:X,shiftBy:Y}=J;let q=Number(W&V),F=W>>Y;q>Q&&(q-=X,F+=n0);const P=G*Q;return{nextN:F,offset:P+Math.abs(q)-1,isZero:q===0,isNeg:q<0,isNegF:G%2!=0,offsetF:P}},H6=function(W){return PW.get(W)||1},v7=function(W){if(W!==C1)throw Error("invalid wNAF")},PQ=function(W,G,J,Q){(function(K,z){if(!Array.isArray(K))throw Error("array expected");K.forEach(($,N)=>{if(!($ instanceof z))throw Error("invalid point at index "+N)})})(J,W),function(K,z){if(!Array.isArray(K))throw Error("array of scalars expected");K.forEach(($,N)=>{if(!z.isValid($))throw Error("invalid scalar at index "+N)})}(Q,G);const V=J.length,X=Q.length;if(V!==X)throw Error("arrays of points and scalars must have equal length");const Y=W.ZERO,q=n7(BigInt(V));let F=1;q>12?F=q-3:q>4?F=q-2:q>0&&(F=2);const P=l1(F),U=Array(Number(P)+1).fill(Y);let C=Y;for(let K=Math.floor((G.BITS-1)/F)*F;K>=0;K-=F){U.fill(Y);for(let $=0;$<X;$++){const N=Q[$],g=Number(N>>BigInt(K)&P);U[g]=U[g].add(J[$])}let z=Y;for(let $=U.length-1,N=Y;$>0;$--)N=N.add(U[$]),z=z.add(N);if(C=C.add(z),K!==0)for(let $=0;$<F;$++)C=C.double()}return C},g7=function(W,G,J){if(G){if(G.ORDER!==W)throw Error("Field.ORDER must match order: Fp == p, Fn == n");return function(Q){T6(Q,qQ.reduce((V,X)=>(V[X]="function",V),{ORDER:"bigint",MASK:"bigint",BYTES:"number",BITS:"number"}))}(G),G}return i1(W,{isLE:J})},O6=function(W){if(!["compact","recovered","der"].includes(W))throw Error('Signature format must be "compact", "recovered", or "der"');return W},C6=function(W,G){const J={};for(let Q of Object.keys(G))J[Q]=W[Q]===void 0?G[Q]:W[Q];return L8(J.lowS,"lowS"),L8(J.prehash,"prehash"),J.format!==void 0&&O6(J.format),J},o0=function(W,G){const{BYTES:J}=W;let Q;if(typeof G=="bigint")Q=G;else{let V=r("private key",G);try{Q=W.fromBytes(V)}catch(X){throw Error(`invalid private key: expected ui8a of size ${J}, got ${typeof G}`)}}if(!W.isValidNot0(Q))throw Error("invalid private key: out of range [1..N-1]");return Q},FQ=function(W,G={}){const J=function(Z,k,M={},H){if(H===void 0&&(H=Z==="edwards"),!k||typeof k!="object")throw Error(`expected valid ${Z} CURVE object`);for(let D of["p","n","h"]){const B=k[D];if(!(typeof B=="bigint"&&B>C1))throw Error(`CURVE.${D} must be positive bigint`)}const j=g7(k.p,M.Fp,H),O=g7(k.n,M.Fn,H),R=["Gx","Gy","a","b"];for(let D of R)if(!j.isValid(k[D]))throw Error(`CURVE.${D} must be valid field element of CURVE.Fp`);return{CURVE:k=Object.freeze(Object.assign({},k)),Fp:j,Fn:O}}("weierstrass",W,G),{Fp:Q,Fn:V}=J;let X=J.CURVE;const{h:Y,n:q}=X;T6(G,{},{allowInfinityPoint:"boolean",clearCofactor:"function",isTorsionFree:"function",fromBytes:"function",toBytes:"function",endo:"object",wrapPrivateKey:"boolean"});const{endo:F}=G;if(F&&(!Q.is0(X.a)||typeof F.beta!="bigint"||!Array.isArray(F.basises)))throw Error('invalid endo: expected "beta": bigint and "basises": array');const P=zW(Q,V);function U(){if(!Q.isOdd)throw Error("compression is not supported: Field does not have .isOdd()")}const C=G.toBytes||function(Z,k,M){const{x:H,y:j}=k.toAffine(),O=Q.toBytes(H);if(L8(M,"isCompressed"),M)return U(),B0(KW(!Q.isOdd(j)),O);return B0(Uint8Array.of(4),O,Q.toBytes(j))},K=G.fromBytes||function(Z){r0(Z,void 0,"Point");const{publicKey:k,publicKeyUncompressed:M}=P,H=Z.length,j=Z[0],O=Z.subarray(1);if(H!==k||j!==2&&j!==3){if(H===M&&j===4){const R=Q.BYTES,D=Q.fromBytes(O.subarray(0,R)),B=Q.fromBytes(O.subarray(R,2*R));if(!$(D,B))throw Error("bad point: is not on curve");return{x:D,y:B}}throw Error(`bad point: got length ${H}, expected compressed=${k} or uncompressed=${M}`)}{const R=Q.fromBytes(O);if(!Q.isValid(R))throw Error("bad point: is not on curve, wrong x");const D=z(R);let B;try{B=Q.sqrt(D)}catch(v){const T=v instanceof Error?": "+v.message:"";throw Error("bad point: is not on curve, sqrt error"+T)}return U(),!(1&~j)!==Q.isOdd(B)&&(B=Q.neg(B)),{x:R,y:B}}};function z(Z){const k=Q.sqr(Z),M=Q.mul(k,Z);return Q.add(Q.add(M,Q.mul(Z,X.a)),X.b)}function $(Z,k){const M=Q.sqr(k),H=z(Z);return Q.eql(M,H)}if(!$(X.Gx,X.Gy))throw Error("bad curve params: generator point");const N=Q.mul(Q.pow(X.a,Z8),UQ),g=Q.mul(Q.sqr(X.b),BigInt(27));if(Q.is0(Q.add(N,g)))throw Error("bad curve params: a or b");function y(Z,k,M=!1){if(!Q.isValid(k)||M&&Q.is0(k))throw Error("bad point coordinate "+Z);return k}function E(Z){if(!(Z instanceof I))throw Error("ProjectivePoint expected")}function p(Z){if(!F||!F.basises)throw Error("no endo");return function(k,M,H){const[[j,O],[R,D]]=M,B=S7(D*k,H),v=S7(-O*k,H);let T=k-B*j-v*R,S=-B*O-v*D;const A=T<x0,h=S<x0;A&&(T=-T),h&&(S=-S);const b=l1(Math.ceil(n7(H)/2))+Z1;if(T<x0||T>=b||S<x0||S>=b)throw Error("splitScalar (endomorphism): failed, k="+k);return{k1neg:A,k1:T,k2neg:h,k2:S}}(Z,F.basises,V.ORDER)}const x=O7((Z,k)=>{const{X:M,Y:H,Z:j}=Z;if(Q.eql(j,Q.ONE))return{x:M,y:H};const O=Z.is0();k==null&&(k=O?Q.ONE:Q.inv(j));const R=Q.mul(M,k),D=Q.mul(H,k),B=Q.mul(j,k);if(O)return{x:Q.ZERO,y:Q.ZERO};if(!Q.eql(B,Q.ONE))throw Error("invZ was invalid");return{x:R,y:D}}),f=O7((Z)=>{if(Z.is0()){if(G.allowInfinityPoint&&!Q.is0(Z.Y))return;throw Error("bad point: ZERO")}const{x:k,y:M}=Z.toAffine();if(!Q.isValid(k)||!Q.isValid(M))throw Error("bad point: x or y not field elements");if(!$(k,M))throw Error("bad point: equation left != right");if(!Z.isTorsionFree())throw Error("bad point: not in prime-order subgroup");return!0});function d(Z,k,M,H,j){return M=new I(Q.mul(M.X,Z),M.Y,M.Z),k=O8(H,k),M=O8(j,M),k.add(M)}class I{constructor(Z,k,M){this.X=y("x",Z),this.Y=y("y",k,!0),this.Z=y("z",M),Object.freeze(this)}static CURVE(){return X}static fromAffine(Z){const{x:k,y:M}=Z||{};if(!Z||!Q.isValid(k)||!Q.isValid(M))throw Error("invalid affine point");if(Z instanceof I)throw Error("projective point not allowed");return Q.is0(k)&&Q.is0(M)?I.ZERO:new I(k,M,Q.ONE)}static fromBytes(Z){const k=I.fromAffine(K(r0(Z,void 0,"point")));return k.assertValidity(),k}static fromHex(Z){return I.fromBytes(r("pointHex",Z))}get x(){return this.toAffine().x}get y(){return this.toAffine().y}precompute(Z=8,k=!0){return w.createCache(this,Z),k||this.multiply(Z8),this}assertValidity(){f(this)}hasEvenY(){const{y:Z}=this.toAffine();if(!Q.isOdd)throw Error("Field doesn't support isOdd");return!Q.isOdd(Z)}equals(Z){E(Z);const{X:k,Y:M,Z:H}=this,{X:j,Y:O,Z:R}=Z,D=Q.eql(Q.mul(k,R),Q.mul(j,H)),B=Q.eql(Q.mul(M,R),Q.mul(O,H));return D&&B}negate(){return new I(this.X,Q.neg(this.Y),this.Z)}double(){const{a:Z,b:k}=X,M=Q.mul(k,Z8),{X:H,Y:j,Z:O}=this;let{ZERO:R,ZERO:D,ZERO:B}=Q,v=Q.mul(H,H),T=Q.mul(j,j),S=Q.mul(O,O),A=Q.mul(H,j);return A=Q.add(A,A),B=Q.mul(H,O),B=Q.add(B,B),R=Q.mul(Z,B),D=Q.mul(M,S),D=Q.add(R,D),R=Q.sub(T,D),D=Q.add(T,D),D=Q.mul(R,D),R=Q.mul(A,R),B=Q.mul(M,B),S=Q.mul(Z,S),A=Q.sub(v,S),A=Q.mul(Z,A),A=Q.add(A,B),B=Q.add(v,v),v=Q.add(B,v),v=Q.add(v,S),v=Q.mul(v,A),D=Q.add(D,v),S=Q.mul(j,O),S=Q.add(S,S),v=Q.mul(S,A),R=Q.sub(R,v),B=Q.mul(S,T),B=Q.add(B,B),B=Q.add(B,B),new I(R,D,B)}add(Z){E(Z);const{X:k,Y:M,Z:H}=this,{X:j,Y:O,Z:R}=Z;let{ZERO:D,ZERO:B,ZERO:v}=Q;const T=X.a,S=Q.mul(X.b,Z8);let A=Q.mul(k,j),h=Q.mul(M,O),b=Q.mul(H,R),m=Q.add(k,M),_=Q.add(j,O);m=Q.mul(m,_),_=Q.add(A,h),m=Q.sub(m,_),_=Q.add(k,H);let l=Q.add(j,R);return _=Q.mul(_,l),l=Q.add(A,b),_=Q.sub(_,l),l=Q.add(M,H),D=Q.add(O,R),l=Q.mul(l,D),D=Q.add(h,b),l=Q.sub(l,D),v=Q.mul(T,_),D=Q.mul(S,b),v=Q.add(D,v),D=Q.sub(h,v),v=Q.add(h,v),B=Q.mul(D,v),h=Q.add(A,A),h=Q.add(h,A),b=Q.mul(T,b),_=Q.mul(S,_),h=Q.add(h,b),b=Q.sub(A,b),b=Q.mul(T,b),_=Q.add(_,b),A=Q.mul(h,_),B=Q.add(B,A),A=Q.mul(l,_),D=Q.mul(m,D),D=Q.sub(D,A),A=Q.mul(m,h),v=Q.mul(l,v),v=Q.add(v,A),new I(D,B,v)}subtract(Z){return this.add(Z.negate())}is0(){return this.equals(I.ZERO)}multiply(Z){const{endo:k}=G;if(!V.isValidNot0(Z))throw Error("invalid scalar: out of range");let M,H;const j=(O)=>w.cached(this,O,(R)=>z6(I,R));if(k){const{k1neg:O,k1:R,k2neg:D,k2:B}=p(Z),{p:v,f:T}=j(R),{p:S,f:A}=j(B);H=T.add(A),M=d(k.beta,v,S,O,D)}else{const{p:O,f:R}=j(Z);M=O,H=R}return z6(I,[M,H])[0]}multiplyUnsafe(Z){const{endo:k}=G,M=this;if(!V.isValid(Z))throw Error("invalid scalar: out of range");if(Z===x0||M.is0())return I.ZERO;if(Z===Z1)return M;if(w.hasCache(this))return this.multiply(Z);if(k){const{k1neg:H,k1:j,k2neg:O,k2:R}=p(Z),{p1:D,p2:B}=function(v,T,S,A){let h=T,b=v.ZERO,m=v.ZERO;for(;S>C1||A>C1;)S&n0&&(b=b.add(h)),A&n0&&(m=m.add(h)),h=h.double(),S>>=n0,A>>=n0;return{p1:b,p2:m}}(I,M,j,R);return d(k.beta,D,B,H,O)}return w.unsafe(M,Z)}multiplyAndAddUnsafe(Z,k,M){const H=this.multiplyUnsafe(k).add(Z.multiplyUnsafe(M));return H.is0()?void 0:H}toAffine(Z){return x(this,Z)}isTorsionFree(){const{isTorsionFree:Z}=G;return Y===Z1||(Z?Z(I,this):w.unsafe(this,q).is0())}clearCofactor(){const{clearCofactor:Z}=G;return Y===Z1?this:Z?Z(I,this):this.multiplyUnsafe(Y)}isSmallOrder(){return this.multiplyUnsafe(Y).is0()}toBytes(Z=!0){return L8(Z,"isCompressed"),this.assertValidity(),C(I,this,Z)}toHex(Z=!0){return H1(this.toBytes(Z))}toString(){return`<Point ${this.is0()?"ZERO":this.toHex()}>`}get px(){return this.X}get py(){return this.X}get pz(){return this.Z}toRawBytes(Z=!0){return this.toBytes(Z)}_setWindowSize(Z){this.precompute(Z)}static normalizeZ(Z){return z6(I,Z)}static msm(Z,k){return PQ(I,V,Z,k)}static fromPrivateKey(Z){return I.BASE.multiply(o0(V,Z))}}I.BASE=new I(X.Gx,X.Gy,Q.ONE),I.ZERO=new I(Q.ZERO,Q.ONE,Q.ZERO),I.Fp=Q,I.Fn=V;const L=V.BITS,w=new UW(I,G.endo?Math.ceil(L/2):L);return I.BASE.precompute(8),I},KW=function(W){return Uint8Array.of(W?2:3)},zW=function(W,G){return{secretKey:G.BYTES,publicKey:1+W.BYTES,publicKeyUncompressed:1+2*W.BYTES,publicKeyHasPrefix:!0,signature:2*G.BYTES}},KQ=function(W,G,J={}){u7(G),T6(J,{},{hmac:"function",lowS:"boolean",randomBytes:"function",bits2int:"function",bits2int_modN:"function"});const Q=J.randomBytes||R8,V=J.hmac||((L,...w)=>i7(G,L,B0(...w))),{Fp:X,Fn:Y}=W,{ORDER:q,BITS:F}=Y,{keygen:P,getPublicKey:U,getSharedSecret:C,utils:K,lengths:z}=function(L,w={}){const{Fn:Z}=L,k=w.randomBytes||R8,M=Object.assign(zW(L.Fp,Z),{seed:XW(Z.ORDER)});function H(B){try{return!!o0(Z,B)}catch(v){return!1}}function j(B=k(M.seed)){return YW(r0(B,M.seed,"seed"),Z.ORDER)}function O(B,v=!0){return L.BASE.multiply(o0(Z,B)).toBytes(v)}function R(B){if(typeof B=="bigint")return!1;if(B instanceof L)return!0;const{secretKey:v,publicKey:T,publicKeyUncompressed:S}=M;if(Z.allowedLengths||v===T)return;const A=r("key",B).length;return A===T||A===S}return Object.freeze({getPublicKey:O,getSharedSecret(B,v,T=!0){if(R(B)===!0)throw Error("first arg must be private key");if(R(v)===!1)throw Error("second arg must be public key");const S=o0(Z,B);return L.fromHex(v).multiply(S).toBytes(T)},keygen(B){const v=j(B);return{secretKey:v,publicKey:O(v)}},Point:L,utils:{isValidSecretKey:H,isValidPublicKey(B,v){const{publicKey:T,publicKeyUncompressed:S}=M;try{const A=B.length;return!(v===!0&&A!==T||v===!1&&A!==S||!L.fromBytes(B))}catch(A){return!1}},randomSecretKey:j,isValidPrivateKey:H,randomPrivateKey:j,normPrivateKeyToScalar:(B)=>o0(Z,B),precompute(B=8,v=L.BASE){return v.precompute(B,!1)}},lengths:M})}(W,J),$={prehash:!1,lowS:typeof J.lowS=="boolean"&&J.lowS,format:void 0,extraEntropy:!1},N="compact";function g(L){return L>q>>Z1}function y(L,w){if(!Y.isValidNot0(w))throw Error(`invalid signature ${L}: out of range 1..Point.Fn.ORDER`);return w}class E{constructor(L,w,Z){this.r=y("r",L),this.s=y("s",w),Z!=null&&(this.recovery=Z),Object.freeze(this)}static fromBytes(L,w=N){let Z;if(function(j,O){O6(O);const R=z.signature;r0(j,O==="compact"?R:O==="recovered"?R+1:void 0,O+" signature")}(L,w),w==="der"){const{r:j,s:O}=D0.toSig(r0(L));return new E(j,O)}w==="recovered"&&(Z=L[0],w="compact",L=L.subarray(1));const k=Y.BYTES,M=L.subarray(0,k),H=L.subarray(k,2*k);return new E(Y.fromBytes(M),Y.fromBytes(H),Z)}static fromHex(L,w){return this.fromBytes(M8(L),w)}addRecoveryBit(L){return new E(this.r,this.s,L)}recoverPublicKey(L){const w=X.ORDER,{r:Z,s:k,recovery:M}=this;if(M==null||![0,1,2,3].includes(M))throw Error("recovery id invalid");if(q*FW<w&&M>1)throw Error("recovery id is ambiguous for h>1 curve");const H=M===2||M===3?Z+q:Z;if(!X.isValid(H))throw Error("recovery id 2 or 3 invalid");const j=X.toBytes(H),O=W.fromBytes(B0(KW(!(1&M)),j)),R=Y.inv(H),D=x(r("msgHash",L)),B=Y.create(-D*R),v=Y.create(k*R),T=W.BASE.multiplyUnsafe(B).add(O.multiplyUnsafe(v));if(T.is0())throw Error("point at infinify");return T.assertValidity(),T}hasHighS(){return g(this.s)}toBytes(L=N){if(O6(L),L==="der")return M8(D0.hexFromSig(this));const w=Y.toBytes(this.r),Z=Y.toBytes(this.s);if(L==="recovered"){if(this.recovery==null)throw Error("recovery bit must be present");return B0(Uint8Array.of(this.recovery),w,Z)}return B0(w,Z)}toHex(L){return H1(this.toBytes(L))}assertValidity(){}static fromCompact(L){return E.fromBytes(r("sig",L),"compact")}static fromDER(L){return E.fromBytes(r("sig",L),"der")}normalizeS(){return this.hasHighS()?new E(this.r,Y.neg(this.s),this.recovery):this}toDERRawBytes(){return this.toBytes("der")}toDERHex(){return H1(this.toBytes("der"))}toCompactRawBytes(){return this.toBytes("compact")}toCompactHex(){return H1(this.toBytes("compact"))}}const p=J.bits2int||function(L){if(L.length>8192)throw Error("input is too large");const w=j1(L),Z=8*L.length-F;return Z>0?w>>BigInt(Z):w},x=J.bits2int_modN||function(L){return Y.create(p(L))},f=l1(F);function d(L){return function(w,Z,k,M){if(!L6(Z,k,M))throw Error("expected valid "+w+": "+k+" <= n < "+M+", got "+Z)}("num < 2^"+F,L,x0,f),Y.toBytes(L)}function I(L,w){return r0(L,void 0,"message"),w?r0(G(L),void 0,"prehashed message"):L}return Object.freeze({keygen:P,getPublicKey:U,getSharedSecret:C,utils:K,lengths:z,Point:W,sign(L,w,Z={}){L=r("message",L);const{seed:k,k2sig:M}=function(H,j,O){if(["recovered","canonical"].some((b)=>(b in O)))throw Error("sign() legacy options not supported");const{lowS:R,prehash:D,extraEntropy:B}=C6(O,$);H=I(H,D);const v=x(H),T=o0(Y,j),S=[d(T),d(v)];if(B!=null&&B!==!1){const b=B===!0?Q(z.secretKey):B;S.push(r("extraEntropy",b))}const A=B0(...S),h=v;return{seed:A,k2sig(b){const m=p(b);if(!Y.isValidNot0(m))return;const _=Y.inv(m),l=W.BASE.multiply(m).toAffine(),M0=Y.create(l.x);if(M0===x0)return;const J0=Y.create(_*Y.create(h+M0*T));if(J0===x0)return;let P0=(l.x===M0?0:2)|Number(l.y&Z1),U0=J0;return R&&g(J0)&&(U0=Y.neg(J0),P0^=1),new E(M0,U0,P0)}}}(L,w,Z);return function(H,j,O){if(typeof H!="number"||H<2)throw Error("hashLen must be a number");if(typeof j!="number"||j<2)throw Error("qByteLen must be a number");if(typeof O!="function")throw Error("hmacFn must be a function");const R=(m)=>new Uint8Array(m),D=(m)=>Uint8Array.of(m);let B=R(H),v=R(H),T=0;const S=()=>{B.fill(1),v.fill(0),T=0},A=(...m)=>O(v,B,...m),h=(m=R(0))=>{v=A(D(0),m),B=A(),m.length!==0&&(v=A(D(1),m),B=A())},b=()=>{if(T++>=1000)throw Error("drbg: tried 1000 values");let m=0;const _=[];for(;m<j;){B=A();const l=B.slice();_.push(l),m+=B.length}return B0(..._)};return(m,_)=>{let l;for(S(),h(m);!(l=_(b()));)h();return S(),l}}(G.outputLen,Y.BYTES,V)(k,M)},verify(L,w,Z,k={}){const{lowS:M,prehash:H,format:j}=C6(k,$);if(Z=r("publicKey",Z),w=I(r("message",w),H),("strict"in k))throw Error("options.strict was renamed to lowS");const O=j===void 0?function(R){let D;const B=typeof R=="string"||w8(R),v=!B&&R!==null&&typeof R=="object"&&typeof R.r=="bigint"&&typeof R.s=="bigint";if(!B&&!v)throw Error("invalid signature, expected Uint8Array, hex string or Signature instance");if(v)D=new E(R.r,R.s);else if(B){try{D=E.fromBytes(r("sig",R),"der")}catch(T){if(!(T instanceof D0.Err))throw T}if(!D)try{D=E.fromBytes(r("sig",R),"compact")}catch(T){return!1}}return D||!1}(L):E.fromBytes(r("sig",L),j);if(O===!1)return!1;try{const R=W.fromBytes(Z);if(M&&O.hasHighS())return!1;const{r:D,s:B}=O,v=x(w),T=Y.inv(B),S=Y.create(v*T),A=Y.create(D*T),h=W.BASE.multiplyUnsafe(S).add(R.multiplyUnsafe(A));if(h.is0())return!1;return Y.create(h.x)===D}catch(R){return!1}},recoverPublicKey(L,w,Z={}){const{prehash:k}=C6(Z,$);return w=I(w,k),E.fromBytes(L,"recovered").recoverPublicKey(w).toBytes()},Signature:E,hash:G})},zQ=function(W){const{CURVE:G,curveOpts:J}=function(V){const X={a:V.a,b:V.b,p:V.Fp.ORDER,n:V.n,h:V.h,Gx:V.Gx,Gy:V.Gy},Y=V.Fp;let q=V.allowedPrivateKeyLengths?Array.from(new Set(V.allowedPrivateKeyLengths.map((F)=>Math.ceil(F/2)))):void 0;return{CURVE:X,curveOpts:{Fp:Y,Fn:i1(X.n,{BITS:V.nBitLength,allowedLengths:q,modFromBytes:V.wrapPrivateKey}),allowInfinityPoint:V.allowInfinityPoint,endo:V.endo,isTorsionFree:V.isTorsionFree,clearCofactor:V.clearCofactor,fromBytes:V.fromBytes,toBytes:V.toBytes}}}(W),Q={hmac:W.hmac,randomBytes:W.randomBytes,lowS:W.lowS,bits2int:W.bits2int,bits2int_modN:W.bits2int_modN};return{CURVE:G,curveOpts:J,hash:W.hash,ecdsaOpts:Q}},ZQ=function(W){const{CURVE:G,curveOpts:J,hash:Q,ecdsaOpts:V}=zQ(W);return function(X,Y){const q=Y.Point;return Object.assign({},Y,{ProjectivePoint:q,CURVE:Object.assign({},X,QW(q.Fn.ORDER,q.Fn.BITS))})}(W,KQ(FQ(G,J),Q,V))},D8=function(W,...G){let J=A7[W];if(J===void 0){const Q=M6(c7(W));J=B0(Q,Q),A7[W]=J}return M6(B0(J,...G))},D6=function(W){const{Fn:G,BASE:J}=B1,Q=o0(G,W),V=J.multiply(Q);return{scalar:E6(V.y)?Q:G.neg(Q),bytes:y6(V)}},kW=function(W){const G=I8;if(!G.isValidNot0(W))throw Error("invalid x: Fail if x \u2265 p");const J=G.create(W*W),Q=G.create(J*W+BigInt(7));let V=G.sqrt(Q);E6(V)||(V=G.neg(V));const X=B1.fromAffine({x:W,y:V});return X.assertValidity(),X},HW=function(...W){return B1.Fn.create(_1(D8("BIP0340/challenge",...W)))},y7=function(W){return D6(W).bytes},CQ=function(W,G,J=R8(32)){const{Fn:Q}=B1,V=r("message",W),{bytes:X,scalar:Y}=D6(G),q=r("auxRand",J,32),F=Q.toBytes(Y^_1(D8("BIP0340/aux",q))),P=D8("BIP0340/nonce",F,X,V),{bytes:U,scalar:C}=D6(P),K=HW(U,X,V),z=new Uint8Array(64);if(z.set(U,0),z.set(Q.toBytes(Q.create(C+K*Y)),32),!CW(z,V,X))throw Error("sign: Invalid signature produced");return z},CW=function(W,G,J){const{Fn:Q,BASE:V}=B1,X=r("signature",W,64),Y=r("message",G),q=r("publicKey",J,32);try{const F=kW(_1(q)),P=_1(X.subarray(0,32));if(!L6(P,T7,$1.p))return!1;const U=_1(X.subarray(32,64));if(!L6(U,T7,$1.n))return!1;const C=HW(Q.toBytes(P),y6(F),Y),K=V.multiplyUnsafe(U).add(F.multiplyUnsafe(Q.neg(C))),{x:z,y:$}=K.toAffine();return!(K.is0()||!E6($)||z!==P)}catch(F){return!1}},F1=typeof globalThis=="object"&&("crypto"in globalThis)?globalThis.crypto:void 0,d7=(()=>typeof Uint8Array.from([]).toHex=="function"&&typeof Uint8Array.fromHex=="function")(),nG=Array.from({length:256},(W,G)=>G.toString(16).padStart(2,"0")),B7=48,sG=57,M7=65,eG=70,R7=97,tG=102;class v6{}class _7 extends v6{constructor(W,G,J,Q){super(),this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.blockLen=W,this.outputLen=G,this.padOffset=J,this.isLE=Q,this.buffer=new Uint8Array(W),this.view=F6(this.buffer)}update(W){j8(this),e0(W=N6(W));const{view:G,buffer:J,blockLen:Q}=this,V=W.length;for(let X=0;X<V;){const Y=Math.min(Q-this.pos,V-X);if(Y!==Q)J.set(W.subarray(X,X+Y),this.pos),this.pos+=Y,X+=Y,this.pos===Q&&(this.process(G,0),this.pos=0);else{const q=F6(W);for(;Q<=V-X;X+=Q)this.process(q,X)}}return this.length+=W.length,this.roundClean(),this}digestInto(W){j8(this),function(U,C){e0(U);const K=C.outputLen;if(U.length<K)throw Error("digestInto() expects output buffer of length at least "+K)}(W,this),this.finished=!0;const{buffer:G,view:J,blockLen:Q,isLE:V}=this;let{pos:X}=this;G[X++]=128,B8(this.buffer.subarray(X)),this.padOffset>Q-X&&(this.process(J,0),X=0);for(let U=X;U<Q;U++)G[U]=0;(function(U,C,K,z){if(typeof U.setBigUint64=="function")return U.setBigUint64(C,K,z);const $=BigInt(32),N=BigInt(4294967295),g=Number(K>>$&N),y=Number(K&N),E=z?4:0,p=z?0:4;U.setUint32(C+E,g,z),U.setUint32(C+p,y,z)})(J,Q-8,BigInt(8*this.length),V),this.process(J,0);const Y=F6(W),q=this.outputLen;if(q%4)throw Error("_sha2: outputLen should be aligned to 32bit");const F=q/4,P=this.get();if(F>P.length)throw Error("_sha2: outputLen bigger than state");for(let U=0;U<F;U++)Y.setUint32(4*U,P[U],V)}digest(){const{buffer:W,outputLen:G}=this;this.digestInto(W);const J=W.slice(0,G);return this.destroy(),J}_cloneInto(W){W||(W=new this.constructor),W.set(...this.get());const{blockLen:G,buffer:J,length:Q,finished:V,destroyed:X,pos:Y}=this;return W.destroyed=X,W.finished=V,W.length=Q,W.pos=Y,Q%G&&W.buffer.set(J),W}clone(){return this._cloneInto()}}var E0=Uint32Array.from([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),GQ=Uint32Array.from([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),p0=new Uint32Array(64);class l7 extends _7{constructor(W=32){super(64,W,8,!1),this.A=0|E0[0],this.B=0|E0[1],this.C=0|E0[2],this.D=0|E0[3],this.E=0|E0[4],this.F=0|E0[5],this.G=0|E0[6],this.H=0|E0[7]}get(){const{A:W,B:G,C:J,D:Q,E:V,F:X,G:Y,H:q}=this;return[W,G,J,Q,V,X,Y,q]}set(W,G,J,Q,V,X,Y,q){this.A=0|W,this.B=0|G,this.C=0|J,this.D=0|Q,this.E=0|V,this.F=0|X,this.G=0|Y,this.H=0|q}process(W,G){for(let C=0;C<16;C++,G+=4)p0[C]=W.getUint32(G,!1);for(let C=16;C<64;C++){const K=p0[C-15],z=p0[C-2],$=j0(K,7)^j0(K,18)^K>>>3,N=j0(z,17)^j0(z,19)^z>>>10;p0[C]=N+p0[C-7]+$+p0[C-16]|0}let{A:J,B:Q,C:V,D:X,E:Y,F:q,G:F,H:P}=this;for(let C=0;C<64;C++){const K=P+(j0(Y,6)^j0(Y,11)^j0(Y,25))+((U=Y)&q^~U&F)+GQ[C]+p0[C]|0,z=(j0(J,2)^j0(J,13)^j0(J,22))+JQ(J,Q,V)|0;P=F,F=q,q=Y,Y=X+K|0,X=V,V=Q,Q=J,J=K+z|0}var U;J=J+this.A|0,Q=Q+this.B|0,V=V+this.C|0,X=X+this.D|0,Y=Y+this.E|0,q=q+this.F|0,F=F+this.G|0,P=P+this.H|0,this.set(J,Q,V,X,Y,q,F,P)}roundClean(){B8(p0)}destroy(){this.set(0,0,0,0,0,0,0,0),B8(this.buffer)}}var M6=WQ(()=>new l7);class g6 extends v6{constructor(W,G){super(),this.finished=!1,this.destroyed=!1,u7(W);const J=N6(G);if(this.iHash=W.create(),typeof this.iHash.update!="function")throw Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const Q=this.blockLen,V=new Uint8Array(Q);V.set(J.length>Q?W.create().update(J).digest():J);for(let X=0;X<V.length;X++)V[X]^=54;this.iHash.update(V),this.oHash=W.create();for(let X=0;X<V.length;X++)V[X]^=106;this.oHash.update(V),B8(V)}update(W){return j8(this),this.iHash.update(W),this}digestInto(W){j8(this),e0(W,this.outputLen),this.finished=!0,this.iHash.digestInto(W),this.oHash.update(W),this.oHash.digestInto(W),this.destroy()}digest(){const W=new Uint8Array(this.oHash.outputLen);return this.digestInto(W),W}_cloneInto(W){W||(W=Object.create(Object.getPrototypeOf(this),{}));const{oHash:G,iHash:J,finished:Q,destroyed:V,blockLen:X,outputLen:Y}=this;return W.finished=Q,W.destroyed=V,W.blockLen=X,W.outputLen=Y,W.oHash=G._cloneInto(W.oHash),W.iHash=J._cloneInto(W.iHash),W}clone(){return this._cloneInto()}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}var i7=(W,G,J)=>new g6(W,G).update(J).digest();i7.create=(W,G)=>new g6(W,G);var S6=BigInt(0),R6=BigInt(1),K6=(W)=>typeof W=="bigint"&&S6<=W,l1=(W)=>(R6<<BigInt(W))-R6,V0=BigInt(0),W0=BigInt(1),a0=BigInt(2),s7=BigInt(3),e7=BigInt(4),t7=BigInt(5),QQ=BigInt(7),WW=BigInt(8),VQ=BigInt(9),I7=BigInt(16),qQ=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"],C1=BigInt(0),n0=BigInt(1),k6=new WeakMap,PW=new WeakMap;class UW{constructor(W,G){this.BASE=W.BASE,this.ZERO=W.ZERO,this.Fn=W.Fn,this.bits=G}_unsafeLadder(W,G,J=this.ZERO){let Q=W;for(;G>C1;)G&n0&&(J=J.add(Q)),Q=Q.double(),G>>=n0;return J}precomputeWindow(W,G){const{windows:J,windowSize:Q}=Z6(G,this.bits),V=[];let X=W,Y=X;for(let q=0;q<J;q++){Y=X,V.push(Y);for(let F=1;F<Q;F++)Y=Y.add(X),V.push(Y);X=Y.double()}return V}wNAF(W,G,J){if(!this.Fn.isValid(J))throw Error("invalid scalar");let Q=this.ZERO,V=this.BASE;const X=Z6(W,this.bits);for(let Y=0;Y<X.windows;Y++){const{nextN:q,offset:F,isZero:P,isNeg:U,isNegF:C,offsetF:K}=N7(J,Y,X);J=q,P?V=V.add(O8(C,G[K])):Q=Q.add(O8(U,G[F]))}return v7(J),{p:Q,f:V}}wNAFUnsafe(W,G,J,Q=this.ZERO){const V=Z6(W,this.bits);for(let X=0;X<V.windows&&J!==C1;X++){const{nextN:Y,offset:q,isZero:F,isNeg:P}=N7(J,X,V);if(J=Y,!F){const U=G[q];Q=Q.add(P?U.negate():U)}}return v7(J),Q}getPrecomputes(W,G,J){let Q=k6.get(G);return Q||(Q=this.precomputeWindow(G,W),W!==1&&(typeof J=="function"&&(Q=J(Q)),k6.set(G,Q))),Q}cached(W,G,J){const Q=H6(W);return this.wNAF(Q,this.getPrecomputes(Q,W,J),G)}unsafe(W,G,J,Q){const V=H6(W);return V===1?this._unsafeLadder(W,G,Q):this.wNAFUnsafe(V,this.getPrecomputes(V,W,J),G,Q)}createCache(W,G){qW(G,this.bits),PW.set(W,G),k6.delete(W)}hasCache(W){return H6(W)!==1}}var S7=(W,G)=>(W+(W>=0?G:-G)/FW)/G,D0={Err:class extends Error{constructor(W=""){super(W)}},_tlv:{encode(W,G){const{Err:J}=D0;if(W<0||W>256)throw new J("tlv.encode: wrong tag");if(1&G.length)throw new J("tlv.encode: unpadded data");const Q=G.length/2,V=z8(Q);if(V.length/2&128)throw new J("tlv.encode: long form length too big");const X=Q>127?z8(V.length/2|128):"";return z8(W)+X+V+G},decode(W,G){const{Err:J}=D0;let Q=0;if(W<0||W>256)throw new J("tlv.encode: wrong tag");if(G.length<2||G[Q++]!==W)throw new J("tlv.decode: wrong tlv");const V=G[Q++];let X=0;if(128&V){const q=127&V;if(!q)throw new J("tlv.decode(long): indefinite length not supported");if(q>4)throw new J("tlv.decode(long): byte length is too big");const F=G.subarray(Q,Q+q);if(F.length!==q)throw new J("tlv.decode: length bytes not complete");if(F[0]===0)throw new J("tlv.decode(long): zero leftmost byte");for(let P of F)X=X<<8|P;if(Q+=q,X<128)throw new J("tlv.decode(long): not minimal encoding")}else X=V;const Y=G.subarray(Q,Q+X);if(Y.length!==X)throw new J("tlv.decode: wrong value length");return{v:Y,l:G.subarray(Q+X)}}},_int:{encode(W){const{Err:G}=D0;if(W<x0)throw new G("integer: negative integers are not allowed");let J=z8(W);if(8&Number.parseInt(J[0],16)&&(J="00"+J),1&J.length)throw new G("unexpected DER parsing assertion: unpadded hex");return J},decode(W){const{Err:G}=D0;if(128&W[0])throw new G("invalid signature integer: negative");if(W[0]===0&&!(128&W[1]))throw new G("invalid signature integer: unnecessary leading zero");return j1(W)}},toSig(W){const{Err:G,_int:J,_tlv:Q}=D0,V=r("signature",W),{v:X,l:Y}=Q.decode(48,V);if(Y.length)throw new G("invalid signature: left bytes after parsing");const{v:q,l:F}=Q.decode(2,X),{v:P,l:U}=Q.decode(2,F);if(U.length)throw new G("invalid signature: left bytes after parsing");return{r:J.decode(q),s:J.decode(P)}},hexFromSig(W){const{_tlv:G,_int:J}=D0,Q=G.encode(2,J.encode(W.r))+G.encode(2,J.encode(W.s));return G.encode(48,Q)}},x0=BigInt(0),Z1=BigInt(1),FW=BigInt(2),Z8=BigInt(3),UQ=BigInt(4),$1={p:BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),n:BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),h:BigInt(1),a:BigInt(0),b:BigInt(7),Gx:BigInt("0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),Gy:BigInt("0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8")},kQ={beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),basises:[[BigInt("0x3086d221a7d46bcde86c90e49284eb15"),-BigInt("0xe4437ed6010e88286f547fa90abfe4c3")],[BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),BigInt("0x3086d221a7d46bcde86c90e49284eb15")]]},HQ=BigInt(0),T7=BigInt(1),I6=BigInt(2),I8=i1($1.p,{sqrt(W){const G=$1.p,J=BigInt(3),Q=BigInt(6),V=BigInt(11),X=BigInt(22),Y=BigInt(23),q=BigInt(44),F=BigInt(88),P=W*W*W%G,U=P*P*W%G,C=z0(U,J,G)*U%G,K=z0(C,J,G)*U%G,z=z0(K,I6,G)*P%G,$=z0(z,V,G)*z%G,N=z0($,X,G)*$%G,g=z0(N,q,G)*N%G,y=z0(g,F,G)*g%G,E=z0(y,q,G)*N%G,p=z0(E,J,G)*U%G,x=z0(p,Y,G)*$%G,f=z0(x,Q,G)*P%G,d=z0(f,I6,G);if(!I8.eql(I8.sqr(d),W))throw Error("Cannot find square root");return d}}),ZW=function(W,G){const J=(Q)=>ZQ({...W,hash:Q});return{...J(G),create:J}}({...$1,Fp:I8,lowS:!0,endo:kQ},M6),A7={},y6=(W)=>W.toBytes(!0).slice(1),B1=(()=>ZW.Point)(),E6=(W)=>W%I6===HQ,_1=j1,p6=(()=>{const W=(G=R8(48))=>YW(G,$1.n);return ZW.utils.randomSecretKey,{keygen(G){const J=W(G);return{secretKey:J,publicKey:y7(J)}},getPublicKey:y7,sign:CQ,verify:CW,Point:B1,utils:{randomSecretKey:W,randomPrivateKey:W,taggedHash:D8,lift_x:kW,pointToBytes:y6,numberToBytesBE:N8,bytesToNumberBE:j1,mod:Z0},lengths:{secretKey:32,publicKey:32,publicKeyHasPrefix:!1,signature:64,seed:48}}})(),$Q=new TextEncoder,jQ=new TextDecoder,s0=(W)=>$Q.encode(W),c1=(W)=>jQ.decode(W),x6=(W)=>Array.from(W,(G)=>G.toString(16).padStart(2,"0")).join(""),w0=JSON.stringify,x8=JSON.parse,$W=(W,G=Number.MAX_SAFE_INTEGER)=>W.split("").reduce((J,Q)=>J+Q.charCodeAt(0),0)%G,f6="AES-GCM",BQ={},k8=(W)=>BQ[W]??=crypto.subtle.digest("SHA-1",s0(W)).then((G)=>{const J=new Uint8Array(G);let Q="";for(let V of J)Q+=V.toString(36);return Q}),MQ=async(W,G)=>{const J=crypto.getRandomValues(new Uint8Array(12)),Q=await W,V=await crypto.subtle.encrypt({name:f6,iv:J},Q,s0(G));return`${J.join(",")}\$${((X)=>{const Y=new Uint8Array(X);let q="";for(let F=0;F<Y.length;F+=32768)q+=String.fromCharCode(...Y.subarray(F,F+32768));return btoa(q)})(V)}`},RQ=async(W,G)=>{const[J,Q]=G.split("$");if(!J||!Q)throw Error("Invalid encrypted payload format");const V=Uint8Array.from(J.split(","),Number),X=await W,Y=await crypto.subtle.decrypt({name:f6,iv:V},X,(q=Q,Uint8Array.from(atob(q),(F)=>F.charCodeAt(0)).buffer));var q;return c1(Y)},q0="GenosRTC",h6=(W,G)=>Array.from({length:W},G),LQ="0123456789AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz",w6=(W)=>Array.from(crypto.getRandomValues(new Uint8Array(W)),(G)=>LQ[G%62]).join(""),K1=w6(20),k1=Promise.all.bind(Promise),OQ=typeof window!="undefined",{entries:IQ,fromEntries:jW}=Object,DQ=()=>{},I0=(W)=>Error(`${q0}: ${W}`),H8=(...W)=>W.join("@"),E7="icegatheringstatechange",p7="offer",xQ=[...h6(3,(W,G)=>`stun:stun${G||""}.l.google.com:19302`),"stun:stun.cloudflare.com:3478"].map((W)=>({urls:W})),$6=(W,{rtcConfig:G,rtcPolyfill:J,turnConfig:Q})=>{const V=new(J||RTCPeerConnection)({iceServers:[...xQ,...Q||[]],...G}),X={};let Y,q=!1,F=!1;const P=(K)=>Object.assign(K,{binaryType:"arraybuffer",bufferedAmountLowThreshold:65535,onmessage(z){return X.data?.(z.data)},onopen(){return X.connect?.()},onclose(){return X.close?.()},onerror(z){return!z?.error?.message?.includes("User-Initiated Abort")&&X.error?.(z)}}),U=()=>Promise.race([new Promise((K)=>{const z=()=>{V.iceGatheringState==="complete"&&(V.removeEventListener(E7,z),K())};V.addEventListener(E7,z),z()}),new Promise((K)=>setTimeout(K,5000))]).then(()=>({type:V.localDescription.type,sdp:V.localDescription.sdp.replace(/a=ice-options:trickle\s\n/g,"")}));W?P(Y=V.createDataChannel("data")):V.ondatachannel=({channel:K})=>P(Y=K),V.onnegotiationneeded=async()=>{try{q=!0,await V.setLocalDescription(),X.signal?.(await U())}catch(K){X.error?.(K)}finally{q=!1}},V.onconnectionstatechange=()=>{["disconnected","failed","closed"].includes(V.connectionState)&&X.close?.()},V.ontrack=(K)=>{X.track?.(K.track,K.streams[0]),X.stream?.(K.streams[0])},V.onremovestream=(K)=>X.stream?.(K.stream),W&&!V.canTrickleIceCandidates&&V.onnegotiationneeded();const C=()=>V.getSenders();return{created:Date.now(),connection:V,get channel(){return Y},get isDead(){return V.connectionState==="closed"},async signal(K){if(Y?.readyState!=="open"||K.sdp?.includes("a=rtpmap"))try{if(K.type===p7){if(q||V.signalingState!=="stable"&&!F){if(W)return;await k1([V.setLocalDescription({type:"rollback"}),V.setRemoteDescription(K)])}else await V.setRemoteDescription(K);await V.setLocalDescription();const z=await U();return X.signal?.(z),z}if(K.type==="answer"){F=!0;try{await V.setRemoteDescription(K)}finally{F=!1}}}catch(z){X.error?.(z)}},sendData(K){return Y.send(K)},destroy(){Y?.close(),V.close(),q=F=!1},setHandlers(K){return Object.assign(X,K)},offerPromise:W?new Promise((K)=>X.signal=(z)=>z.type===p7&&K(z)):Promise.resolve(),addStream(K){return K.getTracks().forEach((z)=>V.addTrack(z,K))},removeStream(K){return C().filter((z)=>K.getTracks().includes(z.track)).forEach((z)=>V.removeTrack(z))},addTrack(K,z){return V.addTrack(K,z)},removeTrack(K){const z=C().find(($)=>$.track===K);z&&V.removeTrack(z)},replaceTrack(K,z){return C().find(($)=>$.track===K)?.replaceTrack(z)}}},wQ=Object.getPrototypeOf(Uint8Array),u1=16369,C8=255,j6="bufferedamountlow",z1=(W)=>"@_"+W,NQ=(W,G,J)=>{const Q=new Map,V=new Map,X=new Map,Y={},q={},F={},P={},U=new Map,C=(H,...j)=>U.get(H)?.forEach((O)=>O(...j)),K=(H,j)=>{const O=H?Array.isArray(H)?H:[H]:Q.keys();return Array.from(O,(R)=>{const D=Q.get(R);return D?j(R,D):(console.warn(`${q0}: no peer with id ${R}`),null)}).filter(Boolean)},z=(H)=>{Q.has(H)&&(Q.delete(H),delete Y[H],delete q[H],delete F[H],delete P[H],C("peer:leave",H),G(H))},$=(H)=>new Promise((j,O)=>{let R=setTimeout(()=>{H.removeEventListener(j6,D),O(Error(q0+": bufferLow timeout"))},5000);function D(){clearTimeout(R),H.removeEventListener(j6,D),j()}H.addEventListener(j6,D)}),N=(H)=>{if(X.has(H))return X.get(H);if(!H)throw I0("action type is required");const j=s0(H);if(j.byteLength>12)throw I0(`"${H}" exceeds 12 bytes`);const O=new Uint8Array(12).map((T,S)=>j[S]||0);let R=0;const D=new Map([["message",new Set],["progress",new Set]]),B=async(T,S,A,h)=>{if(A&&typeof A!="object")throw I0("meta must be object");if(T===void 0)throw I0("data cannot be undefined");const b=T instanceof Blob,m=b||T instanceof ArrayBuffer||T instanceof wQ,_=typeof T!="string";if(A&&!m)throw I0("meta only allowed with binary");const l=m?new Uint8Array(b?await T.arrayBuffer():T):s0(_?w0(T):T),M0=A?s0(w0(A)):null,J0=Math.ceil(l.byteLength/u1)+(A?1:0)||1;if(J0>100)throw I0("Message too large, exceeds max chunks 100");const P0=h6(J0,(U0,s)=>{const G0=s===J0-1,n=A&&s===0,r1=n?M0:l.subarray(A?(s-1)*u1:s*u1,A?s*u1:(s+1)*u1),N0=new Uint8Array(15+r1.byteLength);return N0.set(O),N0.set([R],12),N0.set([G0|n<<1|m<<2|_<<3],13),N0.set([Math.round((s+1)/J0*C8)],14),N0.set(r1,15),N0});return R=R+1&C8,k1(K(S,async(U0,s)=>{const{channel:G0}=s;for(let n=0;n<J0;n++){let r1=0;for(;G0.bufferedAmount>G0.bufferedAmountLowThreshold;){if(r1++>3)throw I0(`${q0}: send buffer full, max retries reached for peer ${U0}`);try{await $(G0)}catch(N0){console.warn(N0.message),await new Promise((gW)=>setTimeout(gW,200))}}if(!Q.has(U0))break;s.sendData(P0[n]),h?.(P0[n][14]/C8,U0,A)}}))};V.set(H,{listeners:D,send:B});const v={send:B,on(T,S){return D.get(T)?.add(S)},off(T,S){return D.get(T)?.delete(S)}};return X.set(H,v),v},g=async()=>{try{await k(""),await new Promise((H)=>setTimeout(H,99))}catch(H){console.warn(q0+": error sending leave",H)}for(let[H,j]of Q){try{j.destroy()}catch{}Q.delete(H)}J()},{send:y,on:E}=N(z1("ping")),{send:p,on:x}=N(z1("pong")),{send:f,on:d}=N(z1("signal")),{send:I,on:L}=N(z1("stream")),{send:w,on:Z}=N(z1("track")),{send:k,on:M}=N(z1("leave"));return W((H,j)=>{Q.has(j)||(Q.set(j,H),H.setHandlers({data(O){return((R,D)=>{try{const B=new Uint8Array(D),v=c1(B.subarray(0,12)).replace(/\0/g,"");if(!V.has(v))return console.warn(`${q0}: unregistered type (${v})`);const[T]=B.subarray(12,13),[S]=B.subarray(13,14),[A]=B.subarray(14,15),h=B.subarray(15),b=!!(1&S),m=!!(2&S),_=!!(4&S),l=!!(8&S),M0=V.get(v),J0=(Y[R]||={})[v]||={};if(J0[T]?.chunks?.length>100)return void console.warn(`${q0}: peer ${R} sent too many chunks for nonce ${T}, ignoring.`);const P0=J0[T]||={chunks:[]};if(m)try{P0.meta=x8(c1(h))}catch{return void console.warn(`${q0}: failed to parse meta from peer ${R} for type ${v}`)}else P0.chunks.push(h);if(M0.listeners.get("progress").forEach((G0)=>{try{G0(A/C8,R,P0.meta)}catch(n){console.error(n)}}),!b)return;const U0=new Uint8Array(P0.chunks.reduce((G0,n)=>G0+n.byteLength,0));let s;if(P0.chunks.reduce((G0,n)=>(U0.set(n,G0),G0+n.byteLength),0),delete J0[T],_)s=U0;else if(l)try{s=x8(c1(U0))}catch{return void console.warn(`${q0}: failed to parse JSON message data from peer ${R} for type ${v}`)}else s=c1(U0);M0.listeners.get("message").forEach((G0)=>{try{G0(s,R,P0.meta)}catch(n){console.error(n)}})}catch(B){console.error(`${q0}: error handling data from peer ${R}:`,B)}})(j,O)},stream(O){C("stream:add",O,j,F[j]),delete F[j]},track(O,R){C("track:add",O,R,j,P[j]),delete P[j]},signal(O){return f(O,j)},close(){return z(j)},error(O){console.error(`${q0}: peer error for ${j}`,O),z(j)}}),C("peer:join",j))}),E("message",(H,j)=>p("",j)),x("message",(H,j)=>{q[j]?.(),delete q[j]}),d("message",(H,j)=>Q.get(j)?.signal(H)),L("message",(H,j)=>F[j]=H),Z("message",(H,j)=>P[j]=H),M("message",(H,j)=>z(j)),OQ&&addEventListener("beforeunload",g),{on(H,j){U.has(H)||U.set(H,new Set),U.get(H).add(j)},off(H,j){return U.get(H)?.delete(j)},channel:N,leave:g,async ping(H){if(!H)throw I0("ping() requires target peer ID");const j=Date.now();return y("",H),await new Promise((O)=>q[H]=O),Date.now()-j},getPeers(){return jW(Array.from(Q,([H,j])=>[H,j.connection]))},addStream(H,j,O){return K(j,async(R,D)=>{O&&await I(O,R),D.addStream(H)})},removeStream(H,j){return K(j,(O,R)=>R.removeStream(H))},addTrack(H,j,O,R){return K(O,async(D,B)=>{R&&await w(R,D),B.addTrack(H,j)})},removeTrack(H,j){return K(j,(O,R)=>R.removeTrack(H))},replaceTrack(H,j,O,R){return K(O,async(D,B)=>{R&&await w(R,D),B.replaceTrack(H,j)})}}},$8={},BW={};if(typeof window!="undefined"){const W=()=>{console.info("\u26A1 [GenosRTC] Evento de red detectado. Forzando reconexi\xF3n..."),Object.values(BW).forEach((G)=>{G.socket&&G.socket.readyState!==WebSocket.OPEN&&G.socket.readyState!==WebSocket.CONNECTING&&G.forceReconnect()})};window.addEventListener("online",()=>{console.info("\u2705 Reconnected to the network."),W()}),window.addEventListener("offline",async()=>{console.info("\u274C Disconnected from the network.")}),document.addEventListener("visibilitychange",()=>{document.visibilityState==="visible"&&W()})}var vQ=(W,G,J,Q)=>(W.relayUrls??(Q?((V,X)=>{const Y=[...V];let q=Y.length;const F=()=>{const P=1e4*Math.sin(X++);return P-Math.floor(P)};for(;q;){const P=Math.floor(F()*q--);[Y[q],Y[P]]=[Y[P],Y[q]]}return Y})(G,$W(W.appId)):G)).slice(0,W.relayUrls?.length??W.relayRedundancy??J),MW={},RW="EVENT",LW=p6.utils.randomSecretKey(),gQ=x6(p6.getPublicKey(LW)),b6={},d1={},SQ={},OW=()=>Math.floor(Date.now()/1000),IW=(W)=>SQ[W]??=$W(W,1e4)+20000,f7=async(W,G)=>{const J={kind:IW(W),content:G,pubkey:gQ,created_at:OW(),tags:[["x",W]]},Q=new Uint8Array(await crypto.subtle.digest("SHA-256",s0(w0([0,J.pubkey,J.created_at,J.kind,J.tags,J.content])))),V=p6.sign(Q,LW);return w0([RW,{...J,id:x6(Q),sig:x6(V)}])},h7=(W,G)=>(b6[W]=G,w0(["REQ",W,{kinds:[IW(G)],since:OW(),"#x":[G]}])),b7=(W)=>(delete b6[W],w0(["CLOSE",W])),m6=(({init:W,subscribe:G,announce:J})=>{const Q={};let V,X,Y=!1;return(q,F,P)=>{const{appId:U}=q;if(Q[U]?.[F])return Q[U][F];if(!q||!F||!U&&!q.firebaseApp)throw I0(q?F?"appId missing":"roomId required":"config required");let C=DQ;if(!Y){const Z=W(q);X=h6(20,()=>$6(!0,q)),V=Array.isArray(Z)?Z:[Z];const k=setInterval(()=>{X=X.filter((M)=>{const H=Date.now()-M.created<57333;return H||M.destroy(),H})},57333);Q.offerCleanupTimer||=k,Y=!0}const K={},z={},$=H8(q0,U,F),N=k8($),g=k8(H8($,K1)),y=(async(Z,k,M)=>{const H=await crypto.subtle.digest("SHA-256",s0(`${Z}:${k}:${M}`));return crypto.subtle.importKey("raw",H,{name:f6},!1,["encrypt","decrypt"])})(q.password||"",U,F),E=(Z)=>async(k)=>({type:k.type,sdp:await Z(y,k.sdp)}),p=E(RQ),x=E(MQ),f=(Z,k)=>{z[k]!==Z&&(z[k]?.destroy(),z[k]=Z,C(Z,k),K[k]?.forEach((M)=>M!==Z&&M.destroy()),delete K[k])},d=(Z,k)=>{z[k]===Z&&delete z[k]},I=k1(V.map(async(Z,k)=>{return G(await Z,await N,await g,(M=k,async(H,j,O)=>{const[R,D]=await k1([N,g]);if(H!==R&&H!==D)return;const{peerId:B,offer:v,answer:T}=typeof j=="string"?x8(j):j;if(B!==K1&&!z[B])if(v){if(K[B]?.[M]&&K1>B)return;const S=$6(!1,q);S.setHandlers({connect(){return f(S,B)},close(){return d(S,B)}});try{const A=await p(v);if(S.isDead)return;const[h,b]=await k1([k8(H8($,B)),S.signal(A).then(x)]);O(h,w0({peerId:K1,answer:b}))}catch{P?.({error:"decryption failed (offer)",appId:U,peerId:B,roomId:F})}}else if(T){const S=K[B]?.[M];if(!S||S.isDead)return;S.setHandlers({connect(){return f(S,B)},close(){return d(S,B)}});try{S.signal(await p(T))}catch{P?.({error:"decryption failed (answer)",appId:U,peerId:B,roomId:F})}}else{if(K[B]?.[M])return;const S=X.pop()||$6(!0,q),[A,{offer:h}]=await k1([k8(H8($,B)),S.offerPromise.then(x).then((b)=>({offer:b}))]);K[B]||=[],K[B][M]=S,S.setHandlers({connect(){return f(S,B)},close(){return d(S,B)}}),O(A,w0({peerId:K1,offer:h,peer:S}))}}));var M})),L=[];I.then((Z)=>{V.forEach((k,M)=>{const H=async()=>{const j=await J(await k,await N,await g);L[M]=setTimeout(H,typeof j=="number"?j:5333)};H()}),Q[U][F].onCleanup=()=>{delete Q[U][F],L.forEach(clearTimeout),Z.forEach((k)=>k()),Object.keys(Q).length===0&&(clearInterval(Q.offerCleanupTimer),delete Q.offerCleanupTimer)}}),Q[U]||={};const w=NQ((Z)=>C=Z,(Z)=>delete z[Z],()=>w.onCleanup?.());return Q[U][F]=w}})({init(W){return vQ(W,TQ,5,!0).map((G)=>{const J=((Q,V)=>{const X={};let Y=null;const q=()=>{Y&&(clearTimeout(Y),Y=null);const F=new WebSocket(Q);F.onclose=()=>{$8[Q]??=3333,Y=setTimeout(q,$8[Q]),$8[Q]*=2},F.onmessage=(P)=>V(P.data),X.socket=F,X.url=F.url,X.ready=new Promise((P)=>{F.onopen=()=>{$8[Q]=3333,P(X)}}),X.send=(P)=>{F.readyState===1&&F.send(P)}};return X.forceReconnect=q,q(),BW[Q]=X,X})(G,(Q)=>{const[V,X,Y,q]=x8(Q);if(V===RW)d1[X]?.(b6[X],Y.content);else{const F=`${q0}: relay failure from ${J.url} - `;V==="NOTICE"?console.warn(F+X):V!=="OK"||Y||console.warn(F+q)}});return MW[G]=J,J.ready})},subscribe(W,G,J,Q){const V=w6(64),X=w6(64);return d1[V]=d1[X]=(Y,q)=>Q(Y,q,async(F,P)=>W.send(await f7(F,P))),W.send(h7(V,G)),W.send(h7(X,J)),()=>{W.send(b7(V)),W.send(b7(X)),delete d1[V],delete d1[X]}},async announce(W,G){return W.send(await f7(G,w0({peerId:K1})))}}),$V=(m7=MW,()=>jW(IQ(m7).map(([W,G])=>[W,G.socket]))),m7,TQ=["black.nostrcity.club","eu.purplerelay.com","ftp.halifax.rwth-aachen.de/nostr","nostr.cool110.xyz","nostr.data.haus","nostr.mom","nostr.oxtr.dev","nostr.sathoarder.com","nostr.vulpem.com","playground.nostrcheck.me/relay","relay.agorist.space","relay.binaryrobot.com","relay.fountain.fm","relay.mostro.network","relay.nostraddress.com","relay.nostrdice.com","relay.nostromo.social","relay.oldenburg.cool","relay.snort.social","relay.verified-nostr.com","sendit.nosflare.com","yabu.me/v2","relay.damus.io"].map((W)=>"wss://"+W);var DW=(W,G,J)=>{let Q=G.timestamp;if(G.timestamp&&typeof G.timestamp.physical==="number"){const Y=Date.now()+7200000;if(G.timestamp.physical>Y)Q={physical:Y,logical:G.timestamp.logical}}if(!W||!W.timestamp)return{resolved:!0,value:G.value,timestamp:Q};const V=W.timestamp;if(J.compare(V,Q)<0)return{resolved:!0,value:G.value,timestamp:Q};return{resolved:!1}};class u6{constructor(W,G=50){this.key=`gdb_oplog_${W}`,this.maxSize=G,this.log=this._load()}_load(){try{const W=localStorage.getItem(this.key);return W?JSON.parse(W):[]}catch(W){return console.error("Failed to load oplog from localStorage:",W),[]}}_save(){try{localStorage.setItem(this.key,JSON.stringify(this.log))}catch(W){console.error("Failed to save oplog to localStorage:",W)}}add(W){if(this.log.push(W),this.log.length>this.maxSize)this.log.shift();this._save()}getDelta(W,G){if(!W)return[...this.log];return this.log.filter((J)=>G(J.timestamp,W)>0)}getOldest(){return this.log[0]}clear(){this.log=[],localStorage.removeItem(this.key)}}var AQ=()=>{const W=new Map,G=async()=>{try{const F=await navigator.storage.getDirectory(),U=await(await F.getFileHandle("~opfs-sync-test",{create:!0})).createSyncAccessHandle?.();return await U?.close(),await F.removeEntry("~opfs-sync-test"),!!U}catch{return!1}};let J="idb";const Q=(async()=>{if(await G())J="sync";else try{const F=await navigator.storage.getDirectory(),U=await(await F.getFileHandle("~opfs-async-test",{create:!0})).createWritable?.();if(await U?.close(),await F.removeEntry("~opfs-async-test"),U)J="async";else J="idb"}catch{J="idb"}})(),V=async(F,P)=>{if(!W.has(F))W.set(F,[]);const U=W.get(F),C=U[U.length-1]||Promise.resolve();let K;const z=new Promise(($)=>K=$);U.push(z);try{return await C,await P()}finally{if(U.shift(),K(),U.length===0)W.delete(F)}},X=(()=>{let F;const P=async()=>{if(!F)F=new Promise((U,C)=>{const K=indexedDB.open("opfs-fallback-db",1);K.onupgradeneeded=()=>K.result.createObjectStore("files"),K.onsuccess=()=>U(K.result),K.onerror=()=>C(K.error)});return F};return{getDB:P,get:async(U)=>{const C=await P();return new Promise((K,z)=>{const N=C.transaction("files","readonly").objectStore("files").get(U);N.onsuccess=()=>K(N.result||new Uint8Array),N.onerror=()=>z(N.error)})},set:async(U,C)=>{const K=await P();return new Promise((z,$)=>{const g=K.transaction("files","readwrite").objectStore("files").put(C,U);g.onsuccess=()=>z(),g.onerror=()=>$(g.error)})}}})(),Y=async(F)=>{await Q;try{if(J==="idb"){const z=await X.get(F);return{type:"loaded",name:F,data:z}}const U=await(await navigator.storage.getDirectory()).getFileHandle(F);if(J==="sync"){let z;try{z=await U.createSyncAccessHandle();const $=z.getSize(),N=new Uint8Array($),g=z.read(N,{at:0});return{type:"loaded",name:F,data:N.slice(0,g)}}finally{z?.close()}}const C=await U.getFile(),K=new Uint8Array(await C.arrayBuffer());return{type:"loaded",name:F,data:K}}catch(P){const U=P.name==="NotFoundError"?"File not found":P.message||"Error reading file";return{type:"error",name:F,message:U}}},q=async(F,P)=>{if(await Q,!(P instanceof Uint8Array))return{type:"error",name:F,message:"Content must be a Uint8Array"};return V(F,async()=>{try{if(J==="idb")return await X.set(F,P),{type:"saved",name:F};const C=await(await navigator.storage.getDirectory()).getFileHandle(F,{create:!0});if(J==="sync"){let K;try{K=await C.createSyncAccessHandle(),K.truncate(0),K.write(P,{at:0}),K.flush()}finally{K?.close()}}else{let K;try{K=await C.createWritable(),await K.write(P)}finally{await K?.close()}}return{type:"saved",name:F}}catch(U){return{type:"error",name:F,message:U.message||"Error saving file"}}})};self.onmessage=async({data:F})=>{const{type:P,name:U,content:C}=F;await Q;const K={load:()=>Y(U),save:()=>q(U,C)};try{const z=K[P],$=z?await z():{type:"error",message:`Unrecognized action type: ${P}`};self.postMessage($)}catch(z){console.error("Worker unexpected error:",z),self.postMessage({type:"error",name:U,message:z.message||"Unexpected worker error"})}}},xW=AQ;var t0={$eq:(W,G)=>W===G,$ne:(W,G)=>W!==G,$gt:(W,G)=>W>G,$gte:(W,G)=>W>=G,$lt:(W,G)=>W<G,$lte:(W,G)=>W<=G,$in:(W,G)=>Array.isArray(G)&&(Array.isArray(W)?W.some((J)=>G.includes(J)):G.includes(W)),$between:(W,[G,J])=>W>=G&&W<=J,$exists:(W,G)=>G?W!==void 0:W===void 0,$text:{global:(W,G)=>{const J=(V)=>String(V).normalize("NFD").replace(/[\u0300-\u036f]/g,"").toLowerCase().replace(/[^\w\s]/g,""),Q=J(G);return Object.values(W).some((V)=>typeof V==="object"?null.fieldSearch(V,Q):J(V).includes(Q))},field:(W,G)=>{const J=(V)=>String(V).normalize("NFD").replace(/[\u0300-\u036f]/g,"").toLowerCase().replace(/[^\w\s]/g,""),Q=J(G);return Array.isArray(W)?W.some((V)=>J(V).includes(Q)):J(W).includes(Q)}},$like:(W,G)=>typeof W==="string"&&typeof G==="string"&&new RegExp(`^${G.replace(/%/g,".*").replace(/_/g,".")}\$`,"i").test(W),$regex:(W,G)=>typeof W==="string"&&new RegExp(G.$regex||G,"i").test(W),$and:(W,G,J)=>G.every((Q)=>J.createFilter(Q,J.allNodes)(W)),$or:(W,G,J)=>G.some((Q)=>J.createFilter(Q,J.allNodes)(W)),$not:(W,G,J)=>!J.createFilter(G,J.allNodes)(W),$edge:(W,G,J)=>{if(!W.edges?.length||typeof G!=="object"||G===null)return!1;const Q=J.createFilter(G,J.allNodes),V=[...W.edges],X=new Set(V).add(W.id),Y=[];while(V.length){const q=V.shift(),F=J.allNodes[q];if(!F)continue;if(Q(F))Y.push(F);F.edges?.forEach((P)=>!X.has(P)&&X.add(P)&&V.push(P))}if(Y.length)W._edgeResult=Y;return Y.length>0}},d6=(W,G)=>G.split(".").reduce((J,Q)=>J&&typeof J==="object"&&(Q in J)?J[Q]:void 0,W),v8=(W,G)=>{if(Object.keys(W).length===0)return()=>!0;return(J)=>Object.entries(W).every(([Q,V])=>{if(Q.startsWith("$"))return t0[Q](J,V,{createFilter:v8,allNodes:G});const X=d6(J.value,Q);if(typeof V!=="object"||V===null)return t0.$eq(X,V);return Object.entries(V).every(([Y,q])=>{if(Y==="$text")return t0.$text.field(X,q);if(Y==="$between"&&q.every((F)=>F instanceof Date))return t0.$between(new Date(X),q);return t0[Y]?.(X,q,{createFilter:v8,allNodes:G})??!1})})},c6=(W,G)=>{const{$edge:J,...Q}=G.query||{},V=v8(Q,W),X=Object.values(W).filter(V);let q=[...J?(()=>{const F=v8({$edge:J},W);X.forEach((U)=>F(U));const P=new Map;return X.forEach((U)=>{if(U._edgeResult)U._edgeResult.forEach((C)=>P.set(C.id,C)),delete U._edgeResult}),Array.from(P.values())})():X];if(G.field){const F=G.order==="asc"?1:-1;q.sort((P,U)=>{const C=d6(P.value,G.field),K=d6(U.value,G.field);if(typeof C==="string"&&typeof K==="string")return C.localeCompare(K)*F;return((C??0)-(K??0))*F})}if(G.$after){const F=q.findIndex((P)=>P.id===G.$after);q=F>=0?q.slice(F+1):[]}if(G.$before){const F=q.findIndex((P)=>P.id===G.$before);q=F>=0?q.slice(0,F):[]}if(G.$limit)q=q.slice(0,G.$limit);return q};class _6{constructor(){this.physical=Date.now(),this.logical=0}now(){const W=Date.now();return this.physical=Math.max(this.physical,W),this.logical++,{physical:this.physical,logical:this.logical}}update(W){if(!W||typeof W.physical!=="number"||typeof W.logical!=="number")return;this.physical=Math.max(this.physical,W.physical),this.logical=Math.max(this.logical,W.logical)+1}compare(W,G){if(!W&&!G)return 0;if(!W)return-1;if(!G)return 1;if(W.physical>G.physical)return 1;if(W.physical<G.physical)return-1;if(W.logical>G.logical)return 1;if(W.logical<G.logical)return-1;return 0}}var wW=function(W,G){return W.length===G.length&&W.every((J,Q)=>J===G[Q])};async function yQ(){console.info(navigator?.storage?.getDirectory?"\u2705 OPFS is enabled.":"\uD83D\uDEAB OPFS is not available."),navigator?.storage?.getDirectory&&await navigator.storage.getDirectory()}if(Symbol.dispose===void 0)Object.defineProperty(Symbol,"dispose",{value:Symbol.for("Symbol.dispose")});class NW{constructor(){this.nodes={}}upsert(W,G,J){this.nodes[W]={id:W,value:G,edges:[],timestamp:J}}get(W){return this.nodes[W]||null}link(W,G,J){const Q=this.nodes[W],V=this.nodes[G];if(Q&&V&&!Q.edges.includes(G))Q.edges.push(G),Q.timestamp=J}getAllNodes(){return Object.values(this.nodes)}serialize(){return i0.deflate(v0(this.nodes))}deserialize(W){this.nodes=t1(i0.inflate(new Uint8Array(W)))}}class vW{constructor(W,{password:G,securityManager:J=null,relayUrls:Q=null}={}){if(console.info("\u26A1 GenosDB: Empowering distributed graph databases with real-time synchronization and scalability. Learn more: https://github.com/estebanrfp/gdb \u26A1"),this.oplog=new u6(W,20),this.hybridClock=new _6,this.name=W,this.password=G,this.globalTimestamp=null,this.graph=new NW,this.securityManager=J,!this.securityManager||typeof this.securityManager.verifyIncomingOperations!=="function")console.info("\u26A0\uFE0F SecurityManager inactive!"),console.info("\u27A1\uFE0F Processing P2P data directly.");else console.info("\uD83D\uDD12 GDB: SecurityManager active!"),console.info("\u27A1\uFE0F Verifying incoming operations with SecurityManager.");this.eventListeners=[],this.operators=t0,this.initWorker(),this.ready=this.loadGraphFromOPFS(),this.loadGlobalTimestamp();const V=`graph-sync-room-${this.name}`,X={appId:"1234",...this.password&&{password:this.password}};if(Q)X.relayUrls=Q;const Y=m6(X,V),q=Y.channel("syncGraph");this.syncChannel=q;const F=m6(X,`app-sync-${this.name}`);this.room=F,yQ(),Y.on("peer:join",async(P)=>{console.info("\u26A1 New peer connected:",P),this.syncChannel.send([{type:"sync",timestamp:this.globalTimestamp}])}),Y.on("peer:leave",(P)=>{console.info("\u26A1 Peer disconnected:",P)}),this.syncChannel.on("message",async(P)=>{if(this.securityManager&&typeof this.securityManager.verifyIncomingOperations==="function"){const{validatedOperations:U}=await this.securityManager.verifyIncomingOperations(P);if(U&&U.length>0)await this.receiveChanges(U)}else await this.receiveChanges(P),this.emit()}),this.channel=new BroadcastChannel(`graphdb_sync_${this.name}`),this.channel.onmessage=async(P)=>{if(P.data==="update")console.info("\uD83D\uDD04 Update received from another tab..."),await this.loadGraphFromOPFS(),this.loadGlobalTimestamp(),this.emit()}}loadGlobalTimestamp(){const W=localStorage.getItem(`${this.name}_time`);this.globalTimestamp=W?JSON.parse(W):null}saveGlobalTimestamp(W){this.globalTimestamp=W,localStorage.setItem(`${this.name}_time`,JSON.stringify(W))}initWorker(){try{const W=URL.createObjectURL(new Blob([`(${xW.toString()})()`],{type:"application/javascript"}));this.worker=new Worker(W),this.worker.addEventListener("message",({data:G})=>{console.info(`\uD83D\uDCBE ${G.name} ${G.type}`),URL.revokeObjectURL(W)}),console.info("\u2699\uFE0F Worker initialized successfully.")}catch({message:W}){console.error("\u274C Failed to initialize worker:",W)}}getWorker(){return this.worker}emit(){this.eventListeners.forEach((W)=>W(this.graph.nodes))}compress(W){return i0.deflate(W)}decompress(W){return i0.inflate(W)}async getAllNodes(){return await this.ready,this.graph.getAllNodes()}async generateHash(){return crypto.randomUUID()}async hashValue(W){const G=(new TextEncoder()).encode(W),J=await crypto.subtle.digest("SHA-256",G);return Array.from(new Uint8Array(J)).map((Q)=>Q.toString(16).padStart(2,"0")).join("")}async loadGraphFromOPFS(){try{const G=await((J)=>new Promise((Q,V)=>{const X=async({data:Y})=>{if(Y.type==="loaded"&&Y.name===J)this.worker.removeEventListener("message",X),Q(new Uint8Array(Y.data));else if(Y.type==="error")this.worker.removeEventListener("message",X),V(new Error(Y.message||"Unknown error"))};this.worker.addEventListener("message",X),this.worker.postMessage({type:"load",name:J})}))(`${this.name}_graph.msgpack`).catch(()=>new Uint8Array);G.byteLength>0?this.graph.deserialize(G):console.warn("\u26A0\uFE0F The file '_graph.msgpack' is empty or could not be loaded."),console.info(`\u2705 Graph loaded: [ ${this.graph.getAllNodes().length} nodes ]`)}catch({message:W}){console.error("\u274C Error loading the graph:",W)}}async saveGraphToOPFS(){try{const W=this.graph.serialize();return await((J,Q)=>new Promise((V,X)=>{const Y=({data:q})=>{if(q.type==="saved"&&q.name===J)this.worker.removeEventListener("message",Y),V();else if(q.type==="error")this.worker.removeEventListener("message",Y),X(new Error(q.message||"Save error"))};this.worker.addEventListener("message",Y),this.worker.postMessage({type:"save",name:J,content:Q})}))(`${this.name}_graph.msgpack`,W),this.channel.postMessage("update"),!0}catch({message:W}){throw console.error("\u274C Save error:",W),new Error("Save failed")}}async put(W,G){await this.ready;const J=this.hybridClock.now();return this.saveGlobalTimestamp(J),G??=await this.generateHash(),this.graph.upsert(G,W,J),this.oplog.add({type:"upsert",id:G,timestamp:J}),await this.saveGraphToOPFS(),await this.syncChannel.send([{type:"upsert",id:G,value:W,timestamp:J}]),this.emit(),G}async get(W,G=null){if(await this.ready,typeof W!=="string")return{result:null};const J=this.graph.get(W);if(!J){if(G)G(null);return{result:null}}const Q=(Y)=>{if(!Y)return null;const q=Y.value!==null&&typeof Y.value==="object"?{...Y.value}:Y.value;return{...Y,value:q}};if(!G)return{result:Q(J)};let V=J.timestamp;G(Q(J));const X=(Y)=>{const q=Y[W];if(q){if(this.hybridClock.compare(q.timestamp,V)>0)V=q.timestamp,G(Q(q))}else G(null),this.eventListeners.splice(this.eventListeners.indexOf(X),1)};return this.eventListeners.push(X),{result:Q(J),unsubscribe:()=>{const Y=this.eventListeners.indexOf(X);if(Y>-1)this.eventListeners.splice(Y,1)}}}async map(...W){await this.ready;let J={...{realtime:!1,query:{},field:null,order:"asc",$limit:null,$after:null,$before:null}},Q=null,V=!1;W.forEach((F)=>typeof F==="function"?Q=F:F&&typeof F==="object"&&(V||=("realtime"in F),Object.assign(J,F))),Q&&!V&&(J.realtime=!0);let X=c6(this.graph.nodes,J),Y=null;const q=(F)=>{const P=F.filter((z)=>!X.some(($)=>$.id===z.id)),U=X.filter((z)=>!F.some(($)=>$.id===z.id)),C=F.filter((z)=>{const $=X.find((N)=>N.id===z.id);return $&&!wW(v0(z.value),v0($.value))}),K=(z,$)=>{const N=$==="removed"?null:z.value,g={id:z.id,value:N,edges:z.edges||[],timestamp:z.timestamp||null,action:$};Q(g)};P.forEach((z)=>K(z,"added")),U.forEach((z)=>K(z,"removed")),C.forEach((z)=>K(z,"updated"))};if(Q){if(X.forEach((F)=>{if(F.value)Q({id:F.id,value:F.value,edges:F.edges,timestamp:F.timestamp,action:"initial"})}),J.realtime)Y=(F)=>{const P=c6(F,J);if(!wW(v0(P),v0(X)))q(P),X=P},this.eventListeners.push(Y)}return{results:X,...J.realtime&&Q&&Y&&{unsubscribe:()=>{const F=this.eventListeners.indexOf(Y);F>-1&&this.eventListeners.splice(F,1)}}}}async remove(W){await this.ready;const G=this.hybridClock.now(),J=this.graph.get(W);if(!J)return console.warn(`\u26A0\uFE0F Node with ID '${W}' not found.`);delete this.graph.nodes[W],this.oplog.add({type:"remove",id:W,timestamp:G}),Object.values(this.graph.nodes).forEach((Q)=>Q.edges=Q.edges.filter((V)=>V!==W)),await this.saveGraphToOPFS(),this.saveGlobalTimestamp(G),await this.syncChannel.send([{type:"remove",id:W,value:J.value,timestamp:G}]),this.emit()}async clear(){await this.ready,this.graph.nodes={};try{await(await navigator.storage.getDirectory()).removeEntry(`${this.name}_graph.msgpack`)}catch({message:W}){console.warn(`\u26A0\uFE0F Error deleting _graph.msgpack: ${W}`)}this.emit(),console.info("\u2705 All data has been deleted.")}async link(W,G){await this.ready;const J=this.hybridClock.now();if(!this.graph.nodes[W]||!this.graph.nodes[G]){console.warn(`\u26A0\uFE0F One or both nodes (${W}, ${G}) do not exist.`);return}this.graph.link(W,G,J),this.oplog.add({type:"link",sourceId:W,targetId:G,timestamp:J}),await this.saveGraphToOPFS(),this.saveGlobalTimestamp(J),await this.syncChannel.send([{type:"link",sourceId:W,targetId:G,timestamp:J}]),this.emit()}async applyFullGraph(W){try{console.info("\uD83D\uDD04 Applying full graph from remote..."),this.graph.nodes={...W.nodes},await this.saveGraphToOPFS()}catch({message:G}){console.error(`\u274C Error applying the full graph: ${G}`)}}async receiveChanges(W){let G=!1,J=null;const Q={upsert:(V)=>{const X=this.graph.get(V.id),Y=DW(X,V,this.hybridClock);if(Y.resolved){if(this.graph.upsert(V.id,Y.value,Y.timestamp),this.hybridClock.update(Y.timestamp),this.oplog.add({type:"upsert",id:V.id,timestamp:Y.timestamp}),G=!0,!J||this.hybridClock.compare(Y.timestamp,J)>0)J=Y.timestamp}},remove:(V)=>{const X=this.graph.get(V.id);if(X&&this.hybridClock.compare(X.timestamp,V.timestamp)<0){if(delete this.graph.nodes[V.id],this.hybridClock.update(V.timestamp),this.oplog.add({type:"remove",id:V.id,timestamp:V.timestamp}),G=!0,!J||this.hybridClock.compare(V.timestamp,J)>0)J=V.timestamp}},link:(V)=>{const X=this.graph.get(V.sourceId),Y=this.graph.get(V.targetId);if(X&&Y&&this.hybridClock.compare(X.timestamp,V.timestamp)<0){if(this.graph.link(V.sourceId,V.targetId,V.timestamp),this.hybridClock.update(V.timestamp),this.oplog.add({type:"link",sourceId:V.sourceId,targetId:V.targetId,timestamp:V.timestamp}),G=!0,!J||this.hybridClock.compare(V.timestamp,J)>0)J=V.timestamp}},sync:async(V)=>{const X=V.timestamp;if(X===null){console.info("\uD83D\uDCEC [SYNC REQUEST] from new peer (no timestamp). Sending full graph."),await this.syncChannel.send([{type:"syncReceive",graph:this.graph}]);return}console.info("\uD83D\uDCEC [SYNC REQUEST] since:",new Date(X.physical).toLocaleString());const Y=this.oplog.getOldest();if(Y&&this.hybridClock.compare(X,Y.timestamp)<0){console.info("\uD83D\uDCA5 [FALLBACK TRIGGERED] Peer is too far behind. Sending FULL graph state."),await this.syncChannel.send([{type:"syncReceive",graph:this.graph}]);return}const q=this.oplog.getDelta(X,this.hybridClock.compare);if(q.length>0){const F=q.map((U)=>{if(U.type==="upsert"){const C=this.graph.get(U.id);return{...U,value:C?C.value:null}}return U}),P=i0.deflate(v0(F));console.info("\uD83D\uDCE6 [DELTA SYNC COMPRESSING] Delta compressed for transport."),console.info(`\uD83D\uDE80 [DELTA SYNC SENDING] Found ${q.length} new operations to send.`),await this.syncChannel.send([{type:"deltaSync",operations:P}])}else console.info("\u2705 [ALREADY SYNCED] Peer is up-to-date. Nothing to send.")},deltaSync:(V)=>{console.info("\uD83D\uDEF0\uFE0F [DELTA SYNC RECEIVED] Compressed delta sync received.");let X=t1(i0.inflate(V.operations));console.info("\uD83D\uDEF0\uFE0F [DELTA SYNC DECOMPRESSING] Decompressing delta..."),console.info(`\uD83D\uDEF0\uFE0F [DELTA SYNC APPLYING] Applying ${X.length} operations from a peer.`);for(let Y of X)Q[Y.type]?.(Y)},syncReceive:async(V)=>{if(console.info("\uD83D\uDCE6 [FULL SYNC RECEIVED] Overwriting local state with full graph from a peer."),V.graph)await this.applyFullGraph(V.graph),this.oplog.clear(),console.info("\uD83D\uDD12 Oplog has been cleared due to full sync."),G=!0;else console.error("\u274C Full sync failed: received graph data is invalid.",V.graph)}};for(let V of W)if(Q[V.type])await Q[V.type](V);else console.warn(`\uD83E\uDD37\u200D\u2640\uFE0F [UNKNOWN MESSAGE TYPE] Received unhandled message type: "${V.type}"`);if(J)console.info("\uD83D\uDCC8 [LOCAL TIMESTAMP] Updated."),this.saveGlobalTimestamp(J);if(G)console.info("\uD83D\uDCBE [STATE CHANGED] Saving state and emitting update."),await this.saveGraphToOPFS(),this.emit()}}export{vW as default};
