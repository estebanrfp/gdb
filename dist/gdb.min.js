function H8(J){const Q=J.length;let W=0,V=0;while(V<Q){let G=J.charCodeAt(V++);if((G&4294967168)===0){W++;continue}else if((G&4294965248)===0)W+=2;else{if(G>=55296&&G<=56319){if(V<Q){const X=J.charCodeAt(V);if((X&64512)===56320)++V,G=((G&1023)<<10)+(X&1023)+65536}}if((G&4294901760)===0)W+=3;else W+=4}}return W}function e6(J,Q,W){const V=J.length;let G=W,X=0;while(X<V){let Y=J.charCodeAt(X++);if((Y&4294967168)===0){Q[G++]=Y;continue}else if((Y&4294965248)===0)Q[G++]=Y>>6&31|192;else{if(Y>=55296&&Y<=56319){if(X<V){const q=J.charCodeAt(X);if((q&64512)===56320)++X,Y=((Y&1023)<<10)+(q&1023)+65536}}if((Y&4294901760)===0)Q[G++]=Y>>12&15|224,Q[G++]=Y>>6&63|128;else Q[G++]=Y>>18&7|240,Q[G++]=Y>>12&63|128,Q[G++]=Y>>6&63|128}Q[G++]=Y&63|128}}function J5(J,Q,W){t6.encodeInto(J,Q.subarray(W))}function k8(J,Q,W){if(J.length>s6)J5(J,Q,W);else e6(J,Q,W)}function S1(J,Q,W){let V=Q;const G=V+W,X=[];let Y="";while(V<G){const q=J[V++];if((q&128)===0)X.push(q);else if((q&224)===192){const F=J[V++]&63;X.push((q&31)<<6|F)}else if((q&240)===224){const F=J[V++]&63,U=J[V++]&63;X.push((q&31)<<12|F<<6|U)}else if((q&248)===240){const F=J[V++]&63,U=J[V++]&63,P=J[V++]&63;let $=(q&7)<<18|F<<12|U<<6|P;if($>65535)$-=65536,X.push($>>>10&1023|55296),$=56320|$&1023;X.push($)}else X.push(q);if(X.length>=W5)Y+=String.fromCharCode(...X),X.length=0}if(X.length>0)Y+=String.fromCharCode(...X);return Y}function G5(J,Q,W){const V=J.subarray(Q,Q+W);return Q5.decode(V)}function $8(J,Q,W){if(W>V5)return G5(J,Q,W);else return S1(J,Q,W)}var t6=new TextEncoder,s6=50,W5=4096,Q5=new TextDecoder,V5=200;class A0{constructor(J,Q){this.type=J,this.data=Q}}class i extends Error{constructor(J){super(J);const Q=Object.create(i.prototype);Object.setPrototypeOf(this,Q),Object.defineProperty(this,"name",{configurable:!0,enumerable:!1,value:i.name})}}function B8(J,Q,W){const V=W/4294967296,G=W;J.setUint32(Q,V),J.setUint32(Q+4,G)}function K1(J,Q,W){const V=Math.floor(W/4294967296),G=W;J.setUint32(Q,V),J.setUint32(Q+4,G)}function F1(J,Q){const W=J.getInt32(Q),V=J.getUint32(Q+4);return W*4294967296+V}function j8(J,Q){const W=J.getUint32(Q),V=J.getUint32(Q+4);return W*4294967296+V}var N0=4294967295;function Y5({sec:J,nsec:Q}){if(J>=0&&Q>=0&&J<=q5)if(Q===0&&J<=U5){const W=new Uint8Array(4);return new DataView(W.buffer).setUint32(0,J),W}else{const W=J/4294967296,V=J&4294967295,G=new Uint8Array(8),X=new DataView(G.buffer);return X.setUint32(0,Q<<2|W&3),X.setUint32(4,V),G}else{const W=new Uint8Array(12),V=new DataView(W.buffer);return V.setUint32(0,Q),K1(V,4,J),W}}function P5(J){const Q=J.getTime(),W=Math.floor(Q/1000),V=(Q-W*1000)*1e6,G=Math.floor(V/1e9);return{sec:W+G,nsec:V-G*1e9}}function K5(J){if(J instanceof Date){const Q=P5(J);return Y5(Q)}else return null}function F5(J){const Q=new DataView(J.buffer,J.byteOffset,J.byteLength);switch(J.byteLength){case 4:return{sec:Q.getUint32(0),nsec:0};case 8:{const W=Q.getUint32(0),V=Q.getUint32(4),G=(W&3)*4294967296+V,X=W>>>2;return{sec:G,nsec:X}}case 12:{const W=F1(Q,4),V=Q.getUint32(0);return{sec:W,nsec:V}}default:throw new i(`Unrecognized data size for timestamp (expected 4, 8, or 12): ${J.length}`)}}function z5(J){const Q=F5(J);return new Date(Q.sec*1000+Q.nsec/1e6)}var X5=-1,U5=4294967295,q5=17179869183,R8={type:X5,encode:K5,decode:z5};class $0{constructor(){this.builtInEncoders=[],this.builtInDecoders=[],this.encoders=[],this.decoders=[],this.register(R8)}register({type:J,encode:Q,decode:W}){if(J>=0)this.encoders[J]=Q,this.decoders[J]=W;else{const V=-1-J;this.builtInEncoders[V]=Q,this.builtInDecoders[V]=W}}tryToEncode(J,Q){for(let W=0;W<this.builtInEncoders.length;W++){const V=this.builtInEncoders[W];if(V!=null){const G=V(J,Q);if(G!=null){const X=-1-W;return new A0(X,G)}}}for(let W=0;W<this.encoders.length;W++){const V=this.encoders[W];if(V!=null){const G=V(J,Q);if(G!=null)return new A0(W,G)}}if(J instanceof A0)return J;return null}decode(J,Q,W){const V=Q<0?this.builtInDecoders[-1-Q]:this.decoders[Q];if(V)return V(J,Q,W);else return new A0(Q,J)}}$0.defaultCodec=new $0;var Z5=function(J){return J instanceof ArrayBuffer||typeof SharedArrayBuffer!=="undefined"&&J instanceof SharedArrayBuffer};function b0(J){if(J instanceof Uint8Array)return J;else if(ArrayBuffer.isView(J))return new Uint8Array(J.buffer,J.byteOffset,J.byteLength);else if(Z5(J))return new Uint8Array(J);else return Uint8Array.from(J)}var H5=100,k5=2048;class z1{constructor(J){this.entered=!1,this.extensionCodec=J?.extensionCodec??$0.defaultCodec,this.context=J?.context,this.useBigInt64=J?.useBigInt64??!1,this.maxDepth=J?.maxDepth??H5,this.initialBufferSize=J?.initialBufferSize??k5,this.sortKeys=J?.sortKeys??!1,this.forceFloat32=J?.forceFloat32??!1,this.ignoreUndefined=J?.ignoreUndefined??!1,this.forceIntegerToFloat=J?.forceIntegerToFloat??!1,this.pos=0,this.view=new DataView(new ArrayBuffer(this.initialBufferSize)),this.bytes=new Uint8Array(this.view.buffer)}clone(){return new z1({extensionCodec:this.extensionCodec,context:this.context,useBigInt64:this.useBigInt64,maxDepth:this.maxDepth,initialBufferSize:this.initialBufferSize,sortKeys:this.sortKeys,forceFloat32:this.forceFloat32,ignoreUndefined:this.ignoreUndefined,forceIntegerToFloat:this.forceIntegerToFloat})}reinitializeState(){this.pos=0}encodeSharedRef(J){if(this.entered)return this.clone().encodeSharedRef(J);try{return this.entered=!0,this.reinitializeState(),this.doEncode(J,1),this.bytes.subarray(0,this.pos)}finally{this.entered=!1}}encode(J){if(this.entered)return this.clone().encode(J);try{return this.entered=!0,this.reinitializeState(),this.doEncode(J,1),this.bytes.slice(0,this.pos)}finally{this.entered=!1}}doEncode(J,Q){if(Q>this.maxDepth)throw new Error(`Too deep objects in depth ${Q}`);if(J==null)this.encodeNil();else if(typeof J==="boolean")this.encodeBoolean(J);else if(typeof J==="number")if(!this.forceIntegerToFloat)this.encodeNumber(J);else this.encodeNumberAsFloat(J);else if(typeof J==="string")this.encodeString(J);else if(this.useBigInt64&&typeof J==="bigint")this.encodeBigInt64(J);else this.encodeObject(J,Q)}ensureBufferSizeToWrite(J){const Q=this.pos+J;if(this.view.byteLength<Q)this.resizeBuffer(Q*2)}resizeBuffer(J){const Q=new ArrayBuffer(J),W=new Uint8Array(Q),V=new DataView(Q);W.set(this.bytes),this.view=V,this.bytes=W}encodeNil(){this.writeU8(192)}encodeBoolean(J){if(J===!1)this.writeU8(194);else this.writeU8(195)}encodeNumber(J){if(!this.forceIntegerToFloat&&Number.isSafeInteger(J))if(J>=0)if(J<128)this.writeU8(J);else if(J<256)this.writeU8(204),this.writeU8(J);else if(J<65536)this.writeU8(205),this.writeU16(J);else if(J<4294967296)this.writeU8(206),this.writeU32(J);else if(!this.useBigInt64)this.writeU8(207),this.writeU64(J);else this.encodeNumberAsFloat(J);else if(J>=-32)this.writeU8(224|J+32);else if(J>=-128)this.writeU8(208),this.writeI8(J);else if(J>=-32768)this.writeU8(209),this.writeI16(J);else if(J>=-2147483648)this.writeU8(210),this.writeI32(J);else if(!this.useBigInt64)this.writeU8(211),this.writeI64(J);else this.encodeNumberAsFloat(J);else this.encodeNumberAsFloat(J)}encodeNumberAsFloat(J){if(this.forceFloat32)this.writeU8(202),this.writeF32(J);else this.writeU8(203),this.writeF64(J)}encodeBigInt64(J){if(J>=BigInt(0))this.writeU8(207),this.writeBigUint64(J);else this.writeU8(211),this.writeBigInt64(J)}writeStringHeader(J){if(J<32)this.writeU8(160+J);else if(J<256)this.writeU8(217),this.writeU8(J);else if(J<65536)this.writeU8(218),this.writeU16(J);else if(J<4294967296)this.writeU8(219),this.writeU32(J);else throw new Error(`Too long string: ${J} bytes in UTF-8`)}encodeString(J){const W=H8(J);this.ensureBufferSizeToWrite(5+W),this.writeStringHeader(W),k8(J,this.bytes,this.pos),this.pos+=W}encodeObject(J,Q){const W=this.extensionCodec.tryToEncode(J,this.context);if(W!=null)this.encodeExtension(W);else if(Array.isArray(J))this.encodeArray(J,Q);else if(ArrayBuffer.isView(J))this.encodeBinary(J);else if(typeof J==="object")this.encodeMap(J,Q);else throw new Error(`Unrecognized object: ${Object.prototype.toString.apply(J)}`)}encodeBinary(J){const Q=J.byteLength;if(Q<256)this.writeU8(196),this.writeU8(Q);else if(Q<65536)this.writeU8(197),this.writeU16(Q);else if(Q<4294967296)this.writeU8(198),this.writeU32(Q);else throw new Error(`Too large binary: ${Q}`);const W=b0(J);this.writeU8a(W)}encodeArray(J,Q){const W=J.length;if(W<16)this.writeU8(144+W);else if(W<65536)this.writeU8(220),this.writeU16(W);else if(W<4294967296)this.writeU8(221),this.writeU32(W);else throw new Error(`Too large array: ${W}`);for(let V of J)this.doEncode(V,Q+1)}countWithoutUndefined(J,Q){let W=0;for(let V of Q)if(J[V]!==void 0)W++;return W}encodeMap(J,Q){const W=Object.keys(J);if(this.sortKeys)W.sort();const V=this.ignoreUndefined?this.countWithoutUndefined(J,W):W.length;if(V<16)this.writeU8(128+V);else if(V<65536)this.writeU8(222),this.writeU16(V);else if(V<4294967296)this.writeU8(223),this.writeU32(V);else throw new Error(`Too large map object: ${V}`);for(let G of W){const X=J[G];if(!(this.ignoreUndefined&&X===void 0))this.encodeString(G),this.doEncode(X,Q+1)}}encodeExtension(J){if(typeof J.data==="function"){const W=J.data(this.pos+6),V=W.length;if(V>=4294967296)throw new Error(`Too large extension object: ${V}`);this.writeU8(201),this.writeU32(V),this.writeI8(J.type),this.writeU8a(W);return}const Q=J.data.length;if(Q===1)this.writeU8(212);else if(Q===2)this.writeU8(213);else if(Q===4)this.writeU8(214);else if(Q===8)this.writeU8(215);else if(Q===16)this.writeU8(216);else if(Q<256)this.writeU8(199),this.writeU8(Q);else if(Q<65536)this.writeU8(200),this.writeU16(Q);else if(Q<4294967296)this.writeU8(201),this.writeU32(Q);else throw new Error(`Too large extension object: ${Q}`);this.writeI8(J.type),this.writeU8a(J.data)}writeU8(J){this.ensureBufferSizeToWrite(1),this.view.setUint8(this.pos,J),this.pos++}writeU8a(J){const Q=J.length;this.ensureBufferSizeToWrite(Q),this.bytes.set(J,this.pos),this.pos+=Q}writeI8(J){this.ensureBufferSizeToWrite(1),this.view.setInt8(this.pos,J),this.pos++}writeU16(J){this.ensureBufferSizeToWrite(2),this.view.setUint16(this.pos,J),this.pos+=2}writeI16(J){this.ensureBufferSizeToWrite(2),this.view.setInt16(this.pos,J),this.pos+=2}writeU32(J){this.ensureBufferSizeToWrite(4),this.view.setUint32(this.pos,J),this.pos+=4}writeI32(J){this.ensureBufferSizeToWrite(4),this.view.setInt32(this.pos,J),this.pos+=4}writeF32(J){this.ensureBufferSizeToWrite(4),this.view.setFloat32(this.pos,J),this.pos+=4}writeF64(J){this.ensureBufferSizeToWrite(8),this.view.setFloat64(this.pos,J),this.pos+=8}writeU64(J){this.ensureBufferSizeToWrite(8),B8(this.view,this.pos,J),this.pos+=8}writeI64(J){this.ensureBufferSizeToWrite(8),K1(this.view,this.pos,J),this.pos+=8}writeBigUint64(J){this.ensureBufferSizeToWrite(8),this.view.setBigUint64(this.pos,J),this.pos+=8}writeBigInt64(J){this.ensureBufferSizeToWrite(8),this.view.setBigInt64(this.pos,J),this.pos+=8}}function u0(J,Q){return new z1(Q).encodeSharedRef(J)}function Z1(J){return`${J<0?"-":""}0x${Math.abs(J).toString(16).padStart(2,"0")}`}var $5=16,B5=16;class T1{constructor(J=$5,Q=B5){this.hit=0,this.miss=0,this.maxKeyLength=J,this.maxLengthPerKey=Q,this.caches=[];for(let W=0;W<this.maxKeyLength;W++)this.caches.push([])}canBeCached(J){return J>0&&J<=this.maxKeyLength}find(J,Q,W){const V=this.caches[W-1];J:for(let G of V){const X=G.bytes;for(let Y=0;Y<W;Y++)if(X[Y]!==J[Q+Y])continue J;return G.str}return null}store(J,Q){const W=this.caches[J.length-1],V={bytes:J,str:Q};if(W.length>=this.maxLengthPerKey)W[Math.random()*W.length|0]=V;else W.push(V)}decode(J,Q,W){const V=this.find(J,Q,W);if(V!=null)return this.hit++,V;this.miss++;const G=S1(J,Q,W),X=Uint8Array.prototype.slice.call(J,Q,Q+W);return this.store(X,G),G}}var g1="array",c0="map_key",C8="map_value",j5=(J)=>{if(typeof J==="string"||typeof J==="number")return J;throw new i("The type of key must be string or number but "+typeof J)};class L8{constructor(){this.stack=[],this.stackHeadPosition=-1}get length(){return this.stackHeadPosition+1}top(){return this.stack[this.stackHeadPosition]}pushArrayState(J){const Q=this.getUninitializedStateFromPool();Q.type=g1,Q.position=0,Q.size=J,Q.array=new Array(J)}pushMapState(J){const Q=this.getUninitializedStateFromPool();Q.type=c0,Q.readCount=0,Q.size=J,Q.map={}}getUninitializedStateFromPool(){if(this.stackHeadPosition++,this.stackHeadPosition===this.stack.length){const J={type:void 0,size:0,array:void 0,position:0,readCount:0,map:void 0,key:null};this.stack.push(J)}return this.stack[this.stackHeadPosition]}release(J){if(this.stack[this.stackHeadPosition]!==J)throw new Error("Invalid stack state. Released state is not on top of the stack.");if(J.type===g1){const W=J;W.size=0,W.array=void 0,W.position=0,W.type=void 0}if(J.type===c0||J.type===C8){const W=J;W.size=0,W.map=void 0,W.readCount=0,W.type=void 0}this.stackHeadPosition--}reset(){this.stack.length=0,this.stackHeadPosition=-1}}var m0=-1,v1=new DataView(new ArrayBuffer(0)),R5=new Uint8Array(v1.buffer);try{v1.getInt8(0)}catch(J){if(!(J instanceof RangeError))throw new Error("This module is not supported in the current JavaScript engine because DataView does not throw RangeError on out-of-bounds access")}var M8=new RangeError("Insufficient data"),M5=new T1;class H1{constructor(J){this.totalPos=0,this.pos=0,this.view=v1,this.bytes=R5,this.headByte=m0,this.stack=new L8,this.entered=!1,this.extensionCodec=J?.extensionCodec??$0.defaultCodec,this.context=J?.context,this.useBigInt64=J?.useBigInt64??!1,this.rawStrings=J?.rawStrings??!1,this.maxStrLength=J?.maxStrLength??N0,this.maxBinLength=J?.maxBinLength??N0,this.maxArrayLength=J?.maxArrayLength??N0,this.maxMapLength=J?.maxMapLength??N0,this.maxExtLength=J?.maxExtLength??N0,this.keyDecoder=J?.keyDecoder!==void 0?J.keyDecoder:M5,this.mapKeyConverter=J?.mapKeyConverter??j5}clone(){return new H1({extensionCodec:this.extensionCodec,context:this.context,useBigInt64:this.useBigInt64,rawStrings:this.rawStrings,maxStrLength:this.maxStrLength,maxBinLength:this.maxBinLength,maxArrayLength:this.maxArrayLength,maxMapLength:this.maxMapLength,maxExtLength:this.maxExtLength,keyDecoder:this.keyDecoder})}reinitializeState(){this.totalPos=0,this.headByte=m0,this.stack.reset()}setBuffer(J){const Q=b0(J);this.bytes=Q,this.view=new DataView(Q.buffer,Q.byteOffset,Q.byteLength),this.pos=0}appendBuffer(J){if(this.headByte===m0&&!this.hasRemaining(1))this.setBuffer(J);else{const Q=this.bytes.subarray(this.pos),W=b0(J),V=new Uint8Array(Q.length+W.length);V.set(Q),V.set(W,Q.length),this.setBuffer(V)}}hasRemaining(J){return this.view.byteLength-this.pos>=J}createExtraByteError(J){const{view:Q,pos:W}=this;return new RangeError(`Extra ${Q.byteLength-W} of ${Q.byteLength} byte(s) found at buffer[${J}]`)}decode(J){if(this.entered)return this.clone().decode(J);try{this.entered=!0,this.reinitializeState(),this.setBuffer(J);const Q=this.doDecodeSync();if(this.hasRemaining(1))throw this.createExtraByteError(this.pos);return Q}finally{this.entered=!1}}*decodeMulti(J){if(this.entered){yield*this.clone().decodeMulti(J);return}try{this.entered=!0,this.reinitializeState(),this.setBuffer(J);while(this.hasRemaining(1))yield this.doDecodeSync()}finally{this.entered=!1}}async decodeAsync(J){if(this.entered)return this.clone().decodeAsync(J);try{this.entered=!0;let Q=!1,W;for await(let Y of J){if(Q)throw this.entered=!1,this.createExtraByteError(this.totalPos);this.appendBuffer(Y);try{W=this.doDecodeSync(),Q=!0}catch(q){if(!(q instanceof RangeError))throw q}this.totalPos+=this.pos}if(Q){if(this.hasRemaining(1))throw this.createExtraByteError(this.totalPos);return W}const{headByte:V,pos:G,totalPos:X}=this;throw new RangeError(`Insufficient data in parsing ${Z1(V)} at ${X} (${G} in the current buffer)`)}finally{this.entered=!1}}decodeArrayStream(J){return this.decodeMultiAsync(J,!0)}decodeStream(J){return this.decodeMultiAsync(J,!1)}async*decodeMultiAsync(J,Q){if(this.entered){yield*this.clone().decodeMultiAsync(J,Q);return}try{this.entered=!0;let W=Q,V=-1;for await(let G of J){if(Q&&V===0)throw this.createExtraByteError(this.totalPos);if(this.appendBuffer(G),W)V=this.readArraySize(),W=!1,this.complete();try{while(!0)if(yield this.doDecodeSync(),--V===0)break}catch(X){if(!(X instanceof RangeError))throw X}this.totalPos+=this.pos}}finally{this.entered=!1}}doDecodeSync(){J:while(!0){const J=this.readHeadByte();let Q;if(J>=224)Q=J-256;else if(J<192)if(J<128)Q=J;else if(J<144){const V=J-128;if(V!==0){this.pushMapState(V),this.complete();continue J}else Q={}}else if(J<160){const V=J-144;if(V!==0){this.pushArrayState(V),this.complete();continue J}else Q=[]}else{const V=J-160;Q=this.decodeString(V,0)}else if(J===192)Q=null;else if(J===194)Q=!1;else if(J===195)Q=!0;else if(J===202)Q=this.readF32();else if(J===203)Q=this.readF64();else if(J===204)Q=this.readU8();else if(J===205)Q=this.readU16();else if(J===206)Q=this.readU32();else if(J===207)if(this.useBigInt64)Q=this.readU64AsBigInt();else Q=this.readU64();else if(J===208)Q=this.readI8();else if(J===209)Q=this.readI16();else if(J===210)Q=this.readI32();else if(J===211)if(this.useBigInt64)Q=this.readI64AsBigInt();else Q=this.readI64();else if(J===217){const V=this.lookU8();Q=this.decodeString(V,1)}else if(J===218){const V=this.lookU16();Q=this.decodeString(V,2)}else if(J===219){const V=this.lookU32();Q=this.decodeString(V,4)}else if(J===220){const V=this.readU16();if(V!==0){this.pushArrayState(V),this.complete();continue J}else Q=[]}else if(J===221){const V=this.readU32();if(V!==0){this.pushArrayState(V),this.complete();continue J}else Q=[]}else if(J===222){const V=this.readU16();if(V!==0){this.pushMapState(V),this.complete();continue J}else Q={}}else if(J===223){const V=this.readU32();if(V!==0){this.pushMapState(V),this.complete();continue J}else Q={}}else if(J===196){const V=this.lookU8();Q=this.decodeBinary(V,1)}else if(J===197){const V=this.lookU16();Q=this.decodeBinary(V,2)}else if(J===198){const V=this.lookU32();Q=this.decodeBinary(V,4)}else if(J===212)Q=this.decodeExtension(1,0);else if(J===213)Q=this.decodeExtension(2,0);else if(J===214)Q=this.decodeExtension(4,0);else if(J===215)Q=this.decodeExtension(8,0);else if(J===216)Q=this.decodeExtension(16,0);else if(J===199){const V=this.lookU8();Q=this.decodeExtension(V,1)}else if(J===200){const V=this.lookU16();Q=this.decodeExtension(V,2)}else if(J===201){const V=this.lookU32();Q=this.decodeExtension(V,4)}else throw new i(`Unrecognized type byte: ${Z1(J)}`);this.complete();const W=this.stack;while(W.length>0){const V=W.top();if(V.type===g1)if(V.array[V.position]=Q,V.position++,V.position===V.size)Q=V.array,W.release(V);else continue J;else if(V.type===c0){if(Q==="__proto__")throw new i("The key __proto__ is not allowed");V.key=this.mapKeyConverter(Q),V.type=C8;continue J}else if(V.map[V.key]=Q,V.readCount++,V.readCount===V.size)Q=V.map,W.release(V);else{V.key=null,V.type=c0;continue J}}return Q}}readHeadByte(){if(this.headByte===m0)this.headByte=this.readU8();return this.headByte}complete(){this.headByte=m0}readArraySize(){const J=this.readHeadByte();switch(J){case 220:return this.readU16();case 221:return this.readU32();default:if(J<160)return J-144;else throw new i(`Unrecognized array type byte: ${Z1(J)}`)}}pushMapState(J){if(J>this.maxMapLength)throw new i(`Max length exceeded: map length (${J}) > maxMapLengthLength (${this.maxMapLength})`);this.stack.pushMapState(J)}pushArrayState(J){if(J>this.maxArrayLength)throw new i(`Max length exceeded: array length (${J}) > maxArrayLength (${this.maxArrayLength})`);this.stack.pushArrayState(J)}decodeString(J,Q){if(!this.rawStrings||this.stateIsMapKey())return this.decodeUtf8String(J,Q);return this.decodeBinary(J,Q)}decodeUtf8String(J,Q){if(J>this.maxStrLength)throw new i(`Max length exceeded: UTF-8 byte length (${J}) > maxStrLength (${this.maxStrLength})`);if(this.bytes.byteLength<this.pos+Q+J)throw M8;const W=this.pos+Q;let V;if(this.stateIsMapKey()&&this.keyDecoder?.canBeCached(J))V=this.keyDecoder.decode(this.bytes,W,J);else V=$8(this.bytes,W,J);return this.pos+=Q+J,V}stateIsMapKey(){if(this.stack.length>0)return this.stack.top().type===c0;return!1}decodeBinary(J,Q){if(J>this.maxBinLength)throw new i(`Max length exceeded: bin length (${J}) > maxBinLength (${this.maxBinLength})`);if(!this.hasRemaining(J+Q))throw M8;const W=this.pos+Q,V=this.bytes.subarray(W,W+J);return this.pos+=Q+J,V}decodeExtension(J,Q){if(J>this.maxExtLength)throw new i(`Max length exceeded: ext length (${J}) > maxExtLength (${this.maxExtLength})`);const W=this.view.getInt8(this.pos+Q),V=this.decodeBinary(J,Q+1);return this.extensionCodec.decode(V,W,this.context)}lookU8(){return this.view.getUint8(this.pos)}lookU16(){return this.view.getUint16(this.pos)}lookU32(){return this.view.getUint32(this.pos)}readU8(){const J=this.view.getUint8(this.pos);return this.pos++,J}readI8(){const J=this.view.getInt8(this.pos);return this.pos++,J}readU16(){const J=this.view.getUint16(this.pos);return this.pos+=2,J}readI16(){const J=this.view.getInt16(this.pos);return this.pos+=2,J}readU32(){const J=this.view.getUint32(this.pos);return this.pos+=4,J}readI32(){const J=this.view.getInt32(this.pos);return this.pos+=4,J}readU64(){const J=j8(this.view,this.pos);return this.pos+=8,J}readI64(){const J=F1(this.view,this.pos);return this.pos+=8,J}readU64AsBigInt(){const J=this.view.getBigUint64(this.pos);return this.pos+=8,J}readI64AsBigInt(){const J=this.view.getBigInt64(this.pos);return this.pos+=8,J}readF32(){const J=this.view.getFloat32(this.pos);return this.pos+=4,J}readF64(){const J=this.view.getFloat64(this.pos);return this.pos+=8,J}}function B0(J,Q){return new H1(Q).decode(J)}var E0=function(J){let Q=J.length;while(--Q>=0)J[Q]=0},E1=function(J,Q,W,V,G){this.static_tree=J,this.extra_bits=Q,this.extra_base=W,this.elems=V,this.max_length=G,this.has_stree=J&&J.length},f1=function(J,Q){this.dyn_tree=J,this.max_code=0,this.stat_desc=Q},J0=function(J,Q,W,V,G){this.good_length=J,this.max_lazy=Q,this.nice_length=W,this.max_chain=V,this.func=G},LJ=function(){this.strm=null,this.status=0,this.pending_buf=null,this.pending_buf_size=0,this.pending_out=0,this.pending=0,this.wrap=0,this.gzhead=null,this.gzindex=0,this.method=x1,this.last_flush=-1,this.w_size=0,this.w_bits=0,this.w_mask=0,this.window=null,this.window_size=0,this.prev=null,this.head=null,this.ins_h=0,this.hash_size=0,this.hash_bits=0,this.hash_mask=0,this.hash_shift=0,this.block_start=0,this.match_length=0,this.prev_match=0,this.match_available=0,this.strstart=0,this.match_start=0,this.lookahead=0,this.prev_length=0,this.max_chain_length=0,this.max_lazy_match=0,this.level=0,this.strategy=0,this.good_match=0,this.nice_match=0,this.dyn_ltree=new Uint16Array(ZJ*2),this.dyn_dtree=new Uint16Array((2*FJ+1)*2),this.bl_tree=new Uint16Array((2*zJ+1)*2),F0(this.dyn_ltree),F0(this.dyn_dtree),F0(this.bl_tree),this.l_desc=null,this.d_desc=null,this.bl_desc=null,this.bl_count=new Uint16Array(HJ+1),this.heap=new Uint16Array(2*e1+1),F0(this.heap),this.heap_len=0,this.heap_max=0,this.depth=new Uint16Array(2*e1+1),F0(this.depth),this.sym_buf=0,this.lit_bufsize=0,this.sym_next=0,this.sym_end=0,this.opt_len=0,this.static_len=0,this.matches=0,this.insert=0,this.bi_buf=0,this.bi_valid=0},dJ=function(){this.input=null,this.next_in=0,this.avail_in=0,this.total_in=0,this.output=null,this.next_out=0,this.avail_out=0,this.total_out=0,this.msg="",this.state=null,this.data_type=2,this.adler=0},X1=function(J){this.options=O1.assign({level:aJ,method:tJ,chunkSize:16384,windowBits:15,memLevel:8,strategy:eJ},J||{});let Q=this.options;if(Q.raw&&Q.windowBits>0)Q.windowBits=-Q.windowBits;else if(Q.gzip&&Q.windowBits>0&&Q.windowBits<16)Q.windowBits+=16;this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new A6,this.strm.avail_out=0;let W=n0.deflateInit2(this.strm,Q.level,Q.method,Q.windowBits,Q.memLevel,Q.strategy);if(W!==L1)throw new Error(C0[W]);if(Q.header)n0.deflateSetHeader(this.strm,Q.header);if(Q.dictionary){let V;if(typeof Q.dictionary==="string")V=W1.string2buf(Q.dictionary);else if(N6.call(Q.dictionary)==="[object ArrayBuffer]")V=new Uint8Array(Q.dictionary);else V=Q.dictionary;if(W=n0.deflateSetDictionary(this.strm,V),W!==L1)throw new Error(C0[W]);this._dict_set=!0}},Y8=function(J,Q){const W=new X1(Q);if(W.push(J,!0),W.err)throw W.msg||C0[W.err];return W.result},sJ=function(J,Q){return Q=Q||{},Q.raw=!0,Y8(J,Q)},JW=function(J,Q){return Q=Q||{},Q.gzip=!0,Y8(J,Q)},IW=function(){this.strm=null,this.mode=0,this.last=!1,this.wrap=0,this.havedict=!1,this.flags=0,this.dmax=0,this.check=0,this.total=0,this.head=null,this.wbits=0,this.wsize=0,this.whave=0,this.wnext=0,this.window=null,this.hold=0,this.bits=0,this.length=0,this.offset=0,this.extra=0,this.lencode=null,this.distcode=null,this.lenbits=0,this.distbits=0,this.ncode=0,this.nlen=0,this.ndist=0,this.have=0,this.next=null,this.lens=new Uint16Array(320),this.work=new Uint16Array(288),this.lendyn=null,this.distdyn=null,this.sane=0,this.back=0,this.was=0},uW=function(){this.text=0,this.time=0,this.xflags=0,this.os=0,this.extra=null,this.extra_len=0,this.name="",this.comment="",this.hcrc=0,this.done=!1},U1=function(J){this.options=O1.assign({chunkSize:65536,windowBits:15,to:""},J||{});const Q=this.options;if(Q.raw&&Q.windowBits>=0&&Q.windowBits<16){if(Q.windowBits=-Q.windowBits,Q.windowBits===0)Q.windowBits=-15}if(Q.windowBits>=0&&Q.windowBits<16&&!(J&&J.windowBits))Q.windowBits+=32;if(Q.windowBits>15&&Q.windowBits<48){if((Q.windowBits&15)===0)Q.windowBits|=15}this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new A6,this.strm.avail_out=0;let W=q0.inflateInit2(this.strm,Q.windowBits);if(W!==Q1)throw new Error(C0[W]);if(this.header=new mW,q0.inflateGetHeader(this.strm,this.header),Q.dictionary){if(typeof Q.dictionary==="string")Q.dictionary=W1.string2buf(Q.dictionary);else if(m6.call(Q.dictionary)==="[object ArrayBuffer]")Q.dictionary=new Uint8Array(Q.dictionary);if(Q.raw){if(W=q0.inflateSetDictionary(this.strm,Q.dictionary),W!==Q1)throw new Error(C0[W])}}},P8=function(J,Q){const W=new U1(Q);if(W.push(J),W.err)throw W.msg||C0[W.err];return W.result},lW=function(J,Q){return Q=Q||{},Q.raw=!0,P8(J,Q)};/*! pako 2.1.0 https://github.com/nodeca/pako @license (MIT AND Zlib) */var C5=0,q6=1,L5=2,I5=3,x5=258,V8=29,V1=256,o0=V1+1+V8,g0=30,G8=19,Y6=2*o0+1,j0=15,y1=16,O5=7,X8=256,P6=16,K6=17,F6=18,r1=new Uint8Array([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0]),M1=new Uint8Array([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13]),w5=new Uint8Array([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7]),z6=new Uint8Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),D5=512,U0=new Array((o0+2)*2);E0(U0);var l0=new Array(g0*2);E0(l0);var a0=new Array(D5);E0(a0);var e0=new Array(x5-I5+1);E0(e0);var U8=new Array(V8);E0(U8);var C1=new Array(g0);E0(C1);var Z6,H6,k6,$6=(J)=>{return J<256?a0[J]:a0[256+(J>>>7)]},t0=(J,Q)=>{J.pending_buf[J.pending++]=Q&255,J.pending_buf[J.pending++]=Q>>>8&255},n=(J,Q,W)=>{if(J.bi_valid>y1-W)J.bi_buf|=Q<<J.bi_valid&65535,t0(J,J.bi_buf),J.bi_buf=Q>>y1-J.bi_valid,J.bi_valid+=W-y1;else J.bi_buf|=Q<<J.bi_valid&65535,J.bi_valid+=W},W0=(J,Q,W)=>{n(J,W[Q*2],W[Q*2+1])},B6=(J,Q)=>{let W=0;do W|=J&1,J>>>=1,W<<=1;while(--Q>0);return W>>>1},A5=(J)=>{if(J.bi_valid===16)t0(J,J.bi_buf),J.bi_buf=0,J.bi_valid=0;else if(J.bi_valid>=8)J.pending_buf[J.pending++]=J.bi_buf&255,J.bi_buf>>=8,J.bi_valid-=8},N5=(J,Q)=>{const{dyn_tree:W,max_code:V}=Q,G=Q.stat_desc.static_tree,X=Q.stat_desc.has_stree,Y=Q.stat_desc.extra_bits,q=Q.stat_desc.extra_base,F=Q.stat_desc.max_length;let U,P,$,z,K,k,O=0;for(z=0;z<=j0;z++)J.bl_count[z]=0;W[J.heap[J.heap_max]*2+1]=0;for(U=J.heap_max+1;U<Y6;U++){if(P=J.heap[U],z=W[W[P*2+1]*2+1]+1,z>F)z=F,O++;if(W[P*2+1]=z,P>V)continue;if(J.bl_count[z]++,K=0,P>=q)K=Y[P-q];if(k=W[P*2],J.opt_len+=k*(z+K),X)J.static_len+=k*(G[P*2+1]+K)}if(O===0)return;do{z=F-1;while(J.bl_count[z]===0)z--;J.bl_count[z]--,J.bl_count[z+1]+=2,J.bl_count[F]--,O-=2}while(O>0);for(z=F;z!==0;z--){P=J.bl_count[z];while(P!==0){if($=J.heap[--U],$>V)continue;if(W[$*2+1]!==z)J.opt_len+=(z-W[$*2+1])*W[$*2],W[$*2+1]=z;P--}}},j6=(J,Q,W)=>{const V=new Array(j0+1);let G=0,X,Y;for(X=1;X<=j0;X++)G=G+W[X-1]<<1,V[X]=G;for(Y=0;Y<=Q;Y++){let q=J[Y*2+1];if(q===0)continue;J[Y*2]=B6(V[q]++,q)}},S5=()=>{let J,Q,W,V,G;const X=new Array(j0+1);W=0;for(V=0;V<V8-1;V++){U8[V]=W;for(J=0;J<1<<r1[V];J++)e0[W++]=V}e0[W-1]=V,G=0;for(V=0;V<16;V++){C1[V]=G;for(J=0;J<1<<M1[V];J++)a0[G++]=V}G>>=7;for(;V<g0;V++){C1[V]=G<<7;for(J=0;J<1<<M1[V]-7;J++)a0[256+G++]=V}for(Q=0;Q<=j0;Q++)X[Q]=0;J=0;while(J<=143)U0[J*2+1]=8,J++,X[8]++;while(J<=255)U0[J*2+1]=9,J++,X[9]++;while(J<=279)U0[J*2+1]=7,J++,X[7]++;while(J<=287)U0[J*2+1]=8,J++,X[8]++;j6(U0,o0+1,X);for(J=0;J<g0;J++)l0[J*2+1]=5,l0[J*2]=B6(J,5);Z6=new E1(U0,r1,V1+1,o0,j0),H6=new E1(l0,M1,0,g0,j0),k6=new E1(new Array(0),w5,0,G8,O5)},R6=(J)=>{let Q;for(Q=0;Q<o0;Q++)J.dyn_ltree[Q*2]=0;for(Q=0;Q<g0;Q++)J.dyn_dtree[Q*2]=0;for(Q=0;Q<G8;Q++)J.bl_tree[Q*2]=0;J.dyn_ltree[X8*2]=1,J.opt_len=J.static_len=0,J.sym_next=J.matches=0},M6=(J)=>{if(J.bi_valid>8)t0(J,J.bi_buf);else if(J.bi_valid>0)J.pending_buf[J.pending++]=J.bi_buf;J.bi_buf=0,J.bi_valid=0},I8=(J,Q,W,V)=>{const G=Q*2,X=W*2;return J[G]<J[X]||J[G]===J[X]&&V[Q]<=V[W]},h1=(J,Q,W)=>{const V=J.heap[W];let G=W<<1;while(G<=J.heap_len){if(G<J.heap_len&&I8(Q,J.heap[G+1],J.heap[G],J.depth))G++;if(I8(Q,V,J.heap[G],J.depth))break;J.heap[W]=J.heap[G],W=G,G<<=1}J.heap[W]=V},x8=(J,Q,W)=>{let V,G,X=0,Y,q;if(J.sym_next!==0)do if(V=J.pending_buf[J.sym_buf+X++]&255,V+=(J.pending_buf[J.sym_buf+X++]&255)<<8,G=J.pending_buf[J.sym_buf+X++],V===0)W0(J,G,Q);else{if(Y=e0[G],W0(J,Y+V1+1,Q),q=r1[Y],q!==0)G-=U8[Y],n(J,G,q);if(V--,Y=$6(V),W0(J,Y,W),q=M1[Y],q!==0)V-=C1[Y],n(J,V,q)}while(X<J.sym_next);W0(J,X8,Q)},o1=(J,Q)=>{const W=Q.dyn_tree,V=Q.stat_desc.static_tree,G=Q.stat_desc.has_stree,X=Q.stat_desc.elems;let Y,q,F=-1,U;J.heap_len=0,J.heap_max=Y6;for(Y=0;Y<X;Y++)if(W[Y*2]!==0)J.heap[++J.heap_len]=F=Y,J.depth[Y]=0;else W[Y*2+1]=0;while(J.heap_len<2)if(U=J.heap[++J.heap_len]=F<2?++F:0,W[U*2]=1,J.depth[U]=0,J.opt_len--,G)J.static_len-=V[U*2+1];Q.max_code=F;for(Y=J.heap_len>>1;Y>=1;Y--)h1(J,W,Y);U=X;do Y=J.heap[1],J.heap[1]=J.heap[J.heap_len--],h1(J,W,1),q=J.heap[1],J.heap[--J.heap_max]=Y,J.heap[--J.heap_max]=q,W[U*2]=W[Y*2]+W[q*2],J.depth[U]=(J.depth[Y]>=J.depth[q]?J.depth[Y]:J.depth[q])+1,W[Y*2+1]=W[q*2+1]=U,J.heap[1]=U++,h1(J,W,1);while(J.heap_len>=2);J.heap[--J.heap_max]=J.heap[1],N5(J,Q),j6(W,F,J.bl_count)},O8=(J,Q,W)=>{let V,G=-1,X,Y=Q[1],q=0,F=7,U=4;if(Y===0)F=138,U=3;Q[(W+1)*2+1]=65535;for(V=0;V<=W;V++){if(X=Y,Y=Q[(V+1)*2+1],++q<F&&X===Y)continue;else if(q<U)J.bl_tree[X*2]+=q;else if(X!==0){if(X!==G)J.bl_tree[X*2]++;J.bl_tree[P6*2]++}else if(q<=10)J.bl_tree[K6*2]++;else J.bl_tree[F6*2]++;if(q=0,G=X,Y===0)F=138,U=3;else if(X===Y)F=6,U=3;else F=7,U=4}},w8=(J,Q,W)=>{let V,G=-1,X,Y=Q[1],q=0,F=7,U=4;if(Y===0)F=138,U=3;for(V=0;V<=W;V++){if(X=Y,Y=Q[(V+1)*2+1],++q<F&&X===Y)continue;else if(q<U)do W0(J,X,J.bl_tree);while(--q!==0);else if(X!==0){if(X!==G)W0(J,X,J.bl_tree),q--;W0(J,P6,J.bl_tree),n(J,q-3,2)}else if(q<=10)W0(J,K6,J.bl_tree),n(J,q-3,3);else W0(J,F6,J.bl_tree),n(J,q-11,7);if(q=0,G=X,Y===0)F=138,U=3;else if(X===Y)F=6,U=3;else F=7,U=4}},T5=(J)=>{let Q;O8(J,J.dyn_ltree,J.l_desc.max_code),O8(J,J.dyn_dtree,J.d_desc.max_code),o1(J,J.bl_desc);for(Q=G8-1;Q>=3;Q--)if(J.bl_tree[z6[Q]*2+1]!==0)break;return J.opt_len+=3*(Q+1)+5+5+4,Q},g5=(J,Q,W,V)=>{let G;n(J,Q-257,5),n(J,W-1,5),n(J,V-4,4);for(G=0;G<V;G++)n(J,J.bl_tree[z6[G]*2+1],3);w8(J,J.dyn_ltree,Q-1),w8(J,J.dyn_dtree,W-1)},v5=(J)=>{let Q=4093624447,W;for(W=0;W<=31;W++,Q>>>=1)if(Q&1&&J.dyn_ltree[W*2]!==0)return 0;if(J.dyn_ltree[18]!==0||J.dyn_ltree[20]!==0||J.dyn_ltree[26]!==0)return 1;for(W=32;W<V1;W++)if(J.dyn_ltree[W*2]!==0)return 1;return 0},D8=!1,y5=(J)=>{if(!D8)S5(),D8=!0;J.l_desc=new f1(J.dyn_ltree,Z6),J.d_desc=new f1(J.dyn_dtree,H6),J.bl_desc=new f1(J.bl_tree,k6),J.bi_buf=0,J.bi_valid=0,R6(J)},C6=(J,Q,W,V)=>{if(n(J,(C5<<1)+(V?1:0),3),M6(J),t0(J,W),t0(J,~W),W)J.pending_buf.set(J.window.subarray(Q,Q+W),J.pending);J.pending+=W},E5=(J)=>{n(J,q6<<1,3),W0(J,X8,U0),A5(J)},f5=(J,Q,W,V)=>{let G,X,Y=0;if(J.level>0){if(J.strm.data_type===2)J.strm.data_type=v5(J);if(o1(J,J.l_desc),o1(J,J.d_desc),Y=T5(J),G=J.opt_len+3+7>>>3,X=J.static_len+3+7>>>3,X<=G)G=X}else G=X=W+5;if(W+4<=G&&Q!==-1)C6(J,Q,W,V);else if(J.strategy===4||X===G)n(J,(q6<<1)+(V?1:0),3),x8(J,U0,l0);else n(J,(L5<<1)+(V?1:0),3),g5(J,J.l_desc.max_code+1,J.d_desc.max_code+1,Y+1),x8(J,J.dyn_ltree,J.dyn_dtree);if(R6(J),V)M6(J)},h5=(J,Q,W)=>{if(J.pending_buf[J.sym_buf+J.sym_next++]=Q,J.pending_buf[J.sym_buf+J.sym_next++]=Q>>8,J.pending_buf[J.sym_buf+J.sym_next++]=W,Q===0)J.dyn_ltree[W*2]++;else J.matches++,Q--,J.dyn_ltree[(e0[W]+V1+1)*2]++,J.dyn_dtree[$6(Q)*2]++;return J.sym_next===J.sym_end},p5=y5,b5=C6,u5=f5,m5=h5,c5=E5,_5={_tr_init:p5,_tr_stored_block:b5,_tr_flush_block:u5,_tr_tally:m5,_tr_align:c5},d5=(J,Q,W,V)=>{let G=J&65535|0,X=J>>>16&65535|0,Y=0;while(W!==0){Y=W>2000?2000:W,W-=Y;do G=G+Q[V++]|0,X=X+G|0;while(--Y);G%=65521,X%=65521}return G|X<<16|0},s0=d5,i5=()=>{let J,Q=[];for(var W=0;W<256;W++){J=W;for(var V=0;V<8;V++)J=J&1?3988292384^J>>>1:J>>>1;Q[W]=J}return Q},l5=new Uint32Array(i5()),n5=(J,Q,W,V)=>{const G=l5,X=V+W;J^=-1;for(let Y=V;Y<X;Y++)J=J>>>8^G[(J^Q[Y])&255];return J^-1},_=n5,C0={2:"need dictionary",1:"stream end",0:"","-1":"file error","-2":"stream error","-3":"data error","-4":"insufficient memory","-5":"buffer error","-6":"incompatible version"},x0={Z_NO_FLUSH:0,Z_PARTIAL_FLUSH:1,Z_SYNC_FLUSH:2,Z_FULL_FLUSH:3,Z_FINISH:4,Z_BLOCK:5,Z_TREES:6,Z_OK:0,Z_STREAM_END:1,Z_NEED_DICT:2,Z_ERRNO:-1,Z_STREAM_ERROR:-2,Z_DATA_ERROR:-3,Z_MEM_ERROR:-4,Z_BUF_ERROR:-5,Z_NO_COMPRESSION:0,Z_BEST_SPEED:1,Z_BEST_COMPRESSION:9,Z_DEFAULT_COMPRESSION:-1,Z_FILTERED:1,Z_HUFFMAN_ONLY:2,Z_RLE:3,Z_FIXED:4,Z_DEFAULT_STRATEGY:0,Z_BINARY:0,Z_TEXT:1,Z_UNKNOWN:2,Z_DEFLATED:8},{_tr_init:r5,_tr_stored_block:a1,_tr_flush_block:o5,_tr_tally:Z0,_tr_align:a5}=_5,{Z_NO_FLUSH:H0,Z_PARTIAL_FLUSH:e5,Z_FULL_FLUSH:t5,Z_FINISH:a,Z_BLOCK:A8,Z_OK:d,Z_STREAM_END:N8,Z_STREAM_ERROR:Q0,Z_DATA_ERROR:s5,Z_BUF_ERROR:p1,Z_DEFAULT_COMPRESSION:JJ,Z_FILTERED:WJ,Z_HUFFMAN_ONLY:k1,Z_RLE:QJ,Z_FIXED:VJ,Z_DEFAULT_STRATEGY:GJ,Z_UNKNOWN:XJ,Z_DEFLATED:x1}=x0,UJ=9,qJ=15,YJ=8,PJ=29,KJ=256,e1=KJ+1+PJ,FJ=30,zJ=19,ZJ=2*e1+1,HJ=15,g=3,z0=258,V0=z0+g+1,kJ=32,v0=42,q8=57,t1=69,s1=73,J8=91,W8=103,R0=113,d0=666,l=1,f0=2,L0=3,h0=4,$J=3,M0=(J,Q)=>{return J.msg=C0[Q],Q},S8=(J)=>{return J*2-(J>4?9:0)},F0=(J)=>{let Q=J.length;while(--Q>=0)J[Q]=0},BJ=(J)=>{let Q,W,V,G=J.w_size;Q=J.hash_size,V=Q;do W=J.head[--V],J.head[V]=W>=G?W-G:0;while(--Q);Q=G,V=Q;do W=J.prev[--V],J.prev[V]=W>=G?W-G:0;while(--Q)},jJ=(J,Q,W)=>(Q<<J.hash_shift^W)&J.hash_mask,k0=jJ,r=(J)=>{const Q=J.state;let W=Q.pending;if(W>J.avail_out)W=J.avail_out;if(W===0)return;if(J.output.set(Q.pending_buf.subarray(Q.pending_out,Q.pending_out+W),J.next_out),J.next_out+=W,Q.pending_out+=W,J.total_out+=W,J.avail_out-=W,Q.pending-=W,Q.pending===0)Q.pending_out=0},o=(J,Q)=>{o5(J,J.block_start>=0?J.block_start:-1,J.strstart-J.block_start,Q),J.block_start=J.strstart,r(J.strm)},E=(J,Q)=>{J.pending_buf[J.pending++]=Q},_0=(J,Q)=>{J.pending_buf[J.pending++]=Q>>>8&255,J.pending_buf[J.pending++]=Q&255},Q8=(J,Q,W,V)=>{let G=J.avail_in;if(G>V)G=V;if(G===0)return 0;if(J.avail_in-=G,Q.set(J.input.subarray(J.next_in,J.next_in+G),W),J.state.wrap===1)J.adler=s0(J.adler,Q,G,W);else if(J.state.wrap===2)J.adler=_(J.adler,Q,G,W);return J.next_in+=G,J.total_in+=G,G},L6=(J,Q)=>{let{max_chain_length:W,strstart:V}=J,G,X,Y=J.prev_length,q=J.nice_match;const F=J.strstart>J.w_size-V0?J.strstart-(J.w_size-V0):0,U=J.window,P=J.w_mask,$=J.prev,z=J.strstart+z0;let K=U[V+Y-1],k=U[V+Y];if(J.prev_length>=J.good_match)W>>=2;if(q>J.lookahead)q=J.lookahead;do{if(G=Q,U[G+Y]!==k||U[G+Y-1]!==K||U[G]!==U[V]||U[++G]!==U[V+1])continue;V+=2,G++;do;while(U[++V]===U[++G]&&U[++V]===U[++G]&&U[++V]===U[++G]&&U[++V]===U[++G]&&U[++V]===U[++G]&&U[++V]===U[++G]&&U[++V]===U[++G]&&U[++V]===U[++G]&&V<z);if(X=z0-(z-V),V=z-z0,X>Y){if(J.match_start=Q,Y=X,X>=q)break;K=U[V+Y-1],k=U[V+Y]}}while((Q=$[Q&P])>F&&--W!==0);if(Y<=J.lookahead)return Y;return J.lookahead},y0=(J)=>{const Q=J.w_size;let W,V,G;do{if(V=J.window_size-J.lookahead-J.strstart,J.strstart>=Q+(Q-V0)){if(J.window.set(J.window.subarray(Q,Q+Q-V),0),J.match_start-=Q,J.strstart-=Q,J.block_start-=Q,J.insert>J.strstart)J.insert=J.strstart;BJ(J),V+=Q}if(J.strm.avail_in===0)break;if(W=Q8(J.strm,J.window,J.strstart+J.lookahead,V),J.lookahead+=W,J.lookahead+J.insert>=g){G=J.strstart-J.insert,J.ins_h=J.window[G],J.ins_h=k0(J,J.ins_h,J.window[G+1]);while(J.insert)if(J.ins_h=k0(J,J.ins_h,J.window[G+g-1]),J.prev[G&J.w_mask]=J.head[J.ins_h],J.head[J.ins_h]=G,G++,J.insert--,J.lookahead+J.insert<g)break}}while(J.lookahead<V0&&J.strm.avail_in!==0)},I6=(J,Q)=>{let W=J.pending_buf_size-5>J.w_size?J.w_size:J.pending_buf_size-5,V,G,X,Y=0,q=J.strm.avail_in;do{if(V=65535,X=J.bi_valid+42>>3,J.strm.avail_out<X)break;if(X=J.strm.avail_out-X,G=J.strstart-J.block_start,V>G+J.strm.avail_in)V=G+J.strm.avail_in;if(V>X)V=X;if(V<W&&(V===0&&Q!==a||Q===H0||V!==G+J.strm.avail_in))break;if(Y=Q===a&&V===G+J.strm.avail_in?1:0,a1(J,0,0,Y),J.pending_buf[J.pending-4]=V,J.pending_buf[J.pending-3]=V>>8,J.pending_buf[J.pending-2]=~V,J.pending_buf[J.pending-1]=~V>>8,r(J.strm),G){if(G>V)G=V;J.strm.output.set(J.window.subarray(J.block_start,J.block_start+G),J.strm.next_out),J.strm.next_out+=G,J.strm.avail_out-=G,J.strm.total_out+=G,J.block_start+=G,V-=G}if(V)Q8(J.strm,J.strm.output,J.strm.next_out,V),J.strm.next_out+=V,J.strm.avail_out-=V,J.strm.total_out+=V}while(Y===0);if(q-=J.strm.avail_in,q){if(q>=J.w_size)J.matches=2,J.window.set(J.strm.input.subarray(J.strm.next_in-J.w_size,J.strm.next_in),0),J.strstart=J.w_size,J.insert=J.strstart;else{if(J.window_size-J.strstart<=q){if(J.strstart-=J.w_size,J.window.set(J.window.subarray(J.w_size,J.w_size+J.strstart),0),J.matches<2)J.matches++;if(J.insert>J.strstart)J.insert=J.strstart}J.window.set(J.strm.input.subarray(J.strm.next_in-q,J.strm.next_in),J.strstart),J.strstart+=q,J.insert+=q>J.w_size-J.insert?J.w_size-J.insert:q}J.block_start=J.strstart}if(J.high_water<J.strstart)J.high_water=J.strstart;if(Y)return h0;if(Q!==H0&&Q!==a&&J.strm.avail_in===0&&J.strstart===J.block_start)return f0;if(X=J.window_size-J.strstart,J.strm.avail_in>X&&J.block_start>=J.w_size){if(J.block_start-=J.w_size,J.strstart-=J.w_size,J.window.set(J.window.subarray(J.w_size,J.w_size+J.strstart),0),J.matches<2)J.matches++;if(X+=J.w_size,J.insert>J.strstart)J.insert=J.strstart}if(X>J.strm.avail_in)X=J.strm.avail_in;if(X)Q8(J.strm,J.window,J.strstart,X),J.strstart+=X,J.insert+=X>J.w_size-J.insert?J.w_size-J.insert:X;if(J.high_water<J.strstart)J.high_water=J.strstart;if(X=J.bi_valid+42>>3,X=J.pending_buf_size-X>65535?65535:J.pending_buf_size-X,W=X>J.w_size?J.w_size:X,G=J.strstart-J.block_start,G>=W||(G||Q===a)&&Q!==H0&&J.strm.avail_in===0&&G<=X)V=G>X?X:G,Y=Q===a&&J.strm.avail_in===0&&V===G?1:0,a1(J,J.block_start,V,Y),J.block_start+=V,r(J.strm);return Y?L0:l},b1=(J,Q)=>{let W,V;for(;;){if(J.lookahead<V0){if(y0(J),J.lookahead<V0&&Q===H0)return l;if(J.lookahead===0)break}if(W=0,J.lookahead>=g)J.ins_h=k0(J,J.ins_h,J.window[J.strstart+g-1]),W=J.prev[J.strstart&J.w_mask]=J.head[J.ins_h],J.head[J.ins_h]=J.strstart;if(W!==0&&J.strstart-W<=J.w_size-V0)J.match_length=L6(J,W);if(J.match_length>=g)if(V=Z0(J,J.strstart-J.match_start,J.match_length-g),J.lookahead-=J.match_length,J.match_length<=J.max_lazy_match&&J.lookahead>=g){J.match_length--;do J.strstart++,J.ins_h=k0(J,J.ins_h,J.window[J.strstart+g-1]),W=J.prev[J.strstart&J.w_mask]=J.head[J.ins_h],J.head[J.ins_h]=J.strstart;while(--J.match_length!==0);J.strstart++}else J.strstart+=J.match_length,J.match_length=0,J.ins_h=J.window[J.strstart],J.ins_h=k0(J,J.ins_h,J.window[J.strstart+1]);else V=Z0(J,0,J.window[J.strstart]),J.lookahead--,J.strstart++;if(V){if(o(J,!1),J.strm.avail_out===0)return l}}if(J.insert=J.strstart<g-1?J.strstart:g-1,Q===a){if(o(J,!0),J.strm.avail_out===0)return L0;return h0}if(J.sym_next){if(o(J,!1),J.strm.avail_out===0)return l}return f0},S0=(J,Q)=>{let W,V,G;for(;;){if(J.lookahead<V0){if(y0(J),J.lookahead<V0&&Q===H0)return l;if(J.lookahead===0)break}if(W=0,J.lookahead>=g)J.ins_h=k0(J,J.ins_h,J.window[J.strstart+g-1]),W=J.prev[J.strstart&J.w_mask]=J.head[J.ins_h],J.head[J.ins_h]=J.strstart;if(J.prev_length=J.match_length,J.prev_match=J.match_start,J.match_length=g-1,W!==0&&J.prev_length<J.max_lazy_match&&J.strstart-W<=J.w_size-V0){if(J.match_length=L6(J,W),J.match_length<=5&&(J.strategy===WJ||J.match_length===g&&J.strstart-J.match_start>4096))J.match_length=g-1}if(J.prev_length>=g&&J.match_length<=J.prev_length){G=J.strstart+J.lookahead-g,V=Z0(J,J.strstart-1-J.prev_match,J.prev_length-g),J.lookahead-=J.prev_length-1,J.prev_length-=2;do if(++J.strstart<=G)J.ins_h=k0(J,J.ins_h,J.window[J.strstart+g-1]),W=J.prev[J.strstart&J.w_mask]=J.head[J.ins_h],J.head[J.ins_h]=J.strstart;while(--J.prev_length!==0);if(J.match_available=0,J.match_length=g-1,J.strstart++,V){if(o(J,!1),J.strm.avail_out===0)return l}}else if(J.match_available){if(V=Z0(J,0,J.window[J.strstart-1]),V)o(J,!1);if(J.strstart++,J.lookahead--,J.strm.avail_out===0)return l}else J.match_available=1,J.strstart++,J.lookahead--}if(J.match_available)V=Z0(J,0,J.window[J.strstart-1]),J.match_available=0;if(J.insert=J.strstart<g-1?J.strstart:g-1,Q===a){if(o(J,!0),J.strm.avail_out===0)return L0;return h0}if(J.sym_next){if(o(J,!1),J.strm.avail_out===0)return l}return f0},RJ=(J,Q)=>{let W,V,G,X;const Y=J.window;for(;;){if(J.lookahead<=z0){if(y0(J),J.lookahead<=z0&&Q===H0)return l;if(J.lookahead===0)break}if(J.match_length=0,J.lookahead>=g&&J.strstart>0){if(G=J.strstart-1,V=Y[G],V===Y[++G]&&V===Y[++G]&&V===Y[++G]){X=J.strstart+z0;do;while(V===Y[++G]&&V===Y[++G]&&V===Y[++G]&&V===Y[++G]&&V===Y[++G]&&V===Y[++G]&&V===Y[++G]&&V===Y[++G]&&G<X);if(J.match_length=z0-(X-G),J.match_length>J.lookahead)J.match_length=J.lookahead}}if(J.match_length>=g)W=Z0(J,1,J.match_length-g),J.lookahead-=J.match_length,J.strstart+=J.match_length,J.match_length=0;else W=Z0(J,0,J.window[J.strstart]),J.lookahead--,J.strstart++;if(W){if(o(J,!1),J.strm.avail_out===0)return l}}if(J.insert=0,Q===a){if(o(J,!0),J.strm.avail_out===0)return L0;return h0}if(J.sym_next){if(o(J,!1),J.strm.avail_out===0)return l}return f0},MJ=(J,Q)=>{let W;for(;;){if(J.lookahead===0){if(y0(J),J.lookahead===0){if(Q===H0)return l;break}}if(J.match_length=0,W=Z0(J,0,J.window[J.strstart]),J.lookahead--,J.strstart++,W){if(o(J,!1),J.strm.avail_out===0)return l}}if(J.insert=0,Q===a){if(o(J,!0),J.strm.avail_out===0)return L0;return h0}if(J.sym_next){if(o(J,!1),J.strm.avail_out===0)return l}return f0},i0=[new J0(0,0,0,0,I6),new J0(4,4,8,4,b1),new J0(4,5,16,8,b1),new J0(4,6,32,32,b1),new J0(4,4,16,16,S0),new J0(8,16,32,32,S0),new J0(8,16,128,128,S0),new J0(8,32,128,256,S0),new J0(32,128,258,1024,S0),new J0(32,258,258,4096,S0)],CJ=(J)=>{J.window_size=2*J.w_size,F0(J.head),J.max_lazy_match=i0[J.level].max_lazy,J.good_match=i0[J.level].good_length,J.nice_match=i0[J.level].nice_length,J.max_chain_length=i0[J.level].max_chain,J.strstart=0,J.block_start=0,J.lookahead=0,J.insert=0,J.match_length=J.prev_length=g-1,J.match_available=0,J.ins_h=0},G1=(J)=>{if(!J)return 1;const Q=J.state;if(!Q||Q.strm!==J||Q.status!==v0&&Q.status!==q8&&Q.status!==t1&&Q.status!==s1&&Q.status!==J8&&Q.status!==W8&&Q.status!==R0&&Q.status!==d0)return 1;return 0},x6=(J)=>{if(G1(J))return M0(J,Q0);J.total_in=J.total_out=0,J.data_type=XJ;const Q=J.state;if(Q.pending=0,Q.pending_out=0,Q.wrap<0)Q.wrap=-Q.wrap;return Q.status=Q.wrap===2?q8:Q.wrap?v0:R0,J.adler=Q.wrap===2?0:1,Q.last_flush=-2,r5(Q),d},O6=(J)=>{const Q=x6(J);if(Q===d)CJ(J.state);return Q},IJ=(J,Q)=>{if(G1(J)||J.state.wrap!==2)return Q0;return J.state.gzhead=Q,d},w6=(J,Q,W,V,G,X)=>{if(!J)return Q0;let Y=1;if(Q===JJ)Q=6;if(V<0)Y=0,V=-V;else if(V>15)Y=2,V-=16;if(G<1||G>UJ||W!==x1||V<8||V>15||Q<0||Q>9||X<0||X>VJ||V===8&&Y!==1)return M0(J,Q0);if(V===8)V=9;const q=new LJ;return J.state=q,q.strm=J,q.status=v0,q.wrap=Y,q.gzhead=null,q.w_bits=V,q.w_size=1<<q.w_bits,q.w_mask=q.w_size-1,q.hash_bits=G+7,q.hash_size=1<<q.hash_bits,q.hash_mask=q.hash_size-1,q.hash_shift=~~((q.hash_bits+g-1)/g),q.window=new Uint8Array(q.w_size*2),q.head=new Uint16Array(q.hash_size),q.prev=new Uint16Array(q.w_size),q.lit_bufsize=1<<G+6,q.pending_buf_size=q.lit_bufsize*4,q.pending_buf=new Uint8Array(q.pending_buf_size),q.sym_buf=q.lit_bufsize,q.sym_end=(q.lit_bufsize-1)*3,q.level=Q,q.strategy=X,q.method=W,O6(J)},xJ=(J,Q)=>{return w6(J,Q,x1,qJ,YJ,GJ)},OJ=(J,Q)=>{if(G1(J)||Q>A8||Q<0)return J?M0(J,Q0):Q0;const W=J.state;if(!J.output||J.avail_in!==0&&!J.input||W.status===d0&&Q!==a)return M0(J,J.avail_out===0?p1:Q0);const V=W.last_flush;if(W.last_flush=Q,W.pending!==0){if(r(J),J.avail_out===0)return W.last_flush=-1,d}else if(J.avail_in===0&&S8(Q)<=S8(V)&&Q!==a)return M0(J,p1);if(W.status===d0&&J.avail_in!==0)return M0(J,p1);if(W.status===v0&&W.wrap===0)W.status=R0;if(W.status===v0){let G=x1+(W.w_bits-8<<4)<<8,X=-1;if(W.strategy>=k1||W.level<2)X=0;else if(W.level<6)X=1;else if(W.level===6)X=2;else X=3;if(G|=X<<6,W.strstart!==0)G|=kJ;if(G+=31-G%31,_0(W,G),W.strstart!==0)_0(W,J.adler>>>16),_0(W,J.adler&65535);if(J.adler=1,W.status=R0,r(J),W.pending!==0)return W.last_flush=-1,d}if(W.status===q8)if(J.adler=0,E(W,31),E(W,139),E(W,8),!W.gzhead){if(E(W,0),E(W,0),E(W,0),E(W,0),E(W,0),E(W,W.level===9?2:W.strategy>=k1||W.level<2?4:0),E(W,$J),W.status=R0,r(J),W.pending!==0)return W.last_flush=-1,d}else{if(E(W,(W.gzhead.text?1:0)+(W.gzhead.hcrc?2:0)+(!W.gzhead.extra?0:4)+(!W.gzhead.name?0:8)+(!W.gzhead.comment?0:16)),E(W,W.gzhead.time&255),E(W,W.gzhead.time>>8&255),E(W,W.gzhead.time>>16&255),E(W,W.gzhead.time>>24&255),E(W,W.level===9?2:W.strategy>=k1||W.level<2?4:0),E(W,W.gzhead.os&255),W.gzhead.extra&&W.gzhead.extra.length)E(W,W.gzhead.extra.length&255),E(W,W.gzhead.extra.length>>8&255);if(W.gzhead.hcrc)J.adler=_(J.adler,W.pending_buf,W.pending,0);W.gzindex=0,W.status=t1}if(W.status===t1){if(W.gzhead.extra){let G=W.pending,X=(W.gzhead.extra.length&65535)-W.gzindex;while(W.pending+X>W.pending_buf_size){let q=W.pending_buf_size-W.pending;if(W.pending_buf.set(W.gzhead.extra.subarray(W.gzindex,W.gzindex+q),W.pending),W.pending=W.pending_buf_size,W.gzhead.hcrc&&W.pending>G)J.adler=_(J.adler,W.pending_buf,W.pending-G,G);if(W.gzindex+=q,r(J),W.pending!==0)return W.last_flush=-1,d;G=0,X-=q}let Y=new Uint8Array(W.gzhead.extra);if(W.pending_buf.set(Y.subarray(W.gzindex,W.gzindex+X),W.pending),W.pending+=X,W.gzhead.hcrc&&W.pending>G)J.adler=_(J.adler,W.pending_buf,W.pending-G,G);W.gzindex=0}W.status=s1}if(W.status===s1){if(W.gzhead.name){let G=W.pending,X;do{if(W.pending===W.pending_buf_size){if(W.gzhead.hcrc&&W.pending>G)J.adler=_(J.adler,W.pending_buf,W.pending-G,G);if(r(J),W.pending!==0)return W.last_flush=-1,d;G=0}if(W.gzindex<W.gzhead.name.length)X=W.gzhead.name.charCodeAt(W.gzindex++)&255;else X=0;E(W,X)}while(X!==0);if(W.gzhead.hcrc&&W.pending>G)J.adler=_(J.adler,W.pending_buf,W.pending-G,G);W.gzindex=0}W.status=J8}if(W.status===J8){if(W.gzhead.comment){let G=W.pending,X;do{if(W.pending===W.pending_buf_size){if(W.gzhead.hcrc&&W.pending>G)J.adler=_(J.adler,W.pending_buf,W.pending-G,G);if(r(J),W.pending!==0)return W.last_flush=-1,d;G=0}if(W.gzindex<W.gzhead.comment.length)X=W.gzhead.comment.charCodeAt(W.gzindex++)&255;else X=0;E(W,X)}while(X!==0);if(W.gzhead.hcrc&&W.pending>G)J.adler=_(J.adler,W.pending_buf,W.pending-G,G)}W.status=W8}if(W.status===W8){if(W.gzhead.hcrc){if(W.pending+2>W.pending_buf_size){if(r(J),W.pending!==0)return W.last_flush=-1,d}E(W,J.adler&255),E(W,J.adler>>8&255),J.adler=0}if(W.status=R0,r(J),W.pending!==0)return W.last_flush=-1,d}if(J.avail_in!==0||W.lookahead!==0||Q!==H0&&W.status!==d0){let G=W.level===0?I6(W,Q):W.strategy===k1?MJ(W,Q):W.strategy===QJ?RJ(W,Q):i0[W.level].func(W,Q);if(G===L0||G===h0)W.status=d0;if(G===l||G===L0){if(J.avail_out===0)W.last_flush=-1;return d}if(G===f0){if(Q===e5)a5(W);else if(Q!==A8){if(a1(W,0,0,!1),Q===t5){if(F0(W.head),W.lookahead===0)W.strstart=0,W.block_start=0,W.insert=0}}if(r(J),J.avail_out===0)return W.last_flush=-1,d}}if(Q!==a)return d;if(W.wrap<=0)return N8;if(W.wrap===2)E(W,J.adler&255),E(W,J.adler>>8&255),E(W,J.adler>>16&255),E(W,J.adler>>24&255),E(W,J.total_in&255),E(W,J.total_in>>8&255),E(W,J.total_in>>16&255),E(W,J.total_in>>24&255);else _0(W,J.adler>>>16),_0(W,J.adler&65535);if(r(J),W.wrap>0)W.wrap=-W.wrap;return W.pending!==0?d:N8},wJ=(J)=>{if(G1(J))return Q0;const Q=J.state.status;return J.state=null,Q===R0?M0(J,s5):d},DJ=(J,Q)=>{let W=Q.length;if(G1(J))return Q0;const V=J.state,G=V.wrap;if(G===2||G===1&&V.status!==v0||V.lookahead)return Q0;if(G===1)J.adler=s0(J.adler,Q,W,0);if(V.wrap=0,W>=V.w_size){if(G===0)F0(V.head),V.strstart=0,V.block_start=0,V.insert=0;let F=new Uint8Array(V.w_size);F.set(Q.subarray(W-V.w_size,W),0),Q=F,W=V.w_size}const{avail_in:X,next_in:Y,input:q}=J;J.avail_in=W,J.next_in=0,J.input=Q,y0(V);while(V.lookahead>=g){let F=V.strstart,U=V.lookahead-(g-1);do V.ins_h=k0(V,V.ins_h,V.window[F+g-1]),V.prev[F&V.w_mask]=V.head[V.ins_h],V.head[V.ins_h]=F,F++;while(--U);V.strstart=F,V.lookahead=g-1,y0(V)}return V.strstart+=V.lookahead,V.block_start=V.strstart,V.insert=V.lookahead,V.lookahead=0,V.match_length=V.prev_length=g-1,V.match_available=0,J.next_in=Y,J.input=q,J.avail_in=X,V.wrap=G,d},AJ=xJ,NJ=w6,SJ=O6,TJ=x6,gJ=IJ,vJ=OJ,yJ=wJ,EJ=DJ,fJ="pako deflate (from Nodeca project)",n0={deflateInit:AJ,deflateInit2:NJ,deflateReset:SJ,deflateResetKeep:TJ,deflateSetHeader:gJ,deflate:vJ,deflateEnd:yJ,deflateSetDictionary:EJ,deflateInfo:fJ},hJ=(J,Q)=>{return Object.prototype.hasOwnProperty.call(J,Q)},pJ=function(J){const Q=Array.prototype.slice.call(arguments,1);while(Q.length){const W=Q.shift();if(!W)continue;if(typeof W!=="object")throw new TypeError(W+"must be non-object");for(let V in W)if(hJ(W,V))J[V]=W[V]}return J},bJ=(J)=>{let Q=0;for(let V=0,G=J.length;V<G;V++)Q+=J[V].length;const W=new Uint8Array(Q);for(let V=0,G=0,X=J.length;V<X;V++){let Y=J[V];W.set(Y,G),G+=Y.length}return W},O1={assign:pJ,flattenChunks:bJ},D6=!0;try{String.fromCharCode.apply(null,new Uint8Array(1))}catch(J){D6=!1}var J1=new Uint8Array(256);for(let J=0;J<256;J++)J1[J]=J>=252?6:J>=248?5:J>=240?4:J>=224?3:J>=192?2:1;J1[254]=J1[254]=1;var uJ=(J)=>{if(typeof TextEncoder==="function"&&TextEncoder.prototype.encode)return(new TextEncoder()).encode(J);let Q,W,V,G,X,Y=J.length,q=0;for(G=0;G<Y;G++){if(W=J.charCodeAt(G),(W&64512)===55296&&G+1<Y){if(V=J.charCodeAt(G+1),(V&64512)===56320)W=65536+(W-55296<<10)+(V-56320),G++}q+=W<128?1:W<2048?2:W<65536?3:4}Q=new Uint8Array(q);for(X=0,G=0;X<q;G++){if(W=J.charCodeAt(G),(W&64512)===55296&&G+1<Y){if(V=J.charCodeAt(G+1),(V&64512)===56320)W=65536+(W-55296<<10)+(V-56320),G++}if(W<128)Q[X++]=W;else if(W<2048)Q[X++]=192|W>>>6,Q[X++]=128|W&63;else if(W<65536)Q[X++]=224|W>>>12,Q[X++]=128|W>>>6&63,Q[X++]=128|W&63;else Q[X++]=240|W>>>18,Q[X++]=128|W>>>12&63,Q[X++]=128|W>>>6&63,Q[X++]=128|W&63}return Q},mJ=(J,Q)=>{if(Q<65534){if(J.subarray&&D6)return String.fromCharCode.apply(null,J.length===Q?J:J.subarray(0,Q))}let W="";for(let V=0;V<Q;V++)W+=String.fromCharCode(J[V]);return W},cJ=(J,Q)=>{const W=Q||J.length;if(typeof TextDecoder==="function"&&TextDecoder.prototype.decode)return(new TextDecoder()).decode(J.subarray(0,Q));let V,G;const X=new Array(W*2);for(G=0,V=0;V<W;){let Y=J[V++];if(Y<128){X[G++]=Y;continue}let q=J1[Y];if(q>4){X[G++]=65533,V+=q-1;continue}Y&=q===2?31:q===3?15:7;while(q>1&&V<W)Y=Y<<6|J[V++]&63,q--;if(q>1){X[G++]=65533;continue}if(Y<65536)X[G++]=Y;else Y-=65536,X[G++]=55296|Y>>10&1023,X[G++]=56320|Y&1023}return mJ(X,G)},_J=(J,Q)=>{if(Q=Q||J.length,Q>J.length)Q=J.length;let W=Q-1;while(W>=0&&(J[W]&192)===128)W--;if(W<0)return Q;if(W===0)return Q;return W+J1[J[W]]>Q?W:Q},W1={string2buf:uJ,buf2string:cJ,utf8border:_J},A6=dJ,N6=Object.prototype.toString,{Z_NO_FLUSH:iJ,Z_SYNC_FLUSH:lJ,Z_FULL_FLUSH:nJ,Z_FINISH:rJ,Z_OK:L1,Z_STREAM_END:oJ,Z_DEFAULT_COMPRESSION:aJ,Z_DEFAULT_STRATEGY:eJ,Z_DEFLATED:tJ}=x0;X1.prototype.push=function(J,Q){const W=this.strm,V=this.options.chunkSize;let G,X;if(this.ended)return!1;if(Q===~~Q)X=Q;else X=Q===!0?rJ:iJ;if(typeof J==="string")W.input=W1.string2buf(J);else if(N6.call(J)==="[object ArrayBuffer]")W.input=new Uint8Array(J);else W.input=J;W.next_in=0,W.avail_in=W.input.length;for(;;){if(W.avail_out===0)W.output=new Uint8Array(V),W.next_out=0,W.avail_out=V;if((X===lJ||X===nJ)&&W.avail_out<=6){this.onData(W.output.subarray(0,W.next_out)),W.avail_out=0;continue}if(G=n0.deflate(W,X),G===oJ){if(W.next_out>0)this.onData(W.output.subarray(0,W.next_out));return G=n0.deflateEnd(this.strm),this.onEnd(G),this.ended=!0,G===L1}if(W.avail_out===0){this.onData(W.output);continue}if(X>0&&W.next_out>0){this.onData(W.output.subarray(0,W.next_out)),W.avail_out=0;continue}if(W.avail_in===0)break}return!0};X1.prototype.onData=function(J){this.chunks.push(J)};X1.prototype.onEnd=function(J){if(J===L1)this.result=O1.flattenChunks(this.chunks);this.chunks=[],this.err=J,this.msg=this.strm.msg};var WW=X1,QW=Y8,VW=sJ,GW=JW,XW=x0,UW={Deflate:WW,deflate:QW,deflateRaw:VW,gzip:GW,constants:XW},$1=16209,qW=16191,YW=function J(Q,W){let V,G,X,Y,q,F,U,P,$,z,K,k,O,w,R,A,C,H,T,p,j,v,D,I;const N=Q.state;V=Q.next_in,D=Q.input,G=V+(Q.avail_in-5),X=Q.next_out,I=Q.output,Y=X-(W-Q.avail_out),q=X+(Q.avail_out-257),F=N.dmax,U=N.wsize,P=N.whave,$=N.wnext,z=N.window,K=N.hold,k=N.bits,O=N.lencode,w=N.distcode,R=(1<<N.lenbits)-1,A=(1<<N.distbits)-1;J:do{if(k<15)K+=D[V++]<<k,k+=8,K+=D[V++]<<k,k+=8;C=O[K&R];W:for(;;){if(H=C>>>24,K>>>=H,k-=H,H=C>>>16&255,H===0)I[X++]=C&65535;else if(H&16){if(T=C&65535,H&=15,H){if(k<H)K+=D[V++]<<k,k+=8;T+=K&(1<<H)-1,K>>>=H,k-=H}if(k<15)K+=D[V++]<<k,k+=8,K+=D[V++]<<k,k+=8;C=w[K&A];Q:for(;;){if(H=C>>>24,K>>>=H,k-=H,H=C>>>16&255,H&16){if(p=C&65535,H&=15,k<H){if(K+=D[V++]<<k,k+=8,k<H)K+=D[V++]<<k,k+=8}if(p+=K&(1<<H)-1,p>F){Q.msg="invalid distance too far back",N.mode=$1;break J}if(K>>>=H,k-=H,H=X-Y,p>H){if(H=p-H,H>P){if(N.sane){Q.msg="invalid distance too far back",N.mode=$1;break J}}if(j=0,v=z,$===0){if(j+=U-H,H<T){T-=H;do I[X++]=z[j++];while(--H);j=X-p,v=I}}else if($<H){if(j+=U+$-H,H-=$,H<T){T-=H;do I[X++]=z[j++];while(--H);if(j=0,$<T){H=$,T-=H;do I[X++]=z[j++];while(--H);j=X-p,v=I}}}else if(j+=$-H,H<T){T-=H;do I[X++]=z[j++];while(--H);j=X-p,v=I}while(T>2)I[X++]=v[j++],I[X++]=v[j++],I[X++]=v[j++],T-=3;if(T){if(I[X++]=v[j++],T>1)I[X++]=v[j++]}}else{j=X-p;do I[X++]=I[j++],I[X++]=I[j++],I[X++]=I[j++],T-=3;while(T>2);if(T){if(I[X++]=I[j++],T>1)I[X++]=I[j++]}}}else if((H&64)===0){C=w[(C&65535)+(K&(1<<H)-1)];continue Q}else{Q.msg="invalid distance code",N.mode=$1;break J}break}}else if((H&64)===0){C=O[(C&65535)+(K&(1<<H)-1)];continue W}else if(H&32){N.mode=qW;break J}else{Q.msg="invalid literal/length code",N.mode=$1;break J}break}}while(V<G&&X<q);T=k>>3,V-=T,k-=T<<3,K&=(1<<k)-1,Q.next_in=V,Q.next_out=X,Q.avail_in=V<G?5+(G-V):5-(V-G),Q.avail_out=X<q?257+(q-X):257-(X-q),N.hold=K,N.bits=k;return},T0=15,T8=852,g8=592,v8=0,u1=1,y8=2,PW=new Uint16Array([3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,0,0]),KW=new Uint8Array([16,16,16,16,16,16,16,16,17,17,17,17,18,18,18,18,19,19,19,19,20,20,20,20,21,21,21,21,16,72,78]),FW=new Uint16Array([1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,0,0]),zW=new Uint8Array([16,16,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,64,64]),ZW=(J,Q,W,V,G,X,Y,q)=>{const F=q.bits;let U=0,P=0,$=0,z=0,K=0,k=0,O=0,w=0,R=0,A=0,C,H,T,p,j,v=null,D;const I=new Uint16Array(T0+1),N=new Uint16Array(T0+1);let G0=null,p0,s,Y0;for(U=0;U<=T0;U++)I[U]=0;for(P=0;P<V;P++)I[Q[W+P]]++;K=F;for(z=T0;z>=1;z--)if(I[z]!==0)break;if(K>z)K=z;if(z===0)return G[X++]=1<<24|64<<16|0,G[X++]=1<<24|64<<16|0,q.bits=1,0;for($=1;$<z;$++)if(I[$]!==0)break;if(K<$)K=$;w=1;for(U=1;U<=T0;U++)if(w<<=1,w-=I[U],w<0)return-1;if(w>0&&(J===v8||z!==1))return-1;N[1]=0;for(U=1;U<T0;U++)N[U+1]=N[U]+I[U];for(P=0;P<V;P++)if(Q[W+P]!==0)Y[N[Q[W+P]]++]=P;if(J===v8)v=G0=Y,D=20;else if(J===u1)v=PW,G0=KW,D=257;else v=FW,G0=zW,D=0;if(A=0,P=0,U=$,j=X,k=K,O=0,T=-1,R=1<<K,p=R-1,J===u1&&R>T8||J===y8&&R>g8)return 1;for(;;){if(p0=U-O,Y[P]+1<D)s=0,Y0=Y[P];else if(Y[P]>=D)s=G0[Y[P]-D],Y0=v[Y[P]-D];else s=96,Y0=0;C=1<<U-O,H=1<<k,$=H;do H-=C,G[j+(A>>O)+H]=p0<<24|s<<16|Y0|0;while(H!==0);C=1<<U-1;while(A&C)C>>=1;if(C!==0)A&=C-1,A+=C;else A=0;if(P++,--I[U]===0){if(U===z)break;U=Q[W+Y[P]]}if(U>K&&(A&p)!==T){if(O===0)O=K;j+=$,k=U-O,w=1<<k;while(k+O<z){if(w-=I[k+O],w<=0)break;k++,w<<=1}if(R+=1<<k,J===u1&&R>T8||J===y8&&R>g8)return 1;T=A&p,G[T]=K<<24|k<<16|j-X|0}}if(A!==0)G[j+A]=U-O<<24|64<<16|0;return q.bits=K,0},r0=ZW,HW=0,S6=1,T6=2,{Z_FINISH:E8,Z_BLOCK:kW,Z_TREES:B1,Z_OK:I0,Z_STREAM_END:$W,Z_NEED_DICT:BW,Z_STREAM_ERROR:e,Z_DATA_ERROR:g6,Z_MEM_ERROR:v6,Z_BUF_ERROR:jW,Z_DEFLATED:f8}=x0,w1=16180,h8=16181,p8=16182,b8=16183,u8=16184,m8=16185,c8=16186,_8=16187,d8=16188,i8=16189,I1=16190,X0=16191,m1=16192,l8=16193,c1=16194,n8=16195,r8=16196,o8=16197,a8=16198,j1=16199,R1=16200,e8=16201,t8=16202,s8=16203,J6=16204,W6=16205,_1=16206,Q6=16207,V6=16208,h=16209,y6=16210,E6=16211,RW=852,MW=592,CW=15,LW=CW,G6=(J)=>{return(J>>>24&255)+(J>>>8&65280)+((J&65280)<<8)+((J&255)<<24)},O0=(J)=>{if(!J)return 1;const Q=J.state;if(!Q||Q.strm!==J||Q.mode<w1||Q.mode>E6)return 1;return 0},f6=(J)=>{if(O0(J))return e;const Q=J.state;if(J.total_in=J.total_out=Q.total=0,J.msg="",Q.wrap)J.adler=Q.wrap&1;return Q.mode=w1,Q.last=0,Q.havedict=0,Q.flags=-1,Q.dmax=32768,Q.head=null,Q.hold=0,Q.bits=0,Q.lencode=Q.lendyn=new Int32Array(RW),Q.distcode=Q.distdyn=new Int32Array(MW),Q.sane=1,Q.back=-1,I0},h6=(J)=>{if(O0(J))return e;const Q=J.state;return Q.wsize=0,Q.whave=0,Q.wnext=0,f6(J)},p6=(J,Q)=>{let W;if(O0(J))return e;const V=J.state;if(Q<0)W=0,Q=-Q;else if(W=(Q>>4)+5,Q<48)Q&=15;if(Q&&(Q<8||Q>15))return e;if(V.window!==null&&V.wbits!==Q)V.window=null;return V.wrap=W,V.wbits=Q,h6(J)},b6=(J,Q)=>{if(!J)return e;const W=new IW;J.state=W,W.strm=J,W.window=null,W.mode=w1;const V=p6(J,Q);if(V!==I0)J.state=null;return V},xW=(J)=>{return b6(J,LW)},X6=!0,d1,i1,OW=(J)=>{if(X6){d1=new Int32Array(512),i1=new Int32Array(32);let Q=0;while(Q<144)J.lens[Q++]=8;while(Q<256)J.lens[Q++]=9;while(Q<280)J.lens[Q++]=7;while(Q<288)J.lens[Q++]=8;r0(S6,J.lens,0,288,d1,0,J.work,{bits:9}),Q=0;while(Q<32)J.lens[Q++]=5;r0(T6,J.lens,0,32,i1,0,J.work,{bits:5}),X6=!1}J.lencode=d1,J.lenbits=9,J.distcode=i1,J.distbits=5},u6=(J,Q,W,V)=>{let G;const X=J.state;if(X.window===null)X.wsize=1<<X.wbits,X.wnext=0,X.whave=0,X.window=new Uint8Array(X.wsize);if(V>=X.wsize)X.window.set(Q.subarray(W-X.wsize,W),0),X.wnext=0,X.whave=X.wsize;else{if(G=X.wsize-X.wnext,G>V)G=V;if(X.window.set(Q.subarray(W-V,W-V+G),X.wnext),V-=G,V)X.window.set(Q.subarray(W-V,W),0),X.wnext=V,X.whave=X.wsize;else{if(X.wnext+=G,X.wnext===X.wsize)X.wnext=0;if(X.whave<X.wsize)X.whave+=G}}return 0},wW=(J,Q)=>{let W,V,G,X,Y,q,F,U,P,$,z,K,k,O,w=0,R,A,C,H,T,p,j,v;const D=new Uint8Array(4);let I,N;const G0=new Uint8Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]);if(O0(J)||!J.output||!J.input&&J.avail_in!==0)return e;if(W=J.state,W.mode===X0)W.mode=m1;Y=J.next_out,G=J.output,F=J.avail_out,X=J.next_in,V=J.input,q=J.avail_in,U=W.hold,P=W.bits,$=q,z=F,v=I0;J:for(;;)switch(W.mode){case w1:if(W.wrap===0){W.mode=m1;break}while(P<16){if(q===0)break J;q--,U+=V[X++]<<P,P+=8}if(W.wrap&2&&U===35615){if(W.wbits===0)W.wbits=15;W.check=0,D[0]=U&255,D[1]=U>>>8&255,W.check=_(W.check,D,2,0),U=0,P=0,W.mode=h8;break}if(W.head)W.head.done=!1;if(!(W.wrap&1)||(((U&255)<<8)+(U>>8))%31){J.msg="incorrect header check",W.mode=h;break}if((U&15)!==f8){J.msg="unknown compression method",W.mode=h;break}if(U>>>=4,P-=4,j=(U&15)+8,W.wbits===0)W.wbits=j;if(j>15||j>W.wbits){J.msg="invalid window size",W.mode=h;break}W.dmax=1<<W.wbits,W.flags=0,J.adler=W.check=1,W.mode=U&512?i8:X0,U=0,P=0;break;case h8:while(P<16){if(q===0)break J;q--,U+=V[X++]<<P,P+=8}if(W.flags=U,(W.flags&255)!==f8){J.msg="unknown compression method",W.mode=h;break}if(W.flags&57344){J.msg="unknown header flags set",W.mode=h;break}if(W.head)W.head.text=U>>8&1;if(W.flags&512&&W.wrap&4)D[0]=U&255,D[1]=U>>>8&255,W.check=_(W.check,D,2,0);U=0,P=0,W.mode=p8;case p8:while(P<32){if(q===0)break J;q--,U+=V[X++]<<P,P+=8}if(W.head)W.head.time=U;if(W.flags&512&&W.wrap&4)D[0]=U&255,D[1]=U>>>8&255,D[2]=U>>>16&255,D[3]=U>>>24&255,W.check=_(W.check,D,4,0);U=0,P=0,W.mode=b8;case b8:while(P<16){if(q===0)break J;q--,U+=V[X++]<<P,P+=8}if(W.head)W.head.xflags=U&255,W.head.os=U>>8;if(W.flags&512&&W.wrap&4)D[0]=U&255,D[1]=U>>>8&255,W.check=_(W.check,D,2,0);U=0,P=0,W.mode=u8;case u8:if(W.flags&1024){while(P<16){if(q===0)break J;q--,U+=V[X++]<<P,P+=8}if(W.length=U,W.head)W.head.extra_len=U;if(W.flags&512&&W.wrap&4)D[0]=U&255,D[1]=U>>>8&255,W.check=_(W.check,D,2,0);U=0,P=0}else if(W.head)W.head.extra=null;W.mode=m8;case m8:if(W.flags&1024){if(K=W.length,K>q)K=q;if(K){if(W.head){if(j=W.head.extra_len-W.length,!W.head.extra)W.head.extra=new Uint8Array(W.head.extra_len);W.head.extra.set(V.subarray(X,X+K),j)}if(W.flags&512&&W.wrap&4)W.check=_(W.check,V,K,X);q-=K,X+=K,W.length-=K}if(W.length)break J}W.length=0,W.mode=c8;case c8:if(W.flags&2048){if(q===0)break J;K=0;do if(j=V[X+K++],W.head&&j&&W.length<65536)W.head.name+=String.fromCharCode(j);while(j&&K<q);if(W.flags&512&&W.wrap&4)W.check=_(W.check,V,K,X);if(q-=K,X+=K,j)break J}else if(W.head)W.head.name=null;W.length=0,W.mode=_8;case _8:if(W.flags&4096){if(q===0)break J;K=0;do if(j=V[X+K++],W.head&&j&&W.length<65536)W.head.comment+=String.fromCharCode(j);while(j&&K<q);if(W.flags&512&&W.wrap&4)W.check=_(W.check,V,K,X);if(q-=K,X+=K,j)break J}else if(W.head)W.head.comment=null;W.mode=d8;case d8:if(W.flags&512){while(P<16){if(q===0)break J;q--,U+=V[X++]<<P,P+=8}if(W.wrap&4&&U!==(W.check&65535)){J.msg="header crc mismatch",W.mode=h;break}U=0,P=0}if(W.head)W.head.hcrc=W.flags>>9&1,W.head.done=!0;J.adler=W.check=0,W.mode=X0;break;case i8:while(P<32){if(q===0)break J;q--,U+=V[X++]<<P,P+=8}J.adler=W.check=G6(U),U=0,P=0,W.mode=I1;case I1:if(W.havedict===0)return J.next_out=Y,J.avail_out=F,J.next_in=X,J.avail_in=q,W.hold=U,W.bits=P,BW;J.adler=W.check=1,W.mode=X0;case X0:if(Q===kW||Q===B1)break J;case m1:if(W.last){U>>>=P&7,P-=P&7,W.mode=_1;break}while(P<3){if(q===0)break J;q--,U+=V[X++]<<P,P+=8}switch(W.last=U&1,U>>>=1,P-=1,U&3){case 0:W.mode=l8;break;case 1:if(OW(W),W.mode=j1,Q===B1){U>>>=2,P-=2;break J}break;case 2:W.mode=r8;break;case 3:J.msg="invalid block type",W.mode=h}U>>>=2,P-=2;break;case l8:U>>>=P&7,P-=P&7;while(P<32){if(q===0)break J;q--,U+=V[X++]<<P,P+=8}if((U&65535)!==(U>>>16^65535)){J.msg="invalid stored block lengths",W.mode=h;break}if(W.length=U&65535,U=0,P=0,W.mode=c1,Q===B1)break J;case c1:W.mode=n8;case n8:if(K=W.length,K){if(K>q)K=q;if(K>F)K=F;if(K===0)break J;G.set(V.subarray(X,X+K),Y),q-=K,X+=K,F-=K,Y+=K,W.length-=K;break}W.mode=X0;break;case r8:while(P<14){if(q===0)break J;q--,U+=V[X++]<<P,P+=8}if(W.nlen=(U&31)+257,U>>>=5,P-=5,W.ndist=(U&31)+1,U>>>=5,P-=5,W.ncode=(U&15)+4,U>>>=4,P-=4,W.nlen>286||W.ndist>30){J.msg="too many length or distance symbols",W.mode=h;break}W.have=0,W.mode=o8;case o8:while(W.have<W.ncode){while(P<3){if(q===0)break J;q--,U+=V[X++]<<P,P+=8}W.lens[G0[W.have++]]=U&7,U>>>=3,P-=3}while(W.have<19)W.lens[G0[W.have++]]=0;if(W.lencode=W.lendyn,W.lenbits=7,I={bits:W.lenbits},v=r0(HW,W.lens,0,19,W.lencode,0,W.work,I),W.lenbits=I.bits,v){J.msg="invalid code lengths set",W.mode=h;break}W.have=0,W.mode=a8;case a8:while(W.have<W.nlen+W.ndist){for(;;){if(w=W.lencode[U&(1<<W.lenbits)-1],R=w>>>24,A=w>>>16&255,C=w&65535,R<=P)break;if(q===0)break J;q--,U+=V[X++]<<P,P+=8}if(C<16)U>>>=R,P-=R,W.lens[W.have++]=C;else{if(C===16){N=R+2;while(P<N){if(q===0)break J;q--,U+=V[X++]<<P,P+=8}if(U>>>=R,P-=R,W.have===0){J.msg="invalid bit length repeat",W.mode=h;break}j=W.lens[W.have-1],K=3+(U&3),U>>>=2,P-=2}else if(C===17){N=R+3;while(P<N){if(q===0)break J;q--,U+=V[X++]<<P,P+=8}U>>>=R,P-=R,j=0,K=3+(U&7),U>>>=3,P-=3}else{N=R+7;while(P<N){if(q===0)break J;q--,U+=V[X++]<<P,P+=8}U>>>=R,P-=R,j=0,K=11+(U&127),U>>>=7,P-=7}if(W.have+K>W.nlen+W.ndist){J.msg="invalid bit length repeat",W.mode=h;break}while(K--)W.lens[W.have++]=j}}if(W.mode===h)break;if(W.lens[256]===0){J.msg="invalid code -- missing end-of-block",W.mode=h;break}if(W.lenbits=9,I={bits:W.lenbits},v=r0(S6,W.lens,0,W.nlen,W.lencode,0,W.work,I),W.lenbits=I.bits,v){J.msg="invalid literal/lengths set",W.mode=h;break}if(W.distbits=6,W.distcode=W.distdyn,I={bits:W.distbits},v=r0(T6,W.lens,W.nlen,W.ndist,W.distcode,0,W.work,I),W.distbits=I.bits,v){J.msg="invalid distances set",W.mode=h;break}if(W.mode=j1,Q===B1)break J;case j1:W.mode=R1;case R1:if(q>=6&&F>=258){if(J.next_out=Y,J.avail_out=F,J.next_in=X,J.avail_in=q,W.hold=U,W.bits=P,YW(J,z),Y=J.next_out,G=J.output,F=J.avail_out,X=J.next_in,V=J.input,q=J.avail_in,U=W.hold,P=W.bits,W.mode===X0)W.back=-1;break}W.back=0;for(;;){if(w=W.lencode[U&(1<<W.lenbits)-1],R=w>>>24,A=w>>>16&255,C=w&65535,R<=P)break;if(q===0)break J;q--,U+=V[X++]<<P,P+=8}if(A&&(A&240)===0){H=R,T=A,p=C;for(;;){if(w=W.lencode[p+((U&(1<<H+T)-1)>>H)],R=w>>>24,A=w>>>16&255,C=w&65535,H+R<=P)break;if(q===0)break J;q--,U+=V[X++]<<P,P+=8}U>>>=H,P-=H,W.back+=H}if(U>>>=R,P-=R,W.back+=R,W.length=C,A===0){W.mode=W6;break}if(A&32){W.back=-1,W.mode=X0;break}if(A&64){J.msg="invalid literal/length code",W.mode=h;break}W.extra=A&15,W.mode=e8;case e8:if(W.extra){N=W.extra;while(P<N){if(q===0)break J;q--,U+=V[X++]<<P,P+=8}W.length+=U&(1<<W.extra)-1,U>>>=W.extra,P-=W.extra,W.back+=W.extra}W.was=W.length,W.mode=t8;case t8:for(;;){if(w=W.distcode[U&(1<<W.distbits)-1],R=w>>>24,A=w>>>16&255,C=w&65535,R<=P)break;if(q===0)break J;q--,U+=V[X++]<<P,P+=8}if((A&240)===0){H=R,T=A,p=C;for(;;){if(w=W.distcode[p+((U&(1<<H+T)-1)>>H)],R=w>>>24,A=w>>>16&255,C=w&65535,H+R<=P)break;if(q===0)break J;q--,U+=V[X++]<<P,P+=8}U>>>=H,P-=H,W.back+=H}if(U>>>=R,P-=R,W.back+=R,A&64){J.msg="invalid distance code",W.mode=h;break}W.offset=C,W.extra=A&15,W.mode=s8;case s8:if(W.extra){N=W.extra;while(P<N){if(q===0)break J;q--,U+=V[X++]<<P,P+=8}W.offset+=U&(1<<W.extra)-1,U>>>=W.extra,P-=W.extra,W.back+=W.extra}if(W.offset>W.dmax){J.msg="invalid distance too far back",W.mode=h;break}W.mode=J6;case J6:if(F===0)break J;if(K=z-F,W.offset>K){if(K=W.offset-K,K>W.whave){if(W.sane){J.msg="invalid distance too far back",W.mode=h;break}}if(K>W.wnext)K-=W.wnext,k=W.wsize-K;else k=W.wnext-K;if(K>W.length)K=W.length;O=W.window}else O=G,k=Y-W.offset,K=W.length;if(K>F)K=F;F-=K,W.length-=K;do G[Y++]=O[k++];while(--K);if(W.length===0)W.mode=R1;break;case W6:if(F===0)break J;G[Y++]=W.length,F--,W.mode=R1;break;case _1:if(W.wrap){while(P<32){if(q===0)break J;q--,U|=V[X++]<<P,P+=8}if(z-=F,J.total_out+=z,W.total+=z,W.wrap&4&&z)J.adler=W.check=W.flags?_(W.check,G,z,Y-z):s0(W.check,G,z,Y-z);if(z=F,W.wrap&4&&(W.flags?U:G6(U))!==W.check){J.msg="incorrect data check",W.mode=h;break}U=0,P=0}W.mode=Q6;case Q6:if(W.wrap&&W.flags){while(P<32){if(q===0)break J;q--,U+=V[X++]<<P,P+=8}if(W.wrap&4&&U!==(W.total&4294967295)){J.msg="incorrect length check",W.mode=h;break}U=0,P=0}W.mode=V6;case V6:v=$W;break J;case h:v=g6;break J;case y6:return v6;case E6:default:return e}if(J.next_out=Y,J.avail_out=F,J.next_in=X,J.avail_in=q,W.hold=U,W.bits=P,W.wsize||z!==J.avail_out&&W.mode<h&&(W.mode<_1||Q!==E8)){if(u6(J,J.output,J.next_out,z-J.avail_out));}if($-=J.avail_in,z-=J.avail_out,J.total_in+=$,J.total_out+=z,W.total+=z,W.wrap&4&&z)J.adler=W.check=W.flags?_(W.check,G,z,J.next_out-z):s0(W.check,G,z,J.next_out-z);if(J.data_type=W.bits+(W.last?64:0)+(W.mode===X0?128:0)+(W.mode===j1||W.mode===c1?256:0),($===0&&z===0||Q===E8)&&v===I0)v=jW;return v},DW=(J)=>{if(O0(J))return e;let Q=J.state;if(Q.window)Q.window=null;return J.state=null,I0},AW=(J,Q)=>{if(O0(J))return e;const W=J.state;if((W.wrap&2)===0)return e;return W.head=Q,Q.done=!1,I0},NW=(J,Q)=>{const W=Q.length;let V,G,X;if(O0(J))return e;if(V=J.state,V.wrap!==0&&V.mode!==I1)return e;if(V.mode===I1){if(G=1,G=s0(G,Q,W,0),G!==V.check)return g6}if(X=u6(J,Q,W,W),X)return V.mode=y6,v6;return V.havedict=1,I0},SW=h6,TW=p6,gW=f6,vW=xW,yW=b6,EW=wW,fW=DW,hW=AW,pW=NW,bW="pako inflate (from Nodeca project)",q0={inflateReset:SW,inflateReset2:TW,inflateResetKeep:gW,inflateInit:vW,inflateInit2:yW,inflate:EW,inflateEnd:fW,inflateGetHeader:hW,inflateSetDictionary:pW,inflateInfo:bW},mW=uW,m6=Object.prototype.toString,{Z_NO_FLUSH:cW,Z_FINISH:_W,Z_OK:Q1,Z_STREAM_END:l1,Z_NEED_DICT:n1,Z_STREAM_ERROR:dW,Z_DATA_ERROR:U6,Z_MEM_ERROR:iW}=x0;U1.prototype.push=function(J,Q){const W=this.strm,V=this.options.chunkSize,G=this.options.dictionary;let X,Y,q;if(this.ended)return!1;if(Q===~~Q)Y=Q;else Y=Q===!0?_W:cW;if(m6.call(J)==="[object ArrayBuffer]")W.input=new Uint8Array(J);else W.input=J;W.next_in=0,W.avail_in=W.input.length;for(;;){if(W.avail_out===0)W.output=new Uint8Array(V),W.next_out=0,W.avail_out=V;if(X=q0.inflate(W,Y),X===n1&&G){if(X=q0.inflateSetDictionary(W,G),X===Q1)X=q0.inflate(W,Y);else if(X===U6)X=n1}while(W.avail_in>0&&X===l1&&W.state.wrap>0&&J[W.next_in]!==0)q0.inflateReset(W),X=q0.inflate(W,Y);switch(X){case dW:case U6:case n1:case iW:return this.onEnd(X),this.ended=!0,!1}if(q=W.avail_out,W.next_out){if(W.avail_out===0||X===l1)if(this.options.to==="string"){let F=W1.utf8border(W.output,W.next_out),U=W.next_out-F,P=W1.buf2string(W.output,F);if(W.next_out=U,W.avail_out=V-U,U)W.output.set(W.output.subarray(F,F+U),0);this.onData(P)}else this.onData(W.output.length===W.next_out?W.output:W.output.subarray(0,W.next_out))}if(X===Q1&&q===0)continue;if(X===l1)return X=q0.inflateEnd(this.strm),this.onEnd(X),this.ended=!0,!0;if(W.avail_in===0)break}return!0};U1.prototype.onData=function(J){this.chunks.push(J)};U1.prototype.onEnd=function(J){if(J===Q1)if(this.options.to==="string")this.result=this.chunks.join("");else this.result=O1.flattenChunks(this.chunks);this.chunks=[],this.err=J,this.msg=this.strm.msg};var nW=U1,rW=P8,oW=lW,aW=P8,eW=x0,tW={Inflate:nW,inflate:rW,inflateRaw:oW,ungzip:aW,constants:eW},{Deflate:sW,deflate:J7,deflateRaw:W7,gzip:Q7}=UW,{Inflate:V7,inflate:G7,inflateRaw:X7,ungzip:U7}=tW,q7=sW,Y7=J7,P7=W7,K7=Q7,F7=V7,z7=G7,Z7=X7,H7=U7,k7=x0,w0={Deflate:q7,deflate:Y7,deflateRaw:P7,gzip:K7,Inflate:F7,inflate:z7,inflateRaw:Z7,ungzip:H7,constants:k7};function c6(J,Q,W){let V=Q.timestamp;if(V?.physical>Date.now()+7200000)V={physical:Date.now()+7200000,logical:V.logical};if(Q?.value?.priority===!0&&typeof Q.id==="string"&&Q.id.startsWith("user:")&&("role"in Q.value)){const{priority:G,...X}=Q.value;return{resolved:!0,value:X,timestamp:V}}if(Q?.value?.priority!==void 0){const{priority:G,...X}=Q.value;Q={...Q,value:X}}if(!J?.timestamp)return{resolved:!0,value:Q.value,timestamp:V};if(W.compare(V,J.timestamp)<=0)return{resolved:!1};return{resolved:!0,value:Q.value,timestamp:V}}function _6(J,Q=50){const W=`gdb_oplog_${J}`;let V=[];function G(){try{const Y=localStorage.getItem(W);V=Y?JSON.parse(Y):[]}catch(Y){console.error("\u274C GDB: Failed to load oplog from localStorage:",Y),V=[]}}function X(){try{localStorage.setItem(W,JSON.stringify(V))}catch(Y){console.error("\u274C GDB: Failed to save oplog to localStorage:",Y)}}return G(),{remove(Y){V=V.filter((q)=>q.id!==Y),X()},add(Y){if(V.push(Y),V.length>Q)V.shift();X()},getDelta(Y,q){if(!Y)return[...V];return V.filter((F)=>q(F.timestamp,Y)>0)},getOldest(){return V[0]},clear(){V=[],localStorage.removeItem(W)}}}var $7=()=>{const J=new Map,Q=async()=>{try{const F=await navigator.storage.getDirectory(),P=await(await F.getFileHandle("~opfs-sync-test",{create:!0})).createSyncAccessHandle?.();return await P?.close(),await F.removeEntry("~opfs-sync-test"),!!P}catch{return!1}};let W="idb";const V=(async()=>{if(await Q())W="sync";else try{const F=await navigator.storage.getDirectory(),P=await(await F.getFileHandle("~opfs-async-test",{create:!0})).createWritable?.();if(await P?.close(),await F.removeEntry("~opfs-async-test"),P)W="async";else W="idb"}catch{W="idb"}})(),G=async(F,U)=>{if(!J.has(F))J.set(F,[]);const P=J.get(F),$=P[P.length-1]||Promise.resolve();let z;const K=new Promise((k)=>z=k);P.push(K);try{return await $,await U()}finally{if(P.shift(),z(),P.length===0)J.delete(F)}},X=(()=>{let F;const U=async()=>{if(!F)F=new Promise((P,$)=>{const z=indexedDB.open("opfs-fallback-db",1);z.onupgradeneeded=()=>z.result.createObjectStore("files"),z.onsuccess=()=>P(z.result),z.onerror=()=>$(z.error)});return F};return{getDB:U,get:async(P)=>{const $=await U();return new Promise((z,K)=>{const O=$.transaction("files","readonly").objectStore("files").get(P);O.onsuccess=()=>z(O.result||new Uint8Array),O.onerror=()=>K(O.error)})},set:async(P,$)=>{const z=await U();return new Promise((K,k)=>{const w=z.transaction("files","readwrite").objectStore("files").put($,P);w.onsuccess=()=>K(),w.onerror=()=>k(w.error)})}}})(),Y=async(F)=>{await V;try{if(W==="idb"){const K=await X.get(F);return{type:"loaded",name:F,data:K}}const P=await(await navigator.storage.getDirectory()).getFileHandle(F);if(W==="sync"){let K;try{K=await P.createSyncAccessHandle();const k=K.getSize(),O=new Uint8Array(k),w=K.read(O,{at:0});return{type:"loaded",name:F,data:O.slice(0,w)}}finally{K?.close()}}const $=await P.getFile(),z=new Uint8Array(await $.arrayBuffer());return{type:"loaded",name:F,data:z}}catch(U){if(U.name==="NotFoundError")return{type:"loaded",name:F,data:new Uint8Array};return console.error(`\u274C Worker file load error for '${F}':`,U),{type:"error",name:F,message:U.message||"Error reading file"}}},q=async(F,U)=>{if(await V,!(U instanceof Uint8Array))return{type:"error",name:F,message:"Content must be a Uint8Array"};return G(F,async()=>{try{if(W==="idb")return await X.set(F,U),{type:"saved",name:F};const $=await(await navigator.storage.getDirectory()).getFileHandle(F,{create:!0});if(W==="sync"){let z;try{z=await $.createSyncAccessHandle(),z.truncate(0),z.write(U,{at:0}),z.flush()}finally{z?.close()}}else{let z;try{z=await $.createWritable(),await z.write(U)}finally{await z?.close()}}return{type:"saved",name:F}}catch(P){return{type:"error",name:F,message:P.message||"Error saving file"}}})};self.onmessage=async({data:F})=>{const{type:U,name:P,content:$}=F;await V;const z={load:()=>Y(P),save:()=>q(P,$)};try{const K=z[U],k=K?await K():{type:"error",message:`Unrecognized action type: ${U}`};self.postMessage(k)}catch(K){console.error("\u274C Worker unexpected error:",K),self.postMessage({type:"error",name:P,message:K.message||"Unexpected worker error"})}}},d6=$7;var q1={$eq:(J,Q)=>J===Q,$ne:(J,Q)=>J!==Q,$gt:(J,Q)=>J>Q,$gte:(J,Q)=>J>=Q,$lt:(J,Q)=>J<Q,$lte:(J,Q)=>J<=Q,$in:(J,Q)=>Array.isArray(Q)&&(Array.isArray(J)?J.some((W)=>Q.includes(W)):Q.includes(J)),$between:(J,[Q,W])=>J>=Q&&J<=W,$exists:(J,Q)=>Q?J!==void 0:J===void 0,$startsWith:(J,Q)=>typeof J==="string"&&J.startsWith(Q),$endsWith:(J,Q)=>typeof J==="string"&&J.endsWith(Q),$contains:(J,Q)=>typeof J==="string"&&J.includes(Q),$text:{global:(J,Q)=>{const W=(G)=>String(G).normalize("NFD").replace(/[\u0300-\u036f]/g,"").toLowerCase().replace(/[^\w\s]/g,""),V=W(Q);return Object.values(J).some((G)=>typeof G==="object"?null.fieldSearch(G,V):W(G).includes(V))},field:(J,Q)=>{const W=(G)=>String(G).normalize("NFD").replace(/[\u0300-\u036f]/g,"").toLowerCase().replace(/[^\w\s]/g,""),V=W(Q);return Array.isArray(J)?J.some((G)=>W(G).includes(V)):W(J).includes(V)}},$like:(J,Q)=>typeof J==="string"&&typeof Q==="string"&&new RegExp(`^${Q.replace(/%/g,".*").replace(/_/g,".")}\$`,"i").test(J),$regex:(J,Q)=>typeof J==="string"&&new RegExp(Q.$regex||Q,"i").test(J),$and:(J,Q,W)=>Q.every((V)=>W.createFilter(V,W.allNodes)(J)),$or:(J,Q,W)=>Q.some((V)=>W.createFilter(V,W.allNodes)(J)),$not:(J,Q,W)=>!W.createFilter(Q,W.allNodes)(J),$edge:(J,Q,W)=>{if(!J.edges?.length||typeof Q!=="object"||Q===null)return!1;const V=W.createFilter(Q,W.allNodes),G=[...J.edges],X=new Set(G).add(J.id),Y=[];while(G.length){const q=G.shift(),F=W.allNodes[q];if(!F)continue;if(V(F))Y.push(F);F.edges?.forEach((U)=>!X.has(U)&&X.add(U)&&G.push(U))}if(Y.length)J._edgeResult=Y;return Y.length>0}},D1=(J,Q)=>Q.split(".").reduce((W,V)=>W&&typeof W==="object"&&(V in W)?W[V]:void 0,J),A1=(J,Q)=>{if(Object.keys(J).length===0)return()=>!0;return(W)=>Object.entries(J).every(([V,G])=>{if(V.startsWith("$"))return q1[V](W,G,{createFilter:A1,allNodes:Q});let X=D1(W.value,V);if(X===void 0)X=D1(W,V);if(typeof G!=="object"||G===null)return q1.$eq(X,G);return Object.entries(G).every(([Y,q])=>{if(Y==="$text")return q1.$text.field(X,q);if(Y==="$between"&&q.every((F)=>F instanceof Date))return q1.$between(new Date(X),q);return q1[Y]?.(X,q,{createFilter:A1,allNodes:Q})??!1})})},K8=(J,Q)=>{const{$edge:W,...V}=Q.query||{},G=A1(V,J),X=Object.values(J).filter(G);let q=[...W?(()=>{const F=A1({$edge:W},J);X.forEach((P)=>F(P));const U=new Map;return X.forEach((P)=>{if(P._edgeResult)P._edgeResult.forEach(($)=>U.set($.id,$)),delete P._edgeResult}),Array.from(U.values())})():X];if(Q.field){const F=Q.order==="asc"?1:-1;q.sort((U,P)=>{const $=D1(U.value,Q.field),z=D1(P.value,Q.field);if(typeof $==="string"&&typeof z==="string")return $.localeCompare(z)*F;return(($??0)-(z??0))*F})}if(Q.$after){const F=q.findIndex((U)=>U.id===Q.$after);q=F>=0?q.slice(F+1):[]}if(Q.$before){const F=q.findIndex((U)=>U.id===Q.$before);q=F>=0?q.slice(0,F):[]}if(Q.$limit)q=q.slice(0,Q.$limit);return q};function i6(){let J=Date.now(),Q=0;return{now(){const W=Date.now();return J=Math.max(J,W),Q++,{physical:J,logical:Q}},update(W){if(!W||typeof W.physical!=="number"||typeof W.logical!=="number"){console.warn("\u26A0\uFE0F HybridClock.update received an invalid remote timestamp.",W);return}J=Math.max(J,W.physical),Q=Math.max(Q,W.logical)+1},compare(W,V){if(!W&&!V)return 0;if(!W)return-1;if(!V)return 1;if(W.physical>V.physical)return 1;if(W.physical<V.physical)return-1;if(W.logical>V.logical)return 1;if(W.logical<V.logical)return-1;return 0}}}async function j7(){if(console.info(navigator?.storage?.getDirectory?"\u2705 OPFS is enabled.":"\uD83D\uDEAB OPFS is not available."),navigator?.storage?.getDirectory)await navigator.storage.getDirectory()}var R7=function(){const J={nodes:{}};return{get nodes(){return J.nodes},set nodes(Q){J.nodes=Q||{}},upsert(Q,W,V){const G=J.nodes[Q];J.nodes[Q]={id:Q,value:W&&typeof W==="object"?F8(W):W,edges:G?.edges?[...G.edges]:[],timestamp:V}},get(Q){return J.nodes[Q]||null},link(Q,W,V){const G=J.nodes[Q],X=J.nodes[W];if(G&&X&&!G.edges.includes(W))J.nodes[Q]={...G,edges:[...G.edges,W],timestamp:V}},getAllNodes(){return Object.values(J.nodes)},serialize(){return w0.deflate(u0(J.nodes))},deserialize(Q){J.nodes=B0(w0.inflate(new Uint8Array(Q)))}}};async function HQ(J,Q={}){console.info("\x1B[36m\u26A1 GenosDB: Empowering distributed graph databases with real-time synchronization and scalability. Learn more: https://github.com/estebanrfp/gdb \u26A1\x1B[0m");const{rtc:W=!1,password:V,sm:G=!1,audit:X=!1,ii:Y=!1,rx:q=!1,ai:F=!1,geo:U=!1,nlq:P=!1,saveDelay:$=200,oplogSize:z=20}=Q,K=R7(),k=i6(),O=_6(J,z),w=[];let R=null,A=[],C=null,H=null,T=null,p=null;const j=[],v={};Object.defineProperties(v,{syncChannel:{get:()=>H},broadcastChannel:{get:()=>T},hybridClock:{get:()=>k},graph:{get:()=>({getAllNodes:()=>K.getAllNodes(),get:(B)=>K.get(B)})},worker:{get:()=>C},oplog:{get:()=>O},options:{get:()=>Q},pako:{get:()=>w0},encode:{get:()=>u0},decode:{get:()=>B0},deepClone:{get:()=>F8}});async function D(B,x){try{const M=await import(new URL(`./${B}.min.js`,import.meta.url).href),f=x&&typeof x==="object"?x:{},b=await M.init?.(v,M,f);if(b)Object.assign(v,b);return M}catch(M){throw console.error(`\u274C Initialization of ${B} failed:`,M),M}}function I(){const B=localStorage.getItem(`${J}_time`);R=B?JSON.parse(B):null}function N(B){R=B,localStorage.setItem(`${J}_time`,JSON.stringify(B))}function G0(){try{const B=URL.createObjectURL(new Blob([`(${d6.toString()})()`],{type:"application/javascript"}));C=new Worker(B),URL.revokeObjectURL(B),C.addEventListener("message",({data:x})=>console.debug(`\uD83D\uDCBE ${x.name} ${x.type}`)),console.debug("\u2699\uFE0F Worker initialized successfully.")}catch({message:B}){console.error("\u274C Failed to initialize worker:",B)}}function p0(){const B={...K.nodes};A.forEach((x)=>x(B))}const s=B7(()=>p0()),Y0=n6(async()=>{const B=j.splice(0,j.length);if(!B.length)return!1;return await H.send(B),!0},16);async function z8(){try{const x=await((M)=>new Promise((f,b)=>{const y=async({data:Z})=>{if(Z.type==="loaded"&&Z.name===M)C.removeEventListener("message",y),f(new Uint8Array(Z.data));else if(Z.type==="error")C.removeEventListener("message",y),b(new Error(Z.message||"Unknown error"))};C.addEventListener("message",y),C.postMessage({type:"load",name:M})}))(`${J}_graph.msgpack`).catch(()=>new Uint8Array);x.byteLength>0?K.deserialize(x):console.debug("\uD83D\uDCBE New database. File will be created on first save.")}catch({message:B}){console.error("\u274C Error loading the graph:",B)}}async function r6(){try{const B=K.serialize();return await((M,f)=>new Promise((b,y)=>{const Z=({data:S})=>{if(S.type==="saved"&&S.name===M)C.removeEventListener("message",Z),b();else if(S.type==="error")C.removeEventListener("message",Z),y(new Error(S.message||"Save error"))};C.addEventListener("message",Z),C.postMessage({type:"save",name:M,content:f})}))(`${J}_graph.msgpack`,B),T.postMessage("update"),!0}catch({message:B}){throw console.error("\u274C Save error:",B),new Error("Save failed")}}const Y1=n6(()=>r6(),$);async function o6(B){let x=!1,M=null;const f=(Z)=>{if(!M||k.compare(Z,M)>0)M=Z},b=(Z)=>{try{if(Z instanceof Uint8Array)return B0(w0.inflate(Z));if(Array.isArray(Z))return Z;if(Z&&typeof Z==="object")return B0(w0.inflate(new Uint8Array(Object.values(Z))))}catch(S){console.error("\u274C deltaSync decode failed",S)}return null},y={upsert:(Z)=>{const S=K.get(Z.id),{resolved:L,value:m,timestamp:c}=c6(S,Z,k);if(!L)return;K.upsert(Z.id,m,c),k.update(c),O.add({type:"upsert",id:Z.id,timestamp:c}),x=!0,f(c)},remove:(Z)=>{const S=K.get(Z.id);if(!S||k.compare(S.timestamp,Z.timestamp)>=0)return;delete K.nodes[Z.id],k.update(Z.timestamp),O.add({type:"remove",id:Z.id,timestamp:Z.timestamp}),x=!0,f(Z.timestamp)},link:(Z)=>{const S=K.get(Z.sourceId),L=K.get(Z.targetId);if(!S||!L||k.compare(S.timestamp,Z.timestamp)>=0)return;K.link(Z.sourceId,Z.targetId,Z.timestamp),k.update(Z.timestamp),O.add({type:"link",...Z}),x=!0,f(Z.timestamp)},sync:async({timestamp:Z})=>{const S=O.getOldest();if(Z==null||S&&k.compare(Z,S.timestamp)<0)return console.info("\uD83D\uDCA5 [FALLBACK] Peer too far behind \u2192 sending FULL state."),H.send([{type:"fullStateSync",graphData:K.serialize(),timestamp:R}]);const m=O.getDelta(Z,k.compare);if(!m.length)return;const c=m.map((t)=>t.type==="upsert"?{...t,value:K.get(t.id)?.value}:t);console.info(`\uD83D\uDE80 [DELTA SYNC SENDING] ${c.length} ops.`),await H.send([{type:"deltaSync",operations:w0.deflate(u0(c)),timestamp:R}])},deltaSync:({operations:Z})=>{const S=b(Z);if(!Array.isArray(S)){console.warn("\u26A0\uFE0F deltaSync payload not array. Ignored.");return}console.log(`\uD83D\uDEF0\uFE0F [DELTA SYNC RECEIVED] ${S.length} ops.`);for(let L of S)if(L&&y[L.type])y[L.type](L);else if(L)console.warn(`\uD83E\uDD37 Unknown op: ${L.type}`)},fullStateSync:async({graphData:Z,timestamp:S})=>{if(R&&S&&k.compare(R,S)>0){console.log("\uD83D\uDD04 Local newer, ignoring full sync.");return}if(!(Z instanceof Uint8Array))if(Z&&typeof Z==="object")Z=new Uint8Array(Object.values(Z));else{console.error("\u274C Invalid full graph data received");return}try{if(console.log("\uD83D\uDCE6 [FULL SYNC RECEIVED] Applying full graph."),K.deserialize(Z),O.clear(),x=!0,S)f(S),k.update(S)}catch(L){console.error("\u274C Full sync failed:",L)}}};for(let Z of B)if(y[Z.type])await y[Z.type](Z);else console.warn(`\uD83E\uDD37 Unknown type: ${Z.type}`);if(M&&(!R||k.compare(M,R)>0))console.info(`\uD83D\uDCC8 [GLOBAL TS] Advanced to ${M.logical}`),N(M);if(x)console.info("\uD83D\uDCBE [STATE CHANGED] Saving + emitting."),await Y1(),s()}Object.assign(v,{use(B){if(typeof B==="function")w.push(B)},async put(B,x){const M=k.now();N(M),x=x??crypto.randomUUID(),K.upsert(x,B,M),O.add({type:"upsert",id:x,timestamp:M}),Y1();try{j.push({type:"upsert",id:x,value:B,timestamp:M}),Y0().catch(()=>{})}finally{s()}return x},async link(B,x){const M=k.now();if(!K.nodes[B]||!K.nodes[x]){console.warn(`\u26A0\uFE0F One or both nodes (${B}, ${x}) do not exist.`);return}K.link(B,x,M),O.add({type:"link",sourceId:B,targetId:x,timestamp:M}),Y1(),N(M);try{j.push({type:"link",sourceId:B,targetId:x,timestamp:M}),Y0().catch(()=>{})}finally{s()}},async remove(B){const x=k.now(),M=K.get(B);if(!M)return console.warn(`\u26A0\uFE0F Node with ID '${B}' not found.`);delete K.nodes[B],O.add({type:"remove",id:B,timestamp:x}),Object.values(K.nodes).forEach((f)=>f.edges=f.edges.filter((b)=>b!==B)),Y1(),N(x);try{j.push({type:"remove",id:B,value:M.value,timestamp:x}),Y0().catch(()=>{})}finally{s()}},async get(B,x=null){if(typeof B!=="string")return{result:null};const M=K.get(B);if(!M){if(x)x(null);return{result:null}}const f=(Z)=>{if(!Z)return null;const S=Z.value!==null&&typeof Z.value==="object"?{...Z.value}:Z.value;return{...Z,value:S}};if(!x)return{result:f(M)};let b=M.timestamp;x(f(M));const y=(Z)=>{const S=Z[B];if(S){if(k.compare(S.timestamp,b)>0)b=S.timestamp,x(f(S))}else x(null),A.splice(A.indexOf(y),1)};return A.push(y),{result:f(M),unsubscribe:()=>{const Z=A.indexOf(y);if(Z>-1)A.splice(Z,1)}}},async map(...B){let M={...{realtime:!1,query:{},field:null,order:"asc",$limit:null,$after:null,$before:null}},f=null,b=!1;B.forEach((L)=>typeof L==="function"?f=L:L&&typeof L==="object"&&(b=b||("realtime"in L),Object.assign(M,L))),f&&!b&&(M.realtime=!0);let y=K8(K.nodes,M),Z=null;const S=(L)=>{const m=new Map(y.map((u)=>[u.id,u])),c=new Map(L.map((u)=>[u.id,u])),t=[],D0=[],Z8=[];for(let[u,K0]of c){const P1=m.get(u);if(!P1)t.push(K0);else if((K0.timestamp?.physical||0)!==(P1.timestamp?.physical||0)||(K0.timestamp?.logical||0)!==(P1.timestamp?.logical||0)||!l6(K0.edges||[],P1.edges||[]))D0.push(K0)}for(let[u]of m)if(!c.has(u))Z8.push(m.get(u));const N1=(u,K0)=>f({id:u.id,value:K0==="removed"?null:u.value,edges:u.edges||[],timestamp:u.timestamp||null,action:K0});t.forEach((u)=>N1(u,"added")),Z8.forEach((u)=>N1(u,"removed")),D0.forEach((u)=>N1(u,"updated"))};if(f){if(y.forEach((L)=>{f({id:L.id,value:L.value,edges:L.edges,timestamp:L.timestamp,action:"initial"})}),M.realtime){const L=(m)=>{const c=m.timestamp?.physical||0,t=m.timestamp?.logical||0,D0=(m.edges||[]).join(",");return`${m.id}:${c}:${t}:${D0}`};Z=(m)=>{const c=K8(m,M);if(c.length!==y.length)S(c),y=c;else{const t=c.map(L),D0=y.map(L);if(!l6(t,D0))S(c),y=c}},A.push(Z)}}return{results:y,...M.realtime&&f&&Z&&{unsubscribe:()=>{const L=A.indexOf(Z);L>-1&&A.splice(L,1)}}}},async clear(){K.nodes={};try{await(await navigator.storage.getDirectory()).removeEntry(`${J}_graph.msgpack`)}catch({message:B}){console.warn(`\u26A0\uFE0F Error deleting _graph.msgpack: ${B}`)}p0(),console.info("\u2705 All data has been deleted.")}}),G0(),I(),await j7(),await z8();const P0=[];if(G)P0.push(D("sm",G));if(F)P0.push(D("ai",F));if(q)P0.push(D("rx",q));if(Y)P0.push(D("ii",Y));if(X)P0.push(D("audit",X));if(U)P0.push(D("geo",U));if(P)P0.push(D("nlq",P));await Promise.all(P0);const a6=`graph-sync-room-${J}`;if(W){const{join:B}=await D("genosrtc"),{relayUrls:x,turnConfig:M}=W?.constructor===Object?W:{},f={appId:"1234",...V&&{password:V}};if(x)f.relayUrls=x;if(M)f.turnConfig=M;const b=B(f,a6);H=b.channel("syncGraph"),p=B(f,`app-sync-${J}`),v.room=p,b.on("peer:join",async(y)=>{console.info("\u26A1 New peer connected:",y),H.send([{type:"sync",timestamp:R}])}),b.on("peer:leave",(y)=>{console.info("\u26A1 Peer disconnected:",y)}),H?.on("message",async(y)=>{let Z;try{if(y instanceof Uint8Array||y instanceof ArrayBuffer){const L=B0(y);Z=Array.isArray(L)?L:[L]}else Z=Array.isArray(y)?y:[y]}catch(L){return console.error("\u274C Failed to decode MessagePack:",L)}const S=new Map([...new Set(Z.flatMap((L)=>["id","sourceId","targetId"].map((m)=>L&&L[m]).filter(Boolean)))].map((L)=>K.get(L)?[L,F8(K.get(L))]:null).filter(Boolean));for(let L of w)try{if(Z=await L(Z,S),!Z||!Z.length)return}catch(m){console.error("\u274C Middleware error, discarding message.",m);return}await o6(Z)})}return T=new BroadcastChannel(`graphdb_sync_${J}`),T.onmessage=async(B)=>{if(B.data==="update")console.info("\uD83D\uDD04 Update received from another tab..."),await z8(),I(),s()},console.info(`\u2705 GenosDB [ \x1B[32m${J}\x1B[0m ] instance is ready.`),v}var l6=(J,Q)=>J.length===Q.length&&J.every((W,V)=>W===Q[V]),F8=(J)=>J&&typeof J==="object"?globalThis.structuredClone?.(J)??JSON.parse(JSON.stringify(J)):J,n6=(J,Q=16)=>{let W=null,V=null;return(...G)=>{if(!V)V={},V.promise=new Promise((Y,q)=>(V.resolve=Y,V.reject=q));if(W)("cancelIdleCallback"in window?cancelIdleCallback:clearTimeout)(W);const X=async()=>{W=null;try{V.resolve(await J(...G))}catch(Y){V.reject(Y)}finally{V=null}};return W=("requestIdleCallback"in window)?requestIdleCallback(X,{timeout:Q}):setTimeout(X,Q),V.promise}},B7=(J)=>{let Q=null;return()=>{if(Q!==null)return;Q=requestAnimationFrame(()=>{Q=null,J()})}};export{HQ as gdb};
