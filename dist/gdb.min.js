function Z8(W){const Q=W.length;let J=0,V=0;while(V<Q){let G=W.charCodeAt(V++);if((G&4294967168)===0){J++;continue}else if((G&4294965248)===0)J+=2;else{if(G>=55296&&G<=56319){if(V<Q){const q=W.charCodeAt(V);if((q&64512)===56320)++V,G=((G&1023)<<10)+(q&1023)+65536}}if((G&4294901760)===0)J+=3;else J+=4}}return J}function t6(W,Q,J){const V=W.length;let G=J,q=0;while(q<V){let Y=W.charCodeAt(q++);if((Y&4294967168)===0){Q[G++]=Y;continue}else if((Y&4294965248)===0)Q[G++]=Y>>6&31|192;else{if(Y>=55296&&Y<=56319){if(q<V){const U=W.charCodeAt(q);if((U&64512)===56320)++q,Y=((Y&1023)<<10)+(U&1023)+65536}}if((Y&4294901760)===0)Q[G++]=Y>>12&15|224,Q[G++]=Y>>6&63|128;else Q[G++]=Y>>18&7|240,Q[G++]=Y>>12&63|128,Q[G++]=Y>>6&63|128}Q[G++]=Y&63|128}}function WW(W,Q,J){s6.encodeInto(W,Q.subarray(J))}function H8(W,Q,J){if(W.length>e6)WW(W,Q,J);else t6(W,Q,J)}function v1(W,Q,J){let V=Q;const G=V+J,q=[];let Y="";while(V<G){const U=W[V++];if((U&128)===0)q.push(U);else if((U&224)===192){const z=W[V++]&63;q.push((U&31)<<6|z)}else if((U&240)===224){const z=W[V++]&63,X=W[V++]&63;q.push((U&31)<<12|z<<6|X)}else if((U&248)===240){const z=W[V++]&63,X=W[V++]&63,P=W[V++]&63;let $=(U&7)<<18|z<<12|X<<6|P;if($>65535)$-=65536,q.push($>>>10&1023|55296),$=56320|$&1023;q.push($)}else q.push(U);if(q.length>=JW)Y+=String.fromCharCode(...q),q.length=0}if(q.length>0)Y+=String.fromCharCode(...q);return Y}function GW(W,Q,J){const V=W.subarray(Q,Q+J);return QW.decode(V)}function k8(W,Q,J){if(J>VW)return GW(W,Q,J);else return v1(W,Q,J)}var s6=new TextEncoder,e6=50,JW=4096,QW=new TextDecoder,VW=200;class D0{constructor(W,Q){this.type=W,this.data=Q}}class d extends Error{constructor(W){super(W);const Q=Object.create(d.prototype);Object.setPrototypeOf(this,Q),Object.defineProperty(this,"name",{configurable:!0,enumerable:!1,value:d.name})}}function $8(W,Q,J){const V=J/4294967296,G=J;W.setUint32(Q,V),W.setUint32(Q+4,G)}function P1(W,Q,J){const V=Math.floor(J/4294967296),G=J;W.setUint32(Q,V),W.setUint32(Q+4,G)}function K1(W,Q){const J=W.getInt32(Q),V=W.getUint32(Q+4);return J*4294967296+V}function B8(W,Q){const J=W.getUint32(Q),V=W.getUint32(Q+4);return J*4294967296+V}var A0=4294967295;function YW({sec:W,nsec:Q}){if(W>=0&&Q>=0&&W<=UW)if(Q===0&&W<=XW){const J=new Uint8Array(4);return new DataView(J.buffer).setUint32(0,W),J}else{const J=W/4294967296,V=W&4294967295,G=new Uint8Array(8),q=new DataView(G.buffer);return q.setUint32(0,Q<<2|J&3),q.setUint32(4,V),G}else{const J=new Uint8Array(12),V=new DataView(J.buffer);return V.setUint32(0,Q),P1(V,4,W),J}}function PW(W){const Q=W.getTime(),J=Math.floor(Q/1000),V=(Q-J*1000)*1e6,G=Math.floor(V/1e9);return{sec:J+G,nsec:V-G*1e9}}function KW(W){if(W instanceof Date){const Q=PW(W);return YW(Q)}else return null}function FW(W){const Q=new DataView(W.buffer,W.byteOffset,W.byteLength);switch(W.byteLength){case 4:return{sec:Q.getUint32(0),nsec:0};case 8:{const J=Q.getUint32(0),V=Q.getUint32(4),G=(J&3)*4294967296+V,q=J>>>2;return{sec:G,nsec:q}}case 12:{const J=K1(Q,4),V=Q.getUint32(0);return{sec:J,nsec:V}}default:throw new d(`Unrecognized data size for timestamp (expected 4, 8, or 12): ${W.length}`)}}function zW(W){const Q=FW(W);return new Date(Q.sec*1000+Q.nsec/1e6)}var qW=-1,XW=4294967295,UW=17179869183,C8={type:qW,encode:KW,decode:zW};class B0{constructor(){this.builtInEncoders=[],this.builtInDecoders=[],this.encoders=[],this.decoders=[],this.register(C8)}register({type:W,encode:Q,decode:J}){if(W>=0)this.encoders[W]=Q,this.decoders[W]=J;else{const V=-1-W;this.builtInEncoders[V]=Q,this.builtInDecoders[V]=J}}tryToEncode(W,Q){for(let J=0;J<this.builtInEncoders.length;J++){const V=this.builtInEncoders[J];if(V!=null){const G=V(W,Q);if(G!=null){const q=-1-J;return new D0(q,G)}}}for(let J=0;J<this.encoders.length;J++){const V=this.encoders[J];if(V!=null){const G=V(W,Q);if(G!=null)return new D0(J,G)}}if(W instanceof D0)return W;return null}decode(W,Q,J){const V=Q<0?this.builtInDecoders[-1-Q]:this.decoders[Q];if(V)return V(W,Q,J);else return new D0(Q,W)}}B0.defaultCodec=new B0;var ZW=function(W){return W instanceof ArrayBuffer||typeof SharedArrayBuffer!=="undefined"&&W instanceof SharedArrayBuffer};function h0(W){if(W instanceof Uint8Array)return W;else if(ArrayBuffer.isView(W))return new Uint8Array(W.buffer,W.byteOffset,W.byteLength);else if(ZW(W))return new Uint8Array(W);else return Uint8Array.from(W)}var HW=100,kW=2048;class F1{constructor(W){this.entered=!1,this.extensionCodec=W?.extensionCodec??B0.defaultCodec,this.context=W?.context,this.useBigInt64=W?.useBigInt64??!1,this.maxDepth=W?.maxDepth??HW,this.initialBufferSize=W?.initialBufferSize??kW,this.sortKeys=W?.sortKeys??!1,this.forceFloat32=W?.forceFloat32??!1,this.ignoreUndefined=W?.ignoreUndefined??!1,this.forceIntegerToFloat=W?.forceIntegerToFloat??!1,this.pos=0,this.view=new DataView(new ArrayBuffer(this.initialBufferSize)),this.bytes=new Uint8Array(this.view.buffer)}clone(){return new F1({extensionCodec:this.extensionCodec,context:this.context,useBigInt64:this.useBigInt64,maxDepth:this.maxDepth,initialBufferSize:this.initialBufferSize,sortKeys:this.sortKeys,forceFloat32:this.forceFloat32,ignoreUndefined:this.ignoreUndefined,forceIntegerToFloat:this.forceIntegerToFloat})}reinitializeState(){this.pos=0}encodeSharedRef(W){if(this.entered)return this.clone().encodeSharedRef(W);try{return this.entered=!0,this.reinitializeState(),this.doEncode(W,1),this.bytes.subarray(0,this.pos)}finally{this.entered=!1}}encode(W){if(this.entered)return this.clone().encode(W);try{return this.entered=!0,this.reinitializeState(),this.doEncode(W,1),this.bytes.slice(0,this.pos)}finally{this.entered=!1}}doEncode(W,Q){if(Q>this.maxDepth)throw new Error(`Too deep objects in depth ${Q}`);if(W==null)this.encodeNil();else if(typeof W==="boolean")this.encodeBoolean(W);else if(typeof W==="number")if(!this.forceIntegerToFloat)this.encodeNumber(W);else this.encodeNumberAsFloat(W);else if(typeof W==="string")this.encodeString(W);else if(this.useBigInt64&&typeof W==="bigint")this.encodeBigInt64(W);else this.encodeObject(W,Q)}ensureBufferSizeToWrite(W){const Q=this.pos+W;if(this.view.byteLength<Q)this.resizeBuffer(Q*2)}resizeBuffer(W){const Q=new ArrayBuffer(W),J=new Uint8Array(Q),V=new DataView(Q);J.set(this.bytes),this.view=V,this.bytes=J}encodeNil(){this.writeU8(192)}encodeBoolean(W){if(W===!1)this.writeU8(194);else this.writeU8(195)}encodeNumber(W){if(!this.forceIntegerToFloat&&Number.isSafeInteger(W))if(W>=0)if(W<128)this.writeU8(W);else if(W<256)this.writeU8(204),this.writeU8(W);else if(W<65536)this.writeU8(205),this.writeU16(W);else if(W<4294967296)this.writeU8(206),this.writeU32(W);else if(!this.useBigInt64)this.writeU8(207),this.writeU64(W);else this.encodeNumberAsFloat(W);else if(W>=-32)this.writeU8(224|W+32);else if(W>=-128)this.writeU8(208),this.writeI8(W);else if(W>=-32768)this.writeU8(209),this.writeI16(W);else if(W>=-2147483648)this.writeU8(210),this.writeI32(W);else if(!this.useBigInt64)this.writeU8(211),this.writeI64(W);else this.encodeNumberAsFloat(W);else this.encodeNumberAsFloat(W)}encodeNumberAsFloat(W){if(this.forceFloat32)this.writeU8(202),this.writeF32(W);else this.writeU8(203),this.writeF64(W)}encodeBigInt64(W){if(W>=BigInt(0))this.writeU8(207),this.writeBigUint64(W);else this.writeU8(211),this.writeBigInt64(W)}writeStringHeader(W){if(W<32)this.writeU8(160+W);else if(W<256)this.writeU8(217),this.writeU8(W);else if(W<65536)this.writeU8(218),this.writeU16(W);else if(W<4294967296)this.writeU8(219),this.writeU32(W);else throw new Error(`Too long string: ${W} bytes in UTF-8`)}encodeString(W){const J=Z8(W);this.ensureBufferSizeToWrite(5+J),this.writeStringHeader(J),H8(W,this.bytes,this.pos),this.pos+=J}encodeObject(W,Q){const J=this.extensionCodec.tryToEncode(W,this.context);if(J!=null)this.encodeExtension(J);else if(Array.isArray(W))this.encodeArray(W,Q);else if(ArrayBuffer.isView(W))this.encodeBinary(W);else if(typeof W==="object")this.encodeMap(W,Q);else throw new Error(`Unrecognized object: ${Object.prototype.toString.apply(W)}`)}encodeBinary(W){const Q=W.byteLength;if(Q<256)this.writeU8(196),this.writeU8(Q);else if(Q<65536)this.writeU8(197),this.writeU16(Q);else if(Q<4294967296)this.writeU8(198),this.writeU32(Q);else throw new Error(`Too large binary: ${Q}`);const J=h0(W);this.writeU8a(J)}encodeArray(W,Q){const J=W.length;if(J<16)this.writeU8(144+J);else if(J<65536)this.writeU8(220),this.writeU16(J);else if(J<4294967296)this.writeU8(221),this.writeU32(J);else throw new Error(`Too large array: ${J}`);for(let V of W)this.doEncode(V,Q+1)}countWithoutUndefined(W,Q){let J=0;for(let V of Q)if(W[V]!==void 0)J++;return J}encodeMap(W,Q){const J=Object.keys(W);if(this.sortKeys)J.sort();const V=this.ignoreUndefined?this.countWithoutUndefined(W,J):J.length;if(V<16)this.writeU8(128+V);else if(V<65536)this.writeU8(222),this.writeU16(V);else if(V<4294967296)this.writeU8(223),this.writeU32(V);else throw new Error(`Too large map object: ${V}`);for(let G of J){const q=W[G];if(!(this.ignoreUndefined&&q===void 0))this.encodeString(G),this.doEncode(q,Q+1)}}encodeExtension(W){if(typeof W.data==="function"){const J=W.data(this.pos+6),V=J.length;if(V>=4294967296)throw new Error(`Too large extension object: ${V}`);this.writeU8(201),this.writeU32(V),this.writeI8(W.type),this.writeU8a(J);return}const Q=W.data.length;if(Q===1)this.writeU8(212);else if(Q===2)this.writeU8(213);else if(Q===4)this.writeU8(214);else if(Q===8)this.writeU8(215);else if(Q===16)this.writeU8(216);else if(Q<256)this.writeU8(199),this.writeU8(Q);else if(Q<65536)this.writeU8(200),this.writeU16(Q);else if(Q<4294967296)this.writeU8(201),this.writeU32(Q);else throw new Error(`Too large extension object: ${Q}`);this.writeI8(W.type),this.writeU8a(W.data)}writeU8(W){this.ensureBufferSizeToWrite(1),this.view.setUint8(this.pos,W),this.pos++}writeU8a(W){const Q=W.length;this.ensureBufferSizeToWrite(Q),this.bytes.set(W,this.pos),this.pos+=Q}writeI8(W){this.ensureBufferSizeToWrite(1),this.view.setInt8(this.pos,W),this.pos++}writeU16(W){this.ensureBufferSizeToWrite(2),this.view.setUint16(this.pos,W),this.pos+=2}writeI16(W){this.ensureBufferSizeToWrite(2),this.view.setInt16(this.pos,W),this.pos+=2}writeU32(W){this.ensureBufferSizeToWrite(4),this.view.setUint32(this.pos,W),this.pos+=4}writeI32(W){this.ensureBufferSizeToWrite(4),this.view.setInt32(this.pos,W),this.pos+=4}writeF32(W){this.ensureBufferSizeToWrite(4),this.view.setFloat32(this.pos,W),this.pos+=4}writeF64(W){this.ensureBufferSizeToWrite(8),this.view.setFloat64(this.pos,W),this.pos+=8}writeU64(W){this.ensureBufferSizeToWrite(8),$8(this.view,this.pos,W),this.pos+=8}writeI64(W){this.ensureBufferSizeToWrite(8),P1(this.view,this.pos,W),this.pos+=8}writeBigUint64(W){this.ensureBufferSizeToWrite(8),this.view.setBigUint64(this.pos,W),this.pos+=8}writeBigInt64(W){this.ensureBufferSizeToWrite(8),this.view.setBigInt64(this.pos,W),this.pos+=8}}function b0(W,Q){return new F1(Q).encodeSharedRef(W)}function z1(W){return`${W<0?"-":""}0x${Math.abs(W).toString(16).padStart(2,"0")}`}var $W=16,BW=16;class T1{constructor(W=$W,Q=BW){this.hit=0,this.miss=0,this.maxKeyLength=W,this.maxLengthPerKey=Q,this.caches=[];for(let J=0;J<this.maxKeyLength;J++)this.caches.push([])}canBeCached(W){return W>0&&W<=this.maxKeyLength}find(W,Q,J){const V=this.caches[J-1];W:for(let G of V){const q=G.bytes;for(let Y=0;Y<J;Y++)if(q[Y]!==W[Q+Y])continue W;return G.str}return null}store(W,Q){const J=this.caches[W.length-1],V={bytes:W,str:Q};if(J.length>=this.maxLengthPerKey)J[Math.random()*J.length|0]=V;else J.push(V)}decode(W,Q,J){const V=this.find(W,Q,J);if(V!=null)return this.hit++,V;this.miss++;const G=v1(W,Q,J),q=Uint8Array.prototype.slice.call(W,Q,Q+J);return this.store(q,G),G}}var g1="array",m0="map_key",R8="map_value",CW=(W)=>{if(typeof W==="string"||typeof W==="number")return W;throw new d("The type of key must be string or number but "+typeof W)};class M8{constructor(){this.stack=[],this.stackHeadPosition=-1}get length(){return this.stackHeadPosition+1}top(){return this.stack[this.stackHeadPosition]}pushArrayState(W){const Q=this.getUninitializedStateFromPool();Q.type=g1,Q.position=0,Q.size=W,Q.array=new Array(W)}pushMapState(W){const Q=this.getUninitializedStateFromPool();Q.type=m0,Q.readCount=0,Q.size=W,Q.map={}}getUninitializedStateFromPool(){if(this.stackHeadPosition++,this.stackHeadPosition===this.stack.length){const W={type:void 0,size:0,array:void 0,position:0,readCount:0,map:void 0,key:null};this.stack.push(W)}return this.stack[this.stackHeadPosition]}release(W){if(this.stack[this.stackHeadPosition]!==W)throw new Error("Invalid stack state. Released state is not on top of the stack.");if(W.type===g1){const J=W;J.size=0,J.array=void 0,J.position=0,J.type=void 0}if(W.type===m0||W.type===R8){const J=W;J.size=0,J.map=void 0,J.readCount=0,J.type=void 0}this.stackHeadPosition--}reset(){this.stack.length=0,this.stackHeadPosition=-1}}var u0=-1,y1=new DataView(new ArrayBuffer(0)),jW=new Uint8Array(y1.buffer);try{y1.getInt8(0)}catch(W){if(!(W instanceof RangeError))throw new Error("This module is not supported in the current JavaScript engine because DataView does not throw RangeError on out-of-bounds access")}var j8=new RangeError("Insufficient data"),RW=new T1;class Z1{constructor(W){this.totalPos=0,this.pos=0,this.view=y1,this.bytes=jW,this.headByte=u0,this.stack=new M8,this.entered=!1,this.extensionCodec=W?.extensionCodec??B0.defaultCodec,this.context=W?.context,this.useBigInt64=W?.useBigInt64??!1,this.rawStrings=W?.rawStrings??!1,this.maxStrLength=W?.maxStrLength??A0,this.maxBinLength=W?.maxBinLength??A0,this.maxArrayLength=W?.maxArrayLength??A0,this.maxMapLength=W?.maxMapLength??A0,this.maxExtLength=W?.maxExtLength??A0,this.keyDecoder=W?.keyDecoder!==void 0?W.keyDecoder:RW,this.mapKeyConverter=W?.mapKeyConverter??CW}clone(){return new Z1({extensionCodec:this.extensionCodec,context:this.context,useBigInt64:this.useBigInt64,rawStrings:this.rawStrings,maxStrLength:this.maxStrLength,maxBinLength:this.maxBinLength,maxArrayLength:this.maxArrayLength,maxMapLength:this.maxMapLength,maxExtLength:this.maxExtLength,keyDecoder:this.keyDecoder})}reinitializeState(){this.totalPos=0,this.headByte=u0,this.stack.reset()}setBuffer(W){const Q=h0(W);this.bytes=Q,this.view=new DataView(Q.buffer,Q.byteOffset,Q.byteLength),this.pos=0}appendBuffer(W){if(this.headByte===u0&&!this.hasRemaining(1))this.setBuffer(W);else{const Q=this.bytes.subarray(this.pos),J=h0(W),V=new Uint8Array(Q.length+J.length);V.set(Q),V.set(J,Q.length),this.setBuffer(V)}}hasRemaining(W){return this.view.byteLength-this.pos>=W}createExtraByteError(W){const{view:Q,pos:J}=this;return new RangeError(`Extra ${Q.byteLength-J} of ${Q.byteLength} byte(s) found at buffer[${W}]`)}decode(W){if(this.entered)return this.clone().decode(W);try{this.entered=!0,this.reinitializeState(),this.setBuffer(W);const Q=this.doDecodeSync();if(this.hasRemaining(1))throw this.createExtraByteError(this.pos);return Q}finally{this.entered=!1}}*decodeMulti(W){if(this.entered){yield*this.clone().decodeMulti(W);return}try{this.entered=!0,this.reinitializeState(),this.setBuffer(W);while(this.hasRemaining(1))yield this.doDecodeSync()}finally{this.entered=!1}}async decodeAsync(W){if(this.entered)return this.clone().decodeAsync(W);try{this.entered=!0;let Q=!1,J;for await(let Y of W){if(Q)throw this.entered=!1,this.createExtraByteError(this.totalPos);this.appendBuffer(Y);try{J=this.doDecodeSync(),Q=!0}catch(U){if(!(U instanceof RangeError))throw U}this.totalPos+=this.pos}if(Q){if(this.hasRemaining(1))throw this.createExtraByteError(this.totalPos);return J}const{headByte:V,pos:G,totalPos:q}=this;throw new RangeError(`Insufficient data in parsing ${z1(V)} at ${q} (${G} in the current buffer)`)}finally{this.entered=!1}}decodeArrayStream(W){return this.decodeMultiAsync(W,!0)}decodeStream(W){return this.decodeMultiAsync(W,!1)}async*decodeMultiAsync(W,Q){if(this.entered){yield*this.clone().decodeMultiAsync(W,Q);return}try{this.entered=!0;let J=Q,V=-1;for await(let G of W){if(Q&&V===0)throw this.createExtraByteError(this.totalPos);if(this.appendBuffer(G),J)V=this.readArraySize(),J=!1,this.complete();try{while(!0)if(yield this.doDecodeSync(),--V===0)break}catch(q){if(!(q instanceof RangeError))throw q}this.totalPos+=this.pos}}finally{this.entered=!1}}doDecodeSync(){W:while(!0){const W=this.readHeadByte();let Q;if(W>=224)Q=W-256;else if(W<192)if(W<128)Q=W;else if(W<144){const V=W-128;if(V!==0){this.pushMapState(V),this.complete();continue W}else Q={}}else if(W<160){const V=W-144;if(V!==0){this.pushArrayState(V),this.complete();continue W}else Q=[]}else{const V=W-160;Q=this.decodeString(V,0)}else if(W===192)Q=null;else if(W===194)Q=!1;else if(W===195)Q=!0;else if(W===202)Q=this.readF32();else if(W===203)Q=this.readF64();else if(W===204)Q=this.readU8();else if(W===205)Q=this.readU16();else if(W===206)Q=this.readU32();else if(W===207)if(this.useBigInt64)Q=this.readU64AsBigInt();else Q=this.readU64();else if(W===208)Q=this.readI8();else if(W===209)Q=this.readI16();else if(W===210)Q=this.readI32();else if(W===211)if(this.useBigInt64)Q=this.readI64AsBigInt();else Q=this.readI64();else if(W===217){const V=this.lookU8();Q=this.decodeString(V,1)}else if(W===218){const V=this.lookU16();Q=this.decodeString(V,2)}else if(W===219){const V=this.lookU32();Q=this.decodeString(V,4)}else if(W===220){const V=this.readU16();if(V!==0){this.pushArrayState(V),this.complete();continue W}else Q=[]}else if(W===221){const V=this.readU32();if(V!==0){this.pushArrayState(V),this.complete();continue W}else Q=[]}else if(W===222){const V=this.readU16();if(V!==0){this.pushMapState(V),this.complete();continue W}else Q={}}else if(W===223){const V=this.readU32();if(V!==0){this.pushMapState(V),this.complete();continue W}else Q={}}else if(W===196){const V=this.lookU8();Q=this.decodeBinary(V,1)}else if(W===197){const V=this.lookU16();Q=this.decodeBinary(V,2)}else if(W===198){const V=this.lookU32();Q=this.decodeBinary(V,4)}else if(W===212)Q=this.decodeExtension(1,0);else if(W===213)Q=this.decodeExtension(2,0);else if(W===214)Q=this.decodeExtension(4,0);else if(W===215)Q=this.decodeExtension(8,0);else if(W===216)Q=this.decodeExtension(16,0);else if(W===199){const V=this.lookU8();Q=this.decodeExtension(V,1)}else if(W===200){const V=this.lookU16();Q=this.decodeExtension(V,2)}else if(W===201){const V=this.lookU32();Q=this.decodeExtension(V,4)}else throw new d(`Unrecognized type byte: ${z1(W)}`);this.complete();const J=this.stack;while(J.length>0){const V=J.top();if(V.type===g1)if(V.array[V.position]=Q,V.position++,V.position===V.size)Q=V.array,J.release(V);else continue W;else if(V.type===m0){if(Q==="__proto__")throw new d("The key __proto__ is not allowed");V.key=this.mapKeyConverter(Q),V.type=R8;continue W}else if(V.map[V.key]=Q,V.readCount++,V.readCount===V.size)Q=V.map,J.release(V);else{V.key=null,V.type=m0;continue W}}return Q}}readHeadByte(){if(this.headByte===u0)this.headByte=this.readU8();return this.headByte}complete(){this.headByte=u0}readArraySize(){const W=this.readHeadByte();switch(W){case 220:return this.readU16();case 221:return this.readU32();default:if(W<160)return W-144;else throw new d(`Unrecognized array type byte: ${z1(W)}`)}}pushMapState(W){if(W>this.maxMapLength)throw new d(`Max length exceeded: map length (${W}) > maxMapLengthLength (${this.maxMapLength})`);this.stack.pushMapState(W)}pushArrayState(W){if(W>this.maxArrayLength)throw new d(`Max length exceeded: array length (${W}) > maxArrayLength (${this.maxArrayLength})`);this.stack.pushArrayState(W)}decodeString(W,Q){if(!this.rawStrings||this.stateIsMapKey())return this.decodeUtf8String(W,Q);return this.decodeBinary(W,Q)}decodeUtf8String(W,Q){if(W>this.maxStrLength)throw new d(`Max length exceeded: UTF-8 byte length (${W}) > maxStrLength (${this.maxStrLength})`);if(this.bytes.byteLength<this.pos+Q+W)throw j8;const J=this.pos+Q;let V;if(this.stateIsMapKey()&&this.keyDecoder?.canBeCached(W))V=this.keyDecoder.decode(this.bytes,J,W);else V=k8(this.bytes,J,W);return this.pos+=Q+W,V}stateIsMapKey(){if(this.stack.length>0)return this.stack.top().type===m0;return!1}decodeBinary(W,Q){if(W>this.maxBinLength)throw new d(`Max length exceeded: bin length (${W}) > maxBinLength (${this.maxBinLength})`);if(!this.hasRemaining(W+Q))throw j8;const J=this.pos+Q,V=this.bytes.subarray(J,J+W);return this.pos+=Q+W,V}decodeExtension(W,Q){if(W>this.maxExtLength)throw new d(`Max length exceeded: ext length (${W}) > maxExtLength (${this.maxExtLength})`);const J=this.view.getInt8(this.pos+Q),V=this.decodeBinary(W,Q+1);return this.extensionCodec.decode(V,J,this.context)}lookU8(){return this.view.getUint8(this.pos)}lookU16(){return this.view.getUint16(this.pos)}lookU32(){return this.view.getUint32(this.pos)}readU8(){const W=this.view.getUint8(this.pos);return this.pos++,W}readI8(){const W=this.view.getInt8(this.pos);return this.pos++,W}readU16(){const W=this.view.getUint16(this.pos);return this.pos+=2,W}readI16(){const W=this.view.getInt16(this.pos);return this.pos+=2,W}readU32(){const W=this.view.getUint32(this.pos);return this.pos+=4,W}readI32(){const W=this.view.getInt32(this.pos);return this.pos+=4,W}readU64(){const W=B8(this.view,this.pos);return this.pos+=8,W}readI64(){const W=K1(this.view,this.pos);return this.pos+=8,W}readU64AsBigInt(){const W=this.view.getBigUint64(this.pos);return this.pos+=8,W}readI64AsBigInt(){const W=this.view.getBigInt64(this.pos);return this.pos+=8,W}readF32(){const W=this.view.getFloat32(this.pos);return this.pos+=4,W}readF64(){const W=this.view.getFloat64(this.pos);return this.pos+=8,W}}function c0(W,Q){return new Z1(Q).decode(W)}var y0=function(W){let Q=W.length;while(--Q>=0)W[Q]=0},f1=function(W,Q,J,V,G){this.static_tree=W,this.extra_bits=Q,this.extra_base=J,this.elems=V,this.max_length=G,this.has_stree=W&&W.length},p1=function(W,Q){this.dyn_tree=W,this.max_code=0,this.stat_desc=Q},e=function(W,Q,J,V,G){this.good_length=W,this.max_lazy=Q,this.nice_length=J,this.max_chain=V,this.func=G},L5=function(){this.strm=null,this.status=0,this.pending_buf=null,this.pending_buf_size=0,this.pending_out=0,this.pending=0,this.wrap=0,this.gzhead=null,this.gzindex=0,this.method=x1,this.last_flush=-1,this.w_size=0,this.w_bits=0,this.w_mask=0,this.window=null,this.window_size=0,this.prev=null,this.head=null,this.ins_h=0,this.hash_size=0,this.hash_bits=0,this.hash_mask=0,this.hash_shift=0,this.block_start=0,this.match_length=0,this.prev_match=0,this.match_available=0,this.strstart=0,this.match_start=0,this.lookahead=0,this.prev_length=0,this.max_chain_length=0,this.max_lazy_match=0,this.level=0,this.strategy=0,this.good_match=0,this.nice_match=0,this.dyn_ltree=new Uint16Array(Z5*2),this.dyn_dtree=new Uint16Array((2*F5+1)*2),this.bl_tree=new Uint16Array((2*z5+1)*2),P0(this.dyn_ltree),P0(this.dyn_dtree),P0(this.bl_tree),this.l_desc=null,this.d_desc=null,this.bl_desc=null,this.bl_count=new Uint16Array(H5+1),this.heap=new Uint16Array(2*s1+1),P0(this.heap),this.heap_len=0,this.heap_max=0,this.depth=new Uint16Array(2*s1+1),P0(this.depth),this.sym_buf=0,this.lit_bufsize=0,this.sym_next=0,this.sym_end=0,this.opt_len=0,this.static_len=0,this.matches=0,this.insert=0,this.bi_buf=0,this.bi_valid=0},d5=function(){this.input=null,this.next_in=0,this.avail_in=0,this.total_in=0,this.output=null,this.next_out=0,this.avail_out=0,this.total_out=0,this.msg="",this.state=null,this.data_type=2,this.adler=0},q1=function(W){this.options=I1.assign({level:a5,method:s5,chunkSize:16384,windowBits:15,memLevel:8,strategy:t5},W||{});let Q=this.options;if(Q.raw&&Q.windowBits>0)Q.windowBits=-Q.windowBits;else if(Q.gzip&&Q.windowBits>0&&Q.windowBits<16)Q.windowBits+=16;this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new D6,this.strm.avail_out=0;let J=r0.deflateInit2(this.strm,Q.level,Q.method,Q.windowBits,Q.memLevel,Q.strategy);if(J!==M1)throw new Error(M0[J]);if(Q.header)r0.deflateSetHeader(this.strm,Q.header);if(Q.dictionary){let V;if(typeof Q.dictionary==="string")V=J1.string2buf(Q.dictionary);else if(A6.call(Q.dictionary)==="[object ArrayBuffer]")V=new Uint8Array(Q.dictionary);else V=Q.dictionary;if(J=r0.deflateSetDictionary(this.strm,V),J!==M1)throw new Error(M0[J]);this._dict_set=!0}},P8=function(W,Q){const J=new q1(Q);if(J.push(W,!0),J.err)throw J.msg||M0[J.err];return J.result},e5=function(W,Q){return Q=Q||{},Q.raw=!0,P8(W,Q)},WJ=function(W,Q){return Q=Q||{},Q.gzip=!0,P8(W,Q)},xJ=function(){this.strm=null,this.mode=0,this.last=!1,this.wrap=0,this.havedict=!1,this.flags=0,this.dmax=0,this.check=0,this.total=0,this.head=null,this.wbits=0,this.wsize=0,this.whave=0,this.wnext=0,this.window=null,this.hold=0,this.bits=0,this.length=0,this.offset=0,this.extra=0,this.lencode=null,this.distcode=null,this.lenbits=0,this.distbits=0,this.ncode=0,this.nlen=0,this.ndist=0,this.have=0,this.next=null,this.lens=new Uint16Array(320),this.work=new Uint16Array(288),this.lendyn=null,this.distdyn=null,this.sane=0,this.back=0,this.was=0},uJ=function(){this.text=0,this.time=0,this.xflags=0,this.os=0,this.extra=null,this.extra_len=0,this.name="",this.comment="",this.hcrc=0,this.done=!1},X1=function(W){this.options=I1.assign({chunkSize:65536,windowBits:15,to:""},W||{});const Q=this.options;if(Q.raw&&Q.windowBits>=0&&Q.windowBits<16){if(Q.windowBits=-Q.windowBits,Q.windowBits===0)Q.windowBits=-15}if(Q.windowBits>=0&&Q.windowBits<16&&!(W&&W.windowBits))Q.windowBits+=32;if(Q.windowBits>15&&Q.windowBits<48){if((Q.windowBits&15)===0)Q.windowBits|=15}this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new D6,this.strm.avail_out=0;let J=X0.inflateInit2(this.strm,Q.windowBits);if(J!==Q1)throw new Error(M0[J]);if(this.header=new mJ,X0.inflateGetHeader(this.strm,this.header),Q.dictionary){if(typeof Q.dictionary==="string")Q.dictionary=J1.string2buf(Q.dictionary);else if(u6.call(Q.dictionary)==="[object ArrayBuffer]")Q.dictionary=new Uint8Array(Q.dictionary);if(Q.raw){if(J=X0.inflateSetDictionary(this.strm,Q.dictionary),J!==Q1)throw new Error(M0[J])}}},K8=function(W,Q){const J=new X1(Q);if(J.push(W),J.err)throw J.msg||M0[J.err];return J.result},lJ=function(W,Q){return Q=Q||{},Q.raw=!0,K8(W,Q)};/*! pako 2.1.0 https://github.com/nodeca/pako @license (MIT AND Zlib) */var MW=0,X6=1,LW=2,xW=3,IW=258,G8=29,V1=256,o0=V1+1+G8,v0=30,q8=19,U6=2*o0+1,C0=15,E1=16,OW=7,X8=256,Y6=16,P6=17,K6=18,o1=new Uint8Array([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0]),j1=new Uint8Array([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13]),wW=new Uint8Array([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7]),F6=new Uint8Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),DW=512,q0=new Array((o0+2)*2);y0(q0);var l0=new Array(v0*2);y0(l0);var a0=new Array(DW);y0(a0);var t0=new Array(IW-xW+1);y0(t0);var U8=new Array(G8);y0(U8);var R1=new Array(v0);y0(R1);var z6,Z6,H6,k6=(W)=>{return W<256?a0[W]:a0[256+(W>>>7)]},s0=(W,Q)=>{W.pending_buf[W.pending++]=Q&255,W.pending_buf[W.pending++]=Q>>>8&255},l=(W,Q,J)=>{if(W.bi_valid>E1-J)W.bi_buf|=Q<<W.bi_valid&65535,s0(W,W.bi_buf),W.bi_buf=Q>>E1-W.bi_valid,W.bi_valid+=J-E1;else W.bi_buf|=Q<<W.bi_valid&65535,W.bi_valid+=J},W0=(W,Q,J)=>{l(W,J[Q*2],J[Q*2+1])},$6=(W,Q)=>{let J=0;do J|=W&1,W>>>=1,J<<=1;while(--Q>0);return J>>>1},AW=(W)=>{if(W.bi_valid===16)s0(W,W.bi_buf),W.bi_buf=0,W.bi_valid=0;else if(W.bi_valid>=8)W.pending_buf[W.pending++]=W.bi_buf&255,W.bi_buf>>=8,W.bi_valid-=8},NW=(W,Q)=>{const{dyn_tree:J,max_code:V}=Q,G=Q.stat_desc.static_tree,q=Q.stat_desc.has_stree,Y=Q.stat_desc.extra_bits,U=Q.stat_desc.extra_base,z=Q.stat_desc.max_length;let X,P,$,F,K,H,S=0;for(F=0;F<=C0;F++)W.bl_count[F]=0;J[W.heap[W.heap_max]*2+1]=0;for(X=W.heap_max+1;X<U6;X++){if(P=W.heap[X],F=J[J[P*2+1]*2+1]+1,F>z)F=z,S++;if(J[P*2+1]=F,P>V)continue;if(W.bl_count[F]++,K=0,P>=U)K=Y[P-U];if(H=J[P*2],W.opt_len+=H*(F+K),q)W.static_len+=H*(G[P*2+1]+K)}if(S===0)return;do{F=z-1;while(W.bl_count[F]===0)F--;W.bl_count[F]--,W.bl_count[F+1]+=2,W.bl_count[z]--,S-=2}while(S>0);for(F=z;F!==0;F--){P=W.bl_count[F];while(P!==0){if($=W.heap[--X],$>V)continue;if(J[$*2+1]!==F)W.opt_len+=(F-J[$*2+1])*J[$*2],J[$*2+1]=F;P--}}},B6=(W,Q,J)=>{const V=new Array(C0+1);let G=0,q,Y;for(q=1;q<=C0;q++)G=G+J[q-1]<<1,V[q]=G;for(Y=0;Y<=Q;Y++){let U=W[Y*2+1];if(U===0)continue;W[Y*2]=$6(V[U]++,U)}},SW=()=>{let W,Q,J,V,G;const q=new Array(C0+1);J=0;for(V=0;V<G8-1;V++){U8[V]=J;for(W=0;W<1<<o1[V];W++)t0[J++]=V}t0[J-1]=V,G=0;for(V=0;V<16;V++){R1[V]=G;for(W=0;W<1<<j1[V];W++)a0[G++]=V}G>>=7;for(;V<v0;V++){R1[V]=G<<7;for(W=0;W<1<<j1[V]-7;W++)a0[256+G++]=V}for(Q=0;Q<=C0;Q++)q[Q]=0;W=0;while(W<=143)q0[W*2+1]=8,W++,q[8]++;while(W<=255)q0[W*2+1]=9,W++,q[9]++;while(W<=279)q0[W*2+1]=7,W++,q[7]++;while(W<=287)q0[W*2+1]=8,W++,q[8]++;B6(q0,o0+1,q);for(W=0;W<v0;W++)l0[W*2+1]=5,l0[W*2]=$6(W,5);z6=new f1(q0,o1,V1+1,o0,C0),Z6=new f1(l0,j1,0,v0,C0),H6=new f1(new Array(0),wW,0,q8,OW)},C6=(W)=>{let Q;for(Q=0;Q<o0;Q++)W.dyn_ltree[Q*2]=0;for(Q=0;Q<v0;Q++)W.dyn_dtree[Q*2]=0;for(Q=0;Q<q8;Q++)W.bl_tree[Q*2]=0;W.dyn_ltree[X8*2]=1,W.opt_len=W.static_len=0,W.sym_next=W.matches=0},j6=(W)=>{if(W.bi_valid>8)s0(W,W.bi_buf);else if(W.bi_valid>0)W.pending_buf[W.pending++]=W.bi_buf;W.bi_buf=0,W.bi_valid=0},L8=(W,Q,J,V)=>{const G=Q*2,q=J*2;return W[G]<W[q]||W[G]===W[q]&&V[Q]<=V[J]},h1=(W,Q,J)=>{const V=W.heap[J];let G=J<<1;while(G<=W.heap_len){if(G<W.heap_len&&L8(Q,W.heap[G+1],W.heap[G],W.depth))G++;if(L8(Q,V,W.heap[G],W.depth))break;W.heap[J]=W.heap[G],J=G,G<<=1}W.heap[J]=V},x8=(W,Q,J)=>{let V,G,q=0,Y,U;if(W.sym_next!==0)do if(V=W.pending_buf[W.sym_buf+q++]&255,V+=(W.pending_buf[W.sym_buf+q++]&255)<<8,G=W.pending_buf[W.sym_buf+q++],V===0)W0(W,G,Q);else{if(Y=t0[G],W0(W,Y+V1+1,Q),U=o1[Y],U!==0)G-=U8[Y],l(W,G,U);if(V--,Y=k6(V),W0(W,Y,J),U=j1[Y],U!==0)V-=R1[Y],l(W,V,U)}while(q<W.sym_next);W0(W,X8,Q)},a1=(W,Q)=>{const J=Q.dyn_tree,V=Q.stat_desc.static_tree,G=Q.stat_desc.has_stree,q=Q.stat_desc.elems;let Y,U,z=-1,X;W.heap_len=0,W.heap_max=U6;for(Y=0;Y<q;Y++)if(J[Y*2]!==0)W.heap[++W.heap_len]=z=Y,W.depth[Y]=0;else J[Y*2+1]=0;while(W.heap_len<2)if(X=W.heap[++W.heap_len]=z<2?++z:0,J[X*2]=1,W.depth[X]=0,W.opt_len--,G)W.static_len-=V[X*2+1];Q.max_code=z;for(Y=W.heap_len>>1;Y>=1;Y--)h1(W,J,Y);X=q;do Y=W.heap[1],W.heap[1]=W.heap[W.heap_len--],h1(W,J,1),U=W.heap[1],W.heap[--W.heap_max]=Y,W.heap[--W.heap_max]=U,J[X*2]=J[Y*2]+J[U*2],W.depth[X]=(W.depth[Y]>=W.depth[U]?W.depth[Y]:W.depth[U])+1,J[Y*2+1]=J[U*2+1]=X,W.heap[1]=X++,h1(W,J,1);while(W.heap_len>=2);W.heap[--W.heap_max]=W.heap[1],NW(W,Q),B6(J,z,W.bl_count)},I8=(W,Q,J)=>{let V,G=-1,q,Y=Q[1],U=0,z=7,X=4;if(Y===0)z=138,X=3;Q[(J+1)*2+1]=65535;for(V=0;V<=J;V++){if(q=Y,Y=Q[(V+1)*2+1],++U<z&&q===Y)continue;else if(U<X)W.bl_tree[q*2]+=U;else if(q!==0){if(q!==G)W.bl_tree[q*2]++;W.bl_tree[Y6*2]++}else if(U<=10)W.bl_tree[P6*2]++;else W.bl_tree[K6*2]++;if(U=0,G=q,Y===0)z=138,X=3;else if(q===Y)z=6,X=3;else z=7,X=4}},O8=(W,Q,J)=>{let V,G=-1,q,Y=Q[1],U=0,z=7,X=4;if(Y===0)z=138,X=3;for(V=0;V<=J;V++){if(q=Y,Y=Q[(V+1)*2+1],++U<z&&q===Y)continue;else if(U<X)do W0(W,q,W.bl_tree);while(--U!==0);else if(q!==0){if(q!==G)W0(W,q,W.bl_tree),U--;W0(W,Y6,W.bl_tree),l(W,U-3,2)}else if(U<=10)W0(W,P6,W.bl_tree),l(W,U-3,3);else W0(W,K6,W.bl_tree),l(W,U-11,7);if(U=0,G=q,Y===0)z=138,X=3;else if(q===Y)z=6,X=3;else z=7,X=4}},vW=(W)=>{let Q;I8(W,W.dyn_ltree,W.l_desc.max_code),I8(W,W.dyn_dtree,W.d_desc.max_code),a1(W,W.bl_desc);for(Q=q8-1;Q>=3;Q--)if(W.bl_tree[F6[Q]*2+1]!==0)break;return W.opt_len+=3*(Q+1)+5+5+4,Q},TW=(W,Q,J,V)=>{let G;l(W,Q-257,5),l(W,J-1,5),l(W,V-4,4);for(G=0;G<V;G++)l(W,W.bl_tree[F6[G]*2+1],3);O8(W,W.dyn_ltree,Q-1),O8(W,W.dyn_dtree,J-1)},gW=(W)=>{let Q=4093624447,J;for(J=0;J<=31;J++,Q>>>=1)if(Q&1&&W.dyn_ltree[J*2]!==0)return 0;if(W.dyn_ltree[18]!==0||W.dyn_ltree[20]!==0||W.dyn_ltree[26]!==0)return 1;for(J=32;J<V1;J++)if(W.dyn_ltree[J*2]!==0)return 1;return 0},w8=!1,yW=(W)=>{if(!w8)SW(),w8=!0;W.l_desc=new p1(W.dyn_ltree,z6),W.d_desc=new p1(W.dyn_dtree,Z6),W.bl_desc=new p1(W.bl_tree,H6),W.bi_buf=0,W.bi_valid=0,C6(W)},R6=(W,Q,J,V)=>{if(l(W,(MW<<1)+(V?1:0),3),j6(W),s0(W,J),s0(W,~J),J)W.pending_buf.set(W.window.subarray(Q,Q+J),W.pending);W.pending+=J},EW=(W)=>{l(W,X6<<1,3),W0(W,X8,q0),AW(W)},fW=(W,Q,J,V)=>{let G,q,Y=0;if(W.level>0){if(W.strm.data_type===2)W.strm.data_type=gW(W);if(a1(W,W.l_desc),a1(W,W.d_desc),Y=vW(W),G=W.opt_len+3+7>>>3,q=W.static_len+3+7>>>3,q<=G)G=q}else G=q=J+5;if(J+4<=G&&Q!==-1)R6(W,Q,J,V);else if(W.strategy===4||q===G)l(W,(X6<<1)+(V?1:0),3),x8(W,q0,l0);else l(W,(LW<<1)+(V?1:0),3),TW(W,W.l_desc.max_code+1,W.d_desc.max_code+1,Y+1),x8(W,W.dyn_ltree,W.dyn_dtree);if(C6(W),V)j6(W)},pW=(W,Q,J)=>{if(W.pending_buf[W.sym_buf+W.sym_next++]=Q,W.pending_buf[W.sym_buf+W.sym_next++]=Q>>8,W.pending_buf[W.sym_buf+W.sym_next++]=J,Q===0)W.dyn_ltree[J*2]++;else W.matches++,Q--,W.dyn_ltree[(t0[J]+V1+1)*2]++,W.dyn_dtree[k6(Q)*2]++;return W.sym_next===W.sym_end},hW=yW,bW=R6,uW=fW,mW=pW,cW=EW,_W={_tr_init:hW,_tr_stored_block:bW,_tr_flush_block:uW,_tr_tally:mW,_tr_align:cW},dW=(W,Q,J,V)=>{let G=W&65535|0,q=W>>>16&65535|0,Y=0;while(J!==0){Y=J>2000?2000:J,J-=Y;do G=G+Q[V++]|0,q=q+G|0;while(--Y);G%=65521,q%=65521}return G|q<<16|0},e0=dW,iW=()=>{let W,Q=[];for(var J=0;J<256;J++){W=J;for(var V=0;V<8;V++)W=W&1?3988292384^W>>>1:W>>>1;Q[J]=W}return Q},lW=new Uint32Array(iW()),rW=(W,Q,J,V)=>{const G=lW,q=V+J;W^=-1;for(let Y=V;Y<q;Y++)W=W>>>8^G[(W^Q[Y])&255];return W^-1},m=rW,M0={2:"need dictionary",1:"stream end",0:"","-1":"file error","-2":"stream error","-3":"data error","-4":"insufficient memory","-5":"buffer error","-6":"incompatible version"},I0={Z_NO_FLUSH:0,Z_PARTIAL_FLUSH:1,Z_SYNC_FLUSH:2,Z_FULL_FLUSH:3,Z_FINISH:4,Z_BLOCK:5,Z_TREES:6,Z_OK:0,Z_STREAM_END:1,Z_NEED_DICT:2,Z_ERRNO:-1,Z_STREAM_ERROR:-2,Z_DATA_ERROR:-3,Z_MEM_ERROR:-4,Z_BUF_ERROR:-5,Z_NO_COMPRESSION:0,Z_BEST_SPEED:1,Z_BEST_COMPRESSION:9,Z_DEFAULT_COMPRESSION:-1,Z_FILTERED:1,Z_HUFFMAN_ONLY:2,Z_RLE:3,Z_FIXED:4,Z_DEFAULT_STRATEGY:0,Z_BINARY:0,Z_TEXT:1,Z_UNKNOWN:2,Z_DEFLATED:8},{_tr_init:nW,_tr_stored_block:t1,_tr_flush_block:oW,_tr_tally:F0,_tr_align:aW}=_W,{Z_NO_FLUSH:z0,Z_PARTIAL_FLUSH:tW,Z_FULL_FLUSH:sW,Z_FINISH:a,Z_BLOCK:D8,Z_OK:c,Z_STREAM_END:A8,Z_STREAM_ERROR:J0,Z_DATA_ERROR:eW,Z_BUF_ERROR:b1,Z_DEFAULT_COMPRESSION:W5,Z_FILTERED:J5,Z_HUFFMAN_ONLY:H1,Z_RLE:Q5,Z_FIXED:V5,Z_DEFAULT_STRATEGY:G5,Z_UNKNOWN:q5,Z_DEFLATED:x1}=I0,X5=9,U5=15,Y5=8,P5=29,K5=256,s1=K5+1+P5,F5=30,z5=19,Z5=2*s1+1,H5=15,T=3,K0=258,Q0=K0+T+1,k5=32,T0=42,Y8=57,e1=69,W8=73,J8=91,Q8=103,j0=113,d0=666,i=1,E0=2,L0=3,f0=4,$5=3,R0=(W,Q)=>{return W.msg=M0[Q],Q},N8=(W)=>{return W*2-(W>4?9:0)},P0=(W)=>{let Q=W.length;while(--Q>=0)W[Q]=0},B5=(W)=>{let Q,J,V,G=W.w_size;Q=W.hash_size,V=Q;do J=W.head[--V],W.head[V]=J>=G?J-G:0;while(--Q);Q=G,V=Q;do J=W.prev[--V],W.prev[V]=J>=G?J-G:0;while(--Q)},C5=(W,Q,J)=>(Q<<W.hash_shift^J)&W.hash_mask,Z0=C5,r=(W)=>{const Q=W.state;let J=Q.pending;if(J>W.avail_out)J=W.avail_out;if(J===0)return;if(W.output.set(Q.pending_buf.subarray(Q.pending_out,Q.pending_out+J),W.next_out),W.next_out+=J,Q.pending_out+=J,W.total_out+=J,W.avail_out-=J,Q.pending-=J,Q.pending===0)Q.pending_out=0},n=(W,Q)=>{oW(W,W.block_start>=0?W.block_start:-1,W.strstart-W.block_start,Q),W.block_start=W.strstart,r(W.strm)},y=(W,Q)=>{W.pending_buf[W.pending++]=Q},_0=(W,Q)=>{W.pending_buf[W.pending++]=Q>>>8&255,W.pending_buf[W.pending++]=Q&255},V8=(W,Q,J,V)=>{let G=W.avail_in;if(G>V)G=V;if(G===0)return 0;if(W.avail_in-=G,Q.set(W.input.subarray(W.next_in,W.next_in+G),J),W.state.wrap===1)W.adler=e0(W.adler,Q,G,J);else if(W.state.wrap===2)W.adler=m(W.adler,Q,G,J);return W.next_in+=G,W.total_in+=G,G},M6=(W,Q)=>{let{max_chain_length:J,strstart:V}=W,G,q,Y=W.prev_length,U=W.nice_match;const z=W.strstart>W.w_size-Q0?W.strstart-(W.w_size-Q0):0,X=W.window,P=W.w_mask,$=W.prev,F=W.strstart+K0;let K=X[V+Y-1],H=X[V+Y];if(W.prev_length>=W.good_match)J>>=2;if(U>W.lookahead)U=W.lookahead;do{if(G=Q,X[G+Y]!==H||X[G+Y-1]!==K||X[G]!==X[V]||X[++G]!==X[V+1])continue;V+=2,G++;do;while(X[++V]===X[++G]&&X[++V]===X[++G]&&X[++V]===X[++G]&&X[++V]===X[++G]&&X[++V]===X[++G]&&X[++V]===X[++G]&&X[++V]===X[++G]&&X[++V]===X[++G]&&V<F);if(q=K0-(F-V),V=F-K0,q>Y){if(W.match_start=Q,Y=q,q>=U)break;K=X[V+Y-1],H=X[V+Y]}}while((Q=$[Q&P])>z&&--J!==0);if(Y<=W.lookahead)return Y;return W.lookahead},g0=(W)=>{const Q=W.w_size;let J,V,G;do{if(V=W.window_size-W.lookahead-W.strstart,W.strstart>=Q+(Q-Q0)){if(W.window.set(W.window.subarray(Q,Q+Q-V),0),W.match_start-=Q,W.strstart-=Q,W.block_start-=Q,W.insert>W.strstart)W.insert=W.strstart;B5(W),V+=Q}if(W.strm.avail_in===0)break;if(J=V8(W.strm,W.window,W.strstart+W.lookahead,V),W.lookahead+=J,W.lookahead+W.insert>=T){G=W.strstart-W.insert,W.ins_h=W.window[G],W.ins_h=Z0(W,W.ins_h,W.window[G+1]);while(W.insert)if(W.ins_h=Z0(W,W.ins_h,W.window[G+T-1]),W.prev[G&W.w_mask]=W.head[W.ins_h],W.head[W.ins_h]=G,G++,W.insert--,W.lookahead+W.insert<T)break}}while(W.lookahead<Q0&&W.strm.avail_in!==0)},L6=(W,Q)=>{let J=W.pending_buf_size-5>W.w_size?W.w_size:W.pending_buf_size-5,V,G,q,Y=0,U=W.strm.avail_in;do{if(V=65535,q=W.bi_valid+42>>3,W.strm.avail_out<q)break;if(q=W.strm.avail_out-q,G=W.strstart-W.block_start,V>G+W.strm.avail_in)V=G+W.strm.avail_in;if(V>q)V=q;if(V<J&&(V===0&&Q!==a||Q===z0||V!==G+W.strm.avail_in))break;if(Y=Q===a&&V===G+W.strm.avail_in?1:0,t1(W,0,0,Y),W.pending_buf[W.pending-4]=V,W.pending_buf[W.pending-3]=V>>8,W.pending_buf[W.pending-2]=~V,W.pending_buf[W.pending-1]=~V>>8,r(W.strm),G){if(G>V)G=V;W.strm.output.set(W.window.subarray(W.block_start,W.block_start+G),W.strm.next_out),W.strm.next_out+=G,W.strm.avail_out-=G,W.strm.total_out+=G,W.block_start+=G,V-=G}if(V)V8(W.strm,W.strm.output,W.strm.next_out,V),W.strm.next_out+=V,W.strm.avail_out-=V,W.strm.total_out+=V}while(Y===0);if(U-=W.strm.avail_in,U){if(U>=W.w_size)W.matches=2,W.window.set(W.strm.input.subarray(W.strm.next_in-W.w_size,W.strm.next_in),0),W.strstart=W.w_size,W.insert=W.strstart;else{if(W.window_size-W.strstart<=U){if(W.strstart-=W.w_size,W.window.set(W.window.subarray(W.w_size,W.w_size+W.strstart),0),W.matches<2)W.matches++;if(W.insert>W.strstart)W.insert=W.strstart}W.window.set(W.strm.input.subarray(W.strm.next_in-U,W.strm.next_in),W.strstart),W.strstart+=U,W.insert+=U>W.w_size-W.insert?W.w_size-W.insert:U}W.block_start=W.strstart}if(W.high_water<W.strstart)W.high_water=W.strstart;if(Y)return f0;if(Q!==z0&&Q!==a&&W.strm.avail_in===0&&W.strstart===W.block_start)return E0;if(q=W.window_size-W.strstart,W.strm.avail_in>q&&W.block_start>=W.w_size){if(W.block_start-=W.w_size,W.strstart-=W.w_size,W.window.set(W.window.subarray(W.w_size,W.w_size+W.strstart),0),W.matches<2)W.matches++;if(q+=W.w_size,W.insert>W.strstart)W.insert=W.strstart}if(q>W.strm.avail_in)q=W.strm.avail_in;if(q)V8(W.strm,W.window,W.strstart,q),W.strstart+=q,W.insert+=q>W.w_size-W.insert?W.w_size-W.insert:q;if(W.high_water<W.strstart)W.high_water=W.strstart;if(q=W.bi_valid+42>>3,q=W.pending_buf_size-q>65535?65535:W.pending_buf_size-q,J=q>W.w_size?W.w_size:q,G=W.strstart-W.block_start,G>=J||(G||Q===a)&&Q!==z0&&W.strm.avail_in===0&&G<=q)V=G>q?q:G,Y=Q===a&&W.strm.avail_in===0&&V===G?1:0,t1(W,W.block_start,V,Y),W.block_start+=V,r(W.strm);return Y?L0:i},u1=(W,Q)=>{let J,V;for(;;){if(W.lookahead<Q0){if(g0(W),W.lookahead<Q0&&Q===z0)return i;if(W.lookahead===0)break}if(J=0,W.lookahead>=T)W.ins_h=Z0(W,W.ins_h,W.window[W.strstart+T-1]),J=W.prev[W.strstart&W.w_mask]=W.head[W.ins_h],W.head[W.ins_h]=W.strstart;if(J!==0&&W.strstart-J<=W.w_size-Q0)W.match_length=M6(W,J);if(W.match_length>=T)if(V=F0(W,W.strstart-W.match_start,W.match_length-T),W.lookahead-=W.match_length,W.match_length<=W.max_lazy_match&&W.lookahead>=T){W.match_length--;do W.strstart++,W.ins_h=Z0(W,W.ins_h,W.window[W.strstart+T-1]),J=W.prev[W.strstart&W.w_mask]=W.head[W.ins_h],W.head[W.ins_h]=W.strstart;while(--W.match_length!==0);W.strstart++}else W.strstart+=W.match_length,W.match_length=0,W.ins_h=W.window[W.strstart],W.ins_h=Z0(W,W.ins_h,W.window[W.strstart+1]);else V=F0(W,0,W.window[W.strstart]),W.lookahead--,W.strstart++;if(V){if(n(W,!1),W.strm.avail_out===0)return i}}if(W.insert=W.strstart<T-1?W.strstart:T-1,Q===a){if(n(W,!0),W.strm.avail_out===0)return L0;return f0}if(W.sym_next){if(n(W,!1),W.strm.avail_out===0)return i}return E0},N0=(W,Q)=>{let J,V,G;for(;;){if(W.lookahead<Q0){if(g0(W),W.lookahead<Q0&&Q===z0)return i;if(W.lookahead===0)break}if(J=0,W.lookahead>=T)W.ins_h=Z0(W,W.ins_h,W.window[W.strstart+T-1]),J=W.prev[W.strstart&W.w_mask]=W.head[W.ins_h],W.head[W.ins_h]=W.strstart;if(W.prev_length=W.match_length,W.prev_match=W.match_start,W.match_length=T-1,J!==0&&W.prev_length<W.max_lazy_match&&W.strstart-J<=W.w_size-Q0){if(W.match_length=M6(W,J),W.match_length<=5&&(W.strategy===J5||W.match_length===T&&W.strstart-W.match_start>4096))W.match_length=T-1}if(W.prev_length>=T&&W.match_length<=W.prev_length){G=W.strstart+W.lookahead-T,V=F0(W,W.strstart-1-W.prev_match,W.prev_length-T),W.lookahead-=W.prev_length-1,W.prev_length-=2;do if(++W.strstart<=G)W.ins_h=Z0(W,W.ins_h,W.window[W.strstart+T-1]),J=W.prev[W.strstart&W.w_mask]=W.head[W.ins_h],W.head[W.ins_h]=W.strstart;while(--W.prev_length!==0);if(W.match_available=0,W.match_length=T-1,W.strstart++,V){if(n(W,!1),W.strm.avail_out===0)return i}}else if(W.match_available){if(V=F0(W,0,W.window[W.strstart-1]),V)n(W,!1);if(W.strstart++,W.lookahead--,W.strm.avail_out===0)return i}else W.match_available=1,W.strstart++,W.lookahead--}if(W.match_available)V=F0(W,0,W.window[W.strstart-1]),W.match_available=0;if(W.insert=W.strstart<T-1?W.strstart:T-1,Q===a){if(n(W,!0),W.strm.avail_out===0)return L0;return f0}if(W.sym_next){if(n(W,!1),W.strm.avail_out===0)return i}return E0},j5=(W,Q)=>{let J,V,G,q;const Y=W.window;for(;;){if(W.lookahead<=K0){if(g0(W),W.lookahead<=K0&&Q===z0)return i;if(W.lookahead===0)break}if(W.match_length=0,W.lookahead>=T&&W.strstart>0){if(G=W.strstart-1,V=Y[G],V===Y[++G]&&V===Y[++G]&&V===Y[++G]){q=W.strstart+K0;do;while(V===Y[++G]&&V===Y[++G]&&V===Y[++G]&&V===Y[++G]&&V===Y[++G]&&V===Y[++G]&&V===Y[++G]&&V===Y[++G]&&G<q);if(W.match_length=K0-(q-G),W.match_length>W.lookahead)W.match_length=W.lookahead}}if(W.match_length>=T)J=F0(W,1,W.match_length-T),W.lookahead-=W.match_length,W.strstart+=W.match_length,W.match_length=0;else J=F0(W,0,W.window[W.strstart]),W.lookahead--,W.strstart++;if(J){if(n(W,!1),W.strm.avail_out===0)return i}}if(W.insert=0,Q===a){if(n(W,!0),W.strm.avail_out===0)return L0;return f0}if(W.sym_next){if(n(W,!1),W.strm.avail_out===0)return i}return E0},R5=(W,Q)=>{let J;for(;;){if(W.lookahead===0){if(g0(W),W.lookahead===0){if(Q===z0)return i;break}}if(W.match_length=0,J=F0(W,0,W.window[W.strstart]),W.lookahead--,W.strstart++,J){if(n(W,!1),W.strm.avail_out===0)return i}}if(W.insert=0,Q===a){if(n(W,!0),W.strm.avail_out===0)return L0;return f0}if(W.sym_next){if(n(W,!1),W.strm.avail_out===0)return i}return E0},i0=[new e(0,0,0,0,L6),new e(4,4,8,4,u1),new e(4,5,16,8,u1),new e(4,6,32,32,u1),new e(4,4,16,16,N0),new e(8,16,32,32,N0),new e(8,16,128,128,N0),new e(8,32,128,256,N0),new e(32,128,258,1024,N0),new e(32,258,258,4096,N0)],M5=(W)=>{W.window_size=2*W.w_size,P0(W.head),W.max_lazy_match=i0[W.level].max_lazy,W.good_match=i0[W.level].good_length,W.nice_match=i0[W.level].nice_length,W.max_chain_length=i0[W.level].max_chain,W.strstart=0,W.block_start=0,W.lookahead=0,W.insert=0,W.match_length=W.prev_length=T-1,W.match_available=0,W.ins_h=0},G1=(W)=>{if(!W)return 1;const Q=W.state;if(!Q||Q.strm!==W||Q.status!==T0&&Q.status!==Y8&&Q.status!==e1&&Q.status!==W8&&Q.status!==J8&&Q.status!==Q8&&Q.status!==j0&&Q.status!==d0)return 1;return 0},x6=(W)=>{if(G1(W))return R0(W,J0);W.total_in=W.total_out=0,W.data_type=q5;const Q=W.state;if(Q.pending=0,Q.pending_out=0,Q.wrap<0)Q.wrap=-Q.wrap;return Q.status=Q.wrap===2?Y8:Q.wrap?T0:j0,W.adler=Q.wrap===2?0:1,Q.last_flush=-2,nW(Q),c},I6=(W)=>{const Q=x6(W);if(Q===c)M5(W.state);return Q},x5=(W,Q)=>{if(G1(W)||W.state.wrap!==2)return J0;return W.state.gzhead=Q,c},O6=(W,Q,J,V,G,q)=>{if(!W)return J0;let Y=1;if(Q===W5)Q=6;if(V<0)Y=0,V=-V;else if(V>15)Y=2,V-=16;if(G<1||G>X5||J!==x1||V<8||V>15||Q<0||Q>9||q<0||q>V5||V===8&&Y!==1)return R0(W,J0);if(V===8)V=9;const U=new L5;return W.state=U,U.strm=W,U.status=T0,U.wrap=Y,U.gzhead=null,U.w_bits=V,U.w_size=1<<U.w_bits,U.w_mask=U.w_size-1,U.hash_bits=G+7,U.hash_size=1<<U.hash_bits,U.hash_mask=U.hash_size-1,U.hash_shift=~~((U.hash_bits+T-1)/T),U.window=new Uint8Array(U.w_size*2),U.head=new Uint16Array(U.hash_size),U.prev=new Uint16Array(U.w_size),U.lit_bufsize=1<<G+6,U.pending_buf_size=U.lit_bufsize*4,U.pending_buf=new Uint8Array(U.pending_buf_size),U.sym_buf=U.lit_bufsize,U.sym_end=(U.lit_bufsize-1)*3,U.level=Q,U.strategy=q,U.method=J,I6(W)},I5=(W,Q)=>{return O6(W,Q,x1,U5,Y5,G5)},O5=(W,Q)=>{if(G1(W)||Q>D8||Q<0)return W?R0(W,J0):J0;const J=W.state;if(!W.output||W.avail_in!==0&&!W.input||J.status===d0&&Q!==a)return R0(W,W.avail_out===0?b1:J0);const V=J.last_flush;if(J.last_flush=Q,J.pending!==0){if(r(W),W.avail_out===0)return J.last_flush=-1,c}else if(W.avail_in===0&&N8(Q)<=N8(V)&&Q!==a)return R0(W,b1);if(J.status===d0&&W.avail_in!==0)return R0(W,b1);if(J.status===T0&&J.wrap===0)J.status=j0;if(J.status===T0){let G=x1+(J.w_bits-8<<4)<<8,q=-1;if(J.strategy>=H1||J.level<2)q=0;else if(J.level<6)q=1;else if(J.level===6)q=2;else q=3;if(G|=q<<6,J.strstart!==0)G|=k5;if(G+=31-G%31,_0(J,G),J.strstart!==0)_0(J,W.adler>>>16),_0(J,W.adler&65535);if(W.adler=1,J.status=j0,r(W),J.pending!==0)return J.last_flush=-1,c}if(J.status===Y8)if(W.adler=0,y(J,31),y(J,139),y(J,8),!J.gzhead){if(y(J,0),y(J,0),y(J,0),y(J,0),y(J,0),y(J,J.level===9?2:J.strategy>=H1||J.level<2?4:0),y(J,$5),J.status=j0,r(W),J.pending!==0)return J.last_flush=-1,c}else{if(y(J,(J.gzhead.text?1:0)+(J.gzhead.hcrc?2:0)+(!J.gzhead.extra?0:4)+(!J.gzhead.name?0:8)+(!J.gzhead.comment?0:16)),y(J,J.gzhead.time&255),y(J,J.gzhead.time>>8&255),y(J,J.gzhead.time>>16&255),y(J,J.gzhead.time>>24&255),y(J,J.level===9?2:J.strategy>=H1||J.level<2?4:0),y(J,J.gzhead.os&255),J.gzhead.extra&&J.gzhead.extra.length)y(J,J.gzhead.extra.length&255),y(J,J.gzhead.extra.length>>8&255);if(J.gzhead.hcrc)W.adler=m(W.adler,J.pending_buf,J.pending,0);J.gzindex=0,J.status=e1}if(J.status===e1){if(J.gzhead.extra){let G=J.pending,q=(J.gzhead.extra.length&65535)-J.gzindex;while(J.pending+q>J.pending_buf_size){let U=J.pending_buf_size-J.pending;if(J.pending_buf.set(J.gzhead.extra.subarray(J.gzindex,J.gzindex+U),J.pending),J.pending=J.pending_buf_size,J.gzhead.hcrc&&J.pending>G)W.adler=m(W.adler,J.pending_buf,J.pending-G,G);if(J.gzindex+=U,r(W),J.pending!==0)return J.last_flush=-1,c;G=0,q-=U}let Y=new Uint8Array(J.gzhead.extra);if(J.pending_buf.set(Y.subarray(J.gzindex,J.gzindex+q),J.pending),J.pending+=q,J.gzhead.hcrc&&J.pending>G)W.adler=m(W.adler,J.pending_buf,J.pending-G,G);J.gzindex=0}J.status=W8}if(J.status===W8){if(J.gzhead.name){let G=J.pending,q;do{if(J.pending===J.pending_buf_size){if(J.gzhead.hcrc&&J.pending>G)W.adler=m(W.adler,J.pending_buf,J.pending-G,G);if(r(W),J.pending!==0)return J.last_flush=-1,c;G=0}if(J.gzindex<J.gzhead.name.length)q=J.gzhead.name.charCodeAt(J.gzindex++)&255;else q=0;y(J,q)}while(q!==0);if(J.gzhead.hcrc&&J.pending>G)W.adler=m(W.adler,J.pending_buf,J.pending-G,G);J.gzindex=0}J.status=J8}if(J.status===J8){if(J.gzhead.comment){let G=J.pending,q;do{if(J.pending===J.pending_buf_size){if(J.gzhead.hcrc&&J.pending>G)W.adler=m(W.adler,J.pending_buf,J.pending-G,G);if(r(W),J.pending!==0)return J.last_flush=-1,c;G=0}if(J.gzindex<J.gzhead.comment.length)q=J.gzhead.comment.charCodeAt(J.gzindex++)&255;else q=0;y(J,q)}while(q!==0);if(J.gzhead.hcrc&&J.pending>G)W.adler=m(W.adler,J.pending_buf,J.pending-G,G)}J.status=Q8}if(J.status===Q8){if(J.gzhead.hcrc){if(J.pending+2>J.pending_buf_size){if(r(W),J.pending!==0)return J.last_flush=-1,c}y(J,W.adler&255),y(J,W.adler>>8&255),W.adler=0}if(J.status=j0,r(W),J.pending!==0)return J.last_flush=-1,c}if(W.avail_in!==0||J.lookahead!==0||Q!==z0&&J.status!==d0){let G=J.level===0?L6(J,Q):J.strategy===H1?R5(J,Q):J.strategy===Q5?j5(J,Q):i0[J.level].func(J,Q);if(G===L0||G===f0)J.status=d0;if(G===i||G===L0){if(W.avail_out===0)J.last_flush=-1;return c}if(G===E0){if(Q===tW)aW(J);else if(Q!==D8){if(t1(J,0,0,!1),Q===sW){if(P0(J.head),J.lookahead===0)J.strstart=0,J.block_start=0,J.insert=0}}if(r(W),W.avail_out===0)return J.last_flush=-1,c}}if(Q!==a)return c;if(J.wrap<=0)return A8;if(J.wrap===2)y(J,W.adler&255),y(J,W.adler>>8&255),y(J,W.adler>>16&255),y(J,W.adler>>24&255),y(J,W.total_in&255),y(J,W.total_in>>8&255),y(J,W.total_in>>16&255),y(J,W.total_in>>24&255);else _0(J,W.adler>>>16),_0(J,W.adler&65535);if(r(W),J.wrap>0)J.wrap=-J.wrap;return J.pending!==0?c:A8},w5=(W)=>{if(G1(W))return J0;const Q=W.state.status;return W.state=null,Q===j0?R0(W,eW):c},D5=(W,Q)=>{let J=Q.length;if(G1(W))return J0;const V=W.state,G=V.wrap;if(G===2||G===1&&V.status!==T0||V.lookahead)return J0;if(G===1)W.adler=e0(W.adler,Q,J,0);if(V.wrap=0,J>=V.w_size){if(G===0)P0(V.head),V.strstart=0,V.block_start=0,V.insert=0;let z=new Uint8Array(V.w_size);z.set(Q.subarray(J-V.w_size,J),0),Q=z,J=V.w_size}const{avail_in:q,next_in:Y,input:U}=W;W.avail_in=J,W.next_in=0,W.input=Q,g0(V);while(V.lookahead>=T){let z=V.strstart,X=V.lookahead-(T-1);do V.ins_h=Z0(V,V.ins_h,V.window[z+T-1]),V.prev[z&V.w_mask]=V.head[V.ins_h],V.head[V.ins_h]=z,z++;while(--X);V.strstart=z,V.lookahead=T-1,g0(V)}return V.strstart+=V.lookahead,V.block_start=V.strstart,V.insert=V.lookahead,V.lookahead=0,V.match_length=V.prev_length=T-1,V.match_available=0,W.next_in=Y,W.input=U,W.avail_in=q,V.wrap=G,c},A5=I5,N5=O6,S5=I6,v5=x6,T5=x5,g5=O5,y5=w5,E5=D5,f5="pako deflate (from Nodeca project)",r0={deflateInit:A5,deflateInit2:N5,deflateReset:S5,deflateResetKeep:v5,deflateSetHeader:T5,deflate:g5,deflateEnd:y5,deflateSetDictionary:E5,deflateInfo:f5},p5=(W,Q)=>{return Object.prototype.hasOwnProperty.call(W,Q)},h5=function(W){const Q=Array.prototype.slice.call(arguments,1);while(Q.length){const J=Q.shift();if(!J)continue;if(typeof J!=="object")throw new TypeError(J+"must be non-object");for(let V in J)if(p5(J,V))W[V]=J[V]}return W},b5=(W)=>{let Q=0;for(let V=0,G=W.length;V<G;V++)Q+=W[V].length;const J=new Uint8Array(Q);for(let V=0,G=0,q=W.length;V<q;V++){let Y=W[V];J.set(Y,G),G+=Y.length}return J},I1={assign:h5,flattenChunks:b5},w6=!0;try{String.fromCharCode.apply(null,new Uint8Array(1))}catch(W){w6=!1}var W1=new Uint8Array(256);for(let W=0;W<256;W++)W1[W]=W>=252?6:W>=248?5:W>=240?4:W>=224?3:W>=192?2:1;W1[254]=W1[254]=1;var u5=(W)=>{if(typeof TextEncoder==="function"&&TextEncoder.prototype.encode)return(new TextEncoder()).encode(W);let Q,J,V,G,q,Y=W.length,U=0;for(G=0;G<Y;G++){if(J=W.charCodeAt(G),(J&64512)===55296&&G+1<Y){if(V=W.charCodeAt(G+1),(V&64512)===56320)J=65536+(J-55296<<10)+(V-56320),G++}U+=J<128?1:J<2048?2:J<65536?3:4}Q=new Uint8Array(U);for(q=0,G=0;q<U;G++){if(J=W.charCodeAt(G),(J&64512)===55296&&G+1<Y){if(V=W.charCodeAt(G+1),(V&64512)===56320)J=65536+(J-55296<<10)+(V-56320),G++}if(J<128)Q[q++]=J;else if(J<2048)Q[q++]=192|J>>>6,Q[q++]=128|J&63;else if(J<65536)Q[q++]=224|J>>>12,Q[q++]=128|J>>>6&63,Q[q++]=128|J&63;else Q[q++]=240|J>>>18,Q[q++]=128|J>>>12&63,Q[q++]=128|J>>>6&63,Q[q++]=128|J&63}return Q},m5=(W,Q)=>{if(Q<65534){if(W.subarray&&w6)return String.fromCharCode.apply(null,W.length===Q?W:W.subarray(0,Q))}let J="";for(let V=0;V<Q;V++)J+=String.fromCharCode(W[V]);return J},c5=(W,Q)=>{const J=Q||W.length;if(typeof TextDecoder==="function"&&TextDecoder.prototype.decode)return(new TextDecoder()).decode(W.subarray(0,Q));let V,G;const q=new Array(J*2);for(G=0,V=0;V<J;){let Y=W[V++];if(Y<128){q[G++]=Y;continue}let U=W1[Y];if(U>4){q[G++]=65533,V+=U-1;continue}Y&=U===2?31:U===3?15:7;while(U>1&&V<J)Y=Y<<6|W[V++]&63,U--;if(U>1){q[G++]=65533;continue}if(Y<65536)q[G++]=Y;else Y-=65536,q[G++]=55296|Y>>10&1023,q[G++]=56320|Y&1023}return m5(q,G)},_5=(W,Q)=>{if(Q=Q||W.length,Q>W.length)Q=W.length;let J=Q-1;while(J>=0&&(W[J]&192)===128)J--;if(J<0)return Q;if(J===0)return Q;return J+W1[W[J]]>Q?J:Q},J1={string2buf:u5,buf2string:c5,utf8border:_5},D6=d5,A6=Object.prototype.toString,{Z_NO_FLUSH:i5,Z_SYNC_FLUSH:l5,Z_FULL_FLUSH:r5,Z_FINISH:n5,Z_OK:M1,Z_STREAM_END:o5,Z_DEFAULT_COMPRESSION:a5,Z_DEFAULT_STRATEGY:t5,Z_DEFLATED:s5}=I0;q1.prototype.push=function(W,Q){const J=this.strm,V=this.options.chunkSize;let G,q;if(this.ended)return!1;if(Q===~~Q)q=Q;else q=Q===!0?n5:i5;if(typeof W==="string")J.input=J1.string2buf(W);else if(A6.call(W)==="[object ArrayBuffer]")J.input=new Uint8Array(W);else J.input=W;J.next_in=0,J.avail_in=J.input.length;for(;;){if(J.avail_out===0)J.output=new Uint8Array(V),J.next_out=0,J.avail_out=V;if((q===l5||q===r5)&&J.avail_out<=6){this.onData(J.output.subarray(0,J.next_out)),J.avail_out=0;continue}if(G=r0.deflate(J,q),G===o5){if(J.next_out>0)this.onData(J.output.subarray(0,J.next_out));return G=r0.deflateEnd(this.strm),this.onEnd(G),this.ended=!0,G===M1}if(J.avail_out===0){this.onData(J.output);continue}if(q>0&&J.next_out>0){this.onData(J.output.subarray(0,J.next_out)),J.avail_out=0;continue}if(J.avail_in===0)break}return!0};q1.prototype.onData=function(W){this.chunks.push(W)};q1.prototype.onEnd=function(W){if(W===M1)this.result=I1.flattenChunks(this.chunks);this.chunks=[],this.err=W,this.msg=this.strm.msg};var JJ=q1,QJ=P8,VJ=e5,GJ=WJ,qJ=I0,XJ={Deflate:JJ,deflate:QJ,deflateRaw:VJ,gzip:GJ,constants:qJ},k1=16209,UJ=16191,YJ=function W(Q,J){let V,G,q,Y,U,z,X,P,$,F,K,H,S,x,R,D,w,Z,g,f,C,v,A,L;const N=Q.state;V=Q.next_in,A=Q.input,G=V+(Q.avail_in-5),q=Q.next_out,L=Q.output,Y=q-(J-Q.avail_out),U=q+(Q.avail_out-257),z=N.dmax,X=N.wsize,P=N.whave,$=N.wnext,F=N.window,K=N.hold,H=N.bits,S=N.lencode,x=N.distcode,R=(1<<N.lenbits)-1,D=(1<<N.distbits)-1;W:do{if(H<15)K+=A[V++]<<H,H+=8,K+=A[V++]<<H,H+=8;w=S[K&R];J:for(;;){if(Z=w>>>24,K>>>=Z,H-=Z,Z=w>>>16&255,Z===0)L[q++]=w&65535;else if(Z&16){if(g=w&65535,Z&=15,Z){if(H<Z)K+=A[V++]<<H,H+=8;g+=K&(1<<Z)-1,K>>>=Z,H-=Z}if(H<15)K+=A[V++]<<H,H+=8,K+=A[V++]<<H,H+=8;w=x[K&D];Q:for(;;){if(Z=w>>>24,K>>>=Z,H-=Z,Z=w>>>16&255,Z&16){if(f=w&65535,Z&=15,H<Z){if(K+=A[V++]<<H,H+=8,H<Z)K+=A[V++]<<H,H+=8}if(f+=K&(1<<Z)-1,f>z){Q.msg="invalid distance too far back",N.mode=k1;break W}if(K>>>=Z,H-=Z,Z=q-Y,f>Z){if(Z=f-Z,Z>P){if(N.sane){Q.msg="invalid distance too far back",N.mode=k1;break W}}if(C=0,v=F,$===0){if(C+=X-Z,Z<g){g-=Z;do L[q++]=F[C++];while(--Z);C=q-f,v=L}}else if($<Z){if(C+=X+$-Z,Z-=$,Z<g){g-=Z;do L[q++]=F[C++];while(--Z);if(C=0,$<g){Z=$,g-=Z;do L[q++]=F[C++];while(--Z);C=q-f,v=L}}}else if(C+=$-Z,Z<g){g-=Z;do L[q++]=F[C++];while(--Z);C=q-f,v=L}while(g>2)L[q++]=v[C++],L[q++]=v[C++],L[q++]=v[C++],g-=3;if(g){if(L[q++]=v[C++],g>1)L[q++]=v[C++]}}else{C=q-f;do L[q++]=L[C++],L[q++]=L[C++],L[q++]=L[C++],g-=3;while(g>2);if(g){if(L[q++]=L[C++],g>1)L[q++]=L[C++]}}}else if((Z&64)===0){w=x[(w&65535)+(K&(1<<Z)-1)];continue Q}else{Q.msg="invalid distance code",N.mode=k1;break W}break}}else if((Z&64)===0){w=S[(w&65535)+(K&(1<<Z)-1)];continue J}else if(Z&32){N.mode=UJ;break W}else{Q.msg="invalid literal/length code",N.mode=k1;break W}break}}while(V<G&&q<U);g=H>>3,V-=g,H-=g<<3,K&=(1<<H)-1,Q.next_in=V,Q.next_out=q,Q.avail_in=V<G?5+(G-V):5-(V-G),Q.avail_out=q<U?257+(U-q):257-(q-U),N.hold=K,N.bits=H;return},S0=15,S8=852,v8=592,T8=0,m1=1,g8=2,PJ=new Uint16Array([3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,0,0]),KJ=new Uint8Array([16,16,16,16,16,16,16,16,17,17,17,17,18,18,18,18,19,19,19,19,20,20,20,20,21,21,21,21,16,72,78]),FJ=new Uint16Array([1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,0,0]),zJ=new Uint8Array([16,16,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,64,64]),ZJ=(W,Q,J,V,G,q,Y,U)=>{const z=U.bits;let X=0,P=0,$=0,F=0,K=0,H=0,S=0,x=0,R=0,D=0,w,Z,g,f,C,v=null,A;const L=new Uint16Array(S0+1),N=new Uint16Array(S0+1);let s=null,H0,U0,k0;for(X=0;X<=S0;X++)L[X]=0;for(P=0;P<V;P++)L[Q[J+P]]++;K=z;for(F=S0;F>=1;F--)if(L[F]!==0)break;if(K>F)K=F;if(F===0)return G[q++]=1<<24|64<<16|0,G[q++]=1<<24|64<<16|0,U.bits=1,0;for($=1;$<F;$++)if(L[$]!==0)break;if(K<$)K=$;x=1;for(X=1;X<=S0;X++)if(x<<=1,x-=L[X],x<0)return-1;if(x>0&&(W===T8||F!==1))return-1;N[1]=0;for(X=1;X<S0;X++)N[X+1]=N[X]+L[X];for(P=0;P<V;P++)if(Q[J+P]!==0)Y[N[Q[J+P]]++]=P;if(W===T8)v=s=Y,A=20;else if(W===m1)v=PJ,s=KJ,A=257;else v=FJ,s=zJ,A=0;if(D=0,P=0,X=$,C=q,H=K,S=0,g=-1,R=1<<K,f=R-1,W===m1&&R>S8||W===g8&&R>v8)return 1;for(;;){if(H0=X-S,Y[P]+1<A)U0=0,k0=Y[P];else if(Y[P]>=A)U0=s[Y[P]-A],k0=v[Y[P]-A];else U0=96,k0=0;w=1<<X-S,Z=1<<H,$=Z;do Z-=w,G[C+(D>>S)+Z]=H0<<24|U0<<16|k0|0;while(Z!==0);w=1<<X-1;while(D&w)w>>=1;if(w!==0)D&=w-1,D+=w;else D=0;if(P++,--L[X]===0){if(X===F)break;X=Q[J+Y[P]]}if(X>K&&(D&f)!==g){if(S===0)S=K;C+=$,H=X-S,x=1<<H;while(H+S<F){if(x-=L[H+S],x<=0)break;H++,x<<=1}if(R+=1<<H,W===m1&&R>S8||W===g8&&R>v8)return 1;g=D&f,G[g]=K<<24|H<<16|C-q|0}}if(D!==0)G[C+D]=X-S<<24|64<<16|0;return U.bits=K,0},n0=ZJ,HJ=0,N6=1,S6=2,{Z_FINISH:y8,Z_BLOCK:kJ,Z_TREES:$1,Z_OK:x0,Z_STREAM_END:$J,Z_NEED_DICT:BJ,Z_STREAM_ERROR:t,Z_DATA_ERROR:v6,Z_MEM_ERROR:T6,Z_BUF_ERROR:CJ,Z_DEFLATED:E8}=I0,O1=16180,f8=16181,p8=16182,h8=16183,b8=16184,u8=16185,m8=16186,c8=16187,_8=16188,d8=16189,L1=16190,G0=16191,c1=16192,i8=16193,_1=16194,l8=16195,r8=16196,n8=16197,o8=16198,B1=16199,C1=16200,a8=16201,t8=16202,s8=16203,e8=16204,W6=16205,d1=16206,J6=16207,Q6=16208,h=16209,g6=16210,y6=16211,jJ=852,RJ=592,MJ=15,LJ=MJ,V6=(W)=>{return(W>>>24&255)+(W>>>8&65280)+((W&65280)<<8)+((W&255)<<24)},O0=(W)=>{if(!W)return 1;const Q=W.state;if(!Q||Q.strm!==W||Q.mode<O1||Q.mode>y6)return 1;return 0},E6=(W)=>{if(O0(W))return t;const Q=W.state;if(W.total_in=W.total_out=Q.total=0,W.msg="",Q.wrap)W.adler=Q.wrap&1;return Q.mode=O1,Q.last=0,Q.havedict=0,Q.flags=-1,Q.dmax=32768,Q.head=null,Q.hold=0,Q.bits=0,Q.lencode=Q.lendyn=new Int32Array(jJ),Q.distcode=Q.distdyn=new Int32Array(RJ),Q.sane=1,Q.back=-1,x0},f6=(W)=>{if(O0(W))return t;const Q=W.state;return Q.wsize=0,Q.whave=0,Q.wnext=0,E6(W)},p6=(W,Q)=>{let J;if(O0(W))return t;const V=W.state;if(Q<0)J=0,Q=-Q;else if(J=(Q>>4)+5,Q<48)Q&=15;if(Q&&(Q<8||Q>15))return t;if(V.window!==null&&V.wbits!==Q)V.window=null;return V.wrap=J,V.wbits=Q,f6(W)},h6=(W,Q)=>{if(!W)return t;const J=new xJ;W.state=J,J.strm=W,J.window=null,J.mode=O1;const V=p6(W,Q);if(V!==x0)W.state=null;return V},IJ=(W)=>{return h6(W,LJ)},G6=!0,i1,l1,OJ=(W)=>{if(G6){i1=new Int32Array(512),l1=new Int32Array(32);let Q=0;while(Q<144)W.lens[Q++]=8;while(Q<256)W.lens[Q++]=9;while(Q<280)W.lens[Q++]=7;while(Q<288)W.lens[Q++]=8;n0(N6,W.lens,0,288,i1,0,W.work,{bits:9}),Q=0;while(Q<32)W.lens[Q++]=5;n0(S6,W.lens,0,32,l1,0,W.work,{bits:5}),G6=!1}W.lencode=i1,W.lenbits=9,W.distcode=l1,W.distbits=5},b6=(W,Q,J,V)=>{let G;const q=W.state;if(q.window===null)q.wsize=1<<q.wbits,q.wnext=0,q.whave=0,q.window=new Uint8Array(q.wsize);if(V>=q.wsize)q.window.set(Q.subarray(J-q.wsize,J),0),q.wnext=0,q.whave=q.wsize;else{if(G=q.wsize-q.wnext,G>V)G=V;if(q.window.set(Q.subarray(J-V,J-V+G),q.wnext),V-=G,V)q.window.set(Q.subarray(J-V,J),0),q.wnext=V,q.whave=q.wsize;else{if(q.wnext+=G,q.wnext===q.wsize)q.wnext=0;if(q.whave<q.wsize)q.whave+=G}}return 0},wJ=(W,Q)=>{let J,V,G,q,Y,U,z,X,P,$,F,K,H,S,x=0,R,D,w,Z,g,f,C,v;const A=new Uint8Array(4);let L,N;const s=new Uint8Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]);if(O0(W)||!W.output||!W.input&&W.avail_in!==0)return t;if(J=W.state,J.mode===G0)J.mode=c1;Y=W.next_out,G=W.output,z=W.avail_out,q=W.next_in,V=W.input,U=W.avail_in,X=J.hold,P=J.bits,$=U,F=z,v=x0;W:for(;;)switch(J.mode){case O1:if(J.wrap===0){J.mode=c1;break}while(P<16){if(U===0)break W;U--,X+=V[q++]<<P,P+=8}if(J.wrap&2&&X===35615){if(J.wbits===0)J.wbits=15;J.check=0,A[0]=X&255,A[1]=X>>>8&255,J.check=m(J.check,A,2,0),X=0,P=0,J.mode=f8;break}if(J.head)J.head.done=!1;if(!(J.wrap&1)||(((X&255)<<8)+(X>>8))%31){W.msg="incorrect header check",J.mode=h;break}if((X&15)!==E8){W.msg="unknown compression method",J.mode=h;break}if(X>>>=4,P-=4,C=(X&15)+8,J.wbits===0)J.wbits=C;if(C>15||C>J.wbits){W.msg="invalid window size",J.mode=h;break}J.dmax=1<<J.wbits,J.flags=0,W.adler=J.check=1,J.mode=X&512?d8:G0,X=0,P=0;break;case f8:while(P<16){if(U===0)break W;U--,X+=V[q++]<<P,P+=8}if(J.flags=X,(J.flags&255)!==E8){W.msg="unknown compression method",J.mode=h;break}if(J.flags&57344){W.msg="unknown header flags set",J.mode=h;break}if(J.head)J.head.text=X>>8&1;if(J.flags&512&&J.wrap&4)A[0]=X&255,A[1]=X>>>8&255,J.check=m(J.check,A,2,0);X=0,P=0,J.mode=p8;case p8:while(P<32){if(U===0)break W;U--,X+=V[q++]<<P,P+=8}if(J.head)J.head.time=X;if(J.flags&512&&J.wrap&4)A[0]=X&255,A[1]=X>>>8&255,A[2]=X>>>16&255,A[3]=X>>>24&255,J.check=m(J.check,A,4,0);X=0,P=0,J.mode=h8;case h8:while(P<16){if(U===0)break W;U--,X+=V[q++]<<P,P+=8}if(J.head)J.head.xflags=X&255,J.head.os=X>>8;if(J.flags&512&&J.wrap&4)A[0]=X&255,A[1]=X>>>8&255,J.check=m(J.check,A,2,0);X=0,P=0,J.mode=b8;case b8:if(J.flags&1024){while(P<16){if(U===0)break W;U--,X+=V[q++]<<P,P+=8}if(J.length=X,J.head)J.head.extra_len=X;if(J.flags&512&&J.wrap&4)A[0]=X&255,A[1]=X>>>8&255,J.check=m(J.check,A,2,0);X=0,P=0}else if(J.head)J.head.extra=null;J.mode=u8;case u8:if(J.flags&1024){if(K=J.length,K>U)K=U;if(K){if(J.head){if(C=J.head.extra_len-J.length,!J.head.extra)J.head.extra=new Uint8Array(J.head.extra_len);J.head.extra.set(V.subarray(q,q+K),C)}if(J.flags&512&&J.wrap&4)J.check=m(J.check,V,K,q);U-=K,q+=K,J.length-=K}if(J.length)break W}J.length=0,J.mode=m8;case m8:if(J.flags&2048){if(U===0)break W;K=0;do if(C=V[q+K++],J.head&&C&&J.length<65536)J.head.name+=String.fromCharCode(C);while(C&&K<U);if(J.flags&512&&J.wrap&4)J.check=m(J.check,V,K,q);if(U-=K,q+=K,C)break W}else if(J.head)J.head.name=null;J.length=0,J.mode=c8;case c8:if(J.flags&4096){if(U===0)break W;K=0;do if(C=V[q+K++],J.head&&C&&J.length<65536)J.head.comment+=String.fromCharCode(C);while(C&&K<U);if(J.flags&512&&J.wrap&4)J.check=m(J.check,V,K,q);if(U-=K,q+=K,C)break W}else if(J.head)J.head.comment=null;J.mode=_8;case _8:if(J.flags&512){while(P<16){if(U===0)break W;U--,X+=V[q++]<<P,P+=8}if(J.wrap&4&&X!==(J.check&65535)){W.msg="header crc mismatch",J.mode=h;break}X=0,P=0}if(J.head)J.head.hcrc=J.flags>>9&1,J.head.done=!0;W.adler=J.check=0,J.mode=G0;break;case d8:while(P<32){if(U===0)break W;U--,X+=V[q++]<<P,P+=8}W.adler=J.check=V6(X),X=0,P=0,J.mode=L1;case L1:if(J.havedict===0)return W.next_out=Y,W.avail_out=z,W.next_in=q,W.avail_in=U,J.hold=X,J.bits=P,BJ;W.adler=J.check=1,J.mode=G0;case G0:if(Q===kJ||Q===$1)break W;case c1:if(J.last){X>>>=P&7,P-=P&7,J.mode=d1;break}while(P<3){if(U===0)break W;U--,X+=V[q++]<<P,P+=8}switch(J.last=X&1,X>>>=1,P-=1,X&3){case 0:J.mode=i8;break;case 1:if(OJ(J),J.mode=B1,Q===$1){X>>>=2,P-=2;break W}break;case 2:J.mode=r8;break;case 3:W.msg="invalid block type",J.mode=h}X>>>=2,P-=2;break;case i8:X>>>=P&7,P-=P&7;while(P<32){if(U===0)break W;U--,X+=V[q++]<<P,P+=8}if((X&65535)!==(X>>>16^65535)){W.msg="invalid stored block lengths",J.mode=h;break}if(J.length=X&65535,X=0,P=0,J.mode=_1,Q===$1)break W;case _1:J.mode=l8;case l8:if(K=J.length,K){if(K>U)K=U;if(K>z)K=z;if(K===0)break W;G.set(V.subarray(q,q+K),Y),U-=K,q+=K,z-=K,Y+=K,J.length-=K;break}J.mode=G0;break;case r8:while(P<14){if(U===0)break W;U--,X+=V[q++]<<P,P+=8}if(J.nlen=(X&31)+257,X>>>=5,P-=5,J.ndist=(X&31)+1,X>>>=5,P-=5,J.ncode=(X&15)+4,X>>>=4,P-=4,J.nlen>286||J.ndist>30){W.msg="too many length or distance symbols",J.mode=h;break}J.have=0,J.mode=n8;case n8:while(J.have<J.ncode){while(P<3){if(U===0)break W;U--,X+=V[q++]<<P,P+=8}J.lens[s[J.have++]]=X&7,X>>>=3,P-=3}while(J.have<19)J.lens[s[J.have++]]=0;if(J.lencode=J.lendyn,J.lenbits=7,L={bits:J.lenbits},v=n0(HJ,J.lens,0,19,J.lencode,0,J.work,L),J.lenbits=L.bits,v){W.msg="invalid code lengths set",J.mode=h;break}J.have=0,J.mode=o8;case o8:while(J.have<J.nlen+J.ndist){for(;;){if(x=J.lencode[X&(1<<J.lenbits)-1],R=x>>>24,D=x>>>16&255,w=x&65535,R<=P)break;if(U===0)break W;U--,X+=V[q++]<<P,P+=8}if(w<16)X>>>=R,P-=R,J.lens[J.have++]=w;else{if(w===16){N=R+2;while(P<N){if(U===0)break W;U--,X+=V[q++]<<P,P+=8}if(X>>>=R,P-=R,J.have===0){W.msg="invalid bit length repeat",J.mode=h;break}C=J.lens[J.have-1],K=3+(X&3),X>>>=2,P-=2}else if(w===17){N=R+3;while(P<N){if(U===0)break W;U--,X+=V[q++]<<P,P+=8}X>>>=R,P-=R,C=0,K=3+(X&7),X>>>=3,P-=3}else{N=R+7;while(P<N){if(U===0)break W;U--,X+=V[q++]<<P,P+=8}X>>>=R,P-=R,C=0,K=11+(X&127),X>>>=7,P-=7}if(J.have+K>J.nlen+J.ndist){W.msg="invalid bit length repeat",J.mode=h;break}while(K--)J.lens[J.have++]=C}}if(J.mode===h)break;if(J.lens[256]===0){W.msg="invalid code -- missing end-of-block",J.mode=h;break}if(J.lenbits=9,L={bits:J.lenbits},v=n0(N6,J.lens,0,J.nlen,J.lencode,0,J.work,L),J.lenbits=L.bits,v){W.msg="invalid literal/lengths set",J.mode=h;break}if(J.distbits=6,J.distcode=J.distdyn,L={bits:J.distbits},v=n0(S6,J.lens,J.nlen,J.ndist,J.distcode,0,J.work,L),J.distbits=L.bits,v){W.msg="invalid distances set",J.mode=h;break}if(J.mode=B1,Q===$1)break W;case B1:J.mode=C1;case C1:if(U>=6&&z>=258){if(W.next_out=Y,W.avail_out=z,W.next_in=q,W.avail_in=U,J.hold=X,J.bits=P,YJ(W,F),Y=W.next_out,G=W.output,z=W.avail_out,q=W.next_in,V=W.input,U=W.avail_in,X=J.hold,P=J.bits,J.mode===G0)J.back=-1;break}J.back=0;for(;;){if(x=J.lencode[X&(1<<J.lenbits)-1],R=x>>>24,D=x>>>16&255,w=x&65535,R<=P)break;if(U===0)break W;U--,X+=V[q++]<<P,P+=8}if(D&&(D&240)===0){Z=R,g=D,f=w;for(;;){if(x=J.lencode[f+((X&(1<<Z+g)-1)>>Z)],R=x>>>24,D=x>>>16&255,w=x&65535,Z+R<=P)break;if(U===0)break W;U--,X+=V[q++]<<P,P+=8}X>>>=Z,P-=Z,J.back+=Z}if(X>>>=R,P-=R,J.back+=R,J.length=w,D===0){J.mode=W6;break}if(D&32){J.back=-1,J.mode=G0;break}if(D&64){W.msg="invalid literal/length code",J.mode=h;break}J.extra=D&15,J.mode=a8;case a8:if(J.extra){N=J.extra;while(P<N){if(U===0)break W;U--,X+=V[q++]<<P,P+=8}J.length+=X&(1<<J.extra)-1,X>>>=J.extra,P-=J.extra,J.back+=J.extra}J.was=J.length,J.mode=t8;case t8:for(;;){if(x=J.distcode[X&(1<<J.distbits)-1],R=x>>>24,D=x>>>16&255,w=x&65535,R<=P)break;if(U===0)break W;U--,X+=V[q++]<<P,P+=8}if((D&240)===0){Z=R,g=D,f=w;for(;;){if(x=J.distcode[f+((X&(1<<Z+g)-1)>>Z)],R=x>>>24,D=x>>>16&255,w=x&65535,Z+R<=P)break;if(U===0)break W;U--,X+=V[q++]<<P,P+=8}X>>>=Z,P-=Z,J.back+=Z}if(X>>>=R,P-=R,J.back+=R,D&64){W.msg="invalid distance code",J.mode=h;break}J.offset=w,J.extra=D&15,J.mode=s8;case s8:if(J.extra){N=J.extra;while(P<N){if(U===0)break W;U--,X+=V[q++]<<P,P+=8}J.offset+=X&(1<<J.extra)-1,X>>>=J.extra,P-=J.extra,J.back+=J.extra}if(J.offset>J.dmax){W.msg="invalid distance too far back",J.mode=h;break}J.mode=e8;case e8:if(z===0)break W;if(K=F-z,J.offset>K){if(K=J.offset-K,K>J.whave){if(J.sane){W.msg="invalid distance too far back",J.mode=h;break}}if(K>J.wnext)K-=J.wnext,H=J.wsize-K;else H=J.wnext-K;if(K>J.length)K=J.length;S=J.window}else S=G,H=Y-J.offset,K=J.length;if(K>z)K=z;z-=K,J.length-=K;do G[Y++]=S[H++];while(--K);if(J.length===0)J.mode=C1;break;case W6:if(z===0)break W;G[Y++]=J.length,z--,J.mode=C1;break;case d1:if(J.wrap){while(P<32){if(U===0)break W;U--,X|=V[q++]<<P,P+=8}if(F-=z,W.total_out+=F,J.total+=F,J.wrap&4&&F)W.adler=J.check=J.flags?m(J.check,G,F,Y-F):e0(J.check,G,F,Y-F);if(F=z,J.wrap&4&&(J.flags?X:V6(X))!==J.check){W.msg="incorrect data check",J.mode=h;break}X=0,P=0}J.mode=J6;case J6:if(J.wrap&&J.flags){while(P<32){if(U===0)break W;U--,X+=V[q++]<<P,P+=8}if(J.wrap&4&&X!==(J.total&4294967295)){W.msg="incorrect length check",J.mode=h;break}X=0,P=0}J.mode=Q6;case Q6:v=$J;break W;case h:v=v6;break W;case g6:return T6;case y6:default:return t}if(W.next_out=Y,W.avail_out=z,W.next_in=q,W.avail_in=U,J.hold=X,J.bits=P,J.wsize||F!==W.avail_out&&J.mode<h&&(J.mode<d1||Q!==y8)){if(b6(W,W.output,W.next_out,F-W.avail_out));}if($-=W.avail_in,F-=W.avail_out,W.total_in+=$,W.total_out+=F,J.total+=F,J.wrap&4&&F)W.adler=J.check=J.flags?m(J.check,G,F,W.next_out-F):e0(J.check,G,F,W.next_out-F);if(W.data_type=J.bits+(J.last?64:0)+(J.mode===G0?128:0)+(J.mode===B1||J.mode===_1?256:0),($===0&&F===0||Q===y8)&&v===x0)v=CJ;return v},DJ=(W)=>{if(O0(W))return t;let Q=W.state;if(Q.window)Q.window=null;return W.state=null,x0},AJ=(W,Q)=>{if(O0(W))return t;const J=W.state;if((J.wrap&2)===0)return t;return J.head=Q,Q.done=!1,x0},NJ=(W,Q)=>{const J=Q.length;let V,G,q;if(O0(W))return t;if(V=W.state,V.wrap!==0&&V.mode!==L1)return t;if(V.mode===L1){if(G=1,G=e0(G,Q,J,0),G!==V.check)return v6}if(q=b6(W,Q,J,J),q)return V.mode=g6,T6;return V.havedict=1,x0},SJ=f6,vJ=p6,TJ=E6,gJ=IJ,yJ=h6,EJ=wJ,fJ=DJ,pJ=AJ,hJ=NJ,bJ="pako inflate (from Nodeca project)",X0={inflateReset:SJ,inflateReset2:vJ,inflateResetKeep:TJ,inflateInit:gJ,inflateInit2:yJ,inflate:EJ,inflateEnd:fJ,inflateGetHeader:pJ,inflateSetDictionary:hJ,inflateInfo:bJ},mJ=uJ,u6=Object.prototype.toString,{Z_NO_FLUSH:cJ,Z_FINISH:_J,Z_OK:Q1,Z_STREAM_END:r1,Z_NEED_DICT:n1,Z_STREAM_ERROR:dJ,Z_DATA_ERROR:q6,Z_MEM_ERROR:iJ}=I0;X1.prototype.push=function(W,Q){const J=this.strm,V=this.options.chunkSize,G=this.options.dictionary;let q,Y,U;if(this.ended)return!1;if(Q===~~Q)Y=Q;else Y=Q===!0?_J:cJ;if(u6.call(W)==="[object ArrayBuffer]")J.input=new Uint8Array(W);else J.input=W;J.next_in=0,J.avail_in=J.input.length;for(;;){if(J.avail_out===0)J.output=new Uint8Array(V),J.next_out=0,J.avail_out=V;if(q=X0.inflate(J,Y),q===n1&&G){if(q=X0.inflateSetDictionary(J,G),q===Q1)q=X0.inflate(J,Y);else if(q===q6)q=n1}while(J.avail_in>0&&q===r1&&J.state.wrap>0&&W[J.next_in]!==0)X0.inflateReset(J),q=X0.inflate(J,Y);switch(q){case dJ:case q6:case n1:case iJ:return this.onEnd(q),this.ended=!0,!1}if(U=J.avail_out,J.next_out){if(J.avail_out===0||q===r1)if(this.options.to==="string"){let z=J1.utf8border(J.output,J.next_out),X=J.next_out-z,P=J1.buf2string(J.output,z);if(J.next_out=X,J.avail_out=V-X,X)J.output.set(J.output.subarray(z,z+X),0);this.onData(P)}else this.onData(J.output.length===J.next_out?J.output:J.output.subarray(0,J.next_out))}if(q===Q1&&U===0)continue;if(q===r1)return q=X0.inflateEnd(this.strm),this.onEnd(q),this.ended=!0,!0;if(J.avail_in===0)break}return!0};X1.prototype.onData=function(W){this.chunks.push(W)};X1.prototype.onEnd=function(W){if(W===Q1)if(this.options.to==="string")this.result=this.chunks.join("");else this.result=I1.flattenChunks(this.chunks);this.chunks=[],this.err=W,this.msg=this.strm.msg};var rJ=X1,nJ=K8,oJ=lJ,aJ=K8,tJ=I0,sJ={Inflate:rJ,inflate:nJ,inflateRaw:oJ,ungzip:aJ,constants:tJ},{Deflate:eJ,deflate:W7,deflateRaw:J7,gzip:Q7}=XJ,{Inflate:V7,inflate:G7,inflateRaw:q7,ungzip:X7}=sJ,U7=eJ,Y7=W7,P7=J7,K7=Q7,F7=V7,z7=G7,Z7=q7,H7=X7,k7=I0,p0={Deflate:U7,deflate:Y7,deflateRaw:P7,gzip:K7,Inflate:F7,inflate:z7,inflateRaw:Z7,ungzip:H7,constants:k7};function m6(W,Q,J){let V=Q.timestamp;if(V?.physical>Date.now()+7200000)V={physical:Date.now()+7200000,logical:V.logical};if(!W?.timestamp)return{resolved:!0,value:Q.value,timestamp:V};if(J.compare(V,W.timestamp)<=0)return{resolved:!1};return{resolved:!0,value:Q.value,timestamp:V}}function c6(W,Q=50){const J=`gdb_oplog_${W}`;let V=[];function G(){try{const Y=localStorage.getItem(J);V=Y?JSON.parse(Y):[]}catch(Y){console.error("\u274C GDB: Failed to load oplog from localStorage:",Y),V=[]}}function q(){try{localStorage.setItem(J,JSON.stringify(V))}catch(Y){console.error("\u274C GDB: Failed to save oplog to localStorage:",Y)}}return G(),{remove(Y){V=V.filter((U)=>U.id!==Y),q()},add(Y){if(V.push(Y),V.length>Q)V.shift();q()},getDelta(Y,U){if(!Y)return[...V];return V.filter((z)=>U(z.timestamp,Y)>0)},getOldest(){return V[0]},clear(){V=[],localStorage.removeItem(J)}}}var $7=()=>{const W=new Map,Q=async()=>{try{const z=await navigator.storage.getDirectory(),P=await(await z.getFileHandle("~opfs-sync-test",{create:!0})).createSyncAccessHandle?.();return await P?.close(),await z.removeEntry("~opfs-sync-test"),!!P}catch{return!1}};let J="idb";const V=(async()=>{if(await Q())J="sync";else try{const z=await navigator.storage.getDirectory(),P=await(await z.getFileHandle("~opfs-async-test",{create:!0})).createWritable?.();if(await P?.close(),await z.removeEntry("~opfs-async-test"),P)J="async";else J="idb"}catch{J="idb"}})(),G=async(z,X)=>{if(!W.has(z))W.set(z,[]);const P=W.get(z),$=P[P.length-1]||Promise.resolve();let F;const K=new Promise((H)=>F=H);P.push(K);try{return await $,await X()}finally{if(P.shift(),F(),P.length===0)W.delete(z)}},q=(()=>{let z;const X=async()=>{if(!z)z=new Promise((P,$)=>{const F=indexedDB.open("opfs-fallback-db",1);F.onupgradeneeded=()=>F.result.createObjectStore("files"),F.onsuccess=()=>P(F.result),F.onerror=()=>$(F.error)});return z};return{getDB:X,get:async(P)=>{const $=await X();return new Promise((F,K)=>{const S=$.transaction("files","readonly").objectStore("files").get(P);S.onsuccess=()=>F(S.result||new Uint8Array),S.onerror=()=>K(S.error)})},set:async(P,$)=>{const F=await X();return new Promise((K,H)=>{const x=F.transaction("files","readwrite").objectStore("files").put($,P);x.onsuccess=()=>K(),x.onerror=()=>H(x.error)})}}})(),Y=async(z)=>{await V;try{if(J==="idb"){const K=await q.get(z);return{type:"loaded",name:z,data:K}}const P=await(await navigator.storage.getDirectory()).getFileHandle(z);if(J==="sync"){let K;try{K=await P.createSyncAccessHandle();const H=K.getSize(),S=new Uint8Array(H),x=K.read(S,{at:0});return{type:"loaded",name:z,data:S.slice(0,x)}}finally{K?.close()}}const $=await P.getFile(),F=new Uint8Array(await $.arrayBuffer());return{type:"loaded",name:z,data:F}}catch(X){if(X.name==="NotFoundError")return{type:"loaded",name:z,data:new Uint8Array};return console.error(`\u274C Worker file load error for '${z}':`,X),{type:"error",name:z,message:X.message||"Error reading file"}}},U=async(z,X)=>{if(await V,!(X instanceof Uint8Array))return{type:"error",name:z,message:"Content must be a Uint8Array"};return G(z,async()=>{try{if(J==="idb")return await q.set(z,X),{type:"saved",name:z};const $=await(await navigator.storage.getDirectory()).getFileHandle(z,{create:!0});if(J==="sync"){let F;try{F=await $.createSyncAccessHandle(),F.truncate(0),F.write(X,{at:0}),F.flush()}finally{F?.close()}}else{let F;try{F=await $.createWritable(),await F.write(X)}finally{await F?.close()}}return{type:"saved",name:z}}catch(P){return{type:"error",name:z,message:P.message||"Error saving file"}}})};self.onmessage=async({data:z})=>{const{type:X,name:P,content:$}=z;await V;const F={load:()=>Y(P),save:()=>U(P,$)};try{const K=F[X],H=K?await K():{type:"error",message:`Unrecognized action type: ${X}`};self.postMessage(H)}catch(K){console.error("\u274C Worker unexpected error:",K),self.postMessage({type:"error",name:P,message:K.message||"Unexpected worker error"})}}},_6=$7;var U1={$eq:(W,Q)=>W===Q,$ne:(W,Q)=>W!==Q,$gt:(W,Q)=>W>Q,$gte:(W,Q)=>W>=Q,$lt:(W,Q)=>W<Q,$lte:(W,Q)=>W<=Q,$in:(W,Q)=>Array.isArray(Q)&&(Array.isArray(W)?W.some((J)=>Q.includes(J)):Q.includes(W)),$between:(W,[Q,J])=>W>=Q&&W<=J,$exists:(W,Q)=>Q?W!==void 0:W===void 0,$startsWith:(W,Q)=>typeof W==="string"&&W.startsWith(Q),$endsWith:(W,Q)=>typeof W==="string"&&W.endsWith(Q),$contains:(W,Q)=>typeof W==="string"&&W.includes(Q),$text:{global:(W,Q)=>{const J=(G)=>String(G).normalize("NFD").replace(/[\u0300-\u036f]/g,"").toLowerCase().replace(/[^\w\s]/g,""),V=J(Q);return Object.values(W).some((G)=>typeof G==="object"?null.fieldSearch(G,V):J(G).includes(V))},field:(W,Q)=>{const J=(G)=>String(G).normalize("NFD").replace(/[\u0300-\u036f]/g,"").toLowerCase().replace(/[^\w\s]/g,""),V=J(Q);return Array.isArray(W)?W.some((G)=>J(G).includes(V)):J(W).includes(V)}},$like:(W,Q)=>typeof W==="string"&&typeof Q==="string"&&new RegExp(`^${Q.replace(/%/g,".*").replace(/_/g,".")}\$`,"i").test(W),$regex:(W,Q)=>typeof W==="string"&&new RegExp(Q.$regex||Q,"i").test(W),$and:(W,Q,J)=>Q.every((V)=>J.createFilter(V,J.allNodes)(W)),$or:(W,Q,J)=>Q.some((V)=>J.createFilter(V,J.allNodes)(W)),$not:(W,Q,J)=>!J.createFilter(Q,J.allNodes)(W),$edge:(W,Q,J)=>{if(!W.edges?.length||typeof Q!=="object"||Q===null)return!1;const V=J.createFilter(Q,J.allNodes),G=[...W.edges],q=new Set(G).add(W.id),Y=[];while(G.length){const U=G.shift(),z=J.allNodes[U];if(!z)continue;if(V(z))Y.push(z);z.edges?.forEach((X)=>!q.has(X)&&q.add(X)&&G.push(X))}if(Y.length)W._edgeResult=Y;return Y.length>0}},w1=(W,Q)=>Q.split(".").reduce((J,V)=>J&&typeof J==="object"&&(V in J)?J[V]:void 0,W),D1=(W,Q)=>{if(Object.keys(W).length===0)return()=>!0;return(J)=>Object.entries(W).every(([V,G])=>{if(V.startsWith("$"))return U1[V](J,G,{createFilter:D1,allNodes:Q});let q=w1(J.value,V);if(q===void 0)q=w1(J,V);if(typeof G!=="object"||G===null)return U1.$eq(q,G);return Object.entries(G).every(([Y,U])=>{if(Y==="$text")return U1.$text.field(q,U);if(Y==="$between"&&U.every((z)=>z instanceof Date))return U1.$between(new Date(q),U);return U1[Y]?.(q,U,{createFilter:D1,allNodes:Q})??!1})})},F8=(W,Q)=>{const{$edge:J,...V}=Q.query||{},G=D1(V,W),q=Object.values(W).filter(G);let U=[...J?(()=>{const z=D1({$edge:J},W);q.forEach((P)=>z(P));const X=new Map;return q.forEach((P)=>{if(P._edgeResult)P._edgeResult.forEach(($)=>X.set($.id,$)),delete P._edgeResult}),Array.from(X.values())})():q];if(Q.field){const z=Q.order==="asc"?1:-1;U.sort((X,P)=>{const $=w1(X.value,Q.field),F=w1(P.value,Q.field);if(typeof $==="string"&&typeof F==="string")return $.localeCompare(F)*z;return(($??0)-(F??0))*z})}if(Q.$after){const z=U.findIndex((X)=>X.id===Q.$after);U=z>=0?U.slice(z+1):[]}if(Q.$before){const z=U.findIndex((X)=>X.id===Q.$before);U=z>=0?U.slice(0,z):[]}if(Q.$limit)U=U.slice(0,Q.$limit);return U};function d6(){let W=Date.now(),Q=0;return{now(){const J=Date.now();return W=Math.max(W,J),Q++,{physical:W,logical:Q}},update(J){if(!J||typeof J.physical!=="number"||typeof J.logical!=="number"){console.warn("\u26A0\uFE0F HybridClock.update received an invalid remote timestamp.",J);return}W=Math.max(W,J.physical),Q=Math.max(Q,J.logical)+1},compare(J,V){if(!J&&!V)return 0;if(!J)return-1;if(!V)return 1;if(J.physical>V.physical)return 1;if(J.physical<V.physical)return-1;if(J.logical>V.logical)return 1;if(J.logical<V.logical)return-1;return 0}}}var i6=function(W,Q){return W.length===Q.length&&W.every((J,V)=>J===Q[V])};async function C7(){if(console.info(navigator?.storage?.getDirectory?"\u2705 OPFS is enabled.":"\uD83D\uDEAB OPFS is not available."),navigator?.storage?.getDirectory)await navigator.storage.getDirectory()}var j7=function(){const W={nodes:{}};return{get nodes(){return W.nodes},set nodes(J){W.nodes=J||{}},upsert(J,V,G){const q=W.nodes[J];W.nodes[J]={id:J,value:V&&typeof V==="object"?r6(V):V,edges:q?.edges?[...q.edges]:[],timestamp:G}},get(J){return W.nodes[J]||null},link(J,V,G){const q=W.nodes[J],Y=W.nodes[V];if(q&&Y&&!q.edges.includes(V))W.nodes[J]={...q,edges:[...q.edges,V],timestamp:G}},getAllNodes(){return Object.values(W.nodes)},serialize(){return p0.deflate(b0(W.nodes))},deserialize(J){W.nodes=c0(p0.inflate(new Uint8Array(J)))}}};async function HQ(W,Q={}){console.info("\x1B[36m\u26A1 GenosDB: Empowering distributed graph databases with real-time synchronization and scalability. Learn more: https://github.com/estebanrfp/gdb \u26A1\x1B[0m");const{rtc:J=!1,password:V,sm:G=!1,audit:q=!1,ii:Y=!1,rx:U=!1,ai:z=!1,geo:X=!1,saveDelay:P=200,oplogSize:$=20}=Q,F=j7(),K=d6(),H=c6(W,$),S=[];let x=null,R=[],D=null,w=null,Z=null,g=null;const f=[],C={};Object.defineProperties(C,{syncChannel:{get:()=>w},broadcastChannel:{get:()=>Z},hybridClock:{get:()=>K},graph:{get:()=>({getAllNodes:()=>F.getAllNodes(),get:(k)=>F.get(k)})},worker:{get:()=>D},oplog:{get:()=>H},options:{get:()=>Q},pako:{get:()=>p0},encode:{get:()=>b0},decode:{get:()=>c0},deepClone:{get:()=>r6}});async function v(k,I){try{const j=await import(new URL(`./${k}.min.js`,import.meta.url).href),E=I&&typeof I==="object"?I:{},B=j.init?.(C,j,E);if(B)Object.assign(C,B);return j}catch(j){throw console.error(`\u274C Initialization of ${k} failed:`,j),j}}function A(){const k=localStorage.getItem(`${W}_time`);x=k?JSON.parse(k):null}function L(k){x=k,localStorage.setItem(`${W}_time`,JSON.stringify(k))}function N(){try{const k=URL.createObjectURL(new Blob([`(${_6.toString()})()`],{type:"application/javascript"}));D=new Worker(k),URL.revokeObjectURL(k),D.addEventListener("message",({data:I})=>{console.info(`\uD83D\uDCBE ${I.name} ${I.type}`)}),console.info("\u2699\uFE0F Worker initialized successfully.")}catch({message:k}){console.error("\u274C Failed to initialize worker:",k)}}function s(){const k={...F.nodes};R.forEach((I)=>I(k))}const H0=B7(()=>s()),U0=l6(async()=>{const k=f.splice(0,f.length);if(!k.length)return!1;return await w.send(k),!0},16);async function k0(){try{const I=await((j)=>new Promise((E,B)=>{const O=async({data:M})=>{if(M.type==="loaded"&&M.name===j)D.removeEventListener("message",O),E(new Uint8Array(M.data));else if(M.type==="error")D.removeEventListener("message",O),B(new Error(M.message||"Unknown error"))};D.addEventListener("message",O),D.postMessage({type:"load",name:j})}))(`${W}_graph.msgpack`).catch(()=>new Uint8Array);I.byteLength>0?F.deserialize(I):console.info("\u2139\uFE0F New database. File will be created on first save."),console.info(`\u2705 Graph loaded: [ ${F.getAllNodes().length} nodes ]`)}catch({message:k}){console.error("\u274C Error loading the graph:",k)}}async function A1(){try{const k=F.serialize();return await((j,E)=>new Promise((B,O)=>{const M=({data:p})=>{if(p.type==="saved"&&p.name===j)D.removeEventListener("message",M),B();else if(p.type==="error")D.removeEventListener("message",M),O(new Error(p.message||"Save error"))};D.addEventListener("message",M),D.postMessage({type:"save",name:j,content:E})}))(`${W}_graph.msgpack`,k),Z.postMessage("update"),!0}catch({message:k}){throw console.error("\u274C Save error:",k),new Error("Save failed")}}const N1=l6(()=>A1(),P);async function n6(k){try{console.info("\uD83D\uDD04 Applying full graph from remote..."),F.nodes={...k.nodes},await A1()}catch({message:I}){console.error(`\u274C Error applying the full graph: ${I}`)}}async function o6(k){let I=!1,j=null;const E={upsert:(B)=>{const O=F.get(B.id),M=m6(O,B,K);if(M.resolved){if(F.upsert(B.id,M.value,M.timestamp),K.update(M.timestamp),H.add({type:"upsert",id:B.id,timestamp:M.timestamp}),I=!0,!j||K.compare(M.timestamp,j)>0)j=M.timestamp}},remove:(B)=>{const O=F.get(B.id);if(O&&K.compare(O.timestamp,B.timestamp)<0){if(delete F.nodes[B.id],K.update(B.timestamp),H.add({type:"remove",id:B.id,timestamp:B.timestamp}),I=!0,!j||K.compare(B.timestamp,j)>0)j=B.timestamp}},link:(B)=>{const O=F.get(B.sourceId),M=F.get(B.targetId);if(O&&M&&K.compare(O.timestamp,B.timestamp)<0){if(F.link(B.sourceId,B.targetId,B.timestamp),K.update(B.timestamp),H.add({type:"link",sourceId:B.sourceId,targetId:B.targetId,timestamp:B.timestamp}),I=!0,!j||K.compare(B.timestamp,j)>0)j=B.timestamp}},sync:async(B)=>{const O=B.timestamp;if(O===null){console.info("\uD83D\uDCEC [SYNC REQUEST] from new peer (no timestamp). Sending full graph."),await w.send([{type:"syncReceive",graph:F}]);return}console.info("\uD83D\uDCEC [SYNC REQUEST] since:",new Date(O.physical).toLocaleString());const M=H.getOldest();if(M&&K.compare(O,M.timestamp)<0){console.info("\uD83D\uDCA5 [FALLBACK TRIGGERED] Peer is too far behind. Sending FULL graph state."),await w.send([{type:"syncReceive",graph:F}]);return}const p=H.getDelta(O,K.compare);if(p.length>0){const b=p.map((_)=>{if(_.type==="upsert"){const V0=F.get(_.id);return{..._,value:V0?V0.value:null}}return _}),o=p0.deflate(b0(b));console.info(`\uD83D\uDE80 [DELTA SYNC SENDING] Found ${p.length} new operations to send.`),await w.send([{type:"deltaSync",operations:o}])}else console.info("\u2705 [ALREADY SYNCED] Peer is up-to-date. Nothing to send.")},deltaSync:(B)=>{const O=c0(p0.inflate(B.operations));console.info(`\uD83D\uDEF0\uFE0F [DELTA SYNC RECEIVED] Applying ${O.length} operations from a peer.`);for(let M of O)E[M.type]?.(M)},syncReceive:async(B)=>{if(console.info("\uD83D\uDCE6 [FULL SYNC RECEIVED] Overwriting local state with full graph from a peer."),B.graph&&B.graph.nodes){await n6(B.graph),H.clear(),console.info("\uD83D\uDD12 Oplog has been cleared due to full sync."),I=!0;let O=null;for(let M in B.graph.nodes){const p=B.graph.nodes[M];if(p.timestamp&&(!O||K.compare(p.timestamp,O)>0))O=p.timestamp}if(O)console.info("\uD83D\uDCC8 [GLOBAL TIMESTAMP] Updated from full sync."),j=O,K.update(O)}else console.error("\u274C Full sync failed: received graph data is invalid.",B.graph)}};for(let B of k)if(E[B.type])await E[B.type](B);else console.warn(`\uD83E\uDD37\u200D\u2640\uFE0F [UNKNOWN MESSAGE TYPE] Received unhandled message type: "${B.type}"`);if(j){if(!x||K.compare(j,x)>0)console.info(`\uD83D\uDCC8 [GLOBAL TIMESTAMP] Advanced from ${x?.logical} to ${j.logical}.`),L(j)}if(I)console.info("\uD83D\uDCBE [STATE CHANGED] Saving state and emitting update."),await A1(),s()}Object.assign(C,{use(k){if(typeof k==="function")S.push(k)},async put(k,I){const j=K.now();L(j),I??=crypto.randomUUID(),F.upsert(I,k,j),H.add({type:"upsert",id:I,timestamp:j}),N1();try{f.push({type:"upsert",id:I,value:k,timestamp:j}),U0().catch(()=>{})}finally{H0()}return I},async link(k,I){const j=K.now();if(!F.nodes[k]||!F.nodes[I]){console.warn(`\u26A0\uFE0F One or both nodes (${k}, ${I}) do not exist.`);return}F.link(k,I,j),H.add({type:"link",sourceId:k,targetId:I,timestamp:j}),N1(),L(j);try{f.push({type:"link",sourceId:k,targetId:I,timestamp:j}),U0().catch(()=>{})}finally{H0()}},async remove(k){const I=K.now(),j=F.get(k);if(!j)return console.warn(`\u26A0\uFE0F Node with ID '${k}' not found.`);delete F.nodes[k],H.add({type:"remove",id:k,timestamp:I}),Object.values(F.nodes).forEach((E)=>E.edges=E.edges.filter((B)=>B!==k)),N1(),L(I);try{f.push({type:"remove",id:k,value:j.value,timestamp:I}),U0().catch(()=>{})}finally{H0()}},async get(k,I=null){if(typeof k!=="string")return{result:null};const j=F.get(k);if(!j){if(I)I(null);return{result:null}}const E=(M)=>{if(!M)return null;const p=M.value!==null&&typeof M.value==="object"?{...M.value}:M.value;return{...M,value:p}};if(!I)return{result:E(j)};let B=j.timestamp;I(E(j));const O=(M)=>{const p=M[k];if(p){if(K.compare(p.timestamp,B)>0)B=p.timestamp,I(E(p))}else I(null),R.splice(R.indexOf(O),1)};return R.push(O),{result:E(j),unsubscribe:()=>{const M=R.indexOf(O);if(M>-1)R.splice(M,1)}}},async map(...k){let j={...{realtime:!1,query:{},field:null,order:"asc",$limit:null,$after:null,$before:null}},E=null,B=!1;k.forEach((b)=>typeof b==="function"?E=b:b&&typeof b==="object"&&(B||=("realtime"in b),Object.assign(j,b))),E&&!B&&(j.realtime=!0);let O=F8(F.nodes,j),M=null;const p=(b)=>{const o=new Map(O.map((u)=>[u.id,u])),_=new Map(b.map((u)=>[u.id,u])),V0=[],w0=[],z8=[];for(let[u,Y0]of _){const Y1=o.get(u);if(!Y1)V0.push(Y0);else if((Y0.timestamp?.physical||0)!==(Y1.timestamp?.physical||0)||(Y0.timestamp?.logical||0)!==(Y1.timestamp?.logical||0)||!i6(Y0.edges||[],Y1.edges||[]))w0.push(Y0)}for(let[u]of o)if(!_.has(u))z8.push(o.get(u));const S1=(u,Y0)=>E({id:u.id,value:Y0==="removed"?null:u.value,edges:u.edges||[],timestamp:u.timestamp||null,action:Y0});V0.forEach((u)=>S1(u,"added")),z8.forEach((u)=>S1(u,"removed")),w0.forEach((u)=>S1(u,"updated"))};if(E){if(O.forEach((b)=>{E({id:b.id,value:b.value,edges:b.edges,timestamp:b.timestamp,action:"initial"})}),j.realtime){const b=(o)=>{const _=o.timestamp?.physical||0,V0=o.timestamp?.logical||0,w0=(o.edges||[]).join(",");return`${o.id}:${_}:${V0}:${w0}`};M=(o)=>{const _=F8(o,j);if(_.length!==O.length)p(_),O=_;else{const V0=_.map(b),w0=O.map(b);if(!i6(V0,w0))p(_),O=_}},R.push(M)}}return{results:O,...j.realtime&&E&&M&&{unsubscribe:()=>{const b=R.indexOf(M);b>-1&&R.splice(b,1)}}}},async clear(){F.nodes={};try{await(await navigator.storage.getDirectory()).removeEntry(`${W}_graph.msgpack`)}catch({message:k}){console.warn(`\u26A0\uFE0F Error deleting _graph.msgpack: ${k}`)}s(),console.info("\u2705 All data has been deleted.")}}),N(),A(),await C7(),await k0();const $0=[];if(G)$0.push(v("sm",G));if(z)$0.push(v("AIQuery",z));if(U)$0.push(v("radixindex",U));if(Y)$0.push(v("invertedindex",Y));if(q)$0.push(v("audit",q));if(X)$0.push(v("geo",X));await Promise.all($0);const a6=`graph-sync-room-${W}`;if(J){const{join:k}=await v("genosrtc"),{relayUrls:I,turnConfig:j}=J?.constructor===Object?J:{},E={appId:"1234",...V&&{password:V}};if(I)E.relayUrls=I;if(j)E.turnConfig=j;const B=k(E,a6);w=B.channel("syncGraph"),g=k(E,`app-sync-${W}`),C.room=g,B.on("peer:join",async(O)=>{console.info("\u26A1 New peer connected:",O),w.send([{type:"sync",timestamp:x}])}),B.on("peer:leave",(O)=>{console.info("\u26A1 Peer disconnected:",O)}),w.on("message",async(O)=>{let M=O;for(let p of S)try{if(M=await p(M),!M||M.length===0)return}catch(b){console.error("\u274C GDB: Middleware error, discarding message.",b);return}await o6(M)})}return Z=new BroadcastChannel(`graphdb_sync_${W}`),Z.onmessage=async(k)=>{if(k.data==="update")console.info("\uD83D\uDD04 Update received from another tab..."),await k0(),A(),H0()},console.info(`\u2705 GenosDB [ ${W} ] instance is ready.`),C}var r6=(W)=>{if(W===null||typeof W!=="object")return W;if(typeof structuredClone==="function")return structuredClone(W);return JSON.parse(JSON.stringify(W))},l6=(W,Q=16)=>{let J=null,V=null;return(...G)=>{if(!V)V={},V.promise=new Promise((Y,U)=>(V.resolve=Y,V.reject=U));if(J)("cancelIdleCallback"in window?cancelIdleCallback:clearTimeout)(J);const q=async()=>{J=null;try{V.resolve(await W(...G))}catch(Y){V.reject(Y)}finally{V=null}};return J=("requestIdleCallback"in window)?requestIdleCallback(q,{timeout:Q}):setTimeout(q,Q),V.promise}},B7=(W)=>{let Q=null;return()=>{if(Q!==null)return;Q=requestAnimationFrame(()=>{Q=null,W()})}};export{HQ as gdb};
