async function Z(k,K){console.info("\uD83D\uDEE1\uFE0F [SM-ACLs] Starting ACL module...");try{const x=await X(k,K);if(x)try{Object.defineProperty(k.sm,"acls",{value:x,writable:!0,enumerable:!1,configurable:!0}),console.info("\u2705 [SM-ACLs] Module initialized and attached to gdb.sm.acls.")}catch(z){throw console.error("\u274C [SM-ACLs] Failed to attach: gdb.sm not extensible.",z.message),new Error("SM-ACLs: Cannot attach ACL module to gdb.sm. Ensure gdb.sm is extensible.")}else console.warn("\u26A0\uFE0F [SM-ACLs] Module not activated (options missing).")}catch(x){throw console.error("\u274C [SM-ACLs] Failed to start ACL module.",x),x}}var X=async(k,K)=>{if(!K)return null;const x="owner",z="collaborators",G=()=>{const h=k.sm.getActiveEthAddress();if(!h)throw new Error("[SM-ACLs] Active user session required.");return h},Q=(h)=>new Error(`[SM-ACLs] Only the owner can ${h}.`),V=async(h)=>{const j=[];for(let P of h){const{signer:f,type:D,id:F}=P;if(!f||!F){j.push(P);continue}const H=k.graph.get(F),{[x]:J,[z]:T={}}=H?.value||{};if(D==="put"){if(!H||f===J||T[f]==="write")j.push(P);else console.warn(`[SM-ACLs] DENIED (put): ${f} \u2192 ${F}`);continue}if(D==="remove"){if(!H||J===void 0||f===J)j.push(P);else console.warn(`[SM-ACLs] DENIED (remove): ${f} \u2192 ${F}`);continue}j.push(P)}return j};return k.use(V),{async set(h,j){const P=G(),{result:f}=await k.get(j);if(f){const{[x]:D,[z]:F={}}=f.value;if(P!==D&&F[P]!=="write")throw new Error(`[SM-ACLs] Write denied for node ${j}.`);const{[x]:H,[z]:J,...T}=h;return k.put({...f.value,...T},j)}return k.put({...h,[x]:P,[z]:{}},j)},async grant(h,j,P){const f=G();if(!["read","write"].includes(P))throw new Error("[SM-ACLs] Permission must be 'read' or 'write'.");const{result:D}=await k.get(h);if(!D)throw new Error(`[SM-ACLs] Node ${h} not found.`);if(D.value[x]!==f)throw Q("grant permissions");const F={...D.value[z]??{},[j]:P};await k.put({...D.value,[z]:F},h)},async revoke(h,j){const P=G(),{result:f}=await k.get(h);if(!f)throw new Error(`[SM-ACLs] Node ${h} not found.`);if(f.value[x]!==P)throw Q("revoke permissions");const{[j]:D,...F}=f.value[z]??{};await k.put({...f.value,[z]:F},h)},async delete(h){const j=G(),{result:P}=await k.get(h);if(!P)return;if(P.value[x]!==j)throw Q("delete this node");await k.remove(h)},async getPermissions(h){const{result:j}=await k.get(h);if(!j||j.value[x]===void 0)return null;return{owner:j.value[x],collaborators:j.value[z]??{}}}}};export{Z as start,X as createAclModule};
