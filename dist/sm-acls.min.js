async function _(k,Q){console.info("\uD83D\uDEE1\uFE0F [SM-ACLs] Starting ACL module...");try{const x=await Y(k,Q);if(x)try{Object.defineProperty(k.sm,"acls",{value:x,writable:!0,enumerable:!1,configurable:!0}),console.info("\u2705 [SM-ACLs] Module initialized and attached to gdb.sm.acls.")}catch(D){throw console.error("\u274C [SM-ACLs] Failed to attach: gdb.sm not extensible.",D.message),new Error("SM-ACLs: Cannot attach ACL module to gdb.sm. Ensure gdb.sm is extensible.")}else console.warn("\u26A0\uFE0F [SM-ACLs] Module not activated (options missing).")}catch(x){throw console.error("\u274C [SM-ACLs] Failed to start ACL module.",x),x}}var Y=async(k,Q)=>{if(!Q)return null;const x="owner",D="collaborators",J=()=>{const P=k.sm.getActiveEthAddress();if(!P)throw new Error("[SM-ACLs] Active user session required.");return P},T=(P)=>new Error(`[SM-ACLs] Only the owner can ${P}.`),V=async(P,f)=>{const h=[];for(let j of P){const{signer:z,type:F,id:G}=j;if(!z||!G){h.push(j);continue}const K=f.get(G),{[x]:H,[D]:X={}}=K?.value||{};if(F==="put"){if(!K||z===H||X[z]==="write")h.push(j);else console.warn(`[SM-ACLs] DENIED (put): ${z} \u2192 ${G}`);continue}if(F==="remove"){if(!K||H===void 0||z===H)h.push(j);else console.warn(`[SM-ACLs] DENIED (remove): ${z} \u2192 ${G}`);continue}h.push(j)}return h};return k.use(V),{async set(P,f){const h=J(),{result:j}=await k.get(f);if(j){const{[x]:z,[D]:F={}}=j.value;if(h!==z&&F[h]!=="write")throw new Error(`[SM-ACLs] Write denied for node ${f}.`);const{[x]:G,[D]:K,...H}=P;return k.put({...j.value,...H},f)}return k.put({...P,[x]:h,[D]:{}},f)},async grant(P,f,h){const j=J();if(!["read","write"].includes(h))throw new Error("[SM-ACLs] Permission must be 'read' or 'write'.");const{result:z}=await k.get(P);if(!z)throw new Error(`[SM-ACLs] Node ${P} not found.`);if(z.value[x]!==j)throw T("grant permissions");const F={...z.value[D]??{},[f]:h};await k.put({...z.value,[D]:F},P)},async revoke(P,f){const h=J(),{result:j}=await k.get(P);if(!j)throw new Error(`[SM-ACLs] Node ${P} not found.`);if(j.value[x]!==h)throw T("revoke permissions");const{[f]:z,...F}=j.value[D]??{};await k.put({...j.value,[D]:F},P)},async delete(P){const f=J(),{result:h}=await k.get(P);if(!h)return;if(h.value[x]!==f)throw T("delete this node");await k.remove(P)},async getPermissions(P){const{result:f}=await k.get(P);if(!f||f.value[x]===void 0)return null;return{owner:f.value[x],collaborators:f.value[D]??{}}}}};export{_ as start,Y as createAclModule};
