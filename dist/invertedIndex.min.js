function G(E){const B={},K=E.worker,Q=`${E.name}_inverted_index.json`,R=E.encode,W=E.decode,U=E.pako,X=((q,A)=>{let H;return(...L)=>{clearTimeout(H),H=setTimeout(()=>q.apply(null,L),A)}})(()=>Z(),200);async function Y(){try{const q=await new Promise((A,H)=>{const L=(J)=>{if(J.data.type==="loaded"&&J.data.name===Q)K.removeEventListener("message",L),A(new Uint8Array(J.data.data));else if(J.data.type==="error")K.removeEventListener("message",L),H(new Error(J.data.message))};K.addEventListener("message",L),K.postMessage({type:"load",name:Q})});if(q.byteLength>0){if(!W||!U)throw new Error("InvertedIndexer: decode y pako deben estar en options");const A=U.inflate(q),H=W(A);return Object.assign(B,H),!0}}catch{}return!1}async function Z(){try{if(!R||!U)throw new Error("InvertedIndexer: encode y pako deben estar en options");const q=R(B),A=U.deflate(q);await new Promise((H,L)=>{const J=(C)=>{if(C.data.type==="saved"&&C.data.name===Q)K.removeEventListener("message",J),H();else if(C.data.type==="error")K.removeEventListener("message",J),L(new Error(C.data.message))};K.addEventListener("message",J),K.postMessage({type:"save",name:Q,content:A})})}catch{}}async function _(){(typeof E.graph?.getAllNodes==="function"?await E.graph.getAllNodes():Object.values(E.graph.nodes)).forEach((A)=>V(A.id,A.value,"insert",!1)),X()}function $(){E.map({realtime:!0},(q)=>{if(q.action==="added"||q.action==="updated")V(q.id,q.value,"insert",!0);else if(q.action==="removed")V(q.id,q.value,"remove",!0)})}function V(q,A,H="insert",L=!0){const J=z(A);if(H==="insert")J.forEach((C)=>{if(!B[C])B[C]=[];if(!B[C].includes(q))B[C].push(q)});else if(H==="remove")J.forEach((C)=>{if(B[C]){if(B[C]=B[C].filter((T)=>T!==q),B[C].length===0)delete B[C]}});if(L)X()}function z(q){if(typeof q==="string")return Array.from({length:q.length},(A,H)=>q.substring(0,H+1));if(typeof q==="number")return[String(q)];if(typeof q==="object"&&q!==null)return Object.keys(q);return[]}function S(q){return Object.keys(B).filter((A)=>A.startsWith(q)).flatMap((A)=>B[A])}return{ready:Y().then((q)=>{if(!q)_();$()}),updateIndex:V,searchAllByPrefix:S}}var P=(E)=>{console.log("\uD83C\uDF33 InvertedIndexer module loaded.");const B=G(E);return E.searchByPrefix=async(K)=>{return await B.ready,B.searchAllByPrefix(K).map((R)=>E.graph.get(R))},E};export{P as init,G as InvertedIndexer};
