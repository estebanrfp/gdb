function Q(w){if(typeof w!=="object"||w===null)throw new Error("Los roles personalizados deben ser un objeto v\xE1lido.");q=w}function z(w,G,O=new Set){const V=q;if(!V[w])return!1;if(O.has(w))return!1;if(O.add(w),V[w].can.includes(G))return!0;if(V[w].inherits)return V[w].inherits.some((Y)=>z(Y,G,O));return!1}async function S(w,G,O,V=null){if(await w.ready,!q[O])throw new Error(`El rol '${O}' no existe.`);const Y=`user:${G}`,k=w.graph.get(Y),T={role:O,expiresAt:V?new Date(V).toISOString():null};if(k)Object.assign(k.value,T);else w.graph.insert(Y,T);await w.saveGraphToOPFS(),console.log(`Rol '${O}' asignado al usuario '${G}'${V?` con caducidad en ${V}`:""}.`)}var B=function(){const w=new Uint8Array(32);return window.crypto.getRandomValues(w),w},F=function(){const w=new Uint8Array(16);return window.crypto.getRandomValues(w),w};async function J(w,G){const O=`user:${G}`,V=w.graph.get(O);if(!V)throw new Error("No tienes un rol asignado.");if(V.value.expiresAt&&new Date(V.value.expiresAt)<new Date)throw new Error("Tu rol ha caducado.");return V.value.role}async function L(w,G,O){const V=await J(w,G);if(!z(V,O))throw new Error(`No tienes permiso para realizar la operaci\xF3n '${O}'.`)}async function W(w,G,O,V){return await M(w,G),await L(w,G,O),G}async function M(w,G){const O=`user:${G}`;let V=w.graph.get(O);if(!V){const Y={storedCredential:null,isAuthenticated:!1};w.graph.insert(O,Y),await w.saveGraphToOPFS(),V=w.graph.get(O)}if(!V.value.storedCredential)await P(w,G);else if(!V.value.isAuthenticated)await E(w,G);else console.log("Ya est\xE1s autenticado. Bot\xF3n desactivado.")}async function P(w,G){if(!window.PublicKeyCredential){alert("WebAuthn no es soportado en este navegador.");return}const O=`user:${G}`,V=F(),k={challenge:B(),rp:{name:"RBAC System"},user:{id:V,name:G,displayName:G},pubKeyCredParams:[{type:"public-key",alg:-7}],authenticatorSelection:{authenticatorAttachment:"platform",userVerification:"required"},timeout:60000,attestation:"direct"};try{const T=await navigator.credentials.create({publicKey:k}),j=w.graph.get(O);if(!j){console.error("\xA1Error! El nodo de usuario desapareci\xF3 durante el registro.");return}j.value.storedCredential={id:T.id,type:T.type,rawId:Array.from(new Uint8Array(T.rawId)),response:{attestationObject:Array.from(new Uint8Array(T.response.attestationObject)),clientDataJSON:Array.from(new Uint8Array(T.response.clientDataJSON))}},j.value.isAuthenticated=!0,await w.saveGraphToOPFS(),console.log("Credencial registrada:",T),await E(w,G)}catch(T){console.error("Error en registro",T)}}async function E(w,G){const O=`user:${G}`,V=w.graph.get(O);if(!V){alert("No hay usuario registrado. Registra uno primero.");return}const Y=V.value.storedCredential;if(!Y){alert("No hay credenciales registradas. Registra una primero.");return}const T={challenge:B(),allowCredentials:[{id:Y.id,type:"public-key"}],userVerification:"required",timeout:60000};try{const j=await navigator.credentials.get({publicKey:T});V.value.isAuthenticated=!0,await w.saveGraphToOPFS(),console.log("Autenticaci\xF3n exitosa:",j)}catch(j){console.error("Error en autenticaci\xF3n",j)}}var q={superadmin:{can:["assignRole"],inherits:["admin"]},admin:{can:["delete"],inherits:["manager"]},manager:{can:["publish"],inherits:["user"]},user:{can:["write"],inherits:["guest"]},guest:{can:["read"]}};export{Q as setCustomRoles,W as executeWithPermission,z as can,S as assignRole};
