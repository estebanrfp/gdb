var U=function(){return new Promise((h,R)=>{const E=indexedDB.open("gdb-sm-signing-keys-store",1);E.onupgradeneeded=(L)=>{const X=L.target.result;if(!X.objectStoreNames.contains("privateKeysSM"))X.createObjectStore("privateKeysSM")},E.onsuccess=(L)=>h(L.target.result),E.onerror=(L)=>{console.error("SM: Error al abrir IndexedDB para claves:",L.target.error),R(L.target.error)}})};async function I(h,R){const L=(await U()).transaction("privateKeysSM","readwrite"),X=L.objectStore("privateKeysSM");return await new Promise((_,$)=>{const Y=X.put(R,h);Y.onsuccess=_,Y.onerror=()=>$(Y.error)}),L.done||L.complete}async function m(h){const X=(await U()).transaction("privateKeysSM","readonly").objectStore("privateKeysSM").get(h);return new Promise((_,$)=>{X.onsuccess=()=>_(X.result),X.onerror=()=>{console.error("SM: Error al obtener clave privada JWK:",X.error),$(X.error)}})}async function A(h){if(!h)return null;try{return await window.crypto.subtle.importKey("jwk",h,{name:"ECDSA",namedCurve:"P-256"},!0,["sign"])}catch(R){return console.error("SM: Error al importar clave privada JWK:",R,h),null}}async function M(){const h=await window.crypto.subtle.generateKey({name:"ECDSA",namedCurve:"P-256"},!0,["sign","verify"]),R=await window.crypto.subtle.exportKey("jwk",h.privateKey),E=await window.crypto.subtle.exportKey("jwk",h.publicKey);return{privateKeyJwk:R,publicKeyJwk:E}}var f=function(h){const{signature:R,...E}=h;return JSON.stringify(E,Object.keys(E).sort())};async function O(h,R){const E=f(h),L=(new TextEncoder()).encode(E);return await window.crypto.subtle.sign({name:"ECDSA",hash:{name:"SHA-256"}},R,L)}async function J(h,R,E){try{const L=await window.crypto.subtle.importKey("jwk",E,{name:"ECDSA",namedCurve:"P-256"},!0,["verify"]),X=f(h),_=(new TextEncoder()).encode(X);return await window.crypto.subtle.verify({name:"ECDSA",hash:{name:"SHA-256"}},L,R,_)}catch(L){return console.error("SM: Error al verificar firma ECDSA:",L,{signedDataObject:h,publicKeyJwk:E}),!1}}class F{constructor(h,R,E){if(!h)throw new Error("SecurityManager: localUserHandle es requerido.");if(!R)throw new Error("SecurityManager: dbInstance (GraphDB) es requerida.");if(!E||typeof E.can!=="function"||typeof E.mapChangeTypeToRbacAction!=="function")throw new Error("SecurityManager: rbacModuleInstance con m\xE9todos 'can' y 'mapChangeTypeToRbacAction' es requerido.");this.localUserHandle=h,this.gdb=R,this.rbac=E,this.strictMode=!0,this.localPrivateKey=null,console.log(`SM: SecurityManager inicializado para ${h}. Modo estricto: ${this.strictMode}`)}async _loadLocalPrivateKey(){if(this.localPrivateKey)return this.localPrivateKey;const h=await m(this.localUserHandle);if(h){if(this.localPrivateKey=await A(h),this.localPrivateKey)console.log(`SM: Clave privada cargada para ${this.localUserHandle}`);else console.error(`SM: Fallo al importar clave privada JWK para ${this.localUserHandle}. Se regenerar\xE1 si es necesario.`);return this.localPrivateKey}return console.log(`SM: No se encontr\xF3 clave privada JWK en IndexedDB para ${this.localUserHandle}.`),null}async ensureLocalUserKeys(){if(!this.localUserHandle)throw new Error("SM: Usuario local no establecido en ensureLocalUserKeys.");const R=(await this.gdb.get(`user:${this.localUserHandle}`)).result;let E=null;if(R&&R.value&&R.value.gdbSigningPubKey)E=R.value.gdbSigningPubKey;if(await this._loadLocalPrivateKey(),this.localPrivateKey&&E)return console.log(`SM: Claves de firma para ${this.localUserHandle} ya parecen existir.`),E;console.log(`SM: Generando/regenerando claves de firma para ${this.localUserHandle}...`);const{privateKeyJwk:L,publicKeyJwk:X}=await M();if(await I(this.localUserHandle,L),this.localPrivateKey=await A(L),!this.localPrivateKey)throw new Error(`SM: Fallo cr\xEDtico al generar y cargar la nueva clave privada para ${this.localUserHandle}`);return console.log("SM: Nuevas claves generadas. Clave p\xFAblica JWK:",X),X}async signOutgoingOperations(h){if(!this.localUserHandle)return console.warn("SM: Usuario local no establecido. Enviando operaciones sin firmar."),this.strictMode?[]:h;if(!this.localPrivateKey)await this._loadLocalPrivateKey();if(!this.localPrivateKey)return console.error(`SM: No se pudo cargar o generar clave privada para ${this.localUserHandle}. No se pueden firmar operaciones.`),this.strictMode?[]:h;const R=[];for(let E of h){const L={...E,originUser:this.localUserHandle};try{const X=await O(L,this.localPrivateKey);R.push({...L,signature:Array.from(new Uint8Array(X))})}catch(X){if(console.error(`SM: Error al firmar operaci\xF3n para ${this.localUserHandle}:`,X,L),this.strictMode)continue;R.push(E)}}return R}async verifyIncomingOperations(h){const R=[],E=[];for(let L of h){let X=!1,_=L;if(L.signature&&L.originUser){const{signature:$,originUser:Y,...V}=L;_=V;const z=(await this.gdb.get(`user:${Y}`)).result;if(z&&z.value&&z.value.gdbSigningPubKey){const P=z.value.gdbSigningPubKey,j=new Uint8Array($).buffer;if(await J(V,j,P)){const W=z.value.role;if(z.value.expiresAt&&new Date(z.value.expiresAt)<new Date)console.warn(`SM: Rol para ${Y} ha caducado, op descartada:`,L);else{const B=this.rbac.mapChangeTypeToRbacAction(V.type);if(this.rbac.can(W,B))R.push(V),X=!0;else console.warn(`SM: Usuario ${Y} (rol ${W}) no tiene permiso RBAC para '${B}'. Op descartada:`,L)}}else console.warn("SM: Firma inv\xE1lida. Op descartada:",L)}else console.warn(`SM: No se encontr\xF3 clave p\xFAblica registrada para ${Y} o nodo de usuario inv\xE1lido. Op no verificable:`,L)}if(!X)E.push(L)}return{validatedOperations:R,unverifiedOperations:E}}isStrictMode(){return this.strictMode}setStrictMode(h){this.strictMode=h,console.log(`SM: Modo estricto cambiado a: ${this.strictMode}`)}}function g(h){if(typeof h!=="object"||h===null)throw new Error("RBAC: Los roles personalizados deben ser un objeto v\xE1lido.");G=h,console.log("RBAC: Roles personalizados establecidos.")}function T(h,R,E=new Set){const L=G;if(!L[h])return!1;if(E.has(h))return!1;if(E.add(h),L[h].can&&L[h].can.includes(R))return!0;if(L[h].inherits&&Array.isArray(L[h].inherits))return L[h].inherits.some((X)=>T(X,R,new Set(E)));return!1}async function b(h,R){if(!h)throw new Error("RBAC: Se requiere instancia de GraphDB para inicializar la seguridad.");if(Z=h,x=R,x){if(console.log(`RBAC: Inicializando seguridad completa para el usuario: ${x}`),C=new F(x,Z,{can:T,mapChangeTypeToRbacAction:K}),Z.securityManager=C,Z.sendData&&!Z._originalSendDataByRBAC)Z._originalSendDataByRBAC=Z.sendData.bind(Z),Z.sendData=async($)=>{if(!C)return Z._originalSendDataByRBAC($);const Y=await C.signOutgoingOperations($);return Z._originalSendDataByRBAC(Y)},console.log("RBAC: GDB sendData envuelto para firmas P2P.");const E=await C.ensureLocalUserKeys(),X=(await Z.get(`user:${x}`)).result,_=X&&X.value&&X.value.gdbSigningPubKey;if(!_||JSON.stringify(_)!==JSON.stringify(E)){console.log(`RBAC: Actualizando/guardando gdbSigningPubKey para ${x} en GDB...`);const $=X&&X.value||{},Y=$.role||"user";await Z.put({...$,gdbSigningPubKey:E,role:Y},`user:${x}`),console.log(`RBAC: gdbSigningPubKey y rol para ${x} asegurados en GDB.`)}console.log(`RBAC: Seguridad P2P configurada y activa para ${x}.`)}else{if(console.log("RBAC: No hay usuario local. Seguridad P2P no se activar\xE1."),Z&&Z._originalSendDataByRBAC)Z.sendData=Z._originalSendDataByRBAC,delete Z._originalSendDataByRBAC,console.log("RBAC: GDB sendData restaurado a original.");if(Z)Z.securityManager=null;C=null}}async function y(h,R,E,L=null){if(await h.ready,!G[E])throw new Error(`RBAC: El rol '${E}' no existe.`);const X=`user:${R}`,_=await h.get(X),Y={..._.result&&_.result.value||{},role:E,expiresAt:L?new Date(L).toISOString():null};await h.put(Y,X),console.log(`RBAC: Asignaci\xF3n de rol '${E}' a '${R}' enviada a GDB.`)}var q=function(){const h=new Uint8Array(32);return window.crypto.getRandomValues(h),h},S=function(){const h=new Uint8Array(16);return window.crypto.getRandomValues(h),h};async function c(h,R){if(!h)throw new Error("RBAC: Se requiere instancia de GDB para handleAuthentication.");const E=`user:${R}`,L=await h.get(E);let X=L.result&&L.result.value||null;if(!X)console.log(`RBAC: Usuario ${R} no encontrado. Creando nodo de usuario inicial con rol 'user'.`),X={storedCredential:null,role:"user"},await h.put(X,E);if(!X.storedCredential)console.log(`RBAC: No hay credencial WebAuthn para ${R}. Iniciando registro...`),await D(h,R,X);else console.log(`RBAC: Hay credencial para ${R}. Iniciando autenticaci\xF3n...`),await N(h,R,X);return console.log(`RBAC: Flujo de autenticaci\xF3n WebAuthn completado para ${R}.`),R}async function D(h,R,E){if(!window.PublicKeyCredential)throw alert("WebAuthn no es soportado en este navegador."),new Error("WebAuthn no soportado.");const L=`user:${R}`,X=S(),$={challenge:q(),rp:{name:"GDB Application"},user:{id:X,name:R,displayName:R},pubKeyCredParams:[{type:"public-key",alg:-7}],authenticatorSelection:{authenticatorAttachment:"platform",userVerification:"required"},timeout:60000,attestation:"none"};try{const Y=await navigator.credentials.create({publicKey:$});console.log("RBAC: Credencial WebAuthn creada:",Y);const V={id:Y.id,type:Y.type,rawId:Array.from(new Uint8Array(Y.rawId))},Q={...E,storedCredential:V};await h.put(Q,L),console.log(`RBAC: Credencial WebAuthn registrada para ${R} en GDB.`)}catch(Y){throw console.error("RBAC: Error en registro WebAuthn:",Y),Y}}async function N(h,R,E){if(!window.PublicKeyCredential)throw alert("WebAuthn no es soportado en este navegador."),new Error("WebAuthn no soportado.");if(!E.storedCredential||!E.storedCredential.id)throw console.warn(`RBAC: No hay storedCredential para ${R} a pesar de que el nodo existe. Podr\xEDa necesitar registrarse.`),new Error("Credencial no registrada completamente.");const X={challenge:q(),allowCredentials:[{id:E.storedCredential.id,type:"public-key"}],userVerification:"required",timeout:60000};try{const _=await navigator.credentials.get({publicKey:X});console.log("RBAC: Autenticaci\xF3n WebAuthn exitosa:",_)}catch(_){throw console.error("RBAC: Error en autenticaci\xF3n WebAuthn:",_),_}}async function w(h,R){const E=await h.get(`user:${R}`);if(!E.result||!E.result.value||!E.result.value.role)throw new Error(`RBAC: No se encontr\xF3 rol para ${R}.`);const L=E.result.value;if(L.expiresAt&&new Date(L.expiresAt)<new Date)throw new Error(`RBAC: Rol para ${R} ha caducado.`);return L.role}async function k(h,R,E){const L=await w(h,R);if(!T(L,E))throw new Error(`RBAC: Usuario ${R} (rol ${L}) no tiene permiso para '${E}'.`)}async function l(h,R,E,L){if(!R)throw new Error("RBAC (executeWithPermission): Se requiere un userHandle v\xE1lido.");if(C){if(R!==x)throw new Error(`RBAC (executeWithPermission): Intento de operaci\xF3n como '${R}' pero la sesi\xF3n de seguridad P2P es para '${x}'.`)}else console.warn("RBAC (executeWithPermission): Seguridad P2P no activa. Verificando solo permisos locales.");return await k(h,R,E),console.log(`RBAC (executeWithPermission): ${R} autorizado localmente para '${E}'. Ejecutando acci\xF3n.`),await L(R)}function K(h){if(h==="put"||h==="insert"||h==="update")return"write";if(h==="remove")return"delete";if(h==="link")return"link";if(h==="assignRole")return"assignRole";if(h==="sync"||h==="syncReceive")return"sync";return console.warn(`RBAC: Tipo de cambio desconocido '${h}' para mapeo RBAC.`),"unknown"}var G={superadmin:{can:["assignRole"],inherits:["admin"]},admin:{can:["delete"],inherits:["manager"]},manager:{can:["publish"],inherits:["user"]},user:{can:["write","link","sync"],inherits:["guest"]},guest:{can:["read"]}},Z=null,x=null,C=null;export{g as setCustomRoles,K as mapChangeTypeToRbacAction,b as initializeCompleteSecurity,c as handleAuthentication,l as executeWithPermission,T as can,y as assignRole};
