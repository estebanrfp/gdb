var h$=Object.defineProperty;var l$=($,q)=>{for(var J in q)h$($,J,{get:q[J],enumerable:!0,configurable:!0,set:(G)=>q[J]=()=>G})};var h8="6.14.1";var p$=function($,q,J){const G=q.split("|").map((M)=>M.trim());for(let M=0;M<G.length;M++)switch(q){case"any":return;case"bigint":case"boolean":case"number":case"string":if(typeof $===q)return}const Q=new Error(`invalid value for type ${q}`);throw Q.code="INVALID_ARGUMENT",Q.argument=`value.${J}`,Q.value=$,Q};function i0($,q,J){for(let G in q){let Q=q[G];const M=J?J[G]:null;if(M)p$(Q,M,G);Object.defineProperty($,G,{enumerable:!0,value:Q,writable:!1})}}var k0=function($){if($==null)return"null";if(Array.isArray($))return"[ "+$.map(k0).join(", ")+" ]";if($ instanceof Uint8Array){let J="0x";for(let G=0;G<$.length;G++)J+="0123456789abcdef"[$[G]>>4],J+="0123456789abcdef"[$[G]&15];return J}if(typeof $==="object"&&typeof $.toJSON==="function")return k0($.toJSON());switch(typeof $){case"boolean":case"symbol":return $.toString();case"bigint":return BigInt($).toString();case"number":return $.toString();case"string":return JSON.stringify($);case"object":{const q=Object.keys($);return q.sort(),"{ "+q.map((J)=>`${k0(J)}: ${k0($[J])}`).join(", ")+" }"}}return"[ COULD NOT SERIALIZE ]"};function K8($,q,J){let G=$;{const M=[];if(J){if(("message"in J)||("code"in J)||("name"in J))throw new Error(`value will overwrite populated values: ${k0(J)}`);for(let Y in J){if(Y==="shortMessage")continue;const W=J[Y];M.push(Y+"="+k0(W))}}if(M.push(`code=${q}`),M.push(`version=${h8}`),M.length)$+=" ("+M.join(", ")+")"}let Q;switch(q){case"INVALID_ARGUMENT":Q=new TypeError($);break;case"NUMERIC_FAULT":case"BUFFER_OVERRUN":Q=new RangeError($);break;default:Q=new Error($)}if(i0(Q,{code:q}),J)Object.assign(Q,J);if(Q.shortMessage==null)i0(Q,{shortMessage:G});return Q}function $0($,q,J,G){if(!$)throw K8(q,J,G)}function S($,q,J,G){$0($,q,"INVALID_ARGUMENT",{argument:J,value:G})}function o0($){$0(u$.indexOf($)>=0,"platform missing String.prototype.normalize","UNSUPPORTED_OPERATION",{operation:"String.prototype.normalize",info:{form:$}})}function n0($,q,J){if(J==null)J="";if($!==q){let G=J,Q="new";if(J)G+=".",Q+=" "+J;$0(!1,`private constructor; use ${G}from* methods`,"UNSUPPORTED_OPERATION",{operation:Q})}}var u$=["NFD","NFC","NFKD","NFKC"].reduce(($,q)=>{try{if("test".normalize(q)!=="test")throw new Error("bad");if(q==="NFD"){const J=String.fromCharCode(233).normalize("NFD"),G=String.fromCharCode(101,769);if(J!==G)throw new Error("broken")}$.push(q)}catch(J){}return $},[]);var p8=function($,q,J){if($ instanceof Uint8Array){if(J)return new Uint8Array($);return $}if(typeof $==="string"&&$.match(/^0x(?:[0-9a-f][0-9a-f])*$/i)){const G=new Uint8Array(($.length-2)/2);let Q=2;for(let M=0;M<G.length;M++)G[M]=parseInt($.substring(Q,Q+2),16),Q+=2;return G}S(!1,"invalid BytesLike value",q||"value",$)};function y($,q){return p8($,q,!1)}function z0($,q){return p8($,q,!0)}function A0($,q){if(typeof $!=="string"||!$.match(/^0x[0-9A-Fa-f]*$/))return!1;if(typeof q==="number"&&$.length!==2+2*q)return!1;if(q===!0&&$.length%2!==0)return!1;return!0}function _($){const q=y($);let J="0x";for(let G=0;G<q.length;G++){const Q=q[G];J+=l8[(Q&240)>>4]+l8[Q&15]}return J}function Q0($){return"0x"+$.map((q)=>_(q).substring(2)).join("")}function M0($){if(A0($,!0))return($.length-2)/2;return y($).length}var d$=function($,q,J){const G=y($);$0(q>=G.length,"padding exceeds data length","BUFFER_OVERRUN",{buffer:new Uint8Array(G),length:q,offset:q+1});const Q=new Uint8Array(q);if(Q.fill(0),J)Q.set(G,q-G.length);else Q.set(G,0);return _(Q)};function a0($,q){return d$($,q,!0)}var l8="0123456789abcdef";function D0($,q){switch(typeof $){case"bigint":return $;case"number":return S(Number.isInteger($),"underflow",q||"value",$),S($>=-_0&&$<=_0,"overflow",q||"value",$),BigInt($);case"string":try{if($==="")throw new Error("empty string");if($[0]==="-"&&$[1]!=="-")return-BigInt($.substring(1));return BigInt($)}catch(J){S(!1,`invalid BigNumberish string: ${J.message}`,q||"value",$)}}S(!1,"invalid BigNumberish value",q||"value",$)}function r0($,q){const J=D0($,q);return $0(J>=u8,"unsigned value cannot be negative","NUMERIC_FAULT",{fault:"overflow",operation:"getUint",value:$}),J}function K0($,q){switch(typeof $){case"bigint":return S($>=-_0&&$<=_0,"overflow",q||"value",$),Number($);case"number":return S(Number.isInteger($),"underflow",q||"value",$),S($>=-_0&&$<=_0,"overflow",q||"value",$),$;case"string":try{if($==="")throw new Error("empty string");return K0(BigInt($),q)}catch(J){S(!1,`invalid numeric string: ${J.message}`,q||"value",$)}}S(!1,"invalid numeric value",q||"value",$)}function y0($,q){let G=r0($,"value").toString(16);if(q==null){if(G.length%2)G="0"+G}else{const Q=K0(q,"width");$0(Q*2>=G.length,`value exceeds width (${Q} bytes)`,"NUMERIC_FAULT",{operation:"toBeHex",fault:"overflow",value:$});while(G.length<Q*2)G="0"+G}return"0x"+G}function t0($){const q=r0($,"value");if(q===u8)return new Uint8Array([]);let J=q.toString(16);if(J.length%2)J="0"+J;const G=new Uint8Array(J.length/2);for(let Q=0;Q<G.length;Q++){const M=Q*2;G[Q]=parseInt(J.substring(M,M+2),16)}return G}var u8=BigInt(0),Rq=BigInt(1),_0=9007199254740991;var i$=function($,q,J,G,Q){S(!1,`invalid codepoint at offset ${q}; ${$}`,"bytes",J)},d8=function($,q,J,G,Q){if($==="BAD_PREFIX"||$==="UNEXPECTED_CONTINUE"){let M=0;for(let Y=q+1;Y<J.length;Y++){if(J[Y]>>6!==2)break;M++}return M}if($==="OVERRUN")return J.length-q-1;return 0},o$=function($,q,J,G,Q){if($==="OVERLONG")return S(typeof Q==="number","invalid bad code point for replacement","badCodepoint",Q),G.push(Q),0;return G.push(65533),d8($,q,J,G,Q)};function U0($,q){if(S(typeof $==="string","invalid string value","str",$),q!=null)o0(q),$=$.normalize(q);let J=[];for(let G=0;G<$.length;G++){const Q=$.charCodeAt(G);if(Q<128)J.push(Q);else if(Q<2048)J.push(Q>>6|192),J.push(Q&63|128);else if((Q&64512)==55296){G++;const M=$.charCodeAt(G);S(G<$.length&&(M&64512)===56320,"invalid surrogate pair","str",$);const Y=65536+((Q&1023)<<10)+(M&1023);J.push(Y>>18|240),J.push(Y>>12&63|128),J.push(Y>>6&63|128),J.push(Y&63|128)}else J.push(Q>>12|224),J.push(Q>>6&63|128),J.push(Q&63|128)}return new Uint8Array(J)}var i8=Object.freeze({error:i$,ignore:d8,replace:o$});var m0=function($){if(!Number.isSafeInteger($)||$<0)throw new Error(`Wrong positive integer: ${$}`)};var c0=function($,...q){if(!($ instanceof Uint8Array))throw new Error("Expected Uint8Array");if(q.length>0&&!q.includes($.length))throw new Error(`Expected Uint8Array of length ${q}, not of length=${$.length}`)},o8=function($){if(typeof $!=="function"||typeof $.create!=="function")throw new Error("Hash should be wrapped by utils.wrapConstructor");m0($.outputLen),m0($.blockLen)},Y0=function($,q=!0){if($.destroyed)throw new Error("Hash instance has been destroyed");if(q&&$.finished)throw new Error("Hash#digest() has already been called")},s0=function($,q){c0($);const J=q.outputLen;if($.length<J)throw new Error(`digestInto() expects output buffer of length at least ${J}`)};var e0=typeof globalThis==="object"&&("crypto"in globalThis)?globalThis.crypto:void 0;function ZJ($){if(typeof $!=="string")throw new Error(`utf8ToBytes expected string, got ${typeof $}`);return new Uint8Array((new TextEncoder()).encode($))}function N0($){if(typeof $==="string")$=ZJ($);if(!n8($))throw new Error(`expected Uint8Array, got ${typeof $}`);return $}function r8(...$){const q=new Uint8Array($.reduce((G,Q)=>G+Q.length,0));let J=0;return $.forEach((G)=>{if(!n8(G))throw new Error("Uint8Array expected");q.set(G,J),J+=G.length}),q}function J8($){const q=(G)=>$().update(N0(G)).digest(),J=$();return q.outputLen=J.outputLen,q.blockLen=J.blockLen,q.create=()=>$(),q}function t8($=32){if(e0&&typeof e0.getRandomValues==="function")return e0.getRandomValues(new Uint8Array($));throw new Error("crypto.getRandomValues must be defined")}/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */var n8=($)=>$ instanceof Uint8Array;var a8=($)=>new Uint32Array($.buffer,$.byteOffset,Math.floor($.byteLength/4)),$8=($)=>new DataView($.buffer,$.byteOffset,$.byteLength),t=($,q)=>$<<32-q|$>>>q,IJ=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;if(!IJ)throw new Error("Non little-endian hardware is not supported");class L0{clone(){return this._cloneInto()}}var Aq={}.toString;class U8 extends L0{constructor($,q){super();this.finished=!1,this.destroyed=!1,o8($);const J=N0(q);if(this.iHash=$.create(),typeof this.iHash.update!=="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const G=this.blockLen,Q=new Uint8Array(G);Q.set(J.length>G?$.create().update(J).digest():J);for(let M=0;M<Q.length;M++)Q[M]^=54;this.iHash.update(Q),this.oHash=$.create();for(let M=0;M<Q.length;M++)Q[M]^=54^92;this.oHash.update(Q),Q.fill(0)}update($){return Y0(this),this.iHash.update($),this}digestInto($){Y0(this),c0($,this.outputLen),this.finished=!0,this.iHash.digestInto($),this.oHash.update($),this.oHash.digestInto($),this.destroy()}digest(){const $=new Uint8Array(this.oHash.outputLen);return this.digestInto($),$}_cloneInto($){$||($=Object.create(Object.getPrototypeOf(this),{}));const{oHash:q,iHash:J,finished:G,destroyed:Q,blockLen:M,outputLen:Y}=this;return $=$,$.finished=G,$.destroyed=Q,$.blockLen=M,$.outputLen=Y,$.oHash=q._cloneInto($.oHash),$.iHash=J._cloneInto($.iHash),$}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}var V8=($,q,J)=>new U8($,q).update(J).digest();V8.create=($,q)=>new U8($,q);var zJ=function($,q,J,G){if(typeof $.setBigUint64==="function")return $.setBigUint64(q,J,G);const Q=BigInt(32),M=BigInt(4294967295),Y=Number(J>>Q&M),W=Number(J&M),X=G?4:0,I=G?0:4;$.setUint32(q+X,Y,G),$.setUint32(q+I,W,G)};class T8 extends L0{constructor($,q,J,G){super();this.blockLen=$,this.outputLen=q,this.padOffset=J,this.isLE=G,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array($),this.view=$8(this.buffer)}update($){Y0(this);const{view:q,buffer:J,blockLen:G}=this;$=N0($);const Q=$.length;for(let M=0;M<Q;){const Y=Math.min(G-this.pos,Q-M);if(Y===G){const W=$8($);for(;G<=Q-M;M+=G)this.process(W,M);continue}if(J.set($.subarray(M,M+Y),this.pos),this.pos+=Y,M+=Y,this.pos===G)this.process(q,0),this.pos=0}return this.length+=$.length,this.roundClean(),this}digestInto($){Y0(this),s0($,this),this.finished=!0;const{buffer:q,view:J,blockLen:G,isLE:Q}=this;let{pos:M}=this;if(q[M++]=128,this.buffer.subarray(M).fill(0),this.padOffset>G-M)this.process(J,0),M=0;for(let z=M;z<G;z++)q[z]=0;zJ(J,G-8,BigInt(this.length*8),Q),this.process(J,0);const Y=$8($),W=this.outputLen;if(W%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const X=W/4,I=this.get();if(X>I.length)throw new Error("_sha2: outputLen bigger than state");for(let z=0;z<X;z++)Y.setUint32(4*z,I[z],Q)}digest(){const{buffer:$,outputLen:q}=this;this.digestInto($);const J=$.slice(0,q);return this.destroy(),J}_cloneInto($){$||($=new this.constructor),$.set(...this.get());const{blockLen:q,buffer:J,length:G,finished:Q,destroyed:M,pos:Y}=this;if($.length=G,$.pos=Y,$.finished=Q,$.destroyed=M,G%q)$.buffer.set(J);return $}}var DJ=($,q,J)=>$&q^~$&J,KJ=($,q,J)=>$&q^$&J^q&J,UJ=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),V0=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),T0=new Uint32Array(64);class s8 extends T8{constructor(){super(64,32,8,!1);this.A=V0[0]|0,this.B=V0[1]|0,this.C=V0[2]|0,this.D=V0[3]|0,this.E=V0[4]|0,this.F=V0[5]|0,this.G=V0[6]|0,this.H=V0[7]|0}get(){const{A:$,B:q,C:J,D:G,E:Q,F:M,G:Y,H:W}=this;return[$,q,J,G,Q,M,Y,W]}set($,q,J,G,Q,M,Y,W){this.A=$|0,this.B=q|0,this.C=J|0,this.D=G|0,this.E=Q|0,this.F=M|0,this.G=Y|0,this.H=W|0}process($,q){for(let z=0;z<16;z++,q+=4)T0[z]=$.getUint32(q,!1);for(let z=16;z<64;z++){const K=T0[z-15],R=T0[z-2],w=t(K,7)^t(K,18)^K>>>3,Z=t(R,17)^t(R,19)^R>>>10;T0[z]=Z+T0[z-7]+w+T0[z-16]|0}let{A:J,B:G,C:Q,D:M,E:Y,F:W,G:X,H:I}=this;for(let z=0;z<64;z++){const K=t(Y,6)^t(Y,11)^t(Y,25),R=I+K+DJ(Y,W,X)+UJ[z]+T0[z]|0,Z=(t(J,2)^t(J,13)^t(J,22))+KJ(J,G,Q)|0;I=X,X=W,W=Y,Y=M+R|0,M=Q,Q=G,G=J,J=R+Z|0}J=J+this.A|0,G=G+this.B|0,Q=Q+this.C|0,M=M+this.D|0,Y=Y+this.E|0,W=W+this.F|0,X=X+this.G|0,I=I+this.H|0,this.set(J,G,Q,M,Y,W,X,I)}roundClean(){T0.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}}var e8=J8(()=>new s8);var VJ=function($,q=!1){if(q)return{h:Number($&q8),l:Number($>>$$&q8)};return{h:Number($>>$$&q8)|0,l:Number($&q8)|0}},J$=function($,q=!1){let J=new Uint32Array($.length),G=new Uint32Array($.length);for(let Q=0;Q<$.length;Q++){const{h:M,l:Y}=VJ($[Q],q);[J[Q],G[Q]]=[M,Y]}return[J,G]};var q8=BigInt(4294967295),$$=BigInt(32);var q$=($,q,J)=>$<<J|q>>>32-J,G$=($,q,J)=>q<<J|$>>>32-J,Q$=($,q,J)=>q<<J-32|$>>>64-J,M$=($,q,J)=>$<<J-32|q>>>64-J;function LJ($,q=24){const J=new Uint32Array(10);for(let G=24-q;G<24;G++){for(let Y=0;Y<10;Y++)J[Y]=$[Y]^$[Y+10]^$[Y+20]^$[Y+30]^$[Y+40];for(let Y=0;Y<10;Y+=2){const W=(Y+8)%10,X=(Y+2)%10,I=J[X],z=J[X+1],K=Y$(I,z,1)^J[W],R=X$(I,z,1)^J[W+1];for(let w=0;w<50;w+=10)$[Y+w]^=K,$[Y+w+1]^=R}let Q=$[2],M=$[3];for(let Y=0;Y<24;Y++){const W=I$[Y],X=Y$(Q,M,W),I=X$(Q,M,W),z=W$[Y];Q=$[z],M=$[z+1],$[z]=X,$[z+1]=I}for(let Y=0;Y<50;Y+=10){for(let W=0;W<10;W++)J[W]=$[Y+W];for(let W=0;W<10;W++)$[Y+W]^=~J[(W+2)%10]&J[(W+4)%10]}$[0]^=wJ[G],$[1]^=NJ[G]}J.fill(0)}var[W$,I$,Z$]=[[],[],[]],TJ=BigInt(0),h0=BigInt(1),jJ=BigInt(2),OJ=BigInt(7),HJ=BigInt(256),RJ=BigInt(113);for(let $=0,q=h0,J=1,G=0;$<24;$++){[J,G]=[G,(2*J+3*G)%5],W$.push(2*(5*G+J)),I$.push(($+1)*($+2)/2%64);let Q=TJ;for(let M=0;M<7;M++)if(q=(q<<h0^(q>>OJ)*RJ)%HJ,q&jJ)Q^=h0<<(h0<<BigInt(M))-h0;Z$.push(Q)}var[wJ,NJ]=J$(Z$,!0),Y$=($,q,J)=>J>32?Q$($,q,J):q$($,q,J),X$=($,q,J)=>J>32?M$($,q,J):G$($,q,J);class j8 extends L0{constructor($,q,J,G=!1,Q=24){super();if(this.blockLen=$,this.suffix=q,this.outputLen=J,this.enableXOF=G,this.rounds=Q,this.pos=0,this.posOut=0,this.finished=!1,this.destroyed=!1,m0(J),0>=this.blockLen||this.blockLen>=200)throw new Error("Sha3 supports only keccak-f1600 function");this.state=new Uint8Array(200),this.state32=a8(this.state)}keccak(){LJ(this.state32,this.rounds),this.posOut=0,this.pos=0}update($){Y0(this);const{blockLen:q,state:J}=this;$=N0($);const G=$.length;for(let Q=0;Q<G;){const M=Math.min(q-this.pos,G-Q);for(let Y=0;Y<M;Y++)J[this.pos++]^=$[Q++];if(this.pos===q)this.keccak()}return this}finish(){if(this.finished)return;this.finished=!0;const{state:$,suffix:q,pos:J,blockLen:G}=this;if($[J]^=q,(q&128)!==0&&J===G-1)this.keccak();$[G-1]^=128,this.keccak()}writeInto($){Y0(this,!1),c0($),this.finish();const q=this.state,{blockLen:J}=this;for(let G=0,Q=$.length;G<Q;){if(this.posOut>=J)this.keccak();const M=Math.min(J-this.posOut,Q-G);$.set(q.subarray(this.posOut,this.posOut+M),G),this.posOut+=M,G+=M}return $}xofInto($){if(!this.enableXOF)throw new Error("XOF is not possible for this instance");return this.writeInto($)}xof($){return m0($),this.xofInto(new Uint8Array($))}digestInto($){if(s0($,this),this.finished)throw new Error("digest() was already called");return this.writeInto($),this.destroy(),$}digest(){return this.digestInto(new Uint8Array(this.outputLen))}destroy(){this.destroyed=!0,this.state.fill(0)}_cloneInto($){const{blockLen:q,suffix:J,outputLen:G,rounds:Q,enableXOF:M}=this;return $||($=new j8(q,J,G,M,Q)),$.state32.set(this.state32),$.pos=this.pos,$.posOut=this.posOut,$.finished=this.finished,$.rounds=Q,$.suffix=J,$.outputLen=G,$.enableXOF=M,$.destroyed=this.destroyed,$}}var CJ=($,q,J)=>J8(()=>new j8(q,$,J));var z$=CJ(1,136,32);function s($){const q=y($,"data");return _(U$(q))}var D$=!1,K$=function($){return z$($)},U$=K$;s._=K$;s.lock=function(){D$=!0};s.register=function($){if(D$)throw new TypeError("keccak256 is locked");U$=$};Object.freeze(s);var w8={};l$(w8,{validateObject:()=>{{return O0}},utf8ToBytes:()=>{{return xJ}},numberToVarBytesBE:()=>{{return PJ}},numberToHexUnpadded:()=>{{return j$}},numberToBytesLE:()=>{{return Y8}},numberToBytesBE:()=>{{return j0}},hexToNumber:()=>{{return H8}},hexToBytes:()=>{{return S0}},equalBytes:()=>{{return EJ}},ensureBytes:()=>{{return d}},createHmacDrbg:()=>{{return R8}},concatBytes:()=>{{return b0}},bytesToNumberLE:()=>{{return M8}},bytesToNumberBE:()=>{{return X0}},bytesToHex:()=>{{return C0}},bitSet:()=>{{return AJ}},bitMask:()=>{{return l0}},bitLen:()=>{{return fJ}},bitGet:()=>{{return kJ}}});function C0($){if(!Q8($))throw new Error("Uint8Array expected");let q="";for(let J=0;J<$.length;J++)q+=BJ[$[J]];return q}function j$($){const q=$.toString(16);return q.length&1?`0${q}`:q}function H8($){if(typeof $!=="string")throw new Error("hex string expected, got "+typeof $);return BigInt($===""?"0":`0x${$}`)}function S0($){if(typeof $!=="string")throw new Error("hex string expected, got "+typeof $);const q=$.length;if(q%2)throw new Error("padded hex string expected, got unpadded hex of length "+q);const J=new Uint8Array(q/2);for(let G=0;G<J.length;G++){const Q=G*2,M=$.slice(Q,Q+2),Y=Number.parseInt(M,16);if(Number.isNaN(Y)||Y<0)throw new Error("Invalid byte sequence");J[G]=Y}return J}function X0($){return H8(C0($))}function M8($){if(!Q8($))throw new Error("Uint8Array expected");return H8(C0(Uint8Array.from($).reverse()))}function j0($,q){return S0($.toString(16).padStart(q*2,"0"))}function Y8($,q){return j0($,q).reverse()}function PJ($){return S0(j$($))}function d($,q,J){let G;if(typeof q==="string")try{G=S0(q)}catch(M){throw new Error(`${$} must be valid hex string, got "${q}". Cause: ${M}`)}else if(Q8(q))G=Uint8Array.from(q);else throw new Error(`${$} must be hex string or Uint8Array`);const Q=G.length;if(typeof J==="number"&&Q!==J)throw new Error(`${$} expected ${J} bytes, got ${Q}`);return G}function b0(...$){const q=new Uint8Array($.reduce((G,Q)=>G+Q.length,0));let J=0;return $.forEach((G)=>{if(!Q8(G))throw new Error("Uint8Array expected");q.set(G,J),J+=G.length}),q}function EJ($,q){if($.length!==q.length)return!1;for(let J=0;J<$.length;J++)if($[J]!==q[J])return!1;return!0}function xJ($){if(typeof $!=="string")throw new Error(`utf8ToBytes expected string, got ${typeof $}`);return new Uint8Array((new TextEncoder()).encode($))}function fJ($){let q;for(q=0;$>T$;$>>=G8,q+=1);return q}function kJ($,q){return $>>BigInt(q)&G8}function R8($,q,J){if(typeof $!=="number"||$<2)throw new Error("hashLen must be a number");if(typeof q!=="number"||q<2)throw new Error("qByteLen must be a number");if(typeof J!=="function")throw new Error("hmacFn must be a function");let G=O8($),Q=O8($),M=0;const Y=()=>{G.fill(1),Q.fill(0),M=0},W=(...K)=>J(Q,G,...K),X=(K=O8())=>{if(Q=W(V$([0]),K),G=W(),K.length===0)return;Q=W(V$([1]),K),G=W()},I=()=>{if(M++>=1000)throw new Error("drbg: tried 1000 values");let K=0;const R=[];while(K<q){G=W();const w=G.slice();R.push(w),K+=G.length}return b0(...R)};return(K,R)=>{Y(),X(K);let w=void 0;while(!(w=R(I())))X();return Y(),w}}function O0($,q,J={}){const G=(Q,M,Y)=>{const W=_J[M];if(typeof W!=="function")throw new Error(`Invalid validator "${M}", expected function`);const X=$[Q];if(Y&&X===void 0)return;if(!W(X,$))throw new Error(`Invalid param ${String(Q)}=${X} (${typeof X}), expected ${M}`)};for(let[Q,M]of Object.entries(q))G(Q,M,!1);for(let[Q,M]of Object.entries(J))G(Q,M,!0);return $}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */var T$=BigInt(0),G8=BigInt(1),SJ=BigInt(2),Q8=($)=>$ instanceof Uint8Array,BJ=Array.from({length:256},($,q)=>q.toString(16).padStart(2,"0")),AJ=($,q,J)=>{return $|(J?G8:T$)<<BigInt(q)},l0=($)=>(SJ<<BigInt($-1))-G8,O8=($)=>new Uint8Array($),V$=($)=>Uint8Array.from($),_J={bigint:($)=>typeof $==="bigint",function:($)=>typeof $==="function",boolean:($)=>typeof $==="boolean",string:($)=>typeof $==="string",stringOrUint8Array:($)=>typeof $==="string"||$ instanceof Uint8Array,isSafeInteger:($)=>Number.isSafeInteger($),array:($)=>Array.isArray($),field:($,q)=>q.Fp.isValid($),hash:($)=>typeof $==="function"&&Number.isSafeInteger($.outputLen)};function h($,q){const J=$%q;return J>=v?J:q+J}function vJ($,q,J){if(J<=v||q<v)throw new Error("Expected power/modulo > 0");if(J===b)return v;let G=b;while(q>v){if(q&b)G=G*$%J;$=$*$%J,q>>=b}return G}function i($,q,J){let G=$;while(q-- >v)G*=G,G%=J;return G}function X8($,q){if($===v||q<=v)throw new Error(`invert: expected positive integers, got n=${$} mod=${q}`);let J=h($,q),G=q,Q=v,M=b,Y=b,W=v;while(J!==v){const I=G/J,z=G%J,K=Q-Y*I,R=M-W*I;G=J,J=z,Q=Y,M=W,Y=K,W=R}if(G!==b)throw new Error("invert: does not exist");return h(Q,q)}function yJ($){const q=($-b)/B0;let J,G,Q;for(J=$-b,G=0;J%B0===v;J/=B0,G++);for(Q=B0;Q<$&&vJ(Q,q,$)!==$-b;Q++);if(G===1){const Y=($+b)/N8;return function W(X,I){const z=X.pow(I,Y);if(!X.eql(X.sqr(z),I))throw new Error("Cannot find square root");return z}}const M=(J+b)/B0;return function Y(W,X){if(W.pow(X,q)===W.neg(W.ONE))throw new Error("Cannot find square root");let I=G,z=W.pow(W.mul(W.ONE,Q),J),K=W.pow(X,M),R=W.pow(X,J);while(!W.eql(R,W.ONE)){if(W.eql(R,W.ZERO))return W.ZERO;let w=1;for(let U=W.sqr(R);w<I;w++){if(W.eql(U,W.ONE))break;U=W.sqr(U)}const Z=W.pow(z,b<<BigInt(I-w-1));z=W.sqr(Z),K=W.mul(K,Z),R=W.mul(R,z),I=w}return K}}function mJ($){if($%N8===bJ){const q=($+b)/N8;return function J(G,Q){const M=G.pow(Q,q);if(!G.eql(G.sqr(M),Q))throw new Error("Cannot find square root");return M}}if($%H$===O$){const q=($-O$)/H$;return function J(G,Q){const M=G.mul(Q,B0),Y=G.pow(M,q),W=G.mul(Q,Y),X=G.mul(G.mul(W,B0),Y),I=G.mul(W,G.sub(X,G.ONE));if(!G.eql(G.sqr(I),Q))throw new Error("Cannot find square root");return I}}if($%gJ===FJ);return yJ($)}function L8($){const q={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},J=cJ.reduce((G,Q)=>{return G[Q]="function",G},q);return O0($,J)}function hJ($,q,J){if(J<v)throw new Error("Expected power > 0");if(J===v)return $.ONE;if(J===b)return q;let G=$.ONE,Q=q;while(J>v){if(J&b)G=$.mul(G,Q);Q=$.sqr(Q),J>>=b}return G}function lJ($,q){const J=new Array(q.length),G=q.reduce((M,Y,W)=>{if($.is0(Y))return M;return J[W]=M,$.mul(M,Y)},$.ONE),Q=$.inv(G);return q.reduceRight((M,Y,W)=>{if($.is0(Y))return M;return J[W]=$.mul(M,J[W]),$.mul(M,Y)},Q),J}function C8($,q){const J=q!==void 0?q:$.toString(2).length,G=Math.ceil(J/8);return{nBitLength:J,nByteLength:G}}function R$($,q,J=!1,G={}){if($<=v)throw new Error(`Expected Field ORDER > 0, got ${$}`);const{nBitLength:Q,nByteLength:M}=C8($,q);if(M>2048)throw new Error("Field lengths over 2048 bytes are not supported");const Y=mJ($),W=Object.freeze({ORDER:$,BITS:Q,BYTES:M,MASK:l0(Q),ZERO:v,ONE:b,create:(X)=>h(X,$),isValid:(X)=>{if(typeof X!=="bigint")throw new Error(`Invalid field element: expected bigint, got ${typeof X}`);return v<=X&&X<$},is0:(X)=>X===v,isOdd:(X)=>(X&b)===b,neg:(X)=>h(-X,$),eql:(X,I)=>X===I,sqr:(X)=>h(X*X,$),add:(X,I)=>h(X+I,$),sub:(X,I)=>h(X-I,$),mul:(X,I)=>h(X*I,$),pow:(X,I)=>hJ(W,X,I),div:(X,I)=>h(X*X8(I,$),$),sqrN:(X)=>X*X,addN:(X,I)=>X+I,subN:(X,I)=>X-I,mulN:(X,I)=>X*I,inv:(X)=>X8(X,$),sqrt:G.sqrt||((X)=>Y(W,X)),invertBatch:(X)=>lJ(W,X),cmov:(X,I,z)=>z?I:X,toBytes:(X)=>J?Y8(X,M):j0(X,M),fromBytes:(X)=>{if(X.length!==M)throw new Error(`Fp.fromBytes: expected ${M}, got ${X.length}`);return J?M8(X):X0(X)}});return Object.freeze(W)}function w$($){if(typeof $!=="bigint")throw new Error("field order must be bigint");const q=$.toString(2).length;return Math.ceil(q/8)}function S8($){const q=w$($);return q+Math.ceil(q/2)}function N$($,q,J=!1){const G=$.length,Q=w$(q),M=S8(q);if(G<16||G<M||G>1024)throw new Error(`expected ${M}-1024 bytes of input, got ${G}`);const Y=J?X0($):M8($),W=h(Y,q-b)+b;return J?Y8(W,Q):j0(W,Q)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */var v=BigInt(0),b=BigInt(1),B0=BigInt(2),bJ=BigInt(3),N8=BigInt(4),O$=BigInt(5),H$=BigInt(8),FJ=BigInt(9),gJ=BigInt(16);var cJ=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function L$($,q){const J=(Q,M)=>{const Y=M.negate();return Q?Y:M},G=(Q)=>{const M=Math.ceil(q/Q)+1,Y=2**(Q-1);return{windows:M,windowSize:Y}};return{constTimeNegate:J,unsafeLadder(Q,M){let Y=$.ZERO,W=Q;while(M>uJ){if(M&B8)Y=Y.add(W);W=W.double(),M>>=B8}return Y},precomputeWindow(Q,M){const{windows:Y,windowSize:W}=G(M),X=[];let I=Q,z=I;for(let K=0;K<Y;K++){z=I,X.push(z);for(let R=1;R<W;R++)z=z.add(I),X.push(z);I=z.double()}return X},wNAF(Q,M,Y){const{windows:W,windowSize:X}=G(Q);let{ZERO:I,BASE:z}=$;const K=BigInt(2**Q-1),R=2**Q,w=BigInt(Q);for(let Z=0;Z<W;Z++){const U=Z*X;let V=Number(Y&K);if(Y>>=w,V>X)V-=R,Y+=B8;const T=U,N=U+Math.abs(V)-1,B=Z%2!==0,L=V<0;if(V===0)z=z.add(J(B,M[T]));else I=I.add(J(L,M[N]))}return{p:I,f:z}},wNAFCached(Q,M,Y,W){const X=Q._WINDOW_SIZE||1;let I=M.get(Q);if(!I){if(I=this.precomputeWindow(Q,X),X!==1)M.set(Q,W(I))}return this.wNAF(X,I,Y)}}}function P8($){return L8($.Fp),O0($,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...C8($.n,$.nBitLength),...$,...{p:$.Fp.ORDER}})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */var uJ=BigInt(0),B8=BigInt(1);var dJ=function($){const q=P8($);O0(q,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});const{endo:J,Fp:G,a:Q}=q;if(J){if(!G.eql(Q,G.ZERO))throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");if(typeof J!=="object"||typeof J.beta!=="bigint"||typeof J.splitScalar!=="function")throw new Error("Expected endomorphism with beta: bigint and splitScalar: function")}return Object.freeze({...q})};function nJ($){const q=dJ($),{Fp:J}=q,G=q.toBytes||((Z,U,V)=>{const T=U.toAffine();return b0(Uint8Array.from([4]),J.toBytes(T.x),J.toBytes(T.y))}),Q=q.fromBytes||((Z)=>{const U=Z.subarray(1),V=J.fromBytes(U.subarray(0,J.BYTES)),T=J.fromBytes(U.subarray(J.BYTES,2*J.BYTES));return{x:V,y:T}});function M(Z){const{a:U,b:V}=q,T=J.sqr(Z),N=J.mul(T,Z);return J.add(J.add(N,J.mul(Z,U)),V)}if(!J.eql(J.sqr(q.Gy),M(q.Gx)))throw new Error("bad generator point: equation left != right");function Y(Z){return typeof Z==="bigint"&&W0<Z&&Z<q.n}function W(Z){if(!Y(Z))throw new Error("Expected valid bigint: 0 < bigint < curve.n")}function X(Z){const{allowedPrivateKeyLengths:U,nByteLength:V,wrapPrivateKey:T,n:N}=q;if(U&&typeof Z!=="bigint"){if(Z instanceof Uint8Array)Z=C0(Z);if(typeof Z!=="string"||!U.includes(Z.length))throw new Error("Invalid key");Z=Z.padStart(V*2,"0")}let B;try{B=typeof Z==="bigint"?Z:X0(d("private key",Z,V))}catch(L){throw new Error(`private key must be ${V} bytes, hex or bigint, not ${typeof Z}`)}if(T)B=h(B,N);return W(B),B}const I=new Map;function z(Z){if(!(Z instanceof K))throw new Error("ProjectivePoint expected")}class K{constructor(Z,U,V){if(this.px=Z,this.py=U,this.pz=V,Z==null||!J.isValid(Z))throw new Error("x required");if(U==null||!J.isValid(U))throw new Error("y required");if(V==null||!J.isValid(V))throw new Error("z required")}static fromAffine(Z){const{x:U,y:V}=Z||{};if(!Z||!J.isValid(U)||!J.isValid(V))throw new Error("invalid affine point");if(Z instanceof K)throw new Error("projective point not allowed");const T=(N)=>J.eql(N,J.ZERO);if(T(U)&&T(V))return K.ZERO;return new K(U,V,J.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(Z){const U=J.invertBatch(Z.map((V)=>V.pz));return Z.map((V,T)=>V.toAffine(U[T])).map(K.fromAffine)}static fromHex(Z){const U=K.fromAffine(Q(d("pointHex",Z)));return U.assertValidity(),U}static fromPrivateKey(Z){return K.BASE.multiply(X(Z))}_setWindowSize(Z){this._WINDOW_SIZE=Z,I.delete(this)}assertValidity(){if(this.is0()){if(q.allowInfinityPoint&&!J.is0(this.py))return;throw new Error("bad point: ZERO")}const{x:Z,y:U}=this.toAffine();if(!J.isValid(Z)||!J.isValid(U))throw new Error("bad point: x or y not FE");const V=J.sqr(U),T=M(Z);if(!J.eql(V,T))throw new Error("bad point: equation left != right");if(!this.isTorsionFree())throw new Error("bad point: not in prime-order subgroup")}hasEvenY(){const{y:Z}=this.toAffine();if(J.isOdd)return!J.isOdd(Z);throw new Error("Field doesn't support isOdd")}equals(Z){z(Z);const{px:U,py:V,pz:T}=this,{px:N,py:B,pz:L}=Z,O=J.eql(J.mul(U,L),J.mul(N,T)),H=J.eql(J.mul(V,L),J.mul(B,T));return O&&H}negate(){return new K(this.px,J.neg(this.py),this.pz)}double(){const{a:Z,b:U}=q,V=J.mul(U,C$),{px:T,py:N,pz:B}=this;let{ZERO:L,ZERO:O,ZERO:H}=J,C=J.mul(T,T),a=J.mul(N,N),f=J.mul(B,B),E=J.mul(T,N);return E=J.add(E,E),H=J.mul(T,B),H=J.add(H,H),L=J.mul(Z,H),O=J.mul(V,f),O=J.add(L,O),L=J.sub(a,O),O=J.add(a,O),O=J.mul(L,O),L=J.mul(E,L),H=J.mul(V,H),f=J.mul(Z,f),E=J.sub(C,f),E=J.mul(Z,E),E=J.add(E,H),H=J.add(C,C),C=J.add(H,C),C=J.add(C,f),C=J.mul(C,E),O=J.add(O,C),f=J.mul(N,B),f=J.add(f,f),C=J.mul(f,E),L=J.sub(L,C),H=J.mul(f,a),H=J.add(H,H),H=J.add(H,H),new K(L,O,H)}add(Z){z(Z);const{px:U,py:V,pz:T}=this,{px:N,py:B,pz:L}=Z;let{ZERO:O,ZERO:H,ZERO:C}=J;const a=q.a,f=J.mul(q.b,C$);let E=J.mul(U,N),l=J.mul(V,B),p=J.mul(T,L),Z0=J.add(U,V),m=J.add(N,B);Z0=J.mul(Z0,m),m=J.add(E,l),Z0=J.sub(Z0,m),m=J.add(U,T);let D=J.add(N,L);return m=J.mul(m,D),D=J.add(E,p),m=J.sub(m,D),D=J.add(V,T),O=J.add(B,L),D=J.mul(D,O),O=J.add(l,p),D=J.sub(D,O),C=J.mul(a,m),O=J.mul(f,p),C=J.add(O,C),O=J.sub(l,C),C=J.add(l,C),H=J.mul(O,C),l=J.add(E,E),l=J.add(l,E),p=J.mul(a,p),m=J.mul(f,m),l=J.add(l,p),p=J.sub(E,p),p=J.mul(a,p),m=J.add(m,p),E=J.mul(l,m),H=J.add(H,E),E=J.mul(D,m),O=J.mul(Z0,O),O=J.sub(O,E),E=J.mul(Z0,l),C=J.mul(D,C),C=J.add(C,E),new K(O,H,C)}subtract(Z){return this.add(Z.negate())}is0(){return this.equals(K.ZERO)}wNAF(Z){return w.wNAFCached(this,I,Z,(U)=>{const V=J.invertBatch(U.map((T)=>T.pz));return U.map((T,N)=>T.toAffine(V[N])).map(K.fromAffine)})}multiplyUnsafe(Z){const U=K.ZERO;if(Z===W0)return U;if(W(Z),Z===n)return this;const{endo:V}=q;if(!V)return w.unsafeLadder(this,Z);let{k1neg:T,k1:N,k2neg:B,k2:L}=V.splitScalar(Z),O=U,H=U,C=this;while(N>W0||L>W0){if(N&n)O=O.add(C);if(L&n)H=H.add(C);C=C.double(),N>>=n,L>>=n}if(T)O=O.negate();if(B)H=H.negate();return H=new K(J.mul(H.px,V.beta),H.py,H.pz),O.add(H)}multiply(Z){W(Z);let U=Z,V,T;const{endo:N}=q;if(N){const{k1neg:B,k1:L,k2neg:O,k2:H}=N.splitScalar(U);let{p:C,f:a}=this.wNAF(L),{p:f,f:E}=this.wNAF(H);C=w.constTimeNegate(B,C),f=w.constTimeNegate(O,f),f=new K(J.mul(f.px,N.beta),f.py,f.pz),V=C.add(f),T=a.add(E)}else{const{p:B,f:L}=this.wNAF(U);V=B,T=L}return K.normalizeZ([V,T])[0]}multiplyAndAddUnsafe(Z,U,V){const T=K.BASE,N=(L,O)=>O===W0||O===n||!L.equals(T)?L.multiplyUnsafe(O):L.multiply(O),B=N(this,U).add(N(Z,V));return B.is0()?void 0:B}toAffine(Z){const{px:U,py:V,pz:T}=this,N=this.is0();if(Z==null)Z=N?J.ONE:J.inv(T);const B=J.mul(U,Z),L=J.mul(V,Z),O=J.mul(T,Z);if(N)return{x:J.ZERO,y:J.ZERO};if(!J.eql(O,J.ONE))throw new Error("invZ was invalid");return{x:B,y:L}}isTorsionFree(){const{h:Z,isTorsionFree:U}=q;if(Z===n)return!0;if(U)return U(K,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:Z,clearCofactor:U}=q;if(Z===n)return this;if(U)return U(K,this);return this.multiplyUnsafe(q.h)}toRawBytes(Z=!0){return this.assertValidity(),G(K,this,Z)}toHex(Z=!0){return C0(this.toRawBytes(Z))}}K.BASE=new K(q.Gx,q.Gy,J.ONE),K.ZERO=new K(J.ZERO,J.ONE,J.ZERO);const R=q.nBitLength,w=L$(K,q.endo?Math.ceil(R/2):R);return{CURVE:q,ProjectivePoint:K,normPrivateKeyToScalar:X,weierstrassEquation:M,isWithinCurveOrder:Y}}var aJ=function($){const q=P8($);return O0(q,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...q})};function S$($){const q=aJ($),{Fp:J,n:G}=q,Q=J.BYTES+1,M=2*J.BYTES+1;function Y(D){return W0<D&&D<J.ORDER}function W(D){return h(D,G)}function X(D){return X8(D,G)}const{ProjectivePoint:I,normPrivateKeyToScalar:z,weierstrassEquation:K,isWithinCurveOrder:R}=nJ({...q,toBytes(D,j,P){const k=j.toAffine(),A=J.toBytes(k.x),g=b0;if(P)return g(Uint8Array.from([j.hasEvenY()?2:3]),A);else return g(Uint8Array.from([4]),A,J.toBytes(k.y))},fromBytes(D){const j=D.length,P=D[0],k=D.subarray(1);if(j===Q&&(P===2||P===3)){const A=X0(k);if(!Y(A))throw new Error("Point is not on curve");const g=K(A);let r=J.sqrt(g);const u=(r&n)===n;if((P&1)===1!==u)r=J.neg(r);return{x:A,y:r}}else if(j===M&&P===4){const A=J.fromBytes(k.subarray(0,J.BYTES)),g=J.fromBytes(k.subarray(J.BYTES,2*J.BYTES));return{x:A,y:g}}else throw new Error(`Point of length ${j} was invalid. Expected ${Q} compressed bytes or ${M} uncompressed bytes`)}}),w=(D)=>C0(j0(D,q.nByteLength));function Z(D){const j=G>>n;return D>j}function U(D){return Z(D)?W(-D):D}const V=(D,j,P)=>X0(D.slice(j,P));class T{constructor(D,j,P){this.r=D,this.s=j,this.recovery=P,this.assertValidity()}static fromCompact(D){const j=q.nByteLength;return D=d("compactSignature",D,j*2),new T(V(D,0,j),V(D,j,2*j))}static fromDER(D){const{r:j,s:P}=P0.toSig(d("DER",D));return new T(j,P)}assertValidity(){if(!R(this.r))throw new Error("r must be 0 < r < CURVE.n");if(!R(this.s))throw new Error("s must be 0 < s < CURVE.n")}addRecoveryBit(D){return new T(this.r,this.s,D)}recoverPublicKey(D){const{r:j,s:P,recovery:k}=this,A=C(d("msgHash",D));if(k==null||![0,1,2,3].includes(k))throw new Error("recovery id invalid");const g=k===2||k===3?j+q.n:j;if(g>=J.ORDER)throw new Error("recovery id 2 or 3 invalid");const r=(k&1)===0?"02":"03",u=I.fromHex(r+w(g)),G0=X(g),H0=W(-A*G0),E0=W(P*G0),R0=I.BASE.multiplyAndAddUnsafe(u,H0,E0);if(!R0)throw new Error("point at infinify");return R0.assertValidity(),R0}hasHighS(){return Z(this.s)}normalizeS(){return this.hasHighS()?new T(this.r,W(-this.s),this.recovery):this}toDERRawBytes(){return S0(this.toDERHex())}toDERHex(){return P0.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return S0(this.toCompactHex())}toCompactHex(){return w(this.r)+w(this.s)}}const N={isValidPrivateKey(D){try{return z(D),!0}catch(j){return!1}},normPrivateKeyToScalar:z,randomPrivateKey:()=>{const D=S8(q.n);return N$(q.randomBytes(D),q.n)},precompute(D=8,j=I.BASE){return j._setWindowSize(D),j.multiply(BigInt(3)),j}};function B(D,j=!0){return I.fromPrivateKey(D).toRawBytes(j)}function L(D){const j=D instanceof Uint8Array,P=typeof D==="string",k=(j||P)&&D.length;if(j)return k===Q||k===M;if(P)return k===2*Q||k===2*M;if(D instanceof I)return!0;return!1}function O(D,j,P=!0){if(L(D))throw new Error("first arg must be private key");if(!L(j))throw new Error("second arg must be public key");return I.fromHex(j).multiply(z(D)).toRawBytes(P)}const H=q.bits2int||function(D){const j=X0(D),P=D.length*8-q.nBitLength;return P>0?j>>BigInt(P):j},C=q.bits2int_modN||function(D){return W(H(D))},a=l0(q.nBitLength);function f(D){if(typeof D!=="bigint")throw new Error("bigint expected");if(!(W0<=D&&D<a))throw new Error(`bigint expected < 2^${q.nBitLength}`);return j0(D,q.nByteLength)}function E(D,j,P=l){if(["recovered","canonical"].some((w0)=>(w0 in P)))throw new Error("sign() legacy options not supported");const{hash:k,randomBytes:A}=q;let{lowS:g,prehash:r,extraEntropy:u}=P;if(g==null)g=!0;if(D=d("msgHash",D),r)D=d("prehashed msgHash",k(D));const G0=C(D),H0=z(j),E0=[f(H0),f(G0)];if(u!=null){const w0=u===!0?A(J.BYTES):u;E0.push(d("extraEntropy",w0))}const R0=b0(...E0),u0=G0;function D8(w0){const x0=H(w0);if(!R(x0))return;const y8=X(x0),e=I.BASE.multiply(x0).toAffine(),f0=W(e.x);if(f0===W0)return;const d0=W(y8*W(u0+f0*H0));if(d0===W0)return;let m8=(e.x===f0?0:2)|Number(e.y&n),c8=d0;if(g&&Z(d0))c8=U(d0),m8^=1;return new T(f0,c8,m8)}return{seed:R0,k2sig:D8}}const l={lowS:q.lowS,prehash:!1},p={lowS:q.lowS,prehash:!1};function Z0(D,j,P=l){const{seed:k,k2sig:A}=E(D,j,P),g=q;return R8(g.hash.outputLen,g.nByteLength,g.hmac)(k,A)}I.BASE._setWindowSize(8);function m(D,j,P,k=p){const A=D;if(j=d("msgHash",j),P=d("publicKey",P),("strict"in k))throw new Error("options.strict was renamed to lowS");const{lowS:g,prehash:r}=k;let u=void 0,G0;try{if(typeof A==="string"||A instanceof Uint8Array)try{u=T.fromDER(A)}catch(e){if(!(e instanceof P0.Err))throw e;u=T.fromCompact(A)}else if(typeof A==="object"&&typeof A.r==="bigint"&&typeof A.s==="bigint"){const{r:e,s:f0}=A;u=new T(e,f0)}else throw new Error("PARSE");G0=I.fromHex(P)}catch(e){if(e.message==="PARSE")throw new Error("signature must be Signature instance, Uint8Array or hex string");return!1}if(g&&u.hasHighS())return!1;if(r)j=q.hash(j);const{r:H0,s:E0}=u,R0=C(j),u0=X(E0),D8=W(R0*u0),w0=W(H0*u0),x0=I.BASE.multiplyAndAddUnsafe(G0,D8,w0)?.toAffine();if(!x0)return!1;return W(x0.x)===H0}return{CURVE:q,getPublicKey:B,getSharedSecret:O,sign:Z0,verify:m,ProjectivePoint:I,Signature:T,utils:N}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */var{bytesToNumberBE:iJ,hexToBytes:oJ}=w8,P0={Err:class $ extends Error{constructor(q=""){super(q)}},_parseInt($){const{Err:q}=P0;if($.length<2||$[0]!==2)throw new q("Invalid signature integer tag");const J=$[1],G=$.subarray(2,J+2);if(!J||G.length!==J)throw new q("Invalid signature integer: wrong length");if(G[0]&128)throw new q("Invalid signature integer: negative");if(G[0]===0&&!(G[1]&128))throw new q("Invalid signature integer: unnecessary leading zero");return{d:iJ(G),l:$.subarray(J+2)}},toSig($){const{Err:q}=P0,J=typeof $==="string"?oJ($):$;if(!(J instanceof Uint8Array))throw new Error("ui8a expected");let G=J.length;if(G<2||J[0]!=48)throw new q("Invalid signature tag");if(J[1]!==G-2)throw new q("Invalid signature: incorrect length");const{d:Q,l:M}=P0._parseInt(J.subarray(2)),{d:Y,l:W}=P0._parseInt(M);if(W.length)throw new q("Invalid signature: left bytes after parsing");return{r:Q,s:Y}},hexFromSig($){const q=(I)=>Number.parseInt(I[0],16)&8?"00"+I:I,J=(I)=>{const z=I.toString(16);return z.length&1?`0${z}`:z},G=q(J($.s)),Q=q(J($.r)),M=G.length/2,Y=Q.length/2,W=J(M),X=J(Y);return`30${J(Y+M+4)}02${X}${Q}02${W}${G}`}},W0=BigInt(0),n=BigInt(1),QG=BigInt(2),C$=BigInt(3),MG=BigInt(4);function rJ($){return{hash:$,hmac:(q,...J)=>V8($,q,r8(...J)),randomBytes:t8}}function B$($,q){const J=(G)=>S$({...$,...rJ(G)});return Object.freeze({...J(q),create:J})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */var sJ=function($){const q=x$,J=BigInt(3),G=BigInt(6),Q=BigInt(11),M=BigInt(22),Y=BigInt(23),W=BigInt(44),X=BigInt(88),I=$*$*$%q,z=I*I*$%q,K=i(z,J,q)*z%q,R=i(K,J,q)*z%q,w=i(R,E8,q)*I%q,Z=i(w,Q,q)*w%q,U=i(Z,M,q)*Z%q,V=i(U,W,q)*U%q,T=i(V,X,q)*V%q,N=i(T,W,q)*U%q,B=i(N,J,q)*z%q,L=i(B,Y,q)*Z%q,O=i(L,G,q)*I%q,H=i(O,E8,q);if(!x8.eql(x8.sqr(H),$))throw new Error("Cannot find square root");return H};/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */var x$=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),P$=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),tJ=BigInt(1),E8=BigInt(2),E$=($,q)=>($+q/E8)/q,x8=R$(x$,void 0,void 0,{sqrt:sJ}),I0=B$({a:BigInt(0),b:BigInt(7),Fp:x8,n:P$,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:($)=>{const q=P$,J=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),G=-tJ*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),Q=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),M=J,Y=BigInt("0x100000000000000000000000000000000"),W=E$(M*$,q),X=E$(-G*$,q);let I=h($-W*J-X*Q,q),z=h(-W*G-X*M,q);const K=I>Y,R=z>Y;if(K)I=q-I;if(R)z=q-z;if(I>Y||z>Y)throw new Error("splitScalar: Endomorphism failed, k="+$);return{k1neg:K,k1:I,k2neg:R,k2:z}}}},e8),UG=BigInt(0);var VG=I0.ProjectivePoint;var W8="0x0000000000000000000000000000000000000000000000000000000000000000";var f8=`\x19Ethereum Signed Message:
`;var F$=function($){return a0(t0($),32)},f$=BigInt(0),k$=BigInt(1),A$=BigInt(2),_$=BigInt(27),b$=BigInt(28),I8=BigInt(35),F0={};class o{#$;#q;#G;#J;get r(){return this.#$}set r($){S(M0($)===32,"invalid r","value",$),this.#$=_($)}get s(){return this.#q}set s($){S(M0($)===32,"invalid s","value",$);const q=_($);S(parseInt(q.substring(0,3))<8,"non-canonical s","value",q),this.#q=q}get v(){return this.#G}set v($){const q=K0($,"value");S(q===27||q===28,"invalid v","v",$),this.#G=q}get networkV(){return this.#J}get legacyChainId(){const $=this.networkV;if($==null)return null;return o.getChainId($)}get yParity(){return this.v===27?0:1}get yParityAndS(){const $=y(this.s);if(this.yParity)$[0]|=128;return _($)}get compactSerialized(){return Q0([this.r,this.yParityAndS])}get serialized(){return Q0([this.r,this.s,this.yParity?"0x1c":"0x1b"])}constructor($,q,J,G){n0($,F0,"Signature"),this.#$=q,this.#q=J,this.#G=G,this.#J=null}[Symbol.for("nodejs.util.inspect.custom")](){return`Signature { r: "${this.r}", s: "${this.s}", yParity: ${this.yParity}, networkV: ${this.networkV} }`}clone(){const $=new o(F0,this.r,this.s,this.v);if(this.networkV)$.#J=this.networkV;return $}toJSON(){const $=this.networkV;return{_type:"signature",networkV:$!=null?$.toString():null,r:this.r,s:this.s,v:this.v}}static getChainId($){const q=D0($,"v");if(q==_$||q==b$)return f$;return S(q>=I8,"invalid EIP-155 v","v",$),(q-I8)/A$}static getChainIdV($,q){return D0($)*A$+BigInt(35+q-27)}static getNormalizedV($){const q=D0($);if(q===f$||q===_$)return 27;if(q===k$||q===b$)return 28;return S(q>=I8,"invalid v","v",$),q&k$?27:28}static from($){function q(X,I){S(X,I,"signature",$)}if($==null)return new o(F0,W8,W8,27);if(typeof $==="string"){const X=y($,"signature");if(X.length===64){const I=_(X.slice(0,32)),z=X.slice(32,64),K=z[0]&128?28:27;return z[0]&=127,new o(F0,I,_(z),K)}if(X.length===65){const I=_(X.slice(0,32)),z=X.slice(32,64);q((z[0]&128)===0,"non-canonical s");const K=o.getNormalizedV(X[64]);return new o(F0,I,_(z),K)}q(!1,"invalid raw signature length")}if($ instanceof o)return $.clone();const J=$.r;q(J!=null,"missing r");const G=F$(J),Q=function(X,I){if(X!=null)return F$(X);if(I!=null){q(A0(I,32),"invalid yParityAndS");const z=y(I);return z[0]&=127,_(z)}q(!1,"missing s")}($.s,$.yParityAndS);q((y(Q)[0]&128)==0,"non-canonical s");const{networkV:M,v:Y}=function(X,I,z){if(X!=null){const K=D0(X);return{networkV:K>=I8?K:void 0,v:o.getNormalizedV(K)}}if(I!=null)return q(A0(I,32),"invalid yParityAndS"),{v:y(I)[0]&128?28:27};if(z!=null){switch(K0(z,"sig.yParity")){case 0:return{v:27};case 1:return{v:28}}q(!1,"invalid yParity")}q(!1,"missing v")}($.v,$.yParityAndS,$.yParity),W=new o(F0,G,Q,Y);if(M)W.#J=M;return q($.yParity==null||K0($.yParity,"sig.yParity")===W.yParity,"yParity mismatch"),q($.yParityAndS==null||$.yParityAndS===W.yParityAndS,"yParityAndS mismatch"),W}}class J0{#$;constructor($){S(M0($)===32,"invalid private key","privateKey","[REDACTED]"),this.#$=_($)}get privateKey(){return this.#$}get publicKey(){return J0.computePublicKey(this.#$)}get compressedPublicKey(){return J0.computePublicKey(this.#$,!0)}sign($){S(M0($)===32,"invalid digest length","digest",$);const q=I0.sign(z0($),z0(this.#$),{lowS:!0});return o.from({r:y0(q.r,32),s:y0(q.s,32),v:q.recovery?28:27})}computeSharedSecret($){const q=J0.computePublicKey($);return _(I0.getSharedSecret(z0(this.#$),y(q),!1))}static computePublicKey($,q){let J=y($,"key");if(J.length===32){const Q=I0.getPublicKey(J,!!q);return _(Q)}if(J.length===64){const Q=new Uint8Array(65);Q[0]=4,Q.set(J,1),J=Q}const G=I0.ProjectivePoint.fromHex(J);return _(G.toRawBytes(q))}static recoverPublicKey($,q){S(M0($)===32,"invalid digest length","digest",$);const J=o.from(q);let G=I0.Signature.fromCompact(z0(Q0([J.r,J.s])));G=G.addRecoveryBit(J.yParity);const Q=G.recoverPublicKey(z0($));return S(Q!=null,"invalid signature for digest","signature",q),"0x"+Q.toHex(!1)}static addPoints($,q,J){const G=I0.ProjectivePoint.fromHex(J0.computePublicKey($).substring(2)),Q=I0.ProjectivePoint.fromHex(J0.computePublicKey(q).substring(2));return"0x"+G.add(Q).toHex(!!J)}}var g$=function($){$=$.toLowerCase();const q=$.substring(2).split(""),J=new Uint8Array(40);for(let Q=0;Q<40;Q++)J[Q]=q[Q].charCodeAt(0);const G=y(s(J));for(let Q=0;Q<40;Q+=2){if(G[Q>>1]>>4>=8)q[Q]=q[Q].toUpperCase();if((G[Q>>1]&15)>=8)q[Q+1]=q[Q+1].toUpperCase()}return"0x"+q.join("")},Jq=function($){$=$.toUpperCase(),$=$.substring(4)+$.substring(0,2)+"00";let q=$.split("").map((G)=>{return k8[G]}).join("");while(q.length>=v$){let G=q.substring(0,v$);q=parseInt(G,10)%97+q.substring(G.length)}let J=String(98-parseInt(q,10)%97);while(J.length<2)J="0"+J;return J},Gq=function($){$=$.toLowerCase();let q=eJ;for(let J=0;J<$.length;J++)q=q*$q+qq[$[J]];return q};function c($){if(S(typeof $==="string","invalid address","address",$),$.match(/^(0x)?[0-9a-fA-F]{40}$/)){if(!$.startsWith("0x"))$="0x"+$;const q=g$($);return S(!$.match(/([A-F].*[a-f])|([a-f].*[A-F])/)||q===$,"bad address checksum","address",$),q}if($.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)){S($.substring(2,4)===Jq($),"bad icap checksum","address",$);let q=Gq($.substring(4)).toString(16);while(q.length<40)q="0"+q;return g$("0x"+q)}S(!1,"invalid address","address",$)}var eJ=BigInt(0),$q=BigInt(36),k8={};for(let $=0;$<10;$++)k8[String($)]=String($);for(let $=0;$<26;$++)k8[String.fromCharCode(65+$)]=String(10+$);var v$=15,qq=function(){const $={};for(let q=0;q<36;q++){const J="0123456789abcdefghijklmnopqrstuvwxyz"[q];$[J]=BigInt(q)}return $}();function y$($){let q;if(typeof $==="string")q=J0.computePublicKey($,!1);else q=$.publicKey;return c(s("0x"+q.substring(4)).substring(26))}function A8($,q){return y$(J0.recoverPublicKey($,q))}function _8($){if(typeof $==="string")$=U0($);return s(Q0([U0(f8),U0(String($.length)),$]))}function Z8($,q){const J=_8($);return A8(J,q)}class b8{constructor($,q,J,G=[]){if(!$)throw new Error("SecurityManager: localUserEthAddress es requerido.");try{this.localUserEthAddress=c($)}catch(Q){throw new Error(`SecurityManager: localUserEthAddress '${$}' no es una direcci\xF3n de Ethereum v\xE1lida.`)}if(!q)throw new Error("SecurityManager: dbInstance (GraphDB) es requerida.");if(!J||typeof J.mapChangeTypeToRbacAction!=="function"||typeof J.can!=="function")throw new Error("SecurityManager: rbacFunctions con m\xE9todos 'can' y 'mapChangeTypeToRbacAction' es requerido.");this.gdb=q,this.rbac=J,this.superAdminEthereumAddresses=(G||[]).map((Q)=>{try{return c(Q)}catch(M){return console.warn(`SM: Direcci\xF3n superadmin inv\xE1lida omitida: ${Q}`),null}}).filter(Boolean),console.log(`SM: SecurityManager inicializado para ${this.localUserEthAddress}. SuperAdmins: ${this.superAdminEthereumAddresses.length}`)}_canonicalizeDataForSigning($){return JSON.stringify($,Object.keys($).sort())}async signOutgoingOperations($){if(!this.localUserEthAddress)return console.warn("SM: Usuario ETH local no establecido. No se pueden firmar."),[];if(!window.ethereum||!window.ethereum.request)return console.error("SM: MetaMask no detectado. No se pueden firmar."),[];const q=[];for(let J of $){const G={...J,originUser:this.localUserEthAddress},Q=this._canonicalizeDataForSigning(G),M=_(U0(Q));try{const Y=await window.ethereum.request({method:"personal_sign",params:[M,this.localUserEthAddress]});q.push({...G,originEthAddress:this.localUserEthAddress,signature:Y})}catch(Y){if(console.error(`SM: Error al firmar op para ${this.localUserEthAddress}:`,Y.message),Y.code===4001)console.warn("SM: Usuario rechaz\xF3 firma.")}}return q}async verifyIncomingOperations($){const q=[];for(let J of $){let G=!1,Q=null,M=null;if(J.signature&&J.originEthAddress){const{signature:Y,originEthAddress:W,...X}=J;M=X;try{Q=c(W)}catch(I){console.warn(`SM: originEthAddress '${W}' en op entrante no es v\xE1lida. Descartada.`)}if(Q&&M){const I=this._canonicalizeDataForSigning(M);try{const z=Z8(I,Y);if(c(z)===Q){console.log(`SM: Firma V\xC1LIDA de ${Q}. Verificando permisos...`);const K=M.type;if(K==="put"&&M.id?.startsWith("user:")&&M.value?.role)if(this.superAdminEthereumAddresses.includes(Q))G=!0,console.log(`SM: 'assignRole' P2P OK para superadmin ${Q}.`);else console.warn(`SM: 'assignRole' P2P por ${Q} (NO superadmin). Descartado.`);else{const w=(await this.gdb.get(`user:${Q}`)).result;if(w?.value?.role)if(w.value.expiresAt&&new Date(w.value.expiresAt)<new Date)console.warn(`SM: Rol para ${Q} caducado. Op '${K}' descartada.`);else{const Z=this.rbac.mapChangeTypeToRbacAction(K,M);if(this.rbac.can(w.value.role,Z))G=!0,console.log(`SM: Permiso RBAC OK para ${Q} (rol ${w.value.role}) para '${Z}'.`);else console.warn(`SM: ${Q} (rol ${w.value.role}) SIN permiso RBAC para '${Z}'. Descartado.`)}else console.warn(`SM: Sin nodo/rol en GDB para ${Q} para op '${K}'. Descartado.`)}}else console.warn(`SM: Firma INV\xC1LIDA o no coincide. Recuperada: ${c(z)}, Esperada: ${Q}. Descartada.`)}catch(z){console.error("SM: Error verificando firma o permisos:",z.message,J)}}}else console.warn("SM: Op P2P sin firma o sin originEthAddress. Descartada:",J);if(G&&M)q.push(M)}return{validatedOperations:q,unverifiedOperations:[]}}}function yQ($){if(typeof $!=="object"||$===null)throw new Error("RBAC: Los roles personalizados deben ser un objeto v\xE1lido.");g0=$,console.log("RBAC: Roles personalizados establecidos.")}function v8($,q,J=new Set){const G=g0;if(!G[$])return!1;if(J.has($))return!1;if(J.add($),G[$].can&&G[$].can.includes(q))return!0;if(G[$].inherits&&Array.isArray(G[$].inherits))return G[$].inherits.some((Q)=>v8(Q,q,new Set(J)));return!1}function mQ($){if(typeof $==="function")z8=$,console.log("RBAC: Callback de cambio de estado de seguridad configurado.");else z8=null,console.warn("RBAC: Se intent\xF3 configurar un callback de cambio de estado no v\xE1lido.")}var c$=function(){if(z8)z8({isActive:q0,activeAddress:x})};async function m$($){console.log("RBAC: MetaMask accountsChanged detectado:",$);const q=$&&$.length>0?$[0]:null;let J=null;if(q)try{J=c(q)}catch(G){console.error("RBAC: Direcci\xF3n inv\xE1lida recibida de accountsChanged:",q,G)}if(!J){if(q0)console.log("RBAC: Desconectando seguridad debido a cambio de cuenta a ninguna o inv\xE1lida."),await g8()}else if(J!==x){if(console.log(`RBAC: Cuenta de MetaMask cambiada a ${J}. Reiniciando sesi\xF3n de seguridad.`),F){if(q0)await g8();await Yq(F,J,v0)}else if(console.warn("RBAC: currentGdbInstance no est\xE1 disponible para reinicializar seguridad tras cambio de cuenta."),q0)await g8()}else if(J===x&&!q0)console.log("RBAC: Misma cuenta detectada, pero la seguridad de la app estaba inactiva. No se tomar\xE1 acci\xF3n autom\xE1tica.");else console.log("RBAC: accountsChanged no result\xF3 en un cambio de estado de seguridad necesario.")}var Mq=function(){if(F8&&window.ethereum&&window.ethereum.removeListener)window.ethereum.removeListener("accountsChanged",m$);if(window.ethereum&&window.ethereum.on)window.ethereum.on("accountsChanged",m$),F8=!0,console.log("RBAC: Listener para 'accountsChanged' de MetaMask configurado/reconfigurado.");else console.warn("RBAC: window.ethereum no disponible para configurar listeners de MetaMask."),F8=!1};async function Yq($,q,J=[]){if(!$)throw console.error("RBAC Error: Se requiere instancia de GraphDB para inicializar la seguridad."),new Error("RBAC: Se requiere instancia de GraphDB.");if(!q)throw console.error("RBAC Error: No se proporcion\xF3 direcci\xF3n ETH para inicializar la seguridad."),new Error("RBAC: No se proporcion\xF3 direcci\xF3n ETH.");F=$;let G;try{G=c(q)}catch(X){throw console.error(`RBAC Error: Direcci\xF3n ETH '${q}' inv\xE1lida.`,X),new Error(`RBAC: Direcci\xF3n ETH '${q}' inv\xE1lida.`)}if(x=G,v0=(J||[]).map((X)=>{try{return c(X)}catch(I){return console.warn(`RBAC: Direcci\xF3n superadmin inv\xE1lida omitida: ${X}`),null}}).filter((X)=>X!==null),console.log(`RBAC: Inicializando seguridad para ETH: ${x}`),p0=new b8(x,F,{can:v8,mapChangeTypeToRbacAction:Zq},v0),F.securityManager=p0,F.sendData&&!F._originalSendDataByRBAC)F._originalSendDataByRBAC=F.sendData.bind(F),F.sendData=async(X)=>{if(!p0)return F._originalSendDataByRBAC(X);const I=await p0.signOutgoingOperations(X);return F._originalSendDataByRBAC(I)},console.log("RBAC: GDB sendData envuelto para firmas con MetaMask.");const Q=`user:${x}`,M=await F.get(Q),Y=M.result&&M.result.value||{};let W=Y.role;if(!W)W=Object.keys(g0).includes("user")?"user":Object.keys(g0)[Object.keys(g0).length-1];if(Y.role!==W||!M.result||Y.ethAddress!==x)await F.put({...Y,ethAddress:x,role:W},Q),console.log(`RBAC: Nodo para ETH Address ${x} (rol '${W}') asegurado en GDB.`);else console.log(`RBAC: Nodo para ETH Address ${x} ya existe y est\xE1 actualizado.`);return q0=!0,Mq(),c$(),console.log(`RBAC: Seguridad P2P (MetaMask) configurada y activa para ${x}.`),x}async function g8(){if(console.log("RBAC: Solicitando desactivaci\xF3n de seguridad P2P (MetaMask)."),F&&F._originalSendDataByRBAC)F.sendData=F._originalSendDataByRBAC,delete F._originalSendDataByRBAC,console.log("RBAC: GDB sendData restaurado a original.");if(F)F.securityManager=null;p0=null,x=null,q0=!1,c$(),console.log("RBAC: Seguridad desactivada.")}async function cQ($,q,J,G=null){if(!$||!q||!J)throw new Error("RBAC assignRole: db, targetUserEthAddress, y role son requeridos.");await $.ready;let Q;try{Q=c(q)}catch(I){throw new Error(`RBAC assignRole: targetUserEthAddress '${q}' no es una direcci\xF3n ETH v\xE1lida.`)}if(!g0[J])throw new Error(`RBAC: El rol '${J}' no existe.`);const M=`user:${Q}`,Y=await $.get(M),X={...Y.result&&Y.result.value||{},ethAddress:Q,role:J,assignedByEthAddress:x,expiresAt:G?new Date(G).toISOString():null};await $.put(X,M),console.log(`RBAC: Solicitud de asignaci\xF3n de rol '${J}' a ETH Address '${Q}' enviada a GDB.`)}async function Xq(){if(!q0||!x||!v0||v0.length===0)return!1;return v0.includes(x)}async function Wq($,q,J="desconocida"){let G;try{G=c(q)}catch(Y){throw new Error(`RBAC: Direcci\xF3n ETH '${q}' inv\xE1lida al verificar rol para operaci\xF3n '${J}'.`)}const Q=await $.get(`user:${G}`);if(!Q.result||!Q.result.value||!Q.result.value.role)throw new Error(`RBAC: No se encontr\xF3 rol para ETH Address ${G} en GDB (operaci\xF3n: ${J}).`);const M=Q.result.value;if(M.expiresAt&&new Date(M.expiresAt)<new Date)throw new Error(`RBAC: Rol para ETH Address ${G} ha caducado.`);return M.role}async function Iq($,q,J){const G=await Wq($,q,J);if(!v8(G,J))throw new Error(`RBAC: Usuario ETH ${q} (rol ${G}) no tiene permiso para '${J}'.`)}async function hQ($,q,J,G){if(!$||!q||!J||!G)throw new Error("RBAC executeWithPermission: db, userEthAddressFromApp, operationName, y actionCallback son requeridos.");let Q;try{Q=c(q)}catch(Y){throw new Error(`RBAC (executeWithPermission): Direcci\xF3n ETH '${q}' inv\xE1lida.`)}if(!q0||!x)throw new Error(`RBAC (executeWithPermission): La seguridad no est\xE1 activa. No se puede ejecutar '${J}'.`);if(Q!==x)throw new Error(`RBAC (executeWithPermission): Intento de operaci\xF3n como '${Q}' pero la sesi\xF3n de seguridad activa es para '${x}'.`);let M=!1;if(J==="assignRole"){if(await Xq())M=!0,console.log(`RBAC (executeWithPermission): Usuario activo ${x} autorizado para 'assignRole' por config de superadmin.`)}else await Iq($,x,J),M=!0,console.log(`RBAC (executeWithPermission): ${x} autorizado para '${J}' por rol en GDB.`);if(!M)throw new Error(`RBAC (executeWithPermission): ETH Address ${x} NO TIENE PERMISO para la operaci\xF3n '${J}'.`);return await G(x)}function Zq($,q={}){if($==="put"||$==="insert"||$==="update")return"write";if($==="remove")return"delete";if($==="link")return"link";if($==="sync"||$==="syncReceive")return"sync";return console.warn(`RBAC: Tipo de cambio desconocido '${$}' para mapeo RBAC gen\xE9rico.`),"unknown"}function lQ(){return x}function pQ(){return q0}var g0={superadmin:{can:["assignRole","deleteAny"],inherits:["admin"]},admin:{can:["delete"],inherits:["manager"]},manager:{can:["publish"],inherits:["user"]},user:{can:["write","link","sync"],inherits:["guest"]},guest:{can:["read"]}},F=null,x=null,p0=null,v0=[],q0=!1,z8=null,F8=!1;export{mQ as setSecurityStateChangeCallback,yQ as setCustomRoles,Zq as mapChangeTypeToRbacAction,pQ as isSecurityActive,lQ as getActiveEthAddress,hQ as executeWithPermission,Yq as createSecurity,g8 as clearSecurity,v8 as can,cQ as assignRole};
