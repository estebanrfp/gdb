var U=function(){return new Promise((_,$)=>{const R=indexedDB.open("gdb-sm-signing-keys-store",1);R.onupgradeneeded=(L)=>{const Y=L.target.result;if(!Y.objectStoreNames.contains("privateKeysSM"))Y.createObjectStore("privateKeysSM")},R.onsuccess=(L)=>_(L.target.result),R.onerror=(L)=>{console.error("SM: Error al abrir IndexedDB para claves:",L.target.error),$(L.target.error)}})};async function S(_,$){const L=(await U()).transaction("privateKeysSM","readwrite"),E=L.objectStore("privateKeysSM").put($,_);return new Promise((V,X)=>{L.oncomplete=()=>V(),L.onerror=()=>X(L.error),E.onerror=()=>X(E.error)})}async function v(_){const Y=(await U()).transaction("privateKeysSM","readonly").objectStore("privateKeysSM").get(_);return new Promise((E,V)=>{Y.onsuccess=()=>E(Y.result),Y.onerror=()=>{console.error("SM: Error al obtener clave privada JWK:",Y.error),V(Y.error)}})}async function F(_){if(!_)return null;try{return await window.crypto.subtle.importKey("jwk",_,{name:"ECDSA",namedCurve:"P-256"},!0,["sign"])}catch($){return console.error("SM: Error al importar clave privada JWK:",$,_),null}}async function w(){const _=await window.crypto.subtle.generateKey({name:"ECDSA",namedCurve:"P-256"},!0,["sign","verify"]),$=await window.crypto.subtle.exportKey("jwk",_.privateKey),R=await window.crypto.subtle.exportKey("jwk",_.publicKey);return{privateKeyJwk:$,publicKeyJwk:R}}var O=function(_){const{signature:$,gdbSigningPubKey:R,...L}=_;return JSON.stringify(L,Object.keys(L).sort())};async function P(_,$){const R=O(_),L=(new TextEncoder()).encode(R);return await window.crypto.subtle.sign({name:"ECDSA",hash:{name:"SHA-256"}},$,L)}async function D(_,$,R){try{const L=await window.crypto.subtle.importKey("jwk",R,{name:"ECDSA",namedCurve:"P-256"},!0,["verify"]),Y=O(_),E=(new TextEncoder()).encode(Y);return await window.crypto.subtle.verify({name:"ECDSA",hash:{name:"SHA-256"}},L,$,E)}catch(L){return console.error("SM: Error al verificar firma ECDSA:",L,{signedDataObject:_,publicKeyJwk:R}),!1}}class T{constructor(_,$,R,L=[]){if(!_)throw new Error("SecurityManager: localUserHandle es requerido.");if(!$)throw new Error("SecurityManager: dbInstance (GraphDB) es requerida.");if(!R||typeof R.can!=="function"||typeof R.mapChangeTypeToRbacAction!=="function")throw new Error("SecurityManager: rbacFunctions con m\xE9todos 'can' y 'mapChangeTypeToRbacAction' es requerido.");this.localUserHandle=_,this.gdb=$,this.rbac=R,this.superAdminPublicKeys=[].concat(L||[]).map((Y)=>{try{return typeof Y==="string"?JSON.parse(Y):Y}catch(E){return console.error("SM: Error al parsear clave de superadmin, se omitir\xE1:",Y,E),null}}).filter((Y)=>Y!==null&&typeof Y==="object"&&Y.kty),this.strictMode=!0,this.localPrivateKey=null,console.log(`SM: SecurityManager inicializado para ${_}. Modo estricto: ${this.strictMode}. SuperAdmins configurados: ${this.superAdminPublicKeys.length}`)}async _loadLocalPrivateKey(){if(this.localPrivateKey)return this.localPrivateKey;const _=await v(this.localUserHandle);if(_)this.localPrivateKey=await F(_);return this.localPrivateKey}async ensureLocalUserKeys(){if(!this.localUserHandle)throw new Error("SM: Usuario local no establecido en ensureLocalUserKeys.");if(await this._loadLocalPrivateKey(),this.localPrivateKey){const R=await this.gdb.get(`user:${this.localUserHandle}`);if(R.result?.value?.gdbSigningPubKey)return R.result.value.gdbSigningPubKey;console.warn(`SM: Clave privada local existe para ${this.localUserHandle}, pero no hay clave p\xFAblica en GDB o es inconsistente. Se regenerar\xE1n las claves.`)}console.log(`SM: Generando nuevo par de claves de firma para ${this.localUserHandle}...`);const{privateKeyJwk:_,publicKeyJwk:$}=await w();if(await S(this.localUserHandle,_),this.localPrivateKey=await F(_),!this.localPrivateKey)throw new Error(`SM: Fallo cr\xEDtico al generar y cargar la nueva clave privada para ${this.localUserHandle}`);return $}async signOutgoingOperations(_){if(!this.localUserHandle)return console.warn("SM: Usuario local no establecido. Enviando operaciones sin firmar (si no es modo estricto)."),this.strictMode?[]:_;if(!this.localPrivateKey)await this._loadLocalPrivateKey();if(!this.localPrivateKey)return console.error(`SM: No se pudo cargar o generar clave privada para ${this.localUserHandle}. No se pueden firmar operaciones (enviando sin firmar si no es modo estricto).`),this.strictMode?[]:_;const $=[],L=(await this.gdb.get(`user:${this.localUserHandle}`)).result?.value?.gdbSigningPubKey;if(!L&&this.strictMode)return console.error(`SM: No se encontr\xF3 gdbSigningPubKey para ${this.localUserHandle} al firmar. Operaciones no se enviar\xE1n en modo estricto.`),[];if(!L&&!this.strictMode)console.warn(`SM: No se encontr\xF3 gdbSigningPubKey para ${this.localUserHandle} al firmar. Operaciones se enviar\xE1n sin gdbSigningPubKey adjunta.`);for(let Y of _){const E={...Y,originUser:this.localUserHandle};try{const V=await P(E,this.localPrivateKey);$.push({...E,gdbSigningPubKey:L,signature:Array.from(new Uint8Array(V))})}catch(V){if(console.error(`SM: Error al firmar operaci\xF3n para ${this.localUserHandle}:`,V,E),this.strictMode)continue;$.push(Y)}}return $}async verifyIncomingOperations(_){const $=[],R=[];for(let L of _){let Y=!1,E=L;if(L.signature&&L.originUser&&L.gdbSigningPubKey){const{signature:V,originUser:X,gdbSigningPubKey:G,...z}=L;E=z;const M=new Uint8Array(V).buffer;if(await D(z,M,G)){const B=(await this.gdb.get(`user:${X}`)).result,f=B?.value?.gdbSigningPubKey;if(f&&JSON.stringify(f)===JSON.stringify(G)){const Q=z.type;if(Q==="put"&&z.id&&typeof z.id==="string"&&z.id.startsWith("user:")&&z.value&&typeof z.value.role==="string")if(this.superAdminPublicKeys.some((A)=>A&&JSON.stringify(A)===JSON.stringify(G)))console.log(`SM: Acci\xF3n 'assignRole' (detectada en 'put' a '${z.id}') permitida para ${X} porque su clave p\xFAblica est\xE1 en SUPERADMIN_PUBLIC_KEYS_CONFIG.`),Y=!0;else console.warn(`SM: Intento de 'assignRole' (detectada en 'put' a '${z.id}') por ${X}. Su clave p\xFAblica NO est\xE1 en SUPERADMIN_PUBLIC_KEYS_CONFIG. Operaci\xF3n descartada.`);else{const q=B.value.role;if(!q)console.warn(`SM: Usuario ${X} no tiene rol en GDB para la operaci\xF3n tipo '${Q}' sobre '${z.id}'. Op descartada.`);else if(B.value.expiresAt&&new Date(B.value.expiresAt)<new Date)console.warn(`SM: Rol para ${X} ha caducado. Operaci\xF3n '${Q}' sobre '${z.id}' descartada.`);else{const A=this.rbac.mapChangeTypeToRbacAction(Q,z);if(this.rbac.can(q,A))Y=!0;else console.warn(`SM: Usuario ${X} (rol ${q}) no tiene permiso RBAC para '${A}' (tipo original '${Q}' sobre '${z.id}'). Op descartada.`)}}}else console.warn(`SM: La gdbSigningPubKey del mensaje NO coincide con la registrada en GDB para el usuario ${X}. Op descartada:`,L)}else console.warn("SM: Firma inv\xE1lida. Op descartada:",L)}else console.warn("SM: Operaci\xF3n recibida sin firma/originUser/gdbSigningPubKey completos:",L);if(Y)$.push(E);else R.push(L)}return{validatedOperations:$,unverifiedOperations:R}}isStrictMode(){return this.strictMode}setStrictMode(_){this.strictMode=_,console.log(`SM: Modo estricto cambiado a: ${this.strictMode}`)}}function p(_){if(typeof _!=="object"||_===null)throw new Error("RBAC: Los roles personalizados deben ser un objeto v\xE1lido.");x=_,console.log("RBAC: Roles personalizados establecidos.")}function j(_,$,R=new Set){const L=x;if(!L[_])return!1;if(R.has(_))return!1;if(R.add(_),L[_].can&&L[_].can.includes($))return!0;if(L[_].inherits&&Array.isArray(L[_].inherits))return L[_].inherits.some((Y)=>j(Y,$,new Set(R)));return!1}async function d(_,$,R=[]){if(!_)throw new Error("RBAC: Se requiere instancia de GraphDB para inicializar la seguridad.");if(Z=_,h=$,I=Array.isArray(R)?R:[],h){if(console.log(`RBAC: Inicializando seguridad completa para el usuario: ${h}`),W=new T(h,Z,{can:j,mapChangeTypeToRbacAction:H},I),Z.securityManager=W,Z.sendData&&!Z._originalSendDataByRBAC)Z._originalSendDataByRBAC=Z.sendData.bind(Z),Z.sendData=async(M)=>{if(!W)return Z._originalSendDataByRBAC(M);const C=await W.signOutgoingOperations(M);return Z._originalSendDataByRBAC(C)},console.log("RBAC: GDB sendData envuelto para firmas P2P.");const L=await W.ensureLocalUserKeys(),E=(await Z.get(`user:${h}`)).result,V=E&&E.value||{},X=V.gdbSigningPubKey;let G=V.role;if(!G)G=Object.keys(x).includes("user")?"user":Object.keys(x)[Object.keys(x).length-1],console.log(`RBAC: Usuario ${h} es nuevo o sin rol. Asignando rol por defecto: '${G}' en GDB.`);else console.log(`RBAC: Usuario ${h} ya tiene el rol '${G}' en GDB.`);if(!(X&&L&&JSON.stringify(X)===JSON.stringify(L))||V.role!==G&&G||Object.keys(V).length===0)console.log(`RBAC: Actualizando/guardando nodo para ${h} en GDB con rol '${G}'...`),await Z.put({...V,gdbSigningPubKey:L,role:G},`user:${h}`),console.log(`RBAC: Nodo para ${h} (clave y rol '${G}') asegurado en GDB.`);else console.log(`RBAC: Nodo para ${h} ya est\xE1 actualizado (clave y rol coinciden).`);console.log(`RBAC: Seguridad P2P configurada y activa para ${h}.`)}else{if(console.log("RBAC: No hay usuario local activo. Seguridad P2P no se activar\xE1/se desactivar\xE1."),Z&&Z._originalSendDataByRBAC)Z.sendData=Z._originalSendDataByRBAC,delete Z._originalSendDataByRBAC,console.log("RBAC: GDB sendData restaurado a original.");if(Z)Z.securityManager=null;W=null,I=[]}}async function u(_,$,R,L=null){if(await _.ready,!x[R])throw new Error(`RBAC: El rol '${R}' no existe.`);const Y=`user:${$}`,E=await _.get(Y),X={...E.result&&E.result.value||{},role:R,assignedBy:h,expiresAt:L?new Date(L).toISOString():null};await _.put(X,Y),console.log(`RBAC: Solicitud de asignaci\xF3n de rol '${R}' a '${$}' enviada a GDB.`)}var J=function(){const _=new Uint8Array(32);return window.crypto.getRandomValues(_),_},K=function(){const _=new Uint8Array(16);return window.crypto.getRandomValues(_),_};async function i(_,$){if(!_)throw new Error("RBAC: Se requiere instancia de GDB para handleAuthentication.");const R=`user:${$}`,L=await _.get(R),Y=L.result&&L.result.value||{};if(!Y.storedCredential)console.log(`RBAC: No hay credencial WebAuthn para ${$}. Iniciando registro...`),await m(_,$,Y,R);else console.log(`RBAC: Hay credencial para ${$}. Iniciando autenticaci\xF3n...`),await N(_,$,Y);return console.log(`RBAC: Flujo de autenticaci\xF3n WebAuthn completado para ${$}.`),$}async function m(_,$,R,L){if(!window.PublicKeyCredential)throw alert("WebAuthn no es soportado."),new Error("WebAuthn no soportado.");const Y=K(),V={challenge:J(),rp:{name:"GDB Application"},user:{id:Y,name:$,displayName:$},pubKeyCredParams:[{type:"public-key",alg:-7}],authenticatorSelection:{authenticatorAttachment:"platform",userVerification:"required"},timeout:60000,attestation:"none"};try{const X=await navigator.credentials.create({publicKey:V});R.storedCredential={id:X.id,type:X.type,rawId:Array.from(new Uint8Array(X.rawId))},console.log(`RBAC: Credencial WebAuthn creada para ${$}. Se guardar\xE1 en GDB durante initializeCompleteSecurity.`)}catch(X){throw console.error("RBAC: Error en registro WebAuthn:",X),X}}async function N(_,$,R){if(!window.PublicKeyCredential)throw alert("WebAuthn no es soportado."),new Error("WebAuthn no soportado.");if(!R.storedCredential||!R.storedCredential.rawId)throw console.warn(`RBAC: No hay storedCredential o rawId para ${$}.`),new Error("Credencial WebAuthn no registrada o incompleta para el usuario.");const L=J(),Y=Uint8Array.from(R.storedCredential.rawId).buffer,E={challenge:L,allowCredentials:[{id:Y,type:"public-key"}],userVerification:"required",timeout:60000};try{await navigator.credentials.get({publicKey:E}),console.log(`RBAC: Autenticaci\xF3n WebAuthn exitosa para ${$}.`)}catch(V){throw console.error("RBAC: Error en autenticaci\xF3n WebAuthn:",V),V}}async function k(_,$){const R=await _.get(`user:${$}`);if(!R.result||!R.result.value||!R.result.value.role)throw new Error(`RBAC: No se encontr\xF3 rol para ${$} en GDB.`);const L=R.result.value;if(L.expiresAt&&new Date(L.expiresAt)<new Date)throw new Error(`RBAC: Rol para ${$} ha caducado.`);return L.role}async function c(_,$,R){const L=await k(_,$);if(!j(L,R))throw new Error(`RBAC: Usuario ${$} (rol ${L}) no tiene permiso para '${R}'.`)}async function g(_,$){if(!$||!I||I.length===0)return!1;const L=(await _.get(`user:${$}`)).result;if(!L||!L.value||!L.value.gdbSigningPubKey)return console.warn(`RBAC (isUserSuperAdminByConfigLocal): No se encontr\xF3 gdbSigningPubKey para ${$}.`),!1;const Y=L.value.gdbSigningPubKey;return I.some((V)=>{try{return V&&Y&&JSON.stringify(V)===JSON.stringify(Y)}catch(X){return console.warn("RBAC: Error comparando JWK de superadmin en isUserSuperAdminByConfigLocal",X),!1}})}async function t(_,$,R,L){if(!$)throw new Error("RBAC (executeWithPermission): Se requiere un userHandle v\xE1lido.");if(W&&h&&$!==h)throw new Error(`RBAC (executeWithPermission): Intento de operaci\xF3n como '${$}' pero la sesi\xF3n de seguridad P2P es para '${h}'.`);let Y=!1;if(console.log(`RBAC executeWithPermission: Iniciando para op='${R}', user='${$}'`),R==="assignRole"){console.log("RBAC executeWithPermission: Verificando para 'assignRole' por config de clave p\xFAblica...");const E=await g(_,$);if(console.log(`RBAC executeWithPermission: isUserSuperAdminByConfigLocal devolvi\xF3: ${E}`),E)Y=!0,console.log(`RBAC (executeWithPermission): Permiso CONCEDIDO para 'assignRole' a ${$} por configuraci\xF3n de clave.`);else console.log(`RBAC executeWithPermission: ${$} NO es superadmin por config para 'assignRole'.`)}if(console.log(`RBAC executeWithPermission: Estado de hasPermission ANTES de RBAC por rol (si aplica): ${Y}`),!Y&&R!=="assignRole")console.log(`RBAC executeWithPermission: Procediendo a verificar por RBAC de rol para op='${R}'...`),await c(_,$,R),Y=!0,console.log(`RBAC (executeWithPermission): ${$} autorizado localmente para '${R}' por rol en GDB.`);else if(!Y&&R==="assignRole")console.log("RBAC executeWithPermission: 'assignRole' fall\xF3 la verificaci\xF3n por config y no hay otra v\xEDa de permiso. Se lanzar\xE1 error.");if(!Y)throw console.log(`RBAC executeWithPermission: FINAL: hasPermission es false para ${$} en op '${R}'. Lanzando error.`),new Error(`RBAC (executeWithPermission): Usuario ${$} NO TIENE PERMISO para la operaci\xF3n '${R}'.`);return console.log(`RBAC executeWithPermission: FINAL: hasPermission es true para ${$} en op '${R}'. Ejecutando callback.`),await L($)}function H(_,$={}){if(_==="put"||_==="insert"||_==="update")return"write";if(_==="remove")return"delete";if(_==="link")return"link";if(_==="sync"||_==="syncReceive")return"sync";return console.warn(`RBAC: Tipo de cambio desconocido '${_}' para mapeo RBAC gen\xE9rico.`),"unknown"}var x={superadmin:{can:["assignRole"],inherits:["admin"]},admin:{can:["delete"],inherits:["manager"]},manager:{can:["publish"],inherits:["user"]},user:{can:["write","link","sync"],inherits:["guest"]},guest:{can:["read"]}},Z=null,h=null,W=null,I=[];export{p as setCustomRoles,H as mapChangeTypeToRbacAction,d as initializeCompleteSecurity,i as handleAuthentication,t as executeWithPermission,j as can,u as assignRole};
