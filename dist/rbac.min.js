var S=function(){return new Promise((R,_)=>{const $=indexedDB.open("gdb-sm-signing-keys-store",1);$.onupgradeneeded=(V)=>{const x=V.target.result;if(!x.objectStoreNames.contains("privateKeysSM"))x.createObjectStore("privateKeysSM")},$.onsuccess=(V)=>R(V.target.result),$.onerror=(V)=>{console.error("SM: Error al abrir IndexedDB para claves:",V.target.error),_(V.target.error)}})};async function v(R,_){const V=(await S()).transaction("privateKeysSM","readwrite"),X=V.objectStore("privateKeysSM").put(_,R);await new Promise((Y,Z)=>{X.onsuccess=Y,X.onerror=()=>Z(X.error)}),await(V.done||new Promise((Y)=>{V.oncomplete=Y}))}async function P(R){const x=(await S()).transaction("privateKeysSM","readonly").objectStore("privateKeysSM").get(R);return new Promise((X,Y)=>{x.onsuccess=()=>X(x.result),x.onerror=()=>{console.error("SM: Error al obtener clave privada JWK:",x.error),Y(x.error)}})}async function U(R){if(!R)return null;try{return await window.crypto.subtle.importKey("jwk",R,{name:"ECDSA",namedCurve:"P-256"},!0,["sign"])}catch(_){return console.error("SM: Error al importar clave privada JWK:",_,R),null}}async function D(){const R=await window.crypto.subtle.generateKey({name:"ECDSA",namedCurve:"P-256"},!0,["sign","verify"]),_=await window.crypto.subtle.exportKey("jwk",R.privateKey),$=await window.crypto.subtle.exportKey("jwk",R.publicKey);return{privateKeyJwk:_,publicKeyJwk:$}}var J=function(R){const{signature:_,gdbSigningPubKey:$,...V}=R;return JSON.stringify(V,Object.keys(V).sort())};async function N(R,_){const $=J(R),V=(new TextEncoder()).encode($);return await window.crypto.subtle.sign({name:"ECDSA",hash:{name:"SHA-256"}},_,V)}async function m(R,_,$){try{const V=await window.crypto.subtle.importKey("jwk",$,{name:"ECDSA",namedCurve:"P-256"},!0,["verify"]),x=J(R),X=(new TextEncoder()).encode(x);return await window.crypto.subtle.verify({name:"ECDSA",hash:{name:"SHA-256"}},V,_,X)}catch(V){return console.error("SM: Error al verificar firma ECDSA:",V,{signedDataObject:R,publicKeyJwk:$}),!1}}class A{constructor(R,_,$,V=[]){if(!R)throw new Error("SecurityManager: localUserHandle es requerido.");if(!_)throw new Error("SecurityManager: dbInstance (GraphDB) es requerida.");if(!$||typeof $.can!=="function"||typeof $.mapChangeTypeToRbacAction!=="function")throw new Error("SecurityManager: rbacFunctions con m\xE9todos 'can' y 'mapChangeTypeToRbacAction' es requerido.");this.localUserHandle=R,this.gdb=_,this.rbac=$,this.superAdminPublicKeys=[].concat(V||[]).map((x)=>{try{const X=typeof x==="string"?JSON.parse(x):x;if(X&&typeof X==="object"&&X.kty)return X;return console.error("SM: Clave de superadmin inv\xE1lida (no es objeto JWK con kty), se omitir\xE1:",x),null}catch(X){return console.error("SM: Error al parsear clave de superadmin, se omitir\xE1:",x,X),null}}).filter((x)=>x!==null),this.strictMode=!0,this.localPrivateKey=null,console.log(`SM: SecurityManager inicializado para ${R}. Modo estricto: ${this.strictMode}. SuperAdmins configurados: ${this.superAdminPublicKeys.length}`)}async _loadLocalPrivateKey(){if(this.localPrivateKey)return this.localPrivateKey;const R=await P(this.localUserHandle);if(R)this.localPrivateKey=await U(R);return this.localPrivateKey}async ensureLocalUserKeys(){if(!this.localUserHandle)throw new Error("SM: Usuario local no establecido en ensureLocalUserKeys.");if(await this._loadLocalPrivateKey(),this.localPrivateKey){const $=await this.gdb.get(`user:${this.localUserHandle}`);if($.result?.value?.gdbSigningPubKey)return $.result.value.gdbSigningPubKey;console.warn(`SM: Clave privada local existe para ${this.localUserHandle}, pero no hay clave p\xFAblica en GDB o es inconsistente. Se regenerar\xE1n las claves.`)}console.log(`SM: Generando nuevo par de claves de firma para ${this.localUserHandle}...`);const{privateKeyJwk:R,publicKeyJwk:_}=await D();if(await v(this.localUserHandle,R),this.localPrivateKey=await U(R),!this.localPrivateKey)throw new Error(`SM: Fallo cr\xEDtico al generar y cargar la nueva clave privada para ${this.localUserHandle}`);return _}async signOutgoingOperations(R){if(!this.localUserHandle)return console.warn("SM: Usuario local no establecido. Enviando operaciones sin firmar (si no es modo estricto)."),this.strictMode?[]:R;if(!this.localPrivateKey)await this._loadLocalPrivateKey();if(!this.localPrivateKey)return console.error(`SM: No se pudo cargar o generar clave privada para ${this.localUserHandle}. No se pueden firmar operaciones.`),this.strictMode?[]:R;const _=[],V=(await this.gdb.get(`user:${this.localUserHandle}`)).result?.value?.gdbSigningPubKey;if(!V&&this.strictMode)return console.error(`SM: No se encontr\xF3 gdbSigningPubKey para ${this.localUserHandle} al firmar. Operaciones no se enviar\xE1n en modo estricto.`),[];if(!V&&!this.strictMode)console.warn(`SM: No se encontr\xF3 gdbSigningPubKey para ${this.localUserHandle} al firmar. Las operaciones se firmar\xE1n pero gdbSigningPubKey no se adjuntar\xE1 si no existe.`);for(let x of R){if(x.type==="sync"||x.type==="syncReceive"){_.push(x);continue}const X={...x,originUser:this.localUserHandle};try{const Y=await N(X,this.localPrivateKey);_.push({...X,gdbSigningPubKey:V,signature:Array.from(new Uint8Array(Y))})}catch(Y){if(console.error(`SM: Error al firmar operaci\xF3n para ${this.localUserHandle}:`,Y,X),this.strictMode)continue;_.push(x)}}return _}async verifyIncomingOperations(R){const _=[],$=[];for(let V of R){if(V.type==="sync"||V.type==="syncReceive"){_.push(V);continue}let x=!1,X=V;if(V.signature&&V.originUser&&V.gdbSigningPubKey){const{signature:Y,originUser:Z,gdbSigningPubKey:L,...E}=V;X=E;const B=new Uint8Array(Y).buffer;if(await m(E,B,L)){const T=(await this.gdb.get(`user:${Z}`)).result,j=T?.value?.gdbSigningPubKey;if(j&&JSON.stringify(j)===JSON.stringify(L)){const M=E.type;let f=!1;if(M==="put"&&E.id&&typeof E.id==="string"&&E.id.startsWith("user:")&&E.value&&typeof E.value.role==="string")if(this.superAdminPublicKeys.some((Q)=>Q&&L&&JSON.stringify(Q)===JSON.stringify(L)))console.log(`SM: Acci\xF3n 'assignRole' (detectada en put a ${E.id}) permitida para ${Z} porque su clave p\xFAblica est\xE1 en SUPERADMIN_PUBLIC_KEYS_CONFIG.`),f=!0;else console.warn(`SM: Intento de 'assignRole' (detectado en put a ${E.id}) por ${Z}. Su clave p\xFAblica NO est\xE1 en SUPERADMIN_PUBLIC_KEYS_CONFIG. Operaci\xF3n descartada.`);else{const q=T.value.role;if(!q)console.warn(`SM: Usuario ${Z} no tiene rol en GDB para la operaci\xF3n tipo '${M}' sobre '${E.id}'. Op descartada:`,V);else if(T.value.expiresAt&&new Date(T.value.expiresAt)<new Date)console.warn(`SM: Rol para ${Z} ha caducado, op descartada:`,V);else{const Q=this.rbac.mapChangeTypeToRbacAction(M,E);if(this.rbac.can(q,Q))f=!0;else console.warn(`SM: Usuario ${Z} (rol ${q}) no tiene permiso RBAC para '${Q}' (tipo original '${M}' sobre '${E.id}'). Op descartada.`)}}x=f}else console.warn(`SM: La clave p\xFAblica del mensaje no coincide con la registrada para el usuario ${Z} o el usuario no existe/no tiene clave. Op descartada:`,{msgGdbSignKey:L,registeredKey:j,op:V})}else console.warn("SM: Firma inv\xE1lida. Op descartada:",V)}else if(this.strictMode)console.warn("SM: Operaci\xF3n sin firma/originUser/gdbSigningPubKey completa recibida en modo estricto. Op descartada:",V);else console.warn("SM: Operaci\xF3n sin firma/originUser/gdbSigningPubKey completa recibida en modo NO estricto. Se pasar\xE1 sin verificar permisos P2P:",V);if(x)_.push(X);else $.push(V)}return{validatedOperations:_,unverifiedOperations:$}}isStrictMode(){return this.strictMode}setStrictMode(R){this.strictMode=R,console.log(`SM: Modo estricto cambiado a: ${this.strictMode}`)}}function u(R){if(typeof R!=="object"||R===null)throw new Error("RBAC: Los roles personalizados deben ser un objeto v\xE1lido.");h=R,console.log("RBAC: Roles personalizados establecidos.")}function C(R,_,$=new Set){const V=h;if(!V[R])return!1;if($.has(R))return!1;if($.add(R),V[R].can&&V[R].can.includes(_))return!0;if(V[R].inherits&&Array.isArray(V[R].inherits))return V[R].inherits.some((x)=>C(x,_,new Set($)));return!1}async function d(R,_,$=[]){if(!R)throw new Error("RBAC: Se requiere instancia de GraphDB para inicializar la seguridad.");if(z=R,I=_,W=$,I){if(console.log(`RBAC: Inicializando seguridad completa para el usuario: ${I}`),G=new A(I,z,{can:C,mapChangeTypeToRbacAction:g},$),z.securityManager=G,z.sendData&&!z._originalSendDataByRBAC)z._originalSendDataByRBAC=z.sendData.bind(z),z.sendData=async(B)=>{if(!G)return z._originalSendDataByRBAC(B);const F=await G.signOutgoingOperations(B);return z._originalSendDataByRBAC(F)},console.log("RBAC: GDB sendData envuelto para firmas P2P.");const V=await G.ensureLocalUserKeys(),X=(await z.get(`user:${I}`)).result,Y=X&&X.value||{},Z=Y.gdbSigningPubKey;let L=Y.role;if(!L)L=Object.keys(h).includes("user")?"user":Object.keys(h)[Object.keys(h).length-1],console.log(`RBAC: Usuario ${I} es nuevo o sin rol. Asignando rol por defecto: '${L}' en GDB.`);else console.log(`RBAC: Usuario ${I} ya tiene el rol '${L}' en GDB.`);if(!(Z&&V&&JSON.stringify(Z)===JSON.stringify(V))||Y.role!==L||Object.keys(Y).length===0)console.log(`RBAC: Actualizando/guardando nodo para ${I} en GDB con rol '${L}'...`),await z.put({...Y,gdbSigningPubKey:V,role:L},`user:${I}`),console.log(`RBAC: Nodo para ${I} (clave y rol '${L}') asegurado en GDB.`);else console.log(`RBAC: Nodo para ${I} ya est\xE1 actualizado.`);console.log(`RBAC: Seguridad P2P configurada y activa para ${I}.`)}else{if(console.log("RBAC: No hay usuario local activo. Seguridad P2P no se activar\xE1/se desactivar\xE1."),z&&z._originalSendDataByRBAC)z.sendData=z._originalSendDataByRBAC,delete z._originalSendDataByRBAC,console.log("RBAC: GDB sendData restaurado a original.");if(z)z.securityManager=null;G=null,W=[]}}async function i(R,_,$,V=null){if(await R.ready,!h[$])throw new Error(`RBAC: El rol '${$}' no existe.`);const x=`user:${_}`,X=await R.get(x),Z={...X.result&&X.result.value||{},role:$,assignedBy:I,expiresAt:V?new Date(V).toISOString():null};await R.put(Z,x),console.log(`RBAC: Solicitud de asignaci\xF3n de rol '${$}' a '${_}' enviada a GDB.`)}var w=function(){const R=new Uint8Array(32);return window.crypto.getRandomValues(R),R},k=function(){const R=new Uint8Array(16);return window.crypto.getRandomValues(R),R};async function t(R,_){if(!R)throw new Error("RBAC: Se requiere instancia de GDB para handleAuthentication.");const $=`user:${_}`,V=await R.get($),x=V.result&&V.result.value||null;if(!x||!x.storedCredential)console.log(`RBAC: No hay credencial WebAuthn para ${_} o usuario no existe en GDB. Iniciando registro...`),await H(R,_,x||{},$);else console.log(`RBAC: Hay credencial para ${_}. Iniciando autenticaci\xF3n...`),await K(R,_,x);return console.log(`RBAC: Flujo de autenticaci\xF3n WebAuthn completado para ${_}.`),_}async function H(R,_,$,V){if(!window.PublicKeyCredential)throw alert("WebAuthn no es soportado."),new Error("WebAuthn no soportado.");const x=k(),Y={challenge:w(),rp:{name:"GDB Application"},user:{id:x,name:_,displayName:_},pubKeyCredParams:[{type:"public-key",alg:-7}],authenticatorSelection:{authenticatorAttachment:"platform",userVerification:"required"},timeout:60000,attestation:"none"};try{const Z=await navigator.credentials.create({publicKey:Y}),L={id:Z.id,type:Z.type,rawId:Array.from(new Uint8Array(Z.rawId))};$.storedCredential=L,console.log(`RBAC: Credencial WebAuthn creada para ${_}. Se guardar\xE1 en GDB durante initializeCompleteSecurity.`)}catch(Z){throw console.error("RBAC: Error en registro WebAuthn:",Z),Z}}async function K(R,_,$){if(!window.PublicKeyCredential)throw alert("WebAuthn no es soportado."),new Error("WebAuthn no soportado.");if(!$.storedCredential||!$.storedCredential.id)throw console.warn(`RBAC: No hay storedCredential para ${_}.`),new Error("Credencial WebAuthn no registrada para el usuario.");const x={challenge:w(),allowCredentials:[{id:Uint8Array.from($.storedCredential.rawId).buffer,type:"public-key"}],userVerification:"required",timeout:60000};try{await navigator.credentials.get({publicKey:x}),console.log(`RBAC: Autenticaci\xF3n WebAuthn exitosa para ${_}.`)}catch(X){throw console.error("RBAC: Error en autenticaci\xF3n WebAuthn:",X),X}}async function O(R,_){const $=await R.get(`user:${_}`);if(!$.result||!$.result.value||!$.result.value.role)throw new Error(`RBAC: No se encontr\xF3 rol para ${_} en GDB.`);const V=$.result.value;if(V.expiresAt&&new Date(V.expiresAt)<new Date)throw new Error(`RBAC: Rol para ${_} ha caducado.`);return V.role}async function b(R,_,$){const V=await O(R,_);if(!C(V,$))throw new Error(`RBAC: Usuario ${_} (rol ${V}) no tiene permiso para '${$}'.`)}async function c(R,_){if(!_||!W||W.length===0)return!1;const V=(await R.get(`user:${_}`)).result;if(!V||!V.value||!V.value.gdbSigningPubKey)return console.warn(`RBAC (isUserSuperAdminByConfigLocal): No se encontr\xF3 gdbSigningPubKey para ${_} para verificar si es superadmin por config.`),!1;const x=V.value.gdbSigningPubKey;return W.some((X)=>{try{return X&&x&&JSON.stringify(X)===JSON.stringify(x)}catch(Y){return console.warn("RBAC: Error comparando JWK de superadmin en isUserSuperAdminByConfigLocal",Y),!1}})}async function o(R,_,$,V){if(!_)throw new Error("RBAC (executeWithPermission): Se requiere un userHandle v\xE1lido.");if(G&&I&&_!==I)throw new Error(`RBAC (executeWithPermission): Intento de operaci\xF3n como '${_}' pero la sesi\xF3n de seguridad P2P es para '${I}'.`);let x=!1;if($==="assignRole")if(await c(R,_))x=!0,console.log(`RBAC (executeWithPermission): Usuario ${_} autorizado localmente para 'assignRole' porque su gdbSigningPubKey est\xE1 en la configuraci\xF3n de superadmins.`);else try{const Y=await O(R,_);if(Y==="superadmin"&&C(Y,$))x=!0,console.log(`RBAC (executeWithPermission): Usuario ${_} (NO en config de superadmin) autorizado localmente para 'assignRole' por tener rol '${Y}' en GDB con permiso.`)}catch(Y){}if(!x&&$!=="assignRole")await b(R,_,$),x=!0,console.log(`RBAC (executeWithPermission): ${_} autorizado localmente para '${$}' por rol en GDB.`);if(!x)throw new Error(`RBAC (executeWithPermission): Usuario ${_} NO TIENE PERMISO para la operaci\xF3n '${$}'.`);return await V(_)}function g(R,_={}){if(R==="put"||R==="insert"||R==="update")return"write";if(R==="remove")return"delete";if(R==="link")return"link";if(R==="sync"||R==="syncReceive")return"sync";return console.warn(`RBAC: Tipo de cambio desconocido '${R}' para mapeo RBAC gen\xE9rico.`),"unknown"}var h={superadmin:{can:["assignRole"],inherits:["admin"]},admin:{can:["delete"],inherits:["manager"]},manager:{can:["publish"],inherits:["user"]},user:{can:["write","link","sync"],inherits:["guest"]},guest:{can:["read"]}},z=null,I=null,G=null,W=[];export{u as setCustomRoles,g as mapChangeTypeToRbacAction,d as initializeCompleteSecurity,t as handleAuthentication,o as executeWithPermission,C as can,i as assignRole};
