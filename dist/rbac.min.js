var y$=Object.defineProperty;var c$=($,q)=>{for(var J in q)y$($,J,{get:q[J],enumerable:!0,configurable:!0,set:(G)=>q[J]=()=>G})};var g8="6.14.1";var g$=function($,q,J){const G=q.split("|").map((Q)=>Q.trim());for(let Q=0;Q<G.length;Q++)switch(q){case"any":return;case"bigint":case"boolean":case"number":case"string":if(typeof $===q)return}const M=new Error(`invalid value for type ${q}`);throw M.code="INVALID_ARGUMENT",M.argument=`value.${J}`,M.value=$,M};function i0($,q,J){for(let G in q){let M=q[G];const Q=J?J[G]:null;if(Q)g$(M,Q,G);Object.defineProperty($,G,{enumerable:!0,value:M,writable:!1})}}var E0=function($){if($==null)return"null";if(Array.isArray($))return"[ "+$.map(E0).join(", ")+" ]";if($ instanceof Uint8Array){let J="0x";for(let G=0;G<$.length;G++)J+="0123456789abcdef"[$[G]>>4],J+="0123456789abcdef"[$[G]&15];return J}if(typeof $==="object"&&typeof $.toJSON==="function")return E0($.toJSON());switch(typeof $){case"boolean":case"symbol":return $.toString();case"bigint":return BigInt($).toString();case"number":return $.toString();case"string":return JSON.stringify($);case"object":{const q=Object.keys($);return q.sort(),"{ "+q.map((J)=>`${E0(J)}: ${E0($[J])}`).join(", ")+" }"}}return"[ COULD NOT SERIALIZE ]"};function K8($,q,J){let G=$;{const Q=[];if(J){if(("message"in J)||("code"in J)||("name"in J))throw new Error(`value will overwrite populated values: ${E0(J)}`);for(let I in J){if(I==="shortMessage")continue;const X=J[I];Q.push(I+"="+E0(X))}}if(Q.push(`code=${q}`),Q.push(`version=${g8}`),Q.length)$+=" ("+Q.join(", ")+")"}let M;switch(q){case"INVALID_ARGUMENT":M=new TypeError($);break;case"NUMERIC_FAULT":case"BUFFER_OVERRUN":M=new RangeError($);break;default:M=new Error($)}if(i0(M,{code:q}),J)Object.assign(M,J);if(M.shortMessage==null)i0(M,{shortMessage:G});return M}function $0($,q,J,G){if(!$)throw K8(q,J,G)}function C($,q,J,G){$0($,q,"INVALID_ARGUMENT",{argument:J,value:G})}function n0($){$0(v$.indexOf($)>=0,"platform missing String.prototype.normalize","UNSUPPORTED_OPERATION",{operation:"String.prototype.normalize",info:{form:$}})}function o0($,q,J){if(J==null)J="";if($!==q){let G=J,M="new";if(J)G+=".",M+=" "+J;$0(!1,`private constructor; use ${G}from* methods`,"UNSUPPORTED_OPERATION",{operation:M})}}var v$=["NFD","NFC","NFKD","NFKC"].reduce(($,q)=>{try{if("test".normalize(q)!=="test")throw new Error("bad");if(q==="NFD"){const J=String.fromCharCode(233).normalize("NFD"),G=String.fromCharCode(101,769);if(J!==G)throw new Error("broken")}$.push(q)}catch(J){}return $},[]);var m8=function($,q,J){if($ instanceof Uint8Array){if(J)return new Uint8Array($);return $}if(typeof $==="string"&&$.match(/^0x(?:[0-9a-f][0-9a-f])*$/i)){const G=new Uint8Array(($.length-2)/2);let M=2;for(let Q=0;Q<G.length;Q++)G[Q]=parseInt($.substring(M,M+2),16),M+=2;return G}C(!1,"invalid BytesLike value",q||"value",$)};function c($,q){return m8($,q,!1)}function z0($,q){return m8($,q,!0)}function x0($,q){if(typeof $!=="string"||!$.match(/^0x[0-9A-Fa-f]*$/))return!1;if(typeof q==="number"&&$.length!==2+2*q)return!1;if(q===!0&&$.length%2!==0)return!1;return!0}function k($){const q=c($);let J="0x";for(let G=0;G<q.length;G++){const M=q[G];J+=v8[(M&240)>>4]+v8[M&15]}return J}function G0($){return"0x"+$.map((q)=>k(q).substring(2)).join("")}function M0($){if(x0($,!0))return($.length-2)/2;return c($).length}var m$=function($,q,J){const G=c($);$0(q>=G.length,"padding exceeds data length","BUFFER_OVERRUN",{buffer:new Uint8Array(G),length:q,offset:q+1});const M=new Uint8Array(q);if(M.fill(0),J)M.set(G,q-G.length);else M.set(G,0);return k(M)};function a0($,q){return m$($,q,!0)}var v8="0123456789abcdef";function Z0($,q){switch(typeof $){case"bigint":return $;case"number":return C(Number.isInteger($),"underflow",q||"value",$),C($>=-k0&&$<=k0,"overflow",q||"value",$),BigInt($);case"string":try{if($==="")throw new Error("empty string");if($[0]==="-"&&$[1]!=="-")return-BigInt($.substring(1));return BigInt($)}catch(J){C(!1,`invalid BigNumberish string: ${J.message}`,q||"value",$)}}C(!1,"invalid BigNumberish value",q||"value",$)}function r0($,q){const J=Z0($,q);return $0(J>=h8,"unsigned value cannot be negative","NUMERIC_FAULT",{fault:"overflow",operation:"getUint",value:$}),J}function K0($,q){switch(typeof $){case"bigint":return C($>=-k0&&$<=k0,"overflow",q||"value",$),Number($);case"number":return C(Number.isInteger($),"underflow",q||"value",$),C($>=-k0&&$<=k0,"overflow",q||"value",$),$;case"string":try{if($==="")throw new Error("empty string");return K0(BigInt($),q)}catch(J){C(!1,`invalid numeric string: ${J.message}`,q||"value",$)}}C(!1,"invalid numeric value",q||"value",$)}function g0($,q){let G=r0($,"value").toString(16);if(q==null){if(G.length%2)G="0"+G}else{const M=K0(q,"width");$0(M*2>=G.length,`value exceeds width (${M} bytes)`,"NUMERIC_FAULT",{operation:"toBeHex",fault:"overflow",value:$});while(G.length<M*2)G="0"+G}return"0x"+G}function t0($){const q=r0($,"value");if(q===h8)return new Uint8Array([]);let J=q.toString(16);if(J.length%2)J="0"+J;const G=new Uint8Array(J.length/2);for(let M=0;M<G.length;M++){const Q=M*2;G[M]=parseInt(J.substring(Q,Q+2),16)}return G}var h8=BigInt(0),Tq=BigInt(1),k0=9007199254740991;var h$=function($,q,J,G,M){C(!1,`invalid codepoint at offset ${q}; ${$}`,"bytes",J)},l8=function($,q,J,G,M){if($==="BAD_PREFIX"||$==="UNEXPECTED_CONTINUE"){let Q=0;for(let I=q+1;I<J.length;I++){if(J[I]>>6!==2)break;Q++}return Q}if($==="OVERRUN")return J.length-q-1;return 0},l$=function($,q,J,G,M){if($==="OVERLONG")return C(typeof M==="number","invalid bad code point for replacement","badCodepoint",M),G.push(M),0;return G.push(65533),l8($,q,J,G,M)};function U0($,q){if(C(typeof $==="string","invalid string value","str",$),q!=null)n0(q),$=$.normalize(q);let J=[];for(let G=0;G<$.length;G++){const M=$.charCodeAt(G);if(M<128)J.push(M);else if(M<2048)J.push(M>>6|192),J.push(M&63|128);else if((M&64512)==55296){G++;const Q=$.charCodeAt(G);C(G<$.length&&(Q&64512)===56320,"invalid surrogate pair","str",$);const I=65536+((M&1023)<<10)+(Q&1023);J.push(I>>18|240),J.push(I>>12&63|128),J.push(I>>6&63|128),J.push(I&63|128)}else J.push(M>>12|224),J.push(M>>6&63|128),J.push(M&63|128)}return new Uint8Array(J)}var p8=Object.freeze({error:h$,ignore:l8,replace:l$});var v0=function($){if(!Number.isSafeInteger($)||$<0)throw new Error(`Wrong positive integer: ${$}`)};var m0=function($,...q){if(!($ instanceof Uint8Array))throw new Error("Expected Uint8Array");if(q.length>0&&!q.includes($.length))throw new Error(`Expected Uint8Array of length ${q}, not of length=${$.length}`)},u8=function($){if(typeof $!=="function"||typeof $.create!=="function")throw new Error("Hash should be wrapped by utils.wrapConstructor");v0($.outputLen),v0($.blockLen)},Q0=function($,q=!0){if($.destroyed)throw new Error("Hash instance has been destroyed");if(q&&$.finished)throw new Error("Hash#digest() has already been called")},s0=function($,q){m0($);const J=q.outputLen;if($.length<J)throw new Error(`digestInto() expects output buffer of length at least ${J}`)};var e0=typeof globalThis==="object"&&("crypto"in globalThis)?globalThis.crypto:void 0;function QJ($){if(typeof $!=="string")throw new Error(`utf8ToBytes expected string, got ${typeof $}`);return new Uint8Array((new TextEncoder()).encode($))}function w0($){if(typeof $==="string")$=QJ($);if(!d8($))throw new Error(`expected Uint8Array, got ${typeof $}`);return $}function n8(...$){const q=new Uint8Array($.reduce((G,M)=>G+M.length,0));let J=0;return $.forEach((G)=>{if(!d8(G))throw new Error("Uint8Array expected");q.set(G,J),J+=G.length}),q}function J8($){const q=(G)=>$().update(w0(G)).digest(),J=$();return q.outputLen=J.outputLen,q.blockLen=J.blockLen,q.create=()=>$(),q}function o8($=32){if(e0&&typeof e0.getRandomValues==="function")return e0.getRandomValues(new Uint8Array($));throw new Error("crypto.getRandomValues must be defined")}/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */var d8=($)=>$ instanceof Uint8Array;var i8=($)=>new Uint32Array($.buffer,$.byteOffset,Math.floor($.byteLength/4)),$8=($)=>new DataView($.buffer,$.byteOffset,$.byteLength),t=($,q)=>$<<32-q|$>>>q,MJ=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;if(!MJ)throw new Error("Non little-endian hardware is not supported");class N0{clone(){return this._cloneInto()}}var Aq={}.toString;class U8 extends N0{constructor($,q){super();this.finished=!1,this.destroyed=!1,u8($);const J=w0(q);if(this.iHash=$.create(),typeof this.iHash.update!=="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const G=this.blockLen,M=new Uint8Array(G);M.set(J.length>G?$.create().update(J).digest():J);for(let Q=0;Q<M.length;Q++)M[Q]^=54;this.iHash.update(M),this.oHash=$.create();for(let Q=0;Q<M.length;Q++)M[Q]^=54^92;this.oHash.update(M),M.fill(0)}update($){return Q0(this),this.iHash.update($),this}digestInto($){Q0(this),m0($,this.outputLen),this.finished=!0,this.iHash.digestInto($),this.oHash.update($),this.oHash.digestInto($),this.destroy()}digest(){const $=new Uint8Array(this.oHash.outputLen);return this.digestInto($),$}_cloneInto($){$||($=Object.create(Object.getPrototypeOf(this),{}));const{oHash:q,iHash:J,finished:G,destroyed:M,blockLen:Q,outputLen:I}=this;return $=$,$.finished=G,$.destroyed=M,$.blockLen=Q,$.outputLen=I,$.oHash=q._cloneInto($.oHash),$.iHash=J._cloneInto($.iHash),$}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}var V8=($,q,J)=>new U8($,q).update(J).digest();V8.create=($,q)=>new U8($,q);var IJ=function($,q,J,G){if(typeof $.setBigUint64==="function")return $.setBigUint64(q,J,G);const M=BigInt(32),Q=BigInt(4294967295),I=Number(J>>M&Q),X=Number(J&Q),Y=G?4:0,W=G?0:4;$.setUint32(q+Y,I,G),$.setUint32(q+W,X,G)};class D8 extends N0{constructor($,q,J,G){super();this.blockLen=$,this.outputLen=q,this.padOffset=J,this.isLE=G,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array($),this.view=$8(this.buffer)}update($){Q0(this);const{view:q,buffer:J,blockLen:G}=this;$=w0($);const M=$.length;for(let Q=0;Q<M;){const I=Math.min(G-this.pos,M-Q);if(I===G){const X=$8($);for(;G<=M-Q;Q+=G)this.process(X,Q);continue}if(J.set($.subarray(Q,Q+I),this.pos),this.pos+=I,Q+=I,this.pos===G)this.process(q,0),this.pos=0}return this.length+=$.length,this.roundClean(),this}digestInto($){Q0(this),s0($,this),this.finished=!0;const{buffer:q,view:J,blockLen:G,isLE:M}=this;let{pos:Q}=this;if(q[Q++]=128,this.buffer.subarray(Q).fill(0),this.padOffset>G-Q)this.process(J,0),Q=0;for(let Z=Q;Z<G;Z++)q[Z]=0;IJ(J,G-8,BigInt(this.length*8),M),this.process(J,0);const I=$8($),X=this.outputLen;if(X%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const Y=X/4,W=this.get();if(Y>W.length)throw new Error("_sha2: outputLen bigger than state");for(let Z=0;Z<Y;Z++)I.setUint32(4*Z,W[Z],M)}digest(){const{buffer:$,outputLen:q}=this;this.digestInto($);const J=$.slice(0,q);return this.destroy(),J}_cloneInto($){$||($=new this.constructor),$.set(...this.get());const{blockLen:q,buffer:J,length:G,finished:M,destroyed:Q,pos:I}=this;if($.length=G,$.pos=I,$.finished=M,$.destroyed=Q,G%q)$.buffer.set(J);return $}}var YJ=($,q,J)=>$&q^~$&J,XJ=($,q,J)=>$&q^$&J^q&J,WJ=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),V0=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),D0=new Uint32Array(64);class a8 extends D8{constructor(){super(64,32,8,!1);this.A=V0[0]|0,this.B=V0[1]|0,this.C=V0[2]|0,this.D=V0[3]|0,this.E=V0[4]|0,this.F=V0[5]|0,this.G=V0[6]|0,this.H=V0[7]|0}get(){const{A:$,B:q,C:J,D:G,E:M,F:Q,G:I,H:X}=this;return[$,q,J,G,M,Q,I,X]}set($,q,J,G,M,Q,I,X){this.A=$|0,this.B=q|0,this.C=J|0,this.D=G|0,this.E=M|0,this.F=Q|0,this.G=I|0,this.H=X|0}process($,q){for(let Z=0;Z<16;Z++,q+=4)D0[Z]=$.getUint32(q,!1);for(let Z=16;Z<64;Z++){const U=D0[Z-15],H=D0[Z-2],P=t(U,7)^t(U,18)^U>>>3,z=t(H,17)^t(H,19)^H>>>10;D0[Z]=z+D0[Z-7]+P+D0[Z-16]|0}let{A:J,B:G,C:M,D:Q,E:I,F:X,G:Y,H:W}=this;for(let Z=0;Z<64;Z++){const U=t(I,6)^t(I,11)^t(I,25),H=W+U+YJ(I,X,Y)+WJ[Z]+D0[Z]|0,z=(t(J,2)^t(J,13)^t(J,22))+XJ(J,G,M)|0;W=Y,Y=X,X=I,I=Q+H|0,Q=M,M=G,G=J,J=H+z|0}J=J+this.A|0,G=G+this.B|0,M=M+this.C|0,Q=Q+this.D|0,I=I+this.E|0,X=X+this.F|0,Y=Y+this.G|0,W=W+this.H|0,this.set(J,G,M,Q,I,X,Y,W)}roundClean(){D0.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}}var r8=J8(()=>new a8);var zJ=function($,q=!1){if(q)return{h:Number($&q8),l:Number($>>t8&q8)};return{h:Number($>>t8&q8)|0,l:Number($&q8)|0}},s8=function($,q=!1){let J=new Uint32Array($.length),G=new Uint32Array($.length);for(let M=0;M<$.length;M++){const{h:Q,l:I}=zJ($[M],q);[J[M],G[M]]=[Q,I]}return[J,G]};var q8=BigInt(4294967295),t8=BigInt(32);var e8=($,q,J)=>$<<J|q>>>32-J,$$=($,q,J)=>q<<J|$>>>32-J,J$=($,q,J)=>q<<J-32|$>>>64-J,q$=($,q,J)=>$<<J-32|q>>>64-J;function OJ($,q=24){const J=new Uint32Array(10);for(let G=24-q;G<24;G++){for(let I=0;I<10;I++)J[I]=$[I]^$[I+10]^$[I+20]^$[I+30]^$[I+40];for(let I=0;I<10;I+=2){const X=(I+8)%10,Y=(I+2)%10,W=J[Y],Z=J[Y+1],U=G$(W,Z,1)^J[X],H=M$(W,Z,1)^J[X+1];for(let P=0;P<50;P+=10)$[I+P]^=U,$[I+P+1]^=H}let M=$[2],Q=$[3];for(let I=0;I<24;I++){const X=I$[I],Y=G$(M,Q,X),W=M$(M,Q,X),Z=Q$[I];M=$[Z],Q=$[Z+1],$[Z]=Y,$[Z+1]=W}for(let I=0;I<50;I+=10){for(let X=0;X<10;X++)J[X]=$[I+X];for(let X=0;X<10;X++)$[I+X]^=~J[(X+2)%10]&J[(X+4)%10]}$[0]^=TJ[G],$[1]^=jJ[G]}J.fill(0)}var[Q$,I$,Y$]=[[],[],[]],ZJ=BigInt(0),h0=BigInt(1),KJ=BigInt(2),UJ=BigInt(7),VJ=BigInt(256),DJ=BigInt(113);for(let $=0,q=h0,J=1,G=0;$<24;$++){[J,G]=[G,(2*J+3*G)%5],Q$.push(2*(5*G+J)),I$.push(($+1)*($+2)/2%64);let M=ZJ;for(let Q=0;Q<7;Q++)if(q=(q<<h0^(q>>UJ)*DJ)%VJ,q&KJ)M^=h0<<(h0<<BigInt(Q))-h0;Y$.push(M)}var[TJ,jJ]=s8(Y$,!0),G$=($,q,J)=>J>32?J$($,q,J):e8($,q,J),M$=($,q,J)=>J>32?q$($,q,J):$$($,q,J);class T8 extends N0{constructor($,q,J,G=!1,M=24){super();if(this.blockLen=$,this.suffix=q,this.outputLen=J,this.enableXOF=G,this.rounds=M,this.pos=0,this.posOut=0,this.finished=!1,this.destroyed=!1,v0(J),0>=this.blockLen||this.blockLen>=200)throw new Error("Sha3 supports only keccak-f1600 function");this.state=new Uint8Array(200),this.state32=i8(this.state)}keccak(){OJ(this.state32,this.rounds),this.posOut=0,this.pos=0}update($){Q0(this);const{blockLen:q,state:J}=this;$=w0($);const G=$.length;for(let M=0;M<G;){const Q=Math.min(q-this.pos,G-M);for(let I=0;I<Q;I++)J[this.pos++]^=$[M++];if(this.pos===q)this.keccak()}return this}finish(){if(this.finished)return;this.finished=!0;const{state:$,suffix:q,pos:J,blockLen:G}=this;if($[J]^=q,(q&128)!==0&&J===G-1)this.keccak();$[G-1]^=128,this.keccak()}writeInto($){Q0(this,!1),m0($),this.finish();const q=this.state,{blockLen:J}=this;for(let G=0,M=$.length;G<M;){if(this.posOut>=J)this.keccak();const Q=Math.min(J-this.posOut,M-G);$.set(q.subarray(this.posOut,this.posOut+Q),G),this.posOut+=Q,G+=Q}return $}xofInto($){if(!this.enableXOF)throw new Error("XOF is not possible for this instance");return this.writeInto($)}xof($){return v0($),this.xofInto(new Uint8Array($))}digestInto($){if(s0($,this),this.finished)throw new Error("digest() was already called");return this.writeInto($),this.destroy(),$}digest(){return this.digestInto(new Uint8Array(this.outputLen))}destroy(){this.destroyed=!0,this.state.fill(0)}_cloneInto($){const{blockLen:q,suffix:J,outputLen:G,rounds:M,enableXOF:Q}=this;return $||($=new T8(q,J,G,Q,M)),$.state32.set(this.state32),$.pos=this.pos,$.posOut=this.posOut,$.finished=this.finished,$.rounds=M,$.suffix=J,$.outputLen=G,$.enableXOF=Q,$.destroyed=this.destroyed,$}}var HJ=($,q,J)=>J8(()=>new T8(q,$,J));var X$=HJ(1,136,32);function s($){const q=c($,"data");return k(Z$(q))}var W$=!1,z$=function($){return X$($)},Z$=z$;s._=z$;s.lock=function(){W$=!0};s.register=function($){if(W$)throw new TypeError("keccak256 is locked");Z$=$};Object.freeze(s);var R8={};c$(R8,{validateObject:()=>{{return j0}},utf8ToBytes:()=>{{return CJ}},numberToVarBytesBE:()=>{{return NJ}},numberToHexUnpadded:()=>{{return V$}},numberToBytesLE:()=>{{return I8}},numberToBytesBE:()=>{{return T0}},hexToNumber:()=>{{return O8}},hexToBytes:()=>{{return C0}},equalBytes:()=>{{return LJ}},ensureBytes:()=>{{return d}},createHmacDrbg:()=>{{return H8}},concatBytes:()=>{{return _0}},bytesToNumberLE:()=>{{return Q8}},bytesToNumberBE:()=>{{return I0}},bytesToHex:()=>{{return L0}},bitSet:()=>{{return BJ}},bitMask:()=>{{return l0}},bitLen:()=>{{return SJ}},bitGet:()=>{{return PJ}}});function L0($){if(!M8($))throw new Error("Uint8Array expected");let q="";for(let J=0;J<$.length;J++)q+=wJ[$[J]];return q}function V$($){const q=$.toString(16);return q.length&1?`0${q}`:q}function O8($){if(typeof $!=="string")throw new Error("hex string expected, got "+typeof $);return BigInt($===""?"0":`0x${$}`)}function C0($){if(typeof $!=="string")throw new Error("hex string expected, got "+typeof $);const q=$.length;if(q%2)throw new Error("padded hex string expected, got unpadded hex of length "+q);const J=new Uint8Array(q/2);for(let G=0;G<J.length;G++){const M=G*2,Q=$.slice(M,M+2),I=Number.parseInt(Q,16);if(Number.isNaN(I)||I<0)throw new Error("Invalid byte sequence");J[G]=I}return J}function I0($){return O8(L0($))}function Q8($){if(!M8($))throw new Error("Uint8Array expected");return O8(L0(Uint8Array.from($).reverse()))}function T0($,q){return C0($.toString(16).padStart(q*2,"0"))}function I8($,q){return T0($,q).reverse()}function NJ($){return C0(V$($))}function d($,q,J){let G;if(typeof q==="string")try{G=C0(q)}catch(Q){throw new Error(`${$} must be valid hex string, got "${q}". Cause: ${Q}`)}else if(M8(q))G=Uint8Array.from(q);else throw new Error(`${$} must be hex string or Uint8Array`);const M=G.length;if(typeof J==="number"&&M!==J)throw new Error(`${$} expected ${J} bytes, got ${M}`);return G}function _0(...$){const q=new Uint8Array($.reduce((G,M)=>G+M.length,0));let J=0;return $.forEach((G)=>{if(!M8(G))throw new Error("Uint8Array expected");q.set(G,J),J+=G.length}),q}function LJ($,q){if($.length!==q.length)return!1;for(let J=0;J<$.length;J++)if($[J]!==q[J])return!1;return!0}function CJ($){if(typeof $!=="string")throw new Error(`utf8ToBytes expected string, got ${typeof $}`);return new Uint8Array((new TextEncoder()).encode($))}function SJ($){let q;for(q=0;$>U$;$>>=G8,q+=1);return q}function PJ($,q){return $>>BigInt(q)&G8}function H8($,q,J){if(typeof $!=="number"||$<2)throw new Error("hashLen must be a number");if(typeof q!=="number"||q<2)throw new Error("qByteLen must be a number");if(typeof J!=="function")throw new Error("hmacFn must be a function");let G=j8($),M=j8($),Q=0;const I=()=>{G.fill(1),M.fill(0),Q=0},X=(...U)=>J(M,G,...U),Y=(U=j8())=>{if(M=X(K$([0]),U),G=X(),U.length===0)return;M=X(K$([1]),U),G=X()},W=()=>{if(Q++>=1000)throw new Error("drbg: tried 1000 values");let U=0;const H=[];while(U<q){G=X();const P=G.slice();H.push(P),U+=G.length}return _0(...H)};return(U,H)=>{I(),Y(U);let P=void 0;while(!(P=H(W())))Y();return I(),P}}function j0($,q,J={}){const G=(M,Q,I)=>{const X=AJ[Q];if(typeof X!=="function")throw new Error(`Invalid validator "${Q}", expected function`);const Y=$[M];if(I&&Y===void 0)return;if(!X(Y,$))throw new Error(`Invalid param ${String(M)}=${Y} (${typeof Y}), expected ${Q}`)};for(let[M,Q]of Object.entries(q))G(M,Q,!1);for(let[M,Q]of Object.entries(J))G(M,Q,!0);return $}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */var U$=BigInt(0),G8=BigInt(1),RJ=BigInt(2),M8=($)=>$ instanceof Uint8Array,wJ=Array.from({length:256},($,q)=>q.toString(16).padStart(2,"0")),BJ=($,q,J)=>{return $|(J?G8:U$)<<BigInt(q)},l0=($)=>(RJ<<BigInt($-1))-G8,j8=($)=>new Uint8Array($),K$=($)=>Uint8Array.from($),AJ={bigint:($)=>typeof $==="bigint",function:($)=>typeof $==="function",boolean:($)=>typeof $==="boolean",string:($)=>typeof $==="string",stringOrUint8Array:($)=>typeof $==="string"||$ instanceof Uint8Array,isSafeInteger:($)=>Number.isSafeInteger($),array:($)=>Array.isArray($),field:($,q)=>q.Fp.isValid($),hash:($)=>typeof $==="function"&&Number.isSafeInteger($.outputLen)};function h($,q){const J=$%q;return J>=y?J:q+J}function kJ($,q,J){if(J<=y||q<y)throw new Error("Expected power/modulo > 0");if(J===_)return y;let G=_;while(q>y){if(q&_)G=G*$%J;$=$*$%J,q>>=_}return G}function i($,q,J){let G=$;while(q-- >y)G*=G,G%=J;return G}function Y8($,q){if($===y||q<=y)throw new Error(`invert: expected positive integers, got n=${$} mod=${q}`);let J=h($,q),G=q,M=y,Q=_,I=_,X=y;while(J!==y){const W=G/J,Z=G%J,U=M-I*W,H=Q-X*W;G=J,J=Z,M=I,Q=X,I=U,X=H}if(G!==_)throw new Error("invert: does not exist");return h(M,q)}function _J($){const q=($-_)/S0;let J,G,M;for(J=$-_,G=0;J%S0===y;J/=S0,G++);for(M=S0;M<$&&kJ(M,q,$)!==$-_;M++);if(G===1){const I=($+_)/w8;return function X(Y,W){const Z=Y.pow(W,I);if(!Y.eql(Y.sqr(Z),W))throw new Error("Cannot find square root");return Z}}const Q=(J+_)/S0;return function I(X,Y){if(X.pow(Y,q)===X.neg(X.ONE))throw new Error("Cannot find square root");let W=G,Z=X.pow(X.mul(X.ONE,M),J),U=X.pow(Y,Q),H=X.pow(Y,J);while(!X.eql(H,X.ONE)){if(X.eql(H,X.ZERO))return X.ZERO;let P=1;for(let V=X.sqr(H);P<W;P++){if(X.eql(V,X.ONE))break;V=X.sqr(V)}const z=X.pow(Z,_<<BigInt(W-P-1));Z=X.sqr(z),U=X.mul(U,z),H=X.mul(H,Z),W=P}return U}}function bJ($){if($%w8===fJ){const q=($+_)/w8;return function J(G,M){const Q=G.pow(M,q);if(!G.eql(G.sqr(Q),M))throw new Error("Cannot find square root");return Q}}if($%T$===D$){const q=($-D$)/T$;return function J(G,M){const Q=G.mul(M,S0),I=G.pow(Q,q),X=G.mul(M,I),Y=G.mul(G.mul(X,S0),I),W=G.mul(X,G.sub(Y,G.ONE));if(!G.eql(G.sqr(W),M))throw new Error("Cannot find square root");return W}}if($%xJ===EJ);return _J($)}function N8($){const q={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},J=FJ.reduce((G,M)=>{return G[M]="function",G},q);return j0($,J)}function yJ($,q,J){if(J<y)throw new Error("Expected power > 0");if(J===y)return $.ONE;if(J===_)return q;let G=$.ONE,M=q;while(J>y){if(J&_)G=$.mul(G,M);M=$.sqr(M),J>>=_}return G}function cJ($,q){const J=new Array(q.length),G=q.reduce((Q,I,X)=>{if($.is0(I))return Q;return J[X]=Q,$.mul(Q,I)},$.ONE),M=$.inv(G);return q.reduceRight((Q,I,X)=>{if($.is0(I))return Q;return J[X]=$.mul(Q,J[X]),$.mul(Q,I)},M),J}function L8($,q){const J=q!==void 0?q:$.toString(2).length,G=Math.ceil(J/8);return{nBitLength:J,nByteLength:G}}function j$($,q,J=!1,G={}){if($<=y)throw new Error(`Expected Field ORDER > 0, got ${$}`);const{nBitLength:M,nByteLength:Q}=L8($,q);if(Q>2048)throw new Error("Field lengths over 2048 bytes are not supported");const I=bJ($),X=Object.freeze({ORDER:$,BITS:M,BYTES:Q,MASK:l0(M),ZERO:y,ONE:_,create:(Y)=>h(Y,$),isValid:(Y)=>{if(typeof Y!=="bigint")throw new Error(`Invalid field element: expected bigint, got ${typeof Y}`);return y<=Y&&Y<$},is0:(Y)=>Y===y,isOdd:(Y)=>(Y&_)===_,neg:(Y)=>h(-Y,$),eql:(Y,W)=>Y===W,sqr:(Y)=>h(Y*Y,$),add:(Y,W)=>h(Y+W,$),sub:(Y,W)=>h(Y-W,$),mul:(Y,W)=>h(Y*W,$),pow:(Y,W)=>yJ(X,Y,W),div:(Y,W)=>h(Y*Y8(W,$),$),sqrN:(Y)=>Y*Y,addN:(Y,W)=>Y+W,subN:(Y,W)=>Y-W,mulN:(Y,W)=>Y*W,inv:(Y)=>Y8(Y,$),sqrt:G.sqrt||((Y)=>I(X,Y)),invertBatch:(Y)=>cJ(X,Y),cmov:(Y,W,Z)=>Z?W:Y,toBytes:(Y)=>J?I8(Y,Q):T0(Y,Q),fromBytes:(Y)=>{if(Y.length!==Q)throw new Error(`Fp.fromBytes: expected ${Q}, got ${Y.length}`);return J?Q8(Y):I0(Y)}});return Object.freeze(X)}function O$($){if(typeof $!=="bigint")throw new Error("field order must be bigint");const q=$.toString(2).length;return Math.ceil(q/8)}function C8($){const q=O$($);return q+Math.ceil(q/2)}function H$($,q,J=!1){const G=$.length,M=O$(q),Q=C8(q);if(G<16||G<Q||G>1024)throw new Error(`expected ${Q}-1024 bytes of input, got ${G}`);const I=J?I0($):Q8($),X=h(I,q-_)+_;return J?I8(X,M):T0(X,M)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */var y=BigInt(0),_=BigInt(1),S0=BigInt(2),fJ=BigInt(3),w8=BigInt(4),D$=BigInt(5),T$=BigInt(8),EJ=BigInt(9),xJ=BigInt(16);var FJ=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function R$($,q){const J=(M,Q)=>{const I=Q.negate();return M?I:Q},G=(M)=>{const Q=Math.ceil(q/M)+1,I=2**(M-1);return{windows:Q,windowSize:I}};return{constTimeNegate:J,unsafeLadder(M,Q){let I=$.ZERO,X=M;while(Q>vJ){if(Q&S8)I=I.add(X);X=X.double(),Q>>=S8}return I},precomputeWindow(M,Q){const{windows:I,windowSize:X}=G(Q),Y=[];let W=M,Z=W;for(let U=0;U<I;U++){Z=W,Y.push(Z);for(let H=1;H<X;H++)Z=Z.add(W),Y.push(Z);W=Z.double()}return Y},wNAF(M,Q,I){const{windows:X,windowSize:Y}=G(M);let{ZERO:W,BASE:Z}=$;const U=BigInt(2**M-1),H=2**M,P=BigInt(M);for(let z=0;z<X;z++){const V=z*Y;let T=Number(I&U);if(I>>=P,T>Y)T-=H,I+=S8;const D=V,w=V+Math.abs(T)-1,S=z%2!==0,N=T<0;if(T===0)Z=Z.add(J(S,Q[D]));else W=W.add(J(N,Q[w]))}return{p:W,f:Z}},wNAFCached(M,Q,I,X){const Y=M._WINDOW_SIZE||1;let W=Q.get(M);if(!W){if(W=this.precomputeWindow(M,Y),Y!==1)Q.set(M,X(W))}return this.wNAF(Y,W,I)}}}function P8($){return N8($.Fp),j0($,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...L8($.n,$.nBitLength),...$,...{p:$.Fp.ORDER}})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */var vJ=BigInt(0),S8=BigInt(1);var mJ=function($){const q=P8($);j0(q,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});const{endo:J,Fp:G,a:M}=q;if(J){if(!G.eql(M,G.ZERO))throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");if(typeof J!=="object"||typeof J.beta!=="bigint"||typeof J.splitScalar!=="function")throw new Error("Expected endomorphism with beta: bigint and splitScalar: function")}return Object.freeze({...q})};function pJ($){const q=mJ($),{Fp:J}=q,G=q.toBytes||((z,V,T)=>{const D=V.toAffine();return _0(Uint8Array.from([4]),J.toBytes(D.x),J.toBytes(D.y))}),M=q.fromBytes||((z)=>{const V=z.subarray(1),T=J.fromBytes(V.subarray(0,J.BYTES)),D=J.fromBytes(V.subarray(J.BYTES,2*J.BYTES));return{x:T,y:D}});function Q(z){const{a:V,b:T}=q,D=J.sqr(z),w=J.mul(D,z);return J.add(J.add(w,J.mul(z,V)),T)}if(!J.eql(J.sqr(q.Gy),Q(q.Gx)))throw new Error("bad generator point: equation left != right");function I(z){return typeof z==="bigint"&&Y0<z&&z<q.n}function X(z){if(!I(z))throw new Error("Expected valid bigint: 0 < bigint < curve.n")}function Y(z){const{allowedPrivateKeyLengths:V,nByteLength:T,wrapPrivateKey:D,n:w}=q;if(V&&typeof z!=="bigint"){if(z instanceof Uint8Array)z=L0(z);if(typeof z!=="string"||!V.includes(z.length))throw new Error("Invalid key");z=z.padStart(T*2,"0")}let S;try{S=typeof z==="bigint"?z:I0(d("private key",z,T))}catch(N){throw new Error(`private key must be ${T} bytes, hex or bigint, not ${typeof z}`)}if(D)S=h(S,w);return X(S),S}const W=new Map;function Z(z){if(!(z instanceof U))throw new Error("ProjectivePoint expected")}class U{constructor(z,V,T){if(this.px=z,this.py=V,this.pz=T,z==null||!J.isValid(z))throw new Error("x required");if(V==null||!J.isValid(V))throw new Error("y required");if(T==null||!J.isValid(T))throw new Error("z required")}static fromAffine(z){const{x:V,y:T}=z||{};if(!z||!J.isValid(V)||!J.isValid(T))throw new Error("invalid affine point");if(z instanceof U)throw new Error("projective point not allowed");const D=(w)=>J.eql(w,J.ZERO);if(D(V)&&D(T))return U.ZERO;return new U(V,T,J.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(z){const V=J.invertBatch(z.map((T)=>T.pz));return z.map((T,D)=>T.toAffine(V[D])).map(U.fromAffine)}static fromHex(z){const V=U.fromAffine(M(d("pointHex",z)));return V.assertValidity(),V}static fromPrivateKey(z){return U.BASE.multiply(Y(z))}_setWindowSize(z){this._WINDOW_SIZE=z,W.delete(this)}assertValidity(){if(this.is0()){if(q.allowInfinityPoint&&!J.is0(this.py))return;throw new Error("bad point: ZERO")}const{x:z,y:V}=this.toAffine();if(!J.isValid(z)||!J.isValid(V))throw new Error("bad point: x or y not FE");const T=J.sqr(V),D=Q(z);if(!J.eql(T,D))throw new Error("bad point: equation left != right");if(!this.isTorsionFree())throw new Error("bad point: not in prime-order subgroup")}hasEvenY(){const{y:z}=this.toAffine();if(J.isOdd)return!J.isOdd(z);throw new Error("Field doesn't support isOdd")}equals(z){Z(z);const{px:V,py:T,pz:D}=this,{px:w,py:S,pz:N}=z,O=J.eql(J.mul(V,N),J.mul(w,D)),R=J.eql(J.mul(T,N),J.mul(S,D));return O&&R}negate(){return new U(this.px,J.neg(this.py),this.pz)}double(){const{a:z,b:V}=q,T=J.mul(V,w$),{px:D,py:w,pz:S}=this;let{ZERO:N,ZERO:O,ZERO:R}=J,L=J.mul(D,D),a=J.mul(w,w),f=J.mul(S,S),A=J.mul(D,w);return A=J.add(A,A),R=J.mul(D,S),R=J.add(R,R),N=J.mul(z,R),O=J.mul(T,f),O=J.add(N,O),N=J.sub(a,O),O=J.add(a,O),O=J.mul(N,O),N=J.mul(A,N),R=J.mul(T,R),f=J.mul(z,f),A=J.sub(L,f),A=J.mul(z,A),A=J.add(A,R),R=J.add(L,L),L=J.add(R,L),L=J.add(L,f),L=J.mul(L,A),O=J.add(O,L),f=J.mul(w,S),f=J.add(f,f),L=J.mul(f,A),N=J.sub(N,L),R=J.mul(f,a),R=J.add(R,R),R=J.add(R,R),new U(N,O,R)}add(z){Z(z);const{px:V,py:T,pz:D}=this,{px:w,py:S,pz:N}=z;let{ZERO:O,ZERO:R,ZERO:L}=J;const a=q.a,f=J.mul(q.b,w$);let A=J.mul(V,w),l=J.mul(T,S),p=J.mul(D,N),W0=J.add(V,T),m=J.add(w,S);W0=J.mul(W0,m),m=J.add(A,l),W0=J.sub(W0,m),m=J.add(V,D);let K=J.add(w,N);return m=J.mul(m,K),K=J.add(A,p),m=J.sub(m,K),K=J.add(T,D),O=J.add(S,N),K=J.mul(K,O),O=J.add(l,p),K=J.sub(K,O),L=J.mul(a,m),O=J.mul(f,p),L=J.add(O,L),O=J.sub(l,L),L=J.add(l,L),R=J.mul(O,L),l=J.add(A,A),l=J.add(l,A),p=J.mul(a,p),m=J.mul(f,m),l=J.add(l,p),p=J.sub(A,p),p=J.mul(a,p),m=J.add(m,p),A=J.mul(l,m),R=J.add(R,A),A=J.mul(K,m),O=J.mul(W0,O),O=J.sub(O,A),A=J.mul(W0,l),L=J.mul(K,L),L=J.add(L,A),new U(O,R,L)}subtract(z){return this.add(z.negate())}is0(){return this.equals(U.ZERO)}wNAF(z){return P.wNAFCached(this,W,z,(V)=>{const T=J.invertBatch(V.map((D)=>D.pz));return V.map((D,w)=>D.toAffine(T[w])).map(U.fromAffine)})}multiplyUnsafe(z){const V=U.ZERO;if(z===Y0)return V;if(X(z),z===o)return this;const{endo:T}=q;if(!T)return P.unsafeLadder(this,z);let{k1neg:D,k1:w,k2neg:S,k2:N}=T.splitScalar(z),O=V,R=V,L=this;while(w>Y0||N>Y0){if(w&o)O=O.add(L);if(N&o)R=R.add(L);L=L.double(),w>>=o,N>>=o}if(D)O=O.negate();if(S)R=R.negate();return R=new U(J.mul(R.px,T.beta),R.py,R.pz),O.add(R)}multiply(z){X(z);let V=z,T,D;const{endo:w}=q;if(w){const{k1neg:S,k1:N,k2neg:O,k2:R}=w.splitScalar(V);let{p:L,f:a}=this.wNAF(N),{p:f,f:A}=this.wNAF(R);L=P.constTimeNegate(S,L),f=P.constTimeNegate(O,f),f=new U(J.mul(f.px,w.beta),f.py,f.pz),T=L.add(f),D=a.add(A)}else{const{p:S,f:N}=this.wNAF(V);T=S,D=N}return U.normalizeZ([T,D])[0]}multiplyAndAddUnsafe(z,V,T){const D=U.BASE,w=(N,O)=>O===Y0||O===o||!N.equals(D)?N.multiplyUnsafe(O):N.multiply(O),S=w(this,V).add(w(z,T));return S.is0()?void 0:S}toAffine(z){const{px:V,py:T,pz:D}=this,w=this.is0();if(z==null)z=w?J.ONE:J.inv(D);const S=J.mul(V,z),N=J.mul(T,z),O=J.mul(D,z);if(w)return{x:J.ZERO,y:J.ZERO};if(!J.eql(O,J.ONE))throw new Error("invZ was invalid");return{x:S,y:N}}isTorsionFree(){const{h:z,isTorsionFree:V}=q;if(z===o)return!0;if(V)return V(U,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:z,clearCofactor:V}=q;if(z===o)return this;if(V)return V(U,this);return this.multiplyUnsafe(q.h)}toRawBytes(z=!0){return this.assertValidity(),G(U,this,z)}toHex(z=!0){return L0(this.toRawBytes(z))}}U.BASE=new U(q.Gx,q.Gy,J.ONE),U.ZERO=new U(J.ZERO,J.ONE,J.ZERO);const H=q.nBitLength,P=R$(U,q.endo?Math.ceil(H/2):H);return{CURVE:q,ProjectivePoint:U,normPrivateKeyToScalar:Y,weierstrassEquation:Q,isWithinCurveOrder:I}}var uJ=function($){const q=P8($);return j0(q,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...q})};function N$($){const q=uJ($),{Fp:J,n:G}=q,M=J.BYTES+1,Q=2*J.BYTES+1;function I(K){return Y0<K&&K<J.ORDER}function X(K){return h(K,G)}function Y(K){return Y8(K,G)}const{ProjectivePoint:W,normPrivateKeyToScalar:Z,weierstrassEquation:U,isWithinCurveOrder:H}=pJ({...q,toBytes(K,j,B){const E=j.toAffine(),x=J.toBytes(E.x),b=_0;if(B)return b(Uint8Array.from([j.hasEvenY()?2:3]),x);else return b(Uint8Array.from([4]),x,J.toBytes(E.y))},fromBytes(K){const j=K.length,B=K[0],E=K.subarray(1);if(j===M&&(B===2||B===3)){const x=I0(E);if(!I(x))throw new Error("Point is not on curve");const b=U(x);let r=J.sqrt(b);const u=(r&o)===o;if((B&1)===1!==u)r=J.neg(r);return{x,y:r}}else if(j===Q&&B===4){const x=J.fromBytes(E.subarray(0,J.BYTES)),b=J.fromBytes(E.subarray(J.BYTES,2*J.BYTES));return{x,y:b}}else throw new Error(`Point of length ${j} was invalid. Expected ${M} compressed bytes or ${Q} uncompressed bytes`)}}),P=(K)=>L0(T0(K,q.nByteLength));function z(K){const j=G>>o;return K>j}function V(K){return z(K)?X(-K):K}const T=(K,j,B)=>I0(K.slice(j,B));class D{constructor(K,j,B){this.r=K,this.s=j,this.recovery=B,this.assertValidity()}static fromCompact(K){const j=q.nByteLength;return K=d("compactSignature",K,j*2),new D(T(K,0,j),T(K,j,2*j))}static fromDER(K){const{r:j,s:B}=P0.toSig(d("DER",K));return new D(j,B)}assertValidity(){if(!H(this.r))throw new Error("r must be 0 < r < CURVE.n");if(!H(this.s))throw new Error("s must be 0 < s < CURVE.n")}addRecoveryBit(K){return new D(this.r,this.s,K)}recoverPublicKey(K){const{r:j,s:B,recovery:E}=this,x=L(d("msgHash",K));if(E==null||![0,1,2,3].includes(E))throw new Error("recovery id invalid");const b=E===2||E===3?j+q.n:j;if(b>=J.ORDER)throw new Error("recovery id 2 or 3 invalid");const r=(E&1)===0?"02":"03",u=W.fromHex(r+P(b)),q0=Y(b),O0=X(-x*q0),B0=X(B*q0),H0=W.BASE.multiplyAndAddUnsafe(u,O0,B0);if(!H0)throw new Error("point at infinify");return H0.assertValidity(),H0}hasHighS(){return z(this.s)}normalizeS(){return this.hasHighS()?new D(this.r,X(-this.s),this.recovery):this}toDERRawBytes(){return C0(this.toDERHex())}toDERHex(){return P0.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return C0(this.toCompactHex())}toCompactHex(){return P(this.r)+P(this.s)}}const w={isValidPrivateKey(K){try{return Z(K),!0}catch(j){return!1}},normPrivateKeyToScalar:Z,randomPrivateKey:()=>{const K=C8(q.n);return H$(q.randomBytes(K),q.n)},precompute(K=8,j=W.BASE){return j._setWindowSize(K),j.multiply(BigInt(3)),j}};function S(K,j=!0){return W.fromPrivateKey(K).toRawBytes(j)}function N(K){const j=K instanceof Uint8Array,B=typeof K==="string",E=(j||B)&&K.length;if(j)return E===M||E===Q;if(B)return E===2*M||E===2*Q;if(K instanceof W)return!0;return!1}function O(K,j,B=!0){if(N(K))throw new Error("first arg must be private key");if(!N(j))throw new Error("second arg must be public key");return W.fromHex(j).multiply(Z(K)).toRawBytes(B)}const R=q.bits2int||function(K){const j=I0(K),B=K.length*8-q.nBitLength;return B>0?j>>BigInt(B):j},L=q.bits2int_modN||function(K){return X(R(K))},a=l0(q.nBitLength);function f(K){if(typeof K!=="bigint")throw new Error("bigint expected");if(!(Y0<=K&&K<a))throw new Error(`bigint expected < 2^${q.nBitLength}`);return T0(K,q.nByteLength)}function A(K,j,B=l){if(["recovered","canonical"].some((R0)=>(R0 in B)))throw new Error("sign() legacy options not supported");const{hash:E,randomBytes:x}=q;let{lowS:b,prehash:r,extraEntropy:u}=B;if(b==null)b=!0;if(K=d("msgHash",K),r)K=d("prehashed msgHash",E(K));const q0=L(K),O0=Z(j),B0=[f(O0),f(q0)];if(u!=null){const R0=u===!0?x(J.BYTES):u;B0.push(d("extraEntropy",R0))}const H0=_0(...B0),u0=q0;function Z8(R0){const A0=R(R0);if(!H(A0))return;const F8=Y(A0),e=W.BASE.multiply(A0).toAffine(),f0=X(e.x);if(f0===Y0)return;const d0=X(F8*X(u0+f0*O0));if(d0===Y0)return;let y8=(e.x===f0?0:2)|Number(e.y&o),c8=d0;if(b&&z(d0))c8=V(d0),y8^=1;return new D(f0,c8,y8)}return{seed:H0,k2sig:Z8}}const l={lowS:q.lowS,prehash:!1},p={lowS:q.lowS,prehash:!1};function W0(K,j,B=l){const{seed:E,k2sig:x}=A(K,j,B),b=q;return H8(b.hash.outputLen,b.nByteLength,b.hmac)(E,x)}W.BASE._setWindowSize(8);function m(K,j,B,E=p){const x=K;if(j=d("msgHash",j),B=d("publicKey",B),("strict"in E))throw new Error("options.strict was renamed to lowS");const{lowS:b,prehash:r}=E;let u=void 0,q0;try{if(typeof x==="string"||x instanceof Uint8Array)try{u=D.fromDER(x)}catch(e){if(!(e instanceof P0.Err))throw e;u=D.fromCompact(x)}else if(typeof x==="object"&&typeof x.r==="bigint"&&typeof x.s==="bigint"){const{r:e,s:f0}=x;u=new D(e,f0)}else throw new Error("PARSE");q0=W.fromHex(B)}catch(e){if(e.message==="PARSE")throw new Error("signature must be Signature instance, Uint8Array or hex string");return!1}if(b&&u.hasHighS())return!1;if(r)j=q.hash(j);const{r:O0,s:B0}=u,H0=L(j),u0=Y(B0),Z8=X(H0*u0),R0=X(O0*u0),A0=W.BASE.multiplyAndAddUnsafe(q0,Z8,R0)?.toAffine();if(!A0)return!1;return X(A0.x)===O0}return{CURVE:q,getPublicKey:S,getSharedSecret:O,sign:W0,verify:m,ProjectivePoint:W,Signature:D,utils:w}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */var{bytesToNumberBE:hJ,hexToBytes:lJ}=R8,P0={Err:class $ extends Error{constructor(q=""){super(q)}},_parseInt($){const{Err:q}=P0;if($.length<2||$[0]!==2)throw new q("Invalid signature integer tag");const J=$[1],G=$.subarray(2,J+2);if(!J||G.length!==J)throw new q("Invalid signature integer: wrong length");if(G[0]&128)throw new q("Invalid signature integer: negative");if(G[0]===0&&!(G[1]&128))throw new q("Invalid signature integer: unnecessary leading zero");return{d:hJ(G),l:$.subarray(J+2)}},toSig($){const{Err:q}=P0,J=typeof $==="string"?lJ($):$;if(!(J instanceof Uint8Array))throw new Error("ui8a expected");let G=J.length;if(G<2||J[0]!=48)throw new q("Invalid signature tag");if(J[1]!==G-2)throw new q("Invalid signature: incorrect length");const{d:M,l:Q}=P0._parseInt(J.subarray(2)),{d:I,l:X}=P0._parseInt(Q);if(X.length)throw new q("Invalid signature: left bytes after parsing");return{r:M,s:I}},hexFromSig($){const q=(W)=>Number.parseInt(W[0],16)&8?"00"+W:W,J=(W)=>{const Z=W.toString(16);return Z.length&1?`0${Z}`:Z},G=q(J($.s)),M=q(J($.r)),Q=G.length/2,I=M.length/2,X=J(Q),Y=J(I);return`30${J(I+Q+4)}02${Y}${M}02${X}${G}`}},Y0=BigInt(0),o=BigInt(1),$G=BigInt(2),w$=BigInt(3),JG=BigInt(4);function dJ($){return{hash:$,hmac:(q,...J)=>V8($,q,n8(...J)),randomBytes:o8}}function L$($,q){const J=(G)=>N$({...$,...dJ(G)});return Object.freeze({...J(q),create:J})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */var nJ=function($){const q=P$,J=BigInt(3),G=BigInt(6),M=BigInt(11),Q=BigInt(22),I=BigInt(23),X=BigInt(44),Y=BigInt(88),W=$*$*$%q,Z=W*W*$%q,U=i(Z,J,q)*Z%q,H=i(U,J,q)*Z%q,P=i(H,B8,q)*W%q,z=i(P,M,q)*P%q,V=i(z,Q,q)*z%q,T=i(V,X,q)*V%q,D=i(T,Y,q)*T%q,w=i(D,X,q)*V%q,S=i(w,J,q)*Z%q,N=i(S,I,q)*z%q,O=i(N,G,q)*W%q,R=i(O,B8,q);if(!A8.eql(A8.sqr(R),$))throw new Error("Cannot find square root");return R};/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */var P$=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),C$=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),iJ=BigInt(1),B8=BigInt(2),S$=($,q)=>($+q/B8)/q,A8=j$(P$,void 0,void 0,{sqrt:nJ}),X0=L$({a:BigInt(0),b:BigInt(7),Fp:A8,n:C$,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:($)=>{const q=C$,J=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),G=-iJ*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),M=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),Q=J,I=BigInt("0x100000000000000000000000000000000"),X=S$(Q*$,q),Y=S$(-G*$,q);let W=h($-X*J-Y*M,q),Z=h(-X*G-Y*Q,q);const U=W>I,H=Z>I;if(U)W=q-W;if(H)Z=q-Z;if(W>I||Z>I)throw new Error("splitScalar: Endomorphism failed, k="+$);return{k1neg:U,k1:W,k2neg:H,k2:Z}}}},r8),zG=BigInt(0);var ZG=X0.ProjectivePoint;var X8="0x0000000000000000000000000000000000000000000000000000000000000000";var f8=`\x19Ethereum Signed Message:
`;var k$=function($){return a0(t0($),32)},B$=BigInt(0),A$=BigInt(1),f$=BigInt(2),E$=BigInt(27),x$=BigInt(28),W8=BigInt(35),b0={};class n{#$;#q;#G;#J;get r(){return this.#$}set r($){C(M0($)===32,"invalid r","value",$),this.#$=k($)}get s(){return this.#q}set s($){C(M0($)===32,"invalid s","value",$);const q=k($);C(parseInt(q.substring(0,3))<8,"non-canonical s","value",q),this.#q=q}get v(){return this.#G}set v($){const q=K0($,"value");C(q===27||q===28,"invalid v","v",$),this.#G=q}get networkV(){return this.#J}get legacyChainId(){const $=this.networkV;if($==null)return null;return n.getChainId($)}get yParity(){return this.v===27?0:1}get yParityAndS(){const $=c(this.s);if(this.yParity)$[0]|=128;return k($)}get compactSerialized(){return G0([this.r,this.yParityAndS])}get serialized(){return G0([this.r,this.s,this.yParity?"0x1c":"0x1b"])}constructor($,q,J,G){o0($,b0,"Signature"),this.#$=q,this.#q=J,this.#G=G,this.#J=null}[Symbol.for("nodejs.util.inspect.custom")](){return`Signature { r: "${this.r}", s: "${this.s}", yParity: ${this.yParity}, networkV: ${this.networkV} }`}clone(){const $=new n(b0,this.r,this.s,this.v);if(this.networkV)$.#J=this.networkV;return $}toJSON(){const $=this.networkV;return{_type:"signature",networkV:$!=null?$.toString():null,r:this.r,s:this.s,v:this.v}}static getChainId($){const q=Z0($,"v");if(q==E$||q==x$)return B$;return C(q>=W8,"invalid EIP-155 v","v",$),(q-W8)/f$}static getChainIdV($,q){return Z0($)*f$+BigInt(35+q-27)}static getNormalizedV($){const q=Z0($);if(q===B$||q===E$)return 27;if(q===A$||q===x$)return 28;return C(q>=W8,"invalid v","v",$),q&A$?27:28}static from($){function q(Y,W){C(Y,W,"signature",$)}if($==null)return new n(b0,X8,X8,27);if(typeof $==="string"){const Y=c($,"signature");if(Y.length===64){const W=k(Y.slice(0,32)),Z=Y.slice(32,64),U=Z[0]&128?28:27;return Z[0]&=127,new n(b0,W,k(Z),U)}if(Y.length===65){const W=k(Y.slice(0,32)),Z=Y.slice(32,64);q((Z[0]&128)===0,"non-canonical s");const U=n.getNormalizedV(Y[64]);return new n(b0,W,k(Z),U)}q(!1,"invalid raw signature length")}if($ instanceof n)return $.clone();const J=$.r;q(J!=null,"missing r");const G=k$(J),M=function(Y,W){if(Y!=null)return k$(Y);if(W!=null){q(x0(W,32),"invalid yParityAndS");const Z=c(W);return Z[0]&=127,k(Z)}q(!1,"missing s")}($.s,$.yParityAndS);q((c(M)[0]&128)==0,"non-canonical s");const{networkV:Q,v:I}=function(Y,W,Z){if(Y!=null){const U=Z0(Y);return{networkV:U>=W8?U:void 0,v:n.getNormalizedV(U)}}if(W!=null)return q(x0(W,32),"invalid yParityAndS"),{v:c(W)[0]&128?28:27};if(Z!=null){switch(K0(Z,"sig.yParity")){case 0:return{v:27};case 1:return{v:28}}q(!1,"invalid yParity")}q(!1,"missing v")}($.v,$.yParityAndS,$.yParity),X=new n(b0,G,M,I);if(Q)X.#J=Q;return q($.yParity==null||K0($.yParity,"sig.yParity")===X.yParity,"yParity mismatch"),q($.yParityAndS==null||$.yParityAndS===X.yParityAndS,"yParityAndS mismatch"),X}}class J0{#$;constructor($){C(M0($)===32,"invalid private key","privateKey","[REDACTED]"),this.#$=k($)}get privateKey(){return this.#$}get publicKey(){return J0.computePublicKey(this.#$)}get compressedPublicKey(){return J0.computePublicKey(this.#$,!0)}sign($){C(M0($)===32,"invalid digest length","digest",$);const q=X0.sign(z0($),z0(this.#$),{lowS:!0});return n.from({r:g0(q.r,32),s:g0(q.s,32),v:q.recovery?28:27})}computeSharedSecret($){const q=J0.computePublicKey($);return k(X0.getSharedSecret(z0(this.#$),c(q),!1))}static computePublicKey($,q){let J=c($,"key");if(J.length===32){const M=X0.getPublicKey(J,!!q);return k(M)}if(J.length===64){const M=new Uint8Array(65);M[0]=4,M.set(J,1),J=M}const G=X0.ProjectivePoint.fromHex(J);return k(G.toRawBytes(q))}static recoverPublicKey($,q){C(M0($)===32,"invalid digest length","digest",$);const J=n.from(q);let G=X0.Signature.fromCompact(z0(G0([J.r,J.s])));G=G.addRecoveryBit(J.yParity);const M=G.recoverPublicKey(z0($));return C(M!=null,"invalid signature for digest","signature",q),"0x"+M.toHex(!1)}static addPoints($,q,J){const G=X0.ProjectivePoint.fromHex(J0.computePublicKey($).substring(2)),M=X0.ProjectivePoint.fromHex(J0.computePublicKey(q).substring(2));return"0x"+G.add(M).toHex(!!J)}}var _$=function($){$=$.toLowerCase();const q=$.substring(2).split(""),J=new Uint8Array(40);for(let M=0;M<40;M++)J[M]=q[M].charCodeAt(0);const G=c(s(J));for(let M=0;M<40;M+=2){if(G[M>>1]>>4>=8)q[M]=q[M].toUpperCase();if((G[M>>1]&15)>=8)q[M+1]=q[M+1].toUpperCase()}return"0x"+q.join("")},rJ=function($){$=$.toUpperCase(),$=$.substring(4)+$.substring(0,2)+"00";let q=$.split("").map((G)=>{return E8[G]}).join("");while(q.length>=b$){let G=q.substring(0,b$);q=parseInt(G,10)%97+q.substring(G.length)}let J=String(98-parseInt(q,10)%97);while(J.length<2)J="0"+J;return J},sJ=function($){$=$.toLowerCase();let q=oJ;for(let J=0;J<$.length;J++)q=q*aJ+tJ[$[J]];return q};function g($){if(C(typeof $==="string","invalid address","address",$),$.match(/^(0x)?[0-9a-fA-F]{40}$/)){if(!$.startsWith("0x"))$="0x"+$;const q=_$($);return C(!$.match(/([A-F].*[a-f])|([a-f].*[A-F])/)||q===$,"bad address checksum","address",$),q}if($.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)){C($.substring(2,4)===rJ($),"bad icap checksum","address",$);let q=sJ($.substring(4)).toString(16);while(q.length<40)q="0"+q;return _$("0x"+q)}C(!1,"invalid address","address",$)}var oJ=BigInt(0),aJ=BigInt(36),E8={};for(let $=0;$<10;$++)E8[String($)]=String($);for(let $=0;$<26;$++)E8[String.fromCharCode(65+$)]=String(10+$);var b$=15,tJ=function(){const $={};for(let q=0;q<36;q++){const J="0123456789abcdefghijklmnopqrstuvwxyz"[q];$[J]=BigInt(q)}return $}();function p0($){try{return g($),!0}catch(q){}return!1}function F$($){let q;if(typeof $==="string")q=J0.computePublicKey($,!1);else q=$.publicKey;return g(s("0x"+q.substring(4)).substring(26))}function x8($,q){return F$(J0.recoverPublicKey($,q))}function k8($){if(typeof $==="string")$=U0($);return s(G0([U0(f8),U0(String($.length)),$]))}function z8($,q){const J=k8($);return x8(J,q)}var qq=function($){return k(U0($))};class _8{constructor($,q,J,G=[]){if(!$)throw new Error("SecurityManager: localUserEthAddress es requerido.");try{this.localUserEthAddress=g($)}catch(M){throw new Error(`SecurityManager: localUserEthAddress '${$}' no es una direcci\xF3n de Ethereum v\xE1lida.`)}if(!q)throw new Error("SecurityManager: dbInstance (GraphDB) es requerida.");if(!J||typeof J.mapChangeTypeToRbacAction!=="function"||typeof J.can!=="function")throw new Error("SecurityManager: rbacFunctions con m\xE9todos 'can' y 'mapChangeTypeToRbacAction' es requerido.");this.gdb=q,this.rbac=J,this.superAdminEthereumAddresses=(G||[]).map((M)=>{try{return g(M)}catch(Q){return console.error("SM: Error al normalizar direcci\xF3n de superadmin, se omitir\xE1:",M,Q),null}}).filter((M)=>M!==null),this.strictMode=!0,console.log(`SM: SecurityManager inicializado para ETH Address ${this.localUserEthAddress}. Modo estricto: ${this.strictMode}. SuperAdmins ETH Addresses configurados: ${this.superAdminEthereumAddresses.length}`)}_canonicalizeDataForSigning($){const{signature:q,originEthAddress:J,...G}=$;return JSON.stringify(G,Object.keys(G).sort())}async signOutgoingOperations($){if(!this.localUserEthAddress)return console.warn("SM: Usuario ETH local no establecido."),this.strictMode?[]:$;if(!window.ethereum||!window.ethereum.request)return console.error("SM: MetaMask (window.ethereum) no detectado. No se pueden firmar operaciones."),this.strictMode?[]:$;const q=[];for(let J of $){const G={...J,originUser:this.localUserEthAddress},M=this._canonicalizeDataForSigning(G),Q=qq(M);try{const I=await window.ethereum.request({method:"personal_sign",params:[Q,this.localUserEthAddress]});q.push({...G,originEthAddress:G.originUser,signature:I})}catch(I){if(console.error(`SM: Error al firmar operaci\xF3n con MetaMask para ${this.localUserEthAddress}:`,I),I.code===4001)console.warn("SM: El usuario rechaz\xF3 la solicitud de firma en MetaMask.");if(this.strictMode)continue}}return q}async verifyIncomingOperations($){const q=[],J=[];for(let G of $){let M=!1,Q=G;if(G.signature&&G.originEthAddress){const{signature:I,originEthAddress:X,...Y}=G;let W;try{W=g(X)}catch(H){console.warn(`SM: originEthAddress '${X}' en operaci\xF3n entrante no es v\xE1lida. Op descartada:`,G),J.push(G);continue}Q=Y;const Z={...Y,originUser:W},U=this._canonicalizeDataForSigning(Z);try{const H=z8(U,I);if(g(H)===W){console.log(`SM: Firma v\xE1lida para operaci\xF3n de ${W}.`);const P=Y.type;if(P==="put"&&(Y.id&&typeof Y.id==="string"&&Y.id.startsWith("user:"))&&(Y.value&&typeof Y.value.role==="string"))if(this.superAdminEthereumAddresses.includes(W))M=!0,console.log(`SM: Acci\xF3n 'assignRole' P2P permitida para ${W} (superadmin por config).`);else console.warn(`SM: Intento de 'assignRole' P2P por ${W}. Su direcci\xF3n NO est\xE1 en config de superadmins. Descartado.`);else{const V=`user:${W}`,D=(await this.gdb.get(V)).result;if(D&&D.value&&D.value.role){const w=D.value.role;if(D.value.expiresAt&&new Date(D.value.expiresAt)<new Date)console.warn(`SM: Rol para ${W} ha caducado. Op descartada.`);else{const S=this.rbac.mapChangeTypeToRbacAction(P,Y);if(this.rbac.can(w,S))M=!0;else console.warn(`SM: Usuario ${W} (rol ${w}) no tiene permiso RBAC para '${S}'. Op descartada.`)}}else console.warn(`SM: No se encontr\xF3 nodo o rol en GDB para ${W} para operaci\xF3n '${P}'.`)}}else console.warn(`SM: Firma inv\xE1lida o no coincide con originEthAddress. Recuperada: ${g(H)}, Esperada: ${W}. Op descartada.`)}catch(H){console.error("SM: Error al verificar firma de Ethereum:",H,G)}}else console.warn("SM: Operaci\xF3n recibida sin firma o sin originEthAddress.",G);if(M)q.push({...Q,originUser:normalizedOriginEthAddress});else J.push(G)}return{validatedOperations:q,unverifiedOperations:J}}isStrictMode(){return this.strictMode}setStrictMode($){this.strictMode=$}}function bM($){if(typeof $!=="object"||$===null)throw new Error("RBAC: Los roles personalizados deben ser un objeto v\xE1lido.");y0=$,console.log("RBAC: Roles personalizados establecidos.")}function b8($,q,J=new Set){const G=y0;if(!G[$])return!1;if(J.has($))return!1;if(J.add($),G[$].can&&G[$].can.includes(q))return!0;if(G[$].inherits&&Array.isArray(G[$].inherits))return G[$].inherits.some((M)=>b8(M,q,new Set(J)));return!1}async function FM($,q,J=[]){if(!$)throw new Error("RBAC: Se requiere instancia de GraphDB para inicializar la seguridad.");if(!q)throw new Error("RBAC: No se proporcion\xF3 direcci\xF3n de Ethereum para inicializar la seguridad.");let G;try{G=g(q)}catch(Y){throw new Error(`RBAC: La direcci\xF3n de Ethereum proporcionada '${q}' no es v\xE1lida.`)}if(F=$,v=G,c0=(J||[]).map((Y)=>{try{return g(Y)}catch{return null}}).filter((Y)=>Y!==null),console.log(`RBAC: Inicializando seguridad completa para la direcci\xF3n ETH: ${v}`),F0=new _8(v,F,{can:b8,mapChangeTypeToRbacAction:Iq},c0),F.securityManager=F0,F.sendData&&!F._originalSendDataByRBAC)F._originalSendDataByRBAC=F.sendData.bind(F),F.sendData=async(Y)=>{if(!F0)return F._originalSendDataByRBAC(Y);const W=await F0.signOutgoingOperations(Y);return F._originalSendDataByRBAC(W)},console.log("RBAC: GDB sendData envuelto para firmas con MetaMask.");const M=`user:${v}`,Q=await F.get(M),I=Q.result&&Q.result.value||{};let X=I.role;if(!X)X=Object.keys(y0).includes("user")?"user":Object.keys(y0)[Object.keys(y0).length-1];if(I.role!==X||!Q.result||I.ethAddress!==v)await F.put({...I,ethAddress:v,role:X},M),console.log(`RBAC: Nodo para ETH Address ${v} (rol '${X}') asegurado en GDB.`);else console.log(`RBAC: Nodo para ETH Address ${v} ya existe y est\xE1 actualizado.`);return console.log(`RBAC: Seguridad P2P (MetaMask) configurada y activa para ${v}.`),v}async function yM(){if(console.log("RBAC: Desactivando seguridad P2P (MetaMask)."),F&&F._originalSendDataByRBAC)F.sendData=F._originalSendDataByRBAC,delete F._originalSendDataByRBAC;if(F)F.securityManager=null;F0=null,v=null,c0=[],console.log("RBAC: Seguridad desactivada.")}async function cM($,q,J,G=null){if(await $.ready,!p0(q))throw new Error("RBAC: targetUserEthAddress no es una direcci\xF3n ETH v\xE1lida.");if(!y0[J])throw new Error(`RBAC: El rol '${J}' no existe.`);const M=g(q),Q=`user:${M}`,I=await $.get(Q),Y={...I.result&&I.result.value||{},ethAddress:M,role:J,assignedByEthAddress:v,expiresAt:G?new Date(G).toISOString():null};await $.put(Y,Q),console.log(`RBAC: Solicitud de asignaci\xF3n de rol '${J}' a ETH Address '${M}' enviada a GDB.`)}async function Gq(){if(!v||!c0||c0.length===0)return!1;return c0.includes(v)}async function Mq($,q,J){let G;try{G=g(q)}catch(I){throw new Error(`RBAC: Direcci\xF3n ETH '${q}' inv\xE1lida al verificar rol para '${J}'.`)}const M=await $.get(`user:${G}`);if(!M.result||!M.result.value||!M.result.value.role)throw new Error(`RBAC: No se encontr\xF3 rol para ETH Address ${G} en GDB para la operaci\xF3n '${J}'.`);const Q=M.result.value;if(Q.expiresAt&&new Date(Q.expiresAt)<new Date)throw new Error(`RBAC: Rol para ETH Address ${G} ha caducado.`);return Q.role}async function Qq($,q,J){const G=await Mq($,q,J);if(!b8(G,J))throw new Error(`RBAC: Usuario ETH ${q} (rol ${G}) no tiene permiso para '${J}'.`)}async function gM($,q,J,G){let M;try{M=g(q)}catch(I){throw new Error(`RBAC (executeWithPermission): Direcci\xF3n ETH '${q}' inv\xE1lida.`)}if(F0&&v&&M!==v)throw new Error(`RBAC (executeWithPermission): Intento de operaci\xF3n como '${M}' pero la sesi\xF3n es para '${v}'.`);let Q=!1;if(J==="assignRole"){if(await Gq())Q=!0,console.log(`RBAC (executeWithPermission): ETH Address ${v} autorizado para 'assignRole' por config.`)}else await Qq($,M,J),Q=!0;if(!Q)throw new Error(`RBAC (executeWithPermission): ETH Address ${M} NO TIENE PERMISO para '${J}'.`);return await G(M)}function Iq($,q={}){if($==="put"||$==="insert"||$==="update")return"write";if($==="remove")return"delete";if($==="link")return"link";if($==="sync"||$==="syncReceive")return"sync";return console.warn(`RBAC: Tipo de cambio desconocido '${$}' para mapeo RBAC.`),"unknown"}var y0={superadmin:{can:["assignRole","deleteAny"],inherits:["admin"]},admin:{can:["delete"],inherits:["manager"]},manager:{can:["publish"],inherits:["user"]},user:{can:["write","link","sync"],inherits:["guest"]},guest:{can:["read"]}},F=null,v=null,F0=null,c0=[];export{bM as setCustomRoles,Iq as mapChangeTypeToRbacAction,FM as initializeCompleteSecurity,gM as executeWithPermission,yM as deactivateSecurity,b8 as can,cM as assignRole};
