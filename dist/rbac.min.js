var l$=Object.defineProperty;var p$=($,q)=>{for(var J in q)l$($,J,{get:q[J],enumerable:!0,configurable:!0,set:(G)=>q[J]=()=>G})};var h8="6.14.1";var u$=function($,q,J){const G=q.split("|").map((M)=>M.trim());for(let M=0;M<G.length;M++)switch(q){case"any":return;case"bigint":case"boolean":case"number":case"string":if(typeof $===q)return}const Q=new Error(`invalid value for type ${q}`);throw Q.code="INVALID_ARGUMENT",Q.argument=`value.${J}`,Q.value=$,Q};function i0($,q,J){for(let G in q){let Q=q[G];const M=J?J[G]:null;if(M)u$(Q,M,G);Object.defineProperty($,G,{enumerable:!0,value:Q,writable:!1})}}var A0=function($){if($==null)return"null";if(Array.isArray($))return"[ "+$.map(A0).join(", ")+" ]";if($ instanceof Uint8Array){let J="0x";for(let G=0;G<$.length;G++)J+="0123456789abcdef"[$[G]>>4],J+="0123456789abcdef"[$[G]&15];return J}if(typeof $==="object"&&typeof $.toJSON==="function")return A0($.toJSON());switch(typeof $){case"boolean":case"symbol":return $.toString();case"bigint":return BigInt($).toString();case"number":return $.toString();case"string":return JSON.stringify($);case"object":{const q=Object.keys($);return q.sort(),"{ "+q.map((J)=>`${A0(J)}: ${A0($[J])}`).join(", ")+" }"}}return"[ COULD NOT SERIALIZE ]"};function V8($,q,J){let G=$;{const M=[];if(J){if(("message"in J)||("code"in J)||("name"in J))throw new Error(`value will overwrite populated values: ${A0(J)}`);for(let Y in J){if(Y==="shortMessage")continue;const I=J[Y];M.push(Y+"="+A0(I))}}if(M.push(`code=${q}`),M.push(`version=${h8}`),M.length)$+=" ("+M.join(", ")+")"}let Q;switch(q){case"INVALID_ARGUMENT":Q=new TypeError($);break;case"NUMERIC_FAULT":case"BUFFER_OVERRUN":Q=new RangeError($);break;default:Q=new Error($)}if(i0(Q,{code:q}),J)Object.assign(Q,J);if(Q.shortMessage==null)i0(Q,{shortMessage:G});return Q}function $0($,q,J,G){if(!$)throw V8(q,J,G)}function C($,q,J,G){$0($,q,"INVALID_ARGUMENT",{argument:J,value:G})}function o0($){$0(d$.indexOf($)>=0,"platform missing String.prototype.normalize","UNSUPPORTED_OPERATION",{operation:"String.prototype.normalize",info:{form:$}})}function n0($,q,J){if(J==null)J="";if($!==q){let G=J,Q="new";if(J)G+=".",Q+=" "+J;$0(!1,`private constructor; use ${G}from* methods`,"UNSUPPORTED_OPERATION",{operation:Q})}}var d$=["NFD","NFC","NFKD","NFKC"].reduce(($,q)=>{try{if("test".normalize(q)!=="test")throw new Error("bad");if(q==="NFD"){const J=String.fromCharCode(233).normalize("NFD"),G=String.fromCharCode(101,769);if(J!==G)throw new Error("broken")}$.push(q)}catch(J){}return $},[]);var p8=function($,q,J){if($ instanceof Uint8Array){if(J)return new Uint8Array($);return $}if(typeof $==="string"&&$.match(/^0x(?:[0-9a-f][0-9a-f])*$/i)){const G=new Uint8Array(($.length-2)/2);let Q=2;for(let M=0;M<G.length;M++)G[M]=parseInt($.substring(Q,Q+2),16),Q+=2;return G}C(!1,"invalid BytesLike value",q||"value",$)};function v($,q){return p8($,q,!1)}function z0($,q){return p8($,q,!0)}function k0($,q){if(typeof $!=="string"||!$.match(/^0x[0-9A-Fa-f]*$/))return!1;if(typeof q==="number"&&$.length!==2+2*q)return!1;if(q===!0&&$.length%2!==0)return!1;return!0}function _($){const q=v($);let J="0x";for(let G=0;G<q.length;G++){const Q=q[G];J+=l8[(Q&240)>>4]+l8[Q&15]}return J}function Q0($){return"0x"+$.map((q)=>_(q).substring(2)).join("")}function M0($){if(k0($,!0))return($.length-2)/2;return v($).length}var i$=function($,q,J){const G=v($);$0(q>=G.length,"padding exceeds data length","BUFFER_OVERRUN",{buffer:new Uint8Array(G),length:q,offset:q+1});const Q=new Uint8Array(q);if(Q.fill(0),J)Q.set(G,q-G.length);else Q.set(G,0);return _(Q)};function a0($,q){return i$($,q,!0)}var l8="0123456789abcdef";function K0($,q){switch(typeof $){case"bigint":return $;case"number":return C(Number.isInteger($),"underflow",q||"value",$),C($>=-_0&&$<=_0,"overflow",q||"value",$),BigInt($);case"string":try{if($==="")throw new Error("empty string");if($[0]==="-"&&$[1]!=="-")return-BigInt($.substring(1));return BigInt($)}catch(J){C(!1,`invalid BigNumberish string: ${J.message}`,q||"value",$)}}C(!1,"invalid BigNumberish value",q||"value",$)}function r0($,q){const J=K0($,q);return $0(J>=u8,"unsigned value cannot be negative","NUMERIC_FAULT",{fault:"overflow",operation:"getUint",value:$}),J}function V0($,q){switch(typeof $){case"bigint":return C($>=-_0&&$<=_0,"overflow",q||"value",$),Number($);case"number":return C(Number.isInteger($),"underflow",q||"value",$),C($>=-_0&&$<=_0,"overflow",q||"value",$),$;case"string":try{if($==="")throw new Error("empty string");return V0(BigInt($),q)}catch(J){C(!1,`invalid numeric string: ${J.message}`,q||"value",$)}}C(!1,"invalid numeric value",q||"value",$)}function v0($,q){let G=r0($,"value").toString(16);if(q==null){if(G.length%2)G="0"+G}else{const Q=V0(q,"width");$0(Q*2>=G.length,`value exceeds width (${Q} bytes)`,"NUMERIC_FAULT",{operation:"toBeHex",fault:"overflow",value:$});while(G.length<Q*2)G="0"+G}return"0x"+G}function t0($){const q=r0($,"value");if(q===u8)return new Uint8Array([]);let J=q.toString(16);if(J.length%2)J="0"+J;const G=new Uint8Array(J.length/2);for(let Q=0;Q<G.length;Q++){const M=Q*2;G[Q]=parseInt(J.substring(M,M+2),16)}return G}var u8=BigInt(0),Lq=BigInt(1),_0=9007199254740991;var o$=function($,q,J,G,Q){C(!1,`invalid codepoint at offset ${q}; ${$}`,"bytes",J)},d8=function($,q,J,G,Q){if($==="BAD_PREFIX"||$==="UNEXPECTED_CONTINUE"){let M=0;for(let Y=q+1;Y<J.length;Y++){if(J[Y]>>6!==2)break;M++}return M}if($==="OVERRUN")return J.length-q-1;return 0},n$=function($,q,J,G,Q){if($==="OVERLONG")return C(typeof Q==="number","invalid bad code point for replacement","badCodepoint",Q),G.push(Q),0;return G.push(65533),d8($,q,J,G,Q)};function U0($,q){if(C(typeof $==="string","invalid string value","str",$),q!=null)o0(q),$=$.normalize(q);let J=[];for(let G=0;G<$.length;G++){const Q=$.charCodeAt(G);if(Q<128)J.push(Q);else if(Q<2048)J.push(Q>>6|192),J.push(Q&63|128);else if((Q&64512)==55296){G++;const M=$.charCodeAt(G);C(G<$.length&&(M&64512)===56320,"invalid surrogate pair","str",$);const Y=65536+((Q&1023)<<10)+(M&1023);J.push(Y>>18|240),J.push(Y>>12&63|128),J.push(Y>>6&63|128),J.push(Y&63|128)}else J.push(Q>>12|224),J.push(Q>>6&63|128),J.push(Q&63|128)}return new Uint8Array(J)}var i8=Object.freeze({error:o$,ignore:d8,replace:n$});var m0=function($){if(!Number.isSafeInteger($)||$<0)throw new Error(`Wrong positive integer: ${$}`)};var c0=function($,...q){if(!($ instanceof Uint8Array))throw new Error("Expected Uint8Array");if(q.length>0&&!q.includes($.length))throw new Error(`Expected Uint8Array of length ${q}, not of length=${$.length}`)},o8=function($){if(typeof $!=="function"||typeof $.create!=="function")throw new Error("Hash should be wrapped by utils.wrapConstructor");m0($.outputLen),m0($.blockLen)},Y0=function($,q=!0){if($.destroyed)throw new Error("Hash instance has been destroyed");if(q&&$.finished)throw new Error("Hash#digest() has already been called")},s0=function($,q){c0($);const J=q.outputLen;if($.length<J)throw new Error(`digestInto() expects output buffer of length at least ${J}`)};var e0=typeof globalThis==="object"&&("crypto"in globalThis)?globalThis.crypto:void 0;function zJ($){if(typeof $!=="string")throw new Error(`utf8ToBytes expected string, got ${typeof $}`);return new Uint8Array((new TextEncoder()).encode($))}function L0($){if(typeof $==="string")$=zJ($);if(!n8($))throw new Error(`expected Uint8Array, got ${typeof $}`);return $}function r8(...$){const q=new Uint8Array($.reduce((G,Q)=>G+Q.length,0));let J=0;return $.forEach((G)=>{if(!n8(G))throw new Error("Uint8Array expected");q.set(G,J),J+=G.length}),q}function J8($){const q=(G)=>$().update(L0(G)).digest(),J=$();return q.outputLen=J.outputLen,q.blockLen=J.blockLen,q.create=()=>$(),q}function t8($=32){if(e0&&typeof e0.getRandomValues==="function")return e0.getRandomValues(new Uint8Array($));throw new Error("crypto.getRandomValues must be defined")}/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */var n8=($)=>$ instanceof Uint8Array;var a8=($)=>new Uint32Array($.buffer,$.byteOffset,Math.floor($.byteLength/4)),$8=($)=>new DataView($.buffer,$.byteOffset,$.byteLength),t=($,q)=>$<<32-q|$>>>q,ZJ=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;if(!ZJ)throw new Error("Non little-endian hardware is not supported");class N0{clone(){return this._cloneInto()}}var bq={}.toString;class U8 extends N0{constructor($,q){super();this.finished=!1,this.destroyed=!1,o8($);const J=L0(q);if(this.iHash=$.create(),typeof this.iHash.update!=="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const G=this.blockLen,Q=new Uint8Array(G);Q.set(J.length>G?$.create().update(J).digest():J);for(let M=0;M<Q.length;M++)Q[M]^=54;this.iHash.update(Q),this.oHash=$.create();for(let M=0;M<Q.length;M++)Q[M]^=54^92;this.oHash.update(Q),Q.fill(0)}update($){return Y0(this),this.iHash.update($),this}digestInto($){Y0(this),c0($,this.outputLen),this.finished=!0,this.iHash.digestInto($),this.oHash.update($),this.oHash.digestInto($),this.destroy()}digest(){const $=new Uint8Array(this.oHash.outputLen);return this.digestInto($),$}_cloneInto($){$||($=Object.create(Object.getPrototypeOf(this),{}));const{oHash:q,iHash:J,finished:G,destroyed:Q,blockLen:M,outputLen:Y}=this;return $=$,$.finished=G,$.destroyed=Q,$.blockLen=M,$.outputLen=Y,$.oHash=q._cloneInto($.oHash),$.iHash=J._cloneInto($.iHash),$}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}var D8=($,q,J)=>new U8($,q).update(J).digest();D8.create=($,q)=>new U8($,q);var KJ=function($,q,J,G){if(typeof $.setBigUint64==="function")return $.setBigUint64(q,J,G);const Q=BigInt(32),M=BigInt(4294967295),Y=Number(J>>Q&M),I=Number(J&M),X=G?4:0,W=G?0:4;$.setUint32(q+X,Y,G),$.setUint32(q+W,I,G)};class T8 extends N0{constructor($,q,J,G){super();this.blockLen=$,this.outputLen=q,this.padOffset=J,this.isLE=G,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array($),this.view=$8(this.buffer)}update($){Y0(this);const{view:q,buffer:J,blockLen:G}=this;$=L0($);const Q=$.length;for(let M=0;M<Q;){const Y=Math.min(G-this.pos,Q-M);if(Y===G){const I=$8($);for(;G<=Q-M;M+=G)this.process(I,M);continue}if(J.set($.subarray(M,M+Y),this.pos),this.pos+=Y,M+=Y,this.pos===G)this.process(q,0),this.pos=0}return this.length+=$.length,this.roundClean(),this}digestInto($){Y0(this),s0($,this),this.finished=!0;const{buffer:q,view:J,blockLen:G,isLE:Q}=this;let{pos:M}=this;if(q[M++]=128,this.buffer.subarray(M).fill(0),this.padOffset>G-M)this.process(J,0),M=0;for(let z=M;z<G;z++)q[z]=0;KJ(J,G-8,BigInt(this.length*8),Q),this.process(J,0);const Y=$8($),I=this.outputLen;if(I%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const X=I/4,W=this.get();if(X>W.length)throw new Error("_sha2: outputLen bigger than state");for(let z=0;z<X;z++)Y.setUint32(4*z,W[z],Q)}digest(){const{buffer:$,outputLen:q}=this;this.digestInto($);const J=$.slice(0,q);return this.destroy(),J}_cloneInto($){$||($=new this.constructor),$.set(...this.get());const{blockLen:q,buffer:J,length:G,finished:Q,destroyed:M,pos:Y}=this;if($.length=G,$.pos=Y,$.finished=Q,$.destroyed=M,G%q)$.buffer.set(J);return $}}var VJ=($,q,J)=>$&q^~$&J,UJ=($,q,J)=>$&q^$&J^q&J,DJ=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),D0=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),T0=new Uint32Array(64);class s8 extends T8{constructor(){super(64,32,8,!1);this.A=D0[0]|0,this.B=D0[1]|0,this.C=D0[2]|0,this.D=D0[3]|0,this.E=D0[4]|0,this.F=D0[5]|0,this.G=D0[6]|0,this.H=D0[7]|0}get(){const{A:$,B:q,C:J,D:G,E:Q,F:M,G:Y,H:I}=this;return[$,q,J,G,Q,M,Y,I]}set($,q,J,G,Q,M,Y,I){this.A=$|0,this.B=q|0,this.C=J|0,this.D=G|0,this.E=Q|0,this.F=M|0,this.G=Y|0,this.H=I|0}process($,q){for(let z=0;z<16;z++,q+=4)T0[z]=$.getUint32(q,!1);for(let z=16;z<64;z++){const V=T0[z-15],H=T0[z-2],P=t(V,7)^t(V,18)^V>>>3,Z=t(H,17)^t(H,19)^H>>>10;T0[z]=Z+T0[z-7]+P+T0[z-16]|0}let{A:J,B:G,C:Q,D:M,E:Y,F:I,G:X,H:W}=this;for(let z=0;z<64;z++){const V=t(Y,6)^t(Y,11)^t(Y,25),H=W+V+VJ(Y,I,X)+DJ[z]+T0[z]|0,Z=(t(J,2)^t(J,13)^t(J,22))+UJ(J,G,Q)|0;W=X,X=I,I=Y,Y=M+H|0,M=Q,Q=G,G=J,J=H+Z|0}J=J+this.A|0,G=G+this.B|0,Q=Q+this.C|0,M=M+this.D|0,Y=Y+this.E|0,I=I+this.F|0,X=X+this.G|0,W=W+this.H|0,this.set(J,G,Q,M,Y,I,X,W)}roundClean(){T0.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}}var e8=J8(()=>new s8);var TJ=function($,q=!1){if(q)return{h:Number($&q8),l:Number($>>$$&q8)};return{h:Number($>>$$&q8)|0,l:Number($&q8)|0}},J$=function($,q=!1){let J=new Uint32Array($.length),G=new Uint32Array($.length);for(let Q=0;Q<$.length;Q++){const{h:M,l:Y}=TJ($[Q],q);[J[Q],G[Q]]=[M,Y]}return[J,G]};var q8=BigInt(4294967295),$$=BigInt(32);var q$=($,q,J)=>$<<J|q>>>32-J,G$=($,q,J)=>q<<J|$>>>32-J,Q$=($,q,J)=>q<<J-32|$>>>64-J,M$=($,q,J)=>$<<J-32|q>>>64-J;function CJ($,q=24){const J=new Uint32Array(10);for(let G=24-q;G<24;G++){for(let Y=0;Y<10;Y++)J[Y]=$[Y]^$[Y+10]^$[Y+20]^$[Y+30]^$[Y+40];for(let Y=0;Y<10;Y+=2){const I=(Y+8)%10,X=(Y+2)%10,W=J[X],z=J[X+1],V=Y$(W,z,1)^J[I],H=X$(W,z,1)^J[I+1];for(let P=0;P<50;P+=10)$[Y+P]^=V,$[Y+P+1]^=H}let Q=$[2],M=$[3];for(let Y=0;Y<24;Y++){const I=W$[Y],X=Y$(Q,M,I),W=X$(Q,M,I),z=I$[Y];Q=$[z],M=$[z+1],$[z]=X,$[z+1]=W}for(let Y=0;Y<50;Y+=10){for(let I=0;I<10;I++)J[I]=$[Y+I];for(let I=0;I<10;I++)$[Y+I]^=~J[(I+2)%10]&J[(I+4)%10]}$[0]^=LJ[G],$[1]^=NJ[G]}J.fill(0)}var[I$,W$,Z$]=[[],[],[]],jJ=BigInt(0),h0=BigInt(1),OJ=BigInt(2),HJ=BigInt(7),RJ=BigInt(256),wJ=BigInt(113);for(let $=0,q=h0,J=1,G=0;$<24;$++){[J,G]=[G,(2*J+3*G)%5],I$.push(2*(5*G+J)),W$.push(($+1)*($+2)/2%64);let Q=jJ;for(let M=0;M<7;M++)if(q=(q<<h0^(q>>HJ)*wJ)%RJ,q&OJ)Q^=h0<<(h0<<BigInt(M))-h0;Z$.push(Q)}var[LJ,NJ]=J$(Z$,!0),Y$=($,q,J)=>J>32?Q$($,q,J):q$($,q,J),X$=($,q,J)=>J>32?M$($,q,J):G$($,q,J);class j8 extends N0{constructor($,q,J,G=!1,Q=24){super();if(this.blockLen=$,this.suffix=q,this.outputLen=J,this.enableXOF=G,this.rounds=Q,this.pos=0,this.posOut=0,this.finished=!1,this.destroyed=!1,m0(J),0>=this.blockLen||this.blockLen>=200)throw new Error("Sha3 supports only keccak-f1600 function");this.state=new Uint8Array(200),this.state32=a8(this.state)}keccak(){CJ(this.state32,this.rounds),this.posOut=0,this.pos=0}update($){Y0(this);const{blockLen:q,state:J}=this;$=L0($);const G=$.length;for(let Q=0;Q<G;){const M=Math.min(q-this.pos,G-Q);for(let Y=0;Y<M;Y++)J[this.pos++]^=$[Q++];if(this.pos===q)this.keccak()}return this}finish(){if(this.finished)return;this.finished=!0;const{state:$,suffix:q,pos:J,blockLen:G}=this;if($[J]^=q,(q&128)!==0&&J===G-1)this.keccak();$[G-1]^=128,this.keccak()}writeInto($){Y0(this,!1),c0($),this.finish();const q=this.state,{blockLen:J}=this;for(let G=0,Q=$.length;G<Q;){if(this.posOut>=J)this.keccak();const M=Math.min(J-this.posOut,Q-G);$.set(q.subarray(this.posOut,this.posOut+M),G),this.posOut+=M,G+=M}return $}xofInto($){if(!this.enableXOF)throw new Error("XOF is not possible for this instance");return this.writeInto($)}xof($){return m0($),this.xofInto(new Uint8Array($))}digestInto($){if(s0($,this),this.finished)throw new Error("digest() was already called");return this.writeInto($),this.destroy(),$}digest(){return this.digestInto(new Uint8Array(this.outputLen))}destroy(){this.destroyed=!0,this.state.fill(0)}_cloneInto($){const{blockLen:q,suffix:J,outputLen:G,rounds:Q,enableXOF:M}=this;return $||($=new j8(q,J,G,M,Q)),$.state32.set(this.state32),$.pos=this.pos,$.posOut=this.posOut,$.finished=this.finished,$.rounds=Q,$.suffix=J,$.outputLen=G,$.enableXOF=M,$.destroyed=this.destroyed,$}}var SJ=($,q,J)=>J8(()=>new j8(q,$,J));var z$=SJ(1,136,32);function s($){const q=v($,"data");return _(U$(q))}var K$=!1,V$=function($){return z$($)},U$=V$;s._=V$;s.lock=function(){K$=!0};s.register=function($){if(K$)throw new TypeError("keccak256 is locked");U$=$};Object.freeze(s);var w8={};p$(w8,{validateObject:()=>{{return O0}},utf8ToBytes:()=>{{return EJ}},numberToVarBytesBE:()=>{{return fJ}},numberToHexUnpadded:()=>{{return j$}},numberToBytesLE:()=>{{return Y8}},numberToBytesBE:()=>{{return j0}},hexToNumber:()=>{{return H8}},hexToBytes:()=>{{return S0}},equalBytes:()=>{{return xJ}},ensureBytes:()=>{{return d}},createHmacDrbg:()=>{{return R8}},concatBytes:()=>{{return b0}},bytesToNumberLE:()=>{{return M8}},bytesToNumberBE:()=>{{return X0}},bytesToHex:()=>{{return C0}},bitSet:()=>{{return _J}},bitMask:()=>{{return l0}},bitLen:()=>{{return AJ}},bitGet:()=>{{return kJ}}});function C0($){if(!Q8($))throw new Error("Uint8Array expected");let q="";for(let J=0;J<$.length;J++)q+=BJ[$[J]];return q}function j$($){const q=$.toString(16);return q.length&1?`0${q}`:q}function H8($){if(typeof $!=="string")throw new Error("hex string expected, got "+typeof $);return BigInt($===""?"0":`0x${$}`)}function S0($){if(typeof $!=="string")throw new Error("hex string expected, got "+typeof $);const q=$.length;if(q%2)throw new Error("padded hex string expected, got unpadded hex of length "+q);const J=new Uint8Array(q/2);for(let G=0;G<J.length;G++){const Q=G*2,M=$.slice(Q,Q+2),Y=Number.parseInt(M,16);if(Number.isNaN(Y)||Y<0)throw new Error("Invalid byte sequence");J[G]=Y}return J}function X0($){return H8(C0($))}function M8($){if(!Q8($))throw new Error("Uint8Array expected");return H8(C0(Uint8Array.from($).reverse()))}function j0($,q){return S0($.toString(16).padStart(q*2,"0"))}function Y8($,q){return j0($,q).reverse()}function fJ($){return S0(j$($))}function d($,q,J){let G;if(typeof q==="string")try{G=S0(q)}catch(M){throw new Error(`${$} must be valid hex string, got "${q}". Cause: ${M}`)}else if(Q8(q))G=Uint8Array.from(q);else throw new Error(`${$} must be hex string or Uint8Array`);const Q=G.length;if(typeof J==="number"&&Q!==J)throw new Error(`${$} expected ${J} bytes, got ${Q}`);return G}function b0(...$){const q=new Uint8Array($.reduce((G,Q)=>G+Q.length,0));let J=0;return $.forEach((G)=>{if(!Q8(G))throw new Error("Uint8Array expected");q.set(G,J),J+=G.length}),q}function xJ($,q){if($.length!==q.length)return!1;for(let J=0;J<$.length;J++)if($[J]!==q[J])return!1;return!0}function EJ($){if(typeof $!=="string")throw new Error(`utf8ToBytes expected string, got ${typeof $}`);return new Uint8Array((new TextEncoder()).encode($))}function AJ($){let q;for(q=0;$>T$;$>>=G8,q+=1);return q}function kJ($,q){return $>>BigInt(q)&G8}function R8($,q,J){if(typeof $!=="number"||$<2)throw new Error("hashLen must be a number");if(typeof q!=="number"||q<2)throw new Error("qByteLen must be a number");if(typeof J!=="function")throw new Error("hmacFn must be a function");let G=O8($),Q=O8($),M=0;const Y=()=>{G.fill(1),Q.fill(0),M=0},I=(...V)=>J(Q,G,...V),X=(V=O8())=>{if(Q=I(D$([0]),V),G=I(),V.length===0)return;Q=I(D$([1]),V),G=I()},W=()=>{if(M++>=1000)throw new Error("drbg: tried 1000 values");let V=0;const H=[];while(V<q){G=I();const P=G.slice();H.push(P),V+=G.length}return b0(...H)};return(V,H)=>{Y(),X(V);let P=void 0;while(!(P=H(W())))X();return Y(),P}}function O0($,q,J={}){const G=(Q,M,Y)=>{const I=bJ[M];if(typeof I!=="function")throw new Error(`Invalid validator "${M}", expected function`);const X=$[Q];if(Y&&X===void 0)return;if(!I(X,$))throw new Error(`Invalid param ${String(Q)}=${X} (${typeof X}), expected ${M}`)};for(let[Q,M]of Object.entries(q))G(Q,M,!1);for(let[Q,M]of Object.entries(J))G(Q,M,!0);return $}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */var T$=BigInt(0),G8=BigInt(1),PJ=BigInt(2),Q8=($)=>$ instanceof Uint8Array,BJ=Array.from({length:256},($,q)=>q.toString(16).padStart(2,"0")),_J=($,q,J)=>{return $|(J?G8:T$)<<BigInt(q)},l0=($)=>(PJ<<BigInt($-1))-G8,O8=($)=>new Uint8Array($),D$=($)=>Uint8Array.from($),bJ={bigint:($)=>typeof $==="bigint",function:($)=>typeof $==="function",boolean:($)=>typeof $==="boolean",string:($)=>typeof $==="string",stringOrUint8Array:($)=>typeof $==="string"||$ instanceof Uint8Array,isSafeInteger:($)=>Number.isSafeInteger($),array:($)=>Array.isArray($),field:($,q)=>q.Fp.isValid($),hash:($)=>typeof $==="function"&&Number.isSafeInteger($.outputLen)};function h($,q){const J=$%q;return J>=y?J:q+J}function vJ($,q,J){if(J<=y||q<y)throw new Error("Expected power/modulo > 0");if(J===b)return y;let G=b;while(q>y){if(q&b)G=G*$%J;$=$*$%J,q>>=b}return G}function i($,q,J){let G=$;while(q-- >y)G*=G,G%=J;return G}function X8($,q){if($===y||q<=y)throw new Error(`invert: expected positive integers, got n=${$} mod=${q}`);let J=h($,q),G=q,Q=y,M=b,Y=b,I=y;while(J!==y){const W=G/J,z=G%J,V=Q-Y*W,H=M-I*W;G=J,J=z,Q=Y,M=I,Y=V,I=H}if(G!==b)throw new Error("invert: does not exist");return h(Q,q)}function mJ($){const q=($-b)/P0;let J,G,Q;for(J=$-b,G=0;J%P0===y;J/=P0,G++);for(Q=P0;Q<$&&vJ(Q,q,$)!==$-b;Q++);if(G===1){const Y=($+b)/L8;return function I(X,W){const z=X.pow(W,Y);if(!X.eql(X.sqr(z),W))throw new Error("Cannot find square root");return z}}const M=(J+b)/P0;return function Y(I,X){if(I.pow(X,q)===I.neg(I.ONE))throw new Error("Cannot find square root");let W=G,z=I.pow(I.mul(I.ONE,Q),J),V=I.pow(X,M),H=I.pow(X,J);while(!I.eql(H,I.ONE)){if(I.eql(H,I.ZERO))return I.ZERO;let P=1;for(let U=I.sqr(H);P<W;P++){if(I.eql(U,I.ONE))break;U=I.sqr(U)}const Z=I.pow(z,b<<BigInt(W-P-1));z=I.sqr(Z),V=I.mul(V,Z),H=I.mul(H,z),W=P}return V}}function cJ($){if($%L8===FJ){const q=($+b)/L8;return function J(G,Q){const M=G.pow(Q,q);if(!G.eql(G.sqr(M),Q))throw new Error("Cannot find square root");return M}}if($%H$===O$){const q=($-O$)/H$;return function J(G,Q){const M=G.mul(Q,P0),Y=G.pow(M,q),I=G.mul(Q,Y),X=G.mul(G.mul(I,P0),Y),W=G.mul(I,G.sub(X,G.ONE));if(!G.eql(G.sqr(W),Q))throw new Error("Cannot find square root");return W}}if($%yJ===gJ);return mJ($)}function N8($){const q={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},J=hJ.reduce((G,Q)=>{return G[Q]="function",G},q);return O0($,J)}function lJ($,q,J){if(J<y)throw new Error("Expected power > 0");if(J===y)return $.ONE;if(J===b)return q;let G=$.ONE,Q=q;while(J>y){if(J&b)G=$.mul(G,Q);Q=$.sqr(Q),J>>=b}return G}function pJ($,q){const J=new Array(q.length),G=q.reduce((M,Y,I)=>{if($.is0(Y))return M;return J[I]=M,$.mul(M,Y)},$.ONE),Q=$.inv(G);return q.reduceRight((M,Y,I)=>{if($.is0(Y))return M;return J[I]=$.mul(M,J[I]),$.mul(M,Y)},Q),J}function C8($,q){const J=q!==void 0?q:$.toString(2).length,G=Math.ceil(J/8);return{nBitLength:J,nByteLength:G}}function R$($,q,J=!1,G={}){if($<=y)throw new Error(`Expected Field ORDER > 0, got ${$}`);const{nBitLength:Q,nByteLength:M}=C8($,q);if(M>2048)throw new Error("Field lengths over 2048 bytes are not supported");const Y=cJ($),I=Object.freeze({ORDER:$,BITS:Q,BYTES:M,MASK:l0(Q),ZERO:y,ONE:b,create:(X)=>h(X,$),isValid:(X)=>{if(typeof X!=="bigint")throw new Error(`Invalid field element: expected bigint, got ${typeof X}`);return y<=X&&X<$},is0:(X)=>X===y,isOdd:(X)=>(X&b)===b,neg:(X)=>h(-X,$),eql:(X,W)=>X===W,sqr:(X)=>h(X*X,$),add:(X,W)=>h(X+W,$),sub:(X,W)=>h(X-W,$),mul:(X,W)=>h(X*W,$),pow:(X,W)=>lJ(I,X,W),div:(X,W)=>h(X*X8(W,$),$),sqrN:(X)=>X*X,addN:(X,W)=>X+W,subN:(X,W)=>X-W,mulN:(X,W)=>X*W,inv:(X)=>X8(X,$),sqrt:G.sqrt||((X)=>Y(I,X)),invertBatch:(X)=>pJ(I,X),cmov:(X,W,z)=>z?W:X,toBytes:(X)=>J?Y8(X,M):j0(X,M),fromBytes:(X)=>{if(X.length!==M)throw new Error(`Fp.fromBytes: expected ${M}, got ${X.length}`);return J?M8(X):X0(X)}});return Object.freeze(I)}function w$($){if(typeof $!=="bigint")throw new Error("field order must be bigint");const q=$.toString(2).length;return Math.ceil(q/8)}function S8($){const q=w$($);return q+Math.ceil(q/2)}function L$($,q,J=!1){const G=$.length,Q=w$(q),M=S8(q);if(G<16||G<M||G>1024)throw new Error(`expected ${M}-1024 bytes of input, got ${G}`);const Y=J?X0($):M8($),I=h(Y,q-b)+b;return J?Y8(I,Q):j0(I,Q)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */var y=BigInt(0),b=BigInt(1),P0=BigInt(2),FJ=BigInt(3),L8=BigInt(4),O$=BigInt(5),H$=BigInt(8),gJ=BigInt(9),yJ=BigInt(16);var hJ=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function N$($,q){const J=(Q,M)=>{const Y=M.negate();return Q?Y:M},G=(Q)=>{const M=Math.ceil(q/Q)+1,Y=2**(Q-1);return{windows:M,windowSize:Y}};return{constTimeNegate:J,unsafeLadder(Q,M){let Y=$.ZERO,I=Q;while(M>dJ){if(M&P8)Y=Y.add(I);I=I.double(),M>>=P8}return Y},precomputeWindow(Q,M){const{windows:Y,windowSize:I}=G(M),X=[];let W=Q,z=W;for(let V=0;V<Y;V++){z=W,X.push(z);for(let H=1;H<I;H++)z=z.add(W),X.push(z);W=z.double()}return X},wNAF(Q,M,Y){const{windows:I,windowSize:X}=G(Q);let{ZERO:W,BASE:z}=$;const V=BigInt(2**Q-1),H=2**Q,P=BigInt(Q);for(let Z=0;Z<I;Z++){const U=Z*X;let T=Number(Y&V);if(Y>>=P,T>X)T-=H,Y+=P8;const D=U,w=U+Math.abs(T)-1,S=Z%2!==0,L=T<0;if(T===0)z=z.add(J(S,M[D]));else W=W.add(J(L,M[w]))}return{p:W,f:z}},wNAFCached(Q,M,Y,I){const X=Q._WINDOW_SIZE||1;let W=M.get(Q);if(!W){if(W=this.precomputeWindow(Q,X),X!==1)M.set(Q,I(W))}return this.wNAF(X,W,Y)}}}function B8($){return N8($.Fp),O0($,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...C8($.n,$.nBitLength),...$,...{p:$.Fp.ORDER}})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */var dJ=BigInt(0),P8=BigInt(1);var iJ=function($){const q=B8($);O0(q,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});const{endo:J,Fp:G,a:Q}=q;if(J){if(!G.eql(Q,G.ZERO))throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");if(typeof J!=="object"||typeof J.beta!=="bigint"||typeof J.splitScalar!=="function")throw new Error("Expected endomorphism with beta: bigint and splitScalar: function")}return Object.freeze({...q})};function aJ($){const q=iJ($),{Fp:J}=q,G=q.toBytes||((Z,U,T)=>{const D=U.toAffine();return b0(Uint8Array.from([4]),J.toBytes(D.x),J.toBytes(D.y))}),Q=q.fromBytes||((Z)=>{const U=Z.subarray(1),T=J.fromBytes(U.subarray(0,J.BYTES)),D=J.fromBytes(U.subarray(J.BYTES,2*J.BYTES));return{x:T,y:D}});function M(Z){const{a:U,b:T}=q,D=J.sqr(Z),w=J.mul(D,Z);return J.add(J.add(w,J.mul(Z,U)),T)}if(!J.eql(J.sqr(q.Gy),M(q.Gx)))throw new Error("bad generator point: equation left != right");function Y(Z){return typeof Z==="bigint"&&I0<Z&&Z<q.n}function I(Z){if(!Y(Z))throw new Error("Expected valid bigint: 0 < bigint < curve.n")}function X(Z){const{allowedPrivateKeyLengths:U,nByteLength:T,wrapPrivateKey:D,n:w}=q;if(U&&typeof Z!=="bigint"){if(Z instanceof Uint8Array)Z=C0(Z);if(typeof Z!=="string"||!U.includes(Z.length))throw new Error("Invalid key");Z=Z.padStart(T*2,"0")}let S;try{S=typeof Z==="bigint"?Z:X0(d("private key",Z,T))}catch(L){throw new Error(`private key must be ${T} bytes, hex or bigint, not ${typeof Z}`)}if(D)S=h(S,w);return I(S),S}const W=new Map;function z(Z){if(!(Z instanceof V))throw new Error("ProjectivePoint expected")}class V{constructor(Z,U,T){if(this.px=Z,this.py=U,this.pz=T,Z==null||!J.isValid(Z))throw new Error("x required");if(U==null||!J.isValid(U))throw new Error("y required");if(T==null||!J.isValid(T))throw new Error("z required")}static fromAffine(Z){const{x:U,y:T}=Z||{};if(!Z||!J.isValid(U)||!J.isValid(T))throw new Error("invalid affine point");if(Z instanceof V)throw new Error("projective point not allowed");const D=(w)=>J.eql(w,J.ZERO);if(D(U)&&D(T))return V.ZERO;return new V(U,T,J.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(Z){const U=J.invertBatch(Z.map((T)=>T.pz));return Z.map((T,D)=>T.toAffine(U[D])).map(V.fromAffine)}static fromHex(Z){const U=V.fromAffine(Q(d("pointHex",Z)));return U.assertValidity(),U}static fromPrivateKey(Z){return V.BASE.multiply(X(Z))}_setWindowSize(Z){this._WINDOW_SIZE=Z,W.delete(this)}assertValidity(){if(this.is0()){if(q.allowInfinityPoint&&!J.is0(this.py))return;throw new Error("bad point: ZERO")}const{x:Z,y:U}=this.toAffine();if(!J.isValid(Z)||!J.isValid(U))throw new Error("bad point: x or y not FE");const T=J.sqr(U),D=M(Z);if(!J.eql(T,D))throw new Error("bad point: equation left != right");if(!this.isTorsionFree())throw new Error("bad point: not in prime-order subgroup")}hasEvenY(){const{y:Z}=this.toAffine();if(J.isOdd)return!J.isOdd(Z);throw new Error("Field doesn't support isOdd")}equals(Z){z(Z);const{px:U,py:T,pz:D}=this,{px:w,py:S,pz:L}=Z,O=J.eql(J.mul(U,L),J.mul(w,D)),R=J.eql(J.mul(T,L),J.mul(S,D));return O&&R}negate(){return new V(this.px,J.neg(this.py),this.pz)}double(){const{a:Z,b:U}=q,T=J.mul(U,C$),{px:D,py:w,pz:S}=this;let{ZERO:L,ZERO:O,ZERO:R}=J,N=J.mul(D,D),a=J.mul(w,w),E=J.mul(S,S),f=J.mul(D,w);return f=J.add(f,f),R=J.mul(D,S),R=J.add(R,R),L=J.mul(Z,R),O=J.mul(T,E),O=J.add(L,O),L=J.sub(a,O),O=J.add(a,O),O=J.mul(L,O),L=J.mul(f,L),R=J.mul(T,R),E=J.mul(Z,E),f=J.sub(N,E),f=J.mul(Z,f),f=J.add(f,R),R=J.add(N,N),N=J.add(R,N),N=J.add(N,E),N=J.mul(N,f),O=J.add(O,N),E=J.mul(w,S),E=J.add(E,E),N=J.mul(E,f),L=J.sub(L,N),R=J.mul(E,a),R=J.add(R,R),R=J.add(R,R),new V(L,O,R)}add(Z){z(Z);const{px:U,py:T,pz:D}=this,{px:w,py:S,pz:L}=Z;let{ZERO:O,ZERO:R,ZERO:N}=J;const a=q.a,E=J.mul(q.b,C$);let f=J.mul(U,w),l=J.mul(T,S),p=J.mul(D,L),Z0=J.add(U,T),m=J.add(w,S);Z0=J.mul(Z0,m),m=J.add(f,l),Z0=J.sub(Z0,m),m=J.add(U,D);let K=J.add(w,L);return m=J.mul(m,K),K=J.add(f,p),m=J.sub(m,K),K=J.add(T,D),O=J.add(S,L),K=J.mul(K,O),O=J.add(l,p),K=J.sub(K,O),N=J.mul(a,m),O=J.mul(E,p),N=J.add(O,N),O=J.sub(l,N),N=J.add(l,N),R=J.mul(O,N),l=J.add(f,f),l=J.add(l,f),p=J.mul(a,p),m=J.mul(E,m),l=J.add(l,p),p=J.sub(f,p),p=J.mul(a,p),m=J.add(m,p),f=J.mul(l,m),R=J.add(R,f),f=J.mul(K,m),O=J.mul(Z0,O),O=J.sub(O,f),f=J.mul(Z0,l),N=J.mul(K,N),N=J.add(N,f),new V(O,R,N)}subtract(Z){return this.add(Z.negate())}is0(){return this.equals(V.ZERO)}wNAF(Z){return P.wNAFCached(this,W,Z,(U)=>{const T=J.invertBatch(U.map((D)=>D.pz));return U.map((D,w)=>D.toAffine(T[w])).map(V.fromAffine)})}multiplyUnsafe(Z){const U=V.ZERO;if(Z===I0)return U;if(I(Z),Z===n)return this;const{endo:T}=q;if(!T)return P.unsafeLadder(this,Z);let{k1neg:D,k1:w,k2neg:S,k2:L}=T.splitScalar(Z),O=U,R=U,N=this;while(w>I0||L>I0){if(w&n)O=O.add(N);if(L&n)R=R.add(N);N=N.double(),w>>=n,L>>=n}if(D)O=O.negate();if(S)R=R.negate();return R=new V(J.mul(R.px,T.beta),R.py,R.pz),O.add(R)}multiply(Z){I(Z);let U=Z,T,D;const{endo:w}=q;if(w){const{k1neg:S,k1:L,k2neg:O,k2:R}=w.splitScalar(U);let{p:N,f:a}=this.wNAF(L),{p:E,f}=this.wNAF(R);N=P.constTimeNegate(S,N),E=P.constTimeNegate(O,E),E=new V(J.mul(E.px,w.beta),E.py,E.pz),T=N.add(E),D=a.add(f)}else{const{p:S,f:L}=this.wNAF(U);T=S,D=L}return V.normalizeZ([T,D])[0]}multiplyAndAddUnsafe(Z,U,T){const D=V.BASE,w=(L,O)=>O===I0||O===n||!L.equals(D)?L.multiplyUnsafe(O):L.multiply(O),S=w(this,U).add(w(Z,T));return S.is0()?void 0:S}toAffine(Z){const{px:U,py:T,pz:D}=this,w=this.is0();if(Z==null)Z=w?J.ONE:J.inv(D);const S=J.mul(U,Z),L=J.mul(T,Z),O=J.mul(D,Z);if(w)return{x:J.ZERO,y:J.ZERO};if(!J.eql(O,J.ONE))throw new Error("invZ was invalid");return{x:S,y:L}}isTorsionFree(){const{h:Z,isTorsionFree:U}=q;if(Z===n)return!0;if(U)return U(V,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:Z,clearCofactor:U}=q;if(Z===n)return this;if(U)return U(V,this);return this.multiplyUnsafe(q.h)}toRawBytes(Z=!0){return this.assertValidity(),G(V,this,Z)}toHex(Z=!0){return C0(this.toRawBytes(Z))}}V.BASE=new V(q.Gx,q.Gy,J.ONE),V.ZERO=new V(J.ZERO,J.ONE,J.ZERO);const H=q.nBitLength,P=N$(V,q.endo?Math.ceil(H/2):H);return{CURVE:q,ProjectivePoint:V,normPrivateKeyToScalar:X,weierstrassEquation:M,isWithinCurveOrder:Y}}var rJ=function($){const q=B8($);return O0(q,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...q})};function S$($){const q=rJ($),{Fp:J,n:G}=q,Q=J.BYTES+1,M=2*J.BYTES+1;function Y(K){return I0<K&&K<J.ORDER}function I(K){return h(K,G)}function X(K){return X8(K,G)}const{ProjectivePoint:W,normPrivateKeyToScalar:z,weierstrassEquation:V,isWithinCurveOrder:H}=aJ({...q,toBytes(K,j,B){const A=j.toAffine(),k=J.toBytes(A.x),g=b0;if(B)return g(Uint8Array.from([j.hasEvenY()?2:3]),k);else return g(Uint8Array.from([4]),k,J.toBytes(A.y))},fromBytes(K){const j=K.length,B=K[0],A=K.subarray(1);if(j===Q&&(B===2||B===3)){const k=X0(A);if(!Y(k))throw new Error("Point is not on curve");const g=V(k);let r=J.sqrt(g);const u=(r&n)===n;if((B&1)===1!==u)r=J.neg(r);return{x:k,y:r}}else if(j===M&&B===4){const k=J.fromBytes(A.subarray(0,J.BYTES)),g=J.fromBytes(A.subarray(J.BYTES,2*J.BYTES));return{x:k,y:g}}else throw new Error(`Point of length ${j} was invalid. Expected ${Q} compressed bytes or ${M} uncompressed bytes`)}}),P=(K)=>C0(j0(K,q.nByteLength));function Z(K){const j=G>>n;return K>j}function U(K){return Z(K)?I(-K):K}const T=(K,j,B)=>X0(K.slice(j,B));class D{constructor(K,j,B){this.r=K,this.s=j,this.recovery=B,this.assertValidity()}static fromCompact(K){const j=q.nByteLength;return K=d("compactSignature",K,j*2),new D(T(K,0,j),T(K,j,2*j))}static fromDER(K){const{r:j,s:B}=B0.toSig(d("DER",K));return new D(j,B)}assertValidity(){if(!H(this.r))throw new Error("r must be 0 < r < CURVE.n");if(!H(this.s))throw new Error("s must be 0 < s < CURVE.n")}addRecoveryBit(K){return new D(this.r,this.s,K)}recoverPublicKey(K){const{r:j,s:B,recovery:A}=this,k=N(d("msgHash",K));if(A==null||![0,1,2,3].includes(A))throw new Error("recovery id invalid");const g=A===2||A===3?j+q.n:j;if(g>=J.ORDER)throw new Error("recovery id 2 or 3 invalid");const r=(A&1)===0?"02":"03",u=W.fromHex(r+P(g)),G0=X(g),H0=I(-k*G0),f0=I(B*G0),R0=W.BASE.multiplyAndAddUnsafe(u,H0,f0);if(!R0)throw new Error("point at infinify");return R0.assertValidity(),R0}hasHighS(){return Z(this.s)}normalizeS(){return this.hasHighS()?new D(this.r,I(-this.s),this.recovery):this}toDERRawBytes(){return S0(this.toDERHex())}toDERHex(){return B0.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return S0(this.toCompactHex())}toCompactHex(){return P(this.r)+P(this.s)}}const w={isValidPrivateKey(K){try{return z(K),!0}catch(j){return!1}},normPrivateKeyToScalar:z,randomPrivateKey:()=>{const K=S8(q.n);return L$(q.randomBytes(K),q.n)},precompute(K=8,j=W.BASE){return j._setWindowSize(K),j.multiply(BigInt(3)),j}};function S(K,j=!0){return W.fromPrivateKey(K).toRawBytes(j)}function L(K){const j=K instanceof Uint8Array,B=typeof K==="string",A=(j||B)&&K.length;if(j)return A===Q||A===M;if(B)return A===2*Q||A===2*M;if(K instanceof W)return!0;return!1}function O(K,j,B=!0){if(L(K))throw new Error("first arg must be private key");if(!L(j))throw new Error("second arg must be public key");return W.fromHex(j).multiply(z(K)).toRawBytes(B)}const R=q.bits2int||function(K){const j=X0(K),B=K.length*8-q.nBitLength;return B>0?j>>BigInt(B):j},N=q.bits2int_modN||function(K){return I(R(K))},a=l0(q.nBitLength);function E(K){if(typeof K!=="bigint")throw new Error("bigint expected");if(!(I0<=K&&K<a))throw new Error(`bigint expected < 2^${q.nBitLength}`);return j0(K,q.nByteLength)}function f(K,j,B=l){if(["recovered","canonical"].some((w0)=>(w0 in B)))throw new Error("sign() legacy options not supported");const{hash:A,randomBytes:k}=q;let{lowS:g,prehash:r,extraEntropy:u}=B;if(g==null)g=!0;if(K=d("msgHash",K),r)K=d("prehashed msgHash",A(K));const G0=N(K),H0=z(j),f0=[E(H0),E(G0)];if(u!=null){const w0=u===!0?k(J.BYTES):u;f0.push(d("extraEntropy",w0))}const R0=b0(...f0),u0=G0;function K8(w0){const x0=R(w0);if(!H(x0))return;const v8=X(x0),e=W.BASE.multiply(x0).toAffine(),E0=I(e.x);if(E0===I0)return;const d0=I(v8*I(u0+E0*H0));if(d0===I0)return;let m8=(e.x===E0?0:2)|Number(e.y&n),c8=d0;if(g&&Z(d0))c8=U(d0),m8^=1;return new D(E0,c8,m8)}return{seed:R0,k2sig:K8}}const l={lowS:q.lowS,prehash:!1},p={lowS:q.lowS,prehash:!1};function Z0(K,j,B=l){const{seed:A,k2sig:k}=f(K,j,B),g=q;return R8(g.hash.outputLen,g.nByteLength,g.hmac)(A,k)}W.BASE._setWindowSize(8);function m(K,j,B,A=p){const k=K;if(j=d("msgHash",j),B=d("publicKey",B),("strict"in A))throw new Error("options.strict was renamed to lowS");const{lowS:g,prehash:r}=A;let u=void 0,G0;try{if(typeof k==="string"||k instanceof Uint8Array)try{u=D.fromDER(k)}catch(e){if(!(e instanceof B0.Err))throw e;u=D.fromCompact(k)}else if(typeof k==="object"&&typeof k.r==="bigint"&&typeof k.s==="bigint"){const{r:e,s:E0}=k;u=new D(e,E0)}else throw new Error("PARSE");G0=W.fromHex(B)}catch(e){if(e.message==="PARSE")throw new Error("signature must be Signature instance, Uint8Array or hex string");return!1}if(g&&u.hasHighS())return!1;if(r)j=q.hash(j);const{r:H0,s:f0}=u,R0=N(j),u0=X(f0),K8=I(R0*u0),w0=I(H0*u0),x0=W.BASE.multiplyAndAddUnsafe(G0,K8,w0)?.toAffine();if(!x0)return!1;return I(x0.x)===H0}return{CURVE:q,getPublicKey:S,getSharedSecret:O,sign:Z0,verify:m,ProjectivePoint:W,Signature:D,utils:w}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */var{bytesToNumberBE:oJ,hexToBytes:nJ}=w8,B0={Err:class $ extends Error{constructor(q=""){super(q)}},_parseInt($){const{Err:q}=B0;if($.length<2||$[0]!==2)throw new q("Invalid signature integer tag");const J=$[1],G=$.subarray(2,J+2);if(!J||G.length!==J)throw new q("Invalid signature integer: wrong length");if(G[0]&128)throw new q("Invalid signature integer: negative");if(G[0]===0&&!(G[1]&128))throw new q("Invalid signature integer: unnecessary leading zero");return{d:oJ(G),l:$.subarray(J+2)}},toSig($){const{Err:q}=B0,J=typeof $==="string"?nJ($):$;if(!(J instanceof Uint8Array))throw new Error("ui8a expected");let G=J.length;if(G<2||J[0]!=48)throw new q("Invalid signature tag");if(J[1]!==G-2)throw new q("Invalid signature: incorrect length");const{d:Q,l:M}=B0._parseInt(J.subarray(2)),{d:Y,l:I}=B0._parseInt(M);if(I.length)throw new q("Invalid signature: left bytes after parsing");return{r:Q,s:Y}},hexFromSig($){const q=(W)=>Number.parseInt(W[0],16)&8?"00"+W:W,J=(W)=>{const z=W.toString(16);return z.length&1?`0${z}`:z},G=q(J($.s)),Q=q(J($.r)),M=G.length/2,Y=Q.length/2,I=J(M),X=J(Y);return`30${J(Y+M+4)}02${X}${Q}02${I}${G}`}},I0=BigInt(0),n=BigInt(1),YG=BigInt(2),C$=BigInt(3),XG=BigInt(4);function tJ($){return{hash:$,hmac:(q,...J)=>D8($,q,r8(...J)),randomBytes:t8}}function P$($,q){const J=(G)=>S$({...$,...tJ(G)});return Object.freeze({...J(q),create:J})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */var eJ=function($){const q=x$,J=BigInt(3),G=BigInt(6),Q=BigInt(11),M=BigInt(22),Y=BigInt(23),I=BigInt(44),X=BigInt(88),W=$*$*$%q,z=W*W*$%q,V=i(z,J,q)*z%q,H=i(V,J,q)*z%q,P=i(H,f8,q)*W%q,Z=i(P,Q,q)*P%q,U=i(Z,M,q)*Z%q,T=i(U,I,q)*U%q,D=i(T,X,q)*T%q,w=i(D,I,q)*U%q,S=i(w,J,q)*z%q,L=i(S,Y,q)*Z%q,O=i(L,G,q)*W%q,R=i(O,f8,q);if(!x8.eql(x8.sqr(R),$))throw new Error("Cannot find square root");return R};/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */var x$=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),B$=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),sJ=BigInt(1),f8=BigInt(2),f$=($,q)=>($+q/f8)/q,x8=R$(x$,void 0,void 0,{sqrt:eJ}),W0=P$({a:BigInt(0),b:BigInt(7),Fp:x8,n:B$,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:($)=>{const q=B$,J=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),G=-sJ*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),Q=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),M=J,Y=BigInt("0x100000000000000000000000000000000"),I=f$(M*$,q),X=f$(-G*$,q);let W=h($-I*J-X*Q,q),z=h(-I*G-X*M,q);const V=W>Y,H=z>Y;if(V)W=q-W;if(H)z=q-z;if(W>Y||z>Y)throw new Error("splitScalar: Endomorphism failed, k="+$);return{k1neg:V,k1:W,k2neg:H,k2:z}}}},e8),TG=BigInt(0);var jG=W0.ProjectivePoint;var I8="0x0000000000000000000000000000000000000000000000000000000000000000";var E8=`\x19Ethereum Signed Message:
`;var F$=function($){return a0(t0($),32)},E$=BigInt(0),A$=BigInt(1),k$=BigInt(2),_$=BigInt(27),b$=BigInt(28),W8=BigInt(35),F0={};class o{#$;#q;#G;#J;get r(){return this.#$}set r($){C(M0($)===32,"invalid r","value",$),this.#$=_($)}get s(){return this.#q}set s($){C(M0($)===32,"invalid s","value",$);const q=_($);C(parseInt(q.substring(0,3))<8,"non-canonical s","value",q),this.#q=q}get v(){return this.#G}set v($){const q=V0($,"value");C(q===27||q===28,"invalid v","v",$),this.#G=q}get networkV(){return this.#J}get legacyChainId(){const $=this.networkV;if($==null)return null;return o.getChainId($)}get yParity(){return this.v===27?0:1}get yParityAndS(){const $=v(this.s);if(this.yParity)$[0]|=128;return _($)}get compactSerialized(){return Q0([this.r,this.yParityAndS])}get serialized(){return Q0([this.r,this.s,this.yParity?"0x1c":"0x1b"])}constructor($,q,J,G){n0($,F0,"Signature"),this.#$=q,this.#q=J,this.#G=G,this.#J=null}[Symbol.for("nodejs.util.inspect.custom")](){return`Signature { r: "${this.r}", s: "${this.s}", yParity: ${this.yParity}, networkV: ${this.networkV} }`}clone(){const $=new o(F0,this.r,this.s,this.v);if(this.networkV)$.#J=this.networkV;return $}toJSON(){const $=this.networkV;return{_type:"signature",networkV:$!=null?$.toString():null,r:this.r,s:this.s,v:this.v}}static getChainId($){const q=K0($,"v");if(q==_$||q==b$)return E$;return C(q>=W8,"invalid EIP-155 v","v",$),(q-W8)/k$}static getChainIdV($,q){return K0($)*k$+BigInt(35+q-27)}static getNormalizedV($){const q=K0($);if(q===E$||q===_$)return 27;if(q===A$||q===b$)return 28;return C(q>=W8,"invalid v","v",$),q&A$?27:28}static from($){function q(X,W){C(X,W,"signature",$)}if($==null)return new o(F0,I8,I8,27);if(typeof $==="string"){const X=v($,"signature");if(X.length===64){const W=_(X.slice(0,32)),z=X.slice(32,64),V=z[0]&128?28:27;return z[0]&=127,new o(F0,W,_(z),V)}if(X.length===65){const W=_(X.slice(0,32)),z=X.slice(32,64);q((z[0]&128)===0,"non-canonical s");const V=o.getNormalizedV(X[64]);return new o(F0,W,_(z),V)}q(!1,"invalid raw signature length")}if($ instanceof o)return $.clone();const J=$.r;q(J!=null,"missing r");const G=F$(J),Q=function(X,W){if(X!=null)return F$(X);if(W!=null){q(k0(W,32),"invalid yParityAndS");const z=v(W);return z[0]&=127,_(z)}q(!1,"missing s")}($.s,$.yParityAndS);q((v(Q)[0]&128)==0,"non-canonical s");const{networkV:M,v:Y}=function(X,W,z){if(X!=null){const V=K0(X);return{networkV:V>=W8?V:void 0,v:o.getNormalizedV(V)}}if(W!=null)return q(k0(W,32),"invalid yParityAndS"),{v:v(W)[0]&128?28:27};if(z!=null){switch(V0(z,"sig.yParity")){case 0:return{v:27};case 1:return{v:28}}q(!1,"invalid yParity")}q(!1,"missing v")}($.v,$.yParityAndS,$.yParity),I=new o(F0,G,Q,Y);if(M)I.#J=M;return q($.yParity==null||V0($.yParity,"sig.yParity")===I.yParity,"yParity mismatch"),q($.yParityAndS==null||$.yParityAndS===I.yParityAndS,"yParityAndS mismatch"),I}}class J0{#$;constructor($){C(M0($)===32,"invalid private key","privateKey","[REDACTED]"),this.#$=_($)}get privateKey(){return this.#$}get publicKey(){return J0.computePublicKey(this.#$)}get compressedPublicKey(){return J0.computePublicKey(this.#$,!0)}sign($){C(M0($)===32,"invalid digest length","digest",$);const q=W0.sign(z0($),z0(this.#$),{lowS:!0});return o.from({r:v0(q.r,32),s:v0(q.s,32),v:q.recovery?28:27})}computeSharedSecret($){const q=J0.computePublicKey($);return _(W0.getSharedSecret(z0(this.#$),v(q),!1))}static computePublicKey($,q){let J=v($,"key");if(J.length===32){const Q=W0.getPublicKey(J,!!q);return _(Q)}if(J.length===64){const Q=new Uint8Array(65);Q[0]=4,Q.set(J,1),J=Q}const G=W0.ProjectivePoint.fromHex(J);return _(G.toRawBytes(q))}static recoverPublicKey($,q){C(M0($)===32,"invalid digest length","digest",$);const J=o.from(q);let G=W0.Signature.fromCompact(z0(Q0([J.r,J.s])));G=G.addRecoveryBit(J.yParity);const Q=G.recoverPublicKey(z0($));return C(Q!=null,"invalid signature for digest","signature",q),"0x"+Q.toHex(!1)}static addPoints($,q,J){const G=W0.ProjectivePoint.fromHex(J0.computePublicKey($).substring(2)),Q=W0.ProjectivePoint.fromHex(J0.computePublicKey(q).substring(2));return"0x"+G.add(Q).toHex(!!J)}}var g$=function($){$=$.toLowerCase();const q=$.substring(2).split(""),J=new Uint8Array(40);for(let Q=0;Q<40;Q++)J[Q]=q[Q].charCodeAt(0);const G=v(s(J));for(let Q=0;Q<40;Q+=2){if(G[Q>>1]>>4>=8)q[Q]=q[Q].toUpperCase();if((G[Q>>1]&15)>=8)q[Q+1]=q[Q+1].toUpperCase()}return"0x"+q.join("")},qq=function($){$=$.toUpperCase(),$=$.substring(4)+$.substring(0,2)+"00";let q=$.split("").map((G)=>{return A8[G]}).join("");while(q.length>=y$){let G=q.substring(0,y$);q=parseInt(G,10)%97+q.substring(G.length)}let J=String(98-parseInt(q,10)%97);while(J.length<2)J="0"+J;return J},Qq=function($){$=$.toLowerCase();let q=$q;for(let J=0;J<$.length;J++)q=q*Jq+Gq[$[J]];return q};function c($){if(C(typeof $==="string","invalid address","address",$),$.match(/^(0x)?[0-9a-fA-F]{40}$/)){if(!$.startsWith("0x"))$="0x"+$;const q=g$($);return C(!$.match(/([A-F].*[a-f])|([a-f].*[A-F])/)||q===$,"bad address checksum","address",$),q}if($.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)){C($.substring(2,4)===qq($),"bad icap checksum","address",$);let q=Qq($.substring(4)).toString(16);while(q.length<40)q="0"+q;return g$("0x"+q)}C(!1,"invalid address","address",$)}var $q=BigInt(0),Jq=BigInt(36),A8={};for(let $=0;$<10;$++)A8[String($)]=String($);for(let $=0;$<26;$++)A8[String.fromCharCode(65+$)]=String(10+$);var y$=15,Gq=function(){const $={};for(let q=0;q<36;q++){const J="0123456789abcdefghijklmnopqrstuvwxyz"[q];$[J]=BigInt(q)}return $}();function v$($){let q;if(typeof $==="string")q=J0.computePublicKey($,!1);else q=$.publicKey;return c(s("0x"+q.substring(4)).substring(26))}function k8($,q){return v$(J0.recoverPublicKey($,q))}function _8($){if(typeof $==="string")$=U0($);return s(Q0([U0(E8),U0(String($.length)),$]))}function Z8($,q){const J=_8($);return k8(J,q)}var Yq=function($){return _(U0($))};class b8{constructor($,q,J,G=[]){if(!$)throw new Error("SecurityManager: localUserEthAddress es requerido.");try{this.localUserEthAddress=c($)}catch(Q){throw new Error(`SecurityManager: localUserEthAddress '${$}' no es una direcci\xF3n de Ethereum v\xE1lida.`)}if(!q)throw new Error("SecurityManager: dbInstance (GraphDB) es requerida.");if(!J||typeof J.mapChangeTypeToRbacAction!=="function"||typeof J.can!=="function")throw new Error("SecurityManager: rbacFunctions con m\xE9todos 'can' y 'mapChangeTypeToRbacAction' es requerido.");this.gdb=q,this.rbac=J,this.superAdminEthereumAddresses=(G||[]).map((Q)=>{try{return c(Q)}catch(M){return console.error("SM: Error al normalizar direcci\xF3n de superadmin, se omitir\xE1:",Q,M),null}}).filter((Q)=>Q!==null),this.strictMode=!0,console.log(`SM: SecurityManager inicializado para ETH Address ${this.localUserEthAddress}. Modo estricto: ${this.strictMode}. SuperAdmins ETH Addresses configurados: ${this.superAdminEthereumAddresses.length}`)}_canonicalizeDataForSigning($){const{signature:q,originEthAddress:J,...G}=$;return JSON.stringify(G,Object.keys(G).sort())}async signOutgoingOperations($){if(!this.localUserEthAddress)return console.warn("SM: Usuario ETH local no establecido."),this.strictMode?[]:$;if(!window.ethereum||!window.ethereum.request)return console.error("SM: MetaMask (window.ethereum) no detectado. No se pueden firmar operaciones."),this.strictMode?[]:$;const q=[];for(let J of $){const G={...J,originUser:this.localUserEthAddress},Q=this._canonicalizeDataForSigning(G),M=Yq(Q);try{const Y=await window.ethereum.request({method:"personal_sign",params:[M,this.localUserEthAddress]});q.push({...G,originEthAddress:G.originUser,signature:Y})}catch(Y){if(console.error(`SM: Error al firmar operaci\xF3n con MetaMask para ${this.localUserEthAddress}:`,Y),Y.code===4001)console.warn("SM: El usuario rechaz\xF3 la solicitud de firma en MetaMask.");if(this.strictMode)continue}}return q}async verifyIncomingOperations($){const q=[],J=[];for(let G of $){let Q=!1,M=G;if(G.signature&&G.originEthAddress){const{signature:Y,originEthAddress:I,...X}=G;let W;try{W=c(I)}catch(H){console.warn(`SM: originEthAddress '${I}' en operaci\xF3n entrante no es v\xE1lida. Op descartada:`,G),J.push(G);continue}M=X;const z={...X,originUser:W},V=this._canonicalizeDataForSigning(z);try{const H=Z8(V,Y);if(c(H)===W){console.log(`SM: Firma v\xE1lida para operaci\xF3n de ${W}.`);const P=X.type;if(P==="put"&&(X.id&&typeof X.id==="string"&&X.id.startsWith("user:"))&&(X.value&&typeof X.value.role==="string"))if(this.superAdminEthereumAddresses.includes(W))Q=!0,console.log(`SM: Acci\xF3n 'assignRole' P2P permitida para ${W} (superadmin por config).`);else console.warn(`SM: Intento de 'assignRole' P2P por ${W}. Su direcci\xF3n NO est\xE1 en config de superadmins. Descartado.`);else{const U=`user:${W}`,D=(await this.gdb.get(U)).result;if(D&&D.value&&D.value.role){const w=D.value.role;if(D.value.expiresAt&&new Date(D.value.expiresAt)<new Date)console.warn(`SM: Rol para ${W} ha caducado. Op descartada.`);else{const S=this.rbac.mapChangeTypeToRbacAction(P,X);if(this.rbac.can(w,S))Q=!0;else console.warn(`SM: Usuario ${W} (rol ${w}) no tiene permiso RBAC para '${S}'. Op descartada.`)}}else console.warn(`SM: No se encontr\xF3 nodo o rol en GDB para ${W} para operaci\xF3n '${P}'.`)}}else console.warn(`SM: Firma inv\xE1lida o no coincide con originEthAddress. Recuperada: ${c(H)}, Esperada: ${W}. Op descartada.`)}catch(H){console.error("SM: Error al verificar firma de Ethereum:",H,G)}}else console.warn("SM: Operaci\xF3n recibida sin firma o sin originEthAddress.",G);if(Q)q.push({...M,originUser:normalizedOriginEthAddress});else J.push(G)}return{validatedOperations:q,unverifiedOperations:J}}isStrictMode(){return this.strictMode}setStrictMode($){this.strictMode=$}}function mQ($){if(typeof $!=="object"||$===null)throw new Error("RBAC: Los roles personalizados deben ser un objeto v\xE1lido.");g0=$,console.log("RBAC: Roles personalizados establecidos.")}function y8($,q,J=new Set){const G=g0;if(!G[$])return!1;if(J.has($))return!1;if(J.add($),G[$].can&&G[$].can.includes(q))return!0;if(G[$].inherits&&Array.isArray(G[$].inherits))return G[$].inherits.some((Q)=>y8(Q,q,new Set(J)));return!1}function cQ($){if(typeof $==="function")z8=$,console.log("RBAC: Callback de cambio de estado de seguridad configurado.");else z8=null,console.warn("RBAC: Se intent\xF3 configurar un callback de cambio de estado no v\xE1lido.")}var h$=function(){if(z8)z8({isActive:q0,activeAddress:x})};async function c$($){console.log("RBAC: MetaMask accountsChanged detectado:",$);const q=$&&$.length>0?$[0]:null;let J=null;if(q)try{J=c(q)}catch(G){console.error("RBAC: Direcci\xF3n inv\xE1lida recibida de accountsChanged:",q,G)}if(!J){if(q0)console.log("RBAC: Desconectando seguridad debido a cambio de cuenta a ninguna o inv\xE1lida."),await g8()}else if(J!==x){if(console.log(`RBAC: Cuenta de MetaMask cambiada a ${J}. Reiniciando sesi\xF3n de seguridad.`),F){if(q0)await g8();await Iq(F,J,y0)}else if(console.warn("RBAC: currentGdbInstance no est\xE1 disponible para reinicializar seguridad tras cambio de cuenta."),q0)await g8()}else if(J===x&&!q0)console.log("RBAC: Misma cuenta detectada, pero la seguridad de la app estaba inactiva. No se tomar\xE1 acci\xF3n autom\xE1tica.");else console.log("RBAC: accountsChanged no result\xF3 en un cambio de estado de seguridad necesario.")}var Xq=function(){if(F8&&window.ethereum&&window.ethereum.removeListener)window.ethereum.removeListener("accountsChanged",c$);if(window.ethereum&&window.ethereum.on)window.ethereum.on("accountsChanged",c$),F8=!0,console.log("RBAC: Listener para 'accountsChanged' de MetaMask configurado/reconfigurado.");else console.warn("RBAC: window.ethereum no disponible para configurar listeners de MetaMask."),F8=!1};async function Iq($,q,J=[]){if(!$)throw console.error("RBAC Error: Se requiere instancia de GraphDB para inicializar la seguridad."),new Error("RBAC: Se requiere instancia de GraphDB.");if(!q)throw console.error("RBAC Error: No se proporcion\xF3 direcci\xF3n ETH para inicializar la seguridad."),new Error("RBAC: No se proporcion\xF3 direcci\xF3n ETH.");F=$;let G;try{G=c(q)}catch(X){throw console.error(`RBAC Error: Direcci\xF3n ETH '${q}' inv\xE1lida.`,X),new Error(`RBAC: Direcci\xF3n ETH '${q}' inv\xE1lida.`)}if(x=G,y0=(J||[]).map((X)=>{try{return c(X)}catch(W){return console.warn(`RBAC: Direcci\xF3n superadmin inv\xE1lida omitida: ${X}`),null}}).filter((X)=>X!==null),console.log(`RBAC: Inicializando seguridad para ETH: ${x}`),p0=new b8(x,F,{can:y8,mapChangeTypeToRbacAction:Kq},y0),F.securityManager=p0,F.sendData&&!F._originalSendDataByRBAC)F._originalSendDataByRBAC=F.sendData.bind(F),F.sendData=async(X)=>{if(!p0)return F._originalSendDataByRBAC(X);const W=await p0.signOutgoingOperations(X);return F._originalSendDataByRBAC(W)},console.log("RBAC: GDB sendData envuelto para firmas con MetaMask.");const Q=`user:${x}`,M=await F.get(Q),Y=M.result&&M.result.value||{};let I=Y.role;if(!I)I=Object.keys(g0).includes("user")?"user":Object.keys(g0)[Object.keys(g0).length-1];if(Y.role!==I||!M.result||Y.ethAddress!==x)await F.put({...Y,ethAddress:x,role:I},Q),console.log(`RBAC: Nodo para ETH Address ${x} (rol '${I}') asegurado en GDB.`);else console.log(`RBAC: Nodo para ETH Address ${x} ya existe y est\xE1 actualizado.`);return q0=!0,Xq(),h$(),console.log(`RBAC: Seguridad P2P (MetaMask) configurada y activa para ${x}.`),x}async function g8(){if(console.log("RBAC: Solicitando desactivaci\xF3n de seguridad P2P (MetaMask)."),F&&F._originalSendDataByRBAC)F.sendData=F._originalSendDataByRBAC,delete F._originalSendDataByRBAC,console.log("RBAC: GDB sendData restaurado a original.");if(F)F.securityManager=null;p0=null,x=null,q0=!1,h$(),console.log("RBAC: Seguridad desactivada.")}async function hQ($,q,J,G=null){if(!$||!q||!J)throw new Error("RBAC assignRole: db, targetUserEthAddress, y role son requeridos.");await $.ready;let Q;try{Q=c(q)}catch(W){throw new Error(`RBAC assignRole: targetUserEthAddress '${q}' no es una direcci\xF3n ETH v\xE1lida.`)}if(!g0[J])throw new Error(`RBAC: El rol '${J}' no existe.`);const M=`user:${Q}`,Y=await $.get(M),X={...Y.result&&Y.result.value||{},ethAddress:Q,role:J,assignedByEthAddress:x,expiresAt:G?new Date(G).toISOString():null};await $.put(X,M),console.log(`RBAC: Solicitud de asignaci\xF3n de rol '${J}' a ETH Address '${Q}' enviada a GDB.`)}async function Wq(){if(!q0||!x||!y0||y0.length===0)return!1;return y0.includes(x)}async function Zq($,q,J="desconocida"){let G;try{G=c(q)}catch(Y){throw new Error(`RBAC: Direcci\xF3n ETH '${q}' inv\xE1lida al verificar rol para operaci\xF3n '${J}'.`)}const Q=await $.get(`user:${G}`);if(!Q.result||!Q.result.value||!Q.result.value.role)throw new Error(`RBAC: No se encontr\xF3 rol para ETH Address ${G} en GDB (operaci\xF3n: ${J}).`);const M=Q.result.value;if(M.expiresAt&&new Date(M.expiresAt)<new Date)throw new Error(`RBAC: Rol para ETH Address ${G} ha caducado.`);return M.role}async function zq($,q,J){const G=await Zq($,q,J);if(!y8(G,J))throw new Error(`RBAC: Usuario ETH ${q} (rol ${G}) no tiene permiso para '${J}'.`)}async function lQ($,q,J,G){if(!$||!q||!J||!G)throw new Error("RBAC executeWithPermission: db, userEthAddressFromApp, operationName, y actionCallback son requeridos.");let Q;try{Q=c(q)}catch(Y){throw new Error(`RBAC (executeWithPermission): Direcci\xF3n ETH '${q}' inv\xE1lida.`)}if(!q0||!x)throw new Error(`RBAC (executeWithPermission): La seguridad no est\xE1 activa. No se puede ejecutar '${J}'.`);if(Q!==x)throw new Error(`RBAC (executeWithPermission): Intento de operaci\xF3n como '${Q}' pero la sesi\xF3n de seguridad activa es para '${x}'.`);let M=!1;if(J==="assignRole"){if(await Wq())M=!0,console.log(`RBAC (executeWithPermission): Usuario activo ${x} autorizado para 'assignRole' por config de superadmin.`)}else await zq($,x,J),M=!0,console.log(`RBAC (executeWithPermission): ${x} autorizado para '${J}' por rol en GDB.`);if(!M)throw new Error(`RBAC (executeWithPermission): ETH Address ${x} NO TIENE PERMISO para la operaci\xF3n '${J}'.`);return await G(x)}function Kq($,q={}){if($==="put"||$==="insert"||$==="update")return"write";if($==="remove")return"delete";if($==="link")return"link";if($==="sync"||$==="syncReceive")return"sync";return console.warn(`RBAC: Tipo de cambio desconocido '${$}' para mapeo RBAC gen\xE9rico.`),"unknown"}function pQ(){return x}function uQ(){return q0}var g0={superadmin:{can:["assignRole","deleteAny"],inherits:["admin"]},admin:{can:["delete"],inherits:["manager"]},manager:{can:["publish"],inherits:["user"]},user:{can:["write","link","sync"],inherits:["guest"]},guest:{can:["read"]}},F=null,x=null,p0=null,y0=[],q0=!1,z8=null,F8=!1;export{cQ as setSecurityStateChangeCallback,mQ as setCustomRoles,Kq as mapChangeTypeToRbacAction,uQ as isSecurityActive,Iq as initializeCompleteSecurity,pQ as getActiveEthAddress,lQ as executeWithPermission,g8 as deactivateSecurity,y8 as can,hQ as assignRole};
