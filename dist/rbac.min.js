function $(j){if(typeof j!=="object"||j===null)throw new Error("RBAC: Los roles personalizados deben ser un objeto v\xE1lido.");K=j,console.log("RBAC: Roles personalizados establecidos.")}function W(j,q,B=new Set){const z=K;if(!z[j])return!1;if(B.has(j))return!1;if(B.add(j),z[j].can&&z[j].can.includes(q))return!0;if(z[j].inherits&&Array.isArray(z[j].inherits))return z[j].inherits.some((F)=>W(F,q,new Set(B)));return!1}async function w(j,q,B=[],z){if(!j)throw new Error("RBAC: Se requiere instancia de GraphDB.");if(!q)throw new Error("RBAC: Se requiere userEthAddress del usuario activo.");if(!z)throw new Error("RBAC: Se requiere una instancia de SecurityManager (configurada con MetaMask).");O=j,G=q.toLowerCase(),X=B.map((Y)=>Y.toLowerCase()),V=z,O.securityManager=V;const F=`user:${G}`,J=await O.get(F),L=J.result&&J.result.value||{};let H=L.role;if(!H)H=Object.keys(K).includes("user")?"user":Object.keys(K)[Object.keys(K).length-1],console.log(`RBAC: Usuario ETH ${G} es nuevo en GDB o sin rol. Asignando rol por defecto: '${H}'.`);if(L.ethAddress!==G||L.role!==H||!J.result)await O.put({...L,ethAddress:G,role:H},F),console.log(`RBAC: Nodo para ${F} (rol '${H}') asegurado en GDB.`);console.log(`RBAC: Seguridad (MetaMask) inicializada para ${G}.`)}async function k(j,q,B,z=null){if(await j.ready,!K[B])throw new Error(`RBAC: El rol '${B}' no existe.`);const F=q.startsWith("0x")?`user:${q.toLowerCase()}`:`user:${q}`,J=await j.get(F),H={...J.result&&J.result.value||{},role:B,assignedByEthAddress:G,expiresAt:z?new Date(z).toISOString():null};await j.put(H,F),console.log(`RBAC: Solicitud de asignaci\xF3n de rol '${B}' a '${q}' (nodo ${F}) enviada.`)}async function Z(j,q){const B=`user:${q.toLowerCase()}`,z=await j.get(B);if(!z.result||!z.result.value||!z.result.value.role)throw new Error(`RBAC: No se encontr\xF3 rol para la direcci\xF3n ETH ${q} en GDB.`);const F=z.result.value;if(F.expiresAt&&new Date(F.expiresAt)<new Date)throw new Error(`RBAC: Rol para ${q} ha caducado.`);return F.role}async function _(j,q,B){const z=await Z(j,q);if(!W(z,B))throw new Error(`RBAC: Usuario ETH ${q} (rol ${z}) no tiene permiso local para '${B}'.`)}async function M(j,q,B,z){if(!q)throw new Error("RBAC (executeWithPermission): Se requiere userEthAddressToExecuteAs.");if(V&&G&&q.toLowerCase()!==G)throw new Error(`RBAC (executeWithPermission): Intento de operaci\xF3n como '${q}' pero la sesi\xF3n de seguridad es para '${G}'.`);let F=!1;if(B==="assignRole"){if(X.includes(q.toLowerCase()))F=!0,console.log(`RBAC (executeWithPermission): Usuario ETH ${q} autorizado localmente para 'assignRole' (superadmin por config ETH).`)}if(!F&&B!=="assignRole")await _(j,q,B),F=!0,console.log(`RBAC (executeWithPermission): Usuario ETH ${q} autorizado localmente para '${B}' por rol en GDB.`);if(!F)throw new Error(`RBAC (executeWithPermission): Usuario ETH ${q} NO TIENE PERMISO LOCAL para la operaci\xF3n '${B}'.`);return await z(q)}function P(j,q={}){if(j==="put"||j==="insert"||j==="update")return"write";if(j==="remove")return"delete";if(j==="link")return"link";if(j==="sync"||j==="syncReceive")return"sync";return console.warn(`RBAC: Tipo de cambio desconocido '${j}' para mapeo RBAC gen\xE9rico.`),"unknown"}var K={superadmin:{can:["assignRole"],inherits:["admin"]},admin:{can:["delete"],inherits:["manager"]},manager:{can:["publish"],inherits:["user"]},user:{can:["write","link","sync"],inherits:["guest"]},guest:{can:["read"]}},O=null,G=null,V=null,X=[];export{$ as setCustomRoles,P as mapChangeTypeToRbacAction,w as initializeMetaMaskSecurity,M as executeWithPermission,W as can,k as assignRole};
