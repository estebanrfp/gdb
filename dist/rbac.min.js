var M=function(){return new Promise((h,G)=>{const R=indexedDB.open("gdb-sm-signing-keys-store",1);R.onupgradeneeded=(L)=>{const _=L.target.result;if(!_.objectStoreNames.contains("privateKeysSM"))_.createObjectStore("privateKeysSM")},R.onsuccess=(L)=>h(L.target.result),R.onerror=(L)=>{console.error("SM: Error al abrir IndexedDB para claves:",L.target.error),G(L.target.error)}})};async function D(h,G){const L=(await M()).transaction("privateKeysSM","readwrite"),$=L.objectStore("privateKeysSM").put(G,h);await new Promise((X,x)=>{$.onsuccess=X,$.onerror=()=>x($.error)}),await(L.done||new Promise((X)=>{L.oncomplete=X}))}async function m(h){const _=(await M()).transaction("privateKeysSM","readonly").objectStore("privateKeysSM").get(h);return new Promise(($,X)=>{_.onsuccess=()=>$(_.result),_.onerror=()=>{console.error("SM: Error al obtener clave privada JWK:",_.error),X(_.error)}})}async function Q(h){if(!h)return null;try{return await window.crypto.subtle.importKey("jwk",h,{name:"ECDSA",namedCurve:"P-256"},!0,["sign"])}catch(G){return console.error("SM: Error al importar clave privada JWK:",G,h),null}}async function P(){const h=await window.crypto.subtle.generateKey({name:"ECDSA",namedCurve:"P-256"},!0,["sign","verify"]),G=await window.crypto.subtle.exportKey("jwk",h.privateKey),R=await window.crypto.subtle.exportKey("jwk",h.publicKey);return{privateKeyJwk:G,publicKeyJwk:R}}var F=function(h){const{signature:G,gdbSigningPubKey:R,...L}=h;return JSON.stringify(L,Object.keys(L).sort())};async function J(h,G){const R=F(h),L=(new TextEncoder()).encode(R);return await window.crypto.subtle.sign({name:"ECDSA",hash:{name:"SHA-256"}},G,L)}async function O(h,G,R){try{const L=await window.crypto.subtle.importKey("jwk",R,{name:"ECDSA",namedCurve:"P-256"},!0,["verify"]),_=F(h),$=(new TextEncoder()).encode(_);return await window.crypto.subtle.verify({name:"ECDSA",hash:{name:"SHA-256"}},L,G,$)}catch(L){return console.error("SM: Error al verificar firma ECDSA:",L,{signedDataObject:h,publicKeyJwk:R}),!1}}class T{constructor(h,G,R,L=[]){if(!h)throw new Error("SecurityManager: localUserHandle es requerido.");if(!G)throw new Error("SecurityManager: dbInstance (GraphDB) es requerida.");if(!R||typeof R.can!=="function"||typeof R.mapChangeTypeToRbacAction!=="function")throw new Error("SecurityManager: rbacFunctions con m\xE9todos 'can' y 'mapChangeTypeToRbacAction' es requerido.");this.localUserHandle=h,this.gdb=G,this.rbac=R,this.superAdminPublicKeys=[].concat(L||[]).map((_)=>{try{return typeof _==="string"?JSON.parse(_):_}catch($){return console.error("SM: Error al parsear clave de superadmin, se omitir\xE1:",_,$),null}}).filter((_)=>_!==null),this.strictMode=!0,this.localPrivateKey=null,console.log(`SM: SecurityManager inicializado para ${h}. Modo estricto: ${this.strictMode}. SuperAdmins configurados: ${this.superAdminPublicKeys.length}`)}async _loadLocalPrivateKey(){if(this.localPrivateKey)return this.localPrivateKey;const h=await m(this.localUserHandle);if(h)this.localPrivateKey=await Q(h);if(this.localPrivateKey);return this.localPrivateKey}async ensureLocalUserKeys(){if(!this.localUserHandle)throw new Error("SM: Usuario local no establecido en ensureLocalUserKeys.");if(await this._loadLocalPrivateKey(),this.localPrivateKey){const R=await this.gdb.get(`user:${this.localUserHandle}`);if(R.result&&R.result.value&&R.result.value.gdbSigningPubKey)return R.result.value.gdbSigningPubKey;console.warn(`SM: Clave privada local existe para ${this.localUserHandle}, pero no hay clave p\xFAblica en GDB. Se regenerar\xE1n las claves.`)}console.log(`SM: Generando par de claves de firma para ${this.localUserHandle}...`);const{privateKeyJwk:h,publicKeyJwk:G}=await P();if(await D(this.localUserHandle,h),this.localPrivateKey=await Q(h),!this.localPrivateKey)throw new Error(`SM: Fallo cr\xEDtico al generar y cargar la nueva clave privada para ${this.localUserHandle}`);return G}async signOutgoingOperations(h){if(!this.localUserHandle)return console.warn("SM: Usuario local no establecido. Enviando operaciones sin firmar (si no es modo estricto)."),this.strictMode?[]:h;if(!this.localPrivateKey)await this._loadLocalPrivateKey();if(!this.localPrivateKey)return console.error(`SM: No se pudo cargar o generar clave privada para ${this.localUserHandle}. No se pueden firmar operaciones (enviando sin firmar si no es modo estricto).`),this.strictMode?[]:h;const G=[],R=await this.gdb.get(`user:${this.localUserHandle}`),L=R.result&&R.result.value&&R.result.value.gdbSigningPubKey;if(!L&&this.strictMode)return console.error(`SM: No se encontr\xF3 gdbSigningPubKey para ${this.localUserHandle} al firmar. Operaciones no se enviar\xE1n en modo estricto.`),[];for(let _ of h){const $={..._,originUser:this.localUserHandle};try{const X=await J($,this.localPrivateKey);G.push({...$,gdbSigningPubKey:L,signature:Array.from(new Uint8Array(X))})}catch(X){if(console.error(`SM: Error al firmar operaci\xF3n para ${this.localUserHandle}:`,X,$),this.strictMode)continue;G.push(_)}}return G}async verifyIncomingOperations(h){const G=[],R=[];for(let L of h){let _=!1,$=L;if(L.signature&&L.originUser&&L.gdbSigningPubKey){const{signature:X,originUser:x,gdbSigningPubKey:Y,...z}=L;$=z;const j=new Uint8Array(X).buffer;if(await O(z,j,Y)){const C=(await this.gdb.get(`user:${x}`)).result,q=C&&C.value&&C.value.gdbSigningPubKey;if(q&&JSON.stringify(q)===JSON.stringify(Y)){const W=C.value.role;if(C.value.expiresAt&&new Date(C.value.expiresAt)<new Date)console.warn(`SM: Rol para ${x} ha caducado, op descartada:`,L);else{const B=this.rbac.mapChangeTypeToRbacAction(z.type);if(B==="assignRole")if(!this.superAdminPublicKeys.some((A)=>JSON.stringify(A)===JSON.stringify(Y)))console.warn(`SM: Intento de '${B}' por ${x} que no es superadmin conocido por config. Descartado.`);else if(this.rbac.can(W,B))_=!0;else console.warn(`SM: Superadmin (de config) ${x} (rol DB: ${W}) no tiene permiso RBAC '${B}' en DB. Descartado.`);else if(this.rbac.can(W,B))_=!0;else console.warn(`SM: Usuario ${x} (rol ${W}) no tiene permiso RBAC para '${B}'. Op descartada:`,L)}}else console.warn("SM: La clave p\xFAblica del mensaje no coincide con la registrada para el usuario. Op descartada:",L)}else console.warn("SM: Firma inv\xE1lida. Op descartada:",L)}if(_)G.push($);else R.push(L)}return{validatedOperations:G,unverifiedOperations:R}}isStrictMode(){return this.strictMode}setStrictMode(h){this.strictMode=h,console.log(`SM: Modo estricto cambiado a: ${this.strictMode}`)}}function p(h){if(typeof h!=="object"||h===null)throw new Error("RBAC: Los roles personalizados deben ser un objeto v\xE1lido.");I=h,console.log("RBAC: Roles personalizados establecidos.")}function f(h,G,R=new Set){const L=I;if(!L[h])return!1;if(R.has(h))return!1;if(R.add(h),L[h].can&&L[h].can.includes(G))return!0;if(L[h].inherits&&Array.isArray(L[h].inherits))return L[h].inherits.some((_)=>f(_,G,new Set(R)));return!1}async function l(h,G,R=[]){if(!h)throw new Error("RBAC: Se requiere instancia de GraphDB para inicializar la seguridad.");if(E=h,Z=G,Z){if(console.log(`RBAC: Inicializando seguridad completa para el usuario: ${Z}`),V=new T(Z,E,{can:f,mapChangeTypeToRbacAction:K},R),E.securityManager=V,E.sendData&&!E._originalSendDataByRBAC)E._originalSendDataByRBAC=E.sendData.bind(E),E.sendData=async(Y)=>{if(!V)return E._originalSendDataByRBAC(Y);const z=await V.signOutgoingOperations(Y);return E._originalSendDataByRBAC(z)},console.log("RBAC: GDB sendData envuelto para firmas P2P.");const L=await V.ensureLocalUserKeys(),$=(await E.get(`user:${Z}`)).result,X=$&&$.value&&$.value.gdbSigningPubKey;if(!X||JSON.stringify(X)!==JSON.stringify(L)){console.log(`RBAC: Actualizando/guardando gdbSigningPubKey para ${Z} en GDB...`);const Y=$&&$.value||{},z=Y.role||(Object.keys(I).includes("user")?"user":Object.keys(I)[Object.keys(I).length-1]);await E.put({...Y,gdbSigningPubKey:L,role:z},`user:${Z}`),console.log(`RBAC: gdbSigningPubKey y rol para ${Z} asegurados en GDB.`)}console.log(`RBAC: Seguridad P2P configurada y activa para ${Z}.`)}else{if(console.log("RBAC: No hay usuario local activo. Seguridad P2P no se activar\xE1/se desactivar\xE1."),E&&E._originalSendDataByRBAC)E.sendData=E._originalSendDataByRBAC,delete E._originalSendDataByRBAC,console.log("RBAC: GDB sendData restaurado a original.");if(E)E.securityManager=null;V=null}}async function u(h,G,R,L=null){if(await h.ready,!I[R])throw new Error(`RBAC: El rol '${R}' no existe.`);const _=`user:${G}`,$=await h.get(_),x={...$.result&&$.result.value||{},role:R,assignedBy:Z,expiresAt:L?new Date(L).toISOString():null};await h.put(x,_),console.log(`RBAC: Solicitud de asignaci\xF3n de rol '${R}' a '${G}' enviada a GDB.`)}var U=function(){const h=new Uint8Array(32);return window.crypto.getRandomValues(h),h},S=function(){const h=new Uint8Array(16);return window.crypto.getRandomValues(h),h};async function d(h,G){if(!h)throw new Error("RBAC: Se requiere instancia de GDB para handleAuthentication.");const R=`user:${G}`,L=await h.get(R);let _=L.result&&L.result.value||null,$=!1;if(!_)$=!0,console.log(`RBAC: Usuario ${G} no encontrado en GDB. Creando nodo de usuario inicial.`),_={storedCredential:null};if(!_.storedCredential)console.log(`RBAC: No hay credencial WebAuthn para ${G}. Iniciando registro...`),await w(h,G,_,$,R);else console.log(`RBAC: Hay credencial para ${G}. Iniciando autenticaci\xF3n...`),await N(h,G,_);return console.log(`RBAC: Flujo de autenticaci\xF3n WebAuthn completado para ${G}.`),G}async function w(h,G,R,L,_){if(!window.PublicKeyCredential)throw alert("WebAuthn no es soportado."),new Error("WebAuthn no soportado.");const $=S(),x={challenge:U(),rp:{name:"GDB Application"},user:{id:$,name:G,displayName:G},pubKeyCredParams:[{type:"public-key",alg:-7}],authenticatorSelection:{authenticatorAttachment:"platform",userVerification:"required"},timeout:60000,attestation:"none"};try{const Y=await navigator.credentials.create({publicKey:x}),z={id:Y.id,type:Y.type,rawId:Array.from(new Uint8Array(Y.rawId))};console.log(`RBAC: Credencial WebAuthn creada para ${G}. Se guardar\xE1 junto con la clave de firma.`),R.storedCredential=z}catch(Y){throw console.error("RBAC: Error en registro WebAuthn:",Y),Y}}async function N(h,G,R){if(!window.PublicKeyCredential)throw alert("WebAuthn no es soportado."),new Error("WebAuthn no soportado.");if(!R.storedCredential||!R.storedCredential.id)throw console.warn(`RBAC: No hay storedCredential para ${G}.`),new Error("Credencial no registrada.");const _={challenge:U(),allowCredentials:[{id:R.storedCredential.id,type:"public-key"}],userVerification:"required",timeout:60000};try{await navigator.credentials.get({publicKey:_}),console.log(`RBAC: Autenticaci\xF3n WebAuthn exitosa para ${G}.`)}catch($){throw console.error("RBAC: Error en autenticaci\xF3n WebAuthn:",$),$}}async function v(h,G){const R=await h.get(`user:${G}`);if(!R.result||!R.result.value||!R.result.value.role)throw new Error(`RBAC: No se encontr\xF3 rol para ${G}.`);const L=R.result.value;if(L.expiresAt&&new Date(L.expiresAt)<new Date)throw new Error(`RBAC: Rol para ${G} ha caducado.`);return L.role}async function H(h,G,R){const L=await v(h,G);if(!f(L,R))throw new Error(`RBAC: Usuario ${G} (rol ${L}) no tiene permiso para '${R}'.`)}async function o(h,G,R,L){if(!G)throw new Error("RBAC (executeWithPermission): Se requiere un userHandle v\xE1lido.");if(V&&Z&&G!==Z)throw new Error(`RBAC (executeWithPermission): Intento de operaci\xF3n como '${G}' pero la sesi\xF3n de seguridad P2P es para '${Z}'.`);return await H(h,G,R),console.log(`RBAC (executeWithPermission): ${G} autorizado localmente para '${R}'. Ejecutando acci\xF3n.`),await L(G)}function K(h){if(h==="put"||h==="insert"||h==="update")return"write";if(h==="remove")return"delete";if(h==="link")return"link";if(h==="assignRole")return"assignRole";if(h==="sync"||h==="syncReceive")return"sync";return console.warn(`RBAC: Tipo de cambio desconocido '${h}' para mapeo RBAC.`),"unknown"}var I={superadmin:{can:["assignRole"],inherits:["admin"]},admin:{can:["delete"],inherits:["manager"]},manager:{can:["publish"],inherits:["user"]},user:{can:["write","link","sync"],inherits:["guest"]},guest:{can:["read"]}},E=null,Z=null,V=null;export{p as setCustomRoles,K as mapChangeTypeToRbacAction,l as initializeCompleteSecurity,d as handleAuthentication,o as executeWithPermission,f as can,u as assignRole};
