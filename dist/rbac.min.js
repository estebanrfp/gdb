var I7=Object.defineProperty;var O7=(Q,Y)=>{for(var J in Y)I7(Q,J,{get:Y[J],enumerable:!0,configurable:!0,set:(X)=>Y[J]=()=>X})};var gQ="6.15.0";var R7=function(Q,Y,J){const X=Y.split("|").map((G)=>G.trim());for(let G=0;G<X.length;G++)switch(Y){case"any":return;case"bigint":case"boolean":case"number":case"string":if(typeof Q===Y)return}const q=new Error(`invalid value for type ${Y}`);throw q.code="INVALID_ARGUMENT",q.argument=`value.${J}`,q.value=Q,q};async function a0(Q){const Y=Object.keys(Q);return(await Promise.all(Y.map((X)=>Promise.resolve(Q[X])))).reduce((X,q,G)=>{return X[Y[G]]=q,X},{})}function s(Q,Y,J){for(let X in Y){let q=Y[X];const G=J?J[X]:null;if(G)R7(q,G,X);Object.defineProperty(Q,X,{enumerable:!0,value:q,writable:!1})}}var H9=function(Q,Y){if(Q==null)return"null";if(Y==null)Y=new Set;if(typeof Q==="object"){if(Y.has(Q))return"[Circular]";Y.add(Q)}if(Array.isArray(Q))return"[ "+Q.map((J)=>H9(J,Y)).join(", ")+" ]";if(Q instanceof Uint8Array){let X="0x";for(let q=0;q<Q.length;q++)X+="0123456789abcdef"[Q[q]>>4],X+="0123456789abcdef"[Q[q]&15];return X}if(typeof Q==="object"&&typeof Q.toJSON==="function")return H9(Q.toJSON(),Y);switch(typeof Q){case"boolean":case"number":case"symbol":return Q.toString();case"bigint":return BigInt(Q).toString();case"string":return JSON.stringify(Q);case"object":{const J=Object.keys(Q);return J.sort(),"{ "+J.map((X)=>`${H9(X,Y)}: ${H9(Q[X],Y)}`).join(", ")+" }"}}return"[ COULD NOT SERIALIZE ]"};function vQ(Q,Y){return Q&&Q.code===Y}function d9(Q,Y,J){let X=Q;{const G=[];if(J){if(("message"in J)||("code"in J)||("name"in J))throw new Error(`value will overwrite populated values: ${H9(J)}`);for(let W in J){if(W==="shortMessage")continue;const V=J[W];G.push(W+"="+H9(V))}}if(G.push(`code=${Y}`),G.push(`version=${gQ}`),G.length)Q+=" ("+G.join(", ")+")"}let q;switch(Y){case"INVALID_ARGUMENT":q=new TypeError(Q);break;case"NUMERIC_FAULT":case"BUFFER_OVERRUN":q=new RangeError(Q);break;default:q=new Error(Q)}if(s(q,{code:Y}),J)Object.assign(q,J);if(q.shortMessage==null)s(q,{shortMessage:X});return q}function x(Q,Y,J,X){if(!Q)throw d9(Y,J,X)}function O(Q,Y,J,X){x(Q,Y,"INVALID_ARGUMENT",{argument:J,value:X})}function D9(Q){x(H7.indexOf(Q)>=0,"platform missing String.prototype.normalize","UNSUPPORTED_OPERATION",{operation:"String.prototype.normalize",info:{form:Q}})}function V8(Q,Y,J){if(J==null)J="";if(Q!==Y){let X=J,q="new";if(J)X+=".",q+=" "+J;x(!1,`private constructor; use ${X}from* methods`,"UNSUPPORTED_OPERATION",{operation:q})}}var H7=["NFD","NFC","NFKD","NFKC"].reduce((Q,Y)=>{try{if("test".normalize(Y)!=="test")throw new Error("bad");if(Y==="NFD"){const J=String.fromCharCode(233).normalize("NFD"),X=String.fromCharCode(101,769);if(J!==X)throw new Error("broken")}Q.push(Y)}catch(J){}return Q},[]);var gY=function(Q,Y,J){if(Q instanceof Uint8Array){if(J)return new Uint8Array(Q);return Q}if(typeof Q==="string"&&Q.match(/^0x(?:[0-9a-f][0-9a-f])*$/i)){const X=new Uint8Array((Q.length-2)/2);let q=2;for(let G=0;G<X.length;G++)X[G]=parseInt(Q.substring(q,q+2),16),q+=2;return X}O(!1,"invalid BytesLike value",Y||"value",Q)};function T(Q,Y){return gY(Q,Y,!1)}function d0(Q,Y){return gY(Q,Y,!0)}function D0(Q,Y){if(typeof Q!=="string"||!Q.match(/^0x[0-9A-Fa-f]*$/))return!1;if(typeof Y==="number"&&Q.length!==2+2*Y)return!1;if(Y===!0&&Q.length%2!==0)return!1;return!0}function s0(Q){return D0(Q,!0)||Q instanceof Uint8Array}function N(Q){const Y=T(Q);let J="0x";for(let X=0;X<Y.length;X++){const q=Y[X];J+=xY[(q&240)>>4]+xY[q&15]}return J}function o(Q){return"0x"+Q.map((Y)=>N(Y).substring(2)).join("")}function U8(Q){if(D0(Q,!0))return(Q.length-2)/2;return T(Q).length}function P9(Q,Y,J){const X=T(Q);if(J!=null&&J>X.length)x(!1,"cannot slice beyond data bounds","BUFFER_OVERRUN",{buffer:X,length:X.length,offset:J});return N(X.slice(Y==null?0:Y,J==null?X.length:J))}var D7=function(Q,Y,J){const X=T(Q);x(Y>=X.length,"padding exceeds data length","BUFFER_OVERRUN",{buffer:new Uint8Array(X),length:Y,offset:Y+1});const q=new Uint8Array(Y);if(q.fill(0),J)q.set(X,Y-X.length);else q.set(X,0);return N(q)};function A0(Q,Y){return D7(Q,Y,!0)}var xY="0123456789abcdef";function fQ(Q,Y){let J=h(Q,"value");const X=BigInt($0(Y,"width")),q=l8<<X-l8;if(J<oJ){J=-J,x(J<=q,"too low","NUMERIC_FAULT",{operation:"toTwos",fault:"overflow",value:Q});const G=(l8<<X)-l8;return(~J&G)+l8}else x(J<q,"too high","NUMERIC_FAULT",{operation:"toTwos",fault:"overflow",value:Q});return J}function bQ(Q,Y){const J=l9(Q,"value"),X=BigInt($0(Y,"bits"));return J&(l8<<X)-l8}function h(Q,Y){switch(typeof Q){case"bigint":return Q;case"number":return O(Number.isInteger(Q),"underflow",Y||"value",Q),O(Q>=-j9&&Q<=j9,"overflow",Y||"value",Q),BigInt(Q);case"string":try{if(Q==="")throw new Error("empty string");if(Q[0]==="-"&&Q[1]!=="-")return-BigInt(Q.substring(1));return BigInt(Q)}catch(J){O(!1,`invalid BigNumberish string: ${J.message}`,Y||"value",Q)}}O(!1,"invalid BigNumberish value",Y||"value",Q)}function l9(Q,Y){const J=h(Q,Y);return x(J>=oJ,"unsigned value cannot be negative","NUMERIC_FAULT",{fault:"overflow",operation:"getUint",value:Q}),J}function L9(Q){if(Q instanceof Uint8Array){let Y="0x0";for(let J of Q)Y+=vY[J>>4],Y+=vY[J&15];return BigInt(Y)}return h(Q)}function $0(Q,Y){switch(typeof Q){case"bigint":return O(Q>=-j9&&Q<=j9,"overflow",Y||"value",Q),Number(Q);case"number":return O(Number.isInteger(Q),"underflow",Y||"value",Q),O(Q>=-j9&&Q<=j9,"overflow",Y||"value",Q),Q;case"string":try{if(Q==="")throw new Error("empty string");return $0(BigInt(Q),Y)}catch(J){O(!1,`invalid numeric string: ${J.message}`,Y||"value",Q)}}O(!1,"invalid numeric value",Y||"value",Q)}function l0(Q,Y){let X=l9(Q,"value").toString(16);if(Y==null){if(X.length%2)X="0"+X}else{const q=$0(Y,"width");x(q*2>=X.length,`value exceeds width (${q} bytes)`,"NUMERIC_FAULT",{operation:"toBeHex",fault:"overflow",value:Q});while(X.length<q*2)X="0"+X}return"0x"+X}function t(Q){const Y=l9(Q,"value");if(Y===oJ)return new Uint8Array([]);let J=Y.toString(16);if(J.length%2)J="0"+J;const X=new Uint8Array(J.length/2);for(let q=0;q<X.length;q++){const G=q*2;X[q]=parseInt(J.substring(G,G+2),16)}return X}function yQ(Q){let Y=N(s0(Q)?Q:t(Q)).substring(2);while(Y.startsWith("0"))Y=Y.substring(1);if(Y==="")Y="0";return"0x"+Y}var oJ=BigInt(0),l8=BigInt(1),j9=9007199254740991,vY="0123456789abcdef";var P7=function(Q){if(hQ==null){hQ={};for(let J=0;J<mQ.length;J++)hQ[mQ[J]]=BigInt(J)}const Y=hQ[Q];return O(Y!=null,"invalid base58 value","letter",Q),Y};function _Q(Q){const Y=T(Q);let J=L9(Y),X="";while(J)X=mQ[Number(J%rJ)]+X,J/=rJ;for(let q=0;q<Y.length;q++){if(Y[q])break;X=mQ[0]+X}return X}function cQ(Q){let Y=j7;for(let J=0;J<Q.length;J++)Y*=rJ,Y+=P7(Q[J]);return Y}var mQ="123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz",hQ=null,j7=BigInt(0),rJ=BigInt(58);var L7=function(Q,Y,J,X,q){O(!1,`invalid codepoint at offset ${Y}; ${Q}`,"bytes",J)},fY=function(Q,Y,J,X,q){if(Q==="BAD_PREFIX"||Q==="UNEXPECTED_CONTINUE"){let G=0;for(let W=Y+1;W<J.length;W++){if(J[W]>>6!==2)break;G++}return G}if(Q==="OVERRUN")return J.length-Y-1;return 0},C7=function(Q,Y,J,X,q){if(Q==="OVERLONG")return O(typeof q==="number","invalid bad code point for replacement","badCodepoint",q),X.push(q),0;return X.push(65533),fY(Q,Y,J,X,q)},N7=function(Q,Y){if(Y==null)Y=aJ.error;const J=T(Q,"bytes"),X=[];let q=0;while(q<J.length){const G=J[q++];if(G>>7===0){X.push(G);continue}let W=null,V=null;if((G&224)===192)W=1,V=127;else if((G&240)===224)W=2,V=2047;else if((G&248)===240)W=3,V=65535;else{if((G&192)===128)q+=Y("UNEXPECTED_CONTINUE",q-1,J,X);else q+=Y("BAD_PREFIX",q-1,J,X);continue}if(q-1+W>=J.length){q+=Y("OVERRUN",q-1,J,X);continue}let $=G&(1<<8-W-1)-1;for(let U=0;U<W;U++){let Z=J[q];if((Z&192)!=128){q+=Y("MISSING_CONTINUE",q,J,X),$=null;break}$=$<<6|Z&63,q++}if($===null)continue;if($>1114111){q+=Y("OUT_OF_RANGE",q-1-W,J,X,$);continue}if($>=55296&&$<=57343){q+=Y("UTF16_SURROGATE",q-1-W,J,X,$);continue}if($<=V){q+=Y("OVERLONG",q-1-W,J,X,$);continue}X.push($)}return X};function Z0(Q,Y){if(O(typeof Q==="string","invalid string value","str",Q),Y!=null)D9(Y),Q=Q.normalize(Y);let J=[];for(let X=0;X<Q.length;X++){const q=Q.charCodeAt(X);if(q<128)J.push(q);else if(q<2048)J.push(q>>6|192),J.push(q&63|128);else if((q&64512)==55296){X++;const G=Q.charCodeAt(X);O(X<Q.length&&(G&64512)===56320,"invalid surrogate pair","str",Q);const W=65536+((q&1023)<<10)+(G&1023);J.push(W>>18|240),J.push(W>>12&63|128),J.push(W>>6&63|128),J.push(W&63|128)}else J.push(q>>12|224),J.push(q>>6&63|128),J.push(q&63|128)}return new Uint8Array(J)}var T7=function(Q){return Q.map((Y)=>{if(Y<=65535)return String.fromCharCode(Y);return Y-=65536,String.fromCharCode((Y>>10&1023)+55296,(Y&1023)+56320)}).join("")};function pQ(Q,Y){return T7(N7(Q,Y))}var aJ=Object.freeze({error:L7,ignore:fY,replace:C7});var F7=function(Q){let Y=Q.toString(16);while(Y.length<2)Y="0"+Y;return"0x"+Y},bY=function(Q,Y,J){let X=0;for(let q=0;q<J;q++)X=X*256+Q[Y+q];return X},yY=function(Q,Y,J,X){const q=[];while(J<Y+1+X){const G=hY(Q,J);q.push(G.result),J+=G.consumed,x(J<=Y+1+X,"child data too short","BUFFER_OVERRUN",{buffer:Q,length:X,offset:Y})}return{consumed:1+X,result:q}},hY=function(Q,Y){x(Q.length!==0,"data too short","BUFFER_OVERRUN",{buffer:Q,length:0,offset:1});const J=(X)=>{x(X<=Q.length,"data short segment too short","BUFFER_OVERRUN",{buffer:Q,length:Q.length,offset:X})};if(Q[Y]>=248){const X=Q[Y]-247;J(Y+1+X);const q=bY(Q,Y+1,X);return J(Y+1+X+q),yY(Q,Y,Y+1+X,X+q)}else if(Q[Y]>=192){const X=Q[Y]-192;return J(Y+1+X),yY(Q,Y,Y+1,X)}else if(Q[Y]>=184){const X=Q[Y]-183;J(Y+1+X);const q=bY(Q,Y+1,X);J(Y+1+X+q);const G=N(Q.slice(Y+1+X,Y+1+X+q));return{consumed:1+X+q,result:G}}else if(Q[Y]>=128){const X=Q[Y]-128;J(Y+1+X);const q=N(Q.slice(Y+1,Y+1+X));return{consumed:1+X,result:q}}return{consumed:1,result:F7(Q[Y])}};function B8(Q){const Y=T(Q,"data"),J=hY(Y,0);return O(J.consumed===Y.length,"unexpected junk after rlp payload","data",Q),J.result}var mY=function(Q){const Y=[];while(Q)Y.unshift(Q&255),Q>>=8;return Y},cY=function(Q){if(Array.isArray(Q)){let X=[];if(Q.forEach(function(G){X=X.concat(cY(G))}),X.length<=55)return X.unshift(192+X.length),X;const q=mY(X.length);return q.unshift(247+q.length),q.concat(X)}const Y=Array.prototype.slice.call(T(Q,"object"));if(Y.length===1&&Y[0]<=127)return Y;else if(Y.length<=55)return Y.unshift(128+Y.length),Y;const J=mY(Y.length);return J.unshift(183+J.length),J.concat(Y)};function f0(Q){let Y="0x";for(let J of cY(Q))Y+=_Y[J>>4],Y+=_Y[J&15];return Y}var _Y="0123456789abcdef";function uQ(Q){const Y=T(Q,"randomBytes");Y[6]=Y[6]&15|64,Y[8]=Y[8]&63|128;const J=N(Y);return[J.substring(2,10),J.substring(10,14),J.substring(14,18),J.substring(18,22),J.substring(22,34)].join("-")}var P0=function(Q){if(!Number.isSafeInteger(Q)||Q<0)throw new Error(`Wrong positive integer: ${Q}`)};var i9=function(Q,...Y){if(!(Q instanceof Uint8Array))throw new Error("Expected Uint8Array");if(Y.length>0&&!Y.includes(Q.length))throw new Error(`Expected Uint8Array of length ${Y}, not of length=${Q.length}`)},dQ=function(Q){if(typeof Q!=="function"||typeof Q.create!=="function")throw new Error("Hash should be wrapped by utils.wrapConstructor");P0(Q.outputLen),P0(Q.blockLen)},$8=function(Q,Y=!0){if(Q.destroyed)throw new Error("Hash instance has been destroyed");if(Y&&Q.finished)throw new Error("Hash#digest() has already been called")},lQ=function(Q,Y){i9(Q);const J=Y.outputLen;if(Q.length<J)throw new Error(`digestInto() expects output buffer of length at least ${J}`)};var iQ=typeof globalThis==="object"&&("crypto"in globalThis)?globalThis.crypto:void 0;async function nQ(Q,Y,J){let X=Date.now();for(let q=0;q<Q;q++){J(q);const G=Date.now()-X;if(G>=0&&G<Y)continue;await v7(),X+=G}}function f7(Q){if(typeof Q!=="string")throw new Error(`utf8ToBytes expected string, got ${typeof Q}`);return new Uint8Array((new TextEncoder()).encode(Q))}function t0(Q){if(typeof Q==="string")Q=f7(Q);if(!pY(Q))throw new Error(`expected Uint8Array, got ${typeof Q}`);return Q}function uY(...Q){const Y=new Uint8Array(Q.reduce((X,q)=>X+q.length,0));let J=0;return Q.forEach((X)=>{if(!pY(X))throw new Error("Uint8Array expected");Y.set(X,J),J+=X.length}),Y}function oQ(Q,Y){if(Y!==void 0&&b7.call(Y)!=="[object Object]")throw new Error("Options should be object or undefined");return Object.assign(Q,Y)}function S8(Q){const Y=(X)=>Q().update(t0(X)).digest(),J=Q();return Y.outputLen=J.outputLen,Y.blockLen=J.blockLen,Y.create=()=>Q(),Y}function dY(Q=32){if(iQ&&typeof iQ.getRandomValues==="function")return iQ.getRandomValues(new Uint8Array(Q));throw new Error("crypto.getRandomValues must be defined")}/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */var pY=(Q)=>Q instanceof Uint8Array;var C9=(Q)=>new Uint32Array(Q.buffer,Q.byteOffset,Math.floor(Q.byteLength/4)),N9=(Q)=>new DataView(Q.buffer,Q.byteOffset,Q.byteLength),i0=(Q,Y)=>Q<<32-Y|Q>>>Y,g7=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;if(!g7)throw new Error("Non little-endian hardware is not supported");var v7=async()=>{};class i8{clone(){return this._cloneInto()}}var b7={}.toString;class sJ extends i8{constructor(Q,Y){super();this.finished=!1,this.destroyed=!1,dQ(Q);const J=t0(Y);if(this.iHash=Q.create(),typeof this.iHash.update!=="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const X=this.blockLen,q=new Uint8Array(X);q.set(J.length>X?Q.create().update(J).digest():J);for(let G=0;G<q.length;G++)q[G]^=54;this.iHash.update(q),this.oHash=Q.create();for(let G=0;G<q.length;G++)q[G]^=54^92;this.oHash.update(q),q.fill(0)}update(Q){return $8(this),this.iHash.update(Q),this}digestInto(Q){$8(this),i9(Q,this.outputLen),this.finished=!0,this.iHash.digestInto(Q),this.oHash.update(Q),this.oHash.digestInto(Q),this.destroy()}digest(){const Q=new Uint8Array(this.oHash.outputLen);return this.digestInto(Q),Q}_cloneInto(Q){Q||(Q=Object.create(Object.getPrototypeOf(this),{}));const{oHash:Y,iHash:J,finished:X,destroyed:q,blockLen:G,outputLen:W}=this;return Q=Q,Q.finished=X,Q.destroyed=q,Q.blockLen=G,Q.outputLen=W,Q.oHash=Y._cloneInto(Q.oHash),Q.iHash=J._cloneInto(Q.iHash),Q}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}var n8=(Q,Y,J)=>new sJ(Q,Y).update(J).digest();n8.create=(Q,Y)=>new sJ(Q,Y);var y7=function(Q,Y,J,X){dQ(Q);const q=oQ({dkLen:32,asyncTick:10},X),{c:G,dkLen:W,asyncTick:V}=q;if(P0(G),P0(W),P0(V),G<1)throw new Error("PBKDF2: iterations (c) should be >= 1");const $=t0(Y),U=t0(J),Z=new Uint8Array(W),K=n8.create(Q,$),M=K._cloneInto().update(U);return{c:G,dkLen:W,asyncTick:V,DK:Z,PRF:K,PRFSalt:M}},h7=function(Q,Y,J,X,q){if(Q.destroy(),Y.destroy(),X)X.destroy();return q.fill(0),J};function n9(Q,Y,J,X){const{c:q,dkLen:G,DK:W,PRF:V,PRFSalt:$}=y7(Q,Y,J,X);let U;const Z=new Uint8Array(4),K=N9(Z),M=new Uint8Array(V.outputLen);for(let I=1,z=0;z<G;I++,z+=V.outputLen){const R=W.subarray(z,z+V.outputLen);K.setInt32(0,I,!1),(U=$._cloneInto(U)).update(Z).digestInto(M),R.set(M.subarray(0,R.length));for(let H=1;H<q;H++){V._cloneInto(U).update(M).digestInto(M);for(let D=0;D<R.length;D++)R[D]^=M[D]}}return h7(V,$,W,U,M)}var m7=function(Q,Y,J,X){if(typeof Q.setBigUint64==="function")return Q.setBigUint64(Y,J,X);const q=BigInt(32),G=BigInt(4294967295),W=Number(J>>q&G),V=Number(J&G),$=X?4:0,U=X?0:4;Q.setUint32(Y+$,W,X),Q.setUint32(Y+U,V,X)};class o8 extends i8{constructor(Q,Y,J,X){super();this.blockLen=Q,this.outputLen=Y,this.padOffset=J,this.isLE=X,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(Q),this.view=N9(this.buffer)}update(Q){$8(this);const{view:Y,buffer:J,blockLen:X}=this;Q=t0(Q);const q=Q.length;for(let G=0;G<q;){const W=Math.min(X-this.pos,q-G);if(W===X){const V=N9(Q);for(;X<=q-G;G+=X)this.process(V,G);continue}if(J.set(Q.subarray(G,G+W),this.pos),this.pos+=W,G+=W,this.pos===X)this.process(Y,0),this.pos=0}return this.length+=Q.length,this.roundClean(),this}digestInto(Q){$8(this),lQ(Q,this),this.finished=!0;const{buffer:Y,view:J,blockLen:X,isLE:q}=this;let{pos:G}=this;if(Y[G++]=128,this.buffer.subarray(G).fill(0),this.padOffset>X-G)this.process(J,0),G=0;for(let Z=G;Z<X;Z++)Y[Z]=0;m7(J,X-8,BigInt(this.length*8),q),this.process(J,0);const W=N9(Q),V=this.outputLen;if(V%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const $=V/4,U=this.get();if($>U.length)throw new Error("_sha2: outputLen bigger than state");for(let Z=0;Z<$;Z++)W.setUint32(4*Z,U[Z],q)}digest(){const{buffer:Q,outputLen:Y}=this;this.digestInto(Q);const J=Q.slice(0,Y);return this.destroy(),J}_cloneInto(Q){Q||(Q=new this.constructor),Q.set(...this.get());const{blockLen:Y,buffer:J,length:X,finished:q,destroyed:G,pos:W}=this;if(Q.length=X,Q.pos=W,Q.finished=q,Q.destroyed=G,X%Y)Q.buffer.set(J);return Q}}var _7=(Q,Y,J)=>Q&Y^~Q&J,c7=(Q,Y,J)=>Q&Y^Q&J^Y&J,p7=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),A8=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),E8=new Uint32Array(64);class lY extends o8{constructor(){super(64,32,8,!1);this.A=A8[0]|0,this.B=A8[1]|0,this.C=A8[2]|0,this.D=A8[3]|0,this.E=A8[4]|0,this.F=A8[5]|0,this.G=A8[6]|0,this.H=A8[7]|0}get(){const{A:Q,B:Y,C:J,D:X,E:q,F:G,G:W,H:V}=this;return[Q,Y,J,X,q,G,W,V]}set(Q,Y,J,X,q,G,W,V){this.A=Q|0,this.B=Y|0,this.C=J|0,this.D=X|0,this.E=q|0,this.F=G|0,this.G=W|0,this.H=V|0}process(Q,Y){for(let Z=0;Z<16;Z++,Y+=4)E8[Z]=Q.getUint32(Y,!1);for(let Z=16;Z<64;Z++){const K=E8[Z-15],M=E8[Z-2],I=i0(K,7)^i0(K,18)^K>>>3,z=i0(M,17)^i0(M,19)^M>>>10;E8[Z]=z+E8[Z-7]+I+E8[Z-16]|0}let{A:J,B:X,C:q,D:G,E:W,F:V,G:$,H:U}=this;for(let Z=0;Z<64;Z++){const K=i0(W,6)^i0(W,11)^i0(W,25),M=U+K+_7(W,V,$)+p7[Z]+E8[Z]|0,z=(i0(J,2)^i0(J,13)^i0(J,22))+c7(J,X,q)|0;U=$,$=V,V=W,W=G+M|0,G=q,q=X,X=J,J=M+z|0}J=J+this.A|0,X=X+this.B|0,q=q+this.C|0,G=G+this.D|0,W=W+this.E|0,V=V+this.F|0,$=$+this.G|0,U=U+this.H|0,this.set(J,X,q,G,W,V,$,U)}roundClean(){E8.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}}var Z8=S8(()=>new lY);var iY=function(Q,Y=!1){if(Y)return{h:Number(Q&rQ),l:Number(Q>>tJ&rQ)};return{h:Number(Q>>tJ&rQ)|0,l:Number(Q&rQ)|0}},eJ=function(Q,Y=!1){let J=new Uint32Array(Q.length),X=new Uint32Array(Q.length);for(let q=0;q<Q.length;q++){const{h:G,l:W}=iY(Q[q],Y);[J[q],X[q]]=[G,W]}return[J,X]},t7=function(Q,Y,J,X){const q=(Y>>>0)+(X>>>0);return{h:Q+J+(q/4294967296|0)|0,l:q|0}},rQ=BigInt(4294967295),tJ=BigInt(32),u7=(Q,Y)=>BigInt(Q>>>0)<<tJ|BigInt(Y>>>0),d7=(Q,Y,J)=>Q>>>J,l7=(Q,Y,J)=>Q<<32-J|Y>>>J,i7=(Q,Y,J)=>Q>>>J|Y<<32-J,n7=(Q,Y,J)=>Q<<32-J|Y>>>J,o7=(Q,Y,J)=>Q<<64-J|Y>>>J-32,r7=(Q,Y,J)=>Q>>>J-32|Y<<64-J,a7=(Q,Y)=>Y,s7=(Q,Y)=>Q,Q5=(Q,Y,J)=>Q<<J|Y>>>32-J,J5=(Q,Y,J)=>Y<<J|Q>>>32-J,Y5=(Q,Y,J)=>Y<<J-32|Q>>>64-J,X5=(Q,Y,J)=>Q<<J-32|Y>>>64-J,e7=(Q,Y,J)=>(Q>>>0)+(Y>>>0)+(J>>>0),QG=(Q,Y,J,X)=>Y+J+X+(Q/4294967296|0)|0,JG=(Q,Y,J,X)=>(Q>>>0)+(Y>>>0)+(J>>>0)+(X>>>0),YG=(Q,Y,J,X,q)=>Y+J+X+q+(Q/4294967296|0)|0,XG=(Q,Y,J,X,q)=>(Q>>>0)+(Y>>>0)+(J>>>0)+(X>>>0)+(q>>>0),qG=(Q,Y,J,X,q,G)=>Y+J+X+q+G+(Q/4294967296|0)|0;var GG={fromBig:iY,split:eJ,toBig:u7,shrSH:d7,shrSL:l7,rotrSH:i7,rotrSL:n7,rotrBH:o7,rotrBL:r7,rotr32H:a7,rotr32L:s7,rotlSH:Q5,rotlSL:J5,rotlBH:Y5,rotlBL:X5,add:t7,add3L:e7,add3H:QG,add4L:JG,add4H:YG,add5H:qG,add5L:XG},f=GG;var[WG,VG]=(()=>f.split(["0x428a2f98d728ae22","0x7137449123ef65cd","0xb5c0fbcfec4d3b2f","0xe9b5dba58189dbbc","0x3956c25bf348b538","0x59f111f1b605d019","0x923f82a4af194f9b","0xab1c5ed5da6d8118","0xd807aa98a3030242","0x12835b0145706fbe","0x243185be4ee4b28c","0x550c7dc3d5ffb4e2","0x72be5d74f27b896f","0x80deb1fe3b1696b1","0x9bdc06a725c71235","0xc19bf174cf692694","0xe49b69c19ef14ad2","0xefbe4786384f25e3","0x0fc19dc68b8cd5b5","0x240ca1cc77ac9c65","0x2de92c6f592b0275","0x4a7484aa6ea6e483","0x5cb0a9dcbd41fbd4","0x76f988da831153b5","0x983e5152ee66dfab","0xa831c66d2db43210","0xb00327c898fb213f","0xbf597fc7beef0ee4","0xc6e00bf33da88fc2","0xd5a79147930aa725","0x06ca6351e003826f","0x142929670a0e6e70","0x27b70a8546d22ffc","0x2e1b21385c26c926","0x4d2c6dfc5ac42aed","0x53380d139d95b3df","0x650a73548baf63de","0x766a0abb3c77b2a8","0x81c2c92e47edaee6","0x92722c851482353b","0xa2bfe8a14cf10364","0xa81a664bbc423001","0xc24b8b70d0f89791","0xc76c51a30654be30","0xd192e819d6ef5218","0xd69906245565a910","0xf40e35855771202a","0x106aa07032bbd1b8","0x19a4c116b8d2d0c8","0x1e376c085141ab53","0x2748774cdf8eeb99","0x34b0bcb5e19b48a8","0x391c0cb3c5c95a63","0x4ed8aa4ae3418acb","0x5b9cca4f7763e373","0x682e6ff3d6b2b8a3","0x748f82ee5defb2fc","0x78a5636f43172f60","0x84c87814a1f0ab72","0x8cc702081a6439ec","0x90befffa23631e28","0xa4506cebde82bde9","0xbef9a3f7b2c67915","0xc67178f2e372532b","0xca273eceea26619c","0xd186b8c721c0c207","0xeada7dd6cde0eb1e","0xf57d4f7fee6ed178","0x06f067aa72176fba","0x0a637dc5a2c898a6","0x113f9804bef90dae","0x1b710b35131c471b","0x28db77f523047d84","0x32caab7b40c72493","0x3c9ebe0a15c9bebc","0x431d67c49c100d4c","0x4cc5d4becb3e42b6","0x597f299cfc657e2a","0x5fcb6fab3ad6faec","0x6c44198c4a475817"].map((Q)=>BigInt(Q))))(),k8=new Uint32Array(80),x8=new Uint32Array(80);class nY extends o8{constructor(){super(128,64,16,!1);this.Ah=1779033703|0,this.Al=4089235720|0,this.Bh=3144134277|0,this.Bl=2227873595|0,this.Ch=1013904242|0,this.Cl=4271175723|0,this.Dh=2773480762|0,this.Dl=1595750129|0,this.Eh=1359893119|0,this.El=2917565137|0,this.Fh=2600822924|0,this.Fl=725511199|0,this.Gh=528734635|0,this.Gl=4215389547|0,this.Hh=1541459225|0,this.Hl=327033209|0}get(){const{Ah:Q,Al:Y,Bh:J,Bl:X,Ch:q,Cl:G,Dh:W,Dl:V,Eh:$,El:U,Fh:Z,Fl:K,Gh:M,Gl:I,Hh:z,Hl:R}=this;return[Q,Y,J,X,q,G,W,V,$,U,Z,K,M,I,z,R]}set(Q,Y,J,X,q,G,W,V,$,U,Z,K,M,I,z,R){this.Ah=Q|0,this.Al=Y|0,this.Bh=J|0,this.Bl=X|0,this.Ch=q|0,this.Cl=G|0,this.Dh=W|0,this.Dl=V|0,this.Eh=$|0,this.El=U|0,this.Fh=Z|0,this.Fl=K|0,this.Gh=M|0,this.Gl=I|0,this.Hh=z|0,this.Hl=R|0}process(Q,Y){for(let j=0;j<16;j++,Y+=4)k8[j]=Q.getUint32(Y),x8[j]=Q.getUint32(Y+=4);for(let j=16;j<80;j++){const w=k8[j-15]|0,P=x8[j-15]|0,C=f.rotrSH(w,P,1)^f.rotrSH(w,P,8)^f.shrSH(w,P,7),S=f.rotrSL(w,P,1)^f.rotrSL(w,P,8)^f.shrSL(w,P,7),L=k8[j-2]|0,g=x8[j-2]|0,A=f.rotrSH(L,g,19)^f.rotrBH(L,g,61)^f.shrSH(L,g,6),B=f.rotrSL(L,g,19)^f.rotrBL(L,g,61)^f.shrSL(L,g,6),E=f.add4L(S,B,x8[j-7],x8[j-16]),c=f.add4H(E,C,A,k8[j-7],k8[j-16]);k8[j]=c|0,x8[j]=E|0}let{Ah:J,Al:X,Bh:q,Bl:G,Ch:W,Cl:V,Dh:$,Dl:U,Eh:Z,El:K,Fh:M,Fl:I,Gh:z,Gl:R,Hh:H,Hl:D}=this;for(let j=0;j<80;j++){const w=f.rotrSH(Z,K,14)^f.rotrSH(Z,K,18)^f.rotrBH(Z,K,41),P=f.rotrSL(Z,K,14)^f.rotrSL(Z,K,18)^f.rotrBL(Z,K,41),C=Z&M^~Z&z,S=K&I^~K&R,L=f.add5L(D,P,S,VG[j],x8[j]),g=f.add5H(L,H,w,C,WG[j],k8[j]),A=L|0,B=f.rotrSH(J,X,28)^f.rotrBH(J,X,34)^f.rotrBH(J,X,39),E=f.rotrSL(J,X,28)^f.rotrBL(J,X,34)^f.rotrBL(J,X,39),c=J&q^J&W^q&W,G0=X&G^X&V^G&V;H=z|0,D=R|0,z=M|0,R=I|0,M=Z|0,I=K|0,{h:Z,l:K}=f.add($|0,U|0,g|0,A|0),$=W|0,U=V|0,W=q|0,V=G|0,q=J|0,G=X|0;const p=f.add3L(A,E,G0);J=f.add3H(p,g,B,c),X=p|0}({h:J,l:X}=f.add(this.Ah|0,this.Al|0,J|0,X|0)),{h:q,l:G}=f.add(this.Bh|0,this.Bl|0,q|0,G|0),{h:W,l:V}=f.add(this.Ch|0,this.Cl|0,W|0,V|0),{h:$,l:U}=f.add(this.Dh|0,this.Dl|0,$|0,U|0),{h:Z,l:K}=f.add(this.Eh|0,this.El|0,Z|0,K|0),{h:M,l:I}=f.add(this.Fh|0,this.Fl|0,M|0,I|0),{h:z,l:R}=f.add(this.Gh|0,this.Gl|0,z|0,R|0),{h:H,l:D}=f.add(this.Hh|0,this.Hl|0,H|0,D|0),this.set(J,X,q,G,W,V,$,U,Z,K,M,I,z,R,H,D)}roundClean(){k8.fill(0),x8.fill(0)}destroy(){this.buffer.fill(0),this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}}var aQ=S8(()=>new nY);var UG=function(){if(typeof self!=="undefined")return self;if(typeof window!=="undefined")return window;if(typeof window!=="undefined")return window;throw new Error("unable to locate global object")};function q5(Q){switch(Q){case"sha256":return Z8.create();case"sha512":return aQ.create()}O(!1,"invalid hashing algorithm name","algorithm",Q)}function aY(Q,Y){const J={sha256:Z8,sha512:aQ}[Q];return O(J!=null,"invalid hmac algorithm","algorithm",Q),n8.create(J,Y)}function sY(Q,Y,J,X,q){const G={sha256:Z8,sha512:aQ}[q];return O(G!=null,"invalid pbkdf2 algorithm","algorithm",q),n9(G,Q,Y,{c:J,dkLen:X})}function tY(Q){x(rY!=null,"platform does not support secure random numbers","UNSUPPORTED_OPERATION",{operation:"randomBytes"}),O(Number.isInteger(Q)&&Q>0&&Q<=1024,"invalid length","length",Q);const Y=new Uint8Array(Q);return rY.getRandomValues(Y),Y}var oY=UG(),rY=oY.crypto||oY.msCrypto;function z8(Q,Y,J){const X=T(Y,"key"),q=T(J,"data");return N(JX(Q,X,q))}var eY=!1,QX=function(Q,Y,J){return aY(Q,Y).update(J).digest()},JX=QX;z8._=QX;z8.lock=function(){eY=!0};z8.register=function(Q){if(eY)throw new Error("computeHmac is locked");JX=Q};Object.freeze(z8);function RG(Q,Y=24){const J=new Uint32Array(10);for(let X=24-Y;X<24;X++){for(let W=0;W<10;W++)J[W]=Q[W]^Q[W+10]^Q[W+20]^Q[W+30]^Q[W+40];for(let W=0;W<10;W+=2){const V=(W+8)%10,$=(W+2)%10,U=J[$],Z=J[$+1],K=YX(U,Z,1)^J[V],M=XX(U,Z,1)^J[V+1];for(let I=0;I<50;I+=10)Q[W+I]^=K,Q[W+I+1]^=M}let q=Q[2],G=Q[3];for(let W=0;W<24;W++){const V=GX[W],$=YX(q,G,V),U=XX(q,G,V),Z=qX[W];q=Q[Z],G=Q[Z+1],Q[Z]=$,Q[Z+1]=U}for(let W=0;W<50;W+=10){for(let V=0;V<10;V++)J[V]=Q[W+V];for(let V=0;V<10;V++)Q[W+V]^=~J[(V+2)%10]&J[(V+4)%10]}Q[0]^=IG[X],Q[1]^=OG[X]}J.fill(0)}var[qX,GX,WX]=[[],[],[]],$G=BigInt(0),o9=BigInt(1),ZG=BigInt(2),zG=BigInt(7),KG=BigInt(256),MG=BigInt(113);for(let Q=0,Y=o9,J=1,X=0;Q<24;Q++){[J,X]=[X,(2*J+3*X)%5],qX.push(2*(5*X+J)),GX.push((Q+1)*(Q+2)/2%64);let q=$G;for(let G=0;G<7;G++)if(Y=(Y<<o9^(Y>>zG)*MG)%KG,Y&ZG)q^=o9<<(o9<<BigInt(G))-o9;WX.push(q)}var[IG,OG]=eJ(WX,!0),YX=(Q,Y,J)=>J>32?Y5(Q,Y,J):Q5(Q,Y,J),XX=(Q,Y,J)=>J>32?X5(Q,Y,J):J5(Q,Y,J);class G5 extends i8{constructor(Q,Y,J,X=!1,q=24){super();if(this.blockLen=Q,this.suffix=Y,this.outputLen=J,this.enableXOF=X,this.rounds=q,this.pos=0,this.posOut=0,this.finished=!1,this.destroyed=!1,P0(J),0>=this.blockLen||this.blockLen>=200)throw new Error("Sha3 supports only keccak-f1600 function");this.state=new Uint8Array(200),this.state32=C9(this.state)}keccak(){RG(this.state32,this.rounds),this.posOut=0,this.pos=0}update(Q){$8(this);const{blockLen:Y,state:J}=this;Q=t0(Q);const X=Q.length;for(let q=0;q<X;){const G=Math.min(Y-this.pos,X-q);for(let W=0;W<G;W++)J[this.pos++]^=Q[q++];if(this.pos===Y)this.keccak()}return this}finish(){if(this.finished)return;this.finished=!0;const{state:Q,suffix:Y,pos:J,blockLen:X}=this;if(Q[J]^=Y,(Y&128)!==0&&J===X-1)this.keccak();Q[X-1]^=128,this.keccak()}writeInto(Q){$8(this,!1),i9(Q),this.finish();const Y=this.state,{blockLen:J}=this;for(let X=0,q=Q.length;X<q;){if(this.posOut>=J)this.keccak();const G=Math.min(J-this.posOut,q-X);Q.set(Y.subarray(this.posOut,this.posOut+G),X),this.posOut+=G,X+=G}return Q}xofInto(Q){if(!this.enableXOF)throw new Error("XOF is not possible for this instance");return this.writeInto(Q)}xof(Q){return P0(Q),this.xofInto(new Uint8Array(Q))}digestInto(Q){if(lQ(Q,this),this.finished)throw new Error("digest() was already called");return this.writeInto(Q),this.destroy(),Q}digest(){return this.digestInto(new Uint8Array(this.outputLen))}destroy(){this.destroyed=!0,this.state.fill(0)}_cloneInto(Q){const{blockLen:Y,suffix:J,outputLen:X,rounds:q,enableXOF:G}=this;return Q||(Q=new G5(Y,J,X,G,q)),Q.state32.set(this.state32),Q.pos=this.pos,Q.posOut=this.posOut,Q.finished=this.finished,Q.rounds=q,Q.suffix=J,Q.outputLen=X,Q.enableXOF=G,Q.destroyed=this.destroyed,Q}}var HG=(Q,Y,J)=>S8(()=>new G5(Y,Q,J));var VX=HG(1,136,32);function i(Q){const Y=T(Q,"data");return N(ZX(Y))}var UX=!1,$X=function(Q){return VX(Q)},ZX=$X;i._=$X;i.lock=function(){UX=!0};i.register=function(Q){if(UX)throw new TypeError("keccak256 is locked");ZX=Q};Object.freeze(i);var zX=function(Q,Y,J,X){if(Q===0)return Y^J^X;else if(Q===1)return Y&J|~Y&X;else if(Q===2)return(Y|~J)^X;else if(Q===3)return Y&X|J&~X;else return Y^(J|~X)},DG=new Uint8Array([7,4,13,1,10,6,15,3,12,0,9,5,2,14,11,8]),KX=Uint8Array.from({length:16},(Q,Y)=>Y),PG=KX.map((Q)=>(9*Q+5)%16),W5=[KX],V5=[PG];for(let Q=0;Q<4;Q++)for(let Y of[W5,V5])Y.push(Y[Q].map((J)=>DG[J]));var MX=[[11,14,15,12,5,8,7,9,11,13,14,15,6,7,9,8],[12,13,11,15,6,9,9,7,12,15,11,13,7,8,7,7],[13,15,14,11,7,7,6,8,13,14,13,12,5,5,6,9],[14,11,12,14,8,6,5,5,15,12,15,14,9,9,8,6],[15,12,13,13,9,5,8,6,14,11,12,11,8,6,5,5]].map((Q)=>new Uint8Array(Q)),jG=W5.map((Q,Y)=>Q.map((J)=>MX[Y][J])),LG=V5.map((Q,Y)=>Q.map((J)=>MX[Y][J])),CG=new Uint32Array([0,1518500249,1859775393,2400959708,2840853838]),NG=new Uint32Array([1352829926,1548603684,1836072691,2053994217,0]),sQ=(Q,Y)=>Q<<Y|Q>>>32-Y,tQ=new Uint32Array(16);class IX extends o8{constructor(){super(64,20,8,!0);this.h0=1732584193|0,this.h1=4023233417|0,this.h2=2562383102|0,this.h3=271733878|0,this.h4=3285377520|0}get(){const{h0:Q,h1:Y,h2:J,h3:X,h4:q}=this;return[Q,Y,J,X,q]}set(Q,Y,J,X,q){this.h0=Q|0,this.h1=Y|0,this.h2=J|0,this.h3=X|0,this.h4=q|0}process(Q,Y){for(let M=0;M<16;M++,Y+=4)tQ[M]=Q.getUint32(Y,!0);let J=this.h0|0,X=J,q=this.h1|0,G=q,W=this.h2|0,V=W,$=this.h3|0,U=$,Z=this.h4|0,K=Z;for(let M=0;M<5;M++){const I=4-M,z=CG[M],R=NG[M],H=W5[M],D=V5[M],j=jG[M],w=LG[M];for(let P=0;P<16;P++){const C=sQ(J+zX(M,q,W,$)+tQ[H[P]]+z,j[P])+Z|0;J=Z,Z=$,$=sQ(W,10)|0,W=q,q=C}for(let P=0;P<16;P++){const C=sQ(X+zX(I,G,V,U)+tQ[D[P]]+R,w[P])+K|0;X=K,K=U,U=sQ(V,10)|0,V=G,G=C}}this.set(this.h1+W+U|0,this.h2+$+K|0,this.h3+Z+X|0,this.h4+J+G|0,this.h0+q+V|0)}roundClean(){tQ.fill(0)}destroy(){this.destroyed=!0,this.buffer.fill(0),this.set(0,0,0,0,0)}}var OX=S8(()=>new IX);function K8(Q){const Y=T(Q,"data");return N(DX(Y))}var RX=!1,HX=function(Q){return OX(Q)},DX=HX;K8._=HX;K8.lock=function(){RX=!0};K8.register=function(Q){if(RX)throw new TypeError("ripemd160 is locked");DX=Q};Object.freeze(K8);function E0(Q,Y,J,X,q){const G=T(Q,"password"),W=T(Y,"salt");return N(LX(G,W,J,X,q))}var PX=!1,jX=function(Q,Y,J,X,q){return sY(Q,Y,J,X,q)},LX=jX;E0._=jX;E0.lock=function(){PX=!0};E0.register=function(Q){if(PX)throw new Error("pbkdf2 is locked");LX=Q};Object.freeze(E0);function V0(Q){return TX(Q)}var CX=!1,NX=function(Q){return new Uint8Array(tY(Q))},TX=NX;V0._=NX;V0.lock=function(){CX=!0};V0.register=function(Q){if(CX)throw new Error("randomBytes is locked");TX=Q};Object.freeze(V0);var FX=function(Q,Y,J,X,q,G){let W=Q[Y++]^J[X++],V=Q[Y++]^J[X++],$=Q[Y++]^J[X++],U=Q[Y++]^J[X++],Z=Q[Y++]^J[X++],K=Q[Y++]^J[X++],M=Q[Y++]^J[X++],I=Q[Y++]^J[X++],z=Q[Y++]^J[X++],R=Q[Y++]^J[X++],H=Q[Y++]^J[X++],D=Q[Y++]^J[X++],j=Q[Y++]^J[X++],w=Q[Y++]^J[X++],P=Q[Y++]^J[X++],C=Q[Y++]^J[X++],S=W,L=V,g=$,A=U,B=Z,E=K,c=M,G0=I,p=z,F=R,v=H,b=D,u=j,l=w,r=P,W0=C;for(let H0=0;H0<8;H0+=2)B^=d(S+u|0,7),p^=d(B+S|0,9),u^=d(p+B|0,13),S^=d(u+p|0,18),F^=d(E+L|0,7),l^=d(F+E|0,9),L^=d(l+F|0,13),E^=d(L+l|0,18),r^=d(v+c|0,7),g^=d(r+v|0,9),c^=d(g+r|0,13),v^=d(c+g|0,18),A^=d(W0+b|0,7),G0^=d(A+W0|0,9),b^=d(G0+A|0,13),W0^=d(b+G0|0,18),L^=d(S+A|0,7),g^=d(L+S|0,9),A^=d(g+L|0,13),S^=d(A+g|0,18),c^=d(E+B|0,7),G0^=d(c+E|0,9),B^=d(G0+c|0,13),E^=d(B+G0|0,18),b^=d(v+F|0,7),p^=d(b+v|0,9),F^=d(p+b|0,13),v^=d(F+p|0,18),u^=d(W0+r|0,7),l^=d(u+W0|0,9),r^=d(l+u|0,13),W0^=d(r+l|0,18);q[G++]=W+S|0,q[G++]=V+L|0,q[G++]=$+g|0,q[G++]=U+A|0,q[G++]=Z+B|0,q[G++]=K+E|0,q[G++]=M+c|0,q[G++]=I+G0|0,q[G++]=z+p|0,q[G++]=R+F|0,q[G++]=H+v|0,q[G++]=D+b|0,q[G++]=j+u|0,q[G++]=w+l|0,q[G++]=P+r|0,q[G++]=C+W0|0},T9=function(Q,Y,J,X,q){let G=X+0,W=X+16*q;for(let V=0;V<16;V++)J[W+V]=Q[Y+(2*q-1)*16+V];for(let V=0;V<q;V++,G+=16,Y+=16){if(FX(J,W,Q,Y,J,G),V>0)W+=16;FX(J,G,Q,Y+=16,J,W)}},wX=function(Q,Y,J){const X=oQ({dkLen:32,asyncTick:10,maxmem:1073742848},J),{N:q,r:G,p:W,dkLen:V,asyncTick:$,maxmem:U,onProgress:Z}=X;if(P0(q),P0(G),P0(W),P0(V),P0($),P0(U),Z!==void 0&&typeof Z!=="function")throw new Error("progressCb should be function");const K=128*G,M=K/4;if(q<=1||(q&q-1)!==0||q>=2**(K/8)||q>4294967296)throw new Error("Scrypt: N must be larger than 1, a power of 2, less than 2^(128 * r / 8) and less than 2^32");if(W<0||W>137438953440/K)throw new Error("Scrypt: p must be a positive integer less than or equal to ((2^32 - 1) * 32) / (128 * r)");if(V<0||V>137438953440)throw new Error("Scrypt: dkLen should be positive integer less than or equal to (2^32 - 1) * 32");const I=K*(q+W);if(I>U)throw new Error(`Scrypt: parameters too large, ${I} (128 * r * (N + p)) > ${U} (maxmem)`);const z=n9(Z8,Q,Y,{c:1,dkLen:K*W}),R=C9(z),H=C9(new Uint8Array(K*q)),D=C9(new Uint8Array(K));let j=()=>{};if(Z){const w=2*q*W,P=Math.max(Math.floor(w/1e4),1);let C=0;j=()=>{if(C++,Z&&(!(C%P)||C===w))Z(C/w)}}return{N:q,r:G,p:W,dkLen:V,blockSize32:M,V:H,B32:R,B:z,tmp:D,blockMixCb:j,asyncTick:$}},BX=function(Q,Y,J,X,q){const G=n9(Z8,Q,J,{c:1,dkLen:Y});return J.fill(0),X.fill(0),q.fill(0),G};function SX(Q,Y,J){const{N:X,r:q,p:G,dkLen:W,blockSize32:V,V:$,B32:U,B:Z,tmp:K,blockMixCb:M}=wX(Q,Y,J);for(let I=0;I<G;I++){const z=V*I;for(let R=0;R<V;R++)$[R]=U[z+R];for(let R=0,H=0;R<X-1;R++)T9($,H,$,H+=V,q),M();T9($,(X-1)*V,U,z,q),M();for(let R=0;R<X;R++){const H=U[z+V-16]%X;for(let D=0;D<V;D++)K[D]=U[z+D]^$[H*V+D];T9(K,0,U,z,q),M()}}return BX(Q,W,Z,$,K)}async function AX(Q,Y,J){const{N:X,r:q,p:G,dkLen:W,blockSize32:V,V:$,B32:U,B:Z,tmp:K,blockMixCb:M,asyncTick:I}=wX(Q,Y,J);for(let z=0;z<G;z++){const R=V*z;for(let D=0;D<V;D++)$[D]=U[R+D];let H=0;await nQ(X-1,I,()=>{T9($,H,$,H+=V,q),M()}),T9($,(X-1)*V,U,R,q),M(),await nQ(X,I,()=>{const D=U[R+V-16]%X;for(let j=0;j<V;j++)K[j]=U[R+j]^$[D*V+j];T9(K,0,U,R,q),M()})}return BX(Q,W,Z,$,K)}var d=(Q,Y)=>Q<<Y|Q>>>32-Y;async function M8(Q,Y,J,X,q,G,W){const V=T(Q,"passwd"),$=T(Y,"salt");return N(await vX(V,$,J,X,q,G,W))}function I8(Q,Y,J,X,q,G){const W=T(Q,"passwd"),V=T(Y,"salt");return N(fX(W,V,J,X,q,G))}var EX=!1,kX=!1,xX=async function(Q,Y,J,X,q,G,W){return await AX(Q,Y,{N:J,r:X,p:q,dkLen:G,onProgress:W})},gX=function(Q,Y,J,X,q,G){return SX(Q,Y,{N:J,r:X,p:q,dkLen:G})},vX=xX,fX=gX;M8._=xX;M8.lock=function(){kX=!0};M8.register=function(Q){if(kX)throw new Error("scrypt is locked");vX=Q};Object.freeze(M8);I8._=gX;I8.lock=function(){EX=!0};I8.register=function(Q){if(EX)throw new Error("scryptSync is locked");fX=Q};Object.freeze(I8);function I0(Q){const Y=T(Q,"data");return N(hX(Y))}function r9(Q){const Y=T(Q,"data");return N(mX(Y))}var bX=function(Q){return q5("sha256").update(Q).digest()},yX=function(Q){return q5("sha512").update(Q).digest()},hX=bX,mX=yX,_X=!1,cX=!1;I0._=bX;I0.lock=function(){_X=!0};I0.register=function(Q){if(_X)throw new Error("sha256 is locked");hX=Q};Object.freeze(I0);r9._=yX;r9.lock=function(){cX=!0};r9.register=function(Q){if(cX)throw new Error("sha512 is locked");mX=Q};Object.freeze(I0);var z5={};O7(z5,{validateObject:()=>{{return v8}},utf8ToBytes:()=>{{return SG}},numberToVarBytesBE:()=>{{return wG}},numberToHexUnpadded:()=>{{return dX}},numberToBytesLE:()=>{{return YJ}},numberToBytesBE:()=>{{return g8}},hexToNumber:()=>{{return $5}},hexToBytes:()=>{{return a8}},equalBytes:()=>{{return BG}},ensureBytes:()=>{{return k0}},createHmacDrbg:()=>{{return Z5}},concatBytes:()=>{{return F9}},bytesToNumberLE:()=>{{return JJ}},bytesToNumberBE:()=>{{return O8}},bytesToHex:()=>{{return r8}},bitSet:()=>{{return kG}},bitMask:()=>{{return a9}},bitLen:()=>{{return AG}},bitGet:()=>{{return EG}}});function r8(Q){if(!QJ(Q))throw new Error("Uint8Array expected");let Y="";for(let J=0;J<Q.length;J++)Y+=FG[Q[J]];return Y}function dX(Q){const Y=Q.toString(16);return Y.length&1?`0${Y}`:Y}function $5(Q){if(typeof Q!=="string")throw new Error("hex string expected, got "+typeof Q);return BigInt(Q===""?"0":`0x${Q}`)}function a8(Q){if(typeof Q!=="string")throw new Error("hex string expected, got "+typeof Q);const Y=Q.length;if(Y%2)throw new Error("padded hex string expected, got unpadded hex of length "+Y);const J=new Uint8Array(Y/2);for(let X=0;X<J.length;X++){const q=X*2,G=Q.slice(q,q+2),W=Number.parseInt(G,16);if(Number.isNaN(W)||W<0)throw new Error("Invalid byte sequence");J[X]=W}return J}function O8(Q){return $5(r8(Q))}function JJ(Q){if(!QJ(Q))throw new Error("Uint8Array expected");return $5(r8(Uint8Array.from(Q).reverse()))}function g8(Q,Y){return a8(Q.toString(16).padStart(Y*2,"0"))}function YJ(Q,Y){return g8(Q,Y).reverse()}function wG(Q){return a8(dX(Q))}function k0(Q,Y,J){let X;if(typeof Y==="string")try{X=a8(Y)}catch(G){throw new Error(`${Q} must be valid hex string, got "${Y}". Cause: ${G}`)}else if(QJ(Y))X=Uint8Array.from(Y);else throw new Error(`${Q} must be hex string or Uint8Array`);const q=X.length;if(typeof J==="number"&&q!==J)throw new Error(`${Q} expected ${J} bytes, got ${q}`);return X}function F9(...Q){const Y=new Uint8Array(Q.reduce((X,q)=>X+q.length,0));let J=0;return Q.forEach((X)=>{if(!QJ(X))throw new Error("Uint8Array expected");Y.set(X,J),J+=X.length}),Y}function BG(Q,Y){if(Q.length!==Y.length)return!1;for(let J=0;J<Q.length;J++)if(Q[J]!==Y[J])return!1;return!0}function SG(Q){if(typeof Q!=="string")throw new Error(`utf8ToBytes expected string, got ${typeof Q}`);return new Uint8Array((new TextEncoder()).encode(Q))}function AG(Q){let Y;for(Y=0;Q>uX;Q>>=eQ,Y+=1);return Y}function EG(Q,Y){return Q>>BigInt(Y)&eQ}function Z5(Q,Y,J){if(typeof Q!=="number"||Q<2)throw new Error("hashLen must be a number");if(typeof Y!=="number"||Y<2)throw new Error("qByteLen must be a number");if(typeof J!=="function")throw new Error("hmacFn must be a function");let X=U5(Q),q=U5(Q),G=0;const W=()=>{X.fill(1),q.fill(0),G=0},V=(...K)=>J(q,X,...K),$=(K=U5())=>{if(q=V(pX([0]),K),X=V(),K.length===0)return;q=V(pX([1]),K),X=V()},U=()=>{if(G++>=1000)throw new Error("drbg: tried 1000 values");let K=0;const M=[];while(K<Y){X=V();const I=X.slice();M.push(I),K+=X.length}return F9(...M)};return(K,M)=>{W(),$(K);let I=void 0;while(!(I=M(U())))$();return W(),I}}function v8(Q,Y,J={}){const X=(q,G,W)=>{const V=xG[G];if(typeof V!=="function")throw new Error(`Invalid validator "${G}", expected function`);const $=Q[q];if(W&&$===void 0)return;if(!V($,Q))throw new Error(`Invalid param ${String(q)}=${$} (${typeof $}), expected ${G}`)};for(let[q,G]of Object.entries(Y))X(q,G,!1);for(let[q,G]of Object.entries(J))X(q,G,!0);return Q}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */var uX=BigInt(0),eQ=BigInt(1),TG=BigInt(2),QJ=(Q)=>Q instanceof Uint8Array,FG=Array.from({length:256},(Q,Y)=>Y.toString(16).padStart(2,"0")),kG=(Q,Y,J)=>{return Q|(J?eQ:uX)<<BigInt(Y)},a9=(Q)=>(TG<<BigInt(Q-1))-eQ,U5=(Q)=>new Uint8Array(Q),pX=(Q)=>Uint8Array.from(Q),xG={bigint:(Q)=>typeof Q==="bigint",function:(Q)=>typeof Q==="function",boolean:(Q)=>typeof Q==="boolean",string:(Q)=>typeof Q==="string",stringOrUint8Array:(Q)=>typeof Q==="string"||Q instanceof Uint8Array,isSafeInteger:(Q)=>Number.isSafeInteger(Q),array:(Q)=>Array.isArray(Q),field:(Q,Y)=>Y.Fp.isValid(Q),hash:(Q)=>typeof Q==="function"&&Number.isSafeInteger(Q.outputLen)};function j0(Q,Y){const J=Q%Y;return J>=U0?J:Y+J}function bG(Q,Y,J){if(J<=U0||Y<U0)throw new Error("Expected power/modulo > 0");if(J===X0)return U0;let X=X0;while(Y>U0){if(Y&X0)X=X*Q%J;Q=Q*Q%J,Y>>=X0}return X}function x0(Q,Y,J){let X=Q;while(Y-- >U0)X*=X,X%=J;return X}function XJ(Q,Y){if(Q===U0||Y<=U0)throw new Error(`invert: expected positive integers, got n=${Q} mod=${Y}`);let J=j0(Q,Y),X=Y,q=U0,G=X0,W=X0,V=U0;while(J!==U0){const U=X/J,Z=X%J,K=q-W*U,M=G-V*U;X=J,J=Z,q=W,G=V,W=K,V=M}if(X!==X0)throw new Error("invert: does not exist");return j0(q,Y)}function yG(Q){const Y=(Q-X0)/s8;let J,X,q;for(J=Q-X0,X=0;J%s8===U0;J/=s8,X++);for(q=s8;q<Q&&bG(q,Y,Q)!==Q-X0;q++);if(X===1){const W=(Q+X0)/K5;return function V($,U){const Z=$.pow(U,W);if(!$.eql($.sqr(Z),U))throw new Error("Cannot find square root");return Z}}const G=(J+X0)/s8;return function W(V,$){if(V.pow($,Y)===V.neg(V.ONE))throw new Error("Cannot find square root");let U=X,Z=V.pow(V.mul(V.ONE,q),J),K=V.pow($,G),M=V.pow($,J);while(!V.eql(M,V.ONE)){if(V.eql(M,V.ZERO))return V.ZERO;let I=1;for(let R=V.sqr(M);I<U;I++){if(V.eql(R,V.ONE))break;R=V.sqr(R)}const z=V.pow(Z,X0<<BigInt(U-I-1));Z=V.sqr(z),K=V.mul(K,z),M=V.mul(M,Z),U=I}return K}}function hG(Q){if(Q%K5===gG){const Y=(Q+X0)/K5;return function J(X,q){const G=X.pow(q,Y);if(!X.eql(X.sqr(G),q))throw new Error("Cannot find square root");return G}}if(Q%iX===lX){const Y=(Q-lX)/iX;return function J(X,q){const G=X.mul(q,s8),W=X.pow(G,Y),V=X.mul(q,W),$=X.mul(X.mul(V,s8),W),U=X.mul(V,X.sub($,X.ONE));if(!X.eql(X.sqr(U),q))throw new Error("Cannot find square root");return U}}if(Q%fG===vG);return yG(Q)}function M5(Q){const Y={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},J=mG.reduce((X,q)=>{return X[q]="function",X},Y);return v8(Q,J)}function _G(Q,Y,J){if(J<U0)throw new Error("Expected power > 0");if(J===U0)return Q.ONE;if(J===X0)return Y;let X=Q.ONE,q=Y;while(J>U0){if(J&X0)X=Q.mul(X,q);q=Q.sqr(q),J>>=X0}return X}function cG(Q,Y){const J=new Array(Y.length),X=Y.reduce((G,W,V)=>{if(Q.is0(W))return G;return J[V]=G,Q.mul(G,W)},Q.ONE),q=Q.inv(X);return Y.reduceRight((G,W,V)=>{if(Q.is0(W))return G;return J[V]=Q.mul(G,J[V]),Q.mul(G,W)},q),J}function I5(Q,Y){const J=Y!==void 0?Y:Q.toString(2).length,X=Math.ceil(J/8);return{nBitLength:J,nByteLength:X}}function nX(Q,Y,J=!1,X={}){if(Q<=U0)throw new Error(`Expected Field ORDER > 0, got ${Q}`);const{nBitLength:q,nByteLength:G}=I5(Q,Y);if(G>2048)throw new Error("Field lengths over 2048 bytes are not supported");const W=hG(Q),V=Object.freeze({ORDER:Q,BITS:q,BYTES:G,MASK:a9(q),ZERO:U0,ONE:X0,create:($)=>j0($,Q),isValid:($)=>{if(typeof $!=="bigint")throw new Error(`Invalid field element: expected bigint, got ${typeof $}`);return U0<=$&&$<Q},is0:($)=>$===U0,isOdd:($)=>($&X0)===X0,neg:($)=>j0(-$,Q),eql:($,U)=>$===U,sqr:($)=>j0($*$,Q),add:($,U)=>j0($+U,Q),sub:($,U)=>j0($-U,Q),mul:($,U)=>j0($*U,Q),pow:($,U)=>_G(V,$,U),div:($,U)=>j0($*XJ(U,Q),Q),sqrN:($)=>$*$,addN:($,U)=>$+U,subN:($,U)=>$-U,mulN:($,U)=>$*U,inv:($)=>XJ($,Q),sqrt:X.sqrt||(($)=>W(V,$)),invertBatch:($)=>cG(V,$),cmov:($,U,Z)=>Z?U:$,toBytes:($)=>J?YJ($,G):g8($,G),fromBytes:($)=>{if($.length!==G)throw new Error(`Fp.fromBytes: expected ${G}, got ${$.length}`);return J?JJ($):O8($)}});return Object.freeze(V)}function oX(Q){if(typeof Q!=="bigint")throw new Error("field order must be bigint");const Y=Q.toString(2).length;return Math.ceil(Y/8)}function O5(Q){const Y=oX(Q);return Y+Math.ceil(Y/2)}function rX(Q,Y,J=!1){const X=Q.length,q=oX(Y),G=O5(Y);if(X<16||X<G||X>1024)throw new Error(`expected ${G}-1024 bytes of input, got ${X}`);const W=J?O8(Q):JJ(Q),V=j0(W,Y-X0)+X0;return J?YJ(V,q):g8(V,q)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */var U0=BigInt(0),X0=BigInt(1),s8=BigInt(2),gG=BigInt(3),K5=BigInt(4),lX=BigInt(5),iX=BigInt(8),vG=BigInt(9),fG=BigInt(16);var mG=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function aX(Q,Y){const J=(q,G)=>{const W=G.negate();return q?W:G},X=(q)=>{const G=Math.ceil(Y/q)+1,W=2**(q-1);return{windows:G,windowSize:W}};return{constTimeNegate:J,unsafeLadder(q,G){let W=Q.ZERO,V=q;while(G>uG){if(G&R5)W=W.add(V);V=V.double(),G>>=R5}return W},precomputeWindow(q,G){const{windows:W,windowSize:V}=X(G),$=[];let U=q,Z=U;for(let K=0;K<W;K++){Z=U,$.push(Z);for(let M=1;M<V;M++)Z=Z.add(U),$.push(Z);U=Z.double()}return $},wNAF(q,G,W){const{windows:V,windowSize:$}=X(q);let{ZERO:U,BASE:Z}=Q;const K=BigInt(2**q-1),M=2**q,I=BigInt(q);for(let z=0;z<V;z++){const R=z*$;let H=Number(W&K);if(W>>=I,H>$)H-=M,W+=R5;const D=R,j=R+Math.abs(H)-1,w=z%2!==0,P=H<0;if(H===0)Z=Z.add(J(w,G[D]));else U=U.add(J(P,G[j]))}return{p:U,f:Z}},wNAFCached(q,G,W,V){const $=q._WINDOW_SIZE||1;let U=G.get(q);if(!U){if(U=this.precomputeWindow(q,$),$!==1)G.set(q,V(U))}return this.wNAF($,U,W)}}}function H5(Q){return M5(Q.Fp),v8(Q,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...I5(Q.n,Q.nBitLength),...Q,...{p:Q.Fp.ORDER}})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */var uG=BigInt(0),R5=BigInt(1);var dG=function(Q){const Y=H5(Q);v8(Y,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});const{endo:J,Fp:X,a:q}=Y;if(J){if(!X.eql(q,X.ZERO))throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");if(typeof J!=="object"||typeof J.beta!=="bigint"||typeof J.splitScalar!=="function")throw new Error("Expected endomorphism with beta: bigint and splitScalar: function")}return Object.freeze({...Y})};function nG(Q){const Y=dG(Q),{Fp:J}=Y,X=Y.toBytes||((z,R,H)=>{const D=R.toAffine();return F9(Uint8Array.from([4]),J.toBytes(D.x),J.toBytes(D.y))}),q=Y.fromBytes||((z)=>{const R=z.subarray(1),H=J.fromBytes(R.subarray(0,J.BYTES)),D=J.fromBytes(R.subarray(J.BYTES,2*J.BYTES));return{x:H,y:D}});function G(z){const{a:R,b:H}=Y,D=J.sqr(z),j=J.mul(D,z);return J.add(J.add(j,J.mul(z,R)),H)}if(!J.eql(J.sqr(Y.Gy),G(Y.Gx)))throw new Error("bad generator point: equation left != right");function W(z){return typeof z==="bigint"&&R8<z&&z<Y.n}function V(z){if(!W(z))throw new Error("Expected valid bigint: 0 < bigint < curve.n")}function $(z){const{allowedPrivateKeyLengths:R,nByteLength:H,wrapPrivateKey:D,n:j}=Y;if(R&&typeof z!=="bigint"){if(z instanceof Uint8Array)z=r8(z);if(typeof z!=="string"||!R.includes(z.length))throw new Error("Invalid key");z=z.padStart(H*2,"0")}let w;try{w=typeof z==="bigint"?z:O8(k0("private key",z,H))}catch(P){throw new Error(`private key must be ${H} bytes, hex or bigint, not ${typeof z}`)}if(D)w=j0(w,j);return V(w),w}const U=new Map;function Z(z){if(!(z instanceof K))throw new Error("ProjectivePoint expected")}class K{constructor(z,R,H){if(this.px=z,this.py=R,this.pz=H,z==null||!J.isValid(z))throw new Error("x required");if(R==null||!J.isValid(R))throw new Error("y required");if(H==null||!J.isValid(H))throw new Error("z required")}static fromAffine(z){const{x:R,y:H}=z||{};if(!z||!J.isValid(R)||!J.isValid(H))throw new Error("invalid affine point");if(z instanceof K)throw new Error("projective point not allowed");const D=(j)=>J.eql(j,J.ZERO);if(D(R)&&D(H))return K.ZERO;return new K(R,H,J.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(z){const R=J.invertBatch(z.map((H)=>H.pz));return z.map((H,D)=>H.toAffine(R[D])).map(K.fromAffine)}static fromHex(z){const R=K.fromAffine(q(k0("pointHex",z)));return R.assertValidity(),R}static fromPrivateKey(z){return K.BASE.multiply($(z))}_setWindowSize(z){this._WINDOW_SIZE=z,U.delete(this)}assertValidity(){if(this.is0()){if(Y.allowInfinityPoint&&!J.is0(this.py))return;throw new Error("bad point: ZERO")}const{x:z,y:R}=this.toAffine();if(!J.isValid(z)||!J.isValid(R))throw new Error("bad point: x or y not FE");const H=J.sqr(R),D=G(z);if(!J.eql(H,D))throw new Error("bad point: equation left != right");if(!this.isTorsionFree())throw new Error("bad point: not in prime-order subgroup")}hasEvenY(){const{y:z}=this.toAffine();if(J.isOdd)return!J.isOdd(z);throw new Error("Field doesn't support isOdd")}equals(z){Z(z);const{px:R,py:H,pz:D}=this,{px:j,py:w,pz:P}=z,C=J.eql(J.mul(R,P),J.mul(j,D)),S=J.eql(J.mul(H,P),J.mul(w,D));return C&&S}negate(){return new K(this.px,J.neg(this.py),this.pz)}double(){const{a:z,b:R}=Y,H=J.mul(R,sX),{px:D,py:j,pz:w}=this;let{ZERO:P,ZERO:C,ZERO:S}=J,L=J.mul(D,D),g=J.mul(j,j),A=J.mul(w,w),B=J.mul(D,j);return B=J.add(B,B),S=J.mul(D,w),S=J.add(S,S),P=J.mul(z,S),C=J.mul(H,A),C=J.add(P,C),P=J.sub(g,C),C=J.add(g,C),C=J.mul(P,C),P=J.mul(B,P),S=J.mul(H,S),A=J.mul(z,A),B=J.sub(L,A),B=J.mul(z,B),B=J.add(B,S),S=J.add(L,L),L=J.add(S,L),L=J.add(L,A),L=J.mul(L,B),C=J.add(C,L),A=J.mul(j,w),A=J.add(A,A),L=J.mul(A,B),P=J.sub(P,L),S=J.mul(A,g),S=J.add(S,S),S=J.add(S,S),new K(P,C,S)}add(z){Z(z);const{px:R,py:H,pz:D}=this,{px:j,py:w,pz:P}=z;let{ZERO:C,ZERO:S,ZERO:L}=J;const g=Y.a,A=J.mul(Y.b,sX);let B=J.mul(R,j),E=J.mul(H,w),c=J.mul(D,P),G0=J.add(R,H),p=J.add(j,w);G0=J.mul(G0,p),p=J.add(B,E),G0=J.sub(G0,p),p=J.add(R,D);let F=J.add(j,P);return p=J.mul(p,F),F=J.add(B,c),p=J.sub(p,F),F=J.add(H,D),C=J.add(w,P),F=J.mul(F,C),C=J.add(E,c),F=J.sub(F,C),L=J.mul(g,p),C=J.mul(A,c),L=J.add(C,L),C=J.sub(E,L),L=J.add(E,L),S=J.mul(C,L),E=J.add(B,B),E=J.add(E,B),c=J.mul(g,c),p=J.mul(A,p),E=J.add(E,c),c=J.sub(B,c),c=J.mul(g,c),p=J.add(p,c),B=J.mul(E,p),S=J.add(S,B),B=J.mul(F,p),C=J.mul(G0,C),C=J.sub(C,B),B=J.mul(G0,E),L=J.mul(F,L),L=J.add(L,B),new K(C,S,L)}subtract(z){return this.add(z.negate())}is0(){return this.equals(K.ZERO)}wNAF(z){return I.wNAFCached(this,U,z,(R)=>{const H=J.invertBatch(R.map((D)=>D.pz));return R.map((D,j)=>D.toAffine(H[j])).map(K.fromAffine)})}multiplyUnsafe(z){const R=K.ZERO;if(z===R8)return R;if(V(z),z===b0)return this;const{endo:H}=Y;if(!H)return I.unsafeLadder(this,z);let{k1neg:D,k1:j,k2neg:w,k2:P}=H.splitScalar(z),C=R,S=R,L=this;while(j>R8||P>R8){if(j&b0)C=C.add(L);if(P&b0)S=S.add(L);L=L.double(),j>>=b0,P>>=b0}if(D)C=C.negate();if(w)S=S.negate();return S=new K(J.mul(S.px,H.beta),S.py,S.pz),C.add(S)}multiply(z){V(z);let R=z,H,D;const{endo:j}=Y;if(j){const{k1neg:w,k1:P,k2neg:C,k2:S}=j.splitScalar(R);let{p:L,f:g}=this.wNAF(P),{p:A,f:B}=this.wNAF(S);L=I.constTimeNegate(w,L),A=I.constTimeNegate(C,A),A=new K(J.mul(A.px,j.beta),A.py,A.pz),H=L.add(A),D=g.add(B)}else{const{p:w,f:P}=this.wNAF(R);H=w,D=P}return K.normalizeZ([H,D])[0]}multiplyAndAddUnsafe(z,R,H){const D=K.BASE,j=(P,C)=>C===R8||C===b0||!P.equals(D)?P.multiplyUnsafe(C):P.multiply(C),w=j(this,R).add(j(z,H));return w.is0()?void 0:w}toAffine(z){const{px:R,py:H,pz:D}=this,j=this.is0();if(z==null)z=j?J.ONE:J.inv(D);const w=J.mul(R,z),P=J.mul(H,z),C=J.mul(D,z);if(j)return{x:J.ZERO,y:J.ZERO};if(!J.eql(C,J.ONE))throw new Error("invZ was invalid");return{x:w,y:P}}isTorsionFree(){const{h:z,isTorsionFree:R}=Y;if(z===b0)return!0;if(R)return R(K,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:z,clearCofactor:R}=Y;if(z===b0)return this;if(R)return R(K,this);return this.multiplyUnsafe(Y.h)}toRawBytes(z=!0){return this.assertValidity(),X(K,this,z)}toHex(z=!0){return r8(this.toRawBytes(z))}}K.BASE=new K(Y.Gx,Y.Gy,J.ONE),K.ZERO=new K(J.ZERO,J.ONE,J.ZERO);const M=Y.nBitLength,I=aX(K,Y.endo?Math.ceil(M/2):M);return{CURVE:Y,ProjectivePoint:K,normPrivateKeyToScalar:$,weierstrassEquation:G,isWithinCurveOrder:W}}var oG=function(Q){const Y=H5(Q);return v8(Y,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...Y})};function tX(Q){const Y=oG(Q),{Fp:J,n:X}=Y,q=J.BYTES+1,G=2*J.BYTES+1;function W(F){return R8<F&&F<J.ORDER}function V(F){return j0(F,X)}function $(F){return XJ(F,X)}const{ProjectivePoint:U,normPrivateKeyToScalar:Z,weierstrassEquation:K,isWithinCurveOrder:M}=nG({...Y,toBytes(F,v,b){const u=v.toAffine(),l=J.toBytes(u.x),r=F9;if(b)return r(Uint8Array.from([v.hasEvenY()?2:3]),l);else return r(Uint8Array.from([4]),l,J.toBytes(u.y))},fromBytes(F){const v=F.length,b=F[0],u=F.subarray(1);if(v===q&&(b===2||b===3)){const l=O8(u);if(!W(l))throw new Error("Point is not on curve");const r=K(l);let W0=J.sqrt(r);const H0=(W0&b0)===b0;if((b&1)===1!==H0)W0=J.neg(W0);return{x:l,y:W0}}else if(v===G&&b===4){const l=J.fromBytes(u.subarray(0,J.BYTES)),r=J.fromBytes(u.subarray(J.BYTES,2*J.BYTES));return{x:l,y:r}}else throw new Error(`Point of length ${v} was invalid. Expected ${q} compressed bytes or ${G} uncompressed bytes`)}}),I=(F)=>r8(g8(F,Y.nByteLength));function z(F){const v=X>>b0;return F>v}function R(F){return z(F)?V(-F):F}const H=(F,v,b)=>O8(F.slice(v,b));class D{constructor(F,v,b){this.r=F,this.s=v,this.recovery=b,this.assertValidity()}static fromCompact(F){const v=Y.nByteLength;return F=k0("compactSignature",F,v*2),new D(H(F,0,v),H(F,v,2*v))}static fromDER(F){const{r:v,s:b}=t8.toSig(k0("DER",F));return new D(v,b)}assertValidity(){if(!M(this.r))throw new Error("r must be 0 < r < CURVE.n");if(!M(this.s))throw new Error("s must be 0 < s < CURVE.n")}addRecoveryBit(F){return new D(this.r,this.s,F)}recoverPublicKey(F){const{r:v,s:b,recovery:u}=this,l=L(k0("msgHash",F));if(u==null||![0,1,2,3].includes(u))throw new Error("recovery id invalid");const r=u===2||u===3?v+Y.n:v;if(r>=J.ORDER)throw new Error("recovery id 2 or 3 invalid");const W0=(u&1)===0?"02":"03",H0=U.fromHex(W0+I(r)),W8=$(r),p8=V(-l*W8),I9=V(b*W8),u8=U.BASE.multiplyAndAddUnsafe(H0,p8,I9);if(!u8)throw new Error("point at infinify");return u8.assertValidity(),u8}hasHighS(){return z(this.s)}normalizeS(){return this.hasHighS()?new D(this.r,V(-this.s),this.recovery):this}toDERRawBytes(){return a8(this.toDERHex())}toDERHex(){return t8.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return a8(this.toCompactHex())}toCompactHex(){return I(this.r)+I(this.s)}}const j={isValidPrivateKey(F){try{return Z(F),!0}catch(v){return!1}},normPrivateKeyToScalar:Z,randomPrivateKey:()=>{const F=O5(Y.n);return rX(Y.randomBytes(F),Y.n)},precompute(F=8,v=U.BASE){return v._setWindowSize(F),v.multiply(BigInt(3)),v}};function w(F,v=!0){return U.fromPrivateKey(F).toRawBytes(v)}function P(F){const v=F instanceof Uint8Array,b=typeof F==="string",u=(v||b)&&F.length;if(v)return u===q||u===G;if(b)return u===2*q||u===2*G;if(F instanceof U)return!0;return!1}function C(F,v,b=!0){if(P(F))throw new Error("first arg must be private key");if(!P(v))throw new Error("second arg must be public key");return U.fromHex(v).multiply(Z(F)).toRawBytes(b)}const S=Y.bits2int||function(F){const v=O8(F),b=F.length*8-Y.nBitLength;return b>0?v>>BigInt(b):v},L=Y.bits2int_modN||function(F){return V(S(F))},g=a9(Y.nBitLength);function A(F){if(typeof F!=="bigint")throw new Error("bigint expected");if(!(R8<=F&&F<g))throw new Error(`bigint expected < 2^${Y.nBitLength}`);return g8(F,Y.nByteLength)}function B(F,v,b=E){if(["recovered","canonical"].some((d8)=>(d8 in b)))throw new Error("sign() legacy options not supported");const{hash:u,randomBytes:l}=Y;let{lowS:r,prehash:W0,extraEntropy:H0}=b;if(r==null)r=!0;if(F=k0("msgHash",F),W0)F=k0("prehashed msgHash",u(F));const W8=L(F),p8=Z(v),I9=[A(p8),A(W8)];if(H0!=null){const d8=H0===!0?l(J.BYTES):H0;I9.push(k0("extraEntropy",d8))}const u8=F9(...I9),kQ=W8;function nJ(d8){const O9=S(d8);if(!M(O9))return;const AY=$(O9),r0=U.BASE.multiply(O9).toAffine(),R9=V(r0.x);if(R9===R8)return;const xQ=V(AY*V(kQ+R9*p8));if(xQ===R8)return;let EY=(r0.x===R9?0:2)|Number(r0.y&b0),kY=xQ;if(r&&z(xQ))kY=R(xQ),EY^=1;return new D(R9,kY,EY)}return{seed:u8,k2sig:nJ}}const E={lowS:Y.lowS,prehash:!1},c={lowS:Y.lowS,prehash:!1};function G0(F,v,b=E){const{seed:u,k2sig:l}=B(F,v,b),r=Y;return Z5(r.hash.outputLen,r.nByteLength,r.hmac)(u,l)}U.BASE._setWindowSize(8);function p(F,v,b,u=c){const l=F;if(v=k0("msgHash",v),b=k0("publicKey",b),("strict"in u))throw new Error("options.strict was renamed to lowS");const{lowS:r,prehash:W0}=u;let H0=void 0,W8;try{if(typeof l==="string"||l instanceof Uint8Array)try{H0=D.fromDER(l)}catch(r0){if(!(r0 instanceof t8.Err))throw r0;H0=D.fromCompact(l)}else if(typeof l==="object"&&typeof l.r==="bigint"&&typeof l.s==="bigint"){const{r:r0,s:R9}=l;H0=new D(r0,R9)}else throw new Error("PARSE");W8=U.fromHex(b)}catch(r0){if(r0.message==="PARSE")throw new Error("signature must be Signature instance, Uint8Array or hex string");return!1}if(r&&H0.hasHighS())return!1;if(W0)v=Y.hash(v);const{r:p8,s:I9}=H0,u8=L(v),kQ=$(I9),nJ=V(u8*kQ),d8=V(p8*kQ),O9=U.BASE.multiplyAndAddUnsafe(W8,nJ,d8)?.toAffine();if(!O9)return!1;return V(O9.x)===p8}return{CURVE:Y,getPublicKey:w,getSharedSecret:C,sign:G0,verify:p,ProjectivePoint:U,Signature:D,utils:j}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */var{bytesToNumberBE:lG,hexToBytes:iG}=z5,t8={Err:class Q extends Error{constructor(Y=""){super(Y)}},_parseInt(Q){const{Err:Y}=t8;if(Q.length<2||Q[0]!==2)throw new Y("Invalid signature integer tag");const J=Q[1],X=Q.subarray(2,J+2);if(!J||X.length!==J)throw new Y("Invalid signature integer: wrong length");if(X[0]&128)throw new Y("Invalid signature integer: negative");if(X[0]===0&&!(X[1]&128))throw new Y("Invalid signature integer: unnecessary leading zero");return{d:lG(X),l:Q.subarray(J+2)}},toSig(Q){const{Err:Y}=t8,J=typeof Q==="string"?iG(Q):Q;if(!(J instanceof Uint8Array))throw new Error("ui8a expected");let X=J.length;if(X<2||J[0]!=48)throw new Y("Invalid signature tag");if(J[1]!==X-2)throw new Y("Invalid signature: incorrect length");const{d:q,l:G}=t8._parseInt(J.subarray(2)),{d:W,l:V}=t8._parseInt(G);if(V.length)throw new Y("Invalid signature: left bytes after parsing");return{r:q,s:W}},hexFromSig(Q){const Y=(U)=>Number.parseInt(U[0],16)&8?"00"+U:U,J=(U)=>{const Z=U.toString(16);return Z.length&1?`0${Z}`:Z},X=Y(J(Q.s)),q=Y(J(Q.r)),G=X.length/2,W=q.length/2,V=J(G),$=J(W);return`30${J(W+G+4)}02${$}${q}02${V}${X}`}},R8=BigInt(0),b0=BigInt(1),CZ=BigInt(2),sX=BigInt(3),NZ=BigInt(4);function rG(Q){return{hash:Q,hmac:(Y,...J)=>n8(Q,Y,uY(...J)),randomBytes:dY}}function eX(Q,Y){const J=(X)=>tX({...Q,...rG(X)});return Object.freeze({...J(Y),create:J})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */var sG=function(Q){const Y=Yq,J=BigInt(3),X=BigInt(6),q=BigInt(11),G=BigInt(22),W=BigInt(23),V=BigInt(44),$=BigInt(88),U=Q*Q*Q%Y,Z=U*U*Q%Y,K=x0(Z,J,Y)*Z%Y,M=x0(K,J,Y)*Z%Y,I=x0(M,D5,Y)*U%Y,z=x0(I,q,Y)*I%Y,R=x0(z,G,Y)*z%Y,H=x0(R,V,Y)*R%Y,D=x0(H,$,Y)*H%Y,j=x0(D,V,Y)*R%Y,w=x0(j,J,Y)*Z%Y,P=x0(w,W,Y)*z%Y,C=x0(P,X,Y)*U%Y,S=x0(C,D5,Y);if(!P5.eql(P5.sqr(S),Q))throw new Error("Cannot find square root");return S};/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */var Yq=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),Qq=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),aG=BigInt(1),D5=BigInt(2),Jq=(Q,Y)=>(Q+Y/D5)/Y,P5=nX(Yq,void 0,void 0,{sqrt:sG}),H8=eX({a:BigInt(0),b:BigInt(7),Fp:P5,n:Qq,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:(Q)=>{const Y=Qq,J=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),X=-aG*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),q=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),G=J,W=BigInt("0x100000000000000000000000000000000"),V=Jq(G*Q,Y),$=Jq(-X*Q,Y);let U=j0(Q-V*J-$*q,Y),Z=j0(-V*X-$*G,Y);const K=U>W,M=Z>W;if(K)U=Y-U;if(M)Z=Y-Z;if(U>W||Z>W)throw new Error("splitScalar: Endomorphism failed, k="+Q);return{k1neg:K,k1:U,k2neg:M,k2:Z}}}},Z8),xZ=BigInt(0);var gZ=H8.ProjectivePoint;var j5="0x0000000000000000000000000000000000000000";var qJ="0x0000000000000000000000000000000000000000000000000000000000000000";var L5=`\x19Ethereum Signed Message:
`;var Uq=function(Q){return A0(t(Q),32)},Xq=BigInt(0),qq=BigInt(1),Gq=BigInt(2),Wq=BigInt(27),Vq=BigInt(28),GJ=BigInt(35),w9={};class e{#Q;#J;#Y;#X;get r(){return this.#Q}set r(Q){O(U8(Q)===32,"invalid r","value",Q),this.#Q=N(Q)}get s(){return O(parseInt(this.#J.substring(0,3))<8,"non-canonical s; use ._s","s",this.#J),this.#J}set s(Q){O(U8(Q)===32,"invalid s","value",Q),this.#J=N(Q)}get _s(){return this.#J}isValid(){return parseInt(this.#J.substring(0,3))<8}get v(){return this.#Y}set v(Q){const Y=$0(Q,"value");O(Y===27||Y===28,"invalid v","v",Q),this.#Y=Y}get networkV(){return this.#X}get legacyChainId(){const Q=this.networkV;if(Q==null)return null;return e.getChainId(Q)}get yParity(){return this.v===27?0:1}get yParityAndS(){const Q=T(this.s);if(this.yParity)Q[0]|=128;return N(Q)}get compactSerialized(){return o([this.r,this.yParityAndS])}get serialized(){return o([this.r,this.s,this.yParity?"0x1c":"0x1b"])}constructor(Q,Y,J,X){V8(Q,w9,"Signature"),this.#Q=Y,this.#J=J,this.#Y=X,this.#X=null}[Symbol.for("nodejs.util.inspect.custom")](){return`Signature { r: "${this.r}", s: "${this._s}"${this.isValid()?"":', valid: "false"'}, yParity: ${this.yParity}, networkV: ${this.networkV} }`}clone(){const Q=new e(w9,this.r,this._s,this.v);if(this.networkV)Q.#X=this.networkV;return Q}toJSON(){const Q=this.networkV;return{_type:"signature",networkV:Q!=null?Q.toString():null,r:this.r,s:this._s,v:this.v}}static getChainId(Q){const Y=h(Q,"v");if(Y==Wq||Y==Vq)return Xq;return O(Y>=GJ,"invalid EIP-155 v","v",Q),(Y-GJ)/Gq}static getChainIdV(Q,Y){return h(Q)*Gq+BigInt(35+Y-27)}static getNormalizedV(Q){const Y=h(Q);if(Y===Xq||Y===Wq)return 27;if(Y===qq||Y===Vq)return 28;return O(Y>=GJ,"invalid v","v",Q),Y&qq?27:28}static from(Q){function Y($,U){O($,U,"signature",Q)}if(Q==null)return new e(w9,qJ,qJ,27);if(typeof Q==="string"){const $=T(Q,"signature");if($.length===64){const U=N($.slice(0,32)),Z=$.slice(32,64),K=Z[0]&128?28:27;return Z[0]&=127,new e(w9,U,N(Z),K)}if($.length===65){const U=N($.slice(0,32)),Z=N($.slice(32,64)),K=e.getNormalizedV($[64]);return new e(w9,U,Z,K)}Y(!1,"invalid raw signature length")}if(Q instanceof e)return Q.clone();const J=Q.r;Y(J!=null,"missing r");const X=Uq(J),q=function($,U){if($!=null)return Uq($);if(U!=null){Y(D0(U,32),"invalid yParityAndS");const Z=T(U);return Z[0]&=127,N(Z)}Y(!1,"missing s")}(Q.s,Q.yParityAndS),{networkV:G,v:W}=function($,U,Z){if($!=null){const K=h($);return{networkV:K>=GJ?K:void 0,v:e.getNormalizedV(K)}}if(U!=null)return Y(D0(U,32),"invalid yParityAndS"),{v:T(U)[0]&128?28:27};if(Z!=null){switch($0(Z,"sig.yParity")){case 0:return{v:27};case 1:return{v:28}}Y(!1,"invalid yParity")}Y(!1,"missing v")}(Q.v,Q.yParityAndS,Q.yParity),V=new e(w9,X,q,W);if(G)V.#X=G;return Y(Q.yParity==null||$0(Q.yParity,"sig.yParity")===V.yParity,"yParity mismatch"),Y(Q.yParityAndS==null||Q.yParityAndS===V.yParityAndS,"yParityAndS mismatch"),V}}class q0{#Q;constructor(Q){O(U8(Q)===32,"invalid private key","privateKey","[REDACTED]"),this.#Q=N(Q)}get privateKey(){return this.#Q}get publicKey(){return q0.computePublicKey(this.#Q)}get compressedPublicKey(){return q0.computePublicKey(this.#Q,!0)}sign(Q){O(U8(Q)===32,"invalid digest length","digest",Q);const Y=H8.sign(d0(Q),d0(this.#Q),{lowS:!0});return e.from({r:l0(Y.r,32),s:l0(Y.s,32),v:Y.recovery?28:27})}computeSharedSecret(Q){const Y=q0.computePublicKey(Q);return N(H8.getSharedSecret(d0(this.#Q),T(Y),!1))}static computePublicKey(Q,Y){let J=T(Q,"key");if(J.length===32){const q=H8.getPublicKey(J,!!Y);return N(q)}if(J.length===64){const q=new Uint8Array(65);q[0]=4,q.set(J,1),J=q}const X=H8.ProjectivePoint.fromHex(J);return N(X.toRawBytes(Y))}static recoverPublicKey(Q,Y){O(U8(Q)===32,"invalid digest length","digest",Q);const J=e.from(Y);let X=H8.Signature.fromCompact(d0(o([J.r,J.s])));X=X.addRecoveryBit(J.yParity);const q=X.recoverPublicKey(d0(Q));return O(q!=null,"invalid signature for digest","signature",Y),"0x"+q.toHex(!1)}static addPoints(Q,Y,J){const X=H8.ProjectivePoint.fromHex(q0.computePublicKey(Q).substring(2)),q=H8.ProjectivePoint.fromHex(q0.computePublicKey(Y).substring(2));return"0x"+X.add(q).toHex(!!J)}}var $q=function(Q){Q=Q.toLowerCase();const Y=Q.substring(2).split(""),J=new Uint8Array(40);for(let q=0;q<40;q++)J[q]=Y[q].charCodeAt(0);const X=T(i(J));for(let q=0;q<40;q+=2){if(X[q>>1]>>4>=8)Y[q]=Y[q].toUpperCase();if((X[q>>1]&15)>=8)Y[q+1]=Y[q+1].toUpperCase()}return"0x"+Y.join("")},Q6=function(Q){Q=Q.toUpperCase(),Q=Q.substring(4)+Q.substring(0,2)+"00";let Y=Q.split("").map((X)=>{return C5[X]}).join("");while(Y.length>=Zq){let X=Y.substring(0,Zq);Y=parseInt(X,10)%97+Y.substring(X.length)}let J=String(98-parseInt(Y,10)%97);while(J.length<2)J="0"+J;return J},Y6=function(Q){Q=Q.toLowerCase();let Y=tG;for(let J=0;J<Q.length;J++)Y=Y*eG+J6[Q[J]];return Y};function y(Q){if(O(typeof Q==="string","invalid address","address",Q),Q.match(/^(0x)?[0-9a-fA-F]{40}$/)){if(!Q.startsWith("0x"))Q="0x"+Q;const Y=$q(Q);return O(!Q.match(/([A-F].*[a-f])|([a-f].*[A-F])/)||Y===Q,"bad address checksum","address",Q),Y}if(Q.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)){O(Q.substring(2,4)===Q6(Q),"bad icap checksum","address",Q);let Y=Y6(Q.substring(4)).toString(16);while(Y.length<40)Y="0"+Y;return $q("0x"+Y)}O(!1,"invalid address","address",Q)}var tG=BigInt(0),eG=BigInt(36),C5={};for(let Q=0;Q<10;Q++)C5[String(Q)]=String(Q);for(let Q=0;Q<26;Q++)C5[String.fromCharCode(65+Q)]=String(10+Q);var Zq=15,J6=function(){const Q={};for(let Y=0;Y<36;Y++){const J="0123456789abcdefghijklmnopqrstuvwxyz"[Y];Q[J]=BigInt(Y)}return Q}();function T5(Q){return Q&&typeof Q.getAddress==="function"}async function N5(Q,Y){const J=await Y;if(J==null||J==="0x0000000000000000000000000000000000000000")x(typeof Q!=="string","unconfigured name","UNCONFIGURED_NAME",{value:Q}),O(!1,"invalid AddressLike value; did not resolve to a value address","target",Q);return y(J)}function D8(Q,Y){if(typeof Q==="string"){if(Q.match(/^0x[0-9a-f]{40}$/i))return y(Q);return x(Y!=null,"ENS resolution requires a provider","UNSUPPORTED_OPERATION",{operation:"resolveName"}),N5(Q,Y.resolveName(Q))}else if(T5(Q))return N5(Q,Q.getAddress());else if(Q&&typeof Q.then==="function")return N5(Q,Q);O(!1,"unsupported addressable value","target",Q)}var F5=function(Q,Y){return{address:y(Q),storageKeys:Y.map((J,X)=>{return O(D0(J,32),"invalid slot",`storageKeys[${X}]`,J),J.toLowerCase()})}};function e8(Q){if(Array.isArray(Q))return Q.map((J,X)=>{if(Array.isArray(J))return O(J.length===2,"invalid slot set",`value[${X}]`,J),F5(J[0],J[1]);return O(J!=null&&typeof J==="object","invalid address-slot set","value",Q),F5(J.address,J.storageKeys)});O(Q!=null&&typeof Q==="object","invalid access list","value",Q);const Y=Object.keys(Q).map((J)=>{const X=Q[J].reduce((q,G)=>{return q[G]=!0,q},{});return F5(J,Object.keys(X).sort())});return Y.sort((J,X)=>J.address.localeCompare(X.address)),Y}function zq(Q){return{address:y(Q.address),nonce:h(Q.nonce!=null?Q.nonce:0),chainId:h(Q.chainId!=null?Q.chainId:0),signature:e.from(Q.signature)}}function P8(Q){let Y;if(typeof Q==="string")Y=q0.computePublicKey(Q,!1);else Y=Q.publicKey;return y(i("0x"+Y.substring(4)).substring(26))}function s9(Q,Y){return P8(q0.recoverPublicKey(Q,Y))}var Z6=function(Q){return{blobToKzgCommitment:(X)=>{if("computeBlobProof"in Q){if(("blobToKzgCommitment"in Q)&&typeof Q.blobToKzgCommitment==="function")return T(Q.blobToKzgCommitment(N(X)))}else if(("blobToKzgCommitment"in Q)&&typeof Q.blobToKzgCommitment==="function")return T(Q.blobToKzgCommitment(X));if(("blobToKZGCommitment"in Q)&&typeof Q.blobToKZGCommitment==="function")return T(Q.blobToKZGCommitment(N(X)));O(!1,"unsupported KZG library","kzg",Q)},computeBlobKzgProof:(X,q)=>{if(("computeBlobProof"in Q)&&typeof Q.computeBlobProof==="function")return T(Q.computeBlobProof(N(X),N(q)));if(("computeBlobKzgProof"in Q)&&typeof Q.computeBlobKzgProof==="function")return Q.computeBlobKzgProof(X,q);if(("computeBlobKZGProof"in Q)&&typeof Q.computeBlobKZGProof==="function")return T(Q.computeBlobKZGProof(N(X),N(q)));O(!1,"unsupported KZG library","kzg",Q)}}},Kq=function(Q,Y){let J=Q.toString(16);while(J.length<2)J="0"+J;return J+=I0(Y).substring(4),"0x"+J},B9=function(Q){if(Q==="0x")return null;return y(Q)},WJ=function(Q,Y){try{return e8(Q)}catch(J){O(!1,J.message,Y,Q)}},z6=function(Q,Y){try{if(!Array.isArray(Q))throw new Error("authorizationList: invalid array");const J=[];for(let X=0;X<Q.length;X++){const q=Q[X];if(!Array.isArray(q))throw new Error(`authorization[${X}]: invalid array`);if(q.length!==6)throw new Error(`authorization[${X}]: wrong length`);if(!q[1])throw new Error(`authorization[${X}]: null address`);J.push({address:B9(q[1]),nonce:a(q[2],"nonce"),chainId:a(q[0],"chainId"),signature:e.from({yParity:Q9(q[3],"yParity"),r:A0(q[4],32),s:A0(q[5],32)})})}return J}catch(J){O(!1,J.message,Y,Q)}},Q9=function(Q,Y){if(Q==="0x")return 0;return $0(Q,Y)},a=function(Q,Y){if(Q==="0x")return z0;const J=h(Q,Y);return O(J<=$6,"value exceeds uint size",Y,J),J},m=function(Q,Y){const J=h(Q,"value"),X=t(J);return O(X.length<=32,"value too large",`tx.${Y}`,J),X},VJ=function(Q){return e8(Q).map((Y)=>[Y.address,Y.storageKeys])},K6=function(Q){return Q.map((Y)=>{return[m(Y.chainId,"chainId"),Y.address,m(Y.nonce,"nonce"),m(Y.signature.yParity,"yParity"),t(Y.signature.r),t(Y.signature.s)]})},M6=function(Q,Y){O(Array.isArray(Q),`invalid ${Y}`,"value",Q);for(let J=0;J<Q.length;J++)O(D0(Q[J],32),"invalid ${ param } hash",`value[${J}]`,Q[J]);return Q},I6=function(Q){const Y=B8(Q);O(Array.isArray(Y)&&(Y.length===9||Y.length===6),"invalid field count for legacy transaction","data",Q);const J={type:0,nonce:Q9(Y[0],"nonce"),gasPrice:a(Y[1],"gasPrice"),gasLimit:a(Y[2],"gasLimit"),to:B9(Y[3]),value:a(Y[4],"value"),data:N(Y[5]),chainId:z0};if(Y.length===6)return J;const X=a(Y[6],"v"),q=a(Y[7],"r"),G=a(Y[8],"s");if(q===z0&&G===z0)J.chainId=X;else{let W=(X-U6)/G6;if(W<z0)W=z0;J.chainId=W,O(W!==z0||(X===W6||X===V6),"non-canonical legacy v","v",Y[6]),J.signature=e.from({r:A0(Y[7],32),s:A0(Y[8],32),v:X})}return J},O6=function(Q,Y){const J=[m(Q.nonce,"nonce"),m(Q.gasPrice||0,"gasPrice"),m(Q.gasLimit,"gasLimit"),Q.to||"0x",m(Q.value,"value"),Q.data];let X=z0;if(Q.chainId!=z0)X=h(Q.chainId,"tx.chainId"),O(!Y||Y.networkV==null||Y.legacyChainId===X,"tx.chainId/sig.v mismatch","sig",Y);else if(Q.signature){const G=Q.signature.legacyChainId;if(G!=null)X=G}if(!Y){if(X!==z0)J.push(t(X)),J.push("0x"),J.push("0x");return f0(J)}let q=BigInt(27+Y.yParity);if(X!==z0)q=e.getChainIdV(X,Y.v);else if(BigInt(Y.v)!==q)O(!1,"tx.chainId/sig.v mismatch","sig",Y);return J.push(t(q)),J.push(t(Y.r)),J.push(t(Y.s)),f0(J)},UJ=function(Q,Y){let J;try{if(J=Q9(Y[0],"yParity"),J!==0&&J!==1)throw new Error("bad yParity")}catch(W){O(!1,"invalid yParity","yParity",Y[0])}const X=A0(Y[1],32),q=A0(Y[2],32),G=e.from({r:X,s:q,yParity:J});Q.signature=G},R6=function(Q){const Y=B8(T(Q).slice(1));O(Array.isArray(Y)&&(Y.length===9||Y.length===12),"invalid field count for transaction type: 2","data",N(Q));const J={type:2,chainId:a(Y[0],"chainId"),nonce:Q9(Y[1],"nonce"),maxPriorityFeePerGas:a(Y[2],"maxPriorityFeePerGas"),maxFeePerGas:a(Y[3],"maxFeePerGas"),gasPrice:null,gasLimit:a(Y[4],"gasLimit"),to:B9(Y[5]),value:a(Y[6],"value"),data:N(Y[7]),accessList:WJ(Y[8],"accessList")};if(Y.length===9)return J;return UJ(J,Y.slice(9)),J},H6=function(Q,Y){const J=[m(Q.chainId,"chainId"),m(Q.nonce,"nonce"),m(Q.maxPriorityFeePerGas||0,"maxPriorityFeePerGas"),m(Q.maxFeePerGas||0,"maxFeePerGas"),m(Q.gasLimit,"gasLimit"),Q.to||"0x",m(Q.value,"value"),Q.data,VJ(Q.accessList||[])];if(Y)J.push(m(Y.yParity,"yParity")),J.push(t(Y.r)),J.push(t(Y.s));return o(["0x02",f0(J)])},D6=function(Q){const Y=B8(T(Q).slice(1));O(Array.isArray(Y)&&(Y.length===8||Y.length===11),"invalid field count for transaction type: 1","data",N(Q));const J={type:1,chainId:a(Y[0],"chainId"),nonce:Q9(Y[1],"nonce"),gasPrice:a(Y[2],"gasPrice"),gasLimit:a(Y[3],"gasLimit"),to:B9(Y[4]),value:a(Y[5],"value"),data:N(Y[6]),accessList:WJ(Y[7],"accessList")};if(Y.length===8)return J;return UJ(J,Y.slice(8)),J},P6=function(Q,Y){const J=[m(Q.chainId,"chainId"),m(Q.nonce,"nonce"),m(Q.gasPrice||0,"gasPrice"),m(Q.gasLimit,"gasLimit"),Q.to||"0x",m(Q.value,"value"),Q.data,VJ(Q.accessList||[])];if(Y)J.push(m(Y.yParity,"recoveryParam")),J.push(t(Y.r)),J.push(t(Y.s));return o(["0x01",f0(J)])},j6=function(Q){let Y=B8(T(Q).slice(1)),J="3",X=null;if(Y.length===4&&Array.isArray(Y[0])){J="3 (network format)";const G=Y[1],W=Y[2],V=Y[3];O(Array.isArray(G),"invalid network format: blobs not an array","fields[1]",G),O(Array.isArray(W),"invalid network format: commitments not an array","fields[2]",W),O(Array.isArray(V),"invalid network format: proofs not an array","fields[3]",V),O(G.length===W.length,"invalid network format: blobs/commitments length mismatch","fields",Y),O(G.length===V.length,"invalid network format: blobs/proofs length mismatch","fields",Y),X=[];for(let $=0;$<Y[1].length;$++)X.push({data:G[$],commitment:W[$],proof:V[$]});Y=Y[0]}O(Array.isArray(Y)&&(Y.length===11||Y.length===14),`invalid field count for transaction type: ${J}`,"data",N(Q));const q={type:3,chainId:a(Y[0],"chainId"),nonce:Q9(Y[1],"nonce"),maxPriorityFeePerGas:a(Y[2],"maxPriorityFeePerGas"),maxFeePerGas:a(Y[3],"maxFeePerGas"),gasPrice:null,gasLimit:a(Y[4],"gasLimit"),to:B9(Y[5]),value:a(Y[6],"value"),data:N(Y[7]),accessList:WJ(Y[8],"accessList"),maxFeePerBlobGas:a(Y[9],"maxFeePerBlobGas"),blobVersionedHashes:Y[10]};if(X)q.blobs=X;O(q.to!=null,`invalid address for transaction type: ${J}`,"data",Q),O(Array.isArray(q.blobVersionedHashes),"invalid blobVersionedHashes: must be an array","data",Q);for(let G=0;G<q.blobVersionedHashes.length;G++)O(D0(q.blobVersionedHashes[G],32),`invalid blobVersionedHash at index ${G}: must be length 32`,"data",Q);if(Y.length===11)return q;return UJ(q,Y.slice(11)),q},L6=function(Q,Y,J){const X=[m(Q.chainId,"chainId"),m(Q.nonce,"nonce"),m(Q.maxPriorityFeePerGas||0,"maxPriorityFeePerGas"),m(Q.maxFeePerGas||0,"maxFeePerGas"),m(Q.gasLimit,"gasLimit"),Q.to||j5,m(Q.value,"value"),Q.data,VJ(Q.accessList||[]),m(Q.maxFeePerBlobGas||0,"maxFeePerBlobGas"),M6(Q.blobVersionedHashes||[],"blobVersionedHashes")];if(Y){if(X.push(m(Y.yParity,"yParity")),X.push(t(Y.r)),X.push(t(Y.s)),J)return o(["0x03",f0([X,J.map((q)=>q.data),J.map((q)=>q.commitment),J.map((q)=>q.proof)])])}return o(["0x03",f0(X)])},C6=function(Q){const Y=B8(T(Q).slice(1));O(Array.isArray(Y)&&(Y.length===10||Y.length===13),"invalid field count for transaction type: 4","data",N(Q));const J={type:4,chainId:a(Y[0],"chainId"),nonce:Q9(Y[1],"nonce"),maxPriorityFeePerGas:a(Y[2],"maxPriorityFeePerGas"),maxFeePerGas:a(Y[3],"maxFeePerGas"),gasPrice:null,gasLimit:a(Y[4],"gasLimit"),to:B9(Y[5]),value:a(Y[6],"value"),data:N(Y[7]),accessList:WJ(Y[8],"accessList"),authorizationList:z6(Y[9],"authorizationList")};if(Y.length===10)return J;return UJ(J,Y.slice(10)),J},N6=function(Q,Y){const J=[m(Q.chainId,"chainId"),m(Q.nonce,"nonce"),m(Q.maxPriorityFeePerGas||0,"maxPriorityFeePerGas"),m(Q.maxFeePerGas||0,"maxFeePerGas"),m(Q.gasLimit,"gasLimit"),Q.to||"0x",m(Q.value,"value"),Q.data,VJ(Q.accessList||[]),K6(Q.authorizationList||[])];if(Y)J.push(m(Y.yParity,"yParity")),J.push(t(Y.r)),J.push(t(Y.s));return o(["0x04",f0(J)])},z0=BigInt(0),G6=BigInt(2),W6=BigInt(27),V6=BigInt(28),U6=BigInt(35),$6=BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"),w5=131072;class T0{#Q;#J;#Y;#X;#U;#$;#Z;#z;#K;#M;#I;#O;#V;#G;#q;#W;#R;get type(){return this.#Q}set type(Q){switch(Q){case null:this.#Q=null;break;case 0:case"legacy":this.#Q=0;break;case 1:case"berlin":case"eip-2930":this.#Q=1;break;case 2:case"london":case"eip-1559":this.#Q=2;break;case 3:case"cancun":case"eip-4844":this.#Q=3;break;case 4:case"pectra":case"eip-7702":this.#Q=4;break;default:O(!1,"unsupported transaction type","type",Q)}}get typeName(){switch(this.type){case 0:return"legacy";case 1:return"eip-2930";case 2:return"eip-1559";case 3:return"eip-4844";case 4:return"eip-7702"}return null}get to(){const Q=this.#J;if(Q==null&&this.type===3)return j5;return Q}set to(Q){this.#J=Q==null?null:y(Q)}get nonce(){return this.#X}set nonce(Q){this.#X=$0(Q,"value")}get gasLimit(){return this.#U}set gasLimit(Q){this.#U=h(Q)}get gasPrice(){const Q=this.#$;if(Q==null&&(this.type===0||this.type===1))return z0;return Q}set gasPrice(Q){this.#$=Q==null?null:h(Q,"gasPrice")}get maxPriorityFeePerGas(){const Q=this.#Z;if(Q==null){if(this.type===2||this.type===3)return z0;return null}return Q}set maxPriorityFeePerGas(Q){this.#Z=Q==null?null:h(Q,"maxPriorityFeePerGas")}get maxFeePerGas(){const Q=this.#z;if(Q==null){if(this.type===2||this.type===3)return z0;return null}return Q}set maxFeePerGas(Q){this.#z=Q==null?null:h(Q,"maxFeePerGas")}get data(){return this.#Y}set data(Q){this.#Y=N(Q)}get value(){return this.#K}set value(Q){this.#K=h(Q,"value")}get chainId(){return this.#M}set chainId(Q){this.#M=h(Q)}get signature(){return this.#I||null}set signature(Q){this.#I=Q==null?null:e.from(Q)}get accessList(){const Q=this.#O||null;if(Q==null){if(this.type===1||this.type===2||this.type===3)return[];return null}return Q}set accessList(Q){this.#O=Q==null?null:e8(Q)}get authorizationList(){const Q=this.#R||null;if(Q==null){if(this.type===4)return[]}return Q}set authorizationList(Q){this.#R=Q==null?null:Q.map((Y)=>zq(Y))}get maxFeePerBlobGas(){const Q=this.#V;if(Q==null&&this.type===3)return z0;return Q}set maxFeePerBlobGas(Q){this.#V=Q==null?null:h(Q,"maxFeePerBlobGas")}get blobVersionedHashes(){let Q=this.#G;if(Q==null&&this.type===3)return[];return Q}set blobVersionedHashes(Q){if(Q!=null){O(Array.isArray(Q),"blobVersionedHashes must be an Array","value",Q),Q=Q.slice();for(let Y=0;Y<Q.length;Y++)O(D0(Q[Y],32),"invalid blobVersionedHash",`value[${Y}]`,Q[Y])}this.#G=Q}get blobs(){if(this.#W==null)return null;return this.#W.map((Q)=>Object.assign({},Q))}set blobs(Q){if(Q==null){this.#W=null;return}const Y=[],J=[];for(let X=0;X<Q.length;X++){const q=Q[X];if(s0(q)){x(this.#q,"adding a raw blob requires a KZG library","UNSUPPORTED_OPERATION",{operation:"set blobs()"});let G=T(q);if(O(G.length<=w5,"blob is too large",`blobs[${X}]`,q),G.length!==w5){const $=new Uint8Array(w5);$.set(G),G=$}const W=this.#q.blobToKzgCommitment(G),V=N(this.#q.computeBlobKzgProof(G,W));Y.push({data:N(G),commitment:N(W),proof:V}),J.push(Kq(1,W))}else{const G=N(q.commitment);Y.push({data:N(q.data),commitment:G,proof:N(q.proof)}),J.push(Kq(1,G))}}this.#W=Y,this.#G=J}get kzg(){return this.#q}set kzg(Q){if(Q==null)this.#q=null;else this.#q=Z6(Q)}constructor(){this.#Q=null,this.#J=null,this.#X=0,this.#U=z0,this.#$=null,this.#Z=null,this.#z=null,this.#Y="0x",this.#K=z0,this.#M=z0,this.#I=null,this.#O=null,this.#V=null,this.#G=null,this.#q=null,this.#W=null,this.#R=null}get hash(){if(this.signature==null)return null;return i(this.#H(!0,!1))}get unsignedHash(){return i(this.unsignedSerialized)}get from(){if(this.signature==null)return null;return s9(this.unsignedHash,this.signature)}get fromPublicKey(){if(this.signature==null)return null;return q0.recoverPublicKey(this.unsignedHash,this.signature)}isSigned(){return this.signature!=null}#H(Q,Y){x(!Q||this.signature!=null,"cannot serialize unsigned transaction; maybe you meant .unsignedSerialized","UNSUPPORTED_OPERATION",{operation:".serialized"});const J=Q?this.signature:null;switch(this.inferType()){case 0:return O6(this,J);case 1:return P6(this,J);case 2:return H6(this,J);case 3:return L6(this,J,Y?this.blobs:null);case 4:return N6(this,J)}x(!1,"unsupported transaction type","UNSUPPORTED_OPERATION",{operation:".serialized"})}get serialized(){return this.#H(!0,!0)}get unsignedSerialized(){return this.#H(!1,!1)}inferType(){const Q=this.inferTypes();if(Q.indexOf(2)>=0)return 2;return Q.pop()}inferTypes(){const Q=this.gasPrice!=null,Y=this.maxFeePerGas!=null||this.maxPriorityFeePerGas!=null,J=this.accessList!=null,X=this.#V!=null||this.#G;if(this.maxFeePerGas!=null&&this.maxPriorityFeePerGas!=null)x(this.maxFeePerGas>=this.maxPriorityFeePerGas,"priorityFee cannot be more than maxFee","BAD_DATA",{value:this});x(!Y||this.type!==0&&this.type!==1,"transaction type cannot have maxFeePerGas or maxPriorityFeePerGas","BAD_DATA",{value:this}),x(this.type!==0||!J,"legacy transaction cannot have accessList","BAD_DATA",{value:this});const q=[];if(this.type!=null)q.push(this.type);else if(this.authorizationList&&this.authorizationList.length)q.push(4);else if(Y)q.push(2);else if(Q){if(q.push(1),!J)q.push(0)}else if(J)q.push(1),q.push(2);else if(X&&this.to)q.push(3);else q.push(0),q.push(1),q.push(2),q.push(3);return q.sort(),q}isLegacy(){return this.type===0}isBerlin(){return this.type===1}isLondon(){return this.type===2}isCancun(){return this.type===3}clone(){return T0.from(this)}toJSON(){const Q=(Y)=>{if(Y==null)return null;return Y.toString()};return{type:this.type,to:this.to,data:this.data,nonce:this.nonce,gasLimit:Q(this.gasLimit),gasPrice:Q(this.gasPrice),maxPriorityFeePerGas:Q(this.maxPriorityFeePerGas),maxFeePerGas:Q(this.maxFeePerGas),value:Q(this.value),chainId:Q(this.chainId),sig:this.signature?this.signature.toJSON():null,accessList:this.accessList}}static from(Q){if(Q==null)return new T0;if(typeof Q==="string"){const J=T(Q);if(J[0]>=127)return T0.from(I6(J));switch(J[0]){case 1:return T0.from(D6(J));case 2:return T0.from(R6(J));case 3:return T0.from(j6(J));case 4:return T0.from(C6(J))}x(!1,"unsupported transaction type","UNSUPPORTED_OPERATION",{operation:"from"})}const Y=new T0;if(Q.type!=null)Y.type=Q.type;if(Q.to!=null)Y.to=Q.to;if(Q.nonce!=null)Y.nonce=Q.nonce;if(Q.gasLimit!=null)Y.gasLimit=Q.gasLimit;if(Q.gasPrice!=null)Y.gasPrice=Q.gasPrice;if(Q.maxPriorityFeePerGas!=null)Y.maxPriorityFeePerGas=Q.maxPriorityFeePerGas;if(Q.maxFeePerGas!=null)Y.maxFeePerGas=Q.maxFeePerGas;if(Q.maxFeePerBlobGas!=null)Y.maxFeePerBlobGas=Q.maxFeePerBlobGas;if(Q.data!=null)Y.data=Q.data;if(Q.value!=null)Y.value=Q.value;if(Q.chainId!=null)Y.chainId=Q.chainId;if(Q.signature!=null)Y.signature=e.from(Q.signature);if(Q.accessList!=null)Y.accessList=Q.accessList;if(Q.authorizationList!=null)Y.authorizationList=Q.authorizationList;if(Q.blobVersionedHashes!=null)Y.blobVersionedHashes=Q.blobVersionedHashes;if(Q.kzg!=null)Y.kzg=Q.kzg;if(Q.blobs!=null)Y.blobs=Q.blobs;if(Q.hash!=null)O(Y.isSigned(),"unsigned transaction cannot define '.hash'","tx",Q),O(Y.hash===Q.hash,"hash mismatch","tx",Q);if(Q.from!=null)O(Y.isSigned(),"unsigned transaction cannot define '.from'","tx",Q),O(Y.from.toLowerCase()===(Q.from||"").toLowerCase(),"from mismatch","tx",Q);return Y}}function $J(Q){return O(typeof Q.address==="string","invalid address for hashAuthorization","auth.address",Q),i(o(["0x05",f0([Q.chainId!=null?t(Q.chainId):"0x",y(Q.address),Q.nonce!=null?t(Q.nonce):"0x"])]))}function j8(Q){return i(Z0(Q))}function t9(Q){if(typeof Q==="string")Q=Z0(Q);return i(o([Z0(L5),Z0(String(Q.length)),Q]))}function ZJ(Q,Y){const J=t9(Q);return s9(J,Y)}var w6=function(Q){const Y=T(Q),J=Y.length%32;if(J)return o([Y,Rq.slice(J)]);return N(Y)},Iq=function(Q){return function(Y){return O(typeof Y==="string",`invalid domain value for ${JSON.stringify(Q)}`,`domain.${Q}`,Y),Y}},S5=function(Q){{const Y=Q.match(/^(u?)int(\d+)$/);if(Y){const J=Y[1]==="",X=parseInt(Y[2]);O(X%8===0&&X!==0&&X<=256&&Y[2]===String(X),"invalid numeric width","type",Q);const q=bQ(F6,J?X-1:X),G=J?(q+Dq)*T6:Hq;return function(W){const V=h(W,"value");return O(V>=G&&V<=q,`value out-of-bounds for ${Q}`,"value",V),l0(J?fQ(V,256):V,32)}}}{const Y=Q.match(/^bytes(\d+)$/);if(Y){const J=parseInt(Y[1]);return O(J!==0&&J<=32&&Y[1]===String(J),"invalid bytes width","type",Q),function(X){const q=T(X);return O(q.length===J,`invalid length for ${Q}`,"value",X),w6(X)}}}switch(Q){case"address":return function(Y){return A0(y(Y),32)};case"bool":return function(Y){return!Y?S6:B6};case"bytes":return function(Y){return i(Y)};case"string":return function(Y){return j8(Y)}}return null},Oq=function(Q,Y){return`${Q}(${Y.map(({name:J,type:X})=>X+" "+J).join(",")})`},zJ=function(Q){const Y=Q.match(/^([^\x5b]*)((\x5b\d*\x5d)*)(\x5b(\d*)\x5d)$/);if(Y)return{base:Y[1],index:Y[2]+Y[4],array:{base:Y[1],prefix:Y[1]+Y[2],count:Y[5]?parseInt(Y[5]):-1}};return{base:Q}};var Rq=new Uint8Array(32);Rq.fill(0);var T6=BigInt(-1),Hq=BigInt(0),Dq=BigInt(1),F6=BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"),B6=l0(Dq,32),S6=l0(Hq,32),Mq={name:"string",version:"string",chainId:"uint256",verifyingContract:"address",salt:"bytes32"},B5=["name","version","chainId","verifyingContract","salt"],A6={name:Iq("name"),version:Iq("version"),chainId:function(Q){const Y=h(Q,"domain.chainId");if(O(Y>=0,"invalid chain ID","domain.chainId",Q),Number.isSafeInteger(Y))return Number(Y);return yQ(Y)},verifyingContract:function(Q){try{return y(Q).toLowerCase()}catch(Y){}O(!1,'invalid domain value "verifyingContract"',"domain.verifyingContract",Q)},salt:function(Q){const Y=T(Q,"domain.salt");return O(Y.length===32,'invalid domain value "salt"',"domain.salt",Q),N(Y)}};class L0{primaryType;#Q;get types(){return JSON.parse(this.#Q)}#J;#Y;constructor(Q){this.#J=new Map,this.#Y=new Map;const Y=new Map,J=new Map,X=new Map,q={};Object.keys(Q).forEach((V)=>{q[V]=Q[V].map(({name:$,type:U})=>{let{base:Z,index:K}=zJ(U);if(Z==="int"&&!Q.int)Z="int256";if(Z==="uint"&&!Q.uint)Z="uint256";return{name:$,type:Z+(K||"")}}),Y.set(V,new Set),J.set(V,[]),X.set(V,new Set)}),this.#Q=JSON.stringify(q);for(let V in q){const $=new Set;for(let U of q[V]){O(!$.has(U.name),`duplicate variable name ${JSON.stringify(U.name)} in ${JSON.stringify(V)}`,"types",Q),$.add(U.name);const Z=zJ(U.type).base;if(O(Z!==V,`circular type reference to ${JSON.stringify(Z)}`,"types",Q),S5(Z))continue;O(J.has(Z),`unknown type ${JSON.stringify(Z)}`,"types",Q),J.get(Z).push(V),Y.get(V).add(Z)}}const G=Array.from(J.keys()).filter((V)=>J.get(V).length===0);O(G.length!==0,"missing primary type","types",Q),O(G.length===1,`ambiguous primary types or unused types: ${G.map((V)=>JSON.stringify(V)).join(", ")}`,"types",Q),s(this,{primaryType:G[0]});function W(V,$){O(!$.has(V),`circular type reference to ${JSON.stringify(V)}`,"types",Q),$.add(V);for(let U of Y.get(V)){if(!J.has(U))continue;W(U,$);for(let Z of $)X.get(Z).add(U)}$.delete(V)}W(this.primaryType,new Set);for(let[V,$]of X){const U=Array.from($);U.sort(),this.#J.set(V,Oq(V,q[V])+U.map((Z)=>Oq(Z,q[Z])).join(""))}}getEncoder(Q){let Y=this.#Y.get(Q);if(!Y)Y=this.#X(Q),this.#Y.set(Q,Y);return Y}#X(Q){{const X=S5(Q);if(X)return X}const Y=zJ(Q).array;if(Y){const X=Y.prefix,q=this.getEncoder(X);return(G)=>{O(Y.count===-1||Y.count===G.length,`array length mismatch; expected length ${Y.count}`,"value",G);let W=G.map(q);if(this.#J.has(X))W=W.map(i);return i(o(W))}}const J=this.types[Q];if(J){const X=j8(this.#J.get(Q));return(q)=>{const G=J.map(({name:W,type:V})=>{const $=this.getEncoder(V)(q[W]);if(this.#J.has(V))return i($);return $});return G.unshift(X),o(G)}}O(!1,`unknown type: ${Q}`,"type",Q)}encodeType(Q){const Y=this.#J.get(Q);return O(Y,`unknown type: ${JSON.stringify(Q)}`,"name",Q),Y}encodeData(Q,Y){return this.getEncoder(Q)(Y)}hashStruct(Q,Y){return i(this.encodeData(Q,Y))}encode(Q){return this.encodeData(this.primaryType,Q)}hash(Q){return this.hashStruct(this.primaryType,Q)}_visit(Q,Y,J){if(S5(Q))return J(Q,Y);const X=zJ(Q).array;if(X)return O(X.count===-1||X.count===Y.length,`array length mismatch; expected length ${X.count}`,"value",Y),Y.map((G)=>this._visit(X.prefix,G,J));const q=this.types[Q];if(q)return q.reduce((G,{name:W,type:V})=>{return G[W]=this._visit(V,Y[W],J),G},{});O(!1,`unknown type: ${Q}`,"type",Q)}visit(Q,Y){return this._visit(this.primaryType,Q,Y)}static from(Q){return new L0(Q)}static getPrimaryType(Q){return L0.from(Q).primaryType}static hashStruct(Q,Y,J){return L0.from(Y).hashStruct(Q,J)}static hashDomain(Q){const Y=[];for(let J in Q){if(Q[J]==null)continue;const X=Mq[J];O(X,`invalid typed-data domain key: ${JSON.stringify(J)}`,"domain",Q),Y.push({name:J,type:X})}return Y.sort((J,X)=>{return B5.indexOf(J.name)-B5.indexOf(X.name)}),L0.hashStruct("EIP712Domain",{EIP712Domain:Y},Q)}static encode(Q,Y,J){return o(["0x1901",L0.hashDomain(Q),L0.from(Y).hash(J)])}static hash(Q,Y,J){return i(L0.encode(Q,Y,J))}static async resolveNames(Q,Y,J,X){Q=Object.assign({},Q);for(let W in Q)if(Q[W]==null)delete Q[W];const q={};if(Q.verifyingContract&&!D0(Q.verifyingContract,20))q[Q.verifyingContract]="0x";const G=L0.from(Y);G.visit(J,(W,V)=>{if(W==="address"&&!D0(V,20))q[V]="0x";return V});for(let W in q)q[W]=await X(W);if(Q.verifyingContract&&q[Q.verifyingContract])Q.verifyingContract=q[Q.verifyingContract];return J=G.visit(J,(W,V)=>{if(W==="address"&&q[V])return q[V];return V}),{domain:Q,value:J}}static getPayload(Q,Y,J){L0.hashDomain(Q);const X={},q=[];B5.forEach((V)=>{const $=Q[V];if($==null)return;X[V]=A6[V]($),q.push({name:V,type:Mq[V]})});const G=L0.from(Y);Y=G.types;const W=Object.assign({},Y);return O(W.EIP712Domain==null,"types must not contain EIP712Domain type","types.EIP712Domain",Y),W.EIP712Domain=q,G.encode(J),{types:W,domain:X,primaryType:G.primaryType,message:G.visit(J,(V,$)=>{if(V.match(/^bytes(\d*)/))return N(T($));if(V.match(/^u?int/))return h($).toString();switch(V){case"address":return $.toLowerCase();case"bool":return!!$;case"string":return O(typeof $==="string","invalid string","value",$),$}O(!1,"unsupported type","type",V)})}}}var A5=function(Q){if(Q==null)return null;return Q},K0=function(Q){if(Q==null)return null;return Q.toString()};function e9(Q){const Y={};if(Q.to)Y.to=Q.to;if(Q.from)Y.from=Q.from;if(Q.data)Y.data=N(Q.data);const J="chainId,gasLimit,gasPrice,maxFeePerBlobGas,maxFeePerGas,maxPriorityFeePerGas,value".split(/,/);for(let q of J){if(!(q in Q)||Q[q]==null)continue;Y[q]=h(Q[q],`request.${q}`)}const X="type,nonce".split(/,/);for(let q of X){if(!(q in Q)||Q[q]==null)continue;Y[q]=$0(Q[q],`request.${q}`)}if(Q.accessList)Y.accessList=e8(Q.accessList);if(Q.authorizationList)Y.authorizationList=Q.authorizationList.slice();if("blockTag"in Q)Y.blockTag=Q.blockTag;if("enableCcipRead"in Q)Y.enableCcipRead=!!Q.enableCcipRead;if("customData"in Q)Y.customData=Q.customData;if(("blobVersionedHashes"in Q)&&Q.blobVersionedHashes)Y.blobVersionedHashes=Q.blobVersionedHashes.slice();if("kzg"in Q)Y.kzg=Q.kzg;if(("blobs"in Q)&&Q.blobs)Y.blobs=Q.blobs.map((q)=>{if(s0(q))return N(q);return Object.assign({},q)});return Y}var x6=function(Q){return{orphan:"drop-block",hash:Q.hash,number:Q.number}},Cq=function(Q,Y){return{orphan:"reorder-transaction",tx:Q,other:Y}},Nq=function(Q){return{orphan:"drop-transaction",tx:Q}},g6=function(Q){return{orphan:"drop-log",log:{transactionHash:Q.transactionHash,blockHash:Q.blockHash,blockNumber:Q.blockNumber,address:Q.address,data:Q.data,topics:Object.freeze(Q.topics.slice()),index:Q.index}}},Pq=BigInt(0);class jq{provider;number;hash;timestamp;parentHash;parentBeaconBlockRoot;nonce;difficulty;gasLimit;gasUsed;stateRoot;receiptsRoot;blobGasUsed;excessBlobGas;miner;prevRandao;extraData;baseFeePerGas;#Q;constructor(Q,Y){this.#Q=Q.transactions.map((J)=>{if(typeof J!=="string")return new KJ(J,Y);return J}),s(this,{provider:Y,hash:A5(Q.hash),number:Q.number,timestamp:Q.timestamp,parentHash:Q.parentHash,parentBeaconBlockRoot:Q.parentBeaconBlockRoot,nonce:Q.nonce,difficulty:Q.difficulty,gasLimit:Q.gasLimit,gasUsed:Q.gasUsed,blobGasUsed:Q.blobGasUsed,excessBlobGas:Q.excessBlobGas,miner:Q.miner,prevRandao:A5(Q.prevRandao),extraData:Q.extraData,baseFeePerGas:A5(Q.baseFeePerGas),stateRoot:Q.stateRoot,receiptsRoot:Q.receiptsRoot})}get transactions(){return this.#Q.map((Q)=>{if(typeof Q==="string")return Q;return Q.hash})}get prefetchedTransactions(){const Q=this.#Q.slice();if(Q.length===0)return[];return x(typeof Q[0]==="object","transactions were not prefetched with block request","UNSUPPORTED_OPERATION",{operation:"transactionResponses()"}),Q}toJSON(){const{baseFeePerGas:Q,difficulty:Y,extraData:J,gasLimit:X,gasUsed:q,hash:G,miner:W,prevRandao:V,nonce:$,number:U,parentHash:Z,parentBeaconBlockRoot:K,stateRoot:M,receiptsRoot:I,timestamp:z,transactions:R}=this;return{_type:"Block",baseFeePerGas:K0(Q),difficulty:K0(Y),extraData:J,gasLimit:K0(X),gasUsed:K0(q),blobGasUsed:K0(this.blobGasUsed),excessBlobGas:K0(this.excessBlobGas),hash:G,miner:W,prevRandao:V,nonce:$,number:U,parentHash:Z,timestamp:z,parentBeaconBlockRoot:K,stateRoot:M,receiptsRoot:I,transactions:R}}[Symbol.iterator](){let Q=0;const Y=this.transactions;return{next:()=>{if(Q<this.length)return{value:Y[Q++],done:!1};return{value:void 0,done:!0}}}}get length(){return this.#Q.length}get date(){if(this.timestamp==null)return null;return new Date(this.timestamp*1000)}async getTransaction(Q){let Y=void 0;if(typeof Q==="number")Y=this.#Q[Q];else{const J=Q.toLowerCase();for(let X of this.#Q)if(typeof X==="string"){if(X!==J)continue;Y=X;break}else{if(X.hash!==J)continue;Y=X;break}}if(Y==null)throw new Error("no such tx");if(typeof Y==="string")return await this.provider.getTransaction(Y);else return Y}getPrefetchedTransaction(Q){const Y=this.prefetchedTransactions;if(typeof Q==="number")return Y[Q];Q=Q.toLowerCase();for(let J of Y)if(J.hash===Q)return J;O(!1,"no matching transaction","indexOrHash",Q)}isMined(){return!!this.hash}isLondon(){return!!this.baseFeePerGas}orphanedEvent(){if(!this.isMined())throw new Error("");return x6(this)}}class E5{provider;transactionHash;blockHash;blockNumber;removed;address;data;topics;index;transactionIndex;constructor(Q,Y){this.provider=Y;const J=Object.freeze(Q.topics.slice());s(this,{transactionHash:Q.transactionHash,blockHash:Q.blockHash,blockNumber:Q.blockNumber,removed:Q.removed,address:Q.address,data:Q.data,topics:J,index:Q.index,transactionIndex:Q.transactionIndex})}toJSON(){const{address:Q,blockHash:Y,blockNumber:J,data:X,index:q,removed:G,topics:W,transactionHash:V,transactionIndex:$}=this;return{_type:"log",address:Q,blockHash:Y,blockNumber:J,data:X,index:q,removed:G,topics:W,transactionHash:V,transactionIndex:$}}async getBlock(){const Q=await this.provider.getBlock(this.blockHash);return x(!!Q,"failed to find transaction","UNKNOWN_ERROR",{}),Q}async getTransaction(){const Q=await this.provider.getTransaction(this.transactionHash);return x(!!Q,"failed to find transaction","UNKNOWN_ERROR",{}),Q}async getTransactionReceipt(){const Q=await this.provider.getTransactionReceipt(this.transactionHash);return x(!!Q,"failed to find transaction receipt","UNKNOWN_ERROR",{}),Q}removedEvent(){return g6(this)}}class Lq{provider;to;from;contractAddress;hash;index;blockHash;blockNumber;logsBloom;gasUsed;blobGasUsed;cumulativeGasUsed;gasPrice;blobGasPrice;type;status;root;#Q;constructor(Q,Y){this.#Q=Object.freeze(Q.logs.map((X)=>{return new E5(X,Y)}));let J=Pq;if(Q.effectiveGasPrice!=null)J=Q.effectiveGasPrice;else if(Q.gasPrice!=null)J=Q.gasPrice;s(this,{provider:Y,to:Q.to,from:Q.from,contractAddress:Q.contractAddress,hash:Q.hash,index:Q.index,blockHash:Q.blockHash,blockNumber:Q.blockNumber,logsBloom:Q.logsBloom,gasUsed:Q.gasUsed,cumulativeGasUsed:Q.cumulativeGasUsed,blobGasUsed:Q.blobGasUsed,gasPrice:J,blobGasPrice:Q.blobGasPrice,type:Q.type,status:Q.status,root:Q.root})}get logs(){return this.#Q}toJSON(){const{to:Q,from:Y,contractAddress:J,hash:X,index:q,blockHash:G,blockNumber:W,logsBloom:V,logs:$,status:U,root:Z}=this;return{_type:"TransactionReceipt",blockHash:G,blockNumber:W,contractAddress:J,cumulativeGasUsed:K0(this.cumulativeGasUsed),from:Y,gasPrice:K0(this.gasPrice),blobGasUsed:K0(this.blobGasUsed),blobGasPrice:K0(this.blobGasPrice),gasUsed:K0(this.gasUsed),hash:X,index:q,logs:$,logsBloom:V,root:Z,status:U,to:Q}}get length(){return this.logs.length}[Symbol.iterator](){let Q=0;return{next:()=>{if(Q<this.length)return{value:this.logs[Q++],done:!1};return{value:void 0,done:!0}}}}get fee(){return this.gasUsed*this.gasPrice}async getBlock(){const Q=await this.provider.getBlock(this.blockHash);if(Q==null)throw new Error("TODO");return Q}async getTransaction(){const Q=await this.provider.getTransaction(this.hash);if(Q==null)throw new Error("TODO");return Q}async getResult(){return await this.provider.getTransactionResult(this.hash)}async confirmations(){return await this.provider.getBlockNumber()-this.blockNumber+1}removedEvent(){return Nq(this)}reorderedEvent(Q){return x(!Q||Q.isMined(),"unmined 'other' transction cannot be orphaned","UNSUPPORTED_OPERATION",{operation:"reorderedEvent(other)"}),Cq(this,Q)}}class KJ{provider;blockNumber;blockHash;index;hash;type;to;from;nonce;gasLimit;gasPrice;maxPriorityFeePerGas;maxFeePerGas;maxFeePerBlobGas;data;value;chainId;signature;accessList;blobVersionedHashes;authorizationList;#Q;constructor(Q,Y){this.provider=Y,this.blockNumber=Q.blockNumber!=null?Q.blockNumber:null,this.blockHash=Q.blockHash!=null?Q.blockHash:null,this.hash=Q.hash,this.index=Q.index,this.type=Q.type,this.from=Q.from,this.to=Q.to||null,this.gasLimit=Q.gasLimit,this.nonce=Q.nonce,this.data=Q.data,this.value=Q.value,this.gasPrice=Q.gasPrice,this.maxPriorityFeePerGas=Q.maxPriorityFeePerGas!=null?Q.maxPriorityFeePerGas:null,this.maxFeePerGas=Q.maxFeePerGas!=null?Q.maxFeePerGas:null,this.maxFeePerBlobGas=Q.maxFeePerBlobGas!=null?Q.maxFeePerBlobGas:null,this.chainId=Q.chainId,this.signature=Q.signature,this.accessList=Q.accessList!=null?Q.accessList:null,this.blobVersionedHashes=Q.blobVersionedHashes!=null?Q.blobVersionedHashes:null,this.authorizationList=Q.authorizationList!=null?Q.authorizationList:null,this.#Q=-1}toJSON(){const{blockNumber:Q,blockHash:Y,index:J,hash:X,type:q,to:G,from:W,nonce:V,data:$,signature:U,accessList:Z,blobVersionedHashes:K}=this;return{_type:"TransactionResponse",accessList:Z,blockNumber:Q,blockHash:Y,blobVersionedHashes:K,chainId:K0(this.chainId),data:$,from:W,gasLimit:K0(this.gasLimit),gasPrice:K0(this.gasPrice),hash:X,maxFeePerGas:K0(this.maxFeePerGas),maxPriorityFeePerGas:K0(this.maxPriorityFeePerGas),maxFeePerBlobGas:K0(this.maxFeePerBlobGas),nonce:V,signature:U,to:G,index:J,type:q,value:K0(this.value)}}async getBlock(){let Q=this.blockNumber;if(Q==null){const J=await this.getTransaction();if(J)Q=J.blockNumber}if(Q==null)return null;const Y=this.provider.getBlock(Q);if(Y==null)throw new Error("TODO");return Y}async getTransaction(){return this.provider.getTransaction(this.hash)}async confirmations(){if(this.blockNumber==null){const{tx:Y,blockNumber:J}=await a0({tx:this.getTransaction(),blockNumber:this.provider.getBlockNumber()});if(Y==null||Y.blockNumber==null)return 0;return J-Y.blockNumber+1}return await this.provider.getBlockNumber()-this.blockNumber+1}async wait(Q,Y){const J=Q==null?1:Q,X=Y==null?0:Y;let q=this.#Q,G=-1,W=q===-1?!0:!1;const V=async()=>{if(W)return null;const{blockNumber:K,nonce:M}=await a0({blockNumber:this.provider.getBlockNumber(),nonce:this.provider.getTransactionCount(this.from)});if(M<this.nonce){q=K;return}if(W)return null;const I=await this.getTransaction();if(I&&I.blockNumber!=null)return;if(G===-1){if(G=q-3,G<this.#Q)G=this.#Q}while(G<=K){if(W)return null;const z=await this.provider.getBlock(G,!0);if(z==null)return;for(let R of z)if(R===this.hash)return;for(let R=0;R<z.length;R++){const H=await z.getTransaction(R);if(H.from===this.from&&H.nonce===this.nonce){if(W)return null;const D=await this.provider.getTransactionReceipt(H.hash);if(D==null)return;if(K-D.blockNumber+1<J)return;let j="replaced";if(H.data===this.data&&H.to===this.to&&H.value===this.value)j="repriced";else if(H.data==="0x"&&H.from===H.to&&H.value===Pq)j="cancelled";x(!1,"transaction was replaced","TRANSACTION_REPLACED",{cancelled:j==="replaced"||j==="cancelled",reason:j,replacement:H.replaceableTransaction(q),hash:H.hash,receipt:D})}}G++}return},$=(K)=>{if(K==null||K.status!==0)return K;x(!1,"transaction execution reverted","CALL_EXCEPTION",{action:"sendTransaction",data:null,reason:null,invocation:null,revert:null,transaction:{to:K.to,from:K.from,data:""},receipt:K})},U=await this.provider.getTransactionReceipt(this.hash);if(J===0)return $(U);if(U){if(J===1||await U.confirmations()>=J)return $(U)}else if(await V(),J===0)return null;return await new Promise((K,M)=>{const I=[],z=()=>{I.forEach((H)=>H())};if(I.push(()=>{W=!0}),X>0){const H=setTimeout(()=>{z(),M(d9("wait for transaction timeout","TIMEOUT"))},X);I.push(()=>{clearTimeout(H)})}const R=async(H)=>{if(await H.confirmations()>=J){z();try{K($(H))}catch(D){M(D)}}};if(I.push(()=>{this.provider.off(this.hash,R)}),this.provider.on(this.hash,R),q>=0){const H=async()=>{try{await V()}catch(D){if(vQ(D,"TRANSACTION_REPLACED")){z(),M(D);return}}if(!W)this.provider.once("block",H)};I.push(()=>{this.provider.off("block",H)}),this.provider.once("block",H)}})}isMined(){return this.blockHash!=null}isLegacy(){return this.type===0}isBerlin(){return this.type===1}isLondon(){return this.type===2}isCancun(){return this.type===3}removedEvent(){return x(this.isMined(),"unmined transaction canot be orphaned","UNSUPPORTED_OPERATION",{operation:"removeEvent()"}),Nq(this)}reorderedEvent(Q){return x(this.isMined(),"unmined transaction canot be orphaned","UNSUPPORTED_OPERATION",{operation:"removeEvent()"}),x(!Q||Q.isMined(),"unmined 'other' transaction canot be orphaned","UNSUPPORTED_OPERATION",{operation:"removeEvent()"}),Cq(this,Q)}replaceableTransaction(Q){O(Number.isInteger(Q)&&Q>=0,"invalid startBlock","startBlock",Q);const Y=new KJ(this,this.provider);return Y.#Q=Q,Y}}var J9=function(Q,Y){if(Q.provider)return Q.provider;x(!1,"missing provider","UNSUPPORTED_OPERATION",{operation:Y})};async function Tq(Q,Y){let J=e9(Y);if(J.to!=null)J.to=D8(J.to,Q);if(J.from!=null){const X=J.from;J.from=Promise.all([Q.getAddress(),D8(X,Q)]).then(([q,G])=>{return O(q.toLowerCase()===G.toLowerCase(),"transaction from mismatch","tx.from",G),q})}else J.from=Q.getAddress();return await a0(J)}class QQ{provider;constructor(Q){s(this,{provider:Q||null})}async getNonce(Q){return J9(this,"getTransactionCount").getTransactionCount(await this.getAddress(),Q)}async populateCall(Q){return await Tq(this,Q)}async populateTransaction(Q){const Y=J9(this,"populateTransaction"),J=await Tq(this,Q);if(J.nonce==null)J.nonce=await this.getNonce("pending");if(J.gasLimit==null)J.gasLimit=await this.estimateGas(J);const X=await this.provider.getNetwork();if(J.chainId!=null){const G=h(J.chainId);O(G===X.chainId,"transaction chainId mismatch","tx.chainId",Q.chainId)}else J.chainId=X.chainId;const q=J.maxFeePerGas!=null||J.maxPriorityFeePerGas!=null;if(J.gasPrice!=null&&(J.type===2||q))O(!1,"eip-1559 transaction do not support gasPrice","tx",Q);else if((J.type===0||J.type===1)&&q)O(!1,"pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas","tx",Q);if((J.type===2||J.type==null)&&(J.maxFeePerGas!=null&&J.maxPriorityFeePerGas!=null))J.type=2;else if(J.type===0||J.type===1){const G=await Y.getFeeData();if(x(G.gasPrice!=null,"network does not support gasPrice","UNSUPPORTED_OPERATION",{operation:"getGasPrice"}),J.gasPrice==null)J.gasPrice=G.gasPrice}else{const G=await Y.getFeeData();if(J.type==null)if(G.maxFeePerGas!=null&&G.maxPriorityFeePerGas!=null){if(J.authorizationList&&J.authorizationList.length)J.type=4;else J.type=2;if(J.gasPrice!=null){const W=J.gasPrice;delete J.gasPrice,J.maxFeePerGas=W,J.maxPriorityFeePerGas=W}else{if(J.maxFeePerGas==null)J.maxFeePerGas=G.maxFeePerGas;if(J.maxPriorityFeePerGas==null)J.maxPriorityFeePerGas=G.maxPriorityFeePerGas}}else if(G.gasPrice!=null){if(x(!q,"network does not support EIP-1559","UNSUPPORTED_OPERATION",{operation:"populateTransaction"}),J.gasPrice==null)J.gasPrice=G.gasPrice;J.type=0}else x(!1,"failed to get consistent fee data","UNSUPPORTED_OPERATION",{operation:"signer.getFeeData"});else if(J.type===2||J.type===3||J.type===4){if(J.maxFeePerGas==null)J.maxFeePerGas=G.maxFeePerGas;if(J.maxPriorityFeePerGas==null)J.maxPriorityFeePerGas=G.maxPriorityFeePerGas}}return await a0(J)}async populateAuthorization(Q){const Y=Object.assign({},Q);if(Y.chainId==null)Y.chainId=(await J9(this,"getNetwork").getNetwork()).chainId;if(Y.nonce==null)Y.nonce=await this.getNonce();return Y}async estimateGas(Q){return J9(this,"estimateGas").estimateGas(await this.populateCall(Q))}async call(Q){return J9(this,"call").call(await this.populateCall(Q))}async resolveName(Q){return await J9(this,"resolveName").resolveName(Q)}async sendTransaction(Q){const Y=J9(this,"sendTransaction"),J=await this.populateTransaction(Q);delete J.from;const X=T0.from(J);return await Y.broadcastTransaction(await this.signTransaction(X))}authorize(Q){x(!1,"authorization not implemented for this signer","UNSUPPORTED_OPERATION",{operation:"authorize"})}}class JQ extends QQ{address;constructor(Q,Y){super(Y);s(this,{address:Q})}async getAddress(){return this.address}connect(Q){return new JQ(this.address,Q)}#Q(Q,Y){x(!1,`VoidSigner cannot sign ${Q}`,"UNSUPPORTED_OPERATION",{operation:Y})}async signTransaction(Q){this.#Q("transactions","signTransaction")}async signMessage(Q){this.#Q("messages","signMessage")}async signTypedData(Q,Y,J){this.#Q("typed-data","signTypedData")}}class Y9 extends QQ{address;#Q;constructor(Q,Y){super(Y);O(Q&&typeof Q.sign==="function","invalid private key","privateKey","[ REDACTED ]"),this.#Q=Q;const J=P8(this.signingKey.publicKey);s(this,{address:J})}get signingKey(){return this.#Q}get privateKey(){return this.signingKey.privateKey}async getAddress(){return this.address}connect(Q){return new Y9(this.#Q,Q)}async signTransaction(Q){Q=e9(Q);const{to:Y,from:J}=await a0({to:Q.to?D8(Q.to,this):void 0,from:Q.from?D8(Q.from,this):void 0});if(Y!=null)Q.to=Y;if(J!=null)Q.from=J;if(Q.from!=null)O(y(Q.from)===this.address,"transaction from address mismatch","tx.from",Q.from),delete Q.from;const X=T0.from(Q);return X.signature=this.signingKey.sign(X.unsignedHash),X.serialized}async signMessage(Q){return this.signMessageSync(Q)}signMessageSync(Q){return this.signingKey.sign(t9(Q)).serialized}authorizeSync(Q){O(typeof Q.address==="string","invalid address for authorizeSync","auth.address",Q);const Y=this.signingKey.sign($J(Q));return Object.assign({},{address:y(Q.address),nonce:h(Q.nonce||0),chainId:h(Q.chainId||0)},{signature:Y})}async authorize(Q){return Q=Object.assign({},Q,{address:await D8(Q.address,this)}),this.authorizeSync(await this.populateAuthorization(Q))}async signTypedData(Q,Y,J){const X=await L0.resolveNames(Q,Y,J,async(q)=>{x(this.provider!=null,"cannot resolve ENS names without a provider","UNSUPPORTED_OPERATION",{operation:"resolveName",info:{name:q}});const G=await this.provider.resolveName(q);return x(G!=null,"unconfigured ENS name","UNCONFIGURED_NAME",{value:q}),G});return this.signingKey.sign(L0.hash(X.domain,Y,X.value)).serialized}}var Fq=function(Q,Y){let J=97;return Q.reduce((X,q)=>{if(q===Y)J++;else if(q.match(v6))X.push(String.fromCharCode(J)+q);else J=97,X.push(q);return X},[])};function f6(Q,Y){for(let q=MJ.length-1;q>=0;q--)Q=Q.split(MJ[q]).join(Y.substring(2*q,2*q+2));const J=[],X=Q.replace(/(:|([0-9])|([A-Z][a-z]*))/g,(q,G,W,V)=>{if(W)for(let $=parseInt(W);$>=0;$--)J.push(";");else J.push(G.toLowerCase());return""});if(X)throw new Error(`leftovers: ${JSON.stringify(X)}`);return Fq(Fq(J,";"),":")}function wq(Q){return O(Q[0]==="0","unsupported auwl data","data",Q),f6(Q.substring(1+2*MJ.length),Q.substring(1,1+2*MJ.length))}var MJ=" !#$%&'()*+,-./<=>?@[]^_`{|}~",v6=/^[a-z]*$/i;class k5{locale;constructor(Q){s(this,{locale:Q})}split(Q){return Q.toLowerCase().split(/\s+/g)}join(Q){return Q.join(" ")}}class x5 extends k5{#Q;#J;constructor(Q,Y,J){super(Q);this.#Q=Y,this.#J=J,this.#Y=null}get _data(){return this.#Q}_decodeWords(){return wq(this.#Q)}#Y;#X(){if(this.#Y==null){const Q=this._decodeWords();if(j8(Q.join("\n")+"\n")!==this.#J)throw new Error(`BIP39 Wordlist for ${this.locale} FAILED`);this.#Y=Q}return this.#Y}getWord(Q){const Y=this.#X();return O(Q>=0&&Q<Y.length,`invalid word index: ${Q}`,"index",Q),Y[Q]}getWordIndex(Q){return this.#X().indexOf(Q)}}var b6="0erleonalorenseinceregesticitStanvetearctssi#ch2Athck&tneLl0And#Il.yLeOutO=S|S%b/ra@SurdU'0Ce[Cid|CountCu'Hie=IdOu,-Qui*Ro[TT]T%T*[Tu$0AptDD-tD*[Ju,M.UltV<)Vi)0Rob-0FairF%dRaid0A(EEntRee0Ead0MRRp%tS!_rmBumCoholErtI&LLeyLowMo,O}PhaReadySoT Ways0A>urAz(gOngOuntU'd0Aly,Ch%Ci|G G!GryIm$K!Noun)Nu$O` Sw T&naTiqueXietyY1ArtOlogyPe?P!Pro=Ril1ChCt-EaEnaGueMMedM%MyOundR<+Re,Ri=RowTTefa@Ti,Tw%k0KPe@SaultSetSi,SumeThma0H!>OmTa{T&dT.udeTra@0Ct]D.Gu,NtTh%ToTumn0Era+OcadoOid0AkeA*AyEsomeFulKw?d0Is:ByChel%C#D+GL<)Lc#y~MbooN<aNn RRelyRga(R*lSeS-SketTt!3A^AnAutyCau'ComeEfF%eG(Ha=H(dLie=LowLtN^Nef./TrayTt Twe&Y#d3Cyc!DKeNdOlogyRdR`Tt _{AdeAmeAnketA,EakE[IndOodO[omOu'UeUrUsh_rdAtDyIlMbNeNusOkO,Rd R(gRrowSsTtomUn)XY_{etA(AndA[A=EadEezeI{Id+IefIghtIngIskOccoliOk&OnzeOomO` OwnUsh2Bb!DdyD+tFf$oIldLbLkL!tNd!Nk Rd&Rg R,SS(e[SyTt Y Zz:Bba+B(B!CtusGeKe~LmM aMpNN$N)lNdyNn#NoeNvasNy#Pab!P.$Pta(RRb#RdRgoRpetRryRtSeShS(o/!Su$TT$ogT^Teg%yTt!UghtU'Ut]Ve3Il(gL yM|NsusNturyRe$Rta(_irAlkAmp]An+AosApt Ar+A'AtEapE{Ee'EfErryE,I{&IefIldIm}yOi)Oo'R#-U{!UnkUrn0G?Nnam#Rc!Tiz&TyVil_imApArifyAwAyE<ErkEv I{I|IffImbIn-IpO{OgO'O`OudOwnUbUmpU, Ut^_^A,C#utDeFfeeIlInL!@L%LumnMb(eMeMf%tM-Mm#Mp<yNc tNdu@NfirmNg*[N}@Nsid NtrolNv()OkOlPp PyR$ReRnR*@/Tt#U^UntryUp!Ur'Us(V Yo>_{Ad!AftAmA}AshAt AwlAzyEamEd.EekEwI{etImeIspIt-OpO[Ou^OwdUci$UelUi'Umb!Un^UshYY,$2BeLtu*PPbo?dRiousRr|Rta(R=Sh]/omTe3C!:DMa+MpN)Ng R(gShUght WnY3AlBa>BrisCadeCemb CideCl(eC%a>C*a'ErF&'F(eFyG*eLayLiv M<dMi'Ni$Nti,NyP?tP&dPos.P`PutyRi=ScribeS tSignSkSpair/royTailTe@VelopVi)Vo>3AgramAlAm#dAryCeE'lEtFf G.$Gn.yLemmaNn NosaurRe@RtSag*eScov Sea'ShSmi[S%d Splay/<)V tVideV%)Zzy5Ct%Cum|G~Lph(Ma(Na>NkeyN%OrSeUb!Ve_ftAg#AmaA,-AwEamE[IftIllInkIpI=OpUmY2CkMbNeR(g/T^Ty1Arf1Nam-:G G!RlyRnR`Sily/Sy1HoOlogyOnomy0GeItUca>1F%t0G1GhtTh 2BowD E@r-Eg<tEm|Eph<tEvat%I>Se0B?kBodyBra)Er+Ot]PloyPow Pty0Ab!A@DD![D%'EmyErgyF%)Ga+G(eH<)JoyLi,OughR-hRollSu*T Ti*TryVelope1Isode0U$Uip0AA'OdeOs]R%Upt0CapeSayS&)Ta>0Ern$H-s1Id&)IlOkeOl=1A@Amp!Ce[Ch<+C.eCludeCu'Ecu>Erci'Hau,Hib.I!I,ItOt-P<dPe@Pi*Pla(Po'P*[T&dTra0EEbrow:Br-CeCultyDeIntI`~L'MeMilyMousNNcyNtasyRmSh]TT$Th TigueUltV%.e3Atu*Bru?yD $EEdElMa!N)/iv$T^V W3B Ct]EldGu*LeLmLt N$NdNeNg NishReRmR,Sc$ShTT}[X_gAmeAshAtAv%EeIghtIpOatO{O%Ow UidUshY_mCusGIlLd~owOdOtR)Re,R+tRkRtu}RumRw?dSsil/ UndX_gi!AmeEqu|EshI&dIn+OgOntO,OwnOz&U.2ElNNnyRna)RyTu*:D+tInLaxy~ yMePRa+Rba+Rd&Rl-Rm|SSpTeTh U+Ze3N $NiusN*Nt!Nu(e/u*2O,0AntFtGg!Ng RaffeRlVe_dAn)A*A[IdeImp'ObeOomOryO=OwUe_tDde[LdOdO'RillaSpelSsipV nWn_bA)A(AntApeA[Av.yEatE&IdIefItOc yOupOwUnt_rdE[IdeIltIt?N3M:B.IrLfMm M, NdPpyRb%RdRshR=,TVeWkZ?d3AdAl`ArtAvyD+hogIght~oLmetLpNRo3Dd&Gh~NtPRe/%y5BbyCkeyLdLeLiday~owMeNeyOdPeRnRr%R'Sp.$/TelUrV 5BGeM<Mb!M%Nd*dNgryNtRd!RryRtSb<d3Brid:1EOn0EaEntifyLe2N%e4LLeg$L}[0A+Ita>M&'Mu}Pa@Po'Pro=Pul'0ChCludeComeC*a'DexD-a>Do%Du,ryF<tFl-tF%mHa!H .Iti$Je@JuryMa>N Noc|PutQuiryS<eSe@SideSpi*/$lTa@T e,ToVe,V.eVol=3On0L<dOla>Sue0Em1Ory:CketGu?RZz3AlousAns~yWel9BInKeUr}yY5D+I)MpNg!Ni%Nk/:Ng?oo3EnEpT^upY3CkDD}yNdNgdomSsTT^&TeTt&Wi4EeIfeO{Ow:BBelB%Dd DyKeMpNgua+PtopR+T T(UghUndryVaWWnWsu.Y Zy3Ad AfArnA=Ctu*FtGG$G&dIsu*M#NdNg`NsOp?dSs#Tt Vel3ArB tyBr?yC&'FeFtGhtKeMbM.NkOnQuid/Tt!VeZ?d5AdAnB, C$CkG-NelyNgOpTt yUdUn+VeY$5CkyGga+Mb N?N^Xury3R-s:Ch(eDG-G}tIdIlInJ%KeMm$NNa+Nda>NgoNs]Nu$P!Rb!R^Rg(R(eRketRria+SkSs/ T^T i$ThTrixTt XimumZe3AdowAnAsu*AtCh<-D$DiaLodyLtMb M%yNt]NuRcyR+R.RryShSsa+T$Thod3Dd!DnightLk~]M-NdNimumN%Nu>Rac!Rr%S ySs/akeXXedXtu*5Bi!DelDifyMM|N.%NkeyN, N`OnR$ReRn(gSqu.oTh T]T%Unta(U'VeVie5ChFf(LeLtiplySc!SeumShroomS-/Tu$3Self/ yTh:I=MePk(Rrow/yT]Tu*3ArCkEdGati=G!@I` PhewR=/TTw%kUtr$V WsXt3CeGht5B!I'M(eeOd!Rm$R`SeTab!TeTh(gTi)VelW5C!?Mb R'T:K0EyJe@Li+Scu*S =Ta(Vious0CurE<Tob 0Or1FF Fi)T&2L1Ay0DI=Ymp-0It0CeEI#L(eLy1EnEraIn]Po'T]1An+B.Ch?dD D(?yG<I|Ig($Ph<0Tr-h0H 0Tdo%T TputTside0AlEnEr0NN 0Yg&0/ 0O}:CtDd!GeIrLa)LmNdaNelN-N` P RadeR|RkRrotRtySsT^ThTi|TrolTt nU'VeYm|3A)AnutArAs<tL-<NN$tyNcilOp!Pp Rfe@Rm.Rs#T2O}OtoRa'Ys-$0AnoCn-Ctu*E)GGe#~LotNkO} Pe/olT^Zza_)A}tA,-A>AyEa'Ed+U{UgUn+2EmEtIntL?LeLi)NdNyOlPul?Rt]S.]Ssib!/TatoTt yV tyWd W _@i)Ai'Ed-tEf Epa*Es|EttyEv|I)IdeIm?yIntI%.yIs#Iva>IzeOb!mO)[Odu)Of.OgramOje@Omo>OofOp tyOsp O>@OudOvide2Bl-Dd(g~LpL'Mpk(N^PilPpyR^a'R.yRpo'R'ShTZz!3Ramid:99Al.yAntumArt E,]I{ItIzO>:Bb.Cco#CeCkD?DioIlInI'~yMpN^NdomN+PidReTeTh V&WZ%3AdyAlAs#BelBuildC$lCei=CipeC%dCyc!Du)F!@F%mFu'G]G*tGul?Je@LaxLea'LiefLyMa(Memb M(dMo=Nd NewNtOp&PairPeatPla)P%tQui*ScueSemb!Si,Sour)Sp#'SultTi*T*atTurnUn]Ve$ViewW?d2Y`m0BBb#CeChDeD+F!GhtGidNgOtPp!SkTu$V$V 5AdA,BotBu,CketM<)OfOkieOmSeTa>UghUndU>Y$5Bb DeGLeNNwayR$:DDd!D}[FeIlLadLm#L#LtLu>MeMp!NdTisfyToshiU)Usa+VeY1A!AnA*Att E}HemeHoolI&)I[%sOrp]OutRapRe&RiptRub1AAr^As#AtC#dC*tCt]Cur.yEdEkGm|Le@~M(?Ni%N'Nt&)RiesRvi)Ss]Tt!TupV&_dowAftAllowA*EdEllEriffIeldIftI}IpIv O{OeOotOpOrtOuld O=RimpRugUff!Y0Bl(gCkDeE+GhtGnL|Lk~yLv Mil?Mp!N)NgR&/ Tua>XZe1A>Et^IIllInIrtUll0AbAmEepEnd I)IdeIghtImOg<OtOwUsh0AllArtI!OkeOo`0A{AkeApIffOw0ApCc Ci$CkDaFtL?Ldi LidLut]L=Me#eNgOnRryRtUlUndUpUr)U`0A)A*Ati$AwnEakEci$EedEllEndH eI)Id IkeInIr.L.OilOns%O#OrtOtRayReadR(gY0Ua*UeezeUir*l_b!AdiumAffA+AirsAmpAndArtA>AyEakEelEmEpE*oI{IllIngO{Oma^O}OolOryO=Ra>gyReetRikeR#gRugg!Ud|UffUmb!Y!0Bje@Bm.BwayC)[ChDd&Ff G?G+,ItMm NNnyN'tP PplyP*meReRfa)R+Rpri'RroundR=ySpe@/a(1AllowAmpApArmE?EetIftImIngIt^Ord1MbolMptomRup/em:B!Ck!GIlL|LkNkPeR+tSk/eTtooXi3A^Am~NN<tNnisNtRm/Xt_nkAtEmeEnE%yE*EyIngIsOughtReeRi=RowUmbUnd 0CketDeG LtMb MeNyPRedSsueT!5A,BaccoDayDdl EGe` I!tK&MatoM%rowNeNgueNightOlO`PP-Pp!R^RnadoRtoi'SsT$Uri,W?dW WnY_{AdeAff-Ag-A(Ansf ApAshA=lAyEatEeEndI$IbeI{Igg ImIpOphyOub!U{UeUlyUmpetU,U`Y2BeIt]Mb!NaN}lRkeyRnRt!1El=EntyI)InI,O1PeP-$:5Ly5B*lla0Ab!Awa*C!Cov D DoFairFoldHappyIf%mIqueItIv 'KnownLo{TilUsu$Veil1Da>GradeHoldOnP Set1B<Ge0A+EEdEfulE![U$0Il.y:C<tCuumGueLidL!yL=NNishP%Rious/Ult3H-!L=tNd%Ntu*NueRbRifyRs]RyS'lT <3Ab!Br<tCiousCt%yDeoEw~a+Nta+Ol(Rtu$RusSaS.Su$T$Vid5C$I)IdLc<oLumeTeYa+:GeG#ItLk~LnutNtRfa*RmRri%ShSp/eT VeY3Al`Ap#ArA'lA` BDd(gEk&dIrdLcome/T_!AtEatEelEnE*IpIsp 0DeD`FeLd~NNdowNeNgNkNn Nt ReSdomSeShT}[5LfM<Nd OdOlRdRkRldRryR`_pE{E,!I,I>Ong::Rd3Ar~ow9UUngU`:3BraRo9NeO",y6="0x3c8acc1e7b08d8e76f9fda015ef48dc8c710a73cb7e0f77b2c18a9b5a7adde60",g5=null;class L8 extends x5{constructor(){super("en",b6,y6)}static wordlist(){if(g5==null)g5=new L8;return g5}}var Bq=function(Q){return(1<<Q)-1<<8-Q&255},h6=function(Q){return(1<<Q)-1&255},v5=function(Q,Y){if(D9("NFKD"),Y==null)Y=L8.wordlist();const J=Y.split(Q);O(J.length%3===0&&J.length>=12&&J.length<=24,"invalid mnemonic length","mnemonic","[ REDACTED ]");const X=new Uint8Array(Math.ceil(11*J.length/8));let q=0;for(let U=0;U<J.length;U++){let Z=Y.getWordIndex(J[U].normalize("NFKD"));O(Z>=0,`invalid mnemonic word at index ${U}`,"mnemonic","[ REDACTED ]");for(let K=0;K<11;K++){if(Z&1<<10-K)X[q>>3]|=1<<7-q%8;q++}}const G=32*J.length/3,W=J.length/3,V=Bq(W),$=T(I0(X.slice(0,G/8)))[0]&V;return O($===(X[X.length-1]&V),"invalid mnemonic checksum","mnemonic","[ REDACTED ]"),N(X.slice(0,G/8))},f5=function(Q,Y){if(O(Q.length%4===0&&Q.length>=16&&Q.length<=32,"invalid entropy size","entropy","[ REDACTED ]"),Y==null)Y=L8.wordlist();const J=[0];let X=11;for(let W=0;W<Q.length;W++)if(X>8)J[J.length-1]<<=8,J[J.length-1]|=Q[W],X-=8;else J[J.length-1]<<=X,J[J.length-1]|=Q[W]>>8-X,J.push(Q[W]&h6(8-X)),X+=3;const q=Q.length/4,G=parseInt(I0(Q).substring(2,4),16)&Bq(q);return J[J.length-1]<<=q,J[J.length-1]|=G>>8-q,Y.join(J.map((W)=>Y.getWord(W)))},b5={};class C8{phrase;password;wordlist;entropy;constructor(Q,Y,J,X,q){if(X==null)X="";if(q==null)q=L8.wordlist();V8(Q,b5,"Mnemonic"),s(this,{phrase:J,password:X,wordlist:q,entropy:Y})}computeSeed(){const Q=Z0("mnemonic"+this.password,"NFKD");return E0(Z0(this.phrase,"NFKD"),Q,2048,64,"sha512")}static fromPhrase(Q,Y,J){const X=v5(Q,J);return Q=f5(T(X),J),new C8(b5,X,Q,Y,J)}static fromEntropy(Q,Y,J){const X=T(Q,"entropy"),q=f5(X,J);return new C8(b5,N(X),q,Y,J)}static entropyToPhrase(Q,Y){const J=T(Q,"entropy");return f5(J,Y)}static phraseToEntropy(Q,Y){return v5(Q,Y)}static isValidMnemonic(Q,Y){try{return v5(Q,Y),!0}catch(J){}return!1}}var h5=function(Q){const Y=[];for(let J=0;J<Q.length;J+=4)Y.push(Q[J]<<24|Q[J+1]<<16|Q[J+2]<<8|Q[J+3]);return Y};/*! MIT License. Copyright 2015-2022 Richard Moore <me@ricmoo.com>. See LICENSE.txt. */var O0=function(Q,Y,J,X){if(J==="a"&&!X)throw new TypeError("Private accessor was defined without a getter");if(typeof Y==="function"?Q!==Y||!X:!Y.has(Q))throw new TypeError("Cannot read private member from an object whose class did not declare it");return J==="m"?X:J==="a"?X.call(Q):X?X.value:Y.get(Q)},y5=function(Q,Y,J,X,q){if(X==="m")throw new TypeError("Private method is not writable");if(X==="a"&&!q)throw new TypeError("Private accessor was defined without a setter");if(typeof Y==="function"?Q!==Y||!q:!Y.has(Q))throw new TypeError("Cannot write private member to an object whose class did not declare it");return X==="a"?q.call(Q,J):q?q.value=J:Y.set(Q,J),J},OJ,h0,e0,m6={16:10,24:12,32:14},_6=[1,2,4,8,16,32,64,128,27,54,108,216,171,77,154,47,94,188,99,198,151,53,106,212,179,125,250,239,197,145],y0=[99,124,119,123,242,107,111,197,48,1,103,43,254,215,171,118,202,130,201,125,250,89,71,240,173,212,162,175,156,164,114,192,183,253,147,38,54,63,247,204,52,165,229,241,113,216,49,21,4,199,35,195,24,150,5,154,7,18,128,226,235,39,178,117,9,131,44,26,27,110,90,160,82,59,214,179,41,227,47,132,83,209,0,237,32,252,177,91,106,203,190,57,74,76,88,207,208,239,170,251,67,77,51,133,69,249,2,127,80,60,159,168,81,163,64,143,146,157,56,245,188,182,218,33,16,255,243,210,205,12,19,236,95,151,68,23,196,167,126,61,100,93,25,115,96,129,79,220,34,42,144,136,70,238,184,20,222,94,11,219,224,50,58,10,73,6,36,92,194,211,172,98,145,149,228,121,231,200,55,109,141,213,78,169,108,86,244,234,101,122,174,8,186,120,37,46,28,166,180,198,232,221,116,31,75,189,139,138,112,62,181,102,72,3,246,14,97,53,87,185,134,193,29,158,225,248,152,17,105,217,142,148,155,30,135,233,206,85,40,223,140,161,137,13,191,230,66,104,65,153,45,15,176,84,187,22],IJ=[82,9,106,213,48,54,165,56,191,64,163,158,129,243,215,251,124,227,57,130,155,47,255,135,52,142,67,68,196,222,233,203,84,123,148,50,166,194,35,61,238,76,149,11,66,250,195,78,8,46,161,102,40,217,36,178,118,91,162,73,109,139,209,37,114,248,246,100,134,104,152,22,212,164,92,204,93,101,182,146,108,112,72,80,253,237,185,218,94,21,70,87,167,141,157,132,144,216,171,0,140,188,211,10,247,228,88,5,184,179,69,6,208,44,30,143,202,63,15,2,193,175,189,3,1,19,138,107,58,145,17,65,79,103,220,234,151,242,207,206,240,180,230,115,150,172,116,34,231,173,53,133,226,249,55,232,28,117,223,110,71,241,26,113,29,41,197,137,111,183,98,14,170,24,190,27,252,86,62,75,198,210,121,32,154,219,192,254,120,205,90,244,31,221,168,51,136,7,199,49,177,18,16,89,39,128,236,95,96,81,127,169,25,181,74,13,45,229,122,159,147,201,156,239,160,224,59,77,174,42,245,176,200,235,187,60,131,83,153,97,23,43,4,126,186,119,214,38,225,105,20,99,85,33,12,125],c6=[3328402341,4168907908,4000806809,4135287693,4294111757,3597364157,3731845041,2445657428,1613770832,33620227,3462883241,1445669757,3892248089,3050821474,1303096294,3967186586,2412431941,528646813,2311702848,4202528135,4026202645,2992200171,2387036105,4226871307,1101901292,3017069671,1604494077,1169141738,597466303,1403299063,3832705686,2613100635,1974974402,3791519004,1033081774,1277568618,1815492186,2118074177,4126668546,2211236943,1748251740,1369810420,3521504564,4193382664,3799085459,2883115123,1647391059,706024767,134480908,2512897874,1176707941,2646852446,806885416,932615841,168101135,798661301,235341577,605164086,461406363,3756188221,3454790438,1311188841,2142417613,3933566367,302582043,495158174,1479289972,874125870,907746093,3698224818,3025820398,1537253627,2756858614,1983593293,3084310113,2108928974,1378429307,3722699582,1580150641,327451799,2790478837,3117535592,0,3253595436,1075847264,3825007647,2041688520,3059440621,3563743934,2378943302,1740553945,1916352843,2487896798,2555137236,2958579944,2244988746,3151024235,3320835882,1336584933,3992714006,2252555205,2588757463,1714631509,293963156,2319795663,3925473552,67240454,4269768577,2689618160,2017213508,631218106,1269344483,2723238387,1571005438,2151694528,93294474,1066570413,563977660,1882732616,4059428100,1673313503,2008463041,2950355573,1109467491,537923632,3858759450,4260623118,3218264685,2177748300,403442708,638784309,3287084079,3193921505,899127202,2286175436,773265209,2479146071,1437050866,4236148354,2050833735,3362022572,3126681063,840505643,3866325909,3227541664,427917720,2655997905,2749160575,1143087718,1412049534,999329963,193497219,2353415882,3354324521,1807268051,672404540,2816401017,3160301282,369822493,2916866934,3688947771,1681011286,1949973070,336202270,2454276571,201721354,1210328172,3093060836,2680341085,3184776046,1135389935,3294782118,965841320,831886756,3554993207,4068047243,3588745010,2345191491,1849112409,3664604599,26054028,2983581028,2622377682,1235855840,3630984372,2891339514,4092916743,3488279077,3395642799,4101667470,1202630377,268961816,1874508501,4034427016,1243948399,1546530418,941366308,1470539505,1941222599,2546386513,3421038627,2715671932,3899946140,1042226977,2521517021,1639824860,227249030,260737669,3765465232,2084453954,1907733956,3429263018,2420656344,100860677,4160157185,470683154,3261161891,1781871967,2924959737,1773779408,394692241,2579611992,974986535,664706745,3655459128,3958962195,731420851,571543859,3530123707,2849626480,126783113,865375399,765172662,1008606754,361203602,3387549984,2278477385,2857719295,1344809080,2782912378,59542671,1503764984,160008576,437062935,1707065306,3622233649,2218934982,3496503480,2185314755,697932208,1512910199,504303377,2075177163,2824099068,1841019862,739644986],p6=[2781242211,2230877308,2582542199,2381740923,234877682,3184946027,2984144751,1418839493,1348481072,50462977,2848876391,2102799147,434634494,1656084439,3863849899,2599188086,1167051466,2636087938,1082771913,2281340285,368048890,3954334041,3381544775,201060592,3963727277,1739838676,4250903202,3930435503,3206782108,4149453988,2531553906,1536934080,3262494647,484572669,2923271059,1783375398,1517041206,1098792767,49674231,1334037708,1550332980,4098991525,886171109,150598129,2481090929,1940642008,1398944049,1059722517,201851908,1385547719,1699095331,1587397571,674240536,2704774806,252314885,3039795866,151914247,908333586,2602270848,1038082786,651029483,1766729511,3447698098,2682942837,454166793,2652734339,1951935532,775166490,758520603,3000790638,4004797018,4217086112,4137964114,1299594043,1639438038,3464344499,2068982057,1054729187,1901997871,2534638724,4121318227,1757008337,0,750906861,1614815264,535035132,3363418545,3988151131,3201591914,1183697867,3647454910,1265776953,3734260298,3566750796,3903871064,1250283471,1807470800,717615087,3847203498,384695291,3313910595,3617213773,1432761139,2484176261,3481945413,283769337,100925954,2180939647,4037038160,1148730428,3123027871,3813386408,4087501137,4267549603,3229630528,2315620239,2906624658,3156319645,1215313976,82966005,3747855548,3245848246,1974459098,1665278241,807407632,451280895,251524083,1841287890,1283575245,337120268,891687699,801369324,3787349855,2721421207,3431482436,959321879,1469301956,4065699751,2197585534,1199193405,2898814052,3887750493,724703513,2514908019,2696962144,2551808385,3516813135,2141445340,1715741218,2119445034,2872807568,2198571144,3398190662,700968686,3547052216,1009259540,2041044702,3803995742,487983883,1991105499,1004265696,1449407026,1316239930,504629770,3683797321,168560134,1816667172,3837287516,1570751170,1857934291,4014189740,2797888098,2822345105,2754712981,936633572,2347923833,852879335,1133234376,1500395319,3084545389,2348912013,1689376213,3533459022,3762923945,3034082412,4205598294,133428468,634383082,2949277029,2398386810,3913789102,403703816,3580869306,2297460856,1867130149,1918643758,607656988,4049053350,3346248884,1368901318,600565992,2090982877,2632479860,557719327,3717614411,3697393085,2249034635,2232388234,2430627952,1115438654,3295786421,2865522278,3633334344,84280067,33027830,303828494,2747425121,1600795957,4188952407,3496589753,2434238086,1486471617,658119965,3106381470,953803233,334231800,3005978776,857870609,3151128937,1890179545,2298973838,2805175444,3056442267,574365214,2450884487,550103529,1233637070,4289353045,2018519080,2057691103,2399374476,4166623649,2148108681,387583245,3664101311,836232934,3330556482,3100665960,3280093505,2955516313,2002398509,287182607,3413881008,4238890068,3597515707,975967766],u6=[1671808611,2089089148,2006576759,2072901243,4061003762,1807603307,1873927791,3310653893,810573872,16974337,1739181671,729634347,4263110654,3613570519,2883997099,1989864566,3393556426,2191335298,3376449993,2106063485,4195741690,1508618841,1204391495,4027317232,2917941677,3563566036,2734514082,2951366063,2629772188,2767672228,1922491506,3227229120,3082974647,4246528509,2477669779,644500518,911895606,1061256767,4144166391,3427763148,878471220,2784252325,3845444069,4043897329,1905517169,3631459288,827548209,356461077,67897348,3344078279,593839651,3277757891,405286936,2527147926,84871685,2595565466,118033927,305538066,2157648768,3795705826,3945188843,661212711,2999812018,1973414517,152769033,2208177539,745822252,439235610,455947803,1857215598,1525593178,2700827552,1391895634,994932283,3596728278,3016654259,695947817,3812548067,795958831,2224493444,1408607827,3513301457,0,3979133421,543178784,4229948412,2982705585,1542305371,1790891114,3410398667,3201918910,961245753,1256100938,1289001036,1491644504,3477767631,3496721360,4012557807,2867154858,4212583931,1137018435,1305975373,861234739,2241073541,1171229253,4178635257,33948674,2139225727,1357946960,1011120188,2679776671,2833468328,1374921297,2751356323,1086357568,2408187279,2460827538,2646352285,944271416,4110742005,3168756668,3066132406,3665145818,560153121,271589392,4279952895,4077846003,3530407890,3444343245,202643468,322250259,3962553324,1608629855,2543990167,1154254916,389623319,3294073796,2817676711,2122513534,1028094525,1689045092,1575467613,422261273,1939203699,1621147744,2174228865,1339137615,3699352540,577127458,712922154,2427141008,2290289544,1187679302,3995715566,3100863416,339486740,3732514782,1591917662,186455563,3681988059,3762019296,844522546,978220090,169743370,1239126601,101321734,611076132,1558493276,3260915650,3547250131,2901361580,1655096418,2443721105,2510565781,3828863972,2039214713,3878868455,3359869896,928607799,1840765549,2374762893,3580146133,1322425422,2850048425,1823791212,1459268694,4094161908,3928346602,1706019429,2056189050,2934523822,135794696,3134549946,2022240376,628050469,779246638,472135708,2800834470,3032970164,3327236038,3894660072,3715932637,1956440180,522272287,1272813131,3185336765,2340818315,2323976074,1888542832,1044544574,3049550261,1722469478,1222152264,50660867,4127324150,236067854,1638122081,895445557,1475980887,3117443513,2257655686,3243809217,489110045,2662934430,3778599393,4162055160,2561878936,288563729,1773916777,3648039385,2391345038,2493985684,2612407707,505560094,2274497927,3911240169,3460925390,1442818645,678973480,3749357023,2358182796,2717407649,2306869641,219617805,3218761151,3862026214,1120306242,1756942440,1103331905,2578459033,762796589,252780047,2966125488,1425844308,3151392187,372911126],d6=[1667474886,2088535288,2004326894,2071694838,4075949567,1802223062,1869591006,3318043793,808472672,16843522,1734846926,724270422,4278065639,3621216949,2880169549,1987484396,3402253711,2189597983,3385409673,2105378810,4210693615,1499065266,1195886990,4042263547,2913856577,3570689971,2728590687,2947541573,2627518243,2762274643,1920112356,3233831835,3082273397,4261223649,2475929149,640051788,909531756,1061110142,4160160501,3435941763,875846760,2779116625,3857003729,4059105529,1903268834,3638064043,825316194,353713962,67374088,3351728789,589522246,3284360861,404236336,2526454071,84217610,2593830191,117901582,303183396,2155911963,3806477791,3958056653,656894286,2998062463,1970642922,151591698,2206440989,741110872,437923380,454765878,1852748508,1515908788,2694904667,1381168804,993742198,3604373943,3014905469,690584402,3823320797,791638366,2223281939,1398011302,3520161977,0,3991743681,538992704,4244381667,2981218425,1532751286,1785380564,3419096717,3200178535,960056178,1246420628,1280103576,1482221744,3486468741,3503319995,4025428677,2863326543,4227536621,1128514950,1296947098,859002214,2240123921,1162203018,4193849577,33687044,2139062782,1347481760,1010582648,2678045221,2829640523,1364325282,2745433693,1077985408,2408548869,2459086143,2644360225,943212656,4126475505,3166494563,3065430391,3671750063,555836226,269496352,4294908645,4092792573,3537006015,3452783745,202118168,320025894,3974901699,1600119230,2543297077,1145359496,387397934,3301201811,2812801621,2122220284,1027426170,1684319432,1566435258,421079858,1936954854,1616945344,2172753945,1330631070,3705438115,572679748,707427924,2425400123,2290647819,1179044492,4008585671,3099120491,336870440,3739122087,1583276732,185277718,3688593069,3772791771,842159716,976899700,168435220,1229577106,101059084,606366792,1549591736,3267517855,3553849021,2897014595,1650632388,2442242105,2509612081,3840161747,2038008818,3890688725,3368567691,926374254,1835907034,2374863873,3587531953,1313788572,2846482505,1819063512,1448540844,4109633523,3941213647,1701162954,2054852340,2930698567,134748176,3132806511,2021165296,623210314,774795868,471606328,2795958615,3031746419,3334885783,3907527627,3722280097,1953799400,522133822,1263263126,3183336545,2341176845,2324333839,1886425312,1044267644,3048588401,1718004428,1212733584,50529542,4143317495,235803164,1633788866,892690282,1465383342,3115962473,2256965911,3250673817,488449850,2661202215,3789633753,4177007595,2560144171,286339874,1768537042,3654906025,2391705863,2492770099,2610673197,505291324,2273808917,3924369609,3469625735,1431699370,673740880,3755965093,2358021891,2711746649,2307489801,218961690,3217021541,3873845719,1111672452,1751693520,1094828930,2576986153,757954394,252645662,2964376443,1414855848,3149649517,370555436],l6=[1374988112,2118214995,437757123,975658646,1001089995,530400753,2902087851,1273168787,540080725,2910219766,2295101073,4110568485,1340463100,3307916247,641025152,3043140495,3736164937,632953703,1172967064,1576976609,3274667266,2169303058,2370213795,1809054150,59727847,361929877,3211623147,2505202138,3569255213,1484005843,1239443753,2395588676,1975683434,4102977912,2572697195,666464733,3202437046,4035489047,3374361702,2110667444,1675577880,3843699074,2538681184,1649639237,2976151520,3144396420,4269907996,4178062228,1883793496,2403728665,2497604743,1383856311,2876494627,1917518562,3810496343,1716890410,3001755655,800440835,2261089178,3543599269,807962610,599762354,33778362,3977675356,2328828971,2809771154,4077384432,1315562145,1708848333,101039829,3509871135,3299278474,875451293,2733856160,92987698,2767645557,193195065,1080094634,1584504582,3178106961,1042385657,2531067453,3711829422,1306967366,2438237621,1908694277,67556463,1615861247,429456164,3602770327,2302690252,1742315127,2968011453,126454664,3877198648,2043211483,2709260871,2084704233,4169408201,0,159417987,841739592,504459436,1817866830,4245618683,260388950,1034867998,908933415,168810852,1750902305,2606453969,607530554,202008497,2472011535,3035535058,463180190,2160117071,1641816226,1517767529,470948374,3801332234,3231722213,1008918595,303765277,235474187,4069246893,766945465,337553864,1475418501,2943682380,4003061179,2743034109,4144047775,1551037884,1147550661,1543208500,2336434550,3408119516,3069049960,3102011747,3610369226,1113818384,328671808,2227573024,2236228733,3535486456,2935566865,3341394285,496906059,3702665459,226906860,2009195472,733156972,2842737049,294930682,1206477858,2835123396,2700099354,1451044056,573804783,2269728455,3644379585,2362090238,2564033334,2801107407,2776292904,3669462566,1068351396,742039012,1350078989,1784663195,1417561698,4136440770,2430122216,775550814,2193862645,2673705150,1775276924,1876241833,3475313331,3366754619,270040487,3902563182,3678124923,3441850377,1851332852,3969562369,2203032232,3868552805,2868897406,566021896,4011190502,3135740889,1248802510,3936291284,699432150,832877231,708780849,3332740144,899835584,1951317047,4236429990,3767586992,866637845,4043610186,1106041591,2144161806,395441711,1984812685,1139781709,3433712980,3835036895,2664543715,1282050075,3240894392,1181045119,2640243204,25965917,4203181171,4211818798,3009879386,2463879762,3910161971,1842759443,2597806476,933301370,1509430414,3943906441,3467192302,3076639029,3776767469,2051518780,2631065433,1441952575,404016761,1942435775,1408749034,1610459739,3745345300,2017778566,3400528769,3110650942,941896748,3265478751,371049330,3168937228,675039627,4279080257,967311729,135050206,3635733660,1683407248,2076935265,3576870512,1215061108,3501741890],i6=[1347548327,1400783205,3273267108,2520393566,3409685355,4045380933,2880240216,2471224067,1428173050,4138563181,2441661558,636813900,4233094615,3620022987,2149987652,2411029155,1239331162,1730525723,2554718734,3781033664,46346101,310463728,2743944855,3328955385,3875770207,2501218972,3955191162,3667219033,768917123,3545789473,692707433,1150208456,1786102409,2029293177,1805211710,3710368113,3065962831,401639597,1724457132,3028143674,409198410,2196052529,1620529459,1164071807,3769721975,2226875310,486441376,2499348523,1483753576,428819965,2274680428,3075636216,598438867,3799141122,1474502543,711349675,129166120,53458370,2592523643,2782082824,4063242375,2988687269,3120694122,1559041666,730517276,2460449204,4042459122,2706270690,3446004468,3573941694,533804130,2328143614,2637442643,2695033685,839224033,1973745387,957055980,2856345839,106852767,1371368976,4181598602,1033297158,2933734917,1179510461,3046200461,91341917,1862534868,4284502037,605657339,2547432937,3431546947,2003294622,3182487618,2282195339,954669403,3682191598,1201765386,3917234703,3388507166,0,2198438022,1211247597,2887651696,1315723890,4227665663,1443857720,507358933,657861945,1678381017,560487590,3516619604,975451694,2970356327,261314535,3535072918,2652609425,1333838021,2724322336,1767536459,370938394,182621114,3854606378,1128014560,487725847,185469197,2918353863,3106780840,3356761769,2237133081,1286567175,3152976349,4255350624,2683765030,3160175349,3309594171,878443390,1988838185,3704300486,1756818940,1673061617,3403100636,272786309,1075025698,545572369,2105887268,4174560061,296679730,1841768865,1260232239,4091327024,3960309330,3497509347,1814803222,2578018489,4195456072,575138148,3299409036,446754879,3629546796,4011996048,3347532110,3252238545,4270639778,915985419,3483825537,681933534,651868046,2755636671,3828103837,223377554,2607439820,1649704518,3270937875,3901806776,1580087799,4118987695,3198115200,2087309459,2842678573,3016697106,1003007129,2802849917,1860738147,2077965243,164439672,4100872472,32283319,2827177882,1709610350,2125135846,136428751,3874428392,3652904859,3460984630,3572145929,3593056380,2939266226,824852259,818324884,3224740454,930369212,2801566410,2967507152,355706840,1257309336,4148292826,243256656,790073846,2373340630,1296297904,1422699085,3756299780,3818836405,457992840,3099667487,2135319889,77422314,1560382517,1945798516,788204353,1521706781,1385356242,870912086,325965383,2358957921,2050466060,2388260884,2313884476,4006521127,901210569,3990953189,1014646705,1503449823,1062597235,2031621326,3212035895,3931371469,1533017514,350174575,2256028891,2177544179,1052338372,741876788,1606591296,1914052035,213705253,2334669897,1107234197,1899603969,3725069491,2631447780,2422494913,1635502980,1893020342,1950903388,1120974935],n6=[2807058932,1699970625,2764249623,1586903591,1808481195,1173430173,1487645946,59984867,4199882800,1844882806,1989249228,1277555970,3623636965,3419915562,1149249077,2744104290,1514790577,459744698,244860394,3235995134,1963115311,4027744588,2544078150,4190530515,1608975247,2627016082,2062270317,1507497298,2200818878,567498868,1764313568,3359936201,2305455554,2037970062,1047239000,1910319033,1337376481,2904027272,2892417312,984907214,1243112415,830661914,861968209,2135253587,2011214180,2927934315,2686254721,731183368,1750626376,4246310725,1820824798,4172763771,3542330227,48394827,2404901663,2871682645,671593195,3254988725,2073724613,145085239,2280796200,2779915199,1790575107,2187128086,472615631,3029510009,4075877127,3802222185,4107101658,3201631749,1646252340,4270507174,1402811438,1436590835,3778151818,3950355702,3963161475,4020912224,2667994737,273792366,2331590177,104699613,95345982,3175501286,2377486676,1560637892,3564045318,369057872,4213447064,3919042237,1137477952,2658625497,1119727848,2340947849,1530455833,4007360968,172466556,266959938,516552836,0,2256734592,3980931627,1890328081,1917742170,4294704398,945164165,3575528878,958871085,3647212047,2787207260,1423022939,775562294,1739656202,3876557655,2530391278,2443058075,3310321856,547512796,1265195639,437656594,3121275539,719700128,3762502690,387781147,218828297,3350065803,2830708150,2848461854,428169201,122466165,3720081049,1627235199,648017665,4122762354,1002783846,2117360635,695634755,3336358691,4234721005,4049844452,3704280881,2232435299,574624663,287343814,612205898,1039717051,840019705,2708326185,793451934,821288114,1391201670,3822090177,376187827,3113855344,1224348052,1679968233,2361698556,1058709744,752375421,2431590963,1321699145,3519142200,2734591178,188127444,2177869557,3727205754,2384911031,3215212461,2648976442,2450346104,3432737375,1180849278,331544205,3102249176,4150144569,2952102595,2159976285,2474404304,766078933,313773861,2570832044,2108100632,1668212892,3145456443,2013908262,418672217,3070356634,2594734927,1852171925,3867060991,3473416636,3907448597,2614737639,919489135,164948639,2094410160,2997825956,590424639,2486224549,1723872674,3157750862,3399941250,3501252752,3625268135,2555048196,3673637356,1343127501,4130281361,3599595085,2957853679,1297403050,81781910,3051593425,2283490410,532201772,1367295589,3926170974,895287692,1953757831,1093597963,492483431,3528626907,1446242576,1192455638,1636604631,209336225,344873464,1015671571,669961897,3375740769,3857572124,2973530695,3747192018,1933530610,3464042516,935293895,3454686199,2858115069,1863638845,3683022916,4085369519,3292445032,875313188,1080017571,3279033885,621591778,1233856572,2504130317,24197544,3017672716,3835484340,3247465558,2220981195,3060847922,1551124588,1463996600],o6=[4104605777,1097159550,396673818,660510266,2875968315,2638606623,4200115116,3808662347,821712160,1986918061,3430322568,38544885,3856137295,718002117,893681702,1654886325,2975484382,3122358053,3926825029,4274053469,796197571,1290801793,1184342925,3556361835,2405426947,2459735317,1836772287,1381620373,3196267988,1948373848,3764988233,3385345166,3263785589,2390325492,1480485785,3111247143,3780097726,2293045232,548169417,3459953789,3746175075,439452389,1362321559,1400849762,1685577905,1806599355,2174754046,137073913,1214797936,1174215055,3731654548,2079897426,1943217067,1258480242,529487843,1437280870,3945269170,3049390895,3313212038,923313619,679998000,3215307299,57326082,377642221,3474729866,2041877159,133361907,1776460110,3673476453,96392454,878845905,2801699524,777231668,4082475170,2330014213,4142626212,2213296395,1626319424,1906247262,1846563261,562755902,3708173718,1040559837,3871163981,1418573201,3294430577,114585348,1343618912,2566595609,3186202582,1078185097,3651041127,3896688048,2307622919,425408743,3371096953,2081048481,1108339068,2216610296,0,2156299017,736970802,292596766,1517440620,251657213,2235061775,2933202493,758720310,265905162,1554391400,1532285339,908999204,174567692,1474760595,4002861748,2610011675,3234156416,3693126241,2001430874,303699484,2478443234,2687165888,585122620,454499602,151849742,2345119218,3064510765,514443284,4044981591,1963412655,2581445614,2137062819,19308535,1928707164,1715193156,4219352155,1126790795,600235211,3992742070,3841024952,836553431,1669664834,2535604243,3323011204,1243905413,3141400786,4180808110,698445255,2653899549,2989552604,2253581325,3252932727,3004591147,1891211689,2487810577,3915653703,4237083816,4030667424,2100090966,865136418,1229899655,953270745,3399679628,3557504664,4118925222,2061379749,3079546586,2915017791,983426092,2022837584,1607244650,2118541908,2366882550,3635996816,972512814,3283088770,1568718495,3499326569,3576539503,621982671,2895723464,410887952,2623762152,1002142683,645401037,1494807662,2595684844,1335535747,2507040230,4293295786,3167684641,367585007,3885750714,1865862730,2668221674,2960971305,2763173681,1059270954,2777952454,2724642869,1320957812,2194319100,2429595872,2815956275,77089521,3973773121,3444575871,2448830231,1305906550,4021308739,2857194700,2516901860,3518358430,1787304780,740276417,1699839814,1592394909,2352307457,2272556026,188821243,1729977011,3687994002,274084841,3594982253,3613494426,2701949495,4162096729,322734571,2837966542,1640576439,484830689,1202797690,3537852828,4067639125,349075736,3342319475,4157467219,4255800159,1030690015,1155237496,2951971274,1757691577,607398968,2738905026,499347990,3794078908,1011452712,227885567,2818666809,213114376,3034881240,1455525988,3414450555,850817237,1817998408,3092726480],r6=[0,235474187,470948374,303765277,941896748,908933415,607530554,708780849,1883793496,2118214995,1817866830,1649639237,1215061108,1181045119,1417561698,1517767529,3767586992,4003061179,4236429990,4069246893,3635733660,3602770327,3299278474,3400528769,2430122216,2664543715,2362090238,2193862645,2835123396,2801107407,3035535058,3135740889,3678124923,3576870512,3341394285,3374361702,3810496343,3977675356,4279080257,4043610186,2876494627,2776292904,3076639029,3110650942,2472011535,2640243204,2403728665,2169303058,1001089995,899835584,666464733,699432150,59727847,226906860,530400753,294930682,1273168787,1172967064,1475418501,1509430414,1942435775,2110667444,1876241833,1641816226,2910219766,2743034109,2976151520,3211623147,2505202138,2606453969,2302690252,2269728455,3711829422,3543599269,3240894392,3475313331,3843699074,3943906441,4178062228,4144047775,1306967366,1139781709,1374988112,1610459739,1975683434,2076935265,1775276924,1742315127,1034867998,866637845,566021896,800440835,92987698,193195065,429456164,395441711,1984812685,2017778566,1784663195,1683407248,1315562145,1080094634,1383856311,1551037884,101039829,135050206,437757123,337553864,1042385657,807962610,573804783,742039012,2531067453,2564033334,2328828971,2227573024,2935566865,2700099354,3001755655,3168937228,3868552805,3902563182,4203181171,4102977912,3736164937,3501741890,3265478751,3433712980,1106041591,1340463100,1576976609,1408749034,2043211483,2009195472,1708848333,1809054150,832877231,1068351396,766945465,599762354,159417987,126454664,361929877,463180190,2709260871,2943682380,3178106961,3009879386,2572697195,2538681184,2236228733,2336434550,3509871135,3745345300,3441850377,3274667266,3910161971,3877198648,4110568485,4211818798,2597806476,2497604743,2261089178,2295101073,2733856160,2902087851,3202437046,2968011453,3936291284,3835036895,4136440770,4169408201,3535486456,3702665459,3467192302,3231722213,2051518780,1951317047,1716890410,1750902305,1113818384,1282050075,1584504582,1350078989,168810852,67556463,371049330,404016761,841739592,1008918595,775550814,540080725,3969562369,3801332234,4035489047,4269907996,3569255213,3669462566,3366754619,3332740144,2631065433,2463879762,2160117071,2395588676,2767645557,2868897406,3102011747,3069049960,202008497,33778362,270040487,504459436,875451293,975658646,675039627,641025152,2084704233,1917518562,1615861247,1851332852,1147550661,1248802510,1484005843,1451044056,933301370,967311729,733156972,632953703,260388950,25965917,328671808,496906059,1206477858,1239443753,1543208500,1441952575,2144161806,1908694277,1675577880,1842759443,3610369226,3644379585,3408119516,3307916247,4011190502,3776767469,4077384432,4245618683,2809771154,2842737049,3144396420,3043140495,2673705150,2438237621,2203032232,2370213795],a6=[0,185469197,370938394,487725847,741876788,657861945,975451694,824852259,1483753576,1400783205,1315723890,1164071807,1950903388,2135319889,1649704518,1767536459,2967507152,3152976349,2801566410,2918353863,2631447780,2547432937,2328143614,2177544179,3901806776,3818836405,4270639778,4118987695,3299409036,3483825537,3535072918,3652904859,2077965243,1893020342,1841768865,1724457132,1474502543,1559041666,1107234197,1257309336,598438867,681933534,901210569,1052338372,261314535,77422314,428819965,310463728,3409685355,3224740454,3710368113,3593056380,3875770207,3960309330,4045380933,4195456072,2471224067,2554718734,2237133081,2388260884,3212035895,3028143674,2842678573,2724322336,4138563181,4255350624,3769721975,3955191162,3667219033,3516619604,3431546947,3347532110,2933734917,2782082824,3099667487,3016697106,2196052529,2313884476,2499348523,2683765030,1179510461,1296297904,1347548327,1533017514,1786102409,1635502980,2087309459,2003294622,507358933,355706840,136428751,53458370,839224033,957055980,605657339,790073846,2373340630,2256028891,2607439820,2422494913,2706270690,2856345839,3075636216,3160175349,3573941694,3725069491,3273267108,3356761769,4181598602,4063242375,4011996048,3828103837,1033297158,915985419,730517276,545572369,296679730,446754879,129166120,213705253,1709610350,1860738147,1945798516,2029293177,1239331162,1120974935,1606591296,1422699085,4148292826,4233094615,3781033664,3931371469,3682191598,3497509347,3446004468,3328955385,2939266226,2755636671,3106780840,2988687269,2198438022,2282195339,2501218972,2652609425,1201765386,1286567175,1371368976,1521706781,1805211710,1620529459,2105887268,1988838185,533804130,350174575,164439672,46346101,870912086,954669403,636813900,788204353,2358957921,2274680428,2592523643,2441661558,2695033685,2880240216,3065962831,3182487618,3572145929,3756299780,3270937875,3388507166,4174560061,4091327024,4006521127,3854606378,1014646705,930369212,711349675,560487590,272786309,457992840,106852767,223377554,1678381017,1862534868,1914052035,2031621326,1211247597,1128014560,1580087799,1428173050,32283319,182621114,401639597,486441376,768917123,651868046,1003007129,818324884,1503449823,1385356242,1333838021,1150208456,1973745387,2125135846,1673061617,1756818940,2970356327,3120694122,2802849917,2887651696,2637442643,2520393566,2334669897,2149987652,3917234703,3799141122,4284502037,4100872472,3309594171,3460984630,3545789473,3629546796,2050466060,1899603969,1814803222,1730525723,1443857720,1560382517,1075025698,1260232239,575138148,692707433,878443390,1062597235,243256656,91341917,409198410,325965383,3403100636,3252238545,3704300486,3620022987,3874428392,3990953189,4042459122,4227665663,2460449204,2578018489,2226875310,2411029155,3198115200,3046200461,2827177882,2743944855],s6=[0,218828297,437656594,387781147,875313188,958871085,775562294,590424639,1750626376,1699970625,1917742170,2135253587,1551124588,1367295589,1180849278,1265195639,3501252752,3720081049,3399941250,3350065803,3835484340,3919042237,4270507174,4085369519,3102249176,3051593425,2734591178,2952102595,2361698556,2177869557,2530391278,2614737639,3145456443,3060847922,2708326185,2892417312,2404901663,2187128086,2504130317,2555048196,3542330227,3727205754,3375740769,3292445032,3876557655,3926170974,4246310725,4027744588,1808481195,1723872674,1910319033,2094410160,1608975247,1391201670,1173430173,1224348052,59984867,244860394,428169201,344873464,935293895,984907214,766078933,547512796,1844882806,1627235199,2011214180,2062270317,1507497298,1423022939,1137477952,1321699145,95345982,145085239,532201772,313773861,830661914,1015671571,731183368,648017665,3175501286,2957853679,2807058932,2858115069,2305455554,2220981195,2474404304,2658625497,3575528878,3625268135,3473416636,3254988725,3778151818,3963161475,4213447064,4130281361,3599595085,3683022916,3432737375,3247465558,3802222185,4020912224,4172763771,4122762354,3201631749,3017672716,2764249623,2848461854,2331590177,2280796200,2431590963,2648976442,104699613,188127444,472615631,287343814,840019705,1058709744,671593195,621591778,1852171925,1668212892,1953757831,2037970062,1514790577,1463996600,1080017571,1297403050,3673637356,3623636965,3235995134,3454686199,4007360968,3822090177,4107101658,4190530515,2997825956,3215212461,2830708150,2779915199,2256734592,2340947849,2627016082,2443058075,172466556,122466165,273792366,492483431,1047239000,861968209,612205898,695634755,1646252340,1863638845,2013908262,1963115311,1446242576,1530455833,1277555970,1093597963,1636604631,1820824798,2073724613,1989249228,1436590835,1487645946,1337376481,1119727848,164948639,81781910,331544205,516552836,1039717051,821288114,669961897,719700128,2973530695,3157750862,2871682645,2787207260,2232435299,2283490410,2667994737,2450346104,3647212047,3564045318,3279033885,3464042516,3980931627,3762502690,4150144569,4199882800,3070356634,3121275539,2904027272,2686254721,2200818878,2384911031,2570832044,2486224549,3747192018,3528626907,3310321856,3359936201,3950355702,3867060991,4049844452,4234721005,1739656202,1790575107,2108100632,1890328081,1402811438,1586903591,1233856572,1149249077,266959938,48394827,369057872,418672217,1002783846,919489135,567498868,752375421,209336225,24197544,376187827,459744698,945164165,895287692,574624663,793451934,1679968233,1764313568,2117360635,1933530610,1343127501,1560637892,1243112415,1192455638,3704280881,3519142200,3336358691,3419915562,3907448597,3857572124,4075877127,4294704398,3029510009,3113855344,2927934315,2744104290,2159976285,2377486676,2594734927,2544078150],t6=[0,151849742,303699484,454499602,607398968,758720310,908999204,1059270954,1214797936,1097159550,1517440620,1400849762,1817998408,1699839814,2118541908,2001430874,2429595872,2581445614,2194319100,2345119218,3034881240,3186202582,2801699524,2951971274,3635996816,3518358430,3399679628,3283088770,4237083816,4118925222,4002861748,3885750714,1002142683,850817237,698445255,548169417,529487843,377642221,227885567,77089521,1943217067,2061379749,1640576439,1757691577,1474760595,1592394909,1174215055,1290801793,2875968315,2724642869,3111247143,2960971305,2405426947,2253581325,2638606623,2487810577,3808662347,3926825029,4044981591,4162096729,3342319475,3459953789,3576539503,3693126241,1986918061,2137062819,1685577905,1836772287,1381620373,1532285339,1078185097,1229899655,1040559837,923313619,740276417,621982671,439452389,322734571,137073913,19308535,3871163981,4021308739,4104605777,4255800159,3263785589,3414450555,3499326569,3651041127,2933202493,2815956275,3167684641,3049390895,2330014213,2213296395,2566595609,2448830231,1305906550,1155237496,1607244650,1455525988,1776460110,1626319424,2079897426,1928707164,96392454,213114376,396673818,514443284,562755902,679998000,865136418,983426092,3708173718,3557504664,3474729866,3323011204,4180808110,4030667424,3945269170,3794078908,2507040230,2623762152,2272556026,2390325492,2975484382,3092726480,2738905026,2857194700,3973773121,3856137295,4274053469,4157467219,3371096953,3252932727,3673476453,3556361835,2763173681,2915017791,3064510765,3215307299,2156299017,2307622919,2459735317,2610011675,2081048481,1963412655,1846563261,1729977011,1480485785,1362321559,1243905413,1126790795,878845905,1030690015,645401037,796197571,274084841,425408743,38544885,188821243,3613494426,3731654548,3313212038,3430322568,4082475170,4200115116,3780097726,3896688048,2668221674,2516901860,2366882550,2216610296,3141400786,2989552604,2837966542,2687165888,1202797690,1320957812,1437280870,1554391400,1669664834,1787304780,1906247262,2022837584,265905162,114585348,499347990,349075736,736970802,585122620,972512814,821712160,2595684844,2478443234,2293045232,2174754046,3196267988,3079546586,2895723464,2777952454,3537852828,3687994002,3234156416,3385345166,4142626212,4293295786,3841024952,3992742070,174567692,57326082,410887952,292596766,777231668,660510266,1011452712,893681702,1108339068,1258480242,1343618912,1494807662,1715193156,1865862730,1948373848,2100090966,2701949495,2818666809,3004591147,3122358053,2235061775,2352307457,2535604243,2653899549,3915653703,3764988233,4219352155,4067639125,3444575871,3294430577,3746175075,3594982253,836553431,953270745,600235211,718002117,367585007,484830689,133361907,251657213,2041877159,1891211689,1806599355,1654886325,1568718495,1418573201,1335535747,1184342925];class RJ{get key(){return O0(this,OJ,"f").slice()}constructor(Q){if(OJ.set(this,void 0),h0.set(this,void 0),e0.set(this,void 0),!(this instanceof RJ))throw Error("AES must be instanitated with `new`");y5(this,OJ,new Uint8Array(Q),"f");const Y=m6[this.key.length];if(Y==null)throw new TypeError("invalid key size (must be 16, 24 or 32 bytes)");y5(this,e0,[],"f"),y5(this,h0,[],"f");for(let U=0;U<=Y;U++)O0(this,e0,"f").push([0,0,0,0]),O0(this,h0,"f").push([0,0,0,0]);const J=(Y+1)*4,X=this.key.length/4,q=h5(this.key);let G;for(let U=0;U<X;U++)G=U>>2,O0(this,e0,"f")[G][U%4]=q[U],O0(this,h0,"f")[Y-G][U%4]=q[U];let W=0,V=X,$;while(V<J){if($=q[X-1],q[0]^=y0[$>>16&255]<<24^y0[$>>8&255]<<16^y0[$&255]<<8^y0[$>>24&255]^_6[W]<<24,W+=1,X!=8)for(let M=1;M<X;M++)q[M]^=q[M-1];else{for(let M=1;M<X/2;M++)q[M]^=q[M-1];$=q[X/2-1],q[X/2]^=y0[$&255]^y0[$>>8&255]<<8^y0[$>>16&255]<<16^y0[$>>24&255]<<24;for(let M=X/2+1;M<X;M++)q[M]^=q[M-1]}let U=0,Z,K;while(U<X&&V<J)Z=V>>2,K=V%4,O0(this,e0,"f")[Z][K]=q[U],O0(this,h0,"f")[Y-Z][K]=q[U++],V++}for(let U=1;U<Y;U++)for(let Z=0;Z<4;Z++)$=O0(this,h0,"f")[U][Z],O0(this,h0,"f")[U][Z]=r6[$>>24&255]^a6[$>>16&255]^s6[$>>8&255]^t6[$&255]}encrypt(Q){if(Q.length!=16)throw new TypeError("invalid plaintext size (must be 16 bytes)");const Y=O0(this,e0,"f").length-1,J=[0,0,0,0];let X=h5(Q);for(let W=0;W<4;W++)X[W]^=O0(this,e0,"f")[0][W];for(let W=1;W<Y;W++){for(let V=0;V<4;V++)J[V]=c6[X[V]>>24&255]^p6[X[(V+1)%4]>>16&255]^u6[X[(V+2)%4]>>8&255]^d6[X[(V+3)%4]&255]^O0(this,e0,"f")[W][V];X=J.slice()}const q=new Uint8Array(16);let G=0;for(let W=0;W<4;W++)G=O0(this,e0,"f")[Y][W],q[4*W]=(y0[X[W]>>24&255]^G>>24)&255,q[4*W+1]=(y0[X[(W+1)%4]>>16&255]^G>>16)&255,q[4*W+2]=(y0[X[(W+2)%4]>>8&255]^G>>8)&255,q[4*W+3]=(y0[X[(W+3)%4]&255]^G)&255;return q}decrypt(Q){if(Q.length!=16)throw new TypeError("invalid ciphertext size (must be 16 bytes)");const Y=O0(this,h0,"f").length-1,J=[0,0,0,0];let X=h5(Q);for(let W=0;W<4;W++)X[W]^=O0(this,h0,"f")[0][W];for(let W=1;W<Y;W++){for(let V=0;V<4;V++)J[V]=l6[X[V]>>24&255]^i6[X[(V+3)%4]>>16&255]^n6[X[(V+2)%4]>>8&255]^o6[X[(V+1)%4]&255]^O0(this,h0,"f")[W][V];X=J.slice()}const q=new Uint8Array(16);let G=0;for(let W=0;W<4;W++)G=O0(this,h0,"f")[Y][W],q[4*W]=(IJ[X[W]>>24&255]^G>>24)&255,q[4*W+1]=(IJ[X[(W+3)%4]>>16&255]^G>>16)&255,q[4*W+2]=(IJ[X[(W+2)%4]>>8&255]^G>>8)&255,q[4*W+3]=(IJ[X[(W+1)%4]&255]^G)&255;return q}}OJ=new WeakMap,h0=new WeakMap,e0=new WeakMap;class YQ{constructor(Q,Y,J){if(J&&!(this instanceof J))throw new Error(`${Q} must be instantiated with "new"`);Object.defineProperties(this,{aes:{enumerable:!0,value:new RJ(Y)},name:{enumerable:!0,value:Q}})}}var HJ=function(Q,Y,J,X,q){if(X==="m")throw new TypeError("Private method is not writable");if(X==="a"&&!q)throw new TypeError("Private accessor was defined without a setter");if(typeof Y==="function"?Q!==Y||!q:!Y.has(Q))throw new TypeError("Cannot write private member to an object whose class did not declare it");return X==="a"?q.call(Q,J):q?q.value=J:Y.set(Q,J),J},S9=function(Q,Y,J,X){if(J==="a"&&!X)throw new TypeError("Private accessor was defined without a getter");if(typeof Y==="function"?Q!==Y||!X:!Y.has(Q))throw new TypeError("Cannot read private member from an object whose class did not declare it");return J==="m"?X:J==="a"?X.call(Q):X?X.value:Y.get(Q)},XQ,N8;class qQ extends YQ{constructor(Q,Y){super("ECC",Q,qQ);if(XQ.set(this,void 0),N8.set(this,void 0),Y){if(Y.length%16)throw new TypeError("invalid iv size (must be 16 bytes)");HJ(this,XQ,new Uint8Array(Y),"f")}else HJ(this,XQ,new Uint8Array(16),"f");HJ(this,N8,this.iv,"f")}get iv(){return new Uint8Array(S9(this,XQ,"f"))}encrypt(Q){if(Q.length%16)throw new TypeError("invalid plaintext size (must be multiple of 16 bytes)");const Y=new Uint8Array(Q.length);for(let J=0;J<Q.length;J+=16){for(let X=0;X<16;X++)S9(this,N8,"f")[X]^=Q[J+X];HJ(this,N8,this.aes.encrypt(S9(this,N8,"f")),"f"),Y.set(S9(this,N8,"f"),J)}return Y}decrypt(Q){if(Q.length%16)throw new TypeError("invalid ciphertext size (must be multiple of 16 bytes)");const Y=new Uint8Array(Q.length);for(let J=0;J<Q.length;J+=16){const X=this.aes.decrypt(Q.subarray(J,J+16));for(let q=0;q<16;q++)Y[J+q]=X[q]^S9(this,N8,"f")[q],S9(this,N8,"f")[q]=Q[J+q]}return Y}}XQ=new WeakMap,N8=new WeakMap;var A9=function(Q,Y,J,X,q){if(X==="m")throw new TypeError("Private method is not writable");if(X==="a"&&!q)throw new TypeError("Private accessor was defined without a setter");if(typeof Y==="function"?Q!==Y||!q:!Y.has(Q))throw new TypeError("Cannot write private member to an object whose class did not declare it");return X==="a"?q.call(Q,J):q?q.value=J:Y.set(Q,J),J},m0=function(Q,Y,J,X){if(J==="a"&&!X)throw new TypeError("Private accessor was defined without a getter");if(typeof Y==="function"?Q!==Y||!X:!Y.has(Q))throw new TypeError("Cannot read private member from an object whose class did not declare it");return J==="m"?X:J==="a"?X.call(Q):X?X.value:Y.get(Q)},GQ,X9,_0;class f8 extends YQ{constructor(Q,Y){super("CTR",Q,f8);if(GQ.set(this,void 0),X9.set(this,void 0),_0.set(this,void 0),A9(this,_0,new Uint8Array(16),"f"),m0(this,_0,"f").fill(0),A9(this,GQ,m0(this,_0,"f"),"f"),A9(this,X9,16,"f"),Y==null)Y=1;if(typeof Y==="number")this.setCounterValue(Y);else this.setCounterBytes(Y)}get counter(){return new Uint8Array(m0(this,_0,"f"))}setCounterValue(Q){if(!Number.isInteger(Q)||Q<0||Q>Number.MAX_SAFE_INTEGER)throw new TypeError("invalid counter initial integer value");for(let Y=15;Y>=0;--Y)m0(this,_0,"f")[Y]=Q%256,Q=Math.floor(Q/256)}setCounterBytes(Q){if(Q.length!==16)throw new TypeError("invalid counter initial Uint8Array value length");m0(this,_0,"f").set(Q)}increment(){for(let Q=15;Q>=0;Q--)if(m0(this,_0,"f")[Q]===255)m0(this,_0,"f")[Q]=0;else{m0(this,_0,"f")[Q]++;break}}encrypt(Q){var Y,J;const X=new Uint8Array(Q);for(let q=0;q<X.length;q++){if(m0(this,X9,"f")===16)A9(this,GQ,this.aes.encrypt(m0(this,_0,"f")),"f"),A9(this,X9,0,"f"),this.increment();X[q]^=m0(this,GQ,"f")[A9(this,X9,(J=m0(this,X9,"f"),Y=J++,J),"f"),Y]}return X}decrypt(Q){return this.encrypt(Q)}}GQ=new WeakMap,X9=new WeakMap,_0=new WeakMap;function m5(Q){if(Q.length<16)throw new TypeError("PKCS#7 invalid length");const Y=Q[Q.length-1];if(Y>16)throw new TypeError("PKCS#7 padding byte out of range");const J=Q.length-Y;for(let X=0;X<Y;X++)if(Q[J+X]!==Y)throw new TypeError("PKCS#7 invalid padding byte");return new Uint8Array(Q.subarray(0,J))}function _5(Q){if(typeof Q==="string"&&!Q.startsWith("0x"))Q="0x"+Q;return d0(Q)}function E9(Q,Y){Q=String(Q);while(Q.length<Y)Q="0"+Q;return Q}function q9(Q){if(typeof Q==="string")return Z0(Q,"NFKC");return d0(Q)}function Y0(Q,Y){const J=Y.match(/^([a-z0-9$_.-]*)(:([a-z]+))?(!)?$/i);O(J!=null,"invalid path","path",Y);const X=J[1],q=J[3],G=J[4]==="!";let W=Q;for(let V of X.toLowerCase().split(".")){if(Array.isArray(W)){if(!V.match(/^[0-9]+$/))break;W=W[parseInt(V)]}else if(typeof W==="object"){let $=null;for(let U in W)if(U.toLowerCase()===V){$=W[U];break}W=$}else W=null;if(W==null)break}if(O(!G||W!=null,"missing required value","path",X),q&&W!=null){if(q==="int"){if(typeof W==="string"&&W.match(/^-?[0-9]+$/))return parseInt(W);else if(Number.isSafeInteger(W))return W}if(q==="number"){if(typeof W==="string"&&W.match(/^-?[0-9.]*$/))return parseFloat(W)}if(q==="data"){if(typeof W==="string")return _5(W)}if(q==="array"&&Array.isArray(W))return W;if(q===typeof W)return W;O(!1,`wrong type found for ${q} `,"path",X)}return W}function PJ(Q){try{const Y=JSON.parse(Q);if((Y.version!=null?parseInt(Y.version):0)===3)return!0}catch(Y){}return!1}var e6=function(Q,Y,J){if(Y0(Q,"crypto.cipher:string")==="aes-128-ctr"){const q=Y0(Q,"crypto.cipherparams.iv:data!"),G=new f8(Y,q);return N(G.decrypt(J))}x(!1,"unsupported cipher","UNSUPPORTED_OPERATION",{operation:"decrypt"})},DJ=function(Q,Y){const J=T(Y),X=Y0(Q,"crypto.ciphertext:data!"),q=N(i(o([J.slice(16,32),X]))).substring(2);O(q===Y0(Q,"crypto.mac:string!").toLowerCase(),"incorrect password","password","[ REDACTED ]");const G=e6(Q,J.slice(0,16),X),W=P8(G);if(Q.address){let U=Q.address.toLowerCase();if(!U.startsWith("0x"))U="0x"+U;O(y(U)===W,"keystore address/privateKey mismatch","address",Q.address)}const V={address:W,privateKey:G};if(Y0(Q,"x-ethers.version:string")==="0.1"){const U=J.slice(32,64),Z=Y0(Q,"x-ethers.mnemonicCiphertext:data!"),K=Y0(Q,"x-ethers.mnemonicCounter:data!"),M=new f8(U,K);V.mnemonic={path:Y0(Q,"x-ethers.path:string")||Aq,locale:Y0(Q,"x-ethers.locale:string")||"en",entropy:N(T(M.decrypt(Z)))}}return V},Eq=function(Q){const Y=Y0(Q,"crypto.kdf:string");if(Y&&typeof Y==="string"){if(Y.toLowerCase()==="scrypt"){const J=Y0(Q,"crypto.kdfparams.salt:data!"),X=Y0(Q,"crypto.kdfparams.n:int!"),q=Y0(Q,"crypto.kdfparams.r:int!"),G=Y0(Q,"crypto.kdfparams.p:int!");O(X>0&&(X&X-1)===0,"invalid kdf.N","kdf.N",X),O(q>0&&G>0,"invalid kdf","kdf",Y);const W=Y0(Q,"crypto.kdfparams.dklen:int!");return O(W===32,"invalid kdf.dklen","kdf.dflen",W),{name:"scrypt",salt:J,N:X,r:q,p:G,dkLen:64}}else if(Y.toLowerCase()==="pbkdf2"){const J=Y0(Q,"crypto.kdfparams.salt:data!"),X=Y0(Q,"crypto.kdfparams.prf:string!"),q=X.split("-").pop();O(q==="sha256"||q==="sha512","invalid kdf.pdf","kdf.pdf",X);const G=Y0(Q,"crypto.kdfparams.c:int!"),W=Y0(Q,"crypto.kdfparams.dklen:int!");return O(W===32,"invalid kdf.dklen","kdf.dklen",W),{name:"pbkdf2",salt:J,count:G,dkLen:W,algorithm:q}}}O(!1,"unsupported key-derivation function","kdf",Y)};function c5(Q,Y){const J=JSON.parse(Q),X=q9(Y),q=Eq(J);if(q.name==="pbkdf2"){const{salt:K,count:M,dkLen:I,algorithm:z}=q,R=E0(X,K,M,I,z);return DJ(J,R)}x(q.name==="scrypt","cannot be reached","UNKNOWN_ERROR",{params:q});const{salt:G,N:W,r:V,p:$,dkLen:U}=q,Z=I8(X,G,W,V,$,U);return DJ(J,Z)}var Sq=function(Q){return new Promise((Y)=>{setTimeout(()=>{Y()},Q)})};async function p5(Q,Y,J){const X=JSON.parse(Q),q=q9(Y),G=Eq(X);if(G.name==="pbkdf2"){if(J)J(0),await Sq(0);const{salt:M,count:I,dkLen:z,algorithm:R}=G,H=E0(q,M,I,z,R);if(J)J(1),await Sq(0);return DJ(X,H)}x(G.name==="scrypt","cannot be reached","UNKNOWN_ERROR",{params:G});const{salt:W,N:V,r:$,p:U,dkLen:Z}=G,K=await M8(q,W,V,$,U,Z,J);return DJ(X,K)}var kq=function(Q){const Y=Q.salt!=null?T(Q.salt,"options.salt"):V0(32);let J=1<<17,X=8,q=1;if(Q.scrypt){if(Q.scrypt.N)J=Q.scrypt.N;if(Q.scrypt.r)X=Q.scrypt.r;if(Q.scrypt.p)q=Q.scrypt.p}return O(typeof J==="number"&&J>0&&Number.isSafeInteger(J)&&(BigInt(J)&BigInt(J-1))===BigInt(0),"invalid scrypt N parameter","options.N",J),O(typeof X==="number"&&X>0&&Number.isSafeInteger(X),"invalid scrypt r parameter","options.r",X),O(typeof q==="number"&&q>0&&Number.isSafeInteger(q),"invalid scrypt p parameter","options.p",q),{name:"scrypt",dkLen:32,salt:Y,N:J,r:X,p:q}},xq=function(Q,Y,J,X){const q=T(J.privateKey,"privateKey"),G=X.iv!=null?T(X.iv,"options.iv"):V0(16);O(G.length===16,"invalid options.iv length","options.iv",X.iv);const W=X.uuid!=null?T(X.uuid,"options.uuid"):V0(16);O(W.length===16,"invalid options.uuid length","options.uuid",X.iv);const V=Q.slice(0,16),$=Q.slice(16,32),U=new f8(V,G),Z=T(U.encrypt(q)),K=i(o([$,Z])),M={address:J.address.substring(2).toLowerCase(),id:uQ(W),version:3,Crypto:{cipher:"aes-128-ctr",cipherparams:{iv:N(G).substring(2)},ciphertext:N(Z).substring(2),kdf:"scrypt",kdfparams:{salt:N(Y.salt).substring(2),n:Y.N,dklen:32,p:Y.p,r:Y.r},mac:K.substring(2)}};if(J.mnemonic){const I=X.client!=null?X.client:`ethers/${gQ}`,z=J.mnemonic.path||Aq,R=J.mnemonic.locale||"en",H=Q.slice(32,64),D=T(J.mnemonic.entropy,"account.mnemonic.entropy"),j=V0(16),w=new f8(H,j),P=T(w.encrypt(D)),C=new Date,L="UTC--"+(C.getUTCFullYear()+"-"+E9(C.getUTCMonth()+1,2)+"-"+E9(C.getUTCDate(),2)+"T"+E9(C.getUTCHours(),2)+"-"+E9(C.getUTCMinutes(),2)+"-"+E9(C.getUTCSeconds(),2)+".0Z--")+M.address;M["x-ethers"]={client:I,gethFilename:L,path:z,locale:R,mnemonicCounter:N(j).substring(2),mnemonicCiphertext:N(P).substring(2),version:"0.1"}}return JSON.stringify(M)};function WQ(Q,Y,J){if(J==null)J={};const X=q9(Y),q=kq(J),G=I8(X,q.salt,q.N,q.r,q.p,64);return xq(T(G),q,Q,J)}async function VQ(Q,Y,J){if(J==null)J={};const X=q9(Y),q=kq(J),G=await M8(X,q.salt,q.N,q.r,q.p,64,J.progressCallback);return xq(T(G),q,Q,J)}var Aq="m/44'/60'/0'/0/0";var LJ=function(Q,Y){let J="";while(Q)J=YW[Q%16]+J,Q=Math.trunc(Q/16);while(J.length<Y*2)J="0"+J;return"0x"+J},u5=function(Q){const Y=T(Q),J=P9(I0(I0(Y)),0,4),X=o([Y,J]);return _Q(X)},gq=function(Q,Y,J,X){const q=new Uint8Array(37);if(Q&b8)x(X!=null,"cannot derive child of neutered node","UNSUPPORTED_OPERATION",{operation:"deriveChild"}),q.set(T(X),1);else q.set(T(J));for(let W=24;W>=0;W-=8)q[33+(W>>3)]=Q>>24-W&255;const G=T(z8("sha512",Y,q));return{IL:G.slice(0,32),IR:G.slice(32)}},vq=function(Q,Y){const J=Y.split("/");if(O(J.length>0,"invalid path","path",Y),J[0]==="m")O(Q.depth===0,`cannot derive root path (i.e. path starting with "m/") for a node at non-zero depth ${Q.depth}`,"path",Y),J.shift();let X=Q;for(let q=0;q<J.length;q++){const G=J[q];if(G.match(/^[0-9]+'$/)){const W=parseInt(G.substring(0,G.length-1));O(W<b8,"invalid path index",`path[${q}]`,G),X=X.deriveChild(b8+W)}else if(G.match(/^[0-9]+$/)){const W=parseInt(G);O(W<b8,"invalid path index",`path[${q}]`,G),X=X.deriveChild(W)}else O(!1,"invalid path component",`path[${q}]`,G)}return X};var jJ="m/44'/60'/0'/0/0",QW=new Uint8Array([66,105,116,99,111,105,110,32,115,101,101,100]),b8=2147483648,JW=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),YW="0123456789abcdef",Q8={};class F0 extends Y9{publicKey;fingerprint;parentFingerprint;mnemonic;chainCode;path;index;depth;constructor(Q,Y,J,X,q,G,W,V,$){super(Y,$);V8(Q,Q8,"HDNodeWallet"),s(this,{publicKey:Y.compressedPublicKey});const U=P9(K8(I0(this.publicKey)),0,4);s(this,{parentFingerprint:J,fingerprint:U,chainCode:X,path:q,index:G,depth:W}),s(this,{mnemonic:V})}connect(Q){return new F0(Q8,this.signingKey,this.parentFingerprint,this.chainCode,this.path,this.index,this.depth,this.mnemonic,Q)}#Q(){const Q={address:this.address,privateKey:this.privateKey},Y=this.mnemonic;if(this.path&&Y&&Y.wordlist.locale==="en"&&Y.password==="")Q.mnemonic={path:this.path,locale:"en",entropy:Y.entropy};return Q}async encrypt(Q,Y){return await VQ(this.#Q(),Q,{progressCallback:Y})}encryptSync(Q){return WQ(this.#Q(),Q)}get extendedKey(){return x(this.depth<256,"Depth too deep","UNSUPPORTED_OPERATION",{operation:"extendedKey"}),u5(o(["0x0488ADE4",LJ(this.depth,1),this.parentFingerprint,LJ(this.index,4),this.chainCode,o(["0x00",this.privateKey])]))}hasPath(){return this.path!=null}neuter(){return new k9(Q8,this.address,this.publicKey,this.parentFingerprint,this.chainCode,this.path,this.index,this.depth,this.provider)}deriveChild(Q){const Y=$0(Q,"index");O(Y<=4294967295,"invalid index","index",Y);let J=this.path;if(J){if(J+="/"+(Y&~b8),Y&b8)J+="'"}const{IR:X,IL:q}=gq(Y,this.chainCode,this.publicKey,this.privateKey),G=new q0(l0((L9(q)+BigInt(this.privateKey))%JW,32));return new F0(Q8,G,this.fingerprint,N(X),J,Y,this.depth+1,this.mnemonic,this.provider)}derivePath(Q){return vq(this,Q)}static#J(Q,Y){O(s0(Q),"invalid seed","seed","[REDACTED]");const J=T(Q,"seed");O(J.length>=16&&J.length<=64,"invalid seed","seed","[REDACTED]");const X=T(z8("sha512",QW,J)),q=new q0(N(X.slice(0,32)));return new F0(Q8,q,"0x00000000",N(X.slice(32)),"m",0,0,Y,null)}static fromExtendedKey(Q){const Y=t(cQ(Q));O(Y.length===82||u5(Y.slice(0,78))===Q,"invalid extended key","extendedKey","[ REDACTED ]");const J=Y[4],X=N(Y.slice(5,9)),q=parseInt(N(Y.slice(9,13)).substring(2),16),G=N(Y.slice(13,45)),W=Y.slice(45,78);switch(N(Y.slice(0,4))){case"0x0488b21e":case"0x043587cf":{const V=N(W);return new k9(Q8,P8(V),V,X,G,null,q,J,null)}case"0x0488ade4":case"0x04358394 ":if(W[0]!==0)break;return new F0(Q8,new q0(W.slice(1)),X,G,null,q,J,null,null)}O(!1,"invalid extended key prefix","extendedKey","[ REDACTED ]")}static createRandom(Q,Y,J){if(Q==null)Q="";if(Y==null)Y=jJ;if(J==null)J=L8.wordlist();const X=C8.fromEntropy(V0(16),Q,J);return F0.#J(X.computeSeed(),X).derivePath(Y)}static fromMnemonic(Q,Y){if(!Y)Y=jJ;return F0.#J(Q.computeSeed(),Q).derivePath(Y)}static fromPhrase(Q,Y,J,X){if(Y==null)Y="";if(J==null)J=jJ;if(X==null)X=L8.wordlist();const q=C8.fromPhrase(Q,Y,X);return F0.#J(q.computeSeed(),q).derivePath(J)}static fromSeed(Q){return F0.#J(Q,null)}}class k9 extends JQ{publicKey;fingerprint;parentFingerprint;chainCode;path;index;depth;constructor(Q,Y,J,X,q,G,W,V,$){super(Y,$);V8(Q,Q8,"HDNodeVoidWallet"),s(this,{publicKey:J});const U=P9(K8(I0(J)),0,4);s(this,{publicKey:J,fingerprint:U,parentFingerprint:X,chainCode:q,path:G,index:W,depth:V})}connect(Q){return new k9(Q8,this.address,this.publicKey,this.parentFingerprint,this.chainCode,this.path,this.index,this.depth,Q)}get extendedKey(){return x(this.depth<256,"Depth too deep","UNSUPPORTED_OPERATION",{operation:"extendedKey"}),u5(o(["0x0488B21E",LJ(this.depth,1),this.parentFingerprint,LJ(this.index,4),this.chainCode,this.publicKey]))}hasPath(){return this.path!=null}deriveChild(Q){const Y=$0(Q,"index");O(Y<=4294967295,"invalid index","index",Y);let J=this.path;if(J){if(J+="/"+(Y&~b8),Y&b8)J+="'"}const{IR:X,IL:q}=gq(Y,this.chainCode,this.publicKey,null),G=q0.addPoints(q,this.publicKey,!0),W=P8(G);return new k9(Q8,W,G,this.fingerprint,N(X),J,Y,this.depth+1,this.provider)}derivePath(Q){return vq(this,Q)}}function CJ(Q){try{if(JSON.parse(Q).encseed)return!0}catch(Y){}return!1}function NJ(Q,Y){const J=JSON.parse(Q),X=q9(Y),q=y(Y0(J,"ethaddr:string!")),G=_5(Y0(J,"encseed:string!"));O(G&&G.length%16===0,"invalid encseed","json",Q);const W=T(E0(X,X,2000,32,"sha256")).slice(0,16),V=G.slice(0,16),$=G.slice(16),U=new qQ(W,V),Z=m5(T(U.decrypt($)));let K="";for(let M=0;M<Z.length;M++)K+=String.fromCharCode(Z[M]);return{address:q,privateKey:j8(K)}}var fq=function(Q){return new Promise((Y)=>{setTimeout(()=>{Y()},Q)})};class c0 extends Y9{constructor(Q,Y){if(typeof Q==="string"&&!Q.startsWith("0x"))Q="0x"+Q;let J=typeof Q==="string"?new q0(Q):Q;super(J,Y)}connect(Q){return new c0(this.signingKey,Q)}async encrypt(Q,Y){const J={address:this.address,privateKey:this.privateKey};return await VQ(J,Q,{progressCallback:Y})}encryptSync(Q){const Y={address:this.address,privateKey:this.privateKey};return WQ(Y,Q)}static#Q(Q){if(O(Q,"invalid JSON wallet","json","[ REDACTED ]"),("mnemonic"in Q)&&Q.mnemonic&&Q.mnemonic.locale==="en"){const J=C8.fromEntropy(Q.mnemonic.entropy),X=F0.fromMnemonic(J,Q.mnemonic.path);if(X.address===Q.address&&X.privateKey===Q.privateKey)return X;console.log("WARNING: JSON mismatch address/privateKey != mnemonic; fallback onto private key")}const Y=new c0(Q.privateKey);return O(Y.address===Q.address,"address/privateKey mismatch","json","[ REDACTED ]"),Y}static async fromEncryptedJson(Q,Y,J){let X=null;if(PJ(Q))X=await p5(Q,Y,J);else if(CJ(Q)){if(J)J(0),await fq(0);if(X=NJ(Q,Y),J)J(1),await fq(0)}return c0.#Q(X)}static fromEncryptedJsonSync(Q,Y){let J=null;if(PJ(Q))J=c5(Q,Y);else if(CJ(Q))J=NJ(Q,Y);else O(!1,"invalid JSON wallet","json","[ REDACTED ]");return c0.#Q(J)}static createRandom(Q){const Y=F0.createRandom();if(Q)return Y.connect(Q);return Y}static fromPhrase(Q,Y){const J=F0.fromPhrase(Q);if(Y)return J.connect(Y);return J}}function bq(Q){const Y=Q.length;let J=0,X=0;while(X<Y){let q=Q.charCodeAt(X++);if((q&4294967168)===0){J++;continue}else if((q&4294965248)===0)J+=2;else{if(q>=55296&&q<=56319){if(X<Y){const G=Q.charCodeAt(X);if((G&64512)===56320)++X,q=((q&1023)<<10)+(G&1023)+65536}}if((q&4294901760)===0)J+=3;else J+=4}}return J}function qW(Q,Y,J){const X=Q.length;let q=J,G=0;while(G<X){let W=Q.charCodeAt(G++);if((W&4294967168)===0){Y[q++]=W;continue}else if((W&4294965248)===0)Y[q++]=W>>6&31|192;else{if(W>=55296&&W<=56319){if(G<X){const V=Q.charCodeAt(G);if((V&64512)===56320)++G,W=((W&1023)<<10)+(V&1023)+65536}}if((W&4294901760)===0)Y[q++]=W>>12&15|224,Y[q++]=W>>6&63|128;else Y[q++]=W>>18&7|240,Y[q++]=W>>12&63|128,Y[q++]=W>>6&63|128}Y[q++]=W&63|128}}function VW(Q,Y,J){GW.encodeInto(Q,Y.subarray(J))}function yq(Q,Y,J){if(Q.length>WW)VW(Q,Y,J);else qW(Q,Y,J)}function d5(Q,Y,J){let X=Y;const q=X+J,G=[];let W="";while(X<q){const V=Q[X++];if((V&128)===0)G.push(V);else if((V&224)===192){const $=Q[X++]&63;G.push((V&31)<<6|$)}else if((V&240)===224){const $=Q[X++]&63,U=Q[X++]&63;G.push((V&31)<<12|$<<6|U)}else if((V&248)===240){const $=Q[X++]&63,U=Q[X++]&63,Z=Q[X++]&63;let K=(V&7)<<18|$<<12|U<<6|Z;if(K>65535)K-=65536,G.push(K>>>10&1023|55296),K=56320|K&1023;G.push(K)}else G.push(V);if(G.length>=UW)W+=String.fromCharCode(...G),G.length=0}if(G.length>0)W+=String.fromCharCode(...G);return W}function zW(Q,Y,J){const X=Q.subarray(Y,Y+J);return $W.decode(X)}function hq(Q,Y,J){if(J>ZW)return zW(Q,Y,J);else return d5(Q,Y,J)}var GW=new TextEncoder,WW=50,UW=4096,$W=new TextDecoder,ZW=200;class x9{constructor(Q,Y){this.type=Q,this.data=Y}}class C0 extends Error{constructor(Q){super(Q);const Y=Object.create(C0.prototype);Object.setPrototypeOf(this,Y),Object.defineProperty(this,"name",{configurable:!0,enumerable:!1,value:C0.name})}}function mq(Q,Y,J){const X=J/4294967296,q=J;Q.setUint32(Y,X),Q.setUint32(Y+4,q)}function TJ(Q,Y,J){const X=Math.floor(J/4294967296),q=J;Q.setUint32(Y,X),Q.setUint32(Y+4,q)}function FJ(Q,Y){const J=Q.getInt32(Y),X=Q.getUint32(Y+4);return J*4294967296+X}function _q(Q,Y){const J=Q.getUint32(Y),X=Q.getUint32(Y+4);return J*4294967296+X}var g9=4294967295;function OW({sec:Q,nsec:Y}){if(Q>=0&&Y>=0&&Q<=IW)if(Y===0&&Q<=MW){const J=new Uint8Array(4);return new DataView(J.buffer).setUint32(0,Q),J}else{const J=Q/4294967296,X=Q&4294967295,q=new Uint8Array(8),G=new DataView(q.buffer);return G.setUint32(0,Y<<2|J&3),G.setUint32(4,X),q}else{const J=new Uint8Array(12),X=new DataView(J.buffer);return X.setUint32(0,Y),TJ(X,4,Q),J}}function RW(Q){const Y=Q.getTime(),J=Math.floor(Y/1000),X=(Y-J*1000)*1e6,q=Math.floor(X/1e9);return{sec:J+q,nsec:X-q*1e9}}function HW(Q){if(Q instanceof Date){const Y=RW(Q);return OW(Y)}else return null}function DW(Q){const Y=new DataView(Q.buffer,Q.byteOffset,Q.byteLength);switch(Q.byteLength){case 4:return{sec:Y.getUint32(0),nsec:0};case 8:{const J=Y.getUint32(0),X=Y.getUint32(4),q=(J&3)*4294967296+X,G=J>>>2;return{sec:q,nsec:G}}case 12:{const J=FJ(Y,4),X=Y.getUint32(0);return{sec:J,nsec:X}}default:throw new C0(`Unrecognized data size for timestamp (expected 4, 8, or 12): ${Q.length}`)}}function PW(Q){const Y=DW(Q);return new Date(Y.sec*1000+Y.nsec/1e6)}var KW=-1,MW=4294967295,IW=17179869183,cq={type:KW,encode:HW,decode:PW};class G9{constructor(){this.builtInEncoders=[],this.builtInDecoders=[],this.encoders=[],this.decoders=[],this.register(cq)}register({type:Q,encode:Y,decode:J}){if(Q>=0)this.encoders[Q]=Y,this.decoders[Q]=J;else{const X=-1-Q;this.builtInEncoders[X]=Y,this.builtInDecoders[X]=J}}tryToEncode(Q,Y){for(let J=0;J<this.builtInEncoders.length;J++){const X=this.builtInEncoders[J];if(X!=null){const q=X(Q,Y);if(q!=null){const G=-1-J;return new x9(G,q)}}}for(let J=0;J<this.encoders.length;J++){const X=this.encoders[J];if(X!=null){const q=X(Q,Y);if(q!=null)return new x9(J,q)}}if(Q instanceof x9)return Q;return null}decode(Q,Y,J){const X=Y<0?this.builtInDecoders[-1-Y]:this.decoders[Y];if(X)return X(Q,Y,J);else return new x9(Y,Q)}}G9.defaultCodec=new G9;var jW=function(Q){return Q instanceof ArrayBuffer||typeof SharedArrayBuffer!=="undefined"&&Q instanceof SharedArrayBuffer};function UQ(Q){if(Q instanceof Uint8Array)return Q;else if(ArrayBuffer.isView(Q))return new Uint8Array(Q.buffer,Q.byteOffset,Q.byteLength);else if(jW(Q))return new Uint8Array(Q);else return Uint8Array.from(Q)}var LW=100,CW=2048;class wJ{constructor(Q){this.entered=!1,this.extensionCodec=Q?.extensionCodec??G9.defaultCodec,this.context=Q?.context,this.useBigInt64=Q?.useBigInt64??!1,this.maxDepth=Q?.maxDepth??LW,this.initialBufferSize=Q?.initialBufferSize??CW,this.sortKeys=Q?.sortKeys??!1,this.forceFloat32=Q?.forceFloat32??!1,this.ignoreUndefined=Q?.ignoreUndefined??!1,this.forceIntegerToFloat=Q?.forceIntegerToFloat??!1,this.pos=0,this.view=new DataView(new ArrayBuffer(this.initialBufferSize)),this.bytes=new Uint8Array(this.view.buffer)}clone(){return new wJ({extensionCodec:this.extensionCodec,context:this.context,useBigInt64:this.useBigInt64,maxDepth:this.maxDepth,initialBufferSize:this.initialBufferSize,sortKeys:this.sortKeys,forceFloat32:this.forceFloat32,ignoreUndefined:this.ignoreUndefined,forceIntegerToFloat:this.forceIntegerToFloat})}reinitializeState(){this.pos=0}encodeSharedRef(Q){if(this.entered)return this.clone().encodeSharedRef(Q);try{return this.entered=!0,this.reinitializeState(),this.doEncode(Q,1),this.bytes.subarray(0,this.pos)}finally{this.entered=!1}}encode(Q){if(this.entered)return this.clone().encode(Q);try{return this.entered=!0,this.reinitializeState(),this.doEncode(Q,1),this.bytes.slice(0,this.pos)}finally{this.entered=!1}}doEncode(Q,Y){if(Y>this.maxDepth)throw new Error(`Too deep objects in depth ${Y}`);if(Q==null)this.encodeNil();else if(typeof Q==="boolean")this.encodeBoolean(Q);else if(typeof Q==="number")if(!this.forceIntegerToFloat)this.encodeNumber(Q);else this.encodeNumberAsFloat(Q);else if(typeof Q==="string")this.encodeString(Q);else if(this.useBigInt64&&typeof Q==="bigint")this.encodeBigInt64(Q);else this.encodeObject(Q,Y)}ensureBufferSizeToWrite(Q){const Y=this.pos+Q;if(this.view.byteLength<Y)this.resizeBuffer(Y*2)}resizeBuffer(Q){const Y=new ArrayBuffer(Q),J=new Uint8Array(Y),X=new DataView(Y);J.set(this.bytes),this.view=X,this.bytes=J}encodeNil(){this.writeU8(192)}encodeBoolean(Q){if(Q===!1)this.writeU8(194);else this.writeU8(195)}encodeNumber(Q){if(!this.forceIntegerToFloat&&Number.isSafeInteger(Q))if(Q>=0)if(Q<128)this.writeU8(Q);else if(Q<256)this.writeU8(204),this.writeU8(Q);else if(Q<65536)this.writeU8(205),this.writeU16(Q);else if(Q<4294967296)this.writeU8(206),this.writeU32(Q);else if(!this.useBigInt64)this.writeU8(207),this.writeU64(Q);else this.encodeNumberAsFloat(Q);else if(Q>=-32)this.writeU8(224|Q+32);else if(Q>=-128)this.writeU8(208),this.writeI8(Q);else if(Q>=-32768)this.writeU8(209),this.writeI16(Q);else if(Q>=-2147483648)this.writeU8(210),this.writeI32(Q);else if(!this.useBigInt64)this.writeU8(211),this.writeI64(Q);else this.encodeNumberAsFloat(Q);else this.encodeNumberAsFloat(Q)}encodeNumberAsFloat(Q){if(this.forceFloat32)this.writeU8(202),this.writeF32(Q);else this.writeU8(203),this.writeF64(Q)}encodeBigInt64(Q){if(Q>=BigInt(0))this.writeU8(207),this.writeBigUint64(Q);else this.writeU8(211),this.writeBigInt64(Q)}writeStringHeader(Q){if(Q<32)this.writeU8(160+Q);else if(Q<256)this.writeU8(217),this.writeU8(Q);else if(Q<65536)this.writeU8(218),this.writeU16(Q);else if(Q<4294967296)this.writeU8(219),this.writeU32(Q);else throw new Error(`Too long string: ${Q} bytes in UTF-8`)}encodeString(Q){const J=bq(Q);this.ensureBufferSizeToWrite(5+J),this.writeStringHeader(J),yq(Q,this.bytes,this.pos),this.pos+=J}encodeObject(Q,Y){const J=this.extensionCodec.tryToEncode(Q,this.context);if(J!=null)this.encodeExtension(J);else if(Array.isArray(Q))this.encodeArray(Q,Y);else if(ArrayBuffer.isView(Q))this.encodeBinary(Q);else if(typeof Q==="object")this.encodeMap(Q,Y);else throw new Error(`Unrecognized object: ${Object.prototype.toString.apply(Q)}`)}encodeBinary(Q){const Y=Q.byteLength;if(Y<256)this.writeU8(196),this.writeU8(Y);else if(Y<65536)this.writeU8(197),this.writeU16(Y);else if(Y<4294967296)this.writeU8(198),this.writeU32(Y);else throw new Error(`Too large binary: ${Y}`);const J=UQ(Q);this.writeU8a(J)}encodeArray(Q,Y){const J=Q.length;if(J<16)this.writeU8(144+J);else if(J<65536)this.writeU8(220),this.writeU16(J);else if(J<4294967296)this.writeU8(221),this.writeU32(J);else throw new Error(`Too large array: ${J}`);for(let X of Q)this.doEncode(X,Y+1)}countWithoutUndefined(Q,Y){let J=0;for(let X of Y)if(Q[X]!==void 0)J++;return J}encodeMap(Q,Y){const J=Object.keys(Q);if(this.sortKeys)J.sort();const X=this.ignoreUndefined?this.countWithoutUndefined(Q,J):J.length;if(X<16)this.writeU8(128+X);else if(X<65536)this.writeU8(222),this.writeU16(X);else if(X<4294967296)this.writeU8(223),this.writeU32(X);else throw new Error(`Too large map object: ${X}`);for(let q of J){const G=Q[q];if(!(this.ignoreUndefined&&G===void 0))this.encodeString(q),this.doEncode(G,Y+1)}}encodeExtension(Q){if(typeof Q.data==="function"){const J=Q.data(this.pos+6),X=J.length;if(X>=4294967296)throw new Error(`Too large extension object: ${X}`);this.writeU8(201),this.writeU32(X),this.writeI8(Q.type),this.writeU8a(J);return}const Y=Q.data.length;if(Y===1)this.writeU8(212);else if(Y===2)this.writeU8(213);else if(Y===4)this.writeU8(214);else if(Y===8)this.writeU8(215);else if(Y===16)this.writeU8(216);else if(Y<256)this.writeU8(199),this.writeU8(Y);else if(Y<65536)this.writeU8(200),this.writeU16(Y);else if(Y<4294967296)this.writeU8(201),this.writeU32(Y);else throw new Error(`Too large extension object: ${Y}`);this.writeI8(Q.type),this.writeU8a(Q.data)}writeU8(Q){this.ensureBufferSizeToWrite(1),this.view.setUint8(this.pos,Q),this.pos++}writeU8a(Q){const Y=Q.length;this.ensureBufferSizeToWrite(Y),this.bytes.set(Q,this.pos),this.pos+=Y}writeI8(Q){this.ensureBufferSizeToWrite(1),this.view.setInt8(this.pos,Q),this.pos++}writeU16(Q){this.ensureBufferSizeToWrite(2),this.view.setUint16(this.pos,Q),this.pos+=2}writeI16(Q){this.ensureBufferSizeToWrite(2),this.view.setInt16(this.pos,Q),this.pos+=2}writeU32(Q){this.ensureBufferSizeToWrite(4),this.view.setUint32(this.pos,Q),this.pos+=4}writeI32(Q){this.ensureBufferSizeToWrite(4),this.view.setInt32(this.pos,Q),this.pos+=4}writeF32(Q){this.ensureBufferSizeToWrite(4),this.view.setFloat32(this.pos,Q),this.pos+=4}writeF64(Q){this.ensureBufferSizeToWrite(8),this.view.setFloat64(this.pos,Q),this.pos+=8}writeU64(Q){this.ensureBufferSizeToWrite(8),mq(this.view,this.pos,Q),this.pos+=8}writeI64(Q){this.ensureBufferSizeToWrite(8),TJ(this.view,this.pos,Q),this.pos+=8}writeBigUint64(Q){this.ensureBufferSizeToWrite(8),this.view.setBigUint64(this.pos,Q),this.pos+=8}writeBigInt64(Q){this.ensureBufferSizeToWrite(8),this.view.setBigInt64(this.pos,Q),this.pos+=8}}function l5(Q,Y){return new wJ(Y).encodeSharedRef(Q)}function BJ(Q){return`${Q<0?"-":""}0x${Math.abs(Q).toString(16).padStart(2,"0")}`}var NW=16,TW=16;class i5{constructor(Q=NW,Y=TW){this.hit=0,this.miss=0,this.maxKeyLength=Q,this.maxLengthPerKey=Y,this.caches=[];for(let J=0;J<this.maxKeyLength;J++)this.caches.push([])}canBeCached(Q){return Q>0&&Q<=this.maxKeyLength}find(Q,Y,J){const X=this.caches[J-1];Q:for(let q of X){const G=q.bytes;for(let W=0;W<J;W++)if(G[W]!==Q[Y+W])continue Q;return q.str}return null}store(Q,Y){const J=this.caches[Q.length-1],X={bytes:Q,str:Y};if(J.length>=this.maxLengthPerKey)J[Math.random()*J.length|0]=X;else J.push(X)}decode(Q,Y,J){const X=this.find(Q,Y,J);if(X!=null)return this.hit++,X;this.miss++;const q=d5(Q,Y,J),G=Uint8Array.prototype.slice.call(Q,Y,Y+J);return this.store(G,q),q}}var n5="array",ZQ="map_key",uq="map_value",FW=(Q)=>{if(typeof Q==="string"||typeof Q==="number")return Q;throw new C0("The type of key must be string or number but "+typeof Q)};class dq{constructor(){this.stack=[],this.stackHeadPosition=-1}get length(){return this.stackHeadPosition+1}top(){return this.stack[this.stackHeadPosition]}pushArrayState(Q){const Y=this.getUninitializedStateFromPool();Y.type=n5,Y.position=0,Y.size=Q,Y.array=new Array(Q)}pushMapState(Q){const Y=this.getUninitializedStateFromPool();Y.type=ZQ,Y.readCount=0,Y.size=Q,Y.map={}}getUninitializedStateFromPool(){if(this.stackHeadPosition++,this.stackHeadPosition===this.stack.length){const Q={type:void 0,size:0,array:void 0,position:0,readCount:0,map:void 0,key:null};this.stack.push(Q)}return this.stack[this.stackHeadPosition]}release(Q){if(this.stack[this.stackHeadPosition]!==Q)throw new Error("Invalid stack state. Released state is not on top of the stack.");if(Q.type===n5){const J=Q;J.size=0,J.array=void 0,J.position=0,J.type=void 0}if(Q.type===ZQ||Q.type===uq){const J=Q;J.size=0,J.map=void 0,J.readCount=0,J.type=void 0}this.stackHeadPosition--}reset(){this.stack.length=0,this.stackHeadPosition=-1}}var $Q=-1,o5=new DataView(new ArrayBuffer(0)),wW=new Uint8Array(o5.buffer);try{o5.getInt8(0)}catch(Q){if(!(Q instanceof RangeError))throw new Error("This module is not supported in the current JavaScript engine because DataView does not throw RangeError on out-of-bounds access")}var pq=new RangeError("Insufficient data"),BW=new i5;class SJ{constructor(Q){this.totalPos=0,this.pos=0,this.view=o5,this.bytes=wW,this.headByte=$Q,this.stack=new dq,this.entered=!1,this.extensionCodec=Q?.extensionCodec??G9.defaultCodec,this.context=Q?.context,this.useBigInt64=Q?.useBigInt64??!1,this.rawStrings=Q?.rawStrings??!1,this.maxStrLength=Q?.maxStrLength??g9,this.maxBinLength=Q?.maxBinLength??g9,this.maxArrayLength=Q?.maxArrayLength??g9,this.maxMapLength=Q?.maxMapLength??g9,this.maxExtLength=Q?.maxExtLength??g9,this.keyDecoder=Q?.keyDecoder!==void 0?Q.keyDecoder:BW,this.mapKeyConverter=Q?.mapKeyConverter??FW}clone(){return new SJ({extensionCodec:this.extensionCodec,context:this.context,useBigInt64:this.useBigInt64,rawStrings:this.rawStrings,maxStrLength:this.maxStrLength,maxBinLength:this.maxBinLength,maxArrayLength:this.maxArrayLength,maxMapLength:this.maxMapLength,maxExtLength:this.maxExtLength,keyDecoder:this.keyDecoder})}reinitializeState(){this.totalPos=0,this.headByte=$Q,this.stack.reset()}setBuffer(Q){const Y=UQ(Q);this.bytes=Y,this.view=new DataView(Y.buffer,Y.byteOffset,Y.byteLength),this.pos=0}appendBuffer(Q){if(this.headByte===$Q&&!this.hasRemaining(1))this.setBuffer(Q);else{const Y=this.bytes.subarray(this.pos),J=UQ(Q),X=new Uint8Array(Y.length+J.length);X.set(Y),X.set(J,Y.length),this.setBuffer(X)}}hasRemaining(Q){return this.view.byteLength-this.pos>=Q}createExtraByteError(Q){const{view:Y,pos:J}=this;return new RangeError(`Extra ${Y.byteLength-J} of ${Y.byteLength} byte(s) found at buffer[${Q}]`)}decode(Q){if(this.entered)return this.clone().decode(Q);try{this.entered=!0,this.reinitializeState(),this.setBuffer(Q);const Y=this.doDecodeSync();if(this.hasRemaining(1))throw this.createExtraByteError(this.pos);return Y}finally{this.entered=!1}}*decodeMulti(Q){if(this.entered){yield*this.clone().decodeMulti(Q);return}try{this.entered=!0,this.reinitializeState(),this.setBuffer(Q);while(this.hasRemaining(1))yield this.doDecodeSync()}finally{this.entered=!1}}async decodeAsync(Q){if(this.entered)return this.clone().decodeAsync(Q);try{this.entered=!0;let Y=!1,J;for await(let W of Q){if(Y)throw this.entered=!1,this.createExtraByteError(this.totalPos);this.appendBuffer(W);try{J=this.doDecodeSync(),Y=!0}catch(V){if(!(V instanceof RangeError))throw V}this.totalPos+=this.pos}if(Y){if(this.hasRemaining(1))throw this.createExtraByteError(this.totalPos);return J}const{headByte:X,pos:q,totalPos:G}=this;throw new RangeError(`Insufficient data in parsing ${BJ(X)} at ${G} (${q} in the current buffer)`)}finally{this.entered=!1}}decodeArrayStream(Q){return this.decodeMultiAsync(Q,!0)}decodeStream(Q){return this.decodeMultiAsync(Q,!1)}async*decodeMultiAsync(Q,Y){if(this.entered){yield*this.clone().decodeMultiAsync(Q,Y);return}try{this.entered=!0;let J=Y,X=-1;for await(let q of Q){if(Y&&X===0)throw this.createExtraByteError(this.totalPos);if(this.appendBuffer(q),J)X=this.readArraySize(),J=!1,this.complete();try{while(!0)if(yield this.doDecodeSync(),--X===0)break}catch(G){if(!(G instanceof RangeError))throw G}this.totalPos+=this.pos}}finally{this.entered=!1}}doDecodeSync(){Q:while(!0){const Q=this.readHeadByte();let Y;if(Q>=224)Y=Q-256;else if(Q<192)if(Q<128)Y=Q;else if(Q<144){const X=Q-128;if(X!==0){this.pushMapState(X),this.complete();continue Q}else Y={}}else if(Q<160){const X=Q-144;if(X!==0){this.pushArrayState(X),this.complete();continue Q}else Y=[]}else{const X=Q-160;Y=this.decodeString(X,0)}else if(Q===192)Y=null;else if(Q===194)Y=!1;else if(Q===195)Y=!0;else if(Q===202)Y=this.readF32();else if(Q===203)Y=this.readF64();else if(Q===204)Y=this.readU8();else if(Q===205)Y=this.readU16();else if(Q===206)Y=this.readU32();else if(Q===207)if(this.useBigInt64)Y=this.readU64AsBigInt();else Y=this.readU64();else if(Q===208)Y=this.readI8();else if(Q===209)Y=this.readI16();else if(Q===210)Y=this.readI32();else if(Q===211)if(this.useBigInt64)Y=this.readI64AsBigInt();else Y=this.readI64();else if(Q===217){const X=this.lookU8();Y=this.decodeString(X,1)}else if(Q===218){const X=this.lookU16();Y=this.decodeString(X,2)}else if(Q===219){const X=this.lookU32();Y=this.decodeString(X,4)}else if(Q===220){const X=this.readU16();if(X!==0){this.pushArrayState(X),this.complete();continue Q}else Y=[]}else if(Q===221){const X=this.readU32();if(X!==0){this.pushArrayState(X),this.complete();continue Q}else Y=[]}else if(Q===222){const X=this.readU16();if(X!==0){this.pushMapState(X),this.complete();continue Q}else Y={}}else if(Q===223){const X=this.readU32();if(X!==0){this.pushMapState(X),this.complete();continue Q}else Y={}}else if(Q===196){const X=this.lookU8();Y=this.decodeBinary(X,1)}else if(Q===197){const X=this.lookU16();Y=this.decodeBinary(X,2)}else if(Q===198){const X=this.lookU32();Y=this.decodeBinary(X,4)}else if(Q===212)Y=this.decodeExtension(1,0);else if(Q===213)Y=this.decodeExtension(2,0);else if(Q===214)Y=this.decodeExtension(4,0);else if(Q===215)Y=this.decodeExtension(8,0);else if(Q===216)Y=this.decodeExtension(16,0);else if(Q===199){const X=this.lookU8();Y=this.decodeExtension(X,1)}else if(Q===200){const X=this.lookU16();Y=this.decodeExtension(X,2)}else if(Q===201){const X=this.lookU32();Y=this.decodeExtension(X,4)}else throw new C0(`Unrecognized type byte: ${BJ(Q)}`);this.complete();const J=this.stack;while(J.length>0){const X=J.top();if(X.type===n5)if(X.array[X.position]=Y,X.position++,X.position===X.size)Y=X.array,J.release(X);else continue Q;else if(X.type===ZQ){if(Y==="__proto__")throw new C0("The key __proto__ is not allowed");X.key=this.mapKeyConverter(Y),X.type=uq;continue Q}else if(X.map[X.key]=Y,X.readCount++,X.readCount===X.size)Y=X.map,J.release(X);else{X.key=null,X.type=ZQ;continue Q}}return Y}}readHeadByte(){if(this.headByte===$Q)this.headByte=this.readU8();return this.headByte}complete(){this.headByte=$Q}readArraySize(){const Q=this.readHeadByte();switch(Q){case 220:return this.readU16();case 221:return this.readU32();default:if(Q<160)return Q-144;else throw new C0(`Unrecognized array type byte: ${BJ(Q)}`)}}pushMapState(Q){if(Q>this.maxMapLength)throw new C0(`Max length exceeded: map length (${Q}) > maxMapLengthLength (${this.maxMapLength})`);this.stack.pushMapState(Q)}pushArrayState(Q){if(Q>this.maxArrayLength)throw new C0(`Max length exceeded: array length (${Q}) > maxArrayLength (${this.maxArrayLength})`);this.stack.pushArrayState(Q)}decodeString(Q,Y){if(!this.rawStrings||this.stateIsMapKey())return this.decodeUtf8String(Q,Y);return this.decodeBinary(Q,Y)}decodeUtf8String(Q,Y){if(Q>this.maxStrLength)throw new C0(`Max length exceeded: UTF-8 byte length (${Q}) > maxStrLength (${this.maxStrLength})`);if(this.bytes.byteLength<this.pos+Y+Q)throw pq;const J=this.pos+Y;let X;if(this.stateIsMapKey()&&this.keyDecoder?.canBeCached(Q))X=this.keyDecoder.decode(this.bytes,J,Q);else X=hq(this.bytes,J,Q);return this.pos+=Y+Q,X}stateIsMapKey(){if(this.stack.length>0)return this.stack.top().type===ZQ;return!1}decodeBinary(Q,Y){if(Q>this.maxBinLength)throw new C0(`Max length exceeded: bin length (${Q}) > maxBinLength (${this.maxBinLength})`);if(!this.hasRemaining(Q+Y))throw pq;const J=this.pos+Y,X=this.bytes.subarray(J,J+Q);return this.pos+=Y+Q,X}decodeExtension(Q,Y){if(Q>this.maxExtLength)throw new C0(`Max length exceeded: ext length (${Q}) > maxExtLength (${this.maxExtLength})`);const J=this.view.getInt8(this.pos+Y),X=this.decodeBinary(Q,Y+1);return this.extensionCodec.decode(X,J,this.context)}lookU8(){return this.view.getUint8(this.pos)}lookU16(){return this.view.getUint16(this.pos)}lookU32(){return this.view.getUint32(this.pos)}readU8(){const Q=this.view.getUint8(this.pos);return this.pos++,Q}readI8(){const Q=this.view.getInt8(this.pos);return this.pos++,Q}readU16(){const Q=this.view.getUint16(this.pos);return this.pos+=2,Q}readI16(){const Q=this.view.getInt16(this.pos);return this.pos+=2,Q}readU32(){const Q=this.view.getUint32(this.pos);return this.pos+=4,Q}readI32(){const Q=this.view.getInt32(this.pos);return this.pos+=4,Q}readU64(){const Q=_q(this.view,this.pos);return this.pos+=8,Q}readI64(){const Q=FJ(this.view,this.pos);return this.pos+=8,Q}readU64AsBigInt(){const Q=this.view.getBigUint64(this.pos);return this.pos+=8,Q}readI64AsBigInt(){const Q=this.view.getBigInt64(this.pos);return this.pos+=8,Q}readF32(){const Q=this.view.getFloat32(this.pos);return this.pos+=4,Q}readF64(){const Q=this.view.getFloat64(this.pos);return this.pos+=8,Q}}function r5(Q,Y){return new SJ(Y).decode(Q)}var m9=function(Q){let Y=Q.length;while(--Y>=0)Q[Y]=0},s5=function(Q,Y,J,X,q){this.static_tree=Q,this.extra_bits=Y,this.extra_base=J,this.elems=X,this.max_length=q,this.has_stree=Q&&Q.length},t5=function(Q,Y){this.dyn_tree=Q,this.max_code=0,this.stat_desc=Y},J8=function(Q,Y,J,X,q){this.good_length=Q,this.max_lazy=Y,this.nice_length=J,this.max_chain=X,this.func=q},AV=function(){this.strm=null,this.status=0,this.pending_buf=null,this.pending_buf_size=0,this.pending_out=0,this.pending=0,this.wrap=0,this.gzhead=null,this.gzindex=0,this.method=hJ,this.last_flush=-1,this.w_size=0,this.w_bits=0,this.w_mask=0,this.window=null,this.window_size=0,this.prev=null,this.head=null,this.ins_h=0,this.hash_size=0,this.hash_bits=0,this.hash_mask=0,this.hash_shift=0,this.block_start=0,this.match_length=0,this.prev_match=0,this.match_available=0,this.strstart=0,this.match_start=0,this.lookahead=0,this.prev_length=0,this.max_chain_length=0,this.max_lazy_match=0,this.level=0,this.strategy=0,this.good_match=0,this.nice_match=0,this.dyn_ltree=new Uint16Array(jV*2),this.dyn_dtree=new Uint16Array((2*DV+1)*2),this.bl_tree=new Uint16Array((2*PV+1)*2),y8(this.dyn_ltree),y8(this.dyn_dtree),y8(this.bl_tree),this.l_desc=null,this.d_desc=null,this.bl_desc=null,this.bl_count=new Uint16Array(LV+1),this.heap=new Uint16Array(2*MY+1),y8(this.heap),this.heap_len=0,this.heap_max=0,this.depth=new Uint16Array(2*MY+1),y8(this.depth),this.sym_buf=0,this.lit_bufsize=0,this.sym_next=0,this.sym_end=0,this.opt_len=0,this.static_len=0,this.matches=0,this.insert=0,this.bi_buf=0,this.bi_valid=0},sV=function(){this.input=null,this.next_in=0,this.avail_in=0,this.total_in=0,this.output=null,this.next_out=0,this.avail_out=0,this.total_out=0,this.msg="",this.state=null,this.data_type=2,this.adler=0},BQ=function(Q){this.options=mJ.assign({level:XU,method:GU,chunkSize:16384,windowBits:15,memLevel:8,strategy:qU},Q||{});let Y=this.options;if(Y.raw&&Y.windowBits>0)Y.windowBits=-Y.windowBits;else if(Y.gzip&&Y.windowBits>0&&Y.windowBits<16)Y.windowBits+=16;this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new a1,this.strm.avail_out=0;let J=OQ.deflateInit2(this.strm,Y.level,Y.method,Y.windowBits,Y.memLevel,Y.strategy);if(J!==bJ)throw new Error($9[J]);if(Y.header)OQ.deflateSetHeader(this.strm,Y.header);if(Y.dictionary){let X;if(typeof Y.dictionary==="string")X=NQ.string2buf(Y.dictionary);else if(s1.call(Y.dictionary)==="[object ArrayBuffer]")X=new Uint8Array(Y.dictionary);else X=Y.dictionary;if(J=OQ.deflateSetDictionary(this.strm,X),J!==bJ)throw new Error($9[J]);this._dict_set=!0}},TY=function(Q,Y){const J=new BQ(Y);if(J.push(Q,!0),J.err)throw J.msg||$9[J.err];return J.result},WU=function(Q,Y){return Y=Y||{},Y.raw=!0,TY(Q,Y)},VU=function(Q,Y){return Y=Y||{},Y.gzip=!0,TY(Q,Y)},EU=function(){this.strm=null,this.mode=0,this.last=!1,this.wrap=0,this.havedict=!1,this.flags=0,this.dmax=0,this.check=0,this.total=0,this.head=null,this.wbits=0,this.wsize=0,this.whave=0,this.wnext=0,this.window=null,this.hold=0,this.bits=0,this.length=0,this.offset=0,this.extra=0,this.lencode=null,this.distcode=null,this.lenbits=0,this.distbits=0,this.ncode=0,this.nlen=0,this.ndist=0,this.have=0,this.next=null,this.lens=new Uint16Array(320),this.work=new Uint16Array(288),this.lendyn=null,this.distdyn=null,this.sane=0,this.back=0,this.was=0},nU=function(){this.text=0,this.time=0,this.xflags=0,this.os=0,this.extra=null,this.extra_len=0,this.name="",this.comment="",this.hcrc=0,this.done=!1},SQ=function(Q){this.options=mJ.assign({chunkSize:65536,windowBits:15,to:""},Q||{});const Y=this.options;if(Y.raw&&Y.windowBits>=0&&Y.windowBits<16){if(Y.windowBits=-Y.windowBits,Y.windowBits===0)Y.windowBits=-15}if(Y.windowBits>=0&&Y.windowBits<16&&!(Q&&Q.windowBits))Y.windowBits+=32;if(Y.windowBits>15&&Y.windowBits<48){if((Y.windowBits&15)===0)Y.windowBits|=15}this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new a1,this.strm.avail_out=0;let J=w8.inflateInit2(this.strm,Y.windowBits);if(J!==TQ)throw new Error($9[J]);if(this.header=new oU,w8.inflateGetHeader(this.strm,this.header),Y.dictionary){if(typeof Y.dictionary==="string")Y.dictionary=NQ.string2buf(Y.dictionary);else if($7.call(Y.dictionary)==="[object ArrayBuffer]")Y.dictionary=new Uint8Array(Y.dictionary);if(Y.raw){if(J=w8.inflateSetDictionary(this.strm,Y.dictionary),J!==TQ)throw new Error($9[J])}}},FY=function(Q,Y){const J=new SQ(Y);if(J.push(Q),J.err)throw J.msg||$9[J.err];return J.result},eU=function(Q,Y){return Y=Y||{},Y.raw=!0,FY(Q,Y)};/*! pako 2.1.0 https://github.com/nodeca/pako @license (MIT AND Zlib) */var SW=0,A1=1,AW=2,EW=3,kW=258,PY=29,FQ=256,HQ=FQ+1+PY,b9=30,jY=19,E1=2*HQ+1,W9=15,a5=16,xW=7,LY=256,k1=16,x1=17,g1=18,ZY=new Uint8Array([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0]),vJ=new Uint8Array([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13]),gW=new Uint8Array([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7]),v1=new Uint8Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),vW=512,F8=new Array((HQ+2)*2);m9(F8);var IQ=new Array(b9*2);m9(IQ);var DQ=new Array(vW);m9(DQ);var PQ=new Array(kW-EW+1);m9(PQ);var CY=new Array(PY);m9(CY);var fJ=new Array(b9);m9(fJ);var f1,b1,y1,h1=(Q)=>{return Q<256?DQ[Q]:DQ[256+(Q>>>7)]},jQ=(Q,Y)=>{Q.pending_buf[Q.pending++]=Y&255,Q.pending_buf[Q.pending++]=Y>>>8&255},w0=(Q,Y,J)=>{if(Q.bi_valid>a5-J)Q.bi_buf|=Y<<Q.bi_valid&65535,jQ(Q,Q.bi_buf),Q.bi_buf=Y>>a5-Q.bi_valid,Q.bi_valid+=J-a5;else Q.bi_buf|=Y<<Q.bi_valid&65535,Q.bi_valid+=J},Y8=(Q,Y,J)=>{w0(Q,J[Y*2],J[Y*2+1])},m1=(Q,Y)=>{let J=0;do J|=Q&1,Q>>>=1,J<<=1;while(--Y>0);return J>>>1},fW=(Q)=>{if(Q.bi_valid===16)jQ(Q,Q.bi_buf),Q.bi_buf=0,Q.bi_valid=0;else if(Q.bi_valid>=8)Q.pending_buf[Q.pending++]=Q.bi_buf&255,Q.bi_buf>>=8,Q.bi_valid-=8},bW=(Q,Y)=>{const{dyn_tree:J,max_code:X}=Y,q=Y.stat_desc.static_tree,G=Y.stat_desc.has_stree,W=Y.stat_desc.extra_bits,V=Y.stat_desc.extra_base,$=Y.stat_desc.max_length;let U,Z,K,M,I,z,R=0;for(M=0;M<=W9;M++)Q.bl_count[M]=0;J[Q.heap[Q.heap_max]*2+1]=0;for(U=Q.heap_max+1;U<E1;U++){if(Z=Q.heap[U],M=J[J[Z*2+1]*2+1]+1,M>$)M=$,R++;if(J[Z*2+1]=M,Z>X)continue;if(Q.bl_count[M]++,I=0,Z>=V)I=W[Z-V];if(z=J[Z*2],Q.opt_len+=z*(M+I),G)Q.static_len+=z*(q[Z*2+1]+I)}if(R===0)return;do{M=$-1;while(Q.bl_count[M]===0)M--;Q.bl_count[M]--,Q.bl_count[M+1]+=2,Q.bl_count[$]--,R-=2}while(R>0);for(M=$;M!==0;M--){Z=Q.bl_count[M];while(Z!==0){if(K=Q.heap[--U],K>X)continue;if(J[K*2+1]!==M)Q.opt_len+=(M-J[K*2+1])*J[K*2],J[K*2+1]=M;Z--}}},_1=(Q,Y,J)=>{const X=new Array(W9+1);let q=0,G,W;for(G=1;G<=W9;G++)q=q+J[G-1]<<1,X[G]=q;for(W=0;W<=Y;W++){let V=Q[W*2+1];if(V===0)continue;Q[W*2]=m1(X[V]++,V)}},yW=()=>{let Q,Y,J,X,q;const G=new Array(W9+1);J=0;for(X=0;X<PY-1;X++){CY[X]=J;for(Q=0;Q<1<<ZY[X];Q++)PQ[J++]=X}PQ[J-1]=X,q=0;for(X=0;X<16;X++){fJ[X]=q;for(Q=0;Q<1<<vJ[X];Q++)DQ[q++]=X}q>>=7;for(;X<b9;X++){fJ[X]=q<<7;for(Q=0;Q<1<<vJ[X]-7;Q++)DQ[256+q++]=X}for(Y=0;Y<=W9;Y++)G[Y]=0;Q=0;while(Q<=143)F8[Q*2+1]=8,Q++,G[8]++;while(Q<=255)F8[Q*2+1]=9,Q++,G[9]++;while(Q<=279)F8[Q*2+1]=7,Q++,G[7]++;while(Q<=287)F8[Q*2+1]=8,Q++,G[8]++;_1(F8,HQ+1,G);for(Q=0;Q<b9;Q++)IQ[Q*2+1]=5,IQ[Q*2]=m1(Q,5);f1=new s5(F8,ZY,FQ+1,HQ,W9),b1=new s5(IQ,vJ,0,b9,W9),y1=new s5(new Array(0),gW,0,jY,xW)},c1=(Q)=>{let Y;for(Y=0;Y<HQ;Y++)Q.dyn_ltree[Y*2]=0;for(Y=0;Y<b9;Y++)Q.dyn_dtree[Y*2]=0;for(Y=0;Y<jY;Y++)Q.bl_tree[Y*2]=0;Q.dyn_ltree[LY*2]=1,Q.opt_len=Q.static_len=0,Q.sym_next=Q.matches=0},p1=(Q)=>{if(Q.bi_valid>8)jQ(Q,Q.bi_buf);else if(Q.bi_valid>0)Q.pending_buf[Q.pending++]=Q.bi_buf;Q.bi_buf=0,Q.bi_valid=0},lq=(Q,Y,J,X)=>{const q=Y*2,G=J*2;return Q[q]<Q[G]||Q[q]===Q[G]&&X[Y]<=X[J]},e5=(Q,Y,J)=>{const X=Q.heap[J];let q=J<<1;while(q<=Q.heap_len){if(q<Q.heap_len&&lq(Y,Q.heap[q+1],Q.heap[q],Q.depth))q++;if(lq(Y,X,Q.heap[q],Q.depth))break;Q.heap[J]=Q.heap[q],J=q,q<<=1}Q.heap[J]=X},iq=(Q,Y,J)=>{let X,q,G=0,W,V;if(Q.sym_next!==0)do if(X=Q.pending_buf[Q.sym_buf+G++]&255,X+=(Q.pending_buf[Q.sym_buf+G++]&255)<<8,q=Q.pending_buf[Q.sym_buf+G++],X===0)Y8(Q,q,Y);else{if(W=PQ[q],Y8(Q,W+FQ+1,Y),V=ZY[W],V!==0)q-=CY[W],w0(Q,q,V);if(X--,W=h1(X),Y8(Q,W,J),V=vJ[W],V!==0)X-=fJ[W],w0(Q,X,V)}while(G<Q.sym_next);Y8(Q,LY,Y)},zY=(Q,Y)=>{const J=Y.dyn_tree,X=Y.stat_desc.static_tree,q=Y.stat_desc.has_stree,G=Y.stat_desc.elems;let W,V,$=-1,U;Q.heap_len=0,Q.heap_max=E1;for(W=0;W<G;W++)if(J[W*2]!==0)Q.heap[++Q.heap_len]=$=W,Q.depth[W]=0;else J[W*2+1]=0;while(Q.heap_len<2)if(U=Q.heap[++Q.heap_len]=$<2?++$:0,J[U*2]=1,Q.depth[U]=0,Q.opt_len--,q)Q.static_len-=X[U*2+1];Y.max_code=$;for(W=Q.heap_len>>1;W>=1;W--)e5(Q,J,W);U=G;do W=Q.heap[1],Q.heap[1]=Q.heap[Q.heap_len--],e5(Q,J,1),V=Q.heap[1],Q.heap[--Q.heap_max]=W,Q.heap[--Q.heap_max]=V,J[U*2]=J[W*2]+J[V*2],Q.depth[U]=(Q.depth[W]>=Q.depth[V]?Q.depth[W]:Q.depth[V])+1,J[W*2+1]=J[V*2+1]=U,Q.heap[1]=U++,e5(Q,J,1);while(Q.heap_len>=2);Q.heap[--Q.heap_max]=Q.heap[1],bW(Q,Y),_1(J,$,Q.bl_count)},nq=(Q,Y,J)=>{let X,q=-1,G,W=Y[1],V=0,$=7,U=4;if(W===0)$=138,U=3;Y[(J+1)*2+1]=65535;for(X=0;X<=J;X++){if(G=W,W=Y[(X+1)*2+1],++V<$&&G===W)continue;else if(V<U)Q.bl_tree[G*2]+=V;else if(G!==0){if(G!==q)Q.bl_tree[G*2]++;Q.bl_tree[k1*2]++}else if(V<=10)Q.bl_tree[x1*2]++;else Q.bl_tree[g1*2]++;if(V=0,q=G,W===0)$=138,U=3;else if(G===W)$=6,U=3;else $=7,U=4}},oq=(Q,Y,J)=>{let X,q=-1,G,W=Y[1],V=0,$=7,U=4;if(W===0)$=138,U=3;for(X=0;X<=J;X++){if(G=W,W=Y[(X+1)*2+1],++V<$&&G===W)continue;else if(V<U)do Y8(Q,G,Q.bl_tree);while(--V!==0);else if(G!==0){if(G!==q)Y8(Q,G,Q.bl_tree),V--;Y8(Q,k1,Q.bl_tree),w0(Q,V-3,2)}else if(V<=10)Y8(Q,x1,Q.bl_tree),w0(Q,V-3,3);else Y8(Q,g1,Q.bl_tree),w0(Q,V-11,7);if(V=0,q=G,W===0)$=138,U=3;else if(G===W)$=6,U=3;else $=7,U=4}},hW=(Q)=>{let Y;nq(Q,Q.dyn_ltree,Q.l_desc.max_code),nq(Q,Q.dyn_dtree,Q.d_desc.max_code),zY(Q,Q.bl_desc);for(Y=jY-1;Y>=3;Y--)if(Q.bl_tree[v1[Y]*2+1]!==0)break;return Q.opt_len+=3*(Y+1)+5+5+4,Y},mW=(Q,Y,J,X)=>{let q;w0(Q,Y-257,5),w0(Q,J-1,5),w0(Q,X-4,4);for(q=0;q<X;q++)w0(Q,Q.bl_tree[v1[q]*2+1],3);oq(Q,Q.dyn_ltree,Y-1),oq(Q,Q.dyn_dtree,J-1)},_W=(Q)=>{let Y=4093624447,J;for(J=0;J<=31;J++,Y>>>=1)if(Y&1&&Q.dyn_ltree[J*2]!==0)return 0;if(Q.dyn_ltree[18]!==0||Q.dyn_ltree[20]!==0||Q.dyn_ltree[26]!==0)return 1;for(J=32;J<FQ;J++)if(Q.dyn_ltree[J*2]!==0)return 1;return 0},rq=!1,cW=(Q)=>{if(!rq)yW(),rq=!0;Q.l_desc=new t5(Q.dyn_ltree,f1),Q.d_desc=new t5(Q.dyn_dtree,b1),Q.bl_desc=new t5(Q.bl_tree,y1),Q.bi_buf=0,Q.bi_valid=0,c1(Q)},u1=(Q,Y,J,X)=>{if(w0(Q,(SW<<1)+(X?1:0),3),p1(Q),jQ(Q,J),jQ(Q,~J),J)Q.pending_buf.set(Q.window.subarray(Y,Y+J),Q.pending);Q.pending+=J},pW=(Q)=>{w0(Q,A1<<1,3),Y8(Q,LY,F8),fW(Q)},uW=(Q,Y,J,X)=>{let q,G,W=0;if(Q.level>0){if(Q.strm.data_type===2)Q.strm.data_type=_W(Q);if(zY(Q,Q.l_desc),zY(Q,Q.d_desc),W=hW(Q),q=Q.opt_len+3+7>>>3,G=Q.static_len+3+7>>>3,G<=q)q=G}else q=G=J+5;if(J+4<=q&&Y!==-1)u1(Q,Y,J,X);else if(Q.strategy===4||G===q)w0(Q,(A1<<1)+(X?1:0),3),iq(Q,F8,IQ);else w0(Q,(AW<<1)+(X?1:0),3),mW(Q,Q.l_desc.max_code+1,Q.d_desc.max_code+1,W+1),iq(Q,Q.dyn_ltree,Q.dyn_dtree);if(c1(Q),X)p1(Q)},dW=(Q,Y,J)=>{if(Q.pending_buf[Q.sym_buf+Q.sym_next++]=Y,Q.pending_buf[Q.sym_buf+Q.sym_next++]=Y>>8,Q.pending_buf[Q.sym_buf+Q.sym_next++]=J,Y===0)Q.dyn_ltree[J*2]++;else Q.matches++,Y--,Q.dyn_ltree[(PQ[J]+FQ+1)*2]++,Q.dyn_dtree[h1(Y)*2]++;return Q.sym_next===Q.sym_end},lW=cW,iW=u1,nW=uW,oW=dW,rW=pW,aW={_tr_init:lW,_tr_stored_block:iW,_tr_flush_block:nW,_tr_tally:oW,_tr_align:rW},sW=(Q,Y,J,X)=>{let q=Q&65535|0,G=Q>>>16&65535|0,W=0;while(J!==0){W=J>2000?2000:J,J-=W;do q=q+Y[X++]|0,G=G+q|0;while(--W);q%=65521,G%=65521}return q|G<<16|0},LQ=sW,tW=()=>{let Q,Y=[];for(var J=0;J<256;J++){Q=J;for(var X=0;X<8;X++)Q=Q&1?3988292384^Q>>>1:Q>>>1;Y[J]=Q}return Y},eW=new Uint32Array(tW()),QV=(Q,Y,J,X)=>{const q=eW,G=X+J;Q^=-1;for(let W=X;W<G;W++)Q=Q>>>8^q[(Q^Y[W])&255];return Q^-1},M0=QV,$9={2:"need dictionary",1:"stream end",0:"","-1":"file error","-2":"stream error","-3":"data error","-4":"insufficient memory","-5":"buffer error","-6":"incompatible version"},K9={Z_NO_FLUSH:0,Z_PARTIAL_FLUSH:1,Z_SYNC_FLUSH:2,Z_FULL_FLUSH:3,Z_FINISH:4,Z_BLOCK:5,Z_TREES:6,Z_OK:0,Z_STREAM_END:1,Z_NEED_DICT:2,Z_ERRNO:-1,Z_STREAM_ERROR:-2,Z_DATA_ERROR:-3,Z_MEM_ERROR:-4,Z_BUF_ERROR:-5,Z_NO_COMPRESSION:0,Z_BEST_SPEED:1,Z_BEST_COMPRESSION:9,Z_DEFAULT_COMPRESSION:-1,Z_FILTERED:1,Z_HUFFMAN_ONLY:2,Z_RLE:3,Z_FIXED:4,Z_DEFAULT_STRATEGY:0,Z_BINARY:0,Z_TEXT:1,Z_UNKNOWN:2,Z_DEFLATED:8},{_tr_init:JV,_tr_stored_block:KY,_tr_flush_block:YV,_tr_tally:m8,_tr_align:XV}=aW,{Z_NO_FLUSH:_8,Z_PARTIAL_FLUSH:qV,Z_FULL_FLUSH:GV,Z_FINISH:p0,Z_BLOCK:aq,Z_OK:R0,Z_STREAM_END:sq,Z_STREAM_ERROR:X8,Z_DATA_ERROR:WV,Z_BUF_ERROR:QY,Z_DEFAULT_COMPRESSION:VV,Z_FILTERED:UV,Z_HUFFMAN_ONLY:AJ,Z_RLE:$V,Z_FIXED:ZV,Z_DEFAULT_STRATEGY:zV,Z_UNKNOWN:KV,Z_DEFLATED:hJ}=K9,MV=9,IV=15,OV=8,RV=29,HV=256,MY=HV+1+RV,DV=30,PV=19,jV=2*MY+1,LV=15,_=3,h8=258,q8=h8+_+1,CV=32,y9=42,NY=57,IY=69,OY=73,RY=91,HY=103,V9=113,KQ=666,N0=1,_9=2,Z9=3,c9=4,NV=3,U9=(Q,Y)=>{return Q.msg=$9[Y],Y},tq=(Q)=>{return Q*2-(Q>4?9:0)},y8=(Q)=>{let Y=Q.length;while(--Y>=0)Q[Y]=0},TV=(Q)=>{let Y,J,X,q=Q.w_size;Y=Q.hash_size,X=Y;do J=Q.head[--X],Q.head[X]=J>=q?J-q:0;while(--Y);Y=q,X=Y;do J=Q.prev[--X],Q.prev[X]=J>=q?J-q:0;while(--Y)},FV=(Q,Y,J)=>(Y<<Q.hash_shift^J)&Q.hash_mask,c8=FV,g0=(Q)=>{const Y=Q.state;let J=Y.pending;if(J>Q.avail_out)J=Q.avail_out;if(J===0)return;if(Q.output.set(Y.pending_buf.subarray(Y.pending_out,Y.pending_out+J),Q.next_out),Q.next_out+=J,Y.pending_out+=J,Q.total_out+=J,Q.avail_out-=J,Y.pending-=J,Y.pending===0)Y.pending_out=0},v0=(Q,Y)=>{YV(Q,Q.block_start>=0?Q.block_start:-1,Q.strstart-Q.block_start,Y),Q.block_start=Q.strstart,g0(Q.strm)},n=(Q,Y)=>{Q.pending_buf[Q.pending++]=Y},zQ=(Q,Y)=>{Q.pending_buf[Q.pending++]=Y>>>8&255,Q.pending_buf[Q.pending++]=Y&255},DY=(Q,Y,J,X)=>{let q=Q.avail_in;if(q>X)q=X;if(q===0)return 0;if(Q.avail_in-=q,Y.set(Q.input.subarray(Q.next_in,Q.next_in+q),J),Q.state.wrap===1)Q.adler=LQ(Q.adler,Y,q,J);else if(Q.state.wrap===2)Q.adler=M0(Q.adler,Y,q,J);return Q.next_in+=q,Q.total_in+=q,q},d1=(Q,Y)=>{let{max_chain_length:J,strstart:X}=Q,q,G,W=Q.prev_length,V=Q.nice_match;const $=Q.strstart>Q.w_size-q8?Q.strstart-(Q.w_size-q8):0,U=Q.window,Z=Q.w_mask,K=Q.prev,M=Q.strstart+h8;let I=U[X+W-1],z=U[X+W];if(Q.prev_length>=Q.good_match)J>>=2;if(V>Q.lookahead)V=Q.lookahead;do{if(q=Y,U[q+W]!==z||U[q+W-1]!==I||U[q]!==U[X]||U[++q]!==U[X+1])continue;X+=2,q++;do;while(U[++X]===U[++q]&&U[++X]===U[++q]&&U[++X]===U[++q]&&U[++X]===U[++q]&&U[++X]===U[++q]&&U[++X]===U[++q]&&U[++X]===U[++q]&&U[++X]===U[++q]&&X<M);if(G=h8-(M-X),X=M-h8,G>W){if(Q.match_start=Y,W=G,G>=V)break;I=U[X+W-1],z=U[X+W]}}while((Y=K[Y&Z])>$&&--J!==0);if(W<=Q.lookahead)return W;return Q.lookahead},h9=(Q)=>{const Y=Q.w_size;let J,X,q;do{if(X=Q.window_size-Q.lookahead-Q.strstart,Q.strstart>=Y+(Y-q8)){if(Q.window.set(Q.window.subarray(Y,Y+Y-X),0),Q.match_start-=Y,Q.strstart-=Y,Q.block_start-=Y,Q.insert>Q.strstart)Q.insert=Q.strstart;TV(Q),X+=Y}if(Q.strm.avail_in===0)break;if(J=DY(Q.strm,Q.window,Q.strstart+Q.lookahead,X),Q.lookahead+=J,Q.lookahead+Q.insert>=_){q=Q.strstart-Q.insert,Q.ins_h=Q.window[q],Q.ins_h=c8(Q,Q.ins_h,Q.window[q+1]);while(Q.insert)if(Q.ins_h=c8(Q,Q.ins_h,Q.window[q+_-1]),Q.prev[q&Q.w_mask]=Q.head[Q.ins_h],Q.head[Q.ins_h]=q,q++,Q.insert--,Q.lookahead+Q.insert<_)break}}while(Q.lookahead<q8&&Q.strm.avail_in!==0)},l1=(Q,Y)=>{let J=Q.pending_buf_size-5>Q.w_size?Q.w_size:Q.pending_buf_size-5,X,q,G,W=0,V=Q.strm.avail_in;do{if(X=65535,G=Q.bi_valid+42>>3,Q.strm.avail_out<G)break;if(G=Q.strm.avail_out-G,q=Q.strstart-Q.block_start,X>q+Q.strm.avail_in)X=q+Q.strm.avail_in;if(X>G)X=G;if(X<J&&(X===0&&Y!==p0||Y===_8||X!==q+Q.strm.avail_in))break;if(W=Y===p0&&X===q+Q.strm.avail_in?1:0,KY(Q,0,0,W),Q.pending_buf[Q.pending-4]=X,Q.pending_buf[Q.pending-3]=X>>8,Q.pending_buf[Q.pending-2]=~X,Q.pending_buf[Q.pending-1]=~X>>8,g0(Q.strm),q){if(q>X)q=X;Q.strm.output.set(Q.window.subarray(Q.block_start,Q.block_start+q),Q.strm.next_out),Q.strm.next_out+=q,Q.strm.avail_out-=q,Q.strm.total_out+=q,Q.block_start+=q,X-=q}if(X)DY(Q.strm,Q.strm.output,Q.strm.next_out,X),Q.strm.next_out+=X,Q.strm.avail_out-=X,Q.strm.total_out+=X}while(W===0);if(V-=Q.strm.avail_in,V){if(V>=Q.w_size)Q.matches=2,Q.window.set(Q.strm.input.subarray(Q.strm.next_in-Q.w_size,Q.strm.next_in),0),Q.strstart=Q.w_size,Q.insert=Q.strstart;else{if(Q.window_size-Q.strstart<=V){if(Q.strstart-=Q.w_size,Q.window.set(Q.window.subarray(Q.w_size,Q.w_size+Q.strstart),0),Q.matches<2)Q.matches++;if(Q.insert>Q.strstart)Q.insert=Q.strstart}Q.window.set(Q.strm.input.subarray(Q.strm.next_in-V,Q.strm.next_in),Q.strstart),Q.strstart+=V,Q.insert+=V>Q.w_size-Q.insert?Q.w_size-Q.insert:V}Q.block_start=Q.strstart}if(Q.high_water<Q.strstart)Q.high_water=Q.strstart;if(W)return c9;if(Y!==_8&&Y!==p0&&Q.strm.avail_in===0&&Q.strstart===Q.block_start)return _9;if(G=Q.window_size-Q.strstart,Q.strm.avail_in>G&&Q.block_start>=Q.w_size){if(Q.block_start-=Q.w_size,Q.strstart-=Q.w_size,Q.window.set(Q.window.subarray(Q.w_size,Q.w_size+Q.strstart),0),Q.matches<2)Q.matches++;if(G+=Q.w_size,Q.insert>Q.strstart)Q.insert=Q.strstart}if(G>Q.strm.avail_in)G=Q.strm.avail_in;if(G)DY(Q.strm,Q.window,Q.strstart,G),Q.strstart+=G,Q.insert+=G>Q.w_size-Q.insert?Q.w_size-Q.insert:G;if(Q.high_water<Q.strstart)Q.high_water=Q.strstart;if(G=Q.bi_valid+42>>3,G=Q.pending_buf_size-G>65535?65535:Q.pending_buf_size-G,J=G>Q.w_size?Q.w_size:G,q=Q.strstart-Q.block_start,q>=J||(q||Y===p0)&&Y!==_8&&Q.strm.avail_in===0&&q<=G)X=q>G?G:q,W=Y===p0&&Q.strm.avail_in===0&&X===q?1:0,KY(Q,Q.block_start,X,W),Q.block_start+=X,g0(Q.strm);return W?Z9:N0},JY=(Q,Y)=>{let J,X;for(;;){if(Q.lookahead<q8){if(h9(Q),Q.lookahead<q8&&Y===_8)return N0;if(Q.lookahead===0)break}if(J=0,Q.lookahead>=_)Q.ins_h=c8(Q,Q.ins_h,Q.window[Q.strstart+_-1]),J=Q.prev[Q.strstart&Q.w_mask]=Q.head[Q.ins_h],Q.head[Q.ins_h]=Q.strstart;if(J!==0&&Q.strstart-J<=Q.w_size-q8)Q.match_length=d1(Q,J);if(Q.match_length>=_)if(X=m8(Q,Q.strstart-Q.match_start,Q.match_length-_),Q.lookahead-=Q.match_length,Q.match_length<=Q.max_lazy_match&&Q.lookahead>=_){Q.match_length--;do Q.strstart++,Q.ins_h=c8(Q,Q.ins_h,Q.window[Q.strstart+_-1]),J=Q.prev[Q.strstart&Q.w_mask]=Q.head[Q.ins_h],Q.head[Q.ins_h]=Q.strstart;while(--Q.match_length!==0);Q.strstart++}else Q.strstart+=Q.match_length,Q.match_length=0,Q.ins_h=Q.window[Q.strstart],Q.ins_h=c8(Q,Q.ins_h,Q.window[Q.strstart+1]);else X=m8(Q,0,Q.window[Q.strstart]),Q.lookahead--,Q.strstart++;if(X){if(v0(Q,!1),Q.strm.avail_out===0)return N0}}if(Q.insert=Q.strstart<_-1?Q.strstart:_-1,Y===p0){if(v0(Q,!0),Q.strm.avail_out===0)return Z9;return c9}if(Q.sym_next){if(v0(Q,!1),Q.strm.avail_out===0)return N0}return _9},v9=(Q,Y)=>{let J,X,q;for(;;){if(Q.lookahead<q8){if(h9(Q),Q.lookahead<q8&&Y===_8)return N0;if(Q.lookahead===0)break}if(J=0,Q.lookahead>=_)Q.ins_h=c8(Q,Q.ins_h,Q.window[Q.strstart+_-1]),J=Q.prev[Q.strstart&Q.w_mask]=Q.head[Q.ins_h],Q.head[Q.ins_h]=Q.strstart;if(Q.prev_length=Q.match_length,Q.prev_match=Q.match_start,Q.match_length=_-1,J!==0&&Q.prev_length<Q.max_lazy_match&&Q.strstart-J<=Q.w_size-q8){if(Q.match_length=d1(Q,J),Q.match_length<=5&&(Q.strategy===UV||Q.match_length===_&&Q.strstart-Q.match_start>4096))Q.match_length=_-1}if(Q.prev_length>=_&&Q.match_length<=Q.prev_length){q=Q.strstart+Q.lookahead-_,X=m8(Q,Q.strstart-1-Q.prev_match,Q.prev_length-_),Q.lookahead-=Q.prev_length-1,Q.prev_length-=2;do if(++Q.strstart<=q)Q.ins_h=c8(Q,Q.ins_h,Q.window[Q.strstart+_-1]),J=Q.prev[Q.strstart&Q.w_mask]=Q.head[Q.ins_h],Q.head[Q.ins_h]=Q.strstart;while(--Q.prev_length!==0);if(Q.match_available=0,Q.match_length=_-1,Q.strstart++,X){if(v0(Q,!1),Q.strm.avail_out===0)return N0}}else if(Q.match_available){if(X=m8(Q,0,Q.window[Q.strstart-1]),X)v0(Q,!1);if(Q.strstart++,Q.lookahead--,Q.strm.avail_out===0)return N0}else Q.match_available=1,Q.strstart++,Q.lookahead--}if(Q.match_available)X=m8(Q,0,Q.window[Q.strstart-1]),Q.match_available=0;if(Q.insert=Q.strstart<_-1?Q.strstart:_-1,Y===p0){if(v0(Q,!0),Q.strm.avail_out===0)return Z9;return c9}if(Q.sym_next){if(v0(Q,!1),Q.strm.avail_out===0)return N0}return _9},wV=(Q,Y)=>{let J,X,q,G;const W=Q.window;for(;;){if(Q.lookahead<=h8){if(h9(Q),Q.lookahead<=h8&&Y===_8)return N0;if(Q.lookahead===0)break}if(Q.match_length=0,Q.lookahead>=_&&Q.strstart>0){if(q=Q.strstart-1,X=W[q],X===W[++q]&&X===W[++q]&&X===W[++q]){G=Q.strstart+h8;do;while(X===W[++q]&&X===W[++q]&&X===W[++q]&&X===W[++q]&&X===W[++q]&&X===W[++q]&&X===W[++q]&&X===W[++q]&&q<G);if(Q.match_length=h8-(G-q),Q.match_length>Q.lookahead)Q.match_length=Q.lookahead}}if(Q.match_length>=_)J=m8(Q,1,Q.match_length-_),Q.lookahead-=Q.match_length,Q.strstart+=Q.match_length,Q.match_length=0;else J=m8(Q,0,Q.window[Q.strstart]),Q.lookahead--,Q.strstart++;if(J){if(v0(Q,!1),Q.strm.avail_out===0)return N0}}if(Q.insert=0,Y===p0){if(v0(Q,!0),Q.strm.avail_out===0)return Z9;return c9}if(Q.sym_next){if(v0(Q,!1),Q.strm.avail_out===0)return N0}return _9},BV=(Q,Y)=>{let J;for(;;){if(Q.lookahead===0){if(h9(Q),Q.lookahead===0){if(Y===_8)return N0;break}}if(Q.match_length=0,J=m8(Q,0,Q.window[Q.strstart]),Q.lookahead--,Q.strstart++,J){if(v0(Q,!1),Q.strm.avail_out===0)return N0}}if(Q.insert=0,Y===p0){if(v0(Q,!0),Q.strm.avail_out===0)return Z9;return c9}if(Q.sym_next){if(v0(Q,!1),Q.strm.avail_out===0)return N0}return _9},MQ=[new J8(0,0,0,0,l1),new J8(4,4,8,4,JY),new J8(4,5,16,8,JY),new J8(4,6,32,32,JY),new J8(4,4,16,16,v9),new J8(8,16,32,32,v9),new J8(8,16,128,128,v9),new J8(8,32,128,256,v9),new J8(32,128,258,1024,v9),new J8(32,258,258,4096,v9)],SV=(Q)=>{Q.window_size=2*Q.w_size,y8(Q.head),Q.max_lazy_match=MQ[Q.level].max_lazy,Q.good_match=MQ[Q.level].good_length,Q.nice_match=MQ[Q.level].nice_length,Q.max_chain_length=MQ[Q.level].max_chain,Q.strstart=0,Q.block_start=0,Q.lookahead=0,Q.insert=0,Q.match_length=Q.prev_length=_-1,Q.match_available=0,Q.ins_h=0},wQ=(Q)=>{if(!Q)return 1;const Y=Q.state;if(!Y||Y.strm!==Q||Y.status!==y9&&Y.status!==NY&&Y.status!==IY&&Y.status!==OY&&Y.status!==RY&&Y.status!==HY&&Y.status!==V9&&Y.status!==KQ)return 1;return 0},i1=(Q)=>{if(wQ(Q))return U9(Q,X8);Q.total_in=Q.total_out=0,Q.data_type=KV;const Y=Q.state;if(Y.pending=0,Y.pending_out=0,Y.wrap<0)Y.wrap=-Y.wrap;return Y.status=Y.wrap===2?NY:Y.wrap?y9:V9,Q.adler=Y.wrap===2?0:1,Y.last_flush=-2,JV(Y),R0},n1=(Q)=>{const Y=i1(Q);if(Y===R0)SV(Q.state);return Y},EV=(Q,Y)=>{if(wQ(Q)||Q.state.wrap!==2)return X8;return Q.state.gzhead=Y,R0},o1=(Q,Y,J,X,q,G)=>{if(!Q)return X8;let W=1;if(Y===VV)Y=6;if(X<0)W=0,X=-X;else if(X>15)W=2,X-=16;if(q<1||q>MV||J!==hJ||X<8||X>15||Y<0||Y>9||G<0||G>ZV||X===8&&W!==1)return U9(Q,X8);if(X===8)X=9;const V=new AV;return Q.state=V,V.strm=Q,V.status=y9,V.wrap=W,V.gzhead=null,V.w_bits=X,V.w_size=1<<V.w_bits,V.w_mask=V.w_size-1,V.hash_bits=q+7,V.hash_size=1<<V.hash_bits,V.hash_mask=V.hash_size-1,V.hash_shift=~~((V.hash_bits+_-1)/_),V.window=new Uint8Array(V.w_size*2),V.head=new Uint16Array(V.hash_size),V.prev=new Uint16Array(V.w_size),V.lit_bufsize=1<<q+6,V.pending_buf_size=V.lit_bufsize*4,V.pending_buf=new Uint8Array(V.pending_buf_size),V.sym_buf=V.lit_bufsize,V.sym_end=(V.lit_bufsize-1)*3,V.level=Y,V.strategy=G,V.method=J,n1(Q)},kV=(Q,Y)=>{return o1(Q,Y,hJ,IV,OV,zV)},xV=(Q,Y)=>{if(wQ(Q)||Y>aq||Y<0)return Q?U9(Q,X8):X8;const J=Q.state;if(!Q.output||Q.avail_in!==0&&!Q.input||J.status===KQ&&Y!==p0)return U9(Q,Q.avail_out===0?QY:X8);const X=J.last_flush;if(J.last_flush=Y,J.pending!==0){if(g0(Q),Q.avail_out===0)return J.last_flush=-1,R0}else if(Q.avail_in===0&&tq(Y)<=tq(X)&&Y!==p0)return U9(Q,QY);if(J.status===KQ&&Q.avail_in!==0)return U9(Q,QY);if(J.status===y9&&J.wrap===0)J.status=V9;if(J.status===y9){let q=hJ+(J.w_bits-8<<4)<<8,G=-1;if(J.strategy>=AJ||J.level<2)G=0;else if(J.level<6)G=1;else if(J.level===6)G=2;else G=3;if(q|=G<<6,J.strstart!==0)q|=CV;if(q+=31-q%31,zQ(J,q),J.strstart!==0)zQ(J,Q.adler>>>16),zQ(J,Q.adler&65535);if(Q.adler=1,J.status=V9,g0(Q),J.pending!==0)return J.last_flush=-1,R0}if(J.status===NY)if(Q.adler=0,n(J,31),n(J,139),n(J,8),!J.gzhead){if(n(J,0),n(J,0),n(J,0),n(J,0),n(J,0),n(J,J.level===9?2:J.strategy>=AJ||J.level<2?4:0),n(J,NV),J.status=V9,g0(Q),J.pending!==0)return J.last_flush=-1,R0}else{if(n(J,(J.gzhead.text?1:0)+(J.gzhead.hcrc?2:0)+(!J.gzhead.extra?0:4)+(!J.gzhead.name?0:8)+(!J.gzhead.comment?0:16)),n(J,J.gzhead.time&255),n(J,J.gzhead.time>>8&255),n(J,J.gzhead.time>>16&255),n(J,J.gzhead.time>>24&255),n(J,J.level===9?2:J.strategy>=AJ||J.level<2?4:0),n(J,J.gzhead.os&255),J.gzhead.extra&&J.gzhead.extra.length)n(J,J.gzhead.extra.length&255),n(J,J.gzhead.extra.length>>8&255);if(J.gzhead.hcrc)Q.adler=M0(Q.adler,J.pending_buf,J.pending,0);J.gzindex=0,J.status=IY}if(J.status===IY){if(J.gzhead.extra){let q=J.pending,G=(J.gzhead.extra.length&65535)-J.gzindex;while(J.pending+G>J.pending_buf_size){let V=J.pending_buf_size-J.pending;if(J.pending_buf.set(J.gzhead.extra.subarray(J.gzindex,J.gzindex+V),J.pending),J.pending=J.pending_buf_size,J.gzhead.hcrc&&J.pending>q)Q.adler=M0(Q.adler,J.pending_buf,J.pending-q,q);if(J.gzindex+=V,g0(Q),J.pending!==0)return J.last_flush=-1,R0;q=0,G-=V}let W=new Uint8Array(J.gzhead.extra);if(J.pending_buf.set(W.subarray(J.gzindex,J.gzindex+G),J.pending),J.pending+=G,J.gzhead.hcrc&&J.pending>q)Q.adler=M0(Q.adler,J.pending_buf,J.pending-q,q);J.gzindex=0}J.status=OY}if(J.status===OY){if(J.gzhead.name){let q=J.pending,G;do{if(J.pending===J.pending_buf_size){if(J.gzhead.hcrc&&J.pending>q)Q.adler=M0(Q.adler,J.pending_buf,J.pending-q,q);if(g0(Q),J.pending!==0)return J.last_flush=-1,R0;q=0}if(J.gzindex<J.gzhead.name.length)G=J.gzhead.name.charCodeAt(J.gzindex++)&255;else G=0;n(J,G)}while(G!==0);if(J.gzhead.hcrc&&J.pending>q)Q.adler=M0(Q.adler,J.pending_buf,J.pending-q,q);J.gzindex=0}J.status=RY}if(J.status===RY){if(J.gzhead.comment){let q=J.pending,G;do{if(J.pending===J.pending_buf_size){if(J.gzhead.hcrc&&J.pending>q)Q.adler=M0(Q.adler,J.pending_buf,J.pending-q,q);if(g0(Q),J.pending!==0)return J.last_flush=-1,R0;q=0}if(J.gzindex<J.gzhead.comment.length)G=J.gzhead.comment.charCodeAt(J.gzindex++)&255;else G=0;n(J,G)}while(G!==0);if(J.gzhead.hcrc&&J.pending>q)Q.adler=M0(Q.adler,J.pending_buf,J.pending-q,q)}J.status=HY}if(J.status===HY){if(J.gzhead.hcrc){if(J.pending+2>J.pending_buf_size){if(g0(Q),J.pending!==0)return J.last_flush=-1,R0}n(J,Q.adler&255),n(J,Q.adler>>8&255),Q.adler=0}if(J.status=V9,g0(Q),J.pending!==0)return J.last_flush=-1,R0}if(Q.avail_in!==0||J.lookahead!==0||Y!==_8&&J.status!==KQ){let q=J.level===0?l1(J,Y):J.strategy===AJ?BV(J,Y):J.strategy===$V?wV(J,Y):MQ[J.level].func(J,Y);if(q===Z9||q===c9)J.status=KQ;if(q===N0||q===Z9){if(Q.avail_out===0)J.last_flush=-1;return R0}if(q===_9){if(Y===qV)XV(J);else if(Y!==aq){if(KY(J,0,0,!1),Y===GV){if(y8(J.head),J.lookahead===0)J.strstart=0,J.block_start=0,J.insert=0}}if(g0(Q),Q.avail_out===0)return J.last_flush=-1,R0}}if(Y!==p0)return R0;if(J.wrap<=0)return sq;if(J.wrap===2)n(J,Q.adler&255),n(J,Q.adler>>8&255),n(J,Q.adler>>16&255),n(J,Q.adler>>24&255),n(J,Q.total_in&255),n(J,Q.total_in>>8&255),n(J,Q.total_in>>16&255),n(J,Q.total_in>>24&255);else zQ(J,Q.adler>>>16),zQ(J,Q.adler&65535);if(g0(Q),J.wrap>0)J.wrap=-J.wrap;return J.pending!==0?R0:sq},gV=(Q)=>{if(wQ(Q))return X8;const Y=Q.state.status;return Q.state=null,Y===V9?U9(Q,WV):R0},vV=(Q,Y)=>{let J=Y.length;if(wQ(Q))return X8;const X=Q.state,q=X.wrap;if(q===2||q===1&&X.status!==y9||X.lookahead)return X8;if(q===1)Q.adler=LQ(Q.adler,Y,J,0);if(X.wrap=0,J>=X.w_size){if(q===0)y8(X.head),X.strstart=0,X.block_start=0,X.insert=0;let $=new Uint8Array(X.w_size);$.set(Y.subarray(J-X.w_size,J),0),Y=$,J=X.w_size}const{avail_in:G,next_in:W,input:V}=Q;Q.avail_in=J,Q.next_in=0,Q.input=Y,h9(X);while(X.lookahead>=_){let $=X.strstart,U=X.lookahead-(_-1);do X.ins_h=c8(X,X.ins_h,X.window[$+_-1]),X.prev[$&X.w_mask]=X.head[X.ins_h],X.head[X.ins_h]=$,$++;while(--U);X.strstart=$,X.lookahead=_-1,h9(X)}return X.strstart+=X.lookahead,X.block_start=X.strstart,X.insert=X.lookahead,X.lookahead=0,X.match_length=X.prev_length=_-1,X.match_available=0,Q.next_in=W,Q.input=V,Q.avail_in=G,X.wrap=q,R0},fV=kV,bV=o1,yV=n1,hV=i1,mV=EV,_V=xV,cV=gV,pV=vV,uV="pako deflate (from Nodeca project)",OQ={deflateInit:fV,deflateInit2:bV,deflateReset:yV,deflateResetKeep:hV,deflateSetHeader:mV,deflate:_V,deflateEnd:cV,deflateSetDictionary:pV,deflateInfo:uV},dV=(Q,Y)=>{return Object.prototype.hasOwnProperty.call(Q,Y)},lV=function(Q){const Y=Array.prototype.slice.call(arguments,1);while(Y.length){const J=Y.shift();if(!J)continue;if(typeof J!=="object")throw new TypeError(J+"must be non-object");for(let X in J)if(dV(J,X))Q[X]=J[X]}return Q},iV=(Q)=>{let Y=0;for(let X=0,q=Q.length;X<q;X++)Y+=Q[X].length;const J=new Uint8Array(Y);for(let X=0,q=0,G=Q.length;X<G;X++){let W=Q[X];J.set(W,q),q+=W.length}return J},mJ={assign:lV,flattenChunks:iV},r1=!0;try{String.fromCharCode.apply(null,new Uint8Array(1))}catch(Q){r1=!1}var CQ=new Uint8Array(256);for(let Q=0;Q<256;Q++)CQ[Q]=Q>=252?6:Q>=248?5:Q>=240?4:Q>=224?3:Q>=192?2:1;CQ[254]=CQ[254]=1;var nV=(Q)=>{if(typeof TextEncoder==="function"&&TextEncoder.prototype.encode)return(new TextEncoder()).encode(Q);let Y,J,X,q,G,W=Q.length,V=0;for(q=0;q<W;q++){if(J=Q.charCodeAt(q),(J&64512)===55296&&q+1<W){if(X=Q.charCodeAt(q+1),(X&64512)===56320)J=65536+(J-55296<<10)+(X-56320),q++}V+=J<128?1:J<2048?2:J<65536?3:4}Y=new Uint8Array(V);for(G=0,q=0;G<V;q++){if(J=Q.charCodeAt(q),(J&64512)===55296&&q+1<W){if(X=Q.charCodeAt(q+1),(X&64512)===56320)J=65536+(J-55296<<10)+(X-56320),q++}if(J<128)Y[G++]=J;else if(J<2048)Y[G++]=192|J>>>6,Y[G++]=128|J&63;else if(J<65536)Y[G++]=224|J>>>12,Y[G++]=128|J>>>6&63,Y[G++]=128|J&63;else Y[G++]=240|J>>>18,Y[G++]=128|J>>>12&63,Y[G++]=128|J>>>6&63,Y[G++]=128|J&63}return Y},oV=(Q,Y)=>{if(Y<65534){if(Q.subarray&&r1)return String.fromCharCode.apply(null,Q.length===Y?Q:Q.subarray(0,Y))}let J="";for(let X=0;X<Y;X++)J+=String.fromCharCode(Q[X]);return J},rV=(Q,Y)=>{const J=Y||Q.length;if(typeof TextDecoder==="function"&&TextDecoder.prototype.decode)return(new TextDecoder()).decode(Q.subarray(0,Y));let X,q;const G=new Array(J*2);for(q=0,X=0;X<J;){let W=Q[X++];if(W<128){G[q++]=W;continue}let V=CQ[W];if(V>4){G[q++]=65533,X+=V-1;continue}W&=V===2?31:V===3?15:7;while(V>1&&X<J)W=W<<6|Q[X++]&63,V--;if(V>1){G[q++]=65533;continue}if(W<65536)G[q++]=W;else W-=65536,G[q++]=55296|W>>10&1023,G[q++]=56320|W&1023}return oV(G,q)},aV=(Q,Y)=>{if(Y=Y||Q.length,Y>Q.length)Y=Q.length;let J=Y-1;while(J>=0&&(Q[J]&192)===128)J--;if(J<0)return Y;if(J===0)return Y;return J+CQ[Q[J]]>Y?J:Y},NQ={string2buf:nV,buf2string:rV,utf8border:aV},a1=sV,s1=Object.prototype.toString,{Z_NO_FLUSH:tV,Z_SYNC_FLUSH:eV,Z_FULL_FLUSH:QU,Z_FINISH:JU,Z_OK:bJ,Z_STREAM_END:YU,Z_DEFAULT_COMPRESSION:XU,Z_DEFAULT_STRATEGY:qU,Z_DEFLATED:GU}=K9;BQ.prototype.push=function(Q,Y){const J=this.strm,X=this.options.chunkSize;let q,G;if(this.ended)return!1;if(Y===~~Y)G=Y;else G=Y===!0?JU:tV;if(typeof Q==="string")J.input=NQ.string2buf(Q);else if(s1.call(Q)==="[object ArrayBuffer]")J.input=new Uint8Array(Q);else J.input=Q;J.next_in=0,J.avail_in=J.input.length;for(;;){if(J.avail_out===0)J.output=new Uint8Array(X),J.next_out=0,J.avail_out=X;if((G===eV||G===QU)&&J.avail_out<=6){this.onData(J.output.subarray(0,J.next_out)),J.avail_out=0;continue}if(q=OQ.deflate(J,G),q===YU){if(J.next_out>0)this.onData(J.output.subarray(0,J.next_out));return q=OQ.deflateEnd(this.strm),this.onEnd(q),this.ended=!0,q===bJ}if(J.avail_out===0){this.onData(J.output);continue}if(G>0&&J.next_out>0){this.onData(J.output.subarray(0,J.next_out)),J.avail_out=0;continue}if(J.avail_in===0)break}return!0};BQ.prototype.onData=function(Q){this.chunks.push(Q)};BQ.prototype.onEnd=function(Q){if(Q===bJ)this.result=mJ.flattenChunks(this.chunks);this.chunks=[],this.err=Q,this.msg=this.strm.msg};var UU=BQ,$U=TY,ZU=WU,zU=VU,KU=K9,MU={Deflate:UU,deflate:$U,deflateRaw:ZU,gzip:zU,constants:KU},EJ=16209,IU=16191,OU=function Q(Y,J){let X,q,G,W,V,$,U,Z,K,M,I,z,R,H,D,j,w,P,C,S,L,g,A,B;const E=Y.state;X=Y.next_in,A=Y.input,q=X+(Y.avail_in-5),G=Y.next_out,B=Y.output,W=G-(J-Y.avail_out),V=G+(Y.avail_out-257),$=E.dmax,U=E.wsize,Z=E.whave,K=E.wnext,M=E.window,I=E.hold,z=E.bits,R=E.lencode,H=E.distcode,D=(1<<E.lenbits)-1,j=(1<<E.distbits)-1;Q:do{if(z<15)I+=A[X++]<<z,z+=8,I+=A[X++]<<z,z+=8;w=R[I&D];J:for(;;){if(P=w>>>24,I>>>=P,z-=P,P=w>>>16&255,P===0)B[G++]=w&65535;else if(P&16){if(C=w&65535,P&=15,P){if(z<P)I+=A[X++]<<z,z+=8;C+=I&(1<<P)-1,I>>>=P,z-=P}if(z<15)I+=A[X++]<<z,z+=8,I+=A[X++]<<z,z+=8;w=H[I&j];Y:for(;;){if(P=w>>>24,I>>>=P,z-=P,P=w>>>16&255,P&16){if(S=w&65535,P&=15,z<P){if(I+=A[X++]<<z,z+=8,z<P)I+=A[X++]<<z,z+=8}if(S+=I&(1<<P)-1,S>$){Y.msg="invalid distance too far back",E.mode=EJ;break Q}if(I>>>=P,z-=P,P=G-W,S>P){if(P=S-P,P>Z){if(E.sane){Y.msg="invalid distance too far back",E.mode=EJ;break Q}}if(L=0,g=M,K===0){if(L+=U-P,P<C){C-=P;do B[G++]=M[L++];while(--P);L=G-S,g=B}}else if(K<P){if(L+=U+K-P,P-=K,P<C){C-=P;do B[G++]=M[L++];while(--P);if(L=0,K<C){P=K,C-=P;do B[G++]=M[L++];while(--P);L=G-S,g=B}}}else if(L+=K-P,P<C){C-=P;do B[G++]=M[L++];while(--P);L=G-S,g=B}while(C>2)B[G++]=g[L++],B[G++]=g[L++],B[G++]=g[L++],C-=3;if(C){if(B[G++]=g[L++],C>1)B[G++]=g[L++]}}else{L=G-S;do B[G++]=B[L++],B[G++]=B[L++],B[G++]=B[L++],C-=3;while(C>2);if(C){if(B[G++]=B[L++],C>1)B[G++]=B[L++]}}}else if((P&64)===0){w=H[(w&65535)+(I&(1<<P)-1)];continue Y}else{Y.msg="invalid distance code",E.mode=EJ;break Q}break}}else if((P&64)===0){w=R[(w&65535)+(I&(1<<P)-1)];continue J}else if(P&32){E.mode=IU;break Q}else{Y.msg="invalid literal/length code",E.mode=EJ;break Q}break}}while(X<q&&G<V);C=z>>3,X-=C,z-=C<<3,I&=(1<<z)-1,Y.next_in=X,Y.next_out=G,Y.avail_in=X<q?5+(q-X):5-(X-q),Y.avail_out=G<V?257+(V-G):257-(G-V),E.hold=I,E.bits=z;return},f9=15,eq=852,Q1=592,J1=0,YY=1,Y1=2,RU=new Uint16Array([3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,0,0]),HU=new Uint8Array([16,16,16,16,16,16,16,16,17,17,17,17,18,18,18,18,19,19,19,19,20,20,20,20,21,21,21,21,16,72,78]),DU=new Uint16Array([1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,0,0]),PU=new Uint8Array([16,16,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,64,64]),jU=(Q,Y,J,X,q,G,W,V)=>{const $=V.bits;let U=0,Z=0,K=0,M=0,I=0,z=0,R=0,H=0,D=0,j=0,w,P,C,S,L,g=null,A;const B=new Uint16Array(f9+1),E=new Uint16Array(f9+1);let c=null,G0,p,F;for(U=0;U<=f9;U++)B[U]=0;for(Z=0;Z<X;Z++)B[Y[J+Z]]++;I=$;for(M=f9;M>=1;M--)if(B[M]!==0)break;if(I>M)I=M;if(M===0)return q[G++]=1<<24|64<<16|0,q[G++]=1<<24|64<<16|0,V.bits=1,0;for(K=1;K<M;K++)if(B[K]!==0)break;if(I<K)I=K;H=1;for(U=1;U<=f9;U++)if(H<<=1,H-=B[U],H<0)return-1;if(H>0&&(Q===J1||M!==1))return-1;E[1]=0;for(U=1;U<f9;U++)E[U+1]=E[U]+B[U];for(Z=0;Z<X;Z++)if(Y[J+Z]!==0)W[E[Y[J+Z]]++]=Z;if(Q===J1)g=c=W,A=20;else if(Q===YY)g=RU,c=HU,A=257;else g=DU,c=PU,A=0;if(j=0,Z=0,U=K,L=G,z=I,R=0,C=-1,D=1<<I,S=D-1,Q===YY&&D>eq||Q===Y1&&D>Q1)return 1;for(;;){if(G0=U-R,W[Z]+1<A)p=0,F=W[Z];else if(W[Z]>=A)p=c[W[Z]-A],F=g[W[Z]-A];else p=96,F=0;w=1<<U-R,P=1<<z,K=P;do P-=w,q[L+(j>>R)+P]=G0<<24|p<<16|F|0;while(P!==0);w=1<<U-1;while(j&w)w>>=1;if(w!==0)j&=w-1,j+=w;else j=0;if(Z++,--B[U]===0){if(U===M)break;U=Y[J+W[Z]]}if(U>I&&(j&S)!==C){if(R===0)R=I;L+=K,z=U-R,H=1<<z;while(z+R<M){if(H-=B[z+R],H<=0)break;z++,H<<=1}if(D+=1<<z,Q===YY&&D>eq||Q===Y1&&D>Q1)return 1;C=j&S,q[C]=I<<24|z<<16|L-G|0}}if(j!==0)q[L+j]=U-R<<24|64<<16|0;return V.bits=I,0},RQ=jU,LU=0,t1=1,e1=2,{Z_FINISH:X1,Z_BLOCK:CU,Z_TREES:kJ,Z_OK:z9,Z_STREAM_END:NU,Z_NEED_DICT:TU,Z_STREAM_ERROR:u0,Z_DATA_ERROR:Q7,Z_MEM_ERROR:J7,Z_BUF_ERROR:FU,Z_DEFLATED:q1}=K9,_J=16180,G1=16181,W1=16182,V1=16183,U1=16184,$1=16185,Z1=16186,z1=16187,K1=16188,M1=16189,yJ=16190,T8=16191,XY=16192,I1=16193,qY=16194,O1=16195,R1=16196,H1=16197,D1=16198,xJ=16199,gJ=16200,P1=16201,j1=16202,L1=16203,C1=16204,N1=16205,GY=16206,T1=16207,F1=16208,Q0=16209,Y7=16210,X7=16211,wU=852,BU=592,SU=15,AU=SU,w1=(Q)=>{return(Q>>>24&255)+(Q>>>8&65280)+((Q&65280)<<8)+((Q&255)<<24)},M9=(Q)=>{if(!Q)return 1;const Y=Q.state;if(!Y||Y.strm!==Q||Y.mode<_J||Y.mode>X7)return 1;return 0},q7=(Q)=>{if(M9(Q))return u0;const Y=Q.state;if(Q.total_in=Q.total_out=Y.total=0,Q.msg="",Y.wrap)Q.adler=Y.wrap&1;return Y.mode=_J,Y.last=0,Y.havedict=0,Y.flags=-1,Y.dmax=32768,Y.head=null,Y.hold=0,Y.bits=0,Y.lencode=Y.lendyn=new Int32Array(wU),Y.distcode=Y.distdyn=new Int32Array(BU),Y.sane=1,Y.back=-1,z9},G7=(Q)=>{if(M9(Q))return u0;const Y=Q.state;return Y.wsize=0,Y.whave=0,Y.wnext=0,q7(Q)},W7=(Q,Y)=>{let J;if(M9(Q))return u0;const X=Q.state;if(Y<0)J=0,Y=-Y;else if(J=(Y>>4)+5,Y<48)Y&=15;if(Y&&(Y<8||Y>15))return u0;if(X.window!==null&&X.wbits!==Y)X.window=null;return X.wrap=J,X.wbits=Y,G7(Q)},V7=(Q,Y)=>{if(!Q)return u0;const J=new EU;Q.state=J,J.strm=Q,J.window=null,J.mode=_J;const X=W7(Q,Y);if(X!==z9)Q.state=null;return X},kU=(Q)=>{return V7(Q,AU)},B1=!0,WY,VY,xU=(Q)=>{if(B1){WY=new Int32Array(512),VY=new Int32Array(32);let Y=0;while(Y<144)Q.lens[Y++]=8;while(Y<256)Q.lens[Y++]=9;while(Y<280)Q.lens[Y++]=7;while(Y<288)Q.lens[Y++]=8;RQ(t1,Q.lens,0,288,WY,0,Q.work,{bits:9}),Y=0;while(Y<32)Q.lens[Y++]=5;RQ(e1,Q.lens,0,32,VY,0,Q.work,{bits:5}),B1=!1}Q.lencode=WY,Q.lenbits=9,Q.distcode=VY,Q.distbits=5},U7=(Q,Y,J,X)=>{let q;const G=Q.state;if(G.window===null)G.wsize=1<<G.wbits,G.wnext=0,G.whave=0,G.window=new Uint8Array(G.wsize);if(X>=G.wsize)G.window.set(Y.subarray(J-G.wsize,J),0),G.wnext=0,G.whave=G.wsize;else{if(q=G.wsize-G.wnext,q>X)q=X;if(G.window.set(Y.subarray(J-X,J-X+q),G.wnext),X-=q,X)G.window.set(Y.subarray(J-X,J),0),G.wnext=X,G.whave=G.wsize;else{if(G.wnext+=q,G.wnext===G.wsize)G.wnext=0;if(G.whave<G.wsize)G.whave+=q}}return 0},gU=(Q,Y)=>{let J,X,q,G,W,V,$,U,Z,K,M,I,z,R,H=0,D,j,w,P,C,S,L,g;const A=new Uint8Array(4);let B,E;const c=new Uint8Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]);if(M9(Q)||!Q.output||!Q.input&&Q.avail_in!==0)return u0;if(J=Q.state,J.mode===T8)J.mode=XY;W=Q.next_out,q=Q.output,$=Q.avail_out,G=Q.next_in,X=Q.input,V=Q.avail_in,U=J.hold,Z=J.bits,K=V,M=$,g=z9;Q:for(;;)switch(J.mode){case _J:if(J.wrap===0){J.mode=XY;break}while(Z<16){if(V===0)break Q;V--,U+=X[G++]<<Z,Z+=8}if(J.wrap&2&&U===35615){if(J.wbits===0)J.wbits=15;J.check=0,A[0]=U&255,A[1]=U>>>8&255,J.check=M0(J.check,A,2,0),U=0,Z=0,J.mode=G1;break}if(J.head)J.head.done=!1;if(!(J.wrap&1)||(((U&255)<<8)+(U>>8))%31){Q.msg="incorrect header check",J.mode=Q0;break}if((U&15)!==q1){Q.msg="unknown compression method",J.mode=Q0;break}if(U>>>=4,Z-=4,L=(U&15)+8,J.wbits===0)J.wbits=L;if(L>15||L>J.wbits){Q.msg="invalid window size",J.mode=Q0;break}J.dmax=1<<J.wbits,J.flags=0,Q.adler=J.check=1,J.mode=U&512?M1:T8,U=0,Z=0;break;case G1:while(Z<16){if(V===0)break Q;V--,U+=X[G++]<<Z,Z+=8}if(J.flags=U,(J.flags&255)!==q1){Q.msg="unknown compression method",J.mode=Q0;break}if(J.flags&57344){Q.msg="unknown header flags set",J.mode=Q0;break}if(J.head)J.head.text=U>>8&1;if(J.flags&512&&J.wrap&4)A[0]=U&255,A[1]=U>>>8&255,J.check=M0(J.check,A,2,0);U=0,Z=0,J.mode=W1;case W1:while(Z<32){if(V===0)break Q;V--,U+=X[G++]<<Z,Z+=8}if(J.head)J.head.time=U;if(J.flags&512&&J.wrap&4)A[0]=U&255,A[1]=U>>>8&255,A[2]=U>>>16&255,A[3]=U>>>24&255,J.check=M0(J.check,A,4,0);U=0,Z=0,J.mode=V1;case V1:while(Z<16){if(V===0)break Q;V--,U+=X[G++]<<Z,Z+=8}if(J.head)J.head.xflags=U&255,J.head.os=U>>8;if(J.flags&512&&J.wrap&4)A[0]=U&255,A[1]=U>>>8&255,J.check=M0(J.check,A,2,0);U=0,Z=0,J.mode=U1;case U1:if(J.flags&1024){while(Z<16){if(V===0)break Q;V--,U+=X[G++]<<Z,Z+=8}if(J.length=U,J.head)J.head.extra_len=U;if(J.flags&512&&J.wrap&4)A[0]=U&255,A[1]=U>>>8&255,J.check=M0(J.check,A,2,0);U=0,Z=0}else if(J.head)J.head.extra=null;J.mode=$1;case $1:if(J.flags&1024){if(I=J.length,I>V)I=V;if(I){if(J.head){if(L=J.head.extra_len-J.length,!J.head.extra)J.head.extra=new Uint8Array(J.head.extra_len);J.head.extra.set(X.subarray(G,G+I),L)}if(J.flags&512&&J.wrap&4)J.check=M0(J.check,X,I,G);V-=I,G+=I,J.length-=I}if(J.length)break Q}J.length=0,J.mode=Z1;case Z1:if(J.flags&2048){if(V===0)break Q;I=0;do if(L=X[G+I++],J.head&&L&&J.length<65536)J.head.name+=String.fromCharCode(L);while(L&&I<V);if(J.flags&512&&J.wrap&4)J.check=M0(J.check,X,I,G);if(V-=I,G+=I,L)break Q}else if(J.head)J.head.name=null;J.length=0,J.mode=z1;case z1:if(J.flags&4096){if(V===0)break Q;I=0;do if(L=X[G+I++],J.head&&L&&J.length<65536)J.head.comment+=String.fromCharCode(L);while(L&&I<V);if(J.flags&512&&J.wrap&4)J.check=M0(J.check,X,I,G);if(V-=I,G+=I,L)break Q}else if(J.head)J.head.comment=null;J.mode=K1;case K1:if(J.flags&512){while(Z<16){if(V===0)break Q;V--,U+=X[G++]<<Z,Z+=8}if(J.wrap&4&&U!==(J.check&65535)){Q.msg="header crc mismatch",J.mode=Q0;break}U=0,Z=0}if(J.head)J.head.hcrc=J.flags>>9&1,J.head.done=!0;Q.adler=J.check=0,J.mode=T8;break;case M1:while(Z<32){if(V===0)break Q;V--,U+=X[G++]<<Z,Z+=8}Q.adler=J.check=w1(U),U=0,Z=0,J.mode=yJ;case yJ:if(J.havedict===0)return Q.next_out=W,Q.avail_out=$,Q.next_in=G,Q.avail_in=V,J.hold=U,J.bits=Z,TU;Q.adler=J.check=1,J.mode=T8;case T8:if(Y===CU||Y===kJ)break Q;case XY:if(J.last){U>>>=Z&7,Z-=Z&7,J.mode=GY;break}while(Z<3){if(V===0)break Q;V--,U+=X[G++]<<Z,Z+=8}switch(J.last=U&1,U>>>=1,Z-=1,U&3){case 0:J.mode=I1;break;case 1:if(xU(J),J.mode=xJ,Y===kJ){U>>>=2,Z-=2;break Q}break;case 2:J.mode=R1;break;case 3:Q.msg="invalid block type",J.mode=Q0}U>>>=2,Z-=2;break;case I1:U>>>=Z&7,Z-=Z&7;while(Z<32){if(V===0)break Q;V--,U+=X[G++]<<Z,Z+=8}if((U&65535)!==(U>>>16^65535)){Q.msg="invalid stored block lengths",J.mode=Q0;break}if(J.length=U&65535,U=0,Z=0,J.mode=qY,Y===kJ)break Q;case qY:J.mode=O1;case O1:if(I=J.length,I){if(I>V)I=V;if(I>$)I=$;if(I===0)break Q;q.set(X.subarray(G,G+I),W),V-=I,G+=I,$-=I,W+=I,J.length-=I;break}J.mode=T8;break;case R1:while(Z<14){if(V===0)break Q;V--,U+=X[G++]<<Z,Z+=8}if(J.nlen=(U&31)+257,U>>>=5,Z-=5,J.ndist=(U&31)+1,U>>>=5,Z-=5,J.ncode=(U&15)+4,U>>>=4,Z-=4,J.nlen>286||J.ndist>30){Q.msg="too many length or distance symbols",J.mode=Q0;break}J.have=0,J.mode=H1;case H1:while(J.have<J.ncode){while(Z<3){if(V===0)break Q;V--,U+=X[G++]<<Z,Z+=8}J.lens[c[J.have++]]=U&7,U>>>=3,Z-=3}while(J.have<19)J.lens[c[J.have++]]=0;if(J.lencode=J.lendyn,J.lenbits=7,B={bits:J.lenbits},g=RQ(LU,J.lens,0,19,J.lencode,0,J.work,B),J.lenbits=B.bits,g){Q.msg="invalid code lengths set",J.mode=Q0;break}J.have=0,J.mode=D1;case D1:while(J.have<J.nlen+J.ndist){for(;;){if(H=J.lencode[U&(1<<J.lenbits)-1],D=H>>>24,j=H>>>16&255,w=H&65535,D<=Z)break;if(V===0)break Q;V--,U+=X[G++]<<Z,Z+=8}if(w<16)U>>>=D,Z-=D,J.lens[J.have++]=w;else{if(w===16){E=D+2;while(Z<E){if(V===0)break Q;V--,U+=X[G++]<<Z,Z+=8}if(U>>>=D,Z-=D,J.have===0){Q.msg="invalid bit length repeat",J.mode=Q0;break}L=J.lens[J.have-1],I=3+(U&3),U>>>=2,Z-=2}else if(w===17){E=D+3;while(Z<E){if(V===0)break Q;V--,U+=X[G++]<<Z,Z+=8}U>>>=D,Z-=D,L=0,I=3+(U&7),U>>>=3,Z-=3}else{E=D+7;while(Z<E){if(V===0)break Q;V--,U+=X[G++]<<Z,Z+=8}U>>>=D,Z-=D,L=0,I=11+(U&127),U>>>=7,Z-=7}if(J.have+I>J.nlen+J.ndist){Q.msg="invalid bit length repeat",J.mode=Q0;break}while(I--)J.lens[J.have++]=L}}if(J.mode===Q0)break;if(J.lens[256]===0){Q.msg="invalid code -- missing end-of-block",J.mode=Q0;break}if(J.lenbits=9,B={bits:J.lenbits},g=RQ(t1,J.lens,0,J.nlen,J.lencode,0,J.work,B),J.lenbits=B.bits,g){Q.msg="invalid literal/lengths set",J.mode=Q0;break}if(J.distbits=6,J.distcode=J.distdyn,B={bits:J.distbits},g=RQ(e1,J.lens,J.nlen,J.ndist,J.distcode,0,J.work,B),J.distbits=B.bits,g){Q.msg="invalid distances set",J.mode=Q0;break}if(J.mode=xJ,Y===kJ)break Q;case xJ:J.mode=gJ;case gJ:if(V>=6&&$>=258){if(Q.next_out=W,Q.avail_out=$,Q.next_in=G,Q.avail_in=V,J.hold=U,J.bits=Z,OU(Q,M),W=Q.next_out,q=Q.output,$=Q.avail_out,G=Q.next_in,X=Q.input,V=Q.avail_in,U=J.hold,Z=J.bits,J.mode===T8)J.back=-1;break}J.back=0;for(;;){if(H=J.lencode[U&(1<<J.lenbits)-1],D=H>>>24,j=H>>>16&255,w=H&65535,D<=Z)break;if(V===0)break Q;V--,U+=X[G++]<<Z,Z+=8}if(j&&(j&240)===0){P=D,C=j,S=w;for(;;){if(H=J.lencode[S+((U&(1<<P+C)-1)>>P)],D=H>>>24,j=H>>>16&255,w=H&65535,P+D<=Z)break;if(V===0)break Q;V--,U+=X[G++]<<Z,Z+=8}U>>>=P,Z-=P,J.back+=P}if(U>>>=D,Z-=D,J.back+=D,J.length=w,j===0){J.mode=N1;break}if(j&32){J.back=-1,J.mode=T8;break}if(j&64){Q.msg="invalid literal/length code",J.mode=Q0;break}J.extra=j&15,J.mode=P1;case P1:if(J.extra){E=J.extra;while(Z<E){if(V===0)break Q;V--,U+=X[G++]<<Z,Z+=8}J.length+=U&(1<<J.extra)-1,U>>>=J.extra,Z-=J.extra,J.back+=J.extra}J.was=J.length,J.mode=j1;case j1:for(;;){if(H=J.distcode[U&(1<<J.distbits)-1],D=H>>>24,j=H>>>16&255,w=H&65535,D<=Z)break;if(V===0)break Q;V--,U+=X[G++]<<Z,Z+=8}if((j&240)===0){P=D,C=j,S=w;for(;;){if(H=J.distcode[S+((U&(1<<P+C)-1)>>P)],D=H>>>24,j=H>>>16&255,w=H&65535,P+D<=Z)break;if(V===0)break Q;V--,U+=X[G++]<<Z,Z+=8}U>>>=P,Z-=P,J.back+=P}if(U>>>=D,Z-=D,J.back+=D,j&64){Q.msg="invalid distance code",J.mode=Q0;break}J.offset=w,J.extra=j&15,J.mode=L1;case L1:if(J.extra){E=J.extra;while(Z<E){if(V===0)break Q;V--,U+=X[G++]<<Z,Z+=8}J.offset+=U&(1<<J.extra)-1,U>>>=J.extra,Z-=J.extra,J.back+=J.extra}if(J.offset>J.dmax){Q.msg="invalid distance too far back",J.mode=Q0;break}J.mode=C1;case C1:if($===0)break Q;if(I=M-$,J.offset>I){if(I=J.offset-I,I>J.whave){if(J.sane){Q.msg="invalid distance too far back",J.mode=Q0;break}}if(I>J.wnext)I-=J.wnext,z=J.wsize-I;else z=J.wnext-I;if(I>J.length)I=J.length;R=J.window}else R=q,z=W-J.offset,I=J.length;if(I>$)I=$;$-=I,J.length-=I;do q[W++]=R[z++];while(--I);if(J.length===0)J.mode=gJ;break;case N1:if($===0)break Q;q[W++]=J.length,$--,J.mode=gJ;break;case GY:if(J.wrap){while(Z<32){if(V===0)break Q;V--,U|=X[G++]<<Z,Z+=8}if(M-=$,Q.total_out+=M,J.total+=M,J.wrap&4&&M)Q.adler=J.check=J.flags?M0(J.check,q,M,W-M):LQ(J.check,q,M,W-M);if(M=$,J.wrap&4&&(J.flags?U:w1(U))!==J.check){Q.msg="incorrect data check",J.mode=Q0;break}U=0,Z=0}J.mode=T1;case T1:if(J.wrap&&J.flags){while(Z<32){if(V===0)break Q;V--,U+=X[G++]<<Z,Z+=8}if(J.wrap&4&&U!==(J.total&4294967295)){Q.msg="incorrect length check",J.mode=Q0;break}U=0,Z=0}J.mode=F1;case F1:g=NU;break Q;case Q0:g=Q7;break Q;case Y7:return J7;case X7:default:return u0}if(Q.next_out=W,Q.avail_out=$,Q.next_in=G,Q.avail_in=V,J.hold=U,J.bits=Z,J.wsize||M!==Q.avail_out&&J.mode<Q0&&(J.mode<GY||Y!==X1)){if(U7(Q,Q.output,Q.next_out,M-Q.avail_out));}if(K-=Q.avail_in,M-=Q.avail_out,Q.total_in+=K,Q.total_out+=M,J.total+=M,J.wrap&4&&M)Q.adler=J.check=J.flags?M0(J.check,q,M,Q.next_out-M):LQ(J.check,q,M,Q.next_out-M);if(Q.data_type=J.bits+(J.last?64:0)+(J.mode===T8?128:0)+(J.mode===xJ||J.mode===qY?256:0),(K===0&&M===0||Y===X1)&&g===z9)g=FU;return g},vU=(Q)=>{if(M9(Q))return u0;let Y=Q.state;if(Y.window)Y.window=null;return Q.state=null,z9},fU=(Q,Y)=>{if(M9(Q))return u0;const J=Q.state;if((J.wrap&2)===0)return u0;return J.head=Y,Y.done=!1,z9},bU=(Q,Y)=>{const J=Y.length;let X,q,G;if(M9(Q))return u0;if(X=Q.state,X.wrap!==0&&X.mode!==yJ)return u0;if(X.mode===yJ){if(q=1,q=LQ(q,Y,J,0),q!==X.check)return Q7}if(G=U7(Q,Y,J,J),G)return X.mode=Y7,J7;return X.havedict=1,z9},yU=G7,hU=W7,mU=q7,_U=kU,cU=V7,pU=gU,uU=vU,dU=fU,lU=bU,iU="pako inflate (from Nodeca project)",w8={inflateReset:yU,inflateReset2:hU,inflateResetKeep:mU,inflateInit:_U,inflateInit2:cU,inflate:pU,inflateEnd:uU,inflateGetHeader:dU,inflateSetDictionary:lU,inflateInfo:iU},oU=nU,$7=Object.prototype.toString,{Z_NO_FLUSH:rU,Z_FINISH:aU,Z_OK:TQ,Z_STREAM_END:UY,Z_NEED_DICT:$Y,Z_STREAM_ERROR:sU,Z_DATA_ERROR:S1,Z_MEM_ERROR:tU}=K9;SQ.prototype.push=function(Q,Y){const J=this.strm,X=this.options.chunkSize,q=this.options.dictionary;let G,W,V;if(this.ended)return!1;if(Y===~~Y)W=Y;else W=Y===!0?aU:rU;if($7.call(Q)==="[object ArrayBuffer]")J.input=new Uint8Array(Q);else J.input=Q;J.next_in=0,J.avail_in=J.input.length;for(;;){if(J.avail_out===0)J.output=new Uint8Array(X),J.next_out=0,J.avail_out=X;if(G=w8.inflate(J,W),G===$Y&&q){if(G=w8.inflateSetDictionary(J,q),G===TQ)G=w8.inflate(J,W);else if(G===S1)G=$Y}while(J.avail_in>0&&G===UY&&J.state.wrap>0&&Q[J.next_in]!==0)w8.inflateReset(J),G=w8.inflate(J,W);switch(G){case sU:case S1:case $Y:case tU:return this.onEnd(G),this.ended=!0,!1}if(V=J.avail_out,J.next_out){if(J.avail_out===0||G===UY)if(this.options.to==="string"){let $=NQ.utf8border(J.output,J.next_out),U=J.next_out-$,Z=NQ.buf2string(J.output,$);if(J.next_out=U,J.avail_out=X-U,U)J.output.set(J.output.subarray($,$+U),0);this.onData(Z)}else this.onData(J.output.length===J.next_out?J.output:J.output.subarray(0,J.next_out))}if(G===TQ&&V===0)continue;if(G===UY)return G=w8.inflateEnd(this.strm),this.onEnd(G),this.ended=!0,!0;if(J.avail_in===0)break}return!0};SQ.prototype.onData=function(Q){this.chunks.push(Q)};SQ.prototype.onEnd=function(Q){if(Q===TQ)if(this.options.to==="string")this.result=this.chunks.join("");else this.result=mJ.flattenChunks(this.chunks);this.chunks=[],this.err=Q,this.msg=this.strm.msg};var Q4=SQ,J4=FY,Y4=eU,X4=FY,q4=K9,G4={Inflate:Q4,inflate:J4,inflateRaw:Y4,ungzip:X4,constants:q4},{Deflate:W4,deflate:V4,deflateRaw:U4,gzip:$4}=MU,{Inflate:Z4,inflate:z4,inflateRaw:K4,ungzip:M4}=G4,I4=W4,O4=V4,R4=U4,H4=$4,D4=Z4,P4=z4,j4=K4,L4=M4,C4=K9,wY={Deflate:I4,deflate:O4,deflateRaw:R4,gzip:H4,Inflate:D4,inflate:P4,inflateRaw:j4,ungzip:L4,constants:C4};class cJ{constructor(Q,Y,J,X=[]){if(this.signer=Q,this.dbInstance=Y,this.rbac=J,this.superAdminEthereumAddresses=(X||[]).map((q)=>{try{return y(q)}catch(G){return console.warn(`SSM: Invalid superadmin address skipped: ${q}`),null}}).filter(Boolean),this.localUserEthAddress=null,this._initializedPromise=this.signer&&typeof this.signer.getAddress==="function"?this._initializeAndGetAddress():Promise.resolve(),!this.signer)console.log("SSM: Instance ready for anonymous verification (no local signer).")}async _initializeAndGetAddress(){if(this.signer)this.localUserEthAddress=y(await this.signer.getAddress()),console.log(`SSM: Initialized with signer for ${this.localUserEthAddress}. SuperAdmins: ${this.superAdminEthereumAddresses.join(", ")}`)}async ready(){return this._initializedPromise}_canonicalizeDataForSigning(Q){return JSON.stringify(Q,Object.keys(Q).sort())}async signOutgoingOperations(Q){if(!this.signer||!this.localUserEthAddress)return console.error("SSM: Cannot sign operations. No active signer."),[];const Y=this.localUserEthAddress,J=[];for(let X of Q){const q={...X,originUser:Y},G=this._canonicalizeDataForSigning(q);try{const W=await this.signer.signMessage(Z0(G));J.push({...X,originUser:Y,originEthAddress:Y,signature:W})}catch(W){console.error(`SSM: Error signing operation for ${Y}:`,W.message)}}return J}async verifyIncomingOperations(Q,Y){const J=[];for(let q of Q){let G=null,W=null;if(!q.signature||!q.originEthAddress||!q.originUser){console.warn(`SSM: Incomplete op from ${Y}. DISCARDING.`,q);continue}try{if(G=y(q.originEthAddress),y(q.originUser)!==G){console.warn(`SSM: Address discrepancy in op from ${Y}. DISCARDING.`,q);continue}}catch(R){console.warn(`SSM: Invalid address in op from ${Y}. DISCARDING.`,R.message);continue}const{signature:V,originEthAddress:$,...U}=q;W=U;const Z=this._canonicalizeDataForSigning(W);try{const R=ZJ(Z0(Z),V);if(y(R)!==G){console.warn(`SSM: INVALID signature for op from ${Y}. DISCARDING.`,W);continue}}catch(R){console.error(`SSM: Signature verification error for op from ${Y}. DISCARDING.`,R.message);continue}const M=(await this.dbInstance.get(`user:${G}`)).result?.value?.role||"guest",I=W.type;let z=!1;if(I==="deltaSync"){if(!this.rbac.can(M,"sync")){console.warn(`SSM: Sender ${G} (role: ${M}) DENIED 'sync' permission. Delta package rejected.`);continue}try{const R=r5(wY.inflate(W.operations)),H=[];for(let D of R){const j=this.rbac.mapChangeTypeToRbacAction(D.type,D);if(this.rbac.can(M,j))H.push(D);else console.warn(`SSM: Sender ${G} (role: ${M}) DENIED inner op with action '${j}'.`,D)}if(H.length>0){if(H.length<R.length)W.operations=wY.deflate(l5(H));z=!0}}catch(R){console.error(`SSM: Failed to decompress/decode deltaSync from ${G}. DISCARDING.`,R)}}else{const R=this.rbac.mapChangeTypeToRbacAction(I,W);if(this.rbac.can(M,R))z=!0}if(z)J.push(W);else if(I!=="deltaSync"){const R=this.rbac.mapChangeTypeToRbacAction(I,W);console.warn(`SSM: Sender ${G} (role: ${M}) DENIED operation with action '${R}'.`,W)}}return{validatedOperations:J}}async encryptDataForCurrentUser(Q){if(await this.ready(),!this.signer)throw new Error("SSM Encrypt: User session (signer) required for encryption.");try{const Y=await this._deriveAesKeyInternal("ssm-encrypt-for-current-user-v1"),J=JSON.stringify(Q),X=Z0(J),q=this.dbInstance.compress(X),G=V0(12),W=await crypto.subtle.encrypt({name:"AES-GCM",iv:G},Y,q);return JSON.stringify({iv:N(G),encrypted:N(new Uint8Array(W)),type:"aes-gcm-self-ssm-v2"})}catch(Y){throw console.error("SSM: Error in encryptDataForCurrentUser:",Y),new Error("SSM: Failed to encrypt personal data.")}}async decryptDataForCurrentUser(Q){if(await this.ready(),!this.signer)throw new Error("SSM Decrypt: User session (signer) required for decryption.");let Y;try{Y=JSON.parse(Q)}catch(J){throw new Error("SSM Decrypt: encryptedString is not valid JSON.")}if(Y.type!=="aes-gcm-self-ssm-v2")throw new Error("SSM Decrypt: Unsupported encryption type or incorrect version.");if(!Y.iv||!Y.encrypted)throw new Error("SSM Decrypt: Invalid encrypted data format.");try{const J=T(Y.iv),X=T(Y.encrypted),q=await this._deriveAesKeyInternal("ssm-encrypt-for-current-user-v1"),G=await crypto.subtle.decrypt({name:"AES-GCM",iv:J},q,X),W=this.dbInstance.decompress(new Uint8Array(G));return JSON.parse(pQ(W))}catch(J){throw console.error("SSM: Error in decryptDataForCurrentUser:",J),new Error("SSM: Failed to decrypt personal data.")}}async _deriveAesKeyInternal(Q="ssm-default-aes-salt"){const Y=T(this.signer.privateKey),J=Z0(Q),X=await crypto.subtle.importKey("raw",Y,{name:"PBKDF2"},!1,["deriveKey"]);return crypto.subtle.deriveKey({name:"PBKDF2",salt:J,iterations:1e5,hash:"SHA-256"},X,{name:"AES-GCM",length:256},!0,["encrypt","decrypt"])}}var p9=function(Q){if(!(Q instanceof ArrayBuffer))if(Q.buffer&&Q.buffer instanceof ArrayBuffer)Q=Q.buffer.slice(Q.byteOffset,Q.byteOffset+Q.byteLength);else throw console.error("arrayBufferToBase64Url: input is not ArrayBuffer nor TypedArray with .buffer",Q),new Error("arrayBufferToBase64Url: ArrayBuffer or TypedArray required.");return btoa(String.fromCharCode(...new Uint8Array(Q))).replace(/\+/g,"-").replace(/\//g,"_").replace(/=+$/,"")},u9=function(Q){let Y=Q.replace(/-/g,"+").replace(/_/g,"/");const J=atob(Y),X=new ArrayBuffer(J.length),q=new Uint8Array(X);for(let G=0;G<J.length;G++)q[G]=J.charCodeAt(G);return X},pJ="gdb_ethereum_material_encrypted_webauthn_v2",AQ="gdb_webauthn_registration_details_v2";class BY{constructor(){this.signer=null,this.address=null,this.mnemonic=null,this.webAuthnCredentialId=null,this.webAuthnOriginalChallengeUsedForEncryption=null}async createNewEthereumIdentity(){const Q=c0.createRandom();return this.mnemonic=Q.mnemonic.phrase,console.log("SWM: New Ethereum identity generated (mnemonic and private key in memory)."),{address:await Q.getAddress(),mnemonic:this.mnemonic,privateKey:Q.privateKey}}async _encryptEthereumPrivateKey(Q,Y){const J=V0(12),X=T(Q),q=await window.crypto.subtle.encrypt({name:"AES-GCM",iv:J},Y,X);return JSON.stringify({iv:p9(J.buffer.slice(J.byteOffset,J.byteOffset+J.byteLength)),ciphertext:p9(q)})}async _decryptEthereumPrivateKey(Q,Y){const{iv:J,ciphertext:X}=JSON.parse(Q),q=u9(J),G=u9(X),W=await window.crypto.subtle.decrypt({name:"AES-GCM",iv:new Uint8Array(q)},Y,G);return N(new Uint8Array(W))}async _deriveAesGcmKeyFromWebAuthn(Q,Y){const J=await window.crypto.subtle.importKey("raw",Y,{name:"PBKDF2"},!1,["deriveKey"]);return window.crypto.subtle.deriveKey({name:"PBKDF2",salt:Q,iterations:200000,hash:"SHA-256"},J,{name:"AES-GCM",length:256},!0,["encrypt","decrypt"])}async _loadAndDecryptWalletFromWebAuthnMaterial(Q,Y){const J=localStorage.getItem(pJ);if(!J)return console.warn("SWM (_loadAndDecrypt): No encrypted Ethereum material found."),this.logout(),null;try{const X=await this._deriveAesGcmKeyFromWebAuthn(Q,Y),q=await this._decryptEthereumPrivateKey(J,X),G=new c0(q);return this.signer=G,this.address=await G.getAddress(),this.mnemonic=null,this.webAuthnCredentialId=Q,this.webAuthnOriginalChallengeUsedForEncryption=Y,console.log(`SWM (_loadAndDecrypt): Session established for ${this.address}`),this.address}catch(X){return console.error("SWM (_loadAndDecrypt): Error (decryption/wallet loading):",X),this.logout(),null}}async registerAndProtectWithWebAuthn(Q){if(!window.navigator.credentials||!window.navigator.credentials.create)return console.error("SWM: WebAuthn is not supported by this browser."),alert("WebAuthn is not supported by this browser."),!1;const Y=V0(32),J=Y.buffer.slice(Y.byteOffset,Y.byteOffset+Y.byteLength);try{const X=q0.computePublicKey(Q,!1),q=T(X),G=T(i(q)),V=G.buffer.slice(G.byteOffset,G.byteOffset+Math.min(G.length,64)),U=new c0(Q).address.slice(0,10),Z={challenge:J,rp:{name:"GDB WebAuthn App",id:window.location.hostname},user:{id:V,name:`user-${U}`,displayName:"GDB User"},pubKeyCredParams:[{type:"public-key",alg:-7},{type:"public-key",alg:-257}],authenticatorSelection:{authenticatorAttachment:"platform",userVerification:"preferred",residentKey:"preferred",requireResidentKey:!1},timeout:60000,attestation:"none"},K=await window.navigator.credentials.create({publicKey:Z});if(!K||!K.rawId||!K.id)throw new Error("WebAuthn registration failed or was canceled (no credential).");const M=K.rawId,I=await this._deriveAesGcmKeyFromWebAuthn(M,J),z=await this._encryptEthereumPrivateKey(Q,I);return localStorage.setItem(pJ,z),localStorage.setItem(AQ,JSON.stringify({credentialIdBase64Url:p9(M),originalChallengeBase64Url:p9(J)})),console.log("SWM: WebAuthn registered and Ethereum key encrypted and saved."),await this._loadAndDecryptWalletFromWebAuthnMaterial(M,J)}catch(X){return console.error("SWM: Error during WebAuthn registration:",X),this.logout(),localStorage.removeItem(pJ),localStorage.removeItem(AQ),alert(`WebAuthn registration error: ${X.message||"Unknown. Check console."}`),!1}}async loginWithWebAuthn(){if(!window.navigator.credentials||!window.navigator.credentials.get)return console.error("SWM: WebAuthn is not supported."),alert("WebAuthn is not supported by this browser."),null;const Q=localStorage.getItem(AQ);if(!Q)return console.warn("SWM: No WebAuthn registration details saved."),null;let Y;try{Y=JSON.parse(Q)}catch(W){return console.error("SWM: Error parsing WebAuthn registration details from localStorage:",W),null}if(!Y.credentialIdBase64Url||!Y.originalChallengeBase64Url)return console.error("SWM: WebAuthn registration details in localStorage are incomplete."),null;const J=u9(Y.credentialIdBase64Url),X=u9(Y.originalChallengeBase64Url),q=V0(32),G=q.buffer.slice(q.byteOffset,q.byteOffset+q.byteLength);try{const W={challenge:G,allowCredentials:[{type:"public-key",id:J}],userVerification:"preferred",timeout:60000},V=await window.navigator.credentials.get({publicKey:W});if(!V||!V.rawId||!V.response||!V.response.authenticatorData||!V.response.signature||!V.response.clientDataJSON)throw new Error("WebAuthn authentication failed or was canceled (incomplete assertion).");if(p9(V.rawId)!==Y.credentialIdBase64Url)throw new Error("WebAuthn credential ID in assertion does not match stored ID.");const $=JSON.parse((new TextDecoder()).decode(V.response.clientDataJSON));if($.challenge!==p9(G))throw new Error("WebAuthn assertion challenge mismatch.");if($.origin!==`https://${window.location.hostname}`&&$.origin!==`http://${window.location.hostname}`){let U=window.location.protocol+"//";if($.origin.startsWith(U+window.location.hostname));else if(window.location.hostname==="localhost"&&$.origin.startsWith(U+"localhost"));else console.warn("WebAuthn assertion origin mismatch. Expected based on hostname:",window.location.hostname,"Got:",$.origin)}return console.log("SWM: Interactive WebAuthn assertion received and validated."),await this._loadAndDecryptWalletFromWebAuthnMaterial(V.rawId,X)}catch(W){return console.error("SWM: Error during interactive WebAuthn login:",W),this.logout(),null}}async trySilentWebAuthnLogin(){console.log("SWM: Attempting silent WebAuthn login...");const Q=localStorage.getItem(AQ);if(!Q)return console.warn("SWM Silent Login: No WebAuthn registration details."),null;let Y;try{Y=JSON.parse(Q)}catch(J){return console.error("SWM Silent Login: Error parsing registration details:",J),null}if(!Y.credentialIdBase64Url||!Y.originalChallengeBase64Url)return console.error("SWM Silent Login: Incomplete WebAuthn registration details."),null;try{const J=u9(Y.credentialIdBase64Url),X=u9(Y.originalChallengeBase64Url),q=await this._loadAndDecryptWalletFromWebAuthnMaterial(J,X);if(q)return console.log(`SWM Silent Login: Success for ${q}.`),q;else return console.warn("SWM Silent Login: _loadAndDecryptWalletFromWebAuthnMaterial failed."),null}catch(J){return console.error("SWM Silent Login: Error during silent login attempt:",J),this.logout(),null}}async loadWalletFromMnemonic(Q){try{const Y=c0.fromPhrase(Q);return this.signer=Y,this.address=await Y.getAddress(),this.mnemonic=Q,this.webAuthnCredentialId=null,this.webAuthnOriginalChallengeUsedForEncryption=null,console.log(`SWM: Wallet loaded from mnemonic for ${this.address}. Signer set.`),{address:this.address,privateKey:Y.privateKey,mnemonic:Q}}catch(Y){return console.error("SWM: Error loading wallet from mnemonic:",Y),this.logout(),null}}hasWebAuthnRegistration(){return localStorage.getItem(AQ)!==null&&localStorage.getItem(pJ)!==null}logout(){this.signer=null,this.address=null,this.mnemonic=null,this.webAuthnCredentialId=null,this.webAuthnOriginalChallengeUsedForEncryption=null,console.log("SWM: Wallet session closed (SWM internal state cleared).")}getSigner(){return this.signer}getAddress(){return this.address}getMnemonicForDisplay(){if(this.mnemonic&&(!this.webAuthnCredentialId||!this.webAuthnOriginalChallengeUsedForEncryption))return this.mnemonic;return null}isSessionWebAuthnProtected(){return!!(this.signer&&this.webAuthnCredentialId&&this.webAuthnOriginalChallengeUsedForEncryption)}}function sI(Q){if(typeof Q!=="object"||Q===null||Array.isArray(Q))throw new Error("RBAC: Custom roles must be a valid object.");SY=Q,console.log("RBAC: Custom roles set.")}function uJ(Q,Y,J=new Set){const X=SY;if(!Q||!X[Q])return!1;if(J.has(Q))return console.warn(`RBAC: Inheritance loop detected involving role '${Q}'.`),!1;if(J.add(Q),X[Q].can&&X[Q].can.includes(Y))return J.delete(Q),!0;if(X[Q].inherits&&Array.isArray(X[Q].inherits)){if(X[Q].inherits.some((q)=>uJ(q,Y,new Set(J))))return J.delete(Q),!0}return J.delete(Q),!1}function Z7(Q,Y={}){if(Q==="upsert")return"write";if(Q==="remove")return"delete";if(Q==="link")return"link";if(Q==="sync"||Q==="syncReceive"||Q==="deltaSync")return"sync";return console.warn(`RBAC mapChangeTypeToRbacAction: Unknown change type '${Q}'.`),"unknown"}function tI(Q){if(typeof Q==="function")dJ=Q;else if(Q===null)dJ=null;else console.warn("RBAC: Attempted to set invalid state change callback.")}var o0=function(){if(dJ)dJ({isActive:S0,activeAddress:k?.securityManager?.localUserEthAddress||J0.getAddress(),isWebAuthnProtected:n0,hasVolatileIdentity:!!B0,hasWebAuthnHardwareRegistration:J0.hasWebAuthnRegistration()})};async function eI(){if(S0)await iJ();J0.logout(),B0=null,n0=!1,localStorage.removeItem(G8);try{const Q=await J0.createNewEthereumIdentity();if(Q)B0=Q;return o0(),Q}catch(Q){throw B0=null,o0(),Q}}async function QO(Q){const Y=Q||B0?.privateKey;if(!Y)return alert("RBAC Error: No volatile ETH identity to protect."),null;if(S0&&n0&&k?.securityManager?.signer)return k.securityManager.localUserEthAddress;if(S0)await iJ();J0.logout();const J=await J0.registerAndProtectWithWebAuthn(Y);if(J&&J0.getSigner()){if(B0=null,n0=!0,localStorage.setItem(G8,"true"),k)await lJ(J0.getSigner());else console.warn("RBAC: Identity protected, but GDB not configured. Global RBAC signing not active.");return J}else return n0=!1,localStorage.removeItem(G8),o0(),null}async function JO(){if(S0)await iJ();J0.logout(),B0=null;const Q=await J0.loginWithWebAuthn();if(Q&&J0.getSigner()){if(n0=!0,localStorage.setItem(G8,"true"),k)await lJ(J0.getSigner());else console.warn("RBAC: WebAuthn login OK, but GDB not configured for full security activation.");return Q}else return n0=!1,localStorage.removeItem(G8),o0(),null}async function YO(Q){if(S0)await iJ();J0.logout(),B0=null;const Y=await J0.loadWalletFromMnemonic(Q);if(Y&&Y.address&&J0.getSigner()){if(B0=Y,n0=!1,localStorage.removeItem(G8),k)await lJ(J0.getSigner());else console.warn("RBAC: Mnemonic loaded, but GDB not configured for full security activation.");return B0}else return o0(),null}async function XO(Q,Y=[]){if(!Q){console.error("RBAC: GDB instance is required.");return}if(k=Q,EQ=(Y||[]).map((J)=>{try{return y(J)}catch(X){return console.warn(`RBAC: Invalid superadmin address skipped: ${J}`),null}}).filter(Boolean),!k.securityManager||!(k.securityManager instanceof cJ))k.securityManager=new cJ(null,k,{can:uJ,mapChangeTypeToRbacAction:Z7},EQ),console.log("RBAC: ANONYMOUS/VERIFIER SecurityManager configured on GDB instance by RBAC.");else console.log("RBAC: GDB instance already had a SecurityManager. RBAC will use it."),k.securityManager.rbac={can:uJ,mapChangeTypeToRbacAction:Z7},k.securityManager.superAdminEthereumAddresses=EQ,k.securityManager.dbInstance=k;if(console.log("RBAC: Security context (GDB & SuperAdmins) established. GDB SM is ready for verification."),localStorage.getItem(G8)==="true"&&J0.hasWebAuthnRegistration()){console.log("RBAC: Previous WebAuthn session detected. Attempting silent login...");try{const J=await J0.trySilentWebAuthnLogin();if(J&&J0.getSigner())n0=!0,await lJ(J0.getSigner()),console.log(`RBAC: Silent WebAuthn login successful for ${J}.`);else console.warn("RBAC: Silent WebAuthn login failed or no signer obtained. Manual login required."),localStorage.removeItem(G8),o0()}catch(J){console.error("RBAC: Error during silent WebAuthn login attempt:",J),localStorage.removeItem(G8),o0()}}else o0()}async function lJ(Q){if(!k||!k.securityManager||!Q)return console.error("RBAC Internal: GDB, GDB's SecurityManager, or signer missing for security activation."),S0=!1,o0(),!1;const Y=k.securityManager;if(Y.signer=Q,await Y._initializeAndGetAddress(),console.log(`RBAC: Signer activated on GDB.SecurityManager for ETH: ${Y.localUserEthAddress}`),k.sendData&&!k._originalSendDataBySoftwareRBAC)k._originalSendDataBySoftwareRBAC=k.sendData.bind(k),k.sendData=async(q)=>{const G=await k.securityManager.signOutgoingOperations(q);return k._originalSendDataBySoftwareRBAC(G)},console.log("RBAC: gdbInstance.sendData wrapped for signing.");const J=Y.localUserEthAddress,X=`user:${J}`;try{await k.ready;const q=await k.get(X),G=q.result?.value||{};let W=G.role;if(!W)W=EQ.includes(J)?"superadmin":"user";if(G.role!==W||!q.result||G.ethAddress!==J){const V=k.hybridClock.now();await k.graph.upsert(X,{...G,ethAddress:J,role:W},V),k.sendData([{type:"sync",timestamp:null}]),console.log(`RBAC: User node for ${J} (role '${W}') ensured in GDB.`)}}catch(q){console.error(`RBAC: Error ensuring user node for ${J}:`,q)}return S0=!0,o0(),console.log(`RBAC: P2P signing security ACTIVE for ${J}. GDB's SM will verify all incoming ops.`),!0}async function iJ(){if(console.log("RBAC: Clearing active signing session..."),k&&k._originalSendDataBySoftwareRBAC)k.sendData=k._originalSendDataBySoftwareRBAC,delete k._originalSendDataBySoftwareRBAC,console.log("RBAC: gdbInstance.sendData restored to original.");if(J0.logout(),k&&k.securityManager)k.securityManager.signer=null,k.securityManager.localUserEthAddress=null,console.log("RBAC: Signer removed from GDB.SecurityManager. It now operates in anonymous/verifier mode.");B0=null,n0=!1,localStorage.removeItem(G8),S0=!1,o0(),console.log("RBAC: Signing session closed. GDB.SecurityManager continues to verify incoming P2P operations.")}async function qO(Q,Y){let J="RBAC_ID_PREFIX_"+Y;if(!k)throw new Error("RBAC.put: Not initialized");if(!k.securityManager?.signer)throw new Error("RBAC.put: Session not active");const{result:X}=await N4(J);if(X&&X.decrypted===!1)throw new Error(`RBAC.put: Cannot overwrite encrypted data on node ID '${Y}' owned by another user. DENIED.`);const q=k.securityManager;let G,W;try{const $=await q.encryptDataForCurrentUser(Q),U=JSON.parse($);G=U.encrypted,W={owner:q.localUserEthAddress,encType:U.type,iv:U.iv}}catch($){throw console.error(`RBAC.put: Encryption failed for ID ${Y||"(new)"}: ${$.message}`),$}const V={_gdbWrapperType:z7,_payload:G,_meta:W};return console.log(`RBAC.put: Storing wrapped secure payload for ID: ${Y||"(new)"}`),(await k.put(V,J)).replace(/^RBAC_ID_PREFIX_/,"")}async function N4(Q,Y=null){let J="RBAC_ID_PREFIX_"+Q;if(!k)throw new Error("RBAC.get: Not initialized");const X=k.securityManager,q=async($)=>{if(!$)return null;let U=$.value,Z=!1;if(U&&U._gdbWrapperType===z7){const K=U,M=K._payload,I=K._meta;if(U=typeof M==="string"?M:K,I&&I.owner&&X&&X.signer&&I.owner===X.localUserEthAddress)try{const z=JSON.stringify({iv:I.iv,encrypted:M,type:I.encType});U=await X.decryptDataForCurrentUser(z),Z=!0}catch(z){console.error(`RBAC.get: Decryption failed for node ${$.id}. User: ${X.localUserEthAddress}, Owner: ${I.owner}. Error: ${z.message}`)}else if(I&&I.owner)console.warn(`RBAC.get: Decryption not attempted for node ${$.id}. Owner: ${I.owner}. Session active: ${!!(X&&X.signer)}`);else console.warn(`RBAC.get: Secure payload wrapper for node ${$.id} lacks sufficient metadata for decryption.`)}return{id:Q,value:U,edges:$.edges||[],timestamp:$.timestamp,decrypted:Z}};if(!Y){const $=await k.get(J,null);return{result:await q($?$.result:null)}}let G=null;const W=await k.get(J,null);if(G=await q(W?W.result:null),typeof Y==="function")Y(G);const{unsubscribe:V}=await k.get(J,async($)=>{const U=await q($),Z=U&&G&&k.hybridClock?.compare(U.timestamp,G.timestamp)>0,K=JSON.stringify(U?U.value:null)!==JSON.stringify(G?G.value:null);if(!U&&G){if(G=null,typeof Y==="function")Y(null)}else if(U&&(!G||Z||K)){if(G=U,typeof Y==="function")Y(U)}});return{result:G,unsubscribe:()=>{if(V)V()}}}var K7=function(){if(!S0||!k?.securityManager?.localUserEthAddress)throw new Error("RBAC Operation: Security not active or no local user ETH identified in SecurityManager.");return k.securityManager.localUserEthAddress};async function GO(Q,Y,J=null){if(!Q||!Y)throw new Error("RBAC assignRole: targetUserEthAddress, and role are required.");let X;try{X=y(Q)}catch(U){throw new Error(`RBAC assignRole: targetUserEthAddress '${Q}' is invalid.`)}if(!SY[Y])throw new Error(`RBAC assignRole: Role '${Y}' is not a defined role.`);const q=K7(),G=`user:${X}`,$={...(await k.get(G)).result?.value||{},ethAddress:X,role:Y,assignedByEthAddress:q,expiresAt:J?new Date(J).toISOString():null};await k.put($,G),console.log(`RBAC: Role '${Y}' for ${Q} by ${q} written.`)}async function T4(){if(!S0||!k?.securityManager?.localUserEthAddress)return!1;return EQ.includes(k.securityManager.localUserEthAddress)}async function F4(Q,Y="unknown"){let J;try{J=y(Q)}catch(G){throw new Error(`RBAC: Invalid ETH address '${Q}' when verifying role for op '${Y}'.`)}const X=await k.get(`user:${J}`);if(!X.result?.value?.role)throw console.warn(`RBAC verifyUserRoleLocal: Node/role not found for ETH ${J}. Op: ${Y}. Data:`,X.result?.value),new Error(`RBAC: Role not found for ETH ${J} (operation: ${Y}).`);const q=X.result.value;if(q.expiresAt&&new Date(q.expiresAt)<new Date)throw new Error(`RBAC: Role for ETH ${J} has expired.`);return q.role}async function w4(Q,Y){const J=await F4(Q,Y);if(!uJ(J,Y))throw new Error(`RBAC: ETH User ${Q} (role ${J}) does not have permission for '${Y}'.`)}async function WO(Q){if(!Q)throw new Error("RBAC executeWithPermission: operationName is required.");const Y=K7();if(!(Q==="assignRole"&&await T4()))await w4(Y,Q);return Y}function VO(){return S0?k?.securityManager?.localUserEthAddress:null}function M7(){return S0&&!!k?.securityManager?.signer}function UO(){return S0&&n0}function $O(){return J0.hasWebAuthnRegistration()}function ZO(){if(B0&&B0.mnemonic&&!J0.isSessionWebAuthnProtected())return B0.mnemonic;return J0.getMnemonicForDisplay()}async function zO(Q){if(!M7()||!k?.securityManager)throw new Error("RBAC Encryption: Local signing security not active or SecurityManager not available.");return await k.securityManager.encryptDataForCurrentUser(Q)}async function KO(Q){if(!M7()||!k?.securityManager)throw new Error("RBAC Decryption: Local signing security not active or SecurityManager not available.");return await k.securityManager.decryptDataForCurrentUser(Q)}var SY={superadmin:{can:["assignRole","deleteAny"],inherits:["admin"]},admin:{can:["delete"],inherits:["manager"]},manager:{can:["publish"],inherits:["user"]},user:{can:["write","link","sync"],inherits:["guest"]},guest:{can:["read","sync"]}},G8="gdb_rbac_last_session_was_webauthn",k=null,J0=new BY,EQ=[],S0=!1,B0=null,n0=!1,dJ=null,z7="_gdbSecurePayloadV1";export{eI as startNewUserRegistration,tI as setSecurityStateChangeCallback,sI as setCustomRoles,qO as put,QO as protectCurrentIdentityWithWebAuthn,Z7 as mapChangeTypeToRbacAction,YO as loginOrRecoverUserWithMnemonic,JO as loginCurrentUserWithWebAuthn,M7 as isSecurityActive,UO as isCurrentSessionProtectedByWebAuthn,$O as hasExistingWebAuthnRegistration,ZO as getMnemonicForDisplayAfterRegistrationOrRecovery,VO as getActiveEthAddress,N4 as get,WO as executeWithPermission,zO as encryptDataForCurrentUser,KO as decryptDataForCurrentUser,XO as createSecurityContext,iJ as clearSecurity,uJ as can,GO as assignRole};
