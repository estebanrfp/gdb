var c7=Object.defineProperty;var p7=(Q,Y)=>{for(var J in Y)c7(Q,J,{get:Y[J],enumerable:!0,configurable:!0,set:(X)=>Y[J]=()=>X})};var FQ="6.15.0";var u7=function(Q,Y,J){const X=Y.split("|").map((G)=>G.trim());for(let G=0;G<X.length;G++)switch(Y){case"any":return;case"bigint":case"boolean":case"number":case"string":if(typeof Q===Y)return}const q=new Error(`invalid value for type ${Y}`);throw q.code="INVALID_ARGUMENT",q.argument=`value.${J}`,q.value=Q,q};async function r0(Q){const Y=Object.keys(Q);return(await Promise.all(Y.map((X)=>Promise.resolve(Q[X])))).reduce((X,q,G)=>{return X[Y[G]]=q,X},{})}function s(Q,Y,J){for(let X in Y){let q=Y[X];const G=J?J[X]:null;if(G)u7(q,G,X);Object.defineProperty(Q,X,{enumerable:!0,value:q,writable:!1})}}var O9=function(Q,Y){if(Q==null)return"null";if(Y==null)Y=new Set;if(typeof Q==="object"){if(Y.has(Q))return"[Circular]";Y.add(Q)}if(Array.isArray(Q))return"[ "+Q.map((J)=>O9(J,Y)).join(", ")+" ]";if(Q instanceof Uint8Array){let X="0x";for(let q=0;q<Q.length;q++)X+="0123456789abcdef"[Q[q]>>4],X+="0123456789abcdef"[Q[q]&15];return X}if(typeof Q==="object"&&typeof Q.toJSON==="function")return O9(Q.toJSON(),Y);switch(typeof Q){case"boolean":case"number":case"symbol":return Q.toString();case"bigint":return BigInt(Q).toString();case"string":return JSON.stringify(Q);case"object":{const J=Object.keys(Q);return J.sort(),"{ "+J.map((X)=>`${O9(X,Y)}: ${O9(Q[X],Y)}`).join(", ")+" }"}}return"[ COULD NOT SERIALIZE ]"};function BQ(Q,Y){return Q&&Q.code===Y}function _9(Q,Y,J){let X=Q;{const G=[];if(J){if(("message"in J)||("code"in J)||("name"in J))throw new Error(`value will overwrite populated values: ${O9(J)}`);for(let U in J){if(U==="shortMessage")continue;const W=J[U];G.push(U+"="+O9(W))}}if(G.push(`code=${Y}`),G.push(`version=${FQ}`),G.length)Q+=" ("+G.join(", ")+")"}let q;switch(Y){case"INVALID_ARGUMENT":q=new TypeError(Q);break;case"NUMERIC_FAULT":case"BUFFER_OVERRUN":q=new RangeError(Q);break;default:q=new Error(Q)}if(s(q,{code:Y}),J)Object.assign(q,J);if(q.shortMessage==null)s(q,{shortMessage:X});return q}function x(Q,Y,J,X){if(!Q)throw _9(Y,J,X)}function O(Q,Y,J,X){x(Q,Y,"INVALID_ARGUMENT",{argument:J,value:X})}function D9(Q){x(d7.indexOf(Q)>=0,"platform missing String.prototype.normalize","UNSUPPORTED_OPERATION",{operation:"String.prototype.normalize",info:{form:Q}})}function U8(Q,Y,J){if(J==null)J="";if(Q!==Y){let X=J,q="new";if(J)X+=".",q+=" "+J;x(!1,`private constructor; use ${X}from* methods`,"UNSUPPORTED_OPERATION",{operation:q})}}var d7=["NFD","NFC","NFKD","NFKC"].reduce((Q,Y)=>{try{if("test".normalize(Y)!=="test")throw new Error("bad");if(Y==="NFD"){const J=String.fromCharCode(233).normalize("NFD"),X=String.fromCharCode(101,769);if(J!==X)throw new Error("broken")}Q.push(Y)}catch(J){}return Q},[]);var OY=function(Q,Y,J){if(Q instanceof Uint8Array){if(J)return new Uint8Array(Q);return Q}if(typeof Q==="string"&&Q.match(/^0x(?:[0-9a-f][0-9a-f])*$/i)){const X=new Uint8Array((Q.length-2)/2);let q=2;for(let G=0;G<X.length;G++)X[G]=parseInt(Q.substring(q,q+2),16),q+=2;return X}O(!1,"invalid BytesLike value",Y||"value",Q)};function N(Q,Y){return OY(Q,Y,!1)}function u0(Q,Y){return OY(Q,Y,!0)}function L0(Q,Y){if(typeof Q!=="string"||!Q.match(/^0x[0-9A-Fa-f]*$/))return!1;if(typeof Y==="number"&&Q.length!==2+2*Y)return!1;if(Y===!0&&Q.length%2!==0)return!1;return!0}function a0(Q){return L0(Q,!0)||Q instanceof Uint8Array}function T(Q){const Y=N(Q);let J="0x";for(let X=0;X<Y.length;X++){const q=Y[X];J+=jY[(q&240)>>4]+jY[q&15]}return J}function o(Q){return"0x"+Q.map((Y)=>T(Y).substring(2)).join("")}function W8(Q){if(L0(Q,!0))return(Q.length-2)/2;return N(Q).length}function I9(Q,Y,J){const X=N(Q);if(J!=null&&J>X.length)x(!1,"cannot slice beyond data bounds","BUFFER_OVERRUN",{buffer:X,length:X.length,offset:J});return T(X.slice(Y==null?0:Y,J==null?X.length:J))}var l7=function(Q,Y,J){const X=N(Q);x(Y>=X.length,"padding exceeds data length","BUFFER_OVERRUN",{buffer:new Uint8Array(X),length:Y,offset:Y+1});const q=new Uint8Array(Y);if(q.fill(0),J)q.set(X,Y-X.length);else q.set(X,0);return T(q)};function E0(Q,Y){return l7(Q,Y,!0)}var jY="0123456789abcdef";function EQ(Q,Y){let J=h(Q,"value");const X=BigInt($0(Y,"width")),q=d8<<X-d8;if(J<gJ){J=-J,x(J<=q,"too low","NUMERIC_FAULT",{operation:"toTwos",fault:"overflow",value:Q});const G=(d8<<X)-d8;return(~J&G)+d8}else x(J<q,"too high","NUMERIC_FAULT",{operation:"toTwos",fault:"overflow",value:Q});return J}function SQ(Q,Y){const J=c9(Q,"value"),X=BigInt($0(Y,"bits"));return J&(d8<<X)-d8}function h(Q,Y){switch(typeof Q){case"bigint":return Q;case"number":return O(Number.isInteger(Q),"underflow",Y||"value",Q),O(Q>=-L9&&Q<=L9,"overflow",Y||"value",Q),BigInt(Q);case"string":try{if(Q==="")throw new Error("empty string");if(Q[0]==="-"&&Q[1]!=="-")return-BigInt(Q.substring(1));return BigInt(Q)}catch(J){O(!1,`invalid BigNumberish string: ${J.message}`,Y||"value",Q)}}O(!1,"invalid BigNumberish value",Y||"value",Q)}function c9(Q,Y){const J=h(Q,Y);return x(J>=gJ,"unsigned value cannot be negative","NUMERIC_FAULT",{fault:"overflow",operation:"getUint",value:Q}),J}function H9(Q){if(Q instanceof Uint8Array){let Y="0x0";for(let J of Q)Y+=DY[J>>4],Y+=DY[J&15];return BigInt(Y)}return h(Q)}function $0(Q,Y){switch(typeof Q){case"bigint":return O(Q>=-L9&&Q<=L9,"overflow",Y||"value",Q),Number(Q);case"number":return O(Number.isInteger(Q),"underflow",Y||"value",Q),O(Q>=-L9&&Q<=L9,"overflow",Y||"value",Q),Q;case"string":try{if(Q==="")throw new Error("empty string");return $0(BigInt(Q),Y)}catch(J){O(!1,`invalid numeric string: ${J.message}`,Y||"value",Q)}}O(!1,"invalid numeric value",Y||"value",Q)}function d0(Q,Y){let X=c9(Q,"value").toString(16);if(Y==null){if(X.length%2)X="0"+X}else{const q=$0(Y,"width");x(q*2>=X.length,`value exceeds width (${q} bytes)`,"NUMERIC_FAULT",{operation:"toBeHex",fault:"overflow",value:Q});while(X.length<q*2)X="0"+X}return"0x"+X}function t(Q){const Y=c9(Q,"value");if(Y===gJ)return new Uint8Array([]);let J=Y.toString(16);if(J.length%2)J="0"+J;const X=new Uint8Array(J.length/2);for(let q=0;q<X.length;q++){const G=q*2;X[q]=parseInt(J.substring(G,G+2),16)}return X}function AQ(Q){let Y=T(a0(Q)?Q:t(Q)).substring(2);while(Y.startsWith("0"))Y=Y.substring(1);if(Y==="")Y="0";return"0x"+Y}var gJ=BigInt(0),d8=BigInt(1),L9=9007199254740991,DY="0123456789abcdef";var n7=function(Q){if(kQ==null){kQ={};for(let J=0;J<xQ.length;J++)kQ[xQ[J]]=BigInt(J)}const Y=kQ[Q];return O(Y!=null,"invalid base58 value","letter",Q),Y};function fQ(Q){const Y=N(Q);let J=H9(Y),X="";while(J)X=xQ[Number(J%yJ)]+X,J/=yJ;for(let q=0;q<Y.length;q++){if(Y[q])break;X=xQ[0]+X}return X}function bQ(Q){let Y=i7;for(let J=0;J<Q.length;J++)Y*=yJ,Y+=n7(Q[J]);return Y}var xQ="123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz",kQ=null,i7=BigInt(0),yJ=BigInt(58);var o7=function(Q,Y,J,X,q){O(!1,`invalid codepoint at offset ${Y}; ${Q}`,"bytes",J)},IY=function(Q,Y,J,X,q){if(Q==="BAD_PREFIX"||Q==="UNEXPECTED_CONTINUE"){let G=0;for(let U=Y+1;U<J.length;U++){if(J[U]>>6!==2)break;G++}return G}if(Q==="OVERRUN")return J.length-Y-1;return 0},r7=function(Q,Y,J,X,q){if(Q==="OVERLONG")return O(typeof q==="number","invalid bad code point for replacement","badCodepoint",q),X.push(q),0;return X.push(65533),IY(Q,Y,J,X,q)},a7=function(Q,Y){if(Y==null)Y=hJ.error;const J=N(Q,"bytes"),X=[];let q=0;while(q<J.length){const G=J[q++];if(G>>7===0){X.push(G);continue}let U=null,W=null;if((G&224)===192)U=1,W=127;else if((G&240)===224)U=2,W=2047;else if((G&248)===240)U=3,W=65535;else{if((G&192)===128)q+=Y("UNEXPECTED_CONTINUE",q-1,J,X);else q+=Y("BAD_PREFIX",q-1,J,X);continue}if(q-1+U>=J.length){q+=Y("OVERRUN",q-1,J,X);continue}let $=G&(1<<8-U-1)-1;for(let V=0;V<U;V++){let z=J[q];if((z&192)!=128){q+=Y("MISSING_CONTINUE",q,J,X),$=null;break}$=$<<6|z&63,q++}if($===null)continue;if($>1114111){q+=Y("OUT_OF_RANGE",q-1-U,J,X,$);continue}if($>=55296&&$<=57343){q+=Y("UTF16_SURROGATE",q-1-U,J,X,$);continue}if($<=W){q+=Y("OVERLONG",q-1-U,J,X,$);continue}X.push($)}return X};function z0(Q,Y){if(O(typeof Q==="string","invalid string value","str",Q),Y!=null)D9(Y),Q=Q.normalize(Y);let J=[];for(let X=0;X<Q.length;X++){const q=Q.charCodeAt(X);if(q<128)J.push(q);else if(q<2048)J.push(q>>6|192),J.push(q&63|128);else if((q&64512)==55296){X++;const G=Q.charCodeAt(X);O(X<Q.length&&(G&64512)===56320,"invalid surrogate pair","str",Q);const U=65536+((q&1023)<<10)+(G&1023);J.push(U>>18|240),J.push(U>>12&63|128),J.push(U>>6&63|128),J.push(U&63|128)}else J.push(q>>12|224),J.push(q>>6&63|128),J.push(q&63|128)}return new Uint8Array(J)}var s7=function(Q){return Q.map((Y)=>{if(Y<=65535)return String.fromCharCode(Y);return Y-=65536,String.fromCharCode((Y>>10&1023)+55296,(Y&1023)+56320)}).join("")};function vQ(Q,Y){return s7(a7(Q,Y))}var hJ=Object.freeze({error:o7,ignore:IY,replace:r7});var t7=function(Q){let Y=Q.toString(16);while(Y.length<2)Y="0"+Y;return"0x"+Y},LY=function(Q,Y,J){let X=0;for(let q=0;q<J;q++)X=X*256+Q[Y+q];return X},HY=function(Q,Y,J,X){const q=[];while(J<Y+1+X){const G=RY(Q,J);q.push(G.result),J+=G.consumed,x(J<=Y+1+X,"child data too short","BUFFER_OVERRUN",{buffer:Q,length:X,offset:Y})}return{consumed:1+X,result:q}},RY=function(Q,Y){x(Q.length!==0,"data too short","BUFFER_OVERRUN",{buffer:Q,length:0,offset:1});const J=(X)=>{x(X<=Q.length,"data short segment too short","BUFFER_OVERRUN",{buffer:Q,length:Q.length,offset:X})};if(Q[Y]>=248){const X=Q[Y]-247;J(Y+1+X);const q=LY(Q,Y+1,X);return J(Y+1+X+q),HY(Q,Y,Y+1+X,X+q)}else if(Q[Y]>=192){const X=Q[Y]-192;return J(Y+1+X),HY(Q,Y,Y+1,X)}else if(Q[Y]>=184){const X=Q[Y]-183;J(Y+1+X);const q=LY(Q,Y+1,X);J(Y+1+X+q);const G=T(Q.slice(Y+1+X,Y+1+X+q));return{consumed:1+X+q,result:G}}else if(Q[Y]>=128){const X=Q[Y]-128;J(Y+1+X);const q=T(Q.slice(Y+1,Y+1+X));return{consumed:1+X,result:q}}return{consumed:1,result:t7(Q[Y])}};function F8(Q){const Y=N(Q,"data"),J=RY(Y,0);return O(J.consumed===Y.length,"unexpected junk after rlp payload","data",Q),J.result}var PY=function(Q){const Y=[];while(Q)Y.unshift(Q&255),Q>>=8;return Y},TY=function(Q){if(Array.isArray(Q)){let X=[];if(Q.forEach(function(G){X=X.concat(TY(G))}),X.length<=55)return X.unshift(192+X.length),X;const q=PY(X.length);return q.unshift(247+q.length),q.concat(X)}const Y=Array.prototype.slice.call(N(Q,"object"));if(Y.length===1&&Y[0]<=127)return Y;else if(Y.length<=55)return Y.unshift(128+Y.length),Y;const J=PY(Y.length);return J.unshift(183+J.length),J.concat(Y)};function b0(Q){let Y="0x";for(let J of TY(Q))Y+=CY[J>>4],Y+=CY[J&15];return Y}var CY="0123456789abcdef";function gQ(Q){const Y=N(Q,"randomBytes");Y[6]=Y[6]&15|64,Y[8]=Y[8]&63|128;const J=T(Y);return[J.substring(2,10),J.substring(10,14),J.substring(14,18),J.substring(18,22),J.substring(22,34)].join("-")}var H0=function(Q){if(!Number.isSafeInteger(Q)||Q<0)throw new Error(`Wrong positive integer: ${Q}`)};var p9=function(Q,...Y){if(!(Q instanceof Uint8Array))throw new Error("Expected Uint8Array");if(Y.length>0&&!Y.includes(Q.length))throw new Error(`Expected Uint8Array of length ${Y}, not of length=${Q.length}`)},yQ=function(Q){if(typeof Q!=="function"||typeof Q.create!=="function")throw new Error("Hash should be wrapped by utils.wrapConstructor");H0(Q.outputLen),H0(Q.blockLen)},V8=function(Q,Y=!0){if(Q.destroyed)throw new Error("Hash instance has been destroyed");if(Y&&Q.finished)throw new Error("Hash#digest() has already been called")},hQ=function(Q,Y){p9(Q);const J=Y.outputLen;if(Q.length<J)throw new Error(`digestInto() expects output buffer of length at least ${J}`)};var mQ=typeof globalThis==="object"&&("crypto"in globalThis)?globalThis.crypto:void 0;async function _Q(Q,Y,J){let X=Date.now();for(let q=0;q<Q;q++){J(q);const G=Date.now()-X;if(G>=0&&G<Y)continue;await W1(),X+=G}}function V1(Q){if(typeof Q!=="string")throw new Error(`utf8ToBytes expected string, got ${typeof Q}`);return new Uint8Array((new TextEncoder()).encode(Q))}function s0(Q){if(typeof Q==="string")Q=V1(Q);if(!NY(Q))throw new Error(`expected Uint8Array, got ${typeof Q}`);return Q}function wY(...Q){const Y=new Uint8Array(Q.reduce((X,q)=>X+q.length,0));let J=0;return Q.forEach((X)=>{if(!NY(X))throw new Error("Uint8Array expected");Y.set(X,J),J+=X.length}),Y}function cQ(Q,Y){if(Y!==void 0&&$1.call(Y)!=="[object Object]")throw new Error("Options should be object or undefined");return Object.assign(Q,Y)}function B8(Q){const Y=(X)=>Q().update(s0(X)).digest(),J=Q();return Y.outputLen=J.outputLen,Y.blockLen=J.blockLen,Y.create=()=>Q(),Y}function FY(Q=32){if(mQ&&typeof mQ.getRandomValues==="function")return mQ.getRandomValues(new Uint8Array(Q));throw new Error("crypto.getRandomValues must be defined")}/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */var NY=(Q)=>Q instanceof Uint8Array;var R9=(Q)=>new Uint32Array(Q.buffer,Q.byteOffset,Math.floor(Q.byteLength/4)),P9=(Q)=>new DataView(Q.buffer,Q.byteOffset,Q.byteLength),l0=(Q,Y)=>Q<<32-Y|Q>>>Y,U1=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;if(!U1)throw new Error("Non little-endian hardware is not supported");var W1=async()=>{};class l8{clone(){return this._cloneInto()}}var $1={}.toString;class mJ extends l8{constructor(Q,Y){super();this.finished=!1,this.destroyed=!1,yQ(Q);const J=s0(Y);if(this.iHash=Q.create(),typeof this.iHash.update!=="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const X=this.blockLen,q=new Uint8Array(X);q.set(J.length>X?Q.create().update(J).digest():J);for(let G=0;G<q.length;G++)q[G]^=54;this.iHash.update(q),this.oHash=Q.create();for(let G=0;G<q.length;G++)q[G]^=54^92;this.oHash.update(q),q.fill(0)}update(Q){return V8(this),this.iHash.update(Q),this}digestInto(Q){V8(this),p9(Q,this.outputLen),this.finished=!0,this.iHash.digestInto(Q),this.oHash.update(Q),this.oHash.digestInto(Q),this.destroy()}digest(){const Q=new Uint8Array(this.oHash.outputLen);return this.digestInto(Q),Q}_cloneInto(Q){Q||(Q=Object.create(Object.getPrototypeOf(this),{}));const{oHash:Y,iHash:J,finished:X,destroyed:q,blockLen:G,outputLen:U}=this;return Q=Q,Q.finished=X,Q.destroyed=q,Q.blockLen=G,Q.outputLen=U,Q.oHash=Y._cloneInto(Q.oHash),Q.iHash=J._cloneInto(Q.iHash),Q}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}var n8=(Q,Y,J)=>new mJ(Q,Y).update(J).digest();n8.create=(Q,Y)=>new mJ(Q,Y);var z1=function(Q,Y,J,X){yQ(Q);const q=cQ({dkLen:32,asyncTick:10},X),{c:G,dkLen:U,asyncTick:W}=q;if(H0(G),H0(U),H0(W),G<1)throw new Error("PBKDF2: iterations (c) should be >= 1");const $=s0(Y),V=s0(J),z=new Uint8Array(U),M=n8.create(Q,$),K=M._cloneInto().update(V);return{c:G,dkLen:U,asyncTick:W,DK:z,PRF:M,PRFSalt:K}},Z1=function(Q,Y,J,X,q){if(Q.destroy(),Y.destroy(),X)X.destroy();return q.fill(0),J};function u9(Q,Y,J,X){const{c:q,dkLen:G,DK:U,PRF:W,PRFSalt:$}=z1(Q,Y,J,X);let V;const z=new Uint8Array(4),M=P9(z),K=new Uint8Array(W.outputLen);for(let j=1,Z=0;Z<G;j++,Z+=W.outputLen){const D=U.subarray(Z,Z+W.outputLen);M.setInt32(0,j,!1),(V=$._cloneInto(V)).update(z).digestInto(K),D.set(K.subarray(0,D.length));for(let I=1;I<q;I++){W._cloneInto(V).update(K).digestInto(K);for(let L=0;L<D.length;L++)D[L]^=K[L]}}return Z1(W,$,U,V,K)}var M1=function(Q,Y,J,X){if(typeof Q.setBigUint64==="function")return Q.setBigUint64(Y,J,X);const q=BigInt(32),G=BigInt(4294967295),U=Number(J>>q&G),W=Number(J&G),$=X?4:0,V=X?0:4;Q.setUint32(Y+$,U,X),Q.setUint32(Y+V,W,X)};class i8 extends l8{constructor(Q,Y,J,X){super();this.blockLen=Q,this.outputLen=Y,this.padOffset=J,this.isLE=X,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(Q),this.view=P9(this.buffer)}update(Q){V8(this);const{view:Y,buffer:J,blockLen:X}=this;Q=s0(Q);const q=Q.length;for(let G=0;G<q;){const U=Math.min(X-this.pos,q-G);if(U===X){const W=P9(Q);for(;X<=q-G;G+=X)this.process(W,G);continue}if(J.set(Q.subarray(G,G+U),this.pos),this.pos+=U,G+=U,this.pos===X)this.process(Y,0),this.pos=0}return this.length+=Q.length,this.roundClean(),this}digestInto(Q){V8(this),hQ(Q,this),this.finished=!0;const{buffer:Y,view:J,blockLen:X,isLE:q}=this;let{pos:G}=this;if(Y[G++]=128,this.buffer.subarray(G).fill(0),this.padOffset>X-G)this.process(J,0),G=0;for(let z=G;z<X;z++)Y[z]=0;M1(J,X-8,BigInt(this.length*8),q),this.process(J,0);const U=P9(Q),W=this.outputLen;if(W%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const $=W/4,V=this.get();if($>V.length)throw new Error("_sha2: outputLen bigger than state");for(let z=0;z<$;z++)U.setUint32(4*z,V[z],q)}digest(){const{buffer:Q,outputLen:Y}=this;this.digestInto(Q);const J=Q.slice(0,Y);return this.destroy(),J}_cloneInto(Q){Q||(Q=new this.constructor),Q.set(...this.get());const{blockLen:Y,buffer:J,length:X,finished:q,destroyed:G,pos:U}=this;if(Q.length=X,Q.pos=U,Q.finished=q,Q.destroyed=G,X%Y)Q.buffer.set(J);return Q}}var K1=(Q,Y,J)=>Q&Y^~Q&J,j1=(Q,Y,J)=>Q&Y^Q&J^Y&J,O1=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),E8=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),S8=new Uint32Array(64);class BY extends i8{constructor(){super(64,32,8,!1);this.A=E8[0]|0,this.B=E8[1]|0,this.C=E8[2]|0,this.D=E8[3]|0,this.E=E8[4]|0,this.F=E8[5]|0,this.G=E8[6]|0,this.H=E8[7]|0}get(){const{A:Q,B:Y,C:J,D:X,E:q,F:G,G:U,H:W}=this;return[Q,Y,J,X,q,G,U,W]}set(Q,Y,J,X,q,G,U,W){this.A=Q|0,this.B=Y|0,this.C=J|0,this.D=X|0,this.E=q|0,this.F=G|0,this.G=U|0,this.H=W|0}process(Q,Y){for(let z=0;z<16;z++,Y+=4)S8[z]=Q.getUint32(Y,!1);for(let z=16;z<64;z++){const M=S8[z-15],K=S8[z-2],j=l0(M,7)^l0(M,18)^M>>>3,Z=l0(K,17)^l0(K,19)^K>>>10;S8[z]=Z+S8[z-7]+j+S8[z-16]|0}let{A:J,B:X,C:q,D:G,E:U,F:W,G:$,H:V}=this;for(let z=0;z<64;z++){const M=l0(U,6)^l0(U,11)^l0(U,25),K=V+M+K1(U,W,$)+O1[z]+S8[z]|0,Z=(l0(J,2)^l0(J,13)^l0(J,22))+j1(J,X,q)|0;V=$,$=W,W=U,U=G+K|0,G=q,q=X,X=J,J=K+Z|0}J=J+this.A|0,X=X+this.B|0,q=q+this.C|0,G=G+this.D|0,U=U+this.E|0,W=W+this.F|0,$=$+this.G|0,V=V+this.H|0,this.set(J,X,q,G,U,W,$,V)}roundClean(){S8.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}}var $8=B8(()=>new BY);var EY=function(Q,Y=!1){if(Y)return{h:Number(Q&pQ),l:Number(Q>>_J&pQ)};return{h:Number(Q>>_J&pQ)|0,l:Number(Q&pQ)|0}},cJ=function(Q,Y=!1){let J=new Uint32Array(Q.length),X=new Uint32Array(Q.length);for(let q=0;q<Q.length;q++){const{h:G,l:U}=EY(Q[q],Y);[J[q],X[q]]=[G,U]}return[J,X]},w1=function(Q,Y,J,X){const q=(Y>>>0)+(X>>>0);return{h:Q+J+(q/4294967296|0)|0,l:q|0}},pQ=BigInt(4294967295),_J=BigInt(32),D1=(Q,Y)=>BigInt(Q>>>0)<<_J|BigInt(Y>>>0),I1=(Q,Y,J)=>Q>>>J,L1=(Q,Y,J)=>Q<<32-J|Y>>>J,H1=(Q,Y,J)=>Q>>>J|Y<<32-J,R1=(Q,Y,J)=>Q<<32-J|Y>>>J,P1=(Q,Y,J)=>Q<<64-J|Y>>>J-32,C1=(Q,Y,J)=>Q>>>J-32|Y<<64-J,T1=(Q,Y)=>Y,N1=(Q,Y)=>Q,pJ=(Q,Y,J)=>Q<<J|Y>>>32-J,uJ=(Q,Y,J)=>Y<<J|Q>>>32-J,dJ=(Q,Y,J)=>Y<<J-32|Q>>>64-J,lJ=(Q,Y,J)=>Q<<J-32|Y>>>64-J,F1=(Q,Y,J)=>(Q>>>0)+(Y>>>0)+(J>>>0),B1=(Q,Y,J,X)=>Y+J+X+(Q/4294967296|0)|0,E1=(Q,Y,J,X)=>(Q>>>0)+(Y>>>0)+(J>>>0)+(X>>>0),S1=(Q,Y,J,X,q)=>Y+J+X+q+(Q/4294967296|0)|0,A1=(Q,Y,J,X,q)=>(Q>>>0)+(Y>>>0)+(J>>>0)+(X>>>0)+(q>>>0),k1=(Q,Y,J,X,q,G)=>Y+J+X+q+G+(Q/4294967296|0)|0;var x1={fromBig:EY,split:cJ,toBig:D1,shrSH:I1,shrSL:L1,rotrSH:H1,rotrSL:R1,rotrBH:P1,rotrBL:C1,rotr32H:T1,rotr32L:N1,rotlSH:pJ,rotlSL:uJ,rotlBH:dJ,rotlBL:lJ,add:w1,add3L:F1,add3H:B1,add4L:E1,add4H:S1,add5H:k1,add5L:A1},v=x1;var[f1,b1]=(()=>v.split(["0x428a2f98d728ae22","0x7137449123ef65cd","0xb5c0fbcfec4d3b2f","0xe9b5dba58189dbbc","0x3956c25bf348b538","0x59f111f1b605d019","0x923f82a4af194f9b","0xab1c5ed5da6d8118","0xd807aa98a3030242","0x12835b0145706fbe","0x243185be4ee4b28c","0x550c7dc3d5ffb4e2","0x72be5d74f27b896f","0x80deb1fe3b1696b1","0x9bdc06a725c71235","0xc19bf174cf692694","0xe49b69c19ef14ad2","0xefbe4786384f25e3","0x0fc19dc68b8cd5b5","0x240ca1cc77ac9c65","0x2de92c6f592b0275","0x4a7484aa6ea6e483","0x5cb0a9dcbd41fbd4","0x76f988da831153b5","0x983e5152ee66dfab","0xa831c66d2db43210","0xb00327c898fb213f","0xbf597fc7beef0ee4","0xc6e00bf33da88fc2","0xd5a79147930aa725","0x06ca6351e003826f","0x142929670a0e6e70","0x27b70a8546d22ffc","0x2e1b21385c26c926","0x4d2c6dfc5ac42aed","0x53380d139d95b3df","0x650a73548baf63de","0x766a0abb3c77b2a8","0x81c2c92e47edaee6","0x92722c851482353b","0xa2bfe8a14cf10364","0xa81a664bbc423001","0xc24b8b70d0f89791","0xc76c51a30654be30","0xd192e819d6ef5218","0xd69906245565a910","0xf40e35855771202a","0x106aa07032bbd1b8","0x19a4c116b8d2d0c8","0x1e376c085141ab53","0x2748774cdf8eeb99","0x34b0bcb5e19b48a8","0x391c0cb3c5c95a63","0x4ed8aa4ae3418acb","0x5b9cca4f7763e373","0x682e6ff3d6b2b8a3","0x748f82ee5defb2fc","0x78a5636f43172f60","0x84c87814a1f0ab72","0x8cc702081a6439ec","0x90befffa23631e28","0xa4506cebde82bde9","0xbef9a3f7b2c67915","0xc67178f2e372532b","0xca273eceea26619c","0xd186b8c721c0c207","0xeada7dd6cde0eb1e","0xf57d4f7fee6ed178","0x06f067aa72176fba","0x0a637dc5a2c898a6","0x113f9804bef90dae","0x1b710b35131c471b","0x28db77f523047d84","0x32caab7b40c72493","0x3c9ebe0a15c9bebc","0x431d67c49c100d4c","0x4cc5d4becb3e42b6","0x597f299cfc657e2a","0x5fcb6fab3ad6faec","0x6c44198c4a475817"].map((Q)=>BigInt(Q))))(),A8=new Uint32Array(80),k8=new Uint32Array(80);class SY extends i8{constructor(){super(128,64,16,!1);this.Ah=1779033703|0,this.Al=4089235720|0,this.Bh=3144134277|0,this.Bl=2227873595|0,this.Ch=1013904242|0,this.Cl=4271175723|0,this.Dh=2773480762|0,this.Dl=1595750129|0,this.Eh=1359893119|0,this.El=2917565137|0,this.Fh=2600822924|0,this.Fl=725511199|0,this.Gh=528734635|0,this.Gl=4215389547|0,this.Hh=1541459225|0,this.Hl=327033209|0}get(){const{Ah:Q,Al:Y,Bh:J,Bl:X,Ch:q,Cl:G,Dh:U,Dl:W,Eh:$,El:V,Fh:z,Fl:M,Gh:K,Gl:j,Hh:Z,Hl:D}=this;return[Q,Y,J,X,q,G,U,W,$,V,z,M,K,j,Z,D]}set(Q,Y,J,X,q,G,U,W,$,V,z,M,K,j,Z,D){this.Ah=Q|0,this.Al=Y|0,this.Bh=J|0,this.Bl=X|0,this.Ch=q|0,this.Cl=G|0,this.Dh=U|0,this.Dl=W|0,this.Eh=$|0,this.El=V|0,this.Fh=z|0,this.Fl=M|0,this.Gh=K|0,this.Gl=j|0,this.Hh=Z|0,this.Hl=D|0}process(Q,Y){for(let R=0;R<16;R++,Y+=4)A8[R]=Q.getUint32(Y),k8[R]=Q.getUint32(Y+=4);for(let R=16;R<80;R++){const F=A8[R-15]|0,H=k8[R-15]|0,C=v.rotrSH(F,H,1)^v.rotrSH(F,H,8)^v.shrSH(F,H,7),E=v.rotrSL(F,H,1)^v.rotrSL(F,H,8)^v.shrSL(F,H,7),P=A8[R-2]|0,f=k8[R-2]|0,S=v.rotrSH(P,f,19)^v.rotrBH(P,f,61)^v.shrSH(P,f,6),B=v.rotrSL(P,f,19)^v.rotrBL(P,f,61)^v.shrSL(P,f,6),A=v.add4L(E,B,k8[R-7],k8[R-16]),c=v.add4H(A,C,S,A8[R-7],A8[R-16]);A8[R]=c|0,k8[R]=A|0}let{Ah:J,Al:X,Bh:q,Bl:G,Ch:U,Cl:W,Dh:$,Dl:V,Eh:z,El:M,Fh:K,Fl:j,Gh:Z,Gl:D,Hh:I,Hl:L}=this;for(let R=0;R<80;R++){const F=v.rotrSH(z,M,14)^v.rotrSH(z,M,18)^v.rotrBH(z,M,41),H=v.rotrSL(z,M,14)^v.rotrSL(z,M,18)^v.rotrBL(z,M,41),C=z&K^~z&Z,E=M&j^~M&D,P=v.add5L(L,H,E,b1[R],k8[R]),f=v.add5H(P,I,F,C,f1[R],A8[R]),S=P|0,B=v.rotrSH(J,X,28)^v.rotrBH(J,X,34)^v.rotrBH(J,X,39),A=v.rotrSL(J,X,28)^v.rotrBL(J,X,34)^v.rotrBL(J,X,39),c=J&q^J&U^q&U,G0=X&G^X&W^G&W;I=Z|0,L=D|0,Z=K|0,D=j|0,K=z|0,j=M|0,{h:z,l:M}=v.add($|0,V|0,f|0,S|0),$=U|0,V=W|0,U=q|0,W=G|0,q=J|0,G=X|0;const p=v.add3L(S,A,G0);J=v.add3H(p,f,B,c),X=p|0}({h:J,l:X}=v.add(this.Ah|0,this.Al|0,J|0,X|0)),{h:q,l:G}=v.add(this.Bh|0,this.Bl|0,q|0,G|0),{h:U,l:W}=v.add(this.Ch|0,this.Cl|0,U|0,W|0),{h:$,l:V}=v.add(this.Dh|0,this.Dl|0,$|0,V|0),{h:z,l:M}=v.add(this.Eh|0,this.El|0,z|0,M|0),{h:K,l:j}=v.add(this.Fh|0,this.Fl|0,K|0,j|0),{h:Z,l:D}=v.add(this.Gh|0,this.Gl|0,Z|0,D|0),{h:I,l:L}=v.add(this.Hh|0,this.Hl|0,I|0,L|0),this.set(J,X,q,G,U,W,$,V,z,M,K,j,Z,D,I,L)}roundClean(){A8.fill(0),k8.fill(0)}destroy(){this.buffer.fill(0),this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}}var uQ=B8(()=>new SY);var v1=function(){if(typeof self!=="undefined")return self;if(typeof window!=="undefined")return window;if(typeof window!=="undefined")return window;throw new Error("unable to locate global object")};function nJ(Q){switch(Q){case"sha256":return $8.create();case"sha512":return uQ.create()}O(!1,"invalid hashing algorithm name","algorithm",Q)}function xY(Q,Y){const J={sha256:$8,sha512:uQ}[Q];return O(J!=null,"invalid hmac algorithm","algorithm",Q),n8.create(J,Y)}function fY(Q,Y,J,X,q){const G={sha256:$8,sha512:uQ}[q];return O(G!=null,"invalid pbkdf2 algorithm","algorithm",q),u9(G,Q,Y,{c:J,dkLen:X})}function bY(Q){x(kY!=null,"platform does not support secure random numbers","UNSUPPORTED_OPERATION",{operation:"randomBytes"}),O(Number.isInteger(Q)&&Q>0&&Q<=1024,"invalid length","length",Q);const Y=new Uint8Array(Q);return kY.getRandomValues(Y),Y}var AY=v1(),kY=AY.crypto||AY.msCrypto;function z8(Q,Y,J){const X=N(Y,"key"),q=N(J,"data");return T(yY(Q,X,q))}var vY=!1,gY=function(Q,Y,J){return xY(Q,Y).update(J).digest()},yY=gY;z8._=gY;z8.lock=function(){vY=!0};z8.register=function(Q){if(vY)throw new Error("computeHmac is locked");yY=Q};Object.freeze(z8);function u1(Q,Y=24){const J=new Uint32Array(10);for(let X=24-Y;X<24;X++){for(let U=0;U<10;U++)J[U]=Q[U]^Q[U+10]^Q[U+20]^Q[U+30]^Q[U+40];for(let U=0;U<10;U+=2){const W=(U+8)%10,$=(U+2)%10,V=J[$],z=J[$+1],M=hY(V,z,1)^J[W],K=mY(V,z,1)^J[W+1];for(let j=0;j<50;j+=10)Q[U+j]^=M,Q[U+j+1]^=K}let q=Q[2],G=Q[3];for(let U=0;U<24;U++){const W=cY[U],$=hY(q,G,W),V=mY(q,G,W),z=_Y[U];q=Q[z],G=Q[z+1],Q[z]=$,Q[z+1]=V}for(let U=0;U<50;U+=10){for(let W=0;W<10;W++)J[W]=Q[U+W];for(let W=0;W<10;W++)Q[U+W]^=~J[(W+2)%10]&J[(W+4)%10]}Q[0]^=c1[X],Q[1]^=p1[X]}J.fill(0)}var[_Y,cY,pY]=[[],[],[]],g1=BigInt(0),d9=BigInt(1),y1=BigInt(2),h1=BigInt(7),m1=BigInt(256),_1=BigInt(113);for(let Q=0,Y=d9,J=1,X=0;Q<24;Q++){[J,X]=[X,(2*J+3*X)%5],_Y.push(2*(5*X+J)),cY.push((Q+1)*(Q+2)/2%64);let q=g1;for(let G=0;G<7;G++)if(Y=(Y<<d9^(Y>>h1)*_1)%m1,Y&y1)q^=d9<<(d9<<BigInt(G))-d9;pY.push(q)}var[c1,p1]=cJ(pY,!0),hY=(Q,Y,J)=>J>32?dJ(Q,Y,J):pJ(Q,Y,J),mY=(Q,Y,J)=>J>32?lJ(Q,Y,J):uJ(Q,Y,J);class iJ extends l8{constructor(Q,Y,J,X=!1,q=24){super();if(this.blockLen=Q,this.suffix=Y,this.outputLen=J,this.enableXOF=X,this.rounds=q,this.pos=0,this.posOut=0,this.finished=!1,this.destroyed=!1,H0(J),0>=this.blockLen||this.blockLen>=200)throw new Error("Sha3 supports only keccak-f1600 function");this.state=new Uint8Array(200),this.state32=R9(this.state)}keccak(){u1(this.state32,this.rounds),this.posOut=0,this.pos=0}update(Q){V8(this);const{blockLen:Y,state:J}=this;Q=s0(Q);const X=Q.length;for(let q=0;q<X;){const G=Math.min(Y-this.pos,X-q);for(let U=0;U<G;U++)J[this.pos++]^=Q[q++];if(this.pos===Y)this.keccak()}return this}finish(){if(this.finished)return;this.finished=!0;const{state:Q,suffix:Y,pos:J,blockLen:X}=this;if(Q[J]^=Y,(Y&128)!==0&&J===X-1)this.keccak();Q[X-1]^=128,this.keccak()}writeInto(Q){V8(this,!1),p9(Q),this.finish();const Y=this.state,{blockLen:J}=this;for(let X=0,q=Q.length;X<q;){if(this.posOut>=J)this.keccak();const G=Math.min(J-this.posOut,q-X);Q.set(Y.subarray(this.posOut,this.posOut+G),X),this.posOut+=G,X+=G}return Q}xofInto(Q){if(!this.enableXOF)throw new Error("XOF is not possible for this instance");return this.writeInto(Q)}xof(Q){return H0(Q),this.xofInto(new Uint8Array(Q))}digestInto(Q){if(hQ(Q,this),this.finished)throw new Error("digest() was already called");return this.writeInto(Q),this.destroy(),Q}digest(){return this.digestInto(new Uint8Array(this.outputLen))}destroy(){this.destroyed=!0,this.state.fill(0)}_cloneInto(Q){const{blockLen:Y,suffix:J,outputLen:X,rounds:q,enableXOF:G}=this;return Q||(Q=new iJ(Y,J,X,G,q)),Q.state32.set(this.state32),Q.pos=this.pos,Q.posOut=this.posOut,Q.finished=this.finished,Q.rounds=q,Q.suffix=J,Q.outputLen=X,Q.enableXOF=G,Q.destroyed=this.destroyed,Q}}var d1=(Q,Y,J)=>B8(()=>new iJ(Y,Q,J));var uY=d1(1,136,32);function n(Q){const Y=N(Q,"data");return T(nY(Y))}var dY=!1,lY=function(Q){return uY(Q)},nY=lY;n._=lY;n.lock=function(){dY=!0};n.register=function(Q){if(dY)throw new TypeError("keccak256 is locked");nY=Q};Object.freeze(n);var iY=function(Q,Y,J,X){if(Q===0)return Y^J^X;else if(Q===1)return Y&J|~Y&X;else if(Q===2)return(Y|~J)^X;else if(Q===3)return Y&X|J&~X;else return Y^(J|~X)},l1=new Uint8Array([7,4,13,1,10,6,15,3,12,0,9,5,2,14,11,8]),oY=Uint8Array.from({length:16},(Q,Y)=>Y),n1=oY.map((Q)=>(9*Q+5)%16),oJ=[oY],rJ=[n1];for(let Q=0;Q<4;Q++)for(let Y of[oJ,rJ])Y.push(Y[Q].map((J)=>l1[J]));var rY=[[11,14,15,12,5,8,7,9,11,13,14,15,6,7,9,8],[12,13,11,15,6,9,9,7,12,15,11,13,7,8,7,7],[13,15,14,11,7,7,6,8,13,14,13,12,5,5,6,9],[14,11,12,14,8,6,5,5,15,12,15,14,9,9,8,6],[15,12,13,13,9,5,8,6,14,11,12,11,8,6,5,5]].map((Q)=>new Uint8Array(Q)),i1=oJ.map((Q,Y)=>Q.map((J)=>rY[Y][J])),o1=rJ.map((Q,Y)=>Q.map((J)=>rY[Y][J])),r1=new Uint32Array([0,1518500249,1859775393,2400959708,2840853838]),a1=new Uint32Array([1352829926,1548603684,1836072691,2053994217,0]),dQ=(Q,Y)=>Q<<Y|Q>>>32-Y,lQ=new Uint32Array(16);class aY extends i8{constructor(){super(64,20,8,!0);this.h0=1732584193|0,this.h1=4023233417|0,this.h2=2562383102|0,this.h3=271733878|0,this.h4=3285377520|0}get(){const{h0:Q,h1:Y,h2:J,h3:X,h4:q}=this;return[Q,Y,J,X,q]}set(Q,Y,J,X,q){this.h0=Q|0,this.h1=Y|0,this.h2=J|0,this.h3=X|0,this.h4=q|0}process(Q,Y){for(let K=0;K<16;K++,Y+=4)lQ[K]=Q.getUint32(Y,!0);let J=this.h0|0,X=J,q=this.h1|0,G=q,U=this.h2|0,W=U,$=this.h3|0,V=$,z=this.h4|0,M=z;for(let K=0;K<5;K++){const j=4-K,Z=r1[K],D=a1[K],I=oJ[K],L=rJ[K],R=i1[K],F=o1[K];for(let H=0;H<16;H++){const C=dQ(J+iY(K,q,U,$)+lQ[I[H]]+Z,R[H])+z|0;J=z,z=$,$=dQ(U,10)|0,U=q,q=C}for(let H=0;H<16;H++){const C=dQ(X+iY(j,G,W,V)+lQ[L[H]]+D,F[H])+M|0;X=M,M=V,V=dQ(W,10)|0,W=G,G=C}}this.set(this.h1+U+V|0,this.h2+$+M|0,this.h3+z+X|0,this.h4+J+G|0,this.h0+q+W|0)}roundClean(){lQ.fill(0)}destroy(){this.destroyed=!0,this.buffer.fill(0),this.set(0,0,0,0,0)}}var sY=B8(()=>new aY);function Z8(Q){const Y=N(Q,"data");return T(QX(Y))}var tY=!1,eY=function(Q){return sY(Q)},QX=eY;Z8._=eY;Z8.lock=function(){tY=!0};Z8.register=function(Q){if(tY)throw new TypeError("ripemd160 is locked");QX=Q};Object.freeze(Z8);function S0(Q,Y,J,X,q){const G=N(Q,"password"),U=N(Y,"salt");return T(XX(G,U,J,X,q))}var JX=!1,YX=function(Q,Y,J,X,q){return fY(Q,Y,J,X,q)},XX=YX;S0._=YX;S0.lock=function(){JX=!0};S0.register=function(Q){if(JX)throw new Error("pbkdf2 is locked");XX=Q};Object.freeze(S0);function W0(Q){return UX(Q)}var qX=!1,GX=function(Q){return new Uint8Array(bY(Q))},UX=GX;W0._=GX;W0.lock=function(){qX=!0};W0.register=function(Q){if(qX)throw new Error("randomBytes is locked");UX=Q};Object.freeze(W0);var WX=function(Q,Y,J,X,q,G){let U=Q[Y++]^J[X++],W=Q[Y++]^J[X++],$=Q[Y++]^J[X++],V=Q[Y++]^J[X++],z=Q[Y++]^J[X++],M=Q[Y++]^J[X++],K=Q[Y++]^J[X++],j=Q[Y++]^J[X++],Z=Q[Y++]^J[X++],D=Q[Y++]^J[X++],I=Q[Y++]^J[X++],L=Q[Y++]^J[X++],R=Q[Y++]^J[X++],F=Q[Y++]^J[X++],H=Q[Y++]^J[X++],C=Q[Y++]^J[X++],E=U,P=W,f=$,S=V,B=z,A=M,c=K,G0=j,p=Z,w=D,b=I,g=L,u=R,l=F,r=H,U0=C;for(let I0=0;I0<8;I0+=2)B^=d(E+u|0,7),p^=d(B+E|0,9),u^=d(p+B|0,13),E^=d(u+p|0,18),w^=d(A+P|0,7),l^=d(w+A|0,9),P^=d(l+w|0,13),A^=d(P+l|0,18),r^=d(b+c|0,7),f^=d(r+b|0,9),c^=d(f+r|0,13),b^=d(c+f|0,18),S^=d(U0+g|0,7),G0^=d(S+U0|0,9),g^=d(G0+S|0,13),U0^=d(g+G0|0,18),P^=d(E+S|0,7),f^=d(P+E|0,9),S^=d(f+P|0,13),E^=d(S+f|0,18),c^=d(A+B|0,7),G0^=d(c+A|0,9),B^=d(G0+c|0,13),A^=d(B+G0|0,18),g^=d(b+w|0,7),p^=d(g+b|0,9),w^=d(p+g|0,13),b^=d(w+p|0,18),u^=d(U0+r|0,7),l^=d(u+U0|0,9),r^=d(l+u|0,13),U0^=d(r+l|0,18);q[G++]=U+E|0,q[G++]=W+P|0,q[G++]=$+f|0,q[G++]=V+S|0,q[G++]=z+B|0,q[G++]=M+A|0,q[G++]=K+c|0,q[G++]=j+G0|0,q[G++]=Z+p|0,q[G++]=D+w|0,q[G++]=I+b|0,q[G++]=L+g|0,q[G++]=R+u|0,q[G++]=F+l|0,q[G++]=H+r|0,q[G++]=C+U0|0},C9=function(Q,Y,J,X,q){let G=X+0,U=X+16*q;for(let W=0;W<16;W++)J[U+W]=Q[Y+(2*q-1)*16+W];for(let W=0;W<q;W++,G+=16,Y+=16){if(WX(J,U,Q,Y,J,G),W>0)U+=16;WX(J,G,Q,Y+=16,J,U)}},VX=function(Q,Y,J){const X=cQ({dkLen:32,asyncTick:10,maxmem:1073742848},J),{N:q,r:G,p:U,dkLen:W,asyncTick:$,maxmem:V,onProgress:z}=X;if(H0(q),H0(G),H0(U),H0(W),H0($),H0(V),z!==void 0&&typeof z!=="function")throw new Error("progressCb should be function");const M=128*G,K=M/4;if(q<=1||(q&q-1)!==0||q>=2**(M/8)||q>4294967296)throw new Error("Scrypt: N must be larger than 1, a power of 2, less than 2^(128 * r / 8) and less than 2^32");if(U<0||U>137438953440/M)throw new Error("Scrypt: p must be a positive integer less than or equal to ((2^32 - 1) * 32) / (128 * r)");if(W<0||W>137438953440)throw new Error("Scrypt: dkLen should be positive integer less than or equal to (2^32 - 1) * 32");const j=M*(q+U);if(j>V)throw new Error(`Scrypt: parameters too large, ${j} (128 * r * (N + p)) > ${V} (maxmem)`);const Z=u9($8,Q,Y,{c:1,dkLen:M*U}),D=R9(Z),I=R9(new Uint8Array(M*q)),L=R9(new Uint8Array(M));let R=()=>{};if(z){const F=2*q*U,H=Math.max(Math.floor(F/1e4),1);let C=0;R=()=>{if(C++,z&&(!(C%H)||C===F))z(C/F)}}return{N:q,r:G,p:U,dkLen:W,blockSize32:K,V:I,B32:D,B:Z,tmp:L,blockMixCb:R,asyncTick:$}},$X=function(Q,Y,J,X,q){const G=u9($8,Q,J,{c:1,dkLen:Y});return J.fill(0),X.fill(0),q.fill(0),G};function zX(Q,Y,J){const{N:X,r:q,p:G,dkLen:U,blockSize32:W,V:$,B32:V,B:z,tmp:M,blockMixCb:K}=VX(Q,Y,J);for(let j=0;j<G;j++){const Z=W*j;for(let D=0;D<W;D++)$[D]=V[Z+D];for(let D=0,I=0;D<X-1;D++)C9($,I,$,I+=W,q),K();C9($,(X-1)*W,V,Z,q),K();for(let D=0;D<X;D++){const I=V[Z+W-16]%X;for(let L=0;L<W;L++)M[L]=V[Z+L]^$[I*W+L];C9(M,0,V,Z,q),K()}}return $X(Q,U,z,$,M)}async function ZX(Q,Y,J){const{N:X,r:q,p:G,dkLen:U,blockSize32:W,V:$,B32:V,B:z,tmp:M,blockMixCb:K,asyncTick:j}=VX(Q,Y,J);for(let Z=0;Z<G;Z++){const D=W*Z;for(let L=0;L<W;L++)$[L]=V[D+L];let I=0;await _Q(X-1,j,()=>{C9($,I,$,I+=W,q),K()}),C9($,(X-1)*W,V,D,q),K(),await _Q(X,j,()=>{const L=V[D+W-16]%X;for(let R=0;R<W;R++)M[R]=V[D+R]^$[L*W+R];C9(M,0,V,D,q),K()})}return $X(Q,U,z,$,M)}var d=(Q,Y)=>Q<<Y|Q>>>32-Y;async function M8(Q,Y,J,X,q,G,U){const W=N(Q,"passwd"),$=N(Y,"salt");return T(await DX(W,$,J,X,q,G,U))}function K8(Q,Y,J,X,q,G){const U=N(Q,"passwd"),W=N(Y,"salt");return T(IX(U,W,J,X,q,G))}var MX=!1,KX=!1,jX=async function(Q,Y,J,X,q,G,U){return await ZX(Q,Y,{N:J,r:X,p:q,dkLen:G,onProgress:U})},OX=function(Q,Y,J,X,q,G){return zX(Q,Y,{N:J,r:X,p:q,dkLen:G})},DX=jX,IX=OX;M8._=jX;M8.lock=function(){KX=!0};M8.register=function(Q){if(KX)throw new Error("scrypt is locked");DX=Q};Object.freeze(M8);K8._=OX;K8.lock=function(){MX=!0};K8.register=function(Q){if(MX)throw new Error("scryptSync is locked");IX=Q};Object.freeze(K8);function j0(Q){const Y=N(Q,"data");return T(RX(Y))}function l9(Q){const Y=N(Q,"data");return T(PX(Y))}var LX=function(Q){return nJ("sha256").update(Q).digest()},HX=function(Q){return nJ("sha512").update(Q).digest()},RX=LX,PX=HX,CX=!1,TX=!1;j0._=LX;j0.lock=function(){CX=!0};j0.register=function(Q){if(CX)throw new Error("sha256 is locked");RX=Q};Object.freeze(j0);l9._=HX;l9.lock=function(){TX=!0};l9.register=function(Q){if(TX)throw new Error("sha512 is locked");PX=Q};Object.freeze(j0);var eJ={};p7(eJ,{validateObject:()=>{{return f8}},utf8ToBytes:()=>{{return JG}},numberToVarBytesBE:()=>{{return e1}},numberToHexUnpadded:()=>{{return FX}},numberToBytesLE:()=>{{return rQ}},numberToBytesBE:()=>{{return x8}},hexToNumber:()=>{{return sJ}},hexToBytes:()=>{{return r8}},equalBytes:()=>{{return QG}},ensureBytes:()=>{{return A0}},createHmacDrbg:()=>{{return tJ}},concatBytes:()=>{{return T9}},bytesToNumberLE:()=>{{return oQ}},bytesToNumberBE:()=>{{return j8}},bytesToHex:()=>{{return o8}},bitSet:()=>{{return qG}},bitMask:()=>{{return n9}},bitLen:()=>{{return YG}},bitGet:()=>{{return XG}}});function o8(Q){if(!iQ(Q))throw new Error("Uint8Array expected");let Y="";for(let J=0;J<Q.length;J++)Y+=t1[Q[J]];return Y}function FX(Q){const Y=Q.toString(16);return Y.length&1?`0${Y}`:Y}function sJ(Q){if(typeof Q!=="string")throw new Error("hex string expected, got "+typeof Q);return BigInt(Q===""?"0":`0x${Q}`)}function r8(Q){if(typeof Q!=="string")throw new Error("hex string expected, got "+typeof Q);const Y=Q.length;if(Y%2)throw new Error("padded hex string expected, got unpadded hex of length "+Y);const J=new Uint8Array(Y/2);for(let X=0;X<J.length;X++){const q=X*2,G=Q.slice(q,q+2),U=Number.parseInt(G,16);if(Number.isNaN(U)||U<0)throw new Error("Invalid byte sequence");J[X]=U}return J}function j8(Q){return sJ(o8(Q))}function oQ(Q){if(!iQ(Q))throw new Error("Uint8Array expected");return sJ(o8(Uint8Array.from(Q).reverse()))}function x8(Q,Y){return r8(Q.toString(16).padStart(Y*2,"0"))}function rQ(Q,Y){return x8(Q,Y).reverse()}function e1(Q){return r8(FX(Q))}function A0(Q,Y,J){let X;if(typeof Y==="string")try{X=r8(Y)}catch(G){throw new Error(`${Q} must be valid hex string, got "${Y}". Cause: ${G}`)}else if(iQ(Y))X=Uint8Array.from(Y);else throw new Error(`${Q} must be hex string or Uint8Array`);const q=X.length;if(typeof J==="number"&&q!==J)throw new Error(`${Q} expected ${J} bytes, got ${q}`);return X}function T9(...Q){const Y=new Uint8Array(Q.reduce((X,q)=>X+q.length,0));let J=0;return Q.forEach((X)=>{if(!iQ(X))throw new Error("Uint8Array expected");Y.set(X,J),J+=X.length}),Y}function QG(Q,Y){if(Q.length!==Y.length)return!1;for(let J=0;J<Q.length;J++)if(Q[J]!==Y[J])return!1;return!0}function JG(Q){if(typeof Q!=="string")throw new Error(`utf8ToBytes expected string, got ${typeof Q}`);return new Uint8Array((new TextEncoder()).encode(Q))}function YG(Q){let Y;for(Y=0;Q>wX;Q>>=nQ,Y+=1);return Y}function XG(Q,Y){return Q>>BigInt(Y)&nQ}function tJ(Q,Y,J){if(typeof Q!=="number"||Q<2)throw new Error("hashLen must be a number");if(typeof Y!=="number"||Y<2)throw new Error("qByteLen must be a number");if(typeof J!=="function")throw new Error("hmacFn must be a function");let X=aJ(Q),q=aJ(Q),G=0;const U=()=>{X.fill(1),q.fill(0),G=0},W=(...M)=>J(q,X,...M),$=(M=aJ())=>{if(q=W(NX([0]),M),X=W(),M.length===0)return;q=W(NX([1]),M),X=W()},V=()=>{if(G++>=1000)throw new Error("drbg: tried 1000 values");let M=0;const K=[];while(M<Y){X=W();const j=X.slice();K.push(j),M+=X.length}return T9(...K)};return(M,K)=>{U(),$(M);let j=void 0;while(!(j=K(V())))$();return U(),j}}function f8(Q,Y,J={}){const X=(q,G,U)=>{const W=GG[G];if(typeof W!=="function")throw new Error(`Invalid validator "${G}", expected function`);const $=Q[q];if(U&&$===void 0)return;if(!W($,Q))throw new Error(`Invalid param ${String(q)}=${$} (${typeof $}), expected ${G}`)};for(let[q,G]of Object.entries(Y))X(q,G,!1);for(let[q,G]of Object.entries(J))X(q,G,!0);return Q}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */var wX=BigInt(0),nQ=BigInt(1),s1=BigInt(2),iQ=(Q)=>Q instanceof Uint8Array,t1=Array.from({length:256},(Q,Y)=>Y.toString(16).padStart(2,"0")),qG=(Q,Y,J)=>{return Q|(J?nQ:wX)<<BigInt(Y)},n9=(Q)=>(s1<<BigInt(Q-1))-nQ,aJ=(Q)=>new Uint8Array(Q),NX=(Q)=>Uint8Array.from(Q),GG={bigint:(Q)=>typeof Q==="bigint",function:(Q)=>typeof Q==="function",boolean:(Q)=>typeof Q==="boolean",string:(Q)=>typeof Q==="string",stringOrUint8Array:(Q)=>typeof Q==="string"||Q instanceof Uint8Array,isSafeInteger:(Q)=>Number.isSafeInteger(Q),array:(Q)=>Array.isArray(Q),field:(Q,Y)=>Y.Fp.isValid(Q),hash:(Q)=>typeof Q==="function"&&Number.isSafeInteger(Q.outputLen)};function R0(Q,Y){const J=Q%Y;return J>=V0?J:Y+J}function $G(Q,Y,J){if(J<=V0||Y<V0)throw new Error("Expected power/modulo > 0");if(J===X0)return V0;let X=X0;while(Y>V0){if(Y&X0)X=X*Q%J;Q=Q*Q%J,Y>>=X0}return X}function k0(Q,Y,J){let X=Q;while(Y-- >V0)X*=X,X%=J;return X}function aQ(Q,Y){if(Q===V0||Y<=V0)throw new Error(`invert: expected positive integers, got n=${Q} mod=${Y}`);let J=R0(Q,Y),X=Y,q=V0,G=X0,U=X0,W=V0;while(J!==V0){const V=X/J,z=X%J,M=q-U*V,K=G-W*V;X=J,J=z,q=U,G=W,U=M,W=K}if(X!==X0)throw new Error("invert: does not exist");return R0(q,Y)}function zG(Q){const Y=(Q-X0)/a8;let J,X,q;for(J=Q-X0,X=0;J%a8===V0;J/=a8,X++);for(q=a8;q<Q&&$G(q,Y,Q)!==Q-X0;q++);if(X===1){const U=(Q+X0)/Q5;return function W($,V){const z=$.pow(V,U);if(!$.eql($.sqr(z),V))throw new Error("Cannot find square root");return z}}const G=(J+X0)/a8;return function U(W,$){if(W.pow($,Y)===W.neg(W.ONE))throw new Error("Cannot find square root");let V=X,z=W.pow(W.mul(W.ONE,q),J),M=W.pow($,G),K=W.pow($,J);while(!W.eql(K,W.ONE)){if(W.eql(K,W.ZERO))return W.ZERO;let j=1;for(let D=W.sqr(K);j<V;j++){if(W.eql(D,W.ONE))break;D=W.sqr(D)}const Z=W.pow(z,X0<<BigInt(V-j-1));z=W.sqr(Z),M=W.mul(M,Z),K=W.mul(K,z),V=j}return M}}function ZG(Q){if(Q%Q5===UG){const Y=(Q+X0)/Q5;return function J(X,q){const G=X.pow(q,Y);if(!X.eql(X.sqr(G),q))throw new Error("Cannot find square root");return G}}if(Q%EX===BX){const Y=(Q-BX)/EX;return function J(X,q){const G=X.mul(q,a8),U=X.pow(G,Y),W=X.mul(q,U),$=X.mul(X.mul(W,a8),U),V=X.mul(W,X.sub($,X.ONE));if(!X.eql(X.sqr(V),q))throw new Error("Cannot find square root");return V}}if(Q%VG===WG);return zG(Q)}function J5(Q){const Y={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},J=MG.reduce((X,q)=>{return X[q]="function",X},Y);return f8(Q,J)}function KG(Q,Y,J){if(J<V0)throw new Error("Expected power > 0");if(J===V0)return Q.ONE;if(J===X0)return Y;let X=Q.ONE,q=Y;while(J>V0){if(J&X0)X=Q.mul(X,q);q=Q.sqr(q),J>>=X0}return X}function jG(Q,Y){const J=new Array(Y.length),X=Y.reduce((G,U,W)=>{if(Q.is0(U))return G;return J[W]=G,Q.mul(G,U)},Q.ONE),q=Q.inv(X);return Y.reduceRight((G,U,W)=>{if(Q.is0(U))return G;return J[W]=Q.mul(G,J[W]),Q.mul(G,U)},q),J}function Y5(Q,Y){const J=Y!==void 0?Y:Q.toString(2).length,X=Math.ceil(J/8);return{nBitLength:J,nByteLength:X}}function SX(Q,Y,J=!1,X={}){if(Q<=V0)throw new Error(`Expected Field ORDER > 0, got ${Q}`);const{nBitLength:q,nByteLength:G}=Y5(Q,Y);if(G>2048)throw new Error("Field lengths over 2048 bytes are not supported");const U=ZG(Q),W=Object.freeze({ORDER:Q,BITS:q,BYTES:G,MASK:n9(q),ZERO:V0,ONE:X0,create:($)=>R0($,Q),isValid:($)=>{if(typeof $!=="bigint")throw new Error(`Invalid field element: expected bigint, got ${typeof $}`);return V0<=$&&$<Q},is0:($)=>$===V0,isOdd:($)=>($&X0)===X0,neg:($)=>R0(-$,Q),eql:($,V)=>$===V,sqr:($)=>R0($*$,Q),add:($,V)=>R0($+V,Q),sub:($,V)=>R0($-V,Q),mul:($,V)=>R0($*V,Q),pow:($,V)=>KG(W,$,V),div:($,V)=>R0($*aQ(V,Q),Q),sqrN:($)=>$*$,addN:($,V)=>$+V,subN:($,V)=>$-V,mulN:($,V)=>$*V,inv:($)=>aQ($,Q),sqrt:X.sqrt||(($)=>U(W,$)),invertBatch:($)=>jG(W,$),cmov:($,V,z)=>z?V:$,toBytes:($)=>J?rQ($,G):x8($,G),fromBytes:($)=>{if($.length!==G)throw new Error(`Fp.fromBytes: expected ${G}, got ${$.length}`);return J?oQ($):j8($)}});return Object.freeze(W)}function AX(Q){if(typeof Q!=="bigint")throw new Error("field order must be bigint");const Y=Q.toString(2).length;return Math.ceil(Y/8)}function X5(Q){const Y=AX(Q);return Y+Math.ceil(Y/2)}function kX(Q,Y,J=!1){const X=Q.length,q=AX(Y),G=X5(Y);if(X<16||X<G||X>1024)throw new Error(`expected ${G}-1024 bytes of input, got ${X}`);const U=J?j8(Q):oQ(Q),W=R0(U,Y-X0)+X0;return J?rQ(W,q):x8(W,q)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */var V0=BigInt(0),X0=BigInt(1),a8=BigInt(2),UG=BigInt(3),Q5=BigInt(4),BX=BigInt(5),EX=BigInt(8),WG=BigInt(9),VG=BigInt(16);var MG=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function xX(Q,Y){const J=(q,G)=>{const U=G.negate();return q?U:G},X=(q)=>{const G=Math.ceil(Y/q)+1,U=2**(q-1);return{windows:G,windowSize:U}};return{constTimeNegate:J,unsafeLadder(q,G){let U=Q.ZERO,W=q;while(G>DG){if(G&q5)U=U.add(W);W=W.double(),G>>=q5}return U},precomputeWindow(q,G){const{windows:U,windowSize:W}=X(G),$=[];let V=q,z=V;for(let M=0;M<U;M++){z=V,$.push(z);for(let K=1;K<W;K++)z=z.add(V),$.push(z);V=z.double()}return $},wNAF(q,G,U){const{windows:W,windowSize:$}=X(q);let{ZERO:V,BASE:z}=Q;const M=BigInt(2**q-1),K=2**q,j=BigInt(q);for(let Z=0;Z<W;Z++){const D=Z*$;let I=Number(U&M);if(U>>=j,I>$)I-=K,U+=q5;const L=D,R=D+Math.abs(I)-1,F=Z%2!==0,H=I<0;if(I===0)z=z.add(J(F,G[L]));else V=V.add(J(H,G[R]))}return{p:V,f:z}},wNAFCached(q,G,U,W){const $=q._WINDOW_SIZE||1;let V=G.get(q);if(!V){if(V=this.precomputeWindow(q,$),$!==1)G.set(q,W(V))}return this.wNAF($,V,U)}}}function G5(Q){return J5(Q.Fp),f8(Q,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...Y5(Q.n,Q.nBitLength),...Q,...{p:Q.Fp.ORDER}})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */var DG=BigInt(0),q5=BigInt(1);var IG=function(Q){const Y=G5(Q);f8(Y,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});const{endo:J,Fp:X,a:q}=Y;if(J){if(!X.eql(q,X.ZERO))throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");if(typeof J!=="object"||typeof J.beta!=="bigint"||typeof J.splitScalar!=="function")throw new Error("Expected endomorphism with beta: bigint and splitScalar: function")}return Object.freeze({...Y})};function RG(Q){const Y=IG(Q),{Fp:J}=Y,X=Y.toBytes||((Z,D,I)=>{const L=D.toAffine();return T9(Uint8Array.from([4]),J.toBytes(L.x),J.toBytes(L.y))}),q=Y.fromBytes||((Z)=>{const D=Z.subarray(1),I=J.fromBytes(D.subarray(0,J.BYTES)),L=J.fromBytes(D.subarray(J.BYTES,2*J.BYTES));return{x:I,y:L}});function G(Z){const{a:D,b:I}=Y,L=J.sqr(Z),R=J.mul(L,Z);return J.add(J.add(R,J.mul(Z,D)),I)}if(!J.eql(J.sqr(Y.Gy),G(Y.Gx)))throw new Error("bad generator point: equation left != right");function U(Z){return typeof Z==="bigint"&&O8<Z&&Z<Y.n}function W(Z){if(!U(Z))throw new Error("Expected valid bigint: 0 < bigint < curve.n")}function $(Z){const{allowedPrivateKeyLengths:D,nByteLength:I,wrapPrivateKey:L,n:R}=Y;if(D&&typeof Z!=="bigint"){if(Z instanceof Uint8Array)Z=o8(Z);if(typeof Z!=="string"||!D.includes(Z.length))throw new Error("Invalid key");Z=Z.padStart(I*2,"0")}let F;try{F=typeof Z==="bigint"?Z:j8(A0("private key",Z,I))}catch(H){throw new Error(`private key must be ${I} bytes, hex or bigint, not ${typeof Z}`)}if(L)F=R0(F,R);return W(F),F}const V=new Map;function z(Z){if(!(Z instanceof M))throw new Error("ProjectivePoint expected")}class M{constructor(Z,D,I){if(this.px=Z,this.py=D,this.pz=I,Z==null||!J.isValid(Z))throw new Error("x required");if(D==null||!J.isValid(D))throw new Error("y required");if(I==null||!J.isValid(I))throw new Error("z required")}static fromAffine(Z){const{x:D,y:I}=Z||{};if(!Z||!J.isValid(D)||!J.isValid(I))throw new Error("invalid affine point");if(Z instanceof M)throw new Error("projective point not allowed");const L=(R)=>J.eql(R,J.ZERO);if(L(D)&&L(I))return M.ZERO;return new M(D,I,J.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(Z){const D=J.invertBatch(Z.map((I)=>I.pz));return Z.map((I,L)=>I.toAffine(D[L])).map(M.fromAffine)}static fromHex(Z){const D=M.fromAffine(q(A0("pointHex",Z)));return D.assertValidity(),D}static fromPrivateKey(Z){return M.BASE.multiply($(Z))}_setWindowSize(Z){this._WINDOW_SIZE=Z,V.delete(this)}assertValidity(){if(this.is0()){if(Y.allowInfinityPoint&&!J.is0(this.py))return;throw new Error("bad point: ZERO")}const{x:Z,y:D}=this.toAffine();if(!J.isValid(Z)||!J.isValid(D))throw new Error("bad point: x or y not FE");const I=J.sqr(D),L=G(Z);if(!J.eql(I,L))throw new Error("bad point: equation left != right");if(!this.isTorsionFree())throw new Error("bad point: not in prime-order subgroup")}hasEvenY(){const{y:Z}=this.toAffine();if(J.isOdd)return!J.isOdd(Z);throw new Error("Field doesn't support isOdd")}equals(Z){z(Z);const{px:D,py:I,pz:L}=this,{px:R,py:F,pz:H}=Z,C=J.eql(J.mul(D,H),J.mul(R,L)),E=J.eql(J.mul(I,H),J.mul(F,L));return C&&E}negate(){return new M(this.px,J.neg(this.py),this.pz)}double(){const{a:Z,b:D}=Y,I=J.mul(D,fX),{px:L,py:R,pz:F}=this;let{ZERO:H,ZERO:C,ZERO:E}=J,P=J.mul(L,L),f=J.mul(R,R),S=J.mul(F,F),B=J.mul(L,R);return B=J.add(B,B),E=J.mul(L,F),E=J.add(E,E),H=J.mul(Z,E),C=J.mul(I,S),C=J.add(H,C),H=J.sub(f,C),C=J.add(f,C),C=J.mul(H,C),H=J.mul(B,H),E=J.mul(I,E),S=J.mul(Z,S),B=J.sub(P,S),B=J.mul(Z,B),B=J.add(B,E),E=J.add(P,P),P=J.add(E,P),P=J.add(P,S),P=J.mul(P,B),C=J.add(C,P),S=J.mul(R,F),S=J.add(S,S),P=J.mul(S,B),H=J.sub(H,P),E=J.mul(S,f),E=J.add(E,E),E=J.add(E,E),new M(H,C,E)}add(Z){z(Z);const{px:D,py:I,pz:L}=this,{px:R,py:F,pz:H}=Z;let{ZERO:C,ZERO:E,ZERO:P}=J;const f=Y.a,S=J.mul(Y.b,fX);let B=J.mul(D,R),A=J.mul(I,F),c=J.mul(L,H),G0=J.add(D,I),p=J.add(R,F);G0=J.mul(G0,p),p=J.add(B,A),G0=J.sub(G0,p),p=J.add(D,L);let w=J.add(R,H);return p=J.mul(p,w),w=J.add(B,c),p=J.sub(p,w),w=J.add(I,L),C=J.add(F,H),w=J.mul(w,C),C=J.add(A,c),w=J.sub(w,C),P=J.mul(f,p),C=J.mul(S,c),P=J.add(C,P),C=J.sub(A,P),P=J.add(A,P),E=J.mul(C,P),A=J.add(B,B),A=J.add(A,B),c=J.mul(f,c),p=J.mul(S,p),A=J.add(A,c),c=J.sub(B,c),c=J.mul(f,c),p=J.add(p,c),B=J.mul(A,p),E=J.add(E,B),B=J.mul(w,p),C=J.mul(G0,C),C=J.sub(C,B),B=J.mul(G0,A),P=J.mul(w,P),P=J.add(P,B),new M(C,E,P)}subtract(Z){return this.add(Z.negate())}is0(){return this.equals(M.ZERO)}wNAF(Z){return j.wNAFCached(this,V,Z,(D)=>{const I=J.invertBatch(D.map((L)=>L.pz));return D.map((L,R)=>L.toAffine(I[R])).map(M.fromAffine)})}multiplyUnsafe(Z){const D=M.ZERO;if(Z===O8)return D;if(W(Z),Z===v0)return this;const{endo:I}=Y;if(!I)return j.unsafeLadder(this,Z);let{k1neg:L,k1:R,k2neg:F,k2:H}=I.splitScalar(Z),C=D,E=D,P=this;while(R>O8||H>O8){if(R&v0)C=C.add(P);if(H&v0)E=E.add(P);P=P.double(),R>>=v0,H>>=v0}if(L)C=C.negate();if(F)E=E.negate();return E=new M(J.mul(E.px,I.beta),E.py,E.pz),C.add(E)}multiply(Z){W(Z);let D=Z,I,L;const{endo:R}=Y;if(R){const{k1neg:F,k1:H,k2neg:C,k2:E}=R.splitScalar(D);let{p:P,f}=this.wNAF(H),{p:S,f:B}=this.wNAF(E);P=j.constTimeNegate(F,P),S=j.constTimeNegate(C,S),S=new M(J.mul(S.px,R.beta),S.py,S.pz),I=P.add(S),L=f.add(B)}else{const{p:F,f:H}=this.wNAF(D);I=F,L=H}return M.normalizeZ([I,L])[0]}multiplyAndAddUnsafe(Z,D,I){const L=M.BASE,R=(H,C)=>C===O8||C===v0||!H.equals(L)?H.multiplyUnsafe(C):H.multiply(C),F=R(this,D).add(R(Z,I));return F.is0()?void 0:F}toAffine(Z){const{px:D,py:I,pz:L}=this,R=this.is0();if(Z==null)Z=R?J.ONE:J.inv(L);const F=J.mul(D,Z),H=J.mul(I,Z),C=J.mul(L,Z);if(R)return{x:J.ZERO,y:J.ZERO};if(!J.eql(C,J.ONE))throw new Error("invZ was invalid");return{x:F,y:H}}isTorsionFree(){const{h:Z,isTorsionFree:D}=Y;if(Z===v0)return!0;if(D)return D(M,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:Z,clearCofactor:D}=Y;if(Z===v0)return this;if(D)return D(M,this);return this.multiplyUnsafe(Y.h)}toRawBytes(Z=!0){return this.assertValidity(),X(M,this,Z)}toHex(Z=!0){return o8(this.toRawBytes(Z))}}M.BASE=new M(Y.Gx,Y.Gy,J.ONE),M.ZERO=new M(J.ZERO,J.ONE,J.ZERO);const K=Y.nBitLength,j=xX(M,Y.endo?Math.ceil(K/2):K);return{CURVE:Y,ProjectivePoint:M,normPrivateKeyToScalar:$,weierstrassEquation:G,isWithinCurveOrder:U}}var PG=function(Q){const Y=G5(Q);return f8(Y,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...Y})};function bX(Q){const Y=PG(Q),{Fp:J,n:X}=Y,q=J.BYTES+1,G=2*J.BYTES+1;function U(w){return O8<w&&w<J.ORDER}function W(w){return R0(w,X)}function $(w){return aQ(w,X)}const{ProjectivePoint:V,normPrivateKeyToScalar:z,weierstrassEquation:M,isWithinCurveOrder:K}=RG({...Y,toBytes(w,b,g){const u=b.toAffine(),l=J.toBytes(u.x),r=T9;if(g)return r(Uint8Array.from([b.hasEvenY()?2:3]),l);else return r(Uint8Array.from([4]),l,J.toBytes(u.y))},fromBytes(w){const b=w.length,g=w[0],u=w.subarray(1);if(b===q&&(g===2||g===3)){const l=j8(u);if(!U(l))throw new Error("Point is not on curve");const r=M(l);let U0=J.sqrt(r);const I0=(U0&v0)===v0;if((g&1)===1!==I0)U0=J.neg(U0);return{x:l,y:U0}}else if(b===G&&g===4){const l=J.fromBytes(u.subarray(0,J.BYTES)),r=J.fromBytes(u.subarray(J.BYTES,2*J.BYTES));return{x:l,y:r}}else throw new Error(`Point of length ${b} was invalid. Expected ${q} compressed bytes or ${G} uncompressed bytes`)}}),j=(w)=>o8(x8(w,Y.nByteLength));function Z(w){const b=X>>v0;return w>b}function D(w){return Z(w)?W(-w):w}const I=(w,b,g)=>j8(w.slice(b,g));class L{constructor(w,b,g){this.r=w,this.s=b,this.recovery=g,this.assertValidity()}static fromCompact(w){const b=Y.nByteLength;return w=A0("compactSignature",w,b*2),new L(I(w,0,b),I(w,b,2*b))}static fromDER(w){const{r:b,s:g}=s8.toSig(A0("DER",w));return new L(b,g)}assertValidity(){if(!K(this.r))throw new Error("r must be 0 < r < CURVE.n");if(!K(this.s))throw new Error("s must be 0 < s < CURVE.n")}addRecoveryBit(w){return new L(this.r,this.s,w)}recoverPublicKey(w){const{r:b,s:g,recovery:u}=this,l=P(A0("msgHash",w));if(u==null||![0,1,2,3].includes(u))throw new Error("recovery id invalid");const r=u===2||u===3?b+Y.n:b;if(r>=J.ORDER)throw new Error("recovery id 2 or 3 invalid");const U0=(u&1)===0?"02":"03",I0=V.fromHex(U0+j(r)),G8=$(r),c8=W(-l*G8),M9=W(g*G8),p8=V.BASE.multiplyAndAddUnsafe(I0,c8,M9);if(!p8)throw new Error("point at infinify");return p8.assertValidity(),p8}hasHighS(){return Z(this.s)}normalizeS(){return this.hasHighS()?new L(this.r,W(-this.s),this.recovery):this}toDERRawBytes(){return r8(this.toDERHex())}toDERHex(){return s8.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return r8(this.toCompactHex())}toCompactHex(){return j(this.r)+j(this.s)}}const R={isValidPrivateKey(w){try{return z(w),!0}catch(b){return!1}},normPrivateKeyToScalar:z,randomPrivateKey:()=>{const w=X5(Y.n);return kX(Y.randomBytes(w),Y.n)},precompute(w=8,b=V.BASE){return b._setWindowSize(w),b.multiply(BigInt(3)),b}};function F(w,b=!0){return V.fromPrivateKey(w).toRawBytes(b)}function H(w){const b=w instanceof Uint8Array,g=typeof w==="string",u=(b||g)&&w.length;if(b)return u===q||u===G;if(g)return u===2*q||u===2*G;if(w instanceof V)return!0;return!1}function C(w,b,g=!0){if(H(w))throw new Error("first arg must be private key");if(!H(b))throw new Error("second arg must be public key");return V.fromHex(b).multiply(z(w)).toRawBytes(g)}const E=Y.bits2int||function(w){const b=j8(w),g=w.length*8-Y.nBitLength;return g>0?b>>BigInt(g):b},P=Y.bits2int_modN||function(w){return W(E(w))},f=n9(Y.nBitLength);function S(w){if(typeof w!=="bigint")throw new Error("bigint expected");if(!(O8<=w&&w<f))throw new Error(`bigint expected < 2^${Y.nBitLength}`);return x8(w,Y.nByteLength)}function B(w,b,g=A){if(["recovered","canonical"].some((u8)=>(u8 in g)))throw new Error("sign() legacy options not supported");const{hash:u,randomBytes:l}=Y;let{lowS:r,prehash:U0,extraEntropy:I0}=g;if(r==null)r=!0;if(w=A0("msgHash",w),U0)w=A0("prehashed msgHash",u(w));const G8=P(w),c8=z(b),M9=[S(c8),S(G8)];if(I0!=null){const u8=I0===!0?l(J.BYTES):I0;M9.push(A0("extraEntropy",u8))}const p8=T9(...M9),NQ=G8;function vJ(u8){const K9=E(u8);if(!K(K9))return;const ZY=$(K9),o0=V.BASE.multiply(K9).toAffine(),j9=W(o0.x);if(j9===O8)return;const wQ=W(ZY*W(NQ+j9*c8));if(wQ===O8)return;let MY=(o0.x===j9?0:2)|Number(o0.y&v0),KY=wQ;if(r&&Z(wQ))KY=D(wQ),MY^=1;return new L(j9,KY,MY)}return{seed:p8,k2sig:vJ}}const A={lowS:Y.lowS,prehash:!1},c={lowS:Y.lowS,prehash:!1};function G0(w,b,g=A){const{seed:u,k2sig:l}=B(w,b,g),r=Y;return tJ(r.hash.outputLen,r.nByteLength,r.hmac)(u,l)}V.BASE._setWindowSize(8);function p(w,b,g,u=c){const l=w;if(b=A0("msgHash",b),g=A0("publicKey",g),("strict"in u))throw new Error("options.strict was renamed to lowS");const{lowS:r,prehash:U0}=u;let I0=void 0,G8;try{if(typeof l==="string"||l instanceof Uint8Array)try{I0=L.fromDER(l)}catch(o0){if(!(o0 instanceof s8.Err))throw o0;I0=L.fromCompact(l)}else if(typeof l==="object"&&typeof l.r==="bigint"&&typeof l.s==="bigint"){const{r:o0,s:j9}=l;I0=new L(o0,j9)}else throw new Error("PARSE");G8=V.fromHex(g)}catch(o0){if(o0.message==="PARSE")throw new Error("signature must be Signature instance, Uint8Array or hex string");return!1}if(r&&I0.hasHighS())return!1;if(U0)b=Y.hash(b);const{r:c8,s:M9}=I0,p8=P(b),NQ=$(M9),vJ=W(p8*NQ),u8=W(c8*NQ),K9=V.BASE.multiplyAndAddUnsafe(G8,vJ,u8)?.toAffine();if(!K9)return!1;return W(K9.x)===c8}return{CURVE:Y,getPublicKey:F,getSharedSecret:C,sign:G0,verify:p,ProjectivePoint:V,Signature:L,utils:R}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */var{bytesToNumberBE:LG,hexToBytes:HG}=eJ,s8={Err:class Q extends Error{constructor(Y=""){super(Y)}},_parseInt(Q){const{Err:Y}=s8;if(Q.length<2||Q[0]!==2)throw new Y("Invalid signature integer tag");const J=Q[1],X=Q.subarray(2,J+2);if(!J||X.length!==J)throw new Y("Invalid signature integer: wrong length");if(X[0]&128)throw new Y("Invalid signature integer: negative");if(X[0]===0&&!(X[1]&128))throw new Y("Invalid signature integer: unnecessary leading zero");return{d:LG(X),l:Q.subarray(J+2)}},toSig(Q){const{Err:Y}=s8,J=typeof Q==="string"?HG(Q):Q;if(!(J instanceof Uint8Array))throw new Error("ui8a expected");let X=J.length;if(X<2||J[0]!=48)throw new Y("Invalid signature tag");if(J[1]!==X-2)throw new Y("Invalid signature: incorrect length");const{d:q,l:G}=s8._parseInt(J.subarray(2)),{d:U,l:W}=s8._parseInt(G);if(W.length)throw new Y("Invalid signature: left bytes after parsing");return{r:q,s:U}},hexFromSig(Q){const Y=(V)=>Number.parseInt(V[0],16)&8?"00"+V:V,J=(V)=>{const z=V.toString(16);return z.length&1?`0${z}`:z},X=Y(J(Q.s)),q=Y(J(Q.r)),G=X.length/2,U=q.length/2,W=J(G),$=J(U);return`30${J(U+G+4)}02${$}${q}02${W}${X}`}},O8=BigInt(0),v0=BigInt(1),w$=BigInt(2),fX=BigInt(3),F$=BigInt(4);function CG(Q){return{hash:Q,hmac:(Y,...J)=>n8(Q,Y,wY(...J)),randomBytes:FY}}function vX(Q,Y){const J=(X)=>bX({...Q,...CG(X)});return Object.freeze({...J(Y),create:J})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */var NG=function(Q){const Y=hX,J=BigInt(3),X=BigInt(6),q=BigInt(11),G=BigInt(22),U=BigInt(23),W=BigInt(44),$=BigInt(88),V=Q*Q*Q%Y,z=V*V*Q%Y,M=k0(z,J,Y)*z%Y,K=k0(M,J,Y)*z%Y,j=k0(K,U5,Y)*V%Y,Z=k0(j,q,Y)*j%Y,D=k0(Z,G,Y)*Z%Y,I=k0(D,W,Y)*D%Y,L=k0(I,$,Y)*I%Y,R=k0(L,W,Y)*D%Y,F=k0(R,J,Y)*z%Y,H=k0(F,U,Y)*Z%Y,C=k0(H,X,Y)*V%Y,E=k0(C,U5,Y);if(!W5.eql(W5.sqr(E),Q))throw new Error("Cannot find square root");return E};/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */var hX=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),gX=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),TG=BigInt(1),U5=BigInt(2),yX=(Q,Y)=>(Q+Y/U5)/Y,W5=SX(hX,void 0,void 0,{sqrt:NG}),D8=vX({a:BigInt(0),b:BigInt(7),Fp:W5,n:gX,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:(Q)=>{const Y=gX,J=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),X=-TG*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),q=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),G=J,U=BigInt("0x100000000000000000000000000000000"),W=yX(G*Q,Y),$=yX(-X*Q,Y);let V=R0(Q-W*J-$*q,Y),z=R0(-W*X-$*G,Y);const M=V>U,K=z>U;if(M)V=Y-V;if(K)z=Y-z;if(V>U||z>U)throw new Error("splitScalar: Endomorphism failed, k="+Q);return{k1neg:M,k1:V,k2neg:K,k2:z}}}},$8),v$=BigInt(0);var g$=D8.ProjectivePoint;var V5="0x0000000000000000000000000000000000000000";var sQ="0x0000000000000000000000000000000000000000000000000000000000000000";var $5=`\x19Ethereum Signed Message:
`;var dX=function(Q){return E0(t(Q),32)},mX=BigInt(0),_X=BigInt(1),cX=BigInt(2),pX=BigInt(27),uX=BigInt(28),tQ=BigInt(35),N9={};class e{#Q;#J;#Y;#X;get r(){return this.#Q}set r(Q){O(W8(Q)===32,"invalid r","value",Q),this.#Q=T(Q)}get s(){return O(parseInt(this.#J.substring(0,3))<8,"non-canonical s; use ._s","s",this.#J),this.#J}set s(Q){O(W8(Q)===32,"invalid s","value",Q),this.#J=T(Q)}get _s(){return this.#J}isValid(){return parseInt(this.#J.substring(0,3))<8}get v(){return this.#Y}set v(Q){const Y=$0(Q,"value");O(Y===27||Y===28,"invalid v","v",Q),this.#Y=Y}get networkV(){return this.#X}get legacyChainId(){const Q=this.networkV;if(Q==null)return null;return e.getChainId(Q)}get yParity(){return this.v===27?0:1}get yParityAndS(){const Q=N(this.s);if(this.yParity)Q[0]|=128;return T(Q)}get compactSerialized(){return o([this.r,this.yParityAndS])}get serialized(){return o([this.r,this.s,this.yParity?"0x1c":"0x1b"])}constructor(Q,Y,J,X){U8(Q,N9,"Signature"),this.#Q=Y,this.#J=J,this.#Y=X,this.#X=null}[Symbol.for("nodejs.util.inspect.custom")](){return`Signature { r: "${this.r}", s: "${this._s}"${this.isValid()?"":', valid: "false"'}, yParity: ${this.yParity}, networkV: ${this.networkV} }`}clone(){const Q=new e(N9,this.r,this._s,this.v);if(this.networkV)Q.#X=this.networkV;return Q}toJSON(){const Q=this.networkV;return{_type:"signature",networkV:Q!=null?Q.toString():null,r:this.r,s:this._s,v:this.v}}static getChainId(Q){const Y=h(Q,"v");if(Y==pX||Y==uX)return mX;return O(Y>=tQ,"invalid EIP-155 v","v",Q),(Y-tQ)/cX}static getChainIdV(Q,Y){return h(Q)*cX+BigInt(35+Y-27)}static getNormalizedV(Q){const Y=h(Q);if(Y===mX||Y===pX)return 27;if(Y===_X||Y===uX)return 28;return O(Y>=tQ,"invalid v","v",Q),Y&_X?27:28}static from(Q){function Y($,V){O($,V,"signature",Q)}if(Q==null)return new e(N9,sQ,sQ,27);if(typeof Q==="string"){const $=N(Q,"signature");if($.length===64){const V=T($.slice(0,32)),z=$.slice(32,64),M=z[0]&128?28:27;return z[0]&=127,new e(N9,V,T(z),M)}if($.length===65){const V=T($.slice(0,32)),z=T($.slice(32,64)),M=e.getNormalizedV($[64]);return new e(N9,V,z,M)}Y(!1,"invalid raw signature length")}if(Q instanceof e)return Q.clone();const J=Q.r;Y(J!=null,"missing r");const X=dX(J),q=function($,V){if($!=null)return dX($);if(V!=null){Y(L0(V,32),"invalid yParityAndS");const z=N(V);return z[0]&=127,T(z)}Y(!1,"missing s")}(Q.s,Q.yParityAndS),{networkV:G,v:U}=function($,V,z){if($!=null){const M=h($);return{networkV:M>=tQ?M:void 0,v:e.getNormalizedV(M)}}if(V!=null)return Y(L0(V,32),"invalid yParityAndS"),{v:N(V)[0]&128?28:27};if(z!=null){switch($0(z,"sig.yParity")){case 0:return{v:27};case 1:return{v:28}}Y(!1,"invalid yParity")}Y(!1,"missing v")}(Q.v,Q.yParityAndS,Q.yParity),W=new e(N9,X,q,U);if(G)W.#X=G;return Y(Q.yParity==null||$0(Q.yParity,"sig.yParity")===W.yParity,"yParity mismatch"),Y(Q.yParityAndS==null||Q.yParityAndS===W.yParityAndS,"yParityAndS mismatch"),W}}class q0{#Q;constructor(Q){O(W8(Q)===32,"invalid private key","privateKey","[REDACTED]"),this.#Q=T(Q)}get privateKey(){return this.#Q}get publicKey(){return q0.computePublicKey(this.#Q)}get compressedPublicKey(){return q0.computePublicKey(this.#Q,!0)}sign(Q){O(W8(Q)===32,"invalid digest length","digest",Q);const Y=D8.sign(u0(Q),u0(this.#Q),{lowS:!0});return e.from({r:d0(Y.r,32),s:d0(Y.s,32),v:Y.recovery?28:27})}computeSharedSecret(Q){const Y=q0.computePublicKey(Q);return T(D8.getSharedSecret(u0(this.#Q),N(Y),!1))}static computePublicKey(Q,Y){let J=N(Q,"key");if(J.length===32){const q=D8.getPublicKey(J,!!Y);return T(q)}if(J.length===64){const q=new Uint8Array(65);q[0]=4,q.set(J,1),J=q}const X=D8.ProjectivePoint.fromHex(J);return T(X.toRawBytes(Y))}static recoverPublicKey(Q,Y){O(W8(Q)===32,"invalid digest length","digest",Q);const J=e.from(Y);let X=D8.Signature.fromCompact(u0(o([J.r,J.s])));X=X.addRecoveryBit(J.yParity);const q=X.recoverPublicKey(u0(Q));return O(q!=null,"invalid signature for digest","signature",Y),"0x"+q.toHex(!1)}static addPoints(Q,Y,J){const X=D8.ProjectivePoint.fromHex(q0.computePublicKey(Q).substring(2)),q=D8.ProjectivePoint.fromHex(q0.computePublicKey(Y).substring(2));return"0x"+X.add(q).toHex(!!J)}}var lX=function(Q){Q=Q.toLowerCase();const Y=Q.substring(2).split(""),J=new Uint8Array(40);for(let q=0;q<40;q++)J[q]=Y[q].charCodeAt(0);const X=N(n(J));for(let q=0;q<40;q+=2){if(X[q>>1]>>4>=8)Y[q]=Y[q].toUpperCase();if((X[q>>1]&15)>=8)Y[q+1]=Y[q+1].toUpperCase()}return"0x"+Y.join("")},BG=function(Q){Q=Q.toUpperCase(),Q=Q.substring(4)+Q.substring(0,2)+"00";let Y=Q.split("").map((X)=>{return z5[X]}).join("");while(Y.length>=nX){let X=Y.substring(0,nX);Y=parseInt(X,10)%97+Y.substring(X.length)}let J=String(98-parseInt(Y,10)%97);while(J.length<2)J="0"+J;return J},SG=function(Q){Q=Q.toLowerCase();let Y=wG;for(let J=0;J<Q.length;J++)Y=Y*FG+EG[Q[J]];return Y};function y(Q){if(O(typeof Q==="string","invalid address","address",Q),Q.match(/^(0x)?[0-9a-fA-F]{40}$/)){if(!Q.startsWith("0x"))Q="0x"+Q;const Y=lX(Q);return O(!Q.match(/([A-F].*[a-f])|([a-f].*[A-F])/)||Y===Q,"bad address checksum","address",Q),Y}if(Q.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)){O(Q.substring(2,4)===BG(Q),"bad icap checksum","address",Q);let Y=SG(Q.substring(4)).toString(16);while(Y.length<40)Y="0"+Y;return lX("0x"+Y)}O(!1,"invalid address","address",Q)}var wG=BigInt(0),FG=BigInt(36),z5={};for(let Q=0;Q<10;Q++)z5[String(Q)]=String(Q);for(let Q=0;Q<26;Q++)z5[String.fromCharCode(65+Q)]=String(10+Q);var nX=15,EG=function(){const Q={};for(let Y=0;Y<36;Y++){const J="0123456789abcdefghijklmnopqrstuvwxyz"[Y];Q[J]=BigInt(Y)}return Q}();function M5(Q){return Q&&typeof Q.getAddress==="function"}async function Z5(Q,Y){const J=await Y;if(J==null||J==="0x0000000000000000000000000000000000000000")x(typeof Q!=="string","unconfigured name","UNCONFIGURED_NAME",{value:Q}),O(!1,"invalid AddressLike value; did not resolve to a value address","target",Q);return y(J)}function I8(Q,Y){if(typeof Q==="string"){if(Q.match(/^0x[0-9a-f]{40}$/i))return y(Q);return x(Y!=null,"ENS resolution requires a provider","UNSUPPORTED_OPERATION",{operation:"resolveName"}),Z5(Q,Y.resolveName(Q))}else if(M5(Q))return Z5(Q,Q.getAddress());else if(Q&&typeof Q.then==="function")return Z5(Q,Q);O(!1,"unsupported addressable value","target",Q)}var K5=function(Q,Y){return{address:y(Q),storageKeys:Y.map((J,X)=>{return O(L0(J,32),"invalid slot",`storageKeys[${X}]`,J),J.toLowerCase()})}};function t8(Q){if(Array.isArray(Q))return Q.map((J,X)=>{if(Array.isArray(J))return O(J.length===2,"invalid slot set",`value[${X}]`,J),K5(J[0],J[1]);return O(J!=null&&typeof J==="object","invalid address-slot set","value",Q),K5(J.address,J.storageKeys)});O(Q!=null&&typeof Q==="object","invalid access list","value",Q);const Y=Object.keys(Q).map((J)=>{const X=Q[J].reduce((q,G)=>{return q[G]=!0,q},{});return K5(J,Object.keys(X).sort())});return Y.sort((J,X)=>J.address.localeCompare(X.address)),Y}function iX(Q){return{address:y(Q.address),nonce:h(Q.nonce!=null?Q.nonce:0),chainId:h(Q.chainId!=null?Q.chainId:0),signature:e.from(Q.signature)}}function L8(Q){let Y;if(typeof Q==="string")Y=q0.computePublicKey(Q,!1);else Y=Q.publicKey;return y(n("0x"+Y.substring(4)).substring(26))}function i9(Q,Y){return L8(q0.recoverPublicKey(Q,Y))}var yG=function(Q){return{blobToKzgCommitment:(X)=>{if("computeBlobProof"in Q){if(("blobToKzgCommitment"in Q)&&typeof Q.blobToKzgCommitment==="function")return N(Q.blobToKzgCommitment(T(X)))}else if(("blobToKzgCommitment"in Q)&&typeof Q.blobToKzgCommitment==="function")return N(Q.blobToKzgCommitment(X));if(("blobToKZGCommitment"in Q)&&typeof Q.blobToKZGCommitment==="function")return N(Q.blobToKZGCommitment(T(X)));O(!1,"unsupported KZG library","kzg",Q)},computeBlobKzgProof:(X,q)=>{if(("computeBlobProof"in Q)&&typeof Q.computeBlobProof==="function")return N(Q.computeBlobProof(T(X),T(q)));if(("computeBlobKzgProof"in Q)&&typeof Q.computeBlobKzgProof==="function")return Q.computeBlobKzgProof(X,q);if(("computeBlobKZGProof"in Q)&&typeof Q.computeBlobKZGProof==="function")return N(Q.computeBlobKZGProof(T(X),T(q)));O(!1,"unsupported KZG library","kzg",Q)}}},oX=function(Q,Y){let J=Q.toString(16);while(J.length<2)J="0"+J;return J+=j0(Y).substring(4),"0x"+J},w9=function(Q){if(Q==="0x")return null;return y(Q)},eQ=function(Q,Y){try{return t8(Q)}catch(J){O(!1,J.message,Y,Q)}},hG=function(Q,Y){try{if(!Array.isArray(Q))throw new Error("authorizationList: invalid array");const J=[];for(let X=0;X<Q.length;X++){const q=Q[X];if(!Array.isArray(q))throw new Error(`authorization[${X}]: invalid array`);if(q.length!==6)throw new Error(`authorization[${X}]: wrong length`);if(!q[1])throw new Error(`authorization[${X}]: null address`);J.push({address:w9(q[1]),nonce:a(q[2],"nonce"),chainId:a(q[0],"chainId"),signature:e.from({yParity:e8(q[3],"yParity"),r:E0(q[4],32),s:E0(q[5],32)})})}return J}catch(J){O(!1,J.message,Y,Q)}},e8=function(Q,Y){if(Q==="0x")return 0;return $0(Q,Y)},a=function(Q,Y){if(Q==="0x")return Z0;const J=h(Q,Y);return O(J<=gG,"value exceeds uint size",Y,J),J},m=function(Q,Y){const J=h(Q,"value"),X=t(J);return O(X.length<=32,"value too large",`tx.${Y}`,J),X},QJ=function(Q){return t8(Q).map((Y)=>[Y.address,Y.storageKeys])},mG=function(Q){return Q.map((Y)=>{return[m(Y.chainId,"chainId"),Y.address,m(Y.nonce,"nonce"),m(Y.signature.yParity,"yParity"),t(Y.signature.r),t(Y.signature.s)]})},_G=function(Q,Y){O(Array.isArray(Q),`invalid ${Y}`,"value",Q);for(let J=0;J<Q.length;J++)O(L0(Q[J],32),"invalid ${ param } hash",`value[${J}]`,Q[J]);return Q},cG=function(Q){const Y=F8(Q);O(Array.isArray(Y)&&(Y.length===9||Y.length===6),"invalid field count for legacy transaction","data",Q);const J={type:0,nonce:e8(Y[0],"nonce"),gasPrice:a(Y[1],"gasPrice"),gasLimit:a(Y[2],"gasLimit"),to:w9(Y[3]),value:a(Y[4],"value"),data:T(Y[5]),chainId:Z0};if(Y.length===6)return J;const X=a(Y[6],"v"),q=a(Y[7],"r"),G=a(Y[8],"s");if(q===Z0&&G===Z0)J.chainId=X;else{let U=(X-vG)/xG;if(U<Z0)U=Z0;J.chainId=U,O(U!==Z0||(X===fG||X===bG),"non-canonical legacy v","v",Y[6]),J.signature=e.from({r:E0(Y[7],32),s:E0(Y[8],32),v:X})}return J},pG=function(Q,Y){const J=[m(Q.nonce,"nonce"),m(Q.gasPrice||0,"gasPrice"),m(Q.gasLimit,"gasLimit"),Q.to||"0x",m(Q.value,"value"),Q.data];let X=Z0;if(Q.chainId!=Z0)X=h(Q.chainId,"tx.chainId"),O(!Y||Y.networkV==null||Y.legacyChainId===X,"tx.chainId/sig.v mismatch","sig",Y);else if(Q.signature){const G=Q.signature.legacyChainId;if(G!=null)X=G}if(!Y){if(X!==Z0)J.push(t(X)),J.push("0x"),J.push("0x");return b0(J)}let q=BigInt(27+Y.yParity);if(X!==Z0)q=e.getChainIdV(X,Y.v);else if(BigInt(Y.v)!==q)O(!1,"tx.chainId/sig.v mismatch","sig",Y);return J.push(t(q)),J.push(t(Y.r)),J.push(t(Y.s)),b0(J)},JJ=function(Q,Y){let J;try{if(J=e8(Y[0],"yParity"),J!==0&&J!==1)throw new Error("bad yParity")}catch(U){O(!1,"invalid yParity","yParity",Y[0])}const X=E0(Y[1],32),q=E0(Y[2],32),G=e.from({r:X,s:q,yParity:J});Q.signature=G},uG=function(Q){const Y=F8(N(Q).slice(1));O(Array.isArray(Y)&&(Y.length===9||Y.length===12),"invalid field count for transaction type: 2","data",T(Q));const J={type:2,chainId:a(Y[0],"chainId"),nonce:e8(Y[1],"nonce"),maxPriorityFeePerGas:a(Y[2],"maxPriorityFeePerGas"),maxFeePerGas:a(Y[3],"maxFeePerGas"),gasPrice:null,gasLimit:a(Y[4],"gasLimit"),to:w9(Y[5]),value:a(Y[6],"value"),data:T(Y[7]),accessList:eQ(Y[8],"accessList")};if(Y.length===9)return J;return JJ(J,Y.slice(9)),J},dG=function(Q,Y){const J=[m(Q.chainId,"chainId"),m(Q.nonce,"nonce"),m(Q.maxPriorityFeePerGas||0,"maxPriorityFeePerGas"),m(Q.maxFeePerGas||0,"maxFeePerGas"),m(Q.gasLimit,"gasLimit"),Q.to||"0x",m(Q.value,"value"),Q.data,QJ(Q.accessList||[])];if(Y)J.push(m(Y.yParity,"yParity")),J.push(t(Y.r)),J.push(t(Y.s));return o(["0x02",b0(J)])},lG=function(Q){const Y=F8(N(Q).slice(1));O(Array.isArray(Y)&&(Y.length===8||Y.length===11),"invalid field count for transaction type: 1","data",T(Q));const J={type:1,chainId:a(Y[0],"chainId"),nonce:e8(Y[1],"nonce"),gasPrice:a(Y[2],"gasPrice"),gasLimit:a(Y[3],"gasLimit"),to:w9(Y[4]),value:a(Y[5],"value"),data:T(Y[6]),accessList:eQ(Y[7],"accessList")};if(Y.length===8)return J;return JJ(J,Y.slice(8)),J},nG=function(Q,Y){const J=[m(Q.chainId,"chainId"),m(Q.nonce,"nonce"),m(Q.gasPrice||0,"gasPrice"),m(Q.gasLimit,"gasLimit"),Q.to||"0x",m(Q.value,"value"),Q.data,QJ(Q.accessList||[])];if(Y)J.push(m(Y.yParity,"recoveryParam")),J.push(t(Y.r)),J.push(t(Y.s));return o(["0x01",b0(J)])},iG=function(Q){let Y=F8(N(Q).slice(1)),J="3",X=null;if(Y.length===4&&Array.isArray(Y[0])){J="3 (network format)";const G=Y[1],U=Y[2],W=Y[3];O(Array.isArray(G),"invalid network format: blobs not an array","fields[1]",G),O(Array.isArray(U),"invalid network format: commitments not an array","fields[2]",U),O(Array.isArray(W),"invalid network format: proofs not an array","fields[3]",W),O(G.length===U.length,"invalid network format: blobs/commitments length mismatch","fields",Y),O(G.length===W.length,"invalid network format: blobs/proofs length mismatch","fields",Y),X=[];for(let $=0;$<Y[1].length;$++)X.push({data:G[$],commitment:U[$],proof:W[$]});Y=Y[0]}O(Array.isArray(Y)&&(Y.length===11||Y.length===14),`invalid field count for transaction type: ${J}`,"data",T(Q));const q={type:3,chainId:a(Y[0],"chainId"),nonce:e8(Y[1],"nonce"),maxPriorityFeePerGas:a(Y[2],"maxPriorityFeePerGas"),maxFeePerGas:a(Y[3],"maxFeePerGas"),gasPrice:null,gasLimit:a(Y[4],"gasLimit"),to:w9(Y[5]),value:a(Y[6],"value"),data:T(Y[7]),accessList:eQ(Y[8],"accessList"),maxFeePerBlobGas:a(Y[9],"maxFeePerBlobGas"),blobVersionedHashes:Y[10]};if(X)q.blobs=X;O(q.to!=null,`invalid address for transaction type: ${J}`,"data",Q),O(Array.isArray(q.blobVersionedHashes),"invalid blobVersionedHashes: must be an array","data",Q);for(let G=0;G<q.blobVersionedHashes.length;G++)O(L0(q.blobVersionedHashes[G],32),`invalid blobVersionedHash at index ${G}: must be length 32`,"data",Q);if(Y.length===11)return q;return JJ(q,Y.slice(11)),q},oG=function(Q,Y,J){const X=[m(Q.chainId,"chainId"),m(Q.nonce,"nonce"),m(Q.maxPriorityFeePerGas||0,"maxPriorityFeePerGas"),m(Q.maxFeePerGas||0,"maxFeePerGas"),m(Q.gasLimit,"gasLimit"),Q.to||V5,m(Q.value,"value"),Q.data,QJ(Q.accessList||[]),m(Q.maxFeePerBlobGas||0,"maxFeePerBlobGas"),_G(Q.blobVersionedHashes||[],"blobVersionedHashes")];if(Y){if(X.push(m(Y.yParity,"yParity")),X.push(t(Y.r)),X.push(t(Y.s)),J)return o(["0x03",b0([X,J.map((q)=>q.data),J.map((q)=>q.commitment),J.map((q)=>q.proof)])])}return o(["0x03",b0(X)])},rG=function(Q){const Y=F8(N(Q).slice(1));O(Array.isArray(Y)&&(Y.length===10||Y.length===13),"invalid field count for transaction type: 4","data",T(Q));const J={type:4,chainId:a(Y[0],"chainId"),nonce:e8(Y[1],"nonce"),maxPriorityFeePerGas:a(Y[2],"maxPriorityFeePerGas"),maxFeePerGas:a(Y[3],"maxFeePerGas"),gasPrice:null,gasLimit:a(Y[4],"gasLimit"),to:w9(Y[5]),value:a(Y[6],"value"),data:T(Y[7]),accessList:eQ(Y[8],"accessList"),authorizationList:hG(Y[9],"authorizationList")};if(Y.length===10)return J;return JJ(J,Y.slice(10)),J},aG=function(Q,Y){const J=[m(Q.chainId,"chainId"),m(Q.nonce,"nonce"),m(Q.maxPriorityFeePerGas||0,"maxPriorityFeePerGas"),m(Q.maxFeePerGas||0,"maxFeePerGas"),m(Q.gasLimit,"gasLimit"),Q.to||"0x",m(Q.value,"value"),Q.data,QJ(Q.accessList||[]),mG(Q.authorizationList||[])];if(Y)J.push(m(Y.yParity,"yParity")),J.push(t(Y.r)),J.push(t(Y.s));return o(["0x04",b0(J)])},Z0=BigInt(0),xG=BigInt(2),fG=BigInt(27),bG=BigInt(28),vG=BigInt(35),gG=BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"),j5=131072;class T0{#Q;#J;#Y;#X;#V;#$;#z;#Z;#M;#K;#j;#O;#W;#G;#q;#U;#D;get type(){return this.#Q}set type(Q){switch(Q){case null:this.#Q=null;break;case 0:case"legacy":this.#Q=0;break;case 1:case"berlin":case"eip-2930":this.#Q=1;break;case 2:case"london":case"eip-1559":this.#Q=2;break;case 3:case"cancun":case"eip-4844":this.#Q=3;break;case 4:case"pectra":case"eip-7702":this.#Q=4;break;default:O(!1,"unsupported transaction type","type",Q)}}get typeName(){switch(this.type){case 0:return"legacy";case 1:return"eip-2930";case 2:return"eip-1559";case 3:return"eip-4844";case 4:return"eip-7702"}return null}get to(){const Q=this.#J;if(Q==null&&this.type===3)return V5;return Q}set to(Q){this.#J=Q==null?null:y(Q)}get nonce(){return this.#X}set nonce(Q){this.#X=$0(Q,"value")}get gasLimit(){return this.#V}set gasLimit(Q){this.#V=h(Q)}get gasPrice(){const Q=this.#$;if(Q==null&&(this.type===0||this.type===1))return Z0;return Q}set gasPrice(Q){this.#$=Q==null?null:h(Q,"gasPrice")}get maxPriorityFeePerGas(){const Q=this.#z;if(Q==null){if(this.type===2||this.type===3)return Z0;return null}return Q}set maxPriorityFeePerGas(Q){this.#z=Q==null?null:h(Q,"maxPriorityFeePerGas")}get maxFeePerGas(){const Q=this.#Z;if(Q==null){if(this.type===2||this.type===3)return Z0;return null}return Q}set maxFeePerGas(Q){this.#Z=Q==null?null:h(Q,"maxFeePerGas")}get data(){return this.#Y}set data(Q){this.#Y=T(Q)}get value(){return this.#M}set value(Q){this.#M=h(Q,"value")}get chainId(){return this.#K}set chainId(Q){this.#K=h(Q)}get signature(){return this.#j||null}set signature(Q){this.#j=Q==null?null:e.from(Q)}get accessList(){const Q=this.#O||null;if(Q==null){if(this.type===1||this.type===2||this.type===3)return[];return null}return Q}set accessList(Q){this.#O=Q==null?null:t8(Q)}get authorizationList(){const Q=this.#D||null;if(Q==null){if(this.type===4)return[]}return Q}set authorizationList(Q){this.#D=Q==null?null:Q.map((Y)=>iX(Y))}get maxFeePerBlobGas(){const Q=this.#W;if(Q==null&&this.type===3)return Z0;return Q}set maxFeePerBlobGas(Q){this.#W=Q==null?null:h(Q,"maxFeePerBlobGas")}get blobVersionedHashes(){let Q=this.#G;if(Q==null&&this.type===3)return[];return Q}set blobVersionedHashes(Q){if(Q!=null){O(Array.isArray(Q),"blobVersionedHashes must be an Array","value",Q),Q=Q.slice();for(let Y=0;Y<Q.length;Y++)O(L0(Q[Y],32),"invalid blobVersionedHash",`value[${Y}]`,Q[Y])}this.#G=Q}get blobs(){if(this.#U==null)return null;return this.#U.map((Q)=>Object.assign({},Q))}set blobs(Q){if(Q==null){this.#U=null;return}const Y=[],J=[];for(let X=0;X<Q.length;X++){const q=Q[X];if(a0(q)){x(this.#q,"adding a raw blob requires a KZG library","UNSUPPORTED_OPERATION",{operation:"set blobs()"});let G=N(q);if(O(G.length<=j5,"blob is too large",`blobs[${X}]`,q),G.length!==j5){const $=new Uint8Array(j5);$.set(G),G=$}const U=this.#q.blobToKzgCommitment(G),W=T(this.#q.computeBlobKzgProof(G,U));Y.push({data:T(G),commitment:T(U),proof:W}),J.push(oX(1,U))}else{const G=T(q.commitment);Y.push({data:T(q.data),commitment:G,proof:T(q.proof)}),J.push(oX(1,G))}}this.#U=Y,this.#G=J}get kzg(){return this.#q}set kzg(Q){if(Q==null)this.#q=null;else this.#q=yG(Q)}constructor(){this.#Q=null,this.#J=null,this.#X=0,this.#V=Z0,this.#$=null,this.#z=null,this.#Z=null,this.#Y="0x",this.#M=Z0,this.#K=Z0,this.#j=null,this.#O=null,this.#W=null,this.#G=null,this.#q=null,this.#U=null,this.#D=null}get hash(){if(this.signature==null)return null;return n(this.#I(!0,!1))}get unsignedHash(){return n(this.unsignedSerialized)}get from(){if(this.signature==null)return null;return i9(this.unsignedHash,this.signature)}get fromPublicKey(){if(this.signature==null)return null;return q0.recoverPublicKey(this.unsignedHash,this.signature)}isSigned(){return this.signature!=null}#I(Q,Y){x(!Q||this.signature!=null,"cannot serialize unsigned transaction; maybe you meant .unsignedSerialized","UNSUPPORTED_OPERATION",{operation:".serialized"});const J=Q?this.signature:null;switch(this.inferType()){case 0:return pG(this,J);case 1:return nG(this,J);case 2:return dG(this,J);case 3:return oG(this,J,Y?this.blobs:null);case 4:return aG(this,J)}x(!1,"unsupported transaction type","UNSUPPORTED_OPERATION",{operation:".serialized"})}get serialized(){return this.#I(!0,!0)}get unsignedSerialized(){return this.#I(!1,!1)}inferType(){const Q=this.inferTypes();if(Q.indexOf(2)>=0)return 2;return Q.pop()}inferTypes(){const Q=this.gasPrice!=null,Y=this.maxFeePerGas!=null||this.maxPriorityFeePerGas!=null,J=this.accessList!=null,X=this.#W!=null||this.#G;if(this.maxFeePerGas!=null&&this.maxPriorityFeePerGas!=null)x(this.maxFeePerGas>=this.maxPriorityFeePerGas,"priorityFee cannot be more than maxFee","BAD_DATA",{value:this});x(!Y||this.type!==0&&this.type!==1,"transaction type cannot have maxFeePerGas or maxPriorityFeePerGas","BAD_DATA",{value:this}),x(this.type!==0||!J,"legacy transaction cannot have accessList","BAD_DATA",{value:this});const q=[];if(this.type!=null)q.push(this.type);else if(this.authorizationList&&this.authorizationList.length)q.push(4);else if(Y)q.push(2);else if(Q){if(q.push(1),!J)q.push(0)}else if(J)q.push(1),q.push(2);else if(X&&this.to)q.push(3);else q.push(0),q.push(1),q.push(2),q.push(3);return q.sort(),q}isLegacy(){return this.type===0}isBerlin(){return this.type===1}isLondon(){return this.type===2}isCancun(){return this.type===3}clone(){return T0.from(this)}toJSON(){const Q=(Y)=>{if(Y==null)return null;return Y.toString()};return{type:this.type,to:this.to,data:this.data,nonce:this.nonce,gasLimit:Q(this.gasLimit),gasPrice:Q(this.gasPrice),maxPriorityFeePerGas:Q(this.maxPriorityFeePerGas),maxFeePerGas:Q(this.maxFeePerGas),value:Q(this.value),chainId:Q(this.chainId),sig:this.signature?this.signature.toJSON():null,accessList:this.accessList}}static from(Q){if(Q==null)return new T0;if(typeof Q==="string"){const J=N(Q);if(J[0]>=127)return T0.from(cG(J));switch(J[0]){case 1:return T0.from(lG(J));case 2:return T0.from(uG(J));case 3:return T0.from(iG(J));case 4:return T0.from(rG(J))}x(!1,"unsupported transaction type","UNSUPPORTED_OPERATION",{operation:"from"})}const Y=new T0;if(Q.type!=null)Y.type=Q.type;if(Q.to!=null)Y.to=Q.to;if(Q.nonce!=null)Y.nonce=Q.nonce;if(Q.gasLimit!=null)Y.gasLimit=Q.gasLimit;if(Q.gasPrice!=null)Y.gasPrice=Q.gasPrice;if(Q.maxPriorityFeePerGas!=null)Y.maxPriorityFeePerGas=Q.maxPriorityFeePerGas;if(Q.maxFeePerGas!=null)Y.maxFeePerGas=Q.maxFeePerGas;if(Q.maxFeePerBlobGas!=null)Y.maxFeePerBlobGas=Q.maxFeePerBlobGas;if(Q.data!=null)Y.data=Q.data;if(Q.value!=null)Y.value=Q.value;if(Q.chainId!=null)Y.chainId=Q.chainId;if(Q.signature!=null)Y.signature=e.from(Q.signature);if(Q.accessList!=null)Y.accessList=Q.accessList;if(Q.authorizationList!=null)Y.authorizationList=Q.authorizationList;if(Q.blobVersionedHashes!=null)Y.blobVersionedHashes=Q.blobVersionedHashes;if(Q.kzg!=null)Y.kzg=Q.kzg;if(Q.blobs!=null)Y.blobs=Q.blobs;if(Q.hash!=null)O(Y.isSigned(),"unsigned transaction cannot define '.hash'","tx",Q),O(Y.hash===Q.hash,"hash mismatch","tx",Q);if(Q.from!=null)O(Y.isSigned(),"unsigned transaction cannot define '.from'","tx",Q),O(Y.from.toLowerCase()===(Q.from||"").toLowerCase(),"from mismatch","tx",Q);return Y}}function YJ(Q){return O(typeof Q.address==="string","invalid address for hashAuthorization","auth.address",Q),n(o(["0x05",b0([Q.chainId!=null?t(Q.chainId):"0x",y(Q.address),Q.nonce!=null?t(Q.nonce):"0x"])]))}function H8(Q){return n(z0(Q))}function o9(Q){if(typeof Q==="string")Q=z0(Q);return n(o([z0($5),z0(String(Q.length)),Q]))}function XJ(Q,Y){const J=o9(Q);return i9(J,Y)}var eG=function(Q){const Y=N(Q),J=Y.length%32;if(J)return o([Y,tX.slice(J)]);return T(Y)},aX=function(Q){return function(Y){return O(typeof Y==="string",`invalid domain value for ${JSON.stringify(Q)}`,`domain.${Q}`,Y),Y}},D5=function(Q){{const Y=Q.match(/^(u?)int(\d+)$/);if(Y){const J=Y[1]==="",X=parseInt(Y[2]);O(X%8===0&&X!==0&&X<=256&&Y[2]===String(X),"invalid numeric width","type",Q);const q=SQ(tG,J?X-1:X),G=J?(q+Qq)*sG:eX;return function(U){const W=h(U,"value");return O(W>=G&&W<=q,`value out-of-bounds for ${Q}`,"value",W),d0(J?EQ(W,256):W,32)}}}{const Y=Q.match(/^bytes(\d+)$/);if(Y){const J=parseInt(Y[1]);return O(J!==0&&J<=32&&Y[1]===String(J),"invalid bytes width","type",Q),function(X){const q=N(X);return O(q.length===J,`invalid length for ${Q}`,"value",X),eG(X)}}}switch(Q){case"address":return function(Y){return E0(y(Y),32)};case"bool":return function(Y){return!Y?JU:QU};case"bytes":return function(Y){return n(Y)};case"string":return function(Y){return H8(Y)}}return null},sX=function(Q,Y){return`${Q}(${Y.map(({name:J,type:X})=>X+" "+J).join(",")})`},qJ=function(Q){const Y=Q.match(/^([^\x5b]*)((\x5b\d*\x5d)*)(\x5b(\d*)\x5d)$/);if(Y)return{base:Y[1],index:Y[2]+Y[4],array:{base:Y[1],prefix:Y[1]+Y[2],count:Y[5]?parseInt(Y[5]):-1}};return{base:Q}};var tX=new Uint8Array(32);tX.fill(0);var sG=BigInt(-1),eX=BigInt(0),Qq=BigInt(1),tG=BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"),QU=d0(Qq,32),JU=d0(eX,32),rX={name:"string",version:"string",chainId:"uint256",verifyingContract:"address",salt:"bytes32"},O5=["name","version","chainId","verifyingContract","salt"],YU={name:aX("name"),version:aX("version"),chainId:function(Q){const Y=h(Q,"domain.chainId");if(O(Y>=0,"invalid chain ID","domain.chainId",Q),Number.isSafeInteger(Y))return Number(Y);return AQ(Y)},verifyingContract:function(Q){try{return y(Q).toLowerCase()}catch(Y){}O(!1,'invalid domain value "verifyingContract"',"domain.verifyingContract",Q)},salt:function(Q){const Y=N(Q,"domain.salt");return O(Y.length===32,'invalid domain value "salt"',"domain.salt",Q),T(Y)}};class P0{primaryType;#Q;get types(){return JSON.parse(this.#Q)}#J;#Y;constructor(Q){this.#J=new Map,this.#Y=new Map;const Y=new Map,J=new Map,X=new Map,q={};Object.keys(Q).forEach((W)=>{q[W]=Q[W].map(({name:$,type:V})=>{let{base:z,index:M}=qJ(V);if(z==="int"&&!Q.int)z="int256";if(z==="uint"&&!Q.uint)z="uint256";return{name:$,type:z+(M||"")}}),Y.set(W,new Set),J.set(W,[]),X.set(W,new Set)}),this.#Q=JSON.stringify(q);for(let W in q){const $=new Set;for(let V of q[W]){O(!$.has(V.name),`duplicate variable name ${JSON.stringify(V.name)} in ${JSON.stringify(W)}`,"types",Q),$.add(V.name);const z=qJ(V.type).base;if(O(z!==W,`circular type reference to ${JSON.stringify(z)}`,"types",Q),D5(z))continue;O(J.has(z),`unknown type ${JSON.stringify(z)}`,"types",Q),J.get(z).push(W),Y.get(W).add(z)}}const G=Array.from(J.keys()).filter((W)=>J.get(W).length===0);O(G.length!==0,"missing primary type","types",Q),O(G.length===1,`ambiguous primary types or unused types: ${G.map((W)=>JSON.stringify(W)).join(", ")}`,"types",Q),s(this,{primaryType:G[0]});function U(W,$){O(!$.has(W),`circular type reference to ${JSON.stringify(W)}`,"types",Q),$.add(W);for(let V of Y.get(W)){if(!J.has(V))continue;U(V,$);for(let z of $)X.get(z).add(V)}$.delete(W)}U(this.primaryType,new Set);for(let[W,$]of X){const V=Array.from($);V.sort(),this.#J.set(W,sX(W,q[W])+V.map((z)=>sX(z,q[z])).join(""))}}getEncoder(Q){let Y=this.#Y.get(Q);if(!Y)Y=this.#X(Q),this.#Y.set(Q,Y);return Y}#X(Q){{const X=D5(Q);if(X)return X}const Y=qJ(Q).array;if(Y){const X=Y.prefix,q=this.getEncoder(X);return(G)=>{O(Y.count===-1||Y.count===G.length,`array length mismatch; expected length ${Y.count}`,"value",G);let U=G.map(q);if(this.#J.has(X))U=U.map(n);return n(o(U))}}const J=this.types[Q];if(J){const X=H8(this.#J.get(Q));return(q)=>{const G=J.map(({name:U,type:W})=>{const $=this.getEncoder(W)(q[U]);if(this.#J.has(W))return n($);return $});return G.unshift(X),o(G)}}O(!1,`unknown type: ${Q}`,"type",Q)}encodeType(Q){const Y=this.#J.get(Q);return O(Y,`unknown type: ${JSON.stringify(Q)}`,"name",Q),Y}encodeData(Q,Y){return this.getEncoder(Q)(Y)}hashStruct(Q,Y){return n(this.encodeData(Q,Y))}encode(Q){return this.encodeData(this.primaryType,Q)}hash(Q){return this.hashStruct(this.primaryType,Q)}_visit(Q,Y,J){if(D5(Q))return J(Q,Y);const X=qJ(Q).array;if(X)return O(X.count===-1||X.count===Y.length,`array length mismatch; expected length ${X.count}`,"value",Y),Y.map((G)=>this._visit(X.prefix,G,J));const q=this.types[Q];if(q)return q.reduce((G,{name:U,type:W})=>{return G[U]=this._visit(W,Y[U],J),G},{});O(!1,`unknown type: ${Q}`,"type",Q)}visit(Q,Y){return this._visit(this.primaryType,Q,Y)}static from(Q){return new P0(Q)}static getPrimaryType(Q){return P0.from(Q).primaryType}static hashStruct(Q,Y,J){return P0.from(Y).hashStruct(Q,J)}static hashDomain(Q){const Y=[];for(let J in Q){if(Q[J]==null)continue;const X=rX[J];O(X,`invalid typed-data domain key: ${JSON.stringify(J)}`,"domain",Q),Y.push({name:J,type:X})}return Y.sort((J,X)=>{return O5.indexOf(J.name)-O5.indexOf(X.name)}),P0.hashStruct("EIP712Domain",{EIP712Domain:Y},Q)}static encode(Q,Y,J){return o(["0x1901",P0.hashDomain(Q),P0.from(Y).hash(J)])}static hash(Q,Y,J){return n(P0.encode(Q,Y,J))}static async resolveNames(Q,Y,J,X){Q=Object.assign({},Q);for(let U in Q)if(Q[U]==null)delete Q[U];const q={};if(Q.verifyingContract&&!L0(Q.verifyingContract,20))q[Q.verifyingContract]="0x";const G=P0.from(Y);G.visit(J,(U,W)=>{if(U==="address"&&!L0(W,20))q[W]="0x";return W});for(let U in q)q[U]=await X(U);if(Q.verifyingContract&&q[Q.verifyingContract])Q.verifyingContract=q[Q.verifyingContract];return J=G.visit(J,(U,W)=>{if(U==="address"&&q[W])return q[W];return W}),{domain:Q,value:J}}static getPayload(Q,Y,J){P0.hashDomain(Q);const X={},q=[];O5.forEach((W)=>{const $=Q[W];if($==null)return;X[W]=YU[W]($),q.push({name:W,type:rX[W]})});const G=P0.from(Y);Y=G.types;const U=Object.assign({},Y);return O(U.EIP712Domain==null,"types must not contain EIP712Domain type","types.EIP712Domain",Y),U.EIP712Domain=q,G.encode(J),{types:U,domain:X,primaryType:G.primaryType,message:G.visit(J,(W,$)=>{if(W.match(/^bytes(\d*)/))return T(N($));if(W.match(/^u?int/))return h($).toString();switch(W){case"address":return $.toLowerCase();case"bool":return!!$;case"string":return O(typeof $==="string","invalid string","value",$),$}O(!1,"unsupported type","type",W)})}}}var I5=function(Q){if(Q==null)return null;return Q},M0=function(Q){if(Q==null)return null;return Q.toString()};function r9(Q){const Y={};if(Q.to)Y.to=Q.to;if(Q.from)Y.from=Q.from;if(Q.data)Y.data=T(Q.data);const J="chainId,gasLimit,gasPrice,maxFeePerBlobGas,maxFeePerGas,maxPriorityFeePerGas,value".split(/,/);for(let q of J){if(!(q in Q)||Q[q]==null)continue;Y[q]=h(Q[q],`request.${q}`)}const X="type,nonce".split(/,/);for(let q of X){if(!(q in Q)||Q[q]==null)continue;Y[q]=$0(Q[q],`request.${q}`)}if(Q.accessList)Y.accessList=t8(Q.accessList);if(Q.authorizationList)Y.authorizationList=Q.authorizationList.slice();if("blockTag"in Q)Y.blockTag=Q.blockTag;if("enableCcipRead"in Q)Y.enableCcipRead=!!Q.enableCcipRead;if("customData"in Q)Y.customData=Q.customData;if(("blobVersionedHashes"in Q)&&Q.blobVersionedHashes)Y.blobVersionedHashes=Q.blobVersionedHashes.slice();if("kzg"in Q)Y.kzg=Q.kzg;if(("blobs"in Q)&&Q.blobs)Y.blobs=Q.blobs.map((q)=>{if(a0(q))return T(q);return Object.assign({},q)});return Y}var GU=function(Q){return{orphan:"drop-block",hash:Q.hash,number:Q.number}},qq=function(Q,Y){return{orphan:"reorder-transaction",tx:Q,other:Y}},Gq=function(Q){return{orphan:"drop-transaction",tx:Q}},UU=function(Q){return{orphan:"drop-log",log:{transactionHash:Q.transactionHash,blockHash:Q.blockHash,blockNumber:Q.blockNumber,address:Q.address,data:Q.data,topics:Object.freeze(Q.topics.slice()),index:Q.index}}},Jq=BigInt(0);class Yq{provider;number;hash;timestamp;parentHash;parentBeaconBlockRoot;nonce;difficulty;gasLimit;gasUsed;stateRoot;receiptsRoot;blobGasUsed;excessBlobGas;miner;prevRandao;extraData;baseFeePerGas;#Q;constructor(Q,Y){this.#Q=Q.transactions.map((J)=>{if(typeof J!=="string")return new GJ(J,Y);return J}),s(this,{provider:Y,hash:I5(Q.hash),number:Q.number,timestamp:Q.timestamp,parentHash:Q.parentHash,parentBeaconBlockRoot:Q.parentBeaconBlockRoot,nonce:Q.nonce,difficulty:Q.difficulty,gasLimit:Q.gasLimit,gasUsed:Q.gasUsed,blobGasUsed:Q.blobGasUsed,excessBlobGas:Q.excessBlobGas,miner:Q.miner,prevRandao:I5(Q.prevRandao),extraData:Q.extraData,baseFeePerGas:I5(Q.baseFeePerGas),stateRoot:Q.stateRoot,receiptsRoot:Q.receiptsRoot})}get transactions(){return this.#Q.map((Q)=>{if(typeof Q==="string")return Q;return Q.hash})}get prefetchedTransactions(){const Q=this.#Q.slice();if(Q.length===0)return[];return x(typeof Q[0]==="object","transactions were not prefetched with block request","UNSUPPORTED_OPERATION",{operation:"transactionResponses()"}),Q}toJSON(){const{baseFeePerGas:Q,difficulty:Y,extraData:J,gasLimit:X,gasUsed:q,hash:G,miner:U,prevRandao:W,nonce:$,number:V,parentHash:z,parentBeaconBlockRoot:M,stateRoot:K,receiptsRoot:j,timestamp:Z,transactions:D}=this;return{_type:"Block",baseFeePerGas:M0(Q),difficulty:M0(Y),extraData:J,gasLimit:M0(X),gasUsed:M0(q),blobGasUsed:M0(this.blobGasUsed),excessBlobGas:M0(this.excessBlobGas),hash:G,miner:U,prevRandao:W,nonce:$,number:V,parentHash:z,timestamp:Z,parentBeaconBlockRoot:M,stateRoot:K,receiptsRoot:j,transactions:D}}[Symbol.iterator](){let Q=0;const Y=this.transactions;return{next:()=>{if(Q<this.length)return{value:Y[Q++],done:!1};return{value:void 0,done:!0}}}}get length(){return this.#Q.length}get date(){if(this.timestamp==null)return null;return new Date(this.timestamp*1000)}async getTransaction(Q){let Y=void 0;if(typeof Q==="number")Y=this.#Q[Q];else{const J=Q.toLowerCase();for(let X of this.#Q)if(typeof X==="string"){if(X!==J)continue;Y=X;break}else{if(X.hash!==J)continue;Y=X;break}}if(Y==null)throw new Error("no such tx");if(typeof Y==="string")return await this.provider.getTransaction(Y);else return Y}getPrefetchedTransaction(Q){const Y=this.prefetchedTransactions;if(typeof Q==="number")return Y[Q];Q=Q.toLowerCase();for(let J of Y)if(J.hash===Q)return J;O(!1,"no matching transaction","indexOrHash",Q)}isMined(){return!!this.hash}isLondon(){return!!this.baseFeePerGas}orphanedEvent(){if(!this.isMined())throw new Error("");return GU(this)}}class L5{provider;transactionHash;blockHash;blockNumber;removed;address;data;topics;index;transactionIndex;constructor(Q,Y){this.provider=Y;const J=Object.freeze(Q.topics.slice());s(this,{transactionHash:Q.transactionHash,blockHash:Q.blockHash,blockNumber:Q.blockNumber,removed:Q.removed,address:Q.address,data:Q.data,topics:J,index:Q.index,transactionIndex:Q.transactionIndex})}toJSON(){const{address:Q,blockHash:Y,blockNumber:J,data:X,index:q,removed:G,topics:U,transactionHash:W,transactionIndex:$}=this;return{_type:"log",address:Q,blockHash:Y,blockNumber:J,data:X,index:q,removed:G,topics:U,transactionHash:W,transactionIndex:$}}async getBlock(){const Q=await this.provider.getBlock(this.blockHash);return x(!!Q,"failed to find transaction","UNKNOWN_ERROR",{}),Q}async getTransaction(){const Q=await this.provider.getTransaction(this.transactionHash);return x(!!Q,"failed to find transaction","UNKNOWN_ERROR",{}),Q}async getTransactionReceipt(){const Q=await this.provider.getTransactionReceipt(this.transactionHash);return x(!!Q,"failed to find transaction receipt","UNKNOWN_ERROR",{}),Q}removedEvent(){return UU(this)}}class Xq{provider;to;from;contractAddress;hash;index;blockHash;blockNumber;logsBloom;gasUsed;blobGasUsed;cumulativeGasUsed;gasPrice;blobGasPrice;type;status;root;#Q;constructor(Q,Y){this.#Q=Object.freeze(Q.logs.map((X)=>{return new L5(X,Y)}));let J=Jq;if(Q.effectiveGasPrice!=null)J=Q.effectiveGasPrice;else if(Q.gasPrice!=null)J=Q.gasPrice;s(this,{provider:Y,to:Q.to,from:Q.from,contractAddress:Q.contractAddress,hash:Q.hash,index:Q.index,blockHash:Q.blockHash,blockNumber:Q.blockNumber,logsBloom:Q.logsBloom,gasUsed:Q.gasUsed,cumulativeGasUsed:Q.cumulativeGasUsed,blobGasUsed:Q.blobGasUsed,gasPrice:J,blobGasPrice:Q.blobGasPrice,type:Q.type,status:Q.status,root:Q.root})}get logs(){return this.#Q}toJSON(){const{to:Q,from:Y,contractAddress:J,hash:X,index:q,blockHash:G,blockNumber:U,logsBloom:W,logs:$,status:V,root:z}=this;return{_type:"TransactionReceipt",blockHash:G,blockNumber:U,contractAddress:J,cumulativeGasUsed:M0(this.cumulativeGasUsed),from:Y,gasPrice:M0(this.gasPrice),blobGasUsed:M0(this.blobGasUsed),blobGasPrice:M0(this.blobGasPrice),gasUsed:M0(this.gasUsed),hash:X,index:q,logs:$,logsBloom:W,root:z,status:V,to:Q}}get length(){return this.logs.length}[Symbol.iterator](){let Q=0;return{next:()=>{if(Q<this.length)return{value:this.logs[Q++],done:!1};return{value:void 0,done:!0}}}}get fee(){return this.gasUsed*this.gasPrice}async getBlock(){const Q=await this.provider.getBlock(this.blockHash);if(Q==null)throw new Error("TODO");return Q}async getTransaction(){const Q=await this.provider.getTransaction(this.hash);if(Q==null)throw new Error("TODO");return Q}async getResult(){return await this.provider.getTransactionResult(this.hash)}async confirmations(){return await this.provider.getBlockNumber()-this.blockNumber+1}removedEvent(){return Gq(this)}reorderedEvent(Q){return x(!Q||Q.isMined(),"unmined 'other' transction cannot be orphaned","UNSUPPORTED_OPERATION",{operation:"reorderedEvent(other)"}),qq(this,Q)}}class GJ{provider;blockNumber;blockHash;index;hash;type;to;from;nonce;gasLimit;gasPrice;maxPriorityFeePerGas;maxFeePerGas;maxFeePerBlobGas;data;value;chainId;signature;accessList;blobVersionedHashes;authorizationList;#Q;constructor(Q,Y){this.provider=Y,this.blockNumber=Q.blockNumber!=null?Q.blockNumber:null,this.blockHash=Q.blockHash!=null?Q.blockHash:null,this.hash=Q.hash,this.index=Q.index,this.type=Q.type,this.from=Q.from,this.to=Q.to||null,this.gasLimit=Q.gasLimit,this.nonce=Q.nonce,this.data=Q.data,this.value=Q.value,this.gasPrice=Q.gasPrice,this.maxPriorityFeePerGas=Q.maxPriorityFeePerGas!=null?Q.maxPriorityFeePerGas:null,this.maxFeePerGas=Q.maxFeePerGas!=null?Q.maxFeePerGas:null,this.maxFeePerBlobGas=Q.maxFeePerBlobGas!=null?Q.maxFeePerBlobGas:null,this.chainId=Q.chainId,this.signature=Q.signature,this.accessList=Q.accessList!=null?Q.accessList:null,this.blobVersionedHashes=Q.blobVersionedHashes!=null?Q.blobVersionedHashes:null,this.authorizationList=Q.authorizationList!=null?Q.authorizationList:null,this.#Q=-1}toJSON(){const{blockNumber:Q,blockHash:Y,index:J,hash:X,type:q,to:G,from:U,nonce:W,data:$,signature:V,accessList:z,blobVersionedHashes:M}=this;return{_type:"TransactionResponse",accessList:z,blockNumber:Q,blockHash:Y,blobVersionedHashes:M,chainId:M0(this.chainId),data:$,from:U,gasLimit:M0(this.gasLimit),gasPrice:M0(this.gasPrice),hash:X,maxFeePerGas:M0(this.maxFeePerGas),maxPriorityFeePerGas:M0(this.maxPriorityFeePerGas),maxFeePerBlobGas:M0(this.maxFeePerBlobGas),nonce:W,signature:V,to:G,index:J,type:q,value:M0(this.value)}}async getBlock(){let Q=this.blockNumber;if(Q==null){const J=await this.getTransaction();if(J)Q=J.blockNumber}if(Q==null)return null;const Y=this.provider.getBlock(Q);if(Y==null)throw new Error("TODO");return Y}async getTransaction(){return this.provider.getTransaction(this.hash)}async confirmations(){if(this.blockNumber==null){const{tx:Y,blockNumber:J}=await r0({tx:this.getTransaction(),blockNumber:this.provider.getBlockNumber()});if(Y==null||Y.blockNumber==null)return 0;return J-Y.blockNumber+1}return await this.provider.getBlockNumber()-this.blockNumber+1}async wait(Q,Y){const J=Q==null?1:Q,X=Y==null?0:Y;let q=this.#Q,G=-1,U=q===-1?!0:!1;const W=async()=>{if(U)return null;const{blockNumber:M,nonce:K}=await r0({blockNumber:this.provider.getBlockNumber(),nonce:this.provider.getTransactionCount(this.from)});if(K<this.nonce){q=M;return}if(U)return null;const j=await this.getTransaction();if(j&&j.blockNumber!=null)return;if(G===-1){if(G=q-3,G<this.#Q)G=this.#Q}while(G<=M){if(U)return null;const Z=await this.provider.getBlock(G,!0);if(Z==null)return;for(let D of Z)if(D===this.hash)return;for(let D=0;D<Z.length;D++){const I=await Z.getTransaction(D);if(I.from===this.from&&I.nonce===this.nonce){if(U)return null;const L=await this.provider.getTransactionReceipt(I.hash);if(L==null)return;if(M-L.blockNumber+1<J)return;let R="replaced";if(I.data===this.data&&I.to===this.to&&I.value===this.value)R="repriced";else if(I.data==="0x"&&I.from===I.to&&I.value===Jq)R="cancelled";x(!1,"transaction was replaced","TRANSACTION_REPLACED",{cancelled:R==="replaced"||R==="cancelled",reason:R,replacement:I.replaceableTransaction(q),hash:I.hash,receipt:L})}}G++}return},$=(M)=>{if(M==null||M.status!==0)return M;x(!1,"transaction execution reverted","CALL_EXCEPTION",{action:"sendTransaction",data:null,reason:null,invocation:null,revert:null,transaction:{to:M.to,from:M.from,data:""},receipt:M})},V=await this.provider.getTransactionReceipt(this.hash);if(J===0)return $(V);if(V){if(J===1||await V.confirmations()>=J)return $(V)}else if(await W(),J===0)return null;return await new Promise((M,K)=>{const j=[],Z=()=>{j.forEach((I)=>I())};if(j.push(()=>{U=!0}),X>0){const I=setTimeout(()=>{Z(),K(_9("wait for transaction timeout","TIMEOUT"))},X);j.push(()=>{clearTimeout(I)})}const D=async(I)=>{if(await I.confirmations()>=J){Z();try{M($(I))}catch(L){K(L)}}};if(j.push(()=>{this.provider.off(this.hash,D)}),this.provider.on(this.hash,D),q>=0){const I=async()=>{try{await W()}catch(L){if(BQ(L,"TRANSACTION_REPLACED")){Z(),K(L);return}}if(!U)this.provider.once("block",I)};j.push(()=>{this.provider.off("block",I)}),this.provider.once("block",I)}})}isMined(){return this.blockHash!=null}isLegacy(){return this.type===0}isBerlin(){return this.type===1}isLondon(){return this.type===2}isCancun(){return this.type===3}removedEvent(){return x(this.isMined(),"unmined transaction canot be orphaned","UNSUPPORTED_OPERATION",{operation:"removeEvent()"}),Gq(this)}reorderedEvent(Q){return x(this.isMined(),"unmined transaction canot be orphaned","UNSUPPORTED_OPERATION",{operation:"removeEvent()"}),x(!Q||Q.isMined(),"unmined 'other' transaction canot be orphaned","UNSUPPORTED_OPERATION",{operation:"removeEvent()"}),qq(this,Q)}replaceableTransaction(Q){O(Number.isInteger(Q)&&Q>=0,"invalid startBlock","startBlock",Q);const Y=new GJ(this,this.provider);return Y.#Q=Q,Y}}var Q9=function(Q,Y){if(Q.provider)return Q.provider;x(!1,"missing provider","UNSUPPORTED_OPERATION",{operation:Y})};async function Uq(Q,Y){let J=r9(Y);if(J.to!=null)J.to=I8(J.to,Q);if(J.from!=null){const X=J.from;J.from=Promise.all([Q.getAddress(),I8(X,Q)]).then(([q,G])=>{return O(q.toLowerCase()===G.toLowerCase(),"transaction from mismatch","tx.from",G),q})}else J.from=Q.getAddress();return await r0(J)}class a9{provider;constructor(Q){s(this,{provider:Q||null})}async getNonce(Q){return Q9(this,"getTransactionCount").getTransactionCount(await this.getAddress(),Q)}async populateCall(Q){return await Uq(this,Q)}async populateTransaction(Q){const Y=Q9(this,"populateTransaction"),J=await Uq(this,Q);if(J.nonce==null)J.nonce=await this.getNonce("pending");if(J.gasLimit==null)J.gasLimit=await this.estimateGas(J);const X=await this.provider.getNetwork();if(J.chainId!=null){const G=h(J.chainId);O(G===X.chainId,"transaction chainId mismatch","tx.chainId",Q.chainId)}else J.chainId=X.chainId;const q=J.maxFeePerGas!=null||J.maxPriorityFeePerGas!=null;if(J.gasPrice!=null&&(J.type===2||q))O(!1,"eip-1559 transaction do not support gasPrice","tx",Q);else if((J.type===0||J.type===1)&&q)O(!1,"pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas","tx",Q);if((J.type===2||J.type==null)&&(J.maxFeePerGas!=null&&J.maxPriorityFeePerGas!=null))J.type=2;else if(J.type===0||J.type===1){const G=await Y.getFeeData();if(x(G.gasPrice!=null,"network does not support gasPrice","UNSUPPORTED_OPERATION",{operation:"getGasPrice"}),J.gasPrice==null)J.gasPrice=G.gasPrice}else{const G=await Y.getFeeData();if(J.type==null)if(G.maxFeePerGas!=null&&G.maxPriorityFeePerGas!=null){if(J.authorizationList&&J.authorizationList.length)J.type=4;else J.type=2;if(J.gasPrice!=null){const U=J.gasPrice;delete J.gasPrice,J.maxFeePerGas=U,J.maxPriorityFeePerGas=U}else{if(J.maxFeePerGas==null)J.maxFeePerGas=G.maxFeePerGas;if(J.maxPriorityFeePerGas==null)J.maxPriorityFeePerGas=G.maxPriorityFeePerGas}}else if(G.gasPrice!=null){if(x(!q,"network does not support EIP-1559","UNSUPPORTED_OPERATION",{operation:"populateTransaction"}),J.gasPrice==null)J.gasPrice=G.gasPrice;J.type=0}else x(!1,"failed to get consistent fee data","UNSUPPORTED_OPERATION",{operation:"signer.getFeeData"});else if(J.type===2||J.type===3||J.type===4){if(J.maxFeePerGas==null)J.maxFeePerGas=G.maxFeePerGas;if(J.maxPriorityFeePerGas==null)J.maxPriorityFeePerGas=G.maxPriorityFeePerGas}}return await r0(J)}async populateAuthorization(Q){const Y=Object.assign({},Q);if(Y.chainId==null)Y.chainId=(await Q9(this,"getNetwork").getNetwork()).chainId;if(Y.nonce==null)Y.nonce=await this.getNonce();return Y}async estimateGas(Q){return Q9(this,"estimateGas").estimateGas(await this.populateCall(Q))}async call(Q){return Q9(this,"call").call(await this.populateCall(Q))}async resolveName(Q){return await Q9(this,"resolveName").resolveName(Q)}async sendTransaction(Q){const Y=Q9(this,"sendTransaction"),J=await this.populateTransaction(Q);delete J.from;const X=T0.from(J);return await Y.broadcastTransaction(await this.signTransaction(X))}authorize(Q){x(!1,"authorization not implemented for this signer","UNSUPPORTED_OPERATION",{operation:"authorize"})}}class s9 extends a9{address;constructor(Q,Y){super(Y);s(this,{address:Q})}async getAddress(){return this.address}connect(Q){return new s9(this.address,Q)}#Q(Q,Y){x(!1,`VoidSigner cannot sign ${Q}`,"UNSUPPORTED_OPERATION",{operation:Y})}async signTransaction(Q){this.#Q("transactions","signTransaction")}async signMessage(Q){this.#Q("messages","signMessage")}async signTypedData(Q,Y,J){this.#Q("typed-data","signTypedData")}}class J9 extends a9{address;#Q;constructor(Q,Y){super(Y);O(Q&&typeof Q.sign==="function","invalid private key","privateKey","[ REDACTED ]"),this.#Q=Q;const J=L8(this.signingKey.publicKey);s(this,{address:J})}get signingKey(){return this.#Q}get privateKey(){return this.signingKey.privateKey}async getAddress(){return this.address}connect(Q){return new J9(this.#Q,Q)}async signTransaction(Q){Q=r9(Q);const{to:Y,from:J}=await r0({to:Q.to?I8(Q.to,this):void 0,from:Q.from?I8(Q.from,this):void 0});if(Y!=null)Q.to=Y;if(J!=null)Q.from=J;if(Q.from!=null)O(y(Q.from)===this.address,"transaction from address mismatch","tx.from",Q.from),delete Q.from;const X=T0.from(Q);return X.signature=this.signingKey.sign(X.unsignedHash),X.serialized}async signMessage(Q){return this.signMessageSync(Q)}signMessageSync(Q){return this.signingKey.sign(o9(Q)).serialized}authorizeSync(Q){O(typeof Q.address==="string","invalid address for authorizeSync","auth.address",Q);const Y=this.signingKey.sign(YJ(Q));return Object.assign({},{address:y(Q.address),nonce:h(Q.nonce||0),chainId:h(Q.chainId||0)},{signature:Y})}async authorize(Q){return Q=Object.assign({},Q,{address:await I8(Q.address,this)}),this.authorizeSync(await this.populateAuthorization(Q))}async signTypedData(Q,Y,J){const X=await P0.resolveNames(Q,Y,J,async(q)=>{x(this.provider!=null,"cannot resolve ENS names without a provider","UNSUPPORTED_OPERATION",{operation:"resolveName",info:{name:q}});const G=await this.provider.resolveName(q);return x(G!=null,"unconfigured ENS name","UNCONFIGURED_NAME",{value:q}),G});return this.signingKey.sign(P0.hash(X.domain,Y,X.value)).serialized}}var Wq=function(Q,Y){let J=97;return Q.reduce((X,q)=>{if(q===Y)J++;else if(q.match(WU))X.push(String.fromCharCode(J)+q);else J=97,X.push(q);return X},[])};function VU(Q,Y){for(let q=UJ.length-1;q>=0;q--)Q=Q.split(UJ[q]).join(Y.substring(2*q,2*q+2));const J=[],X=Q.replace(/(:|([0-9])|([A-Z][a-z]*))/g,(q,G,U,W)=>{if(U)for(let $=parseInt(U);$>=0;$--)J.push(";");else J.push(G.toLowerCase());return""});if(X)throw new Error(`leftovers: ${JSON.stringify(X)}`);return Wq(Wq(J,";"),":")}function Vq(Q){return O(Q[0]==="0","unsupported auwl data","data",Q),VU(Q.substring(1+2*UJ.length),Q.substring(1,1+2*UJ.length))}var UJ=" !#$%&'()*+,-./<=>?@[]^_`{|}~",WU=/^[a-z]*$/i;class H5{locale;constructor(Q){s(this,{locale:Q})}split(Q){return Q.toLowerCase().split(/\s+/g)}join(Q){return Q.join(" ")}}class R5 extends H5{#Q;#J;constructor(Q,Y,J){super(Q);this.#Q=Y,this.#J=J,this.#Y=null}get _data(){return this.#Q}_decodeWords(){return Vq(this.#Q)}#Y;#X(){if(this.#Y==null){const Q=this._decodeWords();if(H8(Q.join("\n")+"\n")!==this.#J)throw new Error(`BIP39 Wordlist for ${this.locale} FAILED`);this.#Y=Q}return this.#Y}getWord(Q){const Y=this.#X();return O(Q>=0&&Q<Y.length,`invalid word index: ${Q}`,"index",Q),Y[Q]}getWordIndex(Q){return this.#X().indexOf(Q)}}var $U="0erleonalorenseinceregesticitStanvetearctssi#ch2Athck&tneLl0And#Il.yLeOutO=S|S%b/ra@SurdU'0Ce[Cid|CountCu'Hie=IdOu,-Qui*Ro[TT]T%T*[Tu$0AptDD-tD*[Ju,M.UltV<)Vi)0Rob-0FairF%dRaid0A(EEntRee0Ead0MRRp%tS!_rmBumCoholErtI&LLeyLowMo,O}PhaReadySoT Ways0A>urAz(gOngOuntU'd0Aly,Ch%Ci|G G!GryIm$K!Noun)Nu$O` Sw T&naTiqueXietyY1ArtOlogyPe?P!Pro=Ril1ChCt-EaEnaGueMMedM%MyOundR<+Re,Ri=RowTTefa@Ti,Tw%k0KPe@SaultSetSi,SumeThma0H!>OmTa{T&dT.udeTra@0Ct]D.Gu,NtTh%ToTumn0Era+OcadoOid0AkeA*AyEsomeFulKw?d0Is:ByChel%C#D+GL<)Lc#y~MbooN<aNn RRelyRga(R*lSeS-SketTt!3A^AnAutyCau'ComeEfF%eG(Ha=H(dLie=LowLtN^Nef./TrayTt Twe&Y#d3Cyc!DKeNdOlogyRdR`Tt _{AdeAmeAnketA,EakE[IndOodO[omOu'UeUrUsh_rdAtDyIlMbNeNusOkO,Rd R(gRrowSsTtomUn)XY_{etA(AndA[A=EadEezeI{Id+IefIghtIngIskOccoliOk&OnzeOomO` OwnUsh2Bb!DdyD+tFf$oIldLbLkL!tNd!Nk Rd&Rg R,SS(e[SyTt Y Zz:Bba+B(B!CtusGeKe~LmM aMpNN$N)lNdyNn#NoeNvasNy#Pab!P.$Pta(RRb#RdRgoRpetRryRtSeShS(o/!Su$TT$ogT^Teg%yTt!UghtU'Ut]Ve3Il(gL yM|NsusNturyRe$Rta(_irAlkAmp]An+AosApt Ar+A'AtEapE{Ee'EfErryE,I{&IefIldIm}yOi)Oo'R#-U{!UnkUrn0G?Nnam#Rc!Tiz&TyVil_imApArifyAwAyE<ErkEv I{I|IffImbIn-IpO{OgO'O`OudOwnUbUmpU, Ut^_^A,C#utDeFfeeIlInL!@L%LumnMb(eMeMf%tM-Mm#Mp<yNc tNdu@NfirmNg*[N}@Nsid NtrolNv()OkOlPp PyR$ReRnR*@/Tt#U^UntryUp!Ur'Us(V Yo>_{Ad!AftAmA}AshAt AwlAzyEamEd.EekEwI{etImeIspIt-OpO[Ou^OwdUci$UelUi'Umb!Un^UshYY,$2BeLtu*PPbo?dRiousRr|Rta(R=Sh]/omTe3C!:DMa+MpN)Ng R(gShUght WnY3AlBa>BrisCadeCemb CideCl(eC%a>C*a'ErF&'F(eFyG*eLayLiv M<dMi'Ni$Nti,NyP?tP&dPos.P`PutyRi=ScribeS tSignSkSpair/royTailTe@VelopVi)Vo>3AgramAlAm#dAryCeE'lEtFf G.$Gn.yLemmaNn NosaurRe@RtSag*eScov Sea'ShSmi[S%d Splay/<)V tVideV%)Zzy5Ct%Cum|G~Lph(Ma(Na>NkeyN%OrSeUb!Ve_ftAg#AmaA,-AwEamE[IftIllInkIpI=OpUmY2CkMbNeR(g/T^Ty1Arf1Nam-:G G!RlyRnR`Sily/Sy1HoOlogyOnomy0GeItUca>1F%t0G1GhtTh 2BowD E@r-Eg<tEm|Eph<tEvat%I>Se0B?kBodyBra)Er+Ot]PloyPow Pty0Ab!A@DD![D%'EmyErgyF%)Ga+G(eH<)JoyLi,OughR-hRollSu*T Ti*TryVelope1Isode0U$Uip0AA'OdeOs]R%Upt0CapeSayS&)Ta>0Ern$H-s1Id&)IlOkeOl=1A@Amp!Ce[Ch<+C.eCludeCu'Ecu>Erci'Hau,Hib.I!I,ItOt-P<dPe@Pi*Pla(Po'P*[T&dTra0EEbrow:Br-CeCultyDeIntI`~L'MeMilyMousNNcyNtasyRmSh]TT$Th TigueUltV%.e3Atu*Bru?yD $EEdElMa!N)/iv$T^V W3B Ct]EldGu*LeLmLt N$NdNeNg NishReRmR,Sc$ShTT}[X_gAmeAshAtAv%EeIghtIpOatO{O%Ow UidUshY_mCusGIlLd~owOdOtR)Re,R+tRkRtu}RumRw?dSsil/ UndX_gi!AmeEqu|EshI&dIn+OgOntO,OwnOz&U.2ElNNnyRna)RyTu*:D+tInLaxy~ yMePRa+Rba+Rd&Rl-Rm|SSpTeTh U+Ze3N $NiusN*Nt!Nu(e/u*2O,0AntFtGg!Ng RaffeRlVe_dAn)A*A[IdeImp'ObeOomOryO=OwUe_tDde[LdOdO'RillaSpelSsipV nWn_bA)A(AntApeA[Av.yEatE&IdIefItOc yOupOwUnt_rdE[IdeIltIt?N3M:B.IrLfMm M, NdPpyRb%RdRshR=,TVeWkZ?d3AdAl`ArtAvyD+hogIght~oLmetLpNRo3Dd&Gh~NtPRe/%y5BbyCkeyLdLeLiday~owMeNeyOdPeRnRr%R'Sp.$/TelUrV 5BGeM<Mb!M%Nd*dNgryNtRd!RryRtSb<d3Brid:1EOn0EaEntifyLe2N%e4LLeg$L}[0A+Ita>M&'Mu}Pa@Po'Pro=Pul'0ChCludeComeC*a'DexD-a>Do%Du,ryF<tFl-tF%mHa!H .Iti$Je@JuryMa>N Noc|PutQuiryS<eSe@SideSpi*/$lTa@T e,ToVe,V.eVol=3On0L<dOla>Sue0Em1Ory:CketGu?RZz3AlousAns~yWel9BInKeUr}yY5D+I)MpNg!Ni%Nk/:Ng?oo3EnEpT^upY3CkDD}yNdNgdomSsTT^&TeTt&Wi4EeIfeO{Ow:BBelB%Dd DyKeMpNgua+PtopR+T T(UghUndryVaWWnWsu.Y Zy3Ad AfArnA=Ctu*FtGG$G&dIsu*M#NdNg`NsOp?dSs#Tt Vel3ArB tyBr?yC&'FeFtGhtKeMbM.NkOnQuid/Tt!VeZ?d5AdAnB, C$CkG-NelyNgOpTt yUdUn+VeY$5CkyGga+Mb N?N^Xury3R-s:Ch(eDG-G}tIdIlInJ%KeMm$NNa+Nda>NgoNs]Nu$P!Rb!R^Rg(R(eRketRria+SkSs/ T^T i$ThTrixTt XimumZe3AdowAnAsu*AtCh<-D$DiaLodyLtMb M%yNt]NuRcyR+R.RryShSsa+T$Thod3Dd!DnightLk~]M-NdNimumN%Nu>Rac!Rr%S ySs/akeXXedXtu*5Bi!DelDifyMM|N.%NkeyN, N`OnR$ReRn(gSqu.oTh T]T%Unta(U'VeVie5ChFf(LeLtiplySc!SeumShroomS-/Tu$3Self/ yTh:I=MePk(Rrow/yT]Tu*3ArCkEdGati=G!@I` PhewR=/TTw%kUtr$V WsXt3CeGht5B!I'M(eeOd!Rm$R`SeTab!TeTh(gTi)VelW5C!?Mb R'T:K0EyJe@Li+Scu*S =Ta(Vious0CurE<Tob 0Or1FF Fi)T&2L1Ay0DI=Ymp-0It0CeEI#L(eLy1EnEraIn]Po'T]1An+B.Ch?dD D(?yG<I|Ig($Ph<0Tr-h0H 0Tdo%T TputTside0AlEnEr0NN 0Yg&0/ 0O}:CtDd!GeIrLa)LmNdaNelN-N` P RadeR|RkRrotRtySsT^ThTi|TrolTt nU'VeYm|3A)AnutArAs<tL-<NN$tyNcilOp!Pp Rfe@Rm.Rs#T2O}OtoRa'Ys-$0AnoCn-Ctu*E)GGe#~LotNkO} Pe/olT^Zza_)A}tA,-A>AyEa'Ed+U{UgUn+2EmEtIntL?LeLi)NdNyOlPul?Rt]S.]Ssib!/TatoTt yV tyWd W _@i)Ai'Ed-tEf Epa*Es|EttyEv|I)IdeIm?yIntI%.yIs#Iva>IzeOb!mO)[Odu)Of.OgramOje@Omo>OofOp tyOsp O>@OudOvide2Bl-Dd(g~LpL'Mpk(N^PilPpyR^a'R.yRpo'R'ShTZz!3Ramid:99Al.yAntumArt E,]I{ItIzO>:Bb.Cco#CeCkD?DioIlInI'~yMpN^NdomN+PidReTeTh V&WZ%3AdyAlAs#BelBuildC$lCei=CipeC%dCyc!Du)F!@F%mFu'G]G*tGul?Je@LaxLea'LiefLyMa(Memb M(dMo=Nd NewNtOp&PairPeatPla)P%tQui*ScueSemb!Si,Sour)Sp#'SultTi*T*atTurnUn]Ve$ViewW?d2Y`m0BBb#CeChDeD+F!GhtGidNgOtPp!SkTu$V$V 5AdA,BotBu,CketM<)OfOkieOmSeTa>UghUndU>Y$5Bb DeGLeNNwayR$:DDd!D}[FeIlLadLm#L#LtLu>MeMp!NdTisfyToshiU)Usa+VeY1A!AnA*Att E}HemeHoolI&)I[%sOrp]OutRapRe&RiptRub1AAr^As#AtC#dC*tCt]Cur.yEdEkGm|Le@~M(?Ni%N'Nt&)RiesRvi)Ss]Tt!TupV&_dowAftAllowA*EdEllEriffIeldIftI}IpIv O{OeOotOpOrtOuld O=RimpRugUff!Y0Bl(gCkDeE+GhtGnL|Lk~yLv Mil?Mp!N)NgR&/ Tua>XZe1A>Et^IIllInIrtUll0AbAmEepEnd I)IdeIghtImOg<OtOwUsh0AllArtI!OkeOo`0A{AkeApIffOw0ApCc Ci$CkDaFtL?Ldi LidLut]L=Me#eNgOnRryRtUlUndUpUr)U`0A)A*Ati$AwnEakEci$EedEllEndH eI)Id IkeInIr.L.OilOns%O#OrtOtRayReadR(gY0Ua*UeezeUir*l_b!AdiumAffA+AirsAmpAndArtA>AyEakEelEmEpE*oI{IllIngO{Oma^O}OolOryO=Ra>gyReetRikeR#gRugg!Ud|UffUmb!Y!0Bje@Bm.BwayC)[ChDd&Ff G?G+,ItMm NNnyN'tP PplyP*meReRfa)R+Rpri'RroundR=ySpe@/a(1AllowAmpApArmE?EetIftImIngIt^Ord1MbolMptomRup/em:B!Ck!GIlL|LkNkPeR+tSk/eTtooXi3A^Am~NN<tNnisNtRm/Xt_nkAtEmeEnE%yE*EyIngIsOughtReeRi=RowUmbUnd 0CketDeG LtMb MeNyPRedSsueT!5A,BaccoDayDdl EGe` I!tK&MatoM%rowNeNgueNightOlO`PP-Pp!R^RnadoRtoi'SsT$Uri,W?dW WnY_{AdeAff-Ag-A(Ansf ApAshA=lAyEatEeEndI$IbeI{Igg ImIpOphyOub!U{UeUlyUmpetU,U`Y2BeIt]Mb!NaN}lRkeyRnRt!1El=EntyI)InI,O1PeP-$:5Ly5B*lla0Ab!Awa*C!Cov D DoFairFoldHappyIf%mIqueItIv 'KnownLo{TilUsu$Veil1Da>GradeHoldOnP Set1B<Ge0A+EEdEfulE![U$0Il.y:C<tCuumGueLidL!yL=NNishP%Rious/Ult3H-!L=tNd%Ntu*NueRbRifyRs]RyS'lT <3Ab!Br<tCiousCt%yDeoEw~a+Nta+Ol(Rtu$RusSaS.Su$T$Vid5C$I)IdLc<oLumeTeYa+:GeG#ItLk~LnutNtRfa*RmRri%ShSp/eT VeY3Al`Ap#ArA'lA` BDd(gEk&dIrdLcome/T_!AtEatEelEnE*IpIsp 0DeD`FeLd~NNdowNeNgNkNn Nt ReSdomSeShT}[5LfM<Nd OdOlRdRkRldRryR`_pE{E,!I,I>Ong::Rd3Ar~ow9UUngU`:3BraRo9NeO",zU="0x3c8acc1e7b08d8e76f9fda015ef48dc8c710a73cb7e0f77b2c18a9b5a7adde60",P5=null;class R8 extends R5{constructor(){super("en",$U,zU)}static wordlist(){if(P5==null)P5=new R8;return P5}}var $q=function(Q){return(1<<Q)-1<<8-Q&255},ZU=function(Q){return(1<<Q)-1&255},C5=function(Q,Y){if(D9("NFKD"),Y==null)Y=R8.wordlist();const J=Y.split(Q);O(J.length%3===0&&J.length>=12&&J.length<=24,"invalid mnemonic length","mnemonic","[ REDACTED ]");const X=new Uint8Array(Math.ceil(11*J.length/8));let q=0;for(let V=0;V<J.length;V++){let z=Y.getWordIndex(J[V].normalize("NFKD"));O(z>=0,`invalid mnemonic word at index ${V}`,"mnemonic","[ REDACTED ]");for(let M=0;M<11;M++){if(z&1<<10-M)X[q>>3]|=1<<7-q%8;q++}}const G=32*J.length/3,U=J.length/3,W=$q(U),$=N(j0(X.slice(0,G/8)))[0]&W;return O($===(X[X.length-1]&W),"invalid mnemonic checksum","mnemonic","[ REDACTED ]"),T(X.slice(0,G/8))},T5=function(Q,Y){if(O(Q.length%4===0&&Q.length>=16&&Q.length<=32,"invalid entropy size","entropy","[ REDACTED ]"),Y==null)Y=R8.wordlist();const J=[0];let X=11;for(let U=0;U<Q.length;U++)if(X>8)J[J.length-1]<<=8,J[J.length-1]|=Q[U],X-=8;else J[J.length-1]<<=X,J[J.length-1]|=Q[U]>>8-X,J.push(Q[U]&ZU(8-X)),X+=3;const q=Q.length/4,G=parseInt(j0(Q).substring(2,4),16)&$q(q);return J[J.length-1]<<=q,J[J.length-1]|=G>>8-q,Y.join(J.map((U)=>Y.getWord(U)))},N5={};class P8{phrase;password;wordlist;entropy;constructor(Q,Y,J,X,q){if(X==null)X="";if(q==null)q=R8.wordlist();U8(Q,N5,"Mnemonic"),s(this,{phrase:J,password:X,wordlist:q,entropy:Y})}computeSeed(){const Q=z0("mnemonic"+this.password,"NFKD");return S0(z0(this.phrase,"NFKD"),Q,2048,64,"sha512")}static fromPhrase(Q,Y,J){const X=C5(Q,J);return Q=T5(N(X),J),new P8(N5,X,Q,Y,J)}static fromEntropy(Q,Y,J){const X=N(Q,"entropy"),q=T5(X,J);return new P8(N5,T(X),q,Y,J)}static entropyToPhrase(Q,Y){const J=N(Q,"entropy");return T5(J,Y)}static phraseToEntropy(Q,Y){return C5(Q,Y)}static isValidMnemonic(Q,Y){try{return C5(Q,Y),!0}catch(J){}return!1}}var F5=function(Q){const Y=[];for(let J=0;J<Q.length;J+=4)Y.push(Q[J]<<24|Q[J+1]<<16|Q[J+2]<<8|Q[J+3]);return Y};/*! MIT License. Copyright 2015-2022 Richard Moore <me@ricmoo.com>. See LICENSE.txt. */var O0=function(Q,Y,J,X){if(J==="a"&&!X)throw new TypeError("Private accessor was defined without a getter");if(typeof Y==="function"?Q!==Y||!X:!Y.has(Q))throw new TypeError("Cannot read private member from an object whose class did not declare it");return J==="m"?X:J==="a"?X.call(Q):X?X.value:Y.get(Q)},w5=function(Q,Y,J,X,q){if(X==="m")throw new TypeError("Private method is not writable");if(X==="a"&&!q)throw new TypeError("Private accessor was defined without a setter");if(typeof Y==="function"?Q!==Y||!q:!Y.has(Q))throw new TypeError("Cannot write private member to an object whose class did not declare it");return X==="a"?q.call(Q,J):q?q.value=J:Y.set(Q,J),J},VJ,y0,t0,MU={16:10,24:12,32:14},KU=[1,2,4,8,16,32,64,128,27,54,108,216,171,77,154,47,94,188,99,198,151,53,106,212,179,125,250,239,197,145],g0=[99,124,119,123,242,107,111,197,48,1,103,43,254,215,171,118,202,130,201,125,250,89,71,240,173,212,162,175,156,164,114,192,183,253,147,38,54,63,247,204,52,165,229,241,113,216,49,21,4,199,35,195,24,150,5,154,7,18,128,226,235,39,178,117,9,131,44,26,27,110,90,160,82,59,214,179,41,227,47,132,83,209,0,237,32,252,177,91,106,203,190,57,74,76,88,207,208,239,170,251,67,77,51,133,69,249,2,127,80,60,159,168,81,163,64,143,146,157,56,245,188,182,218,33,16,255,243,210,205,12,19,236,95,151,68,23,196,167,126,61,100,93,25,115,96,129,79,220,34,42,144,136,70,238,184,20,222,94,11,219,224,50,58,10,73,6,36,92,194,211,172,98,145,149,228,121,231,200,55,109,141,213,78,169,108,86,244,234,101,122,174,8,186,120,37,46,28,166,180,198,232,221,116,31,75,189,139,138,112,62,181,102,72,3,246,14,97,53,87,185,134,193,29,158,225,248,152,17,105,217,142,148,155,30,135,233,206,85,40,223,140,161,137,13,191,230,66,104,65,153,45,15,176,84,187,22],WJ=[82,9,106,213,48,54,165,56,191,64,163,158,129,243,215,251,124,227,57,130,155,47,255,135,52,142,67,68,196,222,233,203,84,123,148,50,166,194,35,61,238,76,149,11,66,250,195,78,8,46,161,102,40,217,36,178,118,91,162,73,109,139,209,37,114,248,246,100,134,104,152,22,212,164,92,204,93,101,182,146,108,112,72,80,253,237,185,218,94,21,70,87,167,141,157,132,144,216,171,0,140,188,211,10,247,228,88,5,184,179,69,6,208,44,30,143,202,63,15,2,193,175,189,3,1,19,138,107,58,145,17,65,79,103,220,234,151,242,207,206,240,180,230,115,150,172,116,34,231,173,53,133,226,249,55,232,28,117,223,110,71,241,26,113,29,41,197,137,111,183,98,14,170,24,190,27,252,86,62,75,198,210,121,32,154,219,192,254,120,205,90,244,31,221,168,51,136,7,199,49,177,18,16,89,39,128,236,95,96,81,127,169,25,181,74,13,45,229,122,159,147,201,156,239,160,224,59,77,174,42,245,176,200,235,187,60,131,83,153,97,23,43,4,126,186,119,214,38,225,105,20,99,85,33,12,125],jU=[3328402341,4168907908,4000806809,4135287693,4294111757,3597364157,3731845041,2445657428,1613770832,33620227,3462883241,1445669757,3892248089,3050821474,1303096294,3967186586,2412431941,528646813,2311702848,4202528135,4026202645,2992200171,2387036105,4226871307,1101901292,3017069671,1604494077,1169141738,597466303,1403299063,3832705686,2613100635,1974974402,3791519004,1033081774,1277568618,1815492186,2118074177,4126668546,2211236943,1748251740,1369810420,3521504564,4193382664,3799085459,2883115123,1647391059,706024767,134480908,2512897874,1176707941,2646852446,806885416,932615841,168101135,798661301,235341577,605164086,461406363,3756188221,3454790438,1311188841,2142417613,3933566367,302582043,495158174,1479289972,874125870,907746093,3698224818,3025820398,1537253627,2756858614,1983593293,3084310113,2108928974,1378429307,3722699582,1580150641,327451799,2790478837,3117535592,0,3253595436,1075847264,3825007647,2041688520,3059440621,3563743934,2378943302,1740553945,1916352843,2487896798,2555137236,2958579944,2244988746,3151024235,3320835882,1336584933,3992714006,2252555205,2588757463,1714631509,293963156,2319795663,3925473552,67240454,4269768577,2689618160,2017213508,631218106,1269344483,2723238387,1571005438,2151694528,93294474,1066570413,563977660,1882732616,4059428100,1673313503,2008463041,2950355573,1109467491,537923632,3858759450,4260623118,3218264685,2177748300,403442708,638784309,3287084079,3193921505,899127202,2286175436,773265209,2479146071,1437050866,4236148354,2050833735,3362022572,3126681063,840505643,3866325909,3227541664,427917720,2655997905,2749160575,1143087718,1412049534,999329963,193497219,2353415882,3354324521,1807268051,672404540,2816401017,3160301282,369822493,2916866934,3688947771,1681011286,1949973070,336202270,2454276571,201721354,1210328172,3093060836,2680341085,3184776046,1135389935,3294782118,965841320,831886756,3554993207,4068047243,3588745010,2345191491,1849112409,3664604599,26054028,2983581028,2622377682,1235855840,3630984372,2891339514,4092916743,3488279077,3395642799,4101667470,1202630377,268961816,1874508501,4034427016,1243948399,1546530418,941366308,1470539505,1941222599,2546386513,3421038627,2715671932,3899946140,1042226977,2521517021,1639824860,227249030,260737669,3765465232,2084453954,1907733956,3429263018,2420656344,100860677,4160157185,470683154,3261161891,1781871967,2924959737,1773779408,394692241,2579611992,974986535,664706745,3655459128,3958962195,731420851,571543859,3530123707,2849626480,126783113,865375399,765172662,1008606754,361203602,3387549984,2278477385,2857719295,1344809080,2782912378,59542671,1503764984,160008576,437062935,1707065306,3622233649,2218934982,3496503480,2185314755,697932208,1512910199,504303377,2075177163,2824099068,1841019862,739644986],OU=[2781242211,2230877308,2582542199,2381740923,234877682,3184946027,2984144751,1418839493,1348481072,50462977,2848876391,2102799147,434634494,1656084439,3863849899,2599188086,1167051466,2636087938,1082771913,2281340285,368048890,3954334041,3381544775,201060592,3963727277,1739838676,4250903202,3930435503,3206782108,4149453988,2531553906,1536934080,3262494647,484572669,2923271059,1783375398,1517041206,1098792767,49674231,1334037708,1550332980,4098991525,886171109,150598129,2481090929,1940642008,1398944049,1059722517,201851908,1385547719,1699095331,1587397571,674240536,2704774806,252314885,3039795866,151914247,908333586,2602270848,1038082786,651029483,1766729511,3447698098,2682942837,454166793,2652734339,1951935532,775166490,758520603,3000790638,4004797018,4217086112,4137964114,1299594043,1639438038,3464344499,2068982057,1054729187,1901997871,2534638724,4121318227,1757008337,0,750906861,1614815264,535035132,3363418545,3988151131,3201591914,1183697867,3647454910,1265776953,3734260298,3566750796,3903871064,1250283471,1807470800,717615087,3847203498,384695291,3313910595,3617213773,1432761139,2484176261,3481945413,283769337,100925954,2180939647,4037038160,1148730428,3123027871,3813386408,4087501137,4267549603,3229630528,2315620239,2906624658,3156319645,1215313976,82966005,3747855548,3245848246,1974459098,1665278241,807407632,451280895,251524083,1841287890,1283575245,337120268,891687699,801369324,3787349855,2721421207,3431482436,959321879,1469301956,4065699751,2197585534,1199193405,2898814052,3887750493,724703513,2514908019,2696962144,2551808385,3516813135,2141445340,1715741218,2119445034,2872807568,2198571144,3398190662,700968686,3547052216,1009259540,2041044702,3803995742,487983883,1991105499,1004265696,1449407026,1316239930,504629770,3683797321,168560134,1816667172,3837287516,1570751170,1857934291,4014189740,2797888098,2822345105,2754712981,936633572,2347923833,852879335,1133234376,1500395319,3084545389,2348912013,1689376213,3533459022,3762923945,3034082412,4205598294,133428468,634383082,2949277029,2398386810,3913789102,403703816,3580869306,2297460856,1867130149,1918643758,607656988,4049053350,3346248884,1368901318,600565992,2090982877,2632479860,557719327,3717614411,3697393085,2249034635,2232388234,2430627952,1115438654,3295786421,2865522278,3633334344,84280067,33027830,303828494,2747425121,1600795957,4188952407,3496589753,2434238086,1486471617,658119965,3106381470,953803233,334231800,3005978776,857870609,3151128937,1890179545,2298973838,2805175444,3056442267,574365214,2450884487,550103529,1233637070,4289353045,2018519080,2057691103,2399374476,4166623649,2148108681,387583245,3664101311,836232934,3330556482,3100665960,3280093505,2955516313,2002398509,287182607,3413881008,4238890068,3597515707,975967766],DU=[1671808611,2089089148,2006576759,2072901243,4061003762,1807603307,1873927791,3310653893,810573872,16974337,1739181671,729634347,4263110654,3613570519,2883997099,1989864566,3393556426,2191335298,3376449993,2106063485,4195741690,1508618841,1204391495,4027317232,2917941677,3563566036,2734514082,2951366063,2629772188,2767672228,1922491506,3227229120,3082974647,4246528509,2477669779,644500518,911895606,1061256767,4144166391,3427763148,878471220,2784252325,3845444069,4043897329,1905517169,3631459288,827548209,356461077,67897348,3344078279,593839651,3277757891,405286936,2527147926,84871685,2595565466,118033927,305538066,2157648768,3795705826,3945188843,661212711,2999812018,1973414517,152769033,2208177539,745822252,439235610,455947803,1857215598,1525593178,2700827552,1391895634,994932283,3596728278,3016654259,695947817,3812548067,795958831,2224493444,1408607827,3513301457,0,3979133421,543178784,4229948412,2982705585,1542305371,1790891114,3410398667,3201918910,961245753,1256100938,1289001036,1491644504,3477767631,3496721360,4012557807,2867154858,4212583931,1137018435,1305975373,861234739,2241073541,1171229253,4178635257,33948674,2139225727,1357946960,1011120188,2679776671,2833468328,1374921297,2751356323,1086357568,2408187279,2460827538,2646352285,944271416,4110742005,3168756668,3066132406,3665145818,560153121,271589392,4279952895,4077846003,3530407890,3444343245,202643468,322250259,3962553324,1608629855,2543990167,1154254916,389623319,3294073796,2817676711,2122513534,1028094525,1689045092,1575467613,422261273,1939203699,1621147744,2174228865,1339137615,3699352540,577127458,712922154,2427141008,2290289544,1187679302,3995715566,3100863416,339486740,3732514782,1591917662,186455563,3681988059,3762019296,844522546,978220090,169743370,1239126601,101321734,611076132,1558493276,3260915650,3547250131,2901361580,1655096418,2443721105,2510565781,3828863972,2039214713,3878868455,3359869896,928607799,1840765549,2374762893,3580146133,1322425422,2850048425,1823791212,1459268694,4094161908,3928346602,1706019429,2056189050,2934523822,135794696,3134549946,2022240376,628050469,779246638,472135708,2800834470,3032970164,3327236038,3894660072,3715932637,1956440180,522272287,1272813131,3185336765,2340818315,2323976074,1888542832,1044544574,3049550261,1722469478,1222152264,50660867,4127324150,236067854,1638122081,895445557,1475980887,3117443513,2257655686,3243809217,489110045,2662934430,3778599393,4162055160,2561878936,288563729,1773916777,3648039385,2391345038,2493985684,2612407707,505560094,2274497927,3911240169,3460925390,1442818645,678973480,3749357023,2358182796,2717407649,2306869641,219617805,3218761151,3862026214,1120306242,1756942440,1103331905,2578459033,762796589,252780047,2966125488,1425844308,3151392187,372911126],IU=[1667474886,2088535288,2004326894,2071694838,4075949567,1802223062,1869591006,3318043793,808472672,16843522,1734846926,724270422,4278065639,3621216949,2880169549,1987484396,3402253711,2189597983,3385409673,2105378810,4210693615,1499065266,1195886990,4042263547,2913856577,3570689971,2728590687,2947541573,2627518243,2762274643,1920112356,3233831835,3082273397,4261223649,2475929149,640051788,909531756,1061110142,4160160501,3435941763,875846760,2779116625,3857003729,4059105529,1903268834,3638064043,825316194,353713962,67374088,3351728789,589522246,3284360861,404236336,2526454071,84217610,2593830191,117901582,303183396,2155911963,3806477791,3958056653,656894286,2998062463,1970642922,151591698,2206440989,741110872,437923380,454765878,1852748508,1515908788,2694904667,1381168804,993742198,3604373943,3014905469,690584402,3823320797,791638366,2223281939,1398011302,3520161977,0,3991743681,538992704,4244381667,2981218425,1532751286,1785380564,3419096717,3200178535,960056178,1246420628,1280103576,1482221744,3486468741,3503319995,4025428677,2863326543,4227536621,1128514950,1296947098,859002214,2240123921,1162203018,4193849577,33687044,2139062782,1347481760,1010582648,2678045221,2829640523,1364325282,2745433693,1077985408,2408548869,2459086143,2644360225,943212656,4126475505,3166494563,3065430391,3671750063,555836226,269496352,4294908645,4092792573,3537006015,3452783745,202118168,320025894,3974901699,1600119230,2543297077,1145359496,387397934,3301201811,2812801621,2122220284,1027426170,1684319432,1566435258,421079858,1936954854,1616945344,2172753945,1330631070,3705438115,572679748,707427924,2425400123,2290647819,1179044492,4008585671,3099120491,336870440,3739122087,1583276732,185277718,3688593069,3772791771,842159716,976899700,168435220,1229577106,101059084,606366792,1549591736,3267517855,3553849021,2897014595,1650632388,2442242105,2509612081,3840161747,2038008818,3890688725,3368567691,926374254,1835907034,2374863873,3587531953,1313788572,2846482505,1819063512,1448540844,4109633523,3941213647,1701162954,2054852340,2930698567,134748176,3132806511,2021165296,623210314,774795868,471606328,2795958615,3031746419,3334885783,3907527627,3722280097,1953799400,522133822,1263263126,3183336545,2341176845,2324333839,1886425312,1044267644,3048588401,1718004428,1212733584,50529542,4143317495,235803164,1633788866,892690282,1465383342,3115962473,2256965911,3250673817,488449850,2661202215,3789633753,4177007595,2560144171,286339874,1768537042,3654906025,2391705863,2492770099,2610673197,505291324,2273808917,3924369609,3469625735,1431699370,673740880,3755965093,2358021891,2711746649,2307489801,218961690,3217021541,3873845719,1111672452,1751693520,1094828930,2576986153,757954394,252645662,2964376443,1414855848,3149649517,370555436],LU=[1374988112,2118214995,437757123,975658646,1001089995,530400753,2902087851,1273168787,540080725,2910219766,2295101073,4110568485,1340463100,3307916247,641025152,3043140495,3736164937,632953703,1172967064,1576976609,3274667266,2169303058,2370213795,1809054150,59727847,361929877,3211623147,2505202138,3569255213,1484005843,1239443753,2395588676,1975683434,4102977912,2572697195,666464733,3202437046,4035489047,3374361702,2110667444,1675577880,3843699074,2538681184,1649639237,2976151520,3144396420,4269907996,4178062228,1883793496,2403728665,2497604743,1383856311,2876494627,1917518562,3810496343,1716890410,3001755655,800440835,2261089178,3543599269,807962610,599762354,33778362,3977675356,2328828971,2809771154,4077384432,1315562145,1708848333,101039829,3509871135,3299278474,875451293,2733856160,92987698,2767645557,193195065,1080094634,1584504582,3178106961,1042385657,2531067453,3711829422,1306967366,2438237621,1908694277,67556463,1615861247,429456164,3602770327,2302690252,1742315127,2968011453,126454664,3877198648,2043211483,2709260871,2084704233,4169408201,0,159417987,841739592,504459436,1817866830,4245618683,260388950,1034867998,908933415,168810852,1750902305,2606453969,607530554,202008497,2472011535,3035535058,463180190,2160117071,1641816226,1517767529,470948374,3801332234,3231722213,1008918595,303765277,235474187,4069246893,766945465,337553864,1475418501,2943682380,4003061179,2743034109,4144047775,1551037884,1147550661,1543208500,2336434550,3408119516,3069049960,3102011747,3610369226,1113818384,328671808,2227573024,2236228733,3535486456,2935566865,3341394285,496906059,3702665459,226906860,2009195472,733156972,2842737049,294930682,1206477858,2835123396,2700099354,1451044056,573804783,2269728455,3644379585,2362090238,2564033334,2801107407,2776292904,3669462566,1068351396,742039012,1350078989,1784663195,1417561698,4136440770,2430122216,775550814,2193862645,2673705150,1775276924,1876241833,3475313331,3366754619,270040487,3902563182,3678124923,3441850377,1851332852,3969562369,2203032232,3868552805,2868897406,566021896,4011190502,3135740889,1248802510,3936291284,699432150,832877231,708780849,3332740144,899835584,1951317047,4236429990,3767586992,866637845,4043610186,1106041591,2144161806,395441711,1984812685,1139781709,3433712980,3835036895,2664543715,1282050075,3240894392,1181045119,2640243204,25965917,4203181171,4211818798,3009879386,2463879762,3910161971,1842759443,2597806476,933301370,1509430414,3943906441,3467192302,3076639029,3776767469,2051518780,2631065433,1441952575,404016761,1942435775,1408749034,1610459739,3745345300,2017778566,3400528769,3110650942,941896748,3265478751,371049330,3168937228,675039627,4279080257,967311729,135050206,3635733660,1683407248,2076935265,3576870512,1215061108,3501741890],HU=[1347548327,1400783205,3273267108,2520393566,3409685355,4045380933,2880240216,2471224067,1428173050,4138563181,2441661558,636813900,4233094615,3620022987,2149987652,2411029155,1239331162,1730525723,2554718734,3781033664,46346101,310463728,2743944855,3328955385,3875770207,2501218972,3955191162,3667219033,768917123,3545789473,692707433,1150208456,1786102409,2029293177,1805211710,3710368113,3065962831,401639597,1724457132,3028143674,409198410,2196052529,1620529459,1164071807,3769721975,2226875310,486441376,2499348523,1483753576,428819965,2274680428,3075636216,598438867,3799141122,1474502543,711349675,129166120,53458370,2592523643,2782082824,4063242375,2988687269,3120694122,1559041666,730517276,2460449204,4042459122,2706270690,3446004468,3573941694,533804130,2328143614,2637442643,2695033685,839224033,1973745387,957055980,2856345839,106852767,1371368976,4181598602,1033297158,2933734917,1179510461,3046200461,91341917,1862534868,4284502037,605657339,2547432937,3431546947,2003294622,3182487618,2282195339,954669403,3682191598,1201765386,3917234703,3388507166,0,2198438022,1211247597,2887651696,1315723890,4227665663,1443857720,507358933,657861945,1678381017,560487590,3516619604,975451694,2970356327,261314535,3535072918,2652609425,1333838021,2724322336,1767536459,370938394,182621114,3854606378,1128014560,487725847,185469197,2918353863,3106780840,3356761769,2237133081,1286567175,3152976349,4255350624,2683765030,3160175349,3309594171,878443390,1988838185,3704300486,1756818940,1673061617,3403100636,272786309,1075025698,545572369,2105887268,4174560061,296679730,1841768865,1260232239,4091327024,3960309330,3497509347,1814803222,2578018489,4195456072,575138148,3299409036,446754879,3629546796,4011996048,3347532110,3252238545,4270639778,915985419,3483825537,681933534,651868046,2755636671,3828103837,223377554,2607439820,1649704518,3270937875,3901806776,1580087799,4118987695,3198115200,2087309459,2842678573,3016697106,1003007129,2802849917,1860738147,2077965243,164439672,4100872472,32283319,2827177882,1709610350,2125135846,136428751,3874428392,3652904859,3460984630,3572145929,3593056380,2939266226,824852259,818324884,3224740454,930369212,2801566410,2967507152,355706840,1257309336,4148292826,243256656,790073846,2373340630,1296297904,1422699085,3756299780,3818836405,457992840,3099667487,2135319889,77422314,1560382517,1945798516,788204353,1521706781,1385356242,870912086,325965383,2358957921,2050466060,2388260884,2313884476,4006521127,901210569,3990953189,1014646705,1503449823,1062597235,2031621326,3212035895,3931371469,1533017514,350174575,2256028891,2177544179,1052338372,741876788,1606591296,1914052035,213705253,2334669897,1107234197,1899603969,3725069491,2631447780,2422494913,1635502980,1893020342,1950903388,1120974935],RU=[2807058932,1699970625,2764249623,1586903591,1808481195,1173430173,1487645946,59984867,4199882800,1844882806,1989249228,1277555970,3623636965,3419915562,1149249077,2744104290,1514790577,459744698,244860394,3235995134,1963115311,4027744588,2544078150,4190530515,1608975247,2627016082,2062270317,1507497298,2200818878,567498868,1764313568,3359936201,2305455554,2037970062,1047239000,1910319033,1337376481,2904027272,2892417312,984907214,1243112415,830661914,861968209,2135253587,2011214180,2927934315,2686254721,731183368,1750626376,4246310725,1820824798,4172763771,3542330227,48394827,2404901663,2871682645,671593195,3254988725,2073724613,145085239,2280796200,2779915199,1790575107,2187128086,472615631,3029510009,4075877127,3802222185,4107101658,3201631749,1646252340,4270507174,1402811438,1436590835,3778151818,3950355702,3963161475,4020912224,2667994737,273792366,2331590177,104699613,95345982,3175501286,2377486676,1560637892,3564045318,369057872,4213447064,3919042237,1137477952,2658625497,1119727848,2340947849,1530455833,4007360968,172466556,266959938,516552836,0,2256734592,3980931627,1890328081,1917742170,4294704398,945164165,3575528878,958871085,3647212047,2787207260,1423022939,775562294,1739656202,3876557655,2530391278,2443058075,3310321856,547512796,1265195639,437656594,3121275539,719700128,3762502690,387781147,218828297,3350065803,2830708150,2848461854,428169201,122466165,3720081049,1627235199,648017665,4122762354,1002783846,2117360635,695634755,3336358691,4234721005,4049844452,3704280881,2232435299,574624663,287343814,612205898,1039717051,840019705,2708326185,793451934,821288114,1391201670,3822090177,376187827,3113855344,1224348052,1679968233,2361698556,1058709744,752375421,2431590963,1321699145,3519142200,2734591178,188127444,2177869557,3727205754,2384911031,3215212461,2648976442,2450346104,3432737375,1180849278,331544205,3102249176,4150144569,2952102595,2159976285,2474404304,766078933,313773861,2570832044,2108100632,1668212892,3145456443,2013908262,418672217,3070356634,2594734927,1852171925,3867060991,3473416636,3907448597,2614737639,919489135,164948639,2094410160,2997825956,590424639,2486224549,1723872674,3157750862,3399941250,3501252752,3625268135,2555048196,3673637356,1343127501,4130281361,3599595085,2957853679,1297403050,81781910,3051593425,2283490410,532201772,1367295589,3926170974,895287692,1953757831,1093597963,492483431,3528626907,1446242576,1192455638,1636604631,209336225,344873464,1015671571,669961897,3375740769,3857572124,2973530695,3747192018,1933530610,3464042516,935293895,3454686199,2858115069,1863638845,3683022916,4085369519,3292445032,875313188,1080017571,3279033885,621591778,1233856572,2504130317,24197544,3017672716,3835484340,3247465558,2220981195,3060847922,1551124588,1463996600],PU=[4104605777,1097159550,396673818,660510266,2875968315,2638606623,4200115116,3808662347,821712160,1986918061,3430322568,38544885,3856137295,718002117,893681702,1654886325,2975484382,3122358053,3926825029,4274053469,796197571,1290801793,1184342925,3556361835,2405426947,2459735317,1836772287,1381620373,3196267988,1948373848,3764988233,3385345166,3263785589,2390325492,1480485785,3111247143,3780097726,2293045232,548169417,3459953789,3746175075,439452389,1362321559,1400849762,1685577905,1806599355,2174754046,137073913,1214797936,1174215055,3731654548,2079897426,1943217067,1258480242,529487843,1437280870,3945269170,3049390895,3313212038,923313619,679998000,3215307299,57326082,377642221,3474729866,2041877159,133361907,1776460110,3673476453,96392454,878845905,2801699524,777231668,4082475170,2330014213,4142626212,2213296395,1626319424,1906247262,1846563261,562755902,3708173718,1040559837,3871163981,1418573201,3294430577,114585348,1343618912,2566595609,3186202582,1078185097,3651041127,3896688048,2307622919,425408743,3371096953,2081048481,1108339068,2216610296,0,2156299017,736970802,292596766,1517440620,251657213,2235061775,2933202493,758720310,265905162,1554391400,1532285339,908999204,174567692,1474760595,4002861748,2610011675,3234156416,3693126241,2001430874,303699484,2478443234,2687165888,585122620,454499602,151849742,2345119218,3064510765,514443284,4044981591,1963412655,2581445614,2137062819,19308535,1928707164,1715193156,4219352155,1126790795,600235211,3992742070,3841024952,836553431,1669664834,2535604243,3323011204,1243905413,3141400786,4180808110,698445255,2653899549,2989552604,2253581325,3252932727,3004591147,1891211689,2487810577,3915653703,4237083816,4030667424,2100090966,865136418,1229899655,953270745,3399679628,3557504664,4118925222,2061379749,3079546586,2915017791,983426092,2022837584,1607244650,2118541908,2366882550,3635996816,972512814,3283088770,1568718495,3499326569,3576539503,621982671,2895723464,410887952,2623762152,1002142683,645401037,1494807662,2595684844,1335535747,2507040230,4293295786,3167684641,367585007,3885750714,1865862730,2668221674,2960971305,2763173681,1059270954,2777952454,2724642869,1320957812,2194319100,2429595872,2815956275,77089521,3973773121,3444575871,2448830231,1305906550,4021308739,2857194700,2516901860,3518358430,1787304780,740276417,1699839814,1592394909,2352307457,2272556026,188821243,1729977011,3687994002,274084841,3594982253,3613494426,2701949495,4162096729,322734571,2837966542,1640576439,484830689,1202797690,3537852828,4067639125,349075736,3342319475,4157467219,4255800159,1030690015,1155237496,2951971274,1757691577,607398968,2738905026,499347990,3794078908,1011452712,227885567,2818666809,213114376,3034881240,1455525988,3414450555,850817237,1817998408,3092726480],CU=[0,235474187,470948374,303765277,941896748,908933415,607530554,708780849,1883793496,2118214995,1817866830,1649639237,1215061108,1181045119,1417561698,1517767529,3767586992,4003061179,4236429990,4069246893,3635733660,3602770327,3299278474,3400528769,2430122216,2664543715,2362090238,2193862645,2835123396,2801107407,3035535058,3135740889,3678124923,3576870512,3341394285,3374361702,3810496343,3977675356,4279080257,4043610186,2876494627,2776292904,3076639029,3110650942,2472011535,2640243204,2403728665,2169303058,1001089995,899835584,666464733,699432150,59727847,226906860,530400753,294930682,1273168787,1172967064,1475418501,1509430414,1942435775,2110667444,1876241833,1641816226,2910219766,2743034109,2976151520,3211623147,2505202138,2606453969,2302690252,2269728455,3711829422,3543599269,3240894392,3475313331,3843699074,3943906441,4178062228,4144047775,1306967366,1139781709,1374988112,1610459739,1975683434,2076935265,1775276924,1742315127,1034867998,866637845,566021896,800440835,92987698,193195065,429456164,395441711,1984812685,2017778566,1784663195,1683407248,1315562145,1080094634,1383856311,1551037884,101039829,135050206,437757123,337553864,1042385657,807962610,573804783,742039012,2531067453,2564033334,2328828971,2227573024,2935566865,2700099354,3001755655,3168937228,3868552805,3902563182,4203181171,4102977912,3736164937,3501741890,3265478751,3433712980,1106041591,1340463100,1576976609,1408749034,2043211483,2009195472,1708848333,1809054150,832877231,1068351396,766945465,599762354,159417987,126454664,361929877,463180190,2709260871,2943682380,3178106961,3009879386,2572697195,2538681184,2236228733,2336434550,3509871135,3745345300,3441850377,3274667266,3910161971,3877198648,4110568485,4211818798,2597806476,2497604743,2261089178,2295101073,2733856160,2902087851,3202437046,2968011453,3936291284,3835036895,4136440770,4169408201,3535486456,3702665459,3467192302,3231722213,2051518780,1951317047,1716890410,1750902305,1113818384,1282050075,1584504582,1350078989,168810852,67556463,371049330,404016761,841739592,1008918595,775550814,540080725,3969562369,3801332234,4035489047,4269907996,3569255213,3669462566,3366754619,3332740144,2631065433,2463879762,2160117071,2395588676,2767645557,2868897406,3102011747,3069049960,202008497,33778362,270040487,504459436,875451293,975658646,675039627,641025152,2084704233,1917518562,1615861247,1851332852,1147550661,1248802510,1484005843,1451044056,933301370,967311729,733156972,632953703,260388950,25965917,328671808,496906059,1206477858,1239443753,1543208500,1441952575,2144161806,1908694277,1675577880,1842759443,3610369226,3644379585,3408119516,3307916247,4011190502,3776767469,4077384432,4245618683,2809771154,2842737049,3144396420,3043140495,2673705150,2438237621,2203032232,2370213795],TU=[0,185469197,370938394,487725847,741876788,657861945,975451694,824852259,1483753576,1400783205,1315723890,1164071807,1950903388,2135319889,1649704518,1767536459,2967507152,3152976349,2801566410,2918353863,2631447780,2547432937,2328143614,2177544179,3901806776,3818836405,4270639778,4118987695,3299409036,3483825537,3535072918,3652904859,2077965243,1893020342,1841768865,1724457132,1474502543,1559041666,1107234197,1257309336,598438867,681933534,901210569,1052338372,261314535,77422314,428819965,310463728,3409685355,3224740454,3710368113,3593056380,3875770207,3960309330,4045380933,4195456072,2471224067,2554718734,2237133081,2388260884,3212035895,3028143674,2842678573,2724322336,4138563181,4255350624,3769721975,3955191162,3667219033,3516619604,3431546947,3347532110,2933734917,2782082824,3099667487,3016697106,2196052529,2313884476,2499348523,2683765030,1179510461,1296297904,1347548327,1533017514,1786102409,1635502980,2087309459,2003294622,507358933,355706840,136428751,53458370,839224033,957055980,605657339,790073846,2373340630,2256028891,2607439820,2422494913,2706270690,2856345839,3075636216,3160175349,3573941694,3725069491,3273267108,3356761769,4181598602,4063242375,4011996048,3828103837,1033297158,915985419,730517276,545572369,296679730,446754879,129166120,213705253,1709610350,1860738147,1945798516,2029293177,1239331162,1120974935,1606591296,1422699085,4148292826,4233094615,3781033664,3931371469,3682191598,3497509347,3446004468,3328955385,2939266226,2755636671,3106780840,2988687269,2198438022,2282195339,2501218972,2652609425,1201765386,1286567175,1371368976,1521706781,1805211710,1620529459,2105887268,1988838185,533804130,350174575,164439672,46346101,870912086,954669403,636813900,788204353,2358957921,2274680428,2592523643,2441661558,2695033685,2880240216,3065962831,3182487618,3572145929,3756299780,3270937875,3388507166,4174560061,4091327024,4006521127,3854606378,1014646705,930369212,711349675,560487590,272786309,457992840,106852767,223377554,1678381017,1862534868,1914052035,2031621326,1211247597,1128014560,1580087799,1428173050,32283319,182621114,401639597,486441376,768917123,651868046,1003007129,818324884,1503449823,1385356242,1333838021,1150208456,1973745387,2125135846,1673061617,1756818940,2970356327,3120694122,2802849917,2887651696,2637442643,2520393566,2334669897,2149987652,3917234703,3799141122,4284502037,4100872472,3309594171,3460984630,3545789473,3629546796,2050466060,1899603969,1814803222,1730525723,1443857720,1560382517,1075025698,1260232239,575138148,692707433,878443390,1062597235,243256656,91341917,409198410,325965383,3403100636,3252238545,3704300486,3620022987,3874428392,3990953189,4042459122,4227665663,2460449204,2578018489,2226875310,2411029155,3198115200,3046200461,2827177882,2743944855],NU=[0,218828297,437656594,387781147,875313188,958871085,775562294,590424639,1750626376,1699970625,1917742170,2135253587,1551124588,1367295589,1180849278,1265195639,3501252752,3720081049,3399941250,3350065803,3835484340,3919042237,4270507174,4085369519,3102249176,3051593425,2734591178,2952102595,2361698556,2177869557,2530391278,2614737639,3145456443,3060847922,2708326185,2892417312,2404901663,2187128086,2504130317,2555048196,3542330227,3727205754,3375740769,3292445032,3876557655,3926170974,4246310725,4027744588,1808481195,1723872674,1910319033,2094410160,1608975247,1391201670,1173430173,1224348052,59984867,244860394,428169201,344873464,935293895,984907214,766078933,547512796,1844882806,1627235199,2011214180,2062270317,1507497298,1423022939,1137477952,1321699145,95345982,145085239,532201772,313773861,830661914,1015671571,731183368,648017665,3175501286,2957853679,2807058932,2858115069,2305455554,2220981195,2474404304,2658625497,3575528878,3625268135,3473416636,3254988725,3778151818,3963161475,4213447064,4130281361,3599595085,3683022916,3432737375,3247465558,3802222185,4020912224,4172763771,4122762354,3201631749,3017672716,2764249623,2848461854,2331590177,2280796200,2431590963,2648976442,104699613,188127444,472615631,287343814,840019705,1058709744,671593195,621591778,1852171925,1668212892,1953757831,2037970062,1514790577,1463996600,1080017571,1297403050,3673637356,3623636965,3235995134,3454686199,4007360968,3822090177,4107101658,4190530515,2997825956,3215212461,2830708150,2779915199,2256734592,2340947849,2627016082,2443058075,172466556,122466165,273792366,492483431,1047239000,861968209,612205898,695634755,1646252340,1863638845,2013908262,1963115311,1446242576,1530455833,1277555970,1093597963,1636604631,1820824798,2073724613,1989249228,1436590835,1487645946,1337376481,1119727848,164948639,81781910,331544205,516552836,1039717051,821288114,669961897,719700128,2973530695,3157750862,2871682645,2787207260,2232435299,2283490410,2667994737,2450346104,3647212047,3564045318,3279033885,3464042516,3980931627,3762502690,4150144569,4199882800,3070356634,3121275539,2904027272,2686254721,2200818878,2384911031,2570832044,2486224549,3747192018,3528626907,3310321856,3359936201,3950355702,3867060991,4049844452,4234721005,1739656202,1790575107,2108100632,1890328081,1402811438,1586903591,1233856572,1149249077,266959938,48394827,369057872,418672217,1002783846,919489135,567498868,752375421,209336225,24197544,376187827,459744698,945164165,895287692,574624663,793451934,1679968233,1764313568,2117360635,1933530610,1343127501,1560637892,1243112415,1192455638,3704280881,3519142200,3336358691,3419915562,3907448597,3857572124,4075877127,4294704398,3029510009,3113855344,2927934315,2744104290,2159976285,2377486676,2594734927,2544078150],wU=[0,151849742,303699484,454499602,607398968,758720310,908999204,1059270954,1214797936,1097159550,1517440620,1400849762,1817998408,1699839814,2118541908,2001430874,2429595872,2581445614,2194319100,2345119218,3034881240,3186202582,2801699524,2951971274,3635996816,3518358430,3399679628,3283088770,4237083816,4118925222,4002861748,3885750714,1002142683,850817237,698445255,548169417,529487843,377642221,227885567,77089521,1943217067,2061379749,1640576439,1757691577,1474760595,1592394909,1174215055,1290801793,2875968315,2724642869,3111247143,2960971305,2405426947,2253581325,2638606623,2487810577,3808662347,3926825029,4044981591,4162096729,3342319475,3459953789,3576539503,3693126241,1986918061,2137062819,1685577905,1836772287,1381620373,1532285339,1078185097,1229899655,1040559837,923313619,740276417,621982671,439452389,322734571,137073913,19308535,3871163981,4021308739,4104605777,4255800159,3263785589,3414450555,3499326569,3651041127,2933202493,2815956275,3167684641,3049390895,2330014213,2213296395,2566595609,2448830231,1305906550,1155237496,1607244650,1455525988,1776460110,1626319424,2079897426,1928707164,96392454,213114376,396673818,514443284,562755902,679998000,865136418,983426092,3708173718,3557504664,3474729866,3323011204,4180808110,4030667424,3945269170,3794078908,2507040230,2623762152,2272556026,2390325492,2975484382,3092726480,2738905026,2857194700,3973773121,3856137295,4274053469,4157467219,3371096953,3252932727,3673476453,3556361835,2763173681,2915017791,3064510765,3215307299,2156299017,2307622919,2459735317,2610011675,2081048481,1963412655,1846563261,1729977011,1480485785,1362321559,1243905413,1126790795,878845905,1030690015,645401037,796197571,274084841,425408743,38544885,188821243,3613494426,3731654548,3313212038,3430322568,4082475170,4200115116,3780097726,3896688048,2668221674,2516901860,2366882550,2216610296,3141400786,2989552604,2837966542,2687165888,1202797690,1320957812,1437280870,1554391400,1669664834,1787304780,1906247262,2022837584,265905162,114585348,499347990,349075736,736970802,585122620,972512814,821712160,2595684844,2478443234,2293045232,2174754046,3196267988,3079546586,2895723464,2777952454,3537852828,3687994002,3234156416,3385345166,4142626212,4293295786,3841024952,3992742070,174567692,57326082,410887952,292596766,777231668,660510266,1011452712,893681702,1108339068,1258480242,1343618912,1494807662,1715193156,1865862730,1948373848,2100090966,2701949495,2818666809,3004591147,3122358053,2235061775,2352307457,2535604243,2653899549,3915653703,3764988233,4219352155,4067639125,3444575871,3294430577,3746175075,3594982253,836553431,953270745,600235211,718002117,367585007,484830689,133361907,251657213,2041877159,1891211689,1806599355,1654886325,1568718495,1418573201,1335535747,1184342925];class $J{get key(){return O0(this,VJ,"f").slice()}constructor(Q){if(VJ.set(this,void 0),y0.set(this,void 0),t0.set(this,void 0),!(this instanceof $J))throw Error("AES must be instanitated with `new`");w5(this,VJ,new Uint8Array(Q),"f");const Y=MU[this.key.length];if(Y==null)throw new TypeError("invalid key size (must be 16, 24 or 32 bytes)");w5(this,t0,[],"f"),w5(this,y0,[],"f");for(let V=0;V<=Y;V++)O0(this,t0,"f").push([0,0,0,0]),O0(this,y0,"f").push([0,0,0,0]);const J=(Y+1)*4,X=this.key.length/4,q=F5(this.key);let G;for(let V=0;V<X;V++)G=V>>2,O0(this,t0,"f")[G][V%4]=q[V],O0(this,y0,"f")[Y-G][V%4]=q[V];let U=0,W=X,$;while(W<J){if($=q[X-1],q[0]^=g0[$>>16&255]<<24^g0[$>>8&255]<<16^g0[$&255]<<8^g0[$>>24&255]^KU[U]<<24,U+=1,X!=8)for(let K=1;K<X;K++)q[K]^=q[K-1];else{for(let K=1;K<X/2;K++)q[K]^=q[K-1];$=q[X/2-1],q[X/2]^=g0[$&255]^g0[$>>8&255]<<8^g0[$>>16&255]<<16^g0[$>>24&255]<<24;for(let K=X/2+1;K<X;K++)q[K]^=q[K-1]}let V=0,z,M;while(V<X&&W<J)z=W>>2,M=W%4,O0(this,t0,"f")[z][M]=q[V],O0(this,y0,"f")[Y-z][M]=q[V++],W++}for(let V=1;V<Y;V++)for(let z=0;z<4;z++)$=O0(this,y0,"f")[V][z],O0(this,y0,"f")[V][z]=CU[$>>24&255]^TU[$>>16&255]^NU[$>>8&255]^wU[$&255]}encrypt(Q){if(Q.length!=16)throw new TypeError("invalid plaintext size (must be 16 bytes)");const Y=O0(this,t0,"f").length-1,J=[0,0,0,0];let X=F5(Q);for(let U=0;U<4;U++)X[U]^=O0(this,t0,"f")[0][U];for(let U=1;U<Y;U++){for(let W=0;W<4;W++)J[W]=jU[X[W]>>24&255]^OU[X[(W+1)%4]>>16&255]^DU[X[(W+2)%4]>>8&255]^IU[X[(W+3)%4]&255]^O0(this,t0,"f")[U][W];X=J.slice()}const q=new Uint8Array(16);let G=0;for(let U=0;U<4;U++)G=O0(this,t0,"f")[Y][U],q[4*U]=(g0[X[U]>>24&255]^G>>24)&255,q[4*U+1]=(g0[X[(U+1)%4]>>16&255]^G>>16)&255,q[4*U+2]=(g0[X[(U+2)%4]>>8&255]^G>>8)&255,q[4*U+3]=(g0[X[(U+3)%4]&255]^G)&255;return q}decrypt(Q){if(Q.length!=16)throw new TypeError("invalid ciphertext size (must be 16 bytes)");const Y=O0(this,y0,"f").length-1,J=[0,0,0,0];let X=F5(Q);for(let U=0;U<4;U++)X[U]^=O0(this,y0,"f")[0][U];for(let U=1;U<Y;U++){for(let W=0;W<4;W++)J[W]=LU[X[W]>>24&255]^HU[X[(W+3)%4]>>16&255]^RU[X[(W+2)%4]>>8&255]^PU[X[(W+1)%4]&255]^O0(this,y0,"f")[U][W];X=J.slice()}const q=new Uint8Array(16);let G=0;for(let U=0;U<4;U++)G=O0(this,y0,"f")[Y][U],q[4*U]=(WJ[X[U]>>24&255]^G>>24)&255,q[4*U+1]=(WJ[X[(U+3)%4]>>16&255]^G>>16)&255,q[4*U+2]=(WJ[X[(U+2)%4]>>8&255]^G>>8)&255,q[4*U+3]=(WJ[X[(U+1)%4]&255]^G)&255;return q}}VJ=new WeakMap,y0=new WeakMap,t0=new WeakMap;class t9{constructor(Q,Y,J){if(J&&!(this instanceof J))throw new Error(`${Q} must be instantiated with "new"`);Object.defineProperties(this,{aes:{enumerable:!0,value:new $J(Y)},name:{enumerable:!0,value:Q}})}}var zJ=function(Q,Y,J,X,q){if(X==="m")throw new TypeError("Private method is not writable");if(X==="a"&&!q)throw new TypeError("Private accessor was defined without a setter");if(typeof Y==="function"?Q!==Y||!q:!Y.has(Q))throw new TypeError("Cannot write private member to an object whose class did not declare it");return X==="a"?q.call(Q,J):q?q.value=J:Y.set(Q,J),J},F9=function(Q,Y,J,X){if(J==="a"&&!X)throw new TypeError("Private accessor was defined without a getter");if(typeof Y==="function"?Q!==Y||!X:!Y.has(Q))throw new TypeError("Cannot read private member from an object whose class did not declare it");return J==="m"?X:J==="a"?X.call(Q):X?X.value:Y.get(Q)},e9,C8;class QQ extends t9{constructor(Q,Y){super("ECC",Q,QQ);if(e9.set(this,void 0),C8.set(this,void 0),Y){if(Y.length%16)throw new TypeError("invalid iv size (must be 16 bytes)");zJ(this,e9,new Uint8Array(Y),"f")}else zJ(this,e9,new Uint8Array(16),"f");zJ(this,C8,this.iv,"f")}get iv(){return new Uint8Array(F9(this,e9,"f"))}encrypt(Q){if(Q.length%16)throw new TypeError("invalid plaintext size (must be multiple of 16 bytes)");const Y=new Uint8Array(Q.length);for(let J=0;J<Q.length;J+=16){for(let X=0;X<16;X++)F9(this,C8,"f")[X]^=Q[J+X];zJ(this,C8,this.aes.encrypt(F9(this,C8,"f")),"f"),Y.set(F9(this,C8,"f"),J)}return Y}decrypt(Q){if(Q.length%16)throw new TypeError("invalid ciphertext size (must be multiple of 16 bytes)");const Y=new Uint8Array(Q.length);for(let J=0;J<Q.length;J+=16){const X=this.aes.decrypt(Q.subarray(J,J+16));for(let q=0;q<16;q++)Y[J+q]=X[q]^F9(this,C8,"f")[q],F9(this,C8,"f")[q]=Q[J+q]}return Y}}e9=new WeakMap,C8=new WeakMap;var B9=function(Q,Y,J,X,q){if(X==="m")throw new TypeError("Private method is not writable");if(X==="a"&&!q)throw new TypeError("Private accessor was defined without a setter");if(typeof Y==="function"?Q!==Y||!q:!Y.has(Q))throw new TypeError("Cannot write private member to an object whose class did not declare it");return X==="a"?q.call(Q,J):q?q.value=J:Y.set(Q,J),J},h0=function(Q,Y,J,X){if(J==="a"&&!X)throw new TypeError("Private accessor was defined without a getter");if(typeof Y==="function"?Q!==Y||!X:!Y.has(Q))throw new TypeError("Cannot read private member from an object whose class did not declare it");return J==="m"?X:J==="a"?X.call(Q):X?X.value:Y.get(Q)},JQ,Y9,m0;class b8 extends t9{constructor(Q,Y){super("CTR",Q,b8);if(JQ.set(this,void 0),Y9.set(this,void 0),m0.set(this,void 0),B9(this,m0,new Uint8Array(16),"f"),h0(this,m0,"f").fill(0),B9(this,JQ,h0(this,m0,"f"),"f"),B9(this,Y9,16,"f"),Y==null)Y=1;if(typeof Y==="number")this.setCounterValue(Y);else this.setCounterBytes(Y)}get counter(){return new Uint8Array(h0(this,m0,"f"))}setCounterValue(Q){if(!Number.isInteger(Q)||Q<0||Q>Number.MAX_SAFE_INTEGER)throw new TypeError("invalid counter initial integer value");for(let Y=15;Y>=0;--Y)h0(this,m0,"f")[Y]=Q%256,Q=Math.floor(Q/256)}setCounterBytes(Q){if(Q.length!==16)throw new TypeError("invalid counter initial Uint8Array value length");h0(this,m0,"f").set(Q)}increment(){for(let Q=15;Q>=0;Q--)if(h0(this,m0,"f")[Q]===255)h0(this,m0,"f")[Q]=0;else{h0(this,m0,"f")[Q]++;break}}encrypt(Q){var Y,J;const X=new Uint8Array(Q);for(let q=0;q<X.length;q++){if(h0(this,Y9,"f")===16)B9(this,JQ,this.aes.encrypt(h0(this,m0,"f")),"f"),B9(this,Y9,0,"f"),this.increment();X[q]^=h0(this,JQ,"f")[B9(this,Y9,(J=h0(this,Y9,"f"),Y=J++,J),"f"),Y]}return X}decrypt(Q){return this.encrypt(Q)}}JQ=new WeakMap,Y9=new WeakMap,m0=new WeakMap;function B5(Q){if(Q.length<16)throw new TypeError("PKCS#7 invalid length");const Y=Q[Q.length-1];if(Y>16)throw new TypeError("PKCS#7 padding byte out of range");const J=Q.length-Y;for(let X=0;X<Y;X++)if(Q[J+X]!==Y)throw new TypeError("PKCS#7 invalid padding byte");return new Uint8Array(Q.subarray(0,J))}function E5(Q){if(typeof Q==="string"&&!Q.startsWith("0x"))Q="0x"+Q;return u0(Q)}function E9(Q,Y){Q=String(Q);while(Q.length<Y)Q="0"+Q;return Q}function X9(Q){if(typeof Q==="string")return z0(Q,"NFKC");return u0(Q)}function Y0(Q,Y){const J=Y.match(/^([a-z0-9$_.-]*)(:([a-z]+))?(!)?$/i);O(J!=null,"invalid path","path",Y);const X=J[1],q=J[3],G=J[4]==="!";let U=Q;for(let W of X.toLowerCase().split(".")){if(Array.isArray(U)){if(!W.match(/^[0-9]+$/))break;U=U[parseInt(W)]}else if(typeof U==="object"){let $=null;for(let V in U)if(V.toLowerCase()===W){$=U[V];break}U=$}else U=null;if(U==null)break}if(O(!G||U!=null,"missing required value","path",X),q&&U!=null){if(q==="int"){if(typeof U==="string"&&U.match(/^-?[0-9]+$/))return parseInt(U);else if(Number.isSafeInteger(U))return U}if(q==="number"){if(typeof U==="string"&&U.match(/^-?[0-9.]*$/))return parseFloat(U)}if(q==="data"){if(typeof U==="string")return E5(U)}if(q==="array"&&Array.isArray(U))return U;if(q===typeof U)return U;O(!1,`wrong type found for ${q} `,"path",X)}return U}function MJ(Q){try{const Y=JSON.parse(Q);if((Y.version!=null?parseInt(Y.version):0)===3)return!0}catch(Y){}return!1}var FU=function(Q,Y,J){if(Y0(Q,"crypto.cipher:string")==="aes-128-ctr"){const q=Y0(Q,"crypto.cipherparams.iv:data!"),G=new b8(Y,q);return T(G.decrypt(J))}x(!1,"unsupported cipher","UNSUPPORTED_OPERATION",{operation:"decrypt"})},ZJ=function(Q,Y){const J=N(Y),X=Y0(Q,"crypto.ciphertext:data!"),q=T(n(o([J.slice(16,32),X]))).substring(2);O(q===Y0(Q,"crypto.mac:string!").toLowerCase(),"incorrect password","password","[ REDACTED ]");const G=FU(Q,J.slice(0,16),X),U=L8(G);if(Q.address){let V=Q.address.toLowerCase();if(!V.startsWith("0x"))V="0x"+V;O(y(V)===U,"keystore address/privateKey mismatch","address",Q.address)}const W={address:U,privateKey:G};if(Y0(Q,"x-ethers.version:string")==="0.1"){const V=J.slice(32,64),z=Y0(Q,"x-ethers.mnemonicCiphertext:data!"),M=Y0(Q,"x-ethers.mnemonicCounter:data!"),K=new b8(V,M);W.mnemonic={path:Y0(Q,"x-ethers.path:string")||Zq,locale:Y0(Q,"x-ethers.locale:string")||"en",entropy:T(N(K.decrypt(z)))}}return W},Mq=function(Q){const Y=Y0(Q,"crypto.kdf:string");if(Y&&typeof Y==="string"){if(Y.toLowerCase()==="scrypt"){const J=Y0(Q,"crypto.kdfparams.salt:data!"),X=Y0(Q,"crypto.kdfparams.n:int!"),q=Y0(Q,"crypto.kdfparams.r:int!"),G=Y0(Q,"crypto.kdfparams.p:int!");O(X>0&&(X&X-1)===0,"invalid kdf.N","kdf.N",X),O(q>0&&G>0,"invalid kdf","kdf",Y);const U=Y0(Q,"crypto.kdfparams.dklen:int!");return O(U===32,"invalid kdf.dklen","kdf.dflen",U),{name:"scrypt",salt:J,N:X,r:q,p:G,dkLen:64}}else if(Y.toLowerCase()==="pbkdf2"){const J=Y0(Q,"crypto.kdfparams.salt:data!"),X=Y0(Q,"crypto.kdfparams.prf:string!"),q=X.split("-").pop();O(q==="sha256"||q==="sha512","invalid kdf.pdf","kdf.pdf",X);const G=Y0(Q,"crypto.kdfparams.c:int!"),U=Y0(Q,"crypto.kdfparams.dklen:int!");return O(U===32,"invalid kdf.dklen","kdf.dklen",U),{name:"pbkdf2",salt:J,count:G,dkLen:U,algorithm:q}}}O(!1,"unsupported key-derivation function","kdf",Y)};function S5(Q,Y){const J=JSON.parse(Q),X=X9(Y),q=Mq(J);if(q.name==="pbkdf2"){const{salt:M,count:K,dkLen:j,algorithm:Z}=q,D=S0(X,M,K,j,Z);return ZJ(J,D)}x(q.name==="scrypt","cannot be reached","UNKNOWN_ERROR",{params:q});const{salt:G,N:U,r:W,p:$,dkLen:V}=q,z=K8(X,G,U,W,$,V);return ZJ(J,z)}var zq=function(Q){return new Promise((Y)=>{setTimeout(()=>{Y()},Q)})};async function A5(Q,Y,J){const X=JSON.parse(Q),q=X9(Y),G=Mq(X);if(G.name==="pbkdf2"){if(J)J(0),await zq(0);const{salt:K,count:j,dkLen:Z,algorithm:D}=G,I=S0(q,K,j,Z,D);if(J)J(1),await zq(0);return ZJ(X,I)}x(G.name==="scrypt","cannot be reached","UNKNOWN_ERROR",{params:G});const{salt:U,N:W,r:$,p:V,dkLen:z}=G,M=await M8(q,U,W,$,V,z,J);return ZJ(X,M)}var Kq=function(Q){const Y=Q.salt!=null?N(Q.salt,"options.salt"):W0(32);let J=1<<17,X=8,q=1;if(Q.scrypt){if(Q.scrypt.N)J=Q.scrypt.N;if(Q.scrypt.r)X=Q.scrypt.r;if(Q.scrypt.p)q=Q.scrypt.p}return O(typeof J==="number"&&J>0&&Number.isSafeInteger(J)&&(BigInt(J)&BigInt(J-1))===BigInt(0),"invalid scrypt N parameter","options.N",J),O(typeof X==="number"&&X>0&&Number.isSafeInteger(X),"invalid scrypt r parameter","options.r",X),O(typeof q==="number"&&q>0&&Number.isSafeInteger(q),"invalid scrypt p parameter","options.p",q),{name:"scrypt",dkLen:32,salt:Y,N:J,r:X,p:q}},jq=function(Q,Y,J,X){const q=N(J.privateKey,"privateKey"),G=X.iv!=null?N(X.iv,"options.iv"):W0(16);O(G.length===16,"invalid options.iv length","options.iv",X.iv);const U=X.uuid!=null?N(X.uuid,"options.uuid"):W0(16);O(U.length===16,"invalid options.uuid length","options.uuid",X.iv);const W=Q.slice(0,16),$=Q.slice(16,32),V=new b8(W,G),z=N(V.encrypt(q)),M=n(o([$,z])),K={address:J.address.substring(2).toLowerCase(),id:gQ(U),version:3,Crypto:{cipher:"aes-128-ctr",cipherparams:{iv:T(G).substring(2)},ciphertext:T(z).substring(2),kdf:"scrypt",kdfparams:{salt:T(Y.salt).substring(2),n:Y.N,dklen:32,p:Y.p,r:Y.r},mac:M.substring(2)}};if(J.mnemonic){const j=X.client!=null?X.client:`ethers/${FQ}`,Z=J.mnemonic.path||Zq,D=J.mnemonic.locale||"en",I=Q.slice(32,64),L=N(J.mnemonic.entropy,"account.mnemonic.entropy"),R=W0(16),F=new b8(I,R),H=N(F.encrypt(L)),C=new Date,P="UTC--"+(C.getUTCFullYear()+"-"+E9(C.getUTCMonth()+1,2)+"-"+E9(C.getUTCDate(),2)+"T"+E9(C.getUTCHours(),2)+"-"+E9(C.getUTCMinutes(),2)+"-"+E9(C.getUTCSeconds(),2)+".0Z--")+K.address;K["x-ethers"]={client:j,gethFilename:P,path:Z,locale:D,mnemonicCounter:T(R).substring(2),mnemonicCiphertext:T(H).substring(2),version:"0.1"}}return JSON.stringify(K)};function YQ(Q,Y,J){if(J==null)J={};const X=X9(Y),q=Kq(J),G=K8(X,q.salt,q.N,q.r,q.p,64);return jq(N(G),q,Q,J)}async function XQ(Q,Y,J){if(J==null)J={};const X=X9(Y),q=Kq(J),G=await M8(X,q.salt,q.N,q.r,q.p,64,J.progressCallback);return jq(N(G),q,Q,J)}var Zq="m/44'/60'/0'/0/0";var jJ=function(Q,Y){let J="";while(Q)J=SU[Q%16]+J,Q=Math.trunc(Q/16);while(J.length<Y*2)J="0"+J;return"0x"+J},k5=function(Q){const Y=N(Q),J=I9(j0(j0(Y)),0,4),X=o([Y,J]);return fQ(X)},Oq=function(Q,Y,J,X){const q=new Uint8Array(37);if(Q&v8)x(X!=null,"cannot derive child of neutered node","UNSUPPORTED_OPERATION",{operation:"deriveChild"}),q.set(N(X),1);else q.set(N(J));for(let U=24;U>=0;U-=8)q[33+(U>>3)]=Q>>24-U&255;const G=N(z8("sha512",Y,q));return{IL:G.slice(0,32),IR:G.slice(32)}},Dq=function(Q,Y){const J=Y.split("/");if(O(J.length>0,"invalid path","path",Y),J[0]==="m")O(Q.depth===0,`cannot derive root path (i.e. path starting with "m/") for a node at non-zero depth ${Q.depth}`,"path",Y),J.shift();let X=Q;for(let q=0;q<J.length;q++){const G=J[q];if(G.match(/^[0-9]+'$/)){const U=parseInt(G.substring(0,G.length-1));O(U<v8,"invalid path index",`path[${q}]`,G),X=X.deriveChild(v8+U)}else if(G.match(/^[0-9]+$/)){const U=parseInt(G);O(U<v8,"invalid path index",`path[${q}]`,G),X=X.deriveChild(U)}else O(!1,"invalid path component",`path[${q}]`,G)}return X};var KJ="m/44'/60'/0'/0/0",BU=new Uint8Array([66,105,116,99,111,105,110,32,115,101,101,100]),v8=2147483648,EU=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),SU="0123456789abcdef",e0={};class N0 extends J9{publicKey;fingerprint;parentFingerprint;mnemonic;chainCode;path;index;depth;constructor(Q,Y,J,X,q,G,U,W,$){super(Y,$);U8(Q,e0,"HDNodeWallet"),s(this,{publicKey:Y.compressedPublicKey});const V=I9(Z8(j0(this.publicKey)),0,4);s(this,{parentFingerprint:J,fingerprint:V,chainCode:X,path:q,index:G,depth:U}),s(this,{mnemonic:W})}connect(Q){return new N0(e0,this.signingKey,this.parentFingerprint,this.chainCode,this.path,this.index,this.depth,this.mnemonic,Q)}#Q(){const Q={address:this.address,privateKey:this.privateKey},Y=this.mnemonic;if(this.path&&Y&&Y.wordlist.locale==="en"&&Y.password==="")Q.mnemonic={path:this.path,locale:"en",entropy:Y.entropy};return Q}async encrypt(Q,Y){return await XQ(this.#Q(),Q,{progressCallback:Y})}encryptSync(Q){return YQ(this.#Q(),Q)}get extendedKey(){return x(this.depth<256,"Depth too deep","UNSUPPORTED_OPERATION",{operation:"extendedKey"}),k5(o(["0x0488ADE4",jJ(this.depth,1),this.parentFingerprint,jJ(this.index,4),this.chainCode,o(["0x00",this.privateKey])]))}hasPath(){return this.path!=null}neuter(){return new S9(e0,this.address,this.publicKey,this.parentFingerprint,this.chainCode,this.path,this.index,this.depth,this.provider)}deriveChild(Q){const Y=$0(Q,"index");O(Y<=4294967295,"invalid index","index",Y);let J=this.path;if(J){if(J+="/"+(Y&~v8),Y&v8)J+="'"}const{IR:X,IL:q}=Oq(Y,this.chainCode,this.publicKey,this.privateKey),G=new q0(d0((H9(q)+BigInt(this.privateKey))%EU,32));return new N0(e0,G,this.fingerprint,T(X),J,Y,this.depth+1,this.mnemonic,this.provider)}derivePath(Q){return Dq(this,Q)}static#J(Q,Y){O(a0(Q),"invalid seed","seed","[REDACTED]");const J=N(Q,"seed");O(J.length>=16&&J.length<=64,"invalid seed","seed","[REDACTED]");const X=N(z8("sha512",BU,J)),q=new q0(T(X.slice(0,32)));return new N0(e0,q,"0x00000000",T(X.slice(32)),"m",0,0,Y,null)}static fromExtendedKey(Q){const Y=t(bQ(Q));O(Y.length===82||k5(Y.slice(0,78))===Q,"invalid extended key","extendedKey","[ REDACTED ]");const J=Y[4],X=T(Y.slice(5,9)),q=parseInt(T(Y.slice(9,13)).substring(2),16),G=T(Y.slice(13,45)),U=Y.slice(45,78);switch(T(Y.slice(0,4))){case"0x0488b21e":case"0x043587cf":{const W=T(U);return new S9(e0,L8(W),W,X,G,null,q,J,null)}case"0x0488ade4":case"0x04358394 ":if(U[0]!==0)break;return new N0(e0,new q0(U.slice(1)),X,G,null,q,J,null,null)}O(!1,"invalid extended key prefix","extendedKey","[ REDACTED ]")}static createRandom(Q,Y,J){if(Q==null)Q="";if(Y==null)Y=KJ;if(J==null)J=R8.wordlist();const X=P8.fromEntropy(W0(16),Q,J);return N0.#J(X.computeSeed(),X).derivePath(Y)}static fromMnemonic(Q,Y){if(!Y)Y=KJ;return N0.#J(Q.computeSeed(),Q).derivePath(Y)}static fromPhrase(Q,Y,J,X){if(Y==null)Y="";if(J==null)J=KJ;if(X==null)X=R8.wordlist();const q=P8.fromPhrase(Q,Y,X);return N0.#J(q.computeSeed(),q).derivePath(J)}static fromSeed(Q){return N0.#J(Q,null)}}class S9 extends s9{publicKey;fingerprint;parentFingerprint;chainCode;path;index;depth;constructor(Q,Y,J,X,q,G,U,W,$){super(Y,$);U8(Q,e0,"HDNodeVoidWallet"),s(this,{publicKey:J});const V=I9(Z8(j0(J)),0,4);s(this,{publicKey:J,fingerprint:V,parentFingerprint:X,chainCode:q,path:G,index:U,depth:W})}connect(Q){return new S9(e0,this.address,this.publicKey,this.parentFingerprint,this.chainCode,this.path,this.index,this.depth,Q)}get extendedKey(){return x(this.depth<256,"Depth too deep","UNSUPPORTED_OPERATION",{operation:"extendedKey"}),k5(o(["0x0488B21E",jJ(this.depth,1),this.parentFingerprint,jJ(this.index,4),this.chainCode,this.publicKey]))}hasPath(){return this.path!=null}deriveChild(Q){const Y=$0(Q,"index");O(Y<=4294967295,"invalid index","index",Y);let J=this.path;if(J){if(J+="/"+(Y&~v8),Y&v8)J+="'"}const{IR:X,IL:q}=Oq(Y,this.chainCode,this.publicKey,null),G=q0.addPoints(q,this.publicKey,!0),U=L8(G);return new S9(e0,U,G,this.fingerprint,T(X),J,Y,this.depth+1,this.provider)}derivePath(Q){return Dq(this,Q)}}function OJ(Q){try{if(JSON.parse(Q).encseed)return!0}catch(Y){}return!1}function DJ(Q,Y){const J=JSON.parse(Q),X=X9(Y),q=y(Y0(J,"ethaddr:string!")),G=E5(Y0(J,"encseed:string!"));O(G&&G.length%16===0,"invalid encseed","json",Q);const U=N(S0(X,X,2000,32,"sha256")).slice(0,16),W=G.slice(0,16),$=G.slice(16),V=new QQ(U,W),z=B5(N(V.decrypt($)));let M="";for(let K=0;K<z.length;K++)M+=String.fromCharCode(z[K]);return{address:q,privateKey:H8(M)}}var Iq=function(Q){return new Promise((Y)=>{setTimeout(()=>{Y()},Q)})};class _0 extends J9{constructor(Q,Y){if(typeof Q==="string"&&!Q.startsWith("0x"))Q="0x"+Q;let J=typeof Q==="string"?new q0(Q):Q;super(J,Y)}connect(Q){return new _0(this.signingKey,Q)}async encrypt(Q,Y){const J={address:this.address,privateKey:this.privateKey};return await XQ(J,Q,{progressCallback:Y})}encryptSync(Q){const Y={address:this.address,privateKey:this.privateKey};return YQ(Y,Q)}static#Q(Q){if(O(Q,"invalid JSON wallet","json","[ REDACTED ]"),("mnemonic"in Q)&&Q.mnemonic&&Q.mnemonic.locale==="en"){const J=P8.fromEntropy(Q.mnemonic.entropy),X=N0.fromMnemonic(J,Q.mnemonic.path);if(X.address===Q.address&&X.privateKey===Q.privateKey)return X;console.log("WARNING: JSON mismatch address/privateKey != mnemonic; fallback onto private key")}const Y=new _0(Q.privateKey);return O(Y.address===Q.address,"address/privateKey mismatch","json","[ REDACTED ]"),Y}static async fromEncryptedJson(Q,Y,J){let X=null;if(MJ(Q))X=await A5(Q,Y,J);else if(OJ(Q)){if(J)J(0),await Iq(0);if(X=DJ(Q,Y),J)J(1),await Iq(0)}return _0.#Q(X)}static fromEncryptedJsonSync(Q,Y){let J=null;if(MJ(Q))J=S5(Q,Y);else if(OJ(Q))J=DJ(Q,Y);else O(!1,"invalid JSON wallet","json","[ REDACTED ]");return _0.#Q(J)}static createRandom(Q){const Y=N0.createRandom();if(Q)return Y.connect(Q);return Y}static fromPhrase(Q,Y){const J=N0.fromPhrase(Q);if(Y)return J.connect(Y);return J}}var v9=function(Q){let Y=Q.length;while(--Y>=0)Q[Y]=0},f5=function(Q,Y,J,X,q){this.static_tree=Q,this.extra_bits=Y,this.extra_base=J,this.elems=X,this.max_length=q,this.has_stree=Q&&Q.length},b5=function(Q,Y){this.dyn_tree=Q,this.max_code=0,this.stat_desc=Y},Q8=function(Q,Y,J,X,q){this.good_length=Q,this.max_lazy=Y,this.nice_length=J,this.max_chain=X,this.func=q},xW=function(){this.strm=null,this.status=0,this.pending_buf=null,this.pending_buf_size=0,this.pending_out=0,this.pending=0,this.wrap=0,this.gzhead=null,this.gzindex=0,this.method=FJ,this.last_flush=-1,this.w_size=0,this.w_bits=0,this.w_mask=0,this.window=null,this.window_size=0,this.prev=null,this.head=null,this.ins_h=0,this.hash_size=0,this.hash_bits=0,this.hash_mask=0,this.hash_shift=0,this.block_start=0,this.match_length=0,this.prev_match=0,this.match_available=0,this.strstart=0,this.match_start=0,this.lookahead=0,this.prev_length=0,this.max_chain_length=0,this.max_lazy_match=0,this.level=0,this.strategy=0,this.good_match=0,this.nice_match=0,this.dyn_ltree=new Uint16Array(TW*2),this.dyn_dtree=new Uint16Array((2*PW+1)*2),this.bl_tree=new Uint16Array((2*CW+1)*2),g8(this.dyn_ltree),g8(this.dyn_dtree),g8(this.bl_tree),this.l_desc=null,this.d_desc=null,this.bl_desc=null,this.bl_count=new Uint16Array(NW+1),this.heap=new Uint16Array(2*r5+1),g8(this.heap),this.heap_len=0,this.heap_max=0,this.depth=new Uint16Array(2*r5+1),g8(this.depth),this.sym_buf=0,this.lit_bufsize=0,this.sym_next=0,this.sym_end=0,this.opt_len=0,this.static_len=0,this.matches=0,this.insert=0,this.bi_buf=0,this.bi_valid=0},QV=function(){this.input=null,this.next_in=0,this.avail_in=0,this.total_in=0,this.output=null,this.next_out=0,this.avail_out=0,this.total_out=0,this.msg="",this.state=null,this.data_type=2,this.adler=0},RQ=function(Q){this.options=BJ.assign({level:UV,method:VV,chunkSize:16384,windowBits:15,memLevel:8,strategy:WV},Q||{});let Y=this.options;if(Y.raw&&Y.windowBits>0)Y.windowBits=-Y.windowBits;else if(Y.gzip&&Y.windowBits>0&&Y.windowBits<16)Y.windowBits+=16;this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new T7,this.strm.avail_out=0;let J=VQ.deflateInit2(this.strm,Y.level,Y.method,Y.windowBits,Y.memLevel,Y.strategy);if(J!==NJ)throw new Error(W9[J]);if(Y.header)VQ.deflateSetHeader(this.strm,Y.header);if(Y.dictionary){let X;if(typeof Y.dictionary==="string")X=DQ.string2buf(Y.dictionary);else if(N7.call(Y.dictionary)==="[object ArrayBuffer]")X=new Uint8Array(Y.dictionary);else X=Y.dictionary;if(J=VQ.deflateSetDictionary(this.strm,X),J!==NJ)throw new Error(W9[J]);this._dict_set=!0}},UY=function(Q,Y){const J=new RQ(Y);if(J.push(Q,!0),J.err)throw J.msg||W9[J.err];return J.result},$V=function(Q,Y){return Y=Y||{},Y.raw=!0,UY(Q,Y)},zV=function(Q,Y){return Y=Y||{},Y.gzip=!0,UY(Q,Y)},fV=function(){this.strm=null,this.mode=0,this.last=!1,this.wrap=0,this.havedict=!1,this.flags=0,this.dmax=0,this.check=0,this.total=0,this.head=null,this.wbits=0,this.wsize=0,this.whave=0,this.wnext=0,this.window=null,this.hold=0,this.bits=0,this.length=0,this.offset=0,this.extra=0,this.lencode=null,this.distcode=null,this.lenbits=0,this.distbits=0,this.ncode=0,this.nlen=0,this.ndist=0,this.have=0,this.next=null,this.lens=new Uint16Array(320),this.work=new Uint16Array(288),this.lendyn=null,this.distdyn=null,this.sane=0,this.back=0,this.was=0},aV=function(){this.text=0,this.time=0,this.xflags=0,this.os=0,this.extra=null,this.extra_len=0,this.name="",this.comment="",this.hcrc=0,this.done=!1},PQ=function(Q){this.options=BJ.assign({chunkSize:65536,windowBits:15,to:""},Q||{});const Y=this.options;if(Y.raw&&Y.windowBits>=0&&Y.windowBits<16){if(Y.windowBits=-Y.windowBits,Y.windowBits===0)Y.windowBits=-15}if(Y.windowBits>=0&&Y.windowBits<16&&!(Q&&Q.windowBits))Y.windowBits+=32;if(Y.windowBits>15&&Y.windowBits<48){if((Y.windowBits&15)===0)Y.windowBits|=15}this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new T7,this.strm.avail_out=0;let J=w8.inflateInit2(this.strm,Y.windowBits);if(J!==IQ)throw new Error(W9[J]);if(this.header=new sV,w8.inflateGetHeader(this.strm,this.header),Y.dictionary){if(typeof Y.dictionary==="string")Y.dictionary=DQ.string2buf(Y.dictionary);else if(g7.call(Y.dictionary)==="[object ArrayBuffer]")Y.dictionary=new Uint8Array(Y.dictionary);if(Y.raw){if(J=w8.inflateSetDictionary(this.strm,Y.dictionary),J!==IQ)throw new Error(W9[J])}}},WY=function(Q,Y){const J=new PQ(Y);if(J.push(Q),J.err)throw J.msg||W9[J.err];return J.result},Y6=function(Q,Y){return Y=Y||{},Y.raw=!0,WY(Q,Y)};/*! pako 2.1.0 https://github.com/nodeca/pako @license (MIT AND Zlib) */var kU=0,Y7=1,xU=2,fU=3,bU=258,JY=29,LQ=256,zQ=LQ+1+JY,x9=30,YY=19,X7=2*zQ+1,q9=15,x5=16,vU=7,XY=256,q7=16,G7=17,U7=18,n5=new Uint8Array([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0]),CJ=new Uint8Array([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13]),gU=new Uint8Array([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7]),W7=new Uint8Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),yU=512,N8=new Array((zQ+2)*2);v9(N8);var WQ=new Array(x9*2);v9(WQ);var ZQ=new Array(yU);v9(ZQ);var MQ=new Array(bU-fU+1);v9(MQ);var qY=new Array(JY);v9(qY);var TJ=new Array(x9);v9(TJ);var V7,$7,z7,Z7=(Q)=>{return Q<256?ZQ[Q]:ZQ[256+(Q>>>7)]},KQ=(Q,Y)=>{Q.pending_buf[Q.pending++]=Y&255,Q.pending_buf[Q.pending++]=Y>>>8&255},w0=(Q,Y,J)=>{if(Q.bi_valid>x5-J)Q.bi_buf|=Y<<Q.bi_valid&65535,KQ(Q,Q.bi_buf),Q.bi_buf=Y>>x5-Q.bi_valid,Q.bi_valid+=J-x5;else Q.bi_buf|=Y<<Q.bi_valid&65535,Q.bi_valid+=J},J8=(Q,Y,J)=>{w0(Q,J[Y*2],J[Y*2+1])},M7=(Q,Y)=>{let J=0;do J|=Q&1,Q>>>=1,J<<=1;while(--Y>0);return J>>>1},hU=(Q)=>{if(Q.bi_valid===16)KQ(Q,Q.bi_buf),Q.bi_buf=0,Q.bi_valid=0;else if(Q.bi_valid>=8)Q.pending_buf[Q.pending++]=Q.bi_buf&255,Q.bi_buf>>=8,Q.bi_valid-=8},mU=(Q,Y)=>{const{dyn_tree:J,max_code:X}=Y,q=Y.stat_desc.static_tree,G=Y.stat_desc.has_stree,U=Y.stat_desc.extra_bits,W=Y.stat_desc.extra_base,$=Y.stat_desc.max_length;let V,z,M,K,j,Z,D=0;for(K=0;K<=q9;K++)Q.bl_count[K]=0;J[Q.heap[Q.heap_max]*2+1]=0;for(V=Q.heap_max+1;V<X7;V++){if(z=Q.heap[V],K=J[J[z*2+1]*2+1]+1,K>$)K=$,D++;if(J[z*2+1]=K,z>X)continue;if(Q.bl_count[K]++,j=0,z>=W)j=U[z-W];if(Z=J[z*2],Q.opt_len+=Z*(K+j),G)Q.static_len+=Z*(q[z*2+1]+j)}if(D===0)return;do{K=$-1;while(Q.bl_count[K]===0)K--;Q.bl_count[K]--,Q.bl_count[K+1]+=2,Q.bl_count[$]--,D-=2}while(D>0);for(K=$;K!==0;K--){z=Q.bl_count[K];while(z!==0){if(M=Q.heap[--V],M>X)continue;if(J[M*2+1]!==K)Q.opt_len+=(K-J[M*2+1])*J[M*2],J[M*2+1]=K;z--}}},K7=(Q,Y,J)=>{const X=new Array(q9+1);let q=0,G,U;for(G=1;G<=q9;G++)q=q+J[G-1]<<1,X[G]=q;for(U=0;U<=Y;U++){let W=Q[U*2+1];if(W===0)continue;Q[U*2]=M7(X[W]++,W)}},_U=()=>{let Q,Y,J,X,q;const G=new Array(q9+1);J=0;for(X=0;X<JY-1;X++){qY[X]=J;for(Q=0;Q<1<<n5[X];Q++)MQ[J++]=X}MQ[J-1]=X,q=0;for(X=0;X<16;X++){TJ[X]=q;for(Q=0;Q<1<<CJ[X];Q++)ZQ[q++]=X}q>>=7;for(;X<x9;X++){TJ[X]=q<<7;for(Q=0;Q<1<<CJ[X]-7;Q++)ZQ[256+q++]=X}for(Y=0;Y<=q9;Y++)G[Y]=0;Q=0;while(Q<=143)N8[Q*2+1]=8,Q++,G[8]++;while(Q<=255)N8[Q*2+1]=9,Q++,G[9]++;while(Q<=279)N8[Q*2+1]=7,Q++,G[7]++;while(Q<=287)N8[Q*2+1]=8,Q++,G[8]++;K7(N8,zQ+1,G);for(Q=0;Q<x9;Q++)WQ[Q*2+1]=5,WQ[Q*2]=M7(Q,5);V7=new f5(N8,n5,LQ+1,zQ,q9),$7=new f5(WQ,CJ,0,x9,q9),z7=new f5(new Array(0),gU,0,YY,vU)},j7=(Q)=>{let Y;for(Y=0;Y<zQ;Y++)Q.dyn_ltree[Y*2]=0;for(Y=0;Y<x9;Y++)Q.dyn_dtree[Y*2]=0;for(Y=0;Y<YY;Y++)Q.bl_tree[Y*2]=0;Q.dyn_ltree[XY*2]=1,Q.opt_len=Q.static_len=0,Q.sym_next=Q.matches=0},O7=(Q)=>{if(Q.bi_valid>8)KQ(Q,Q.bi_buf);else if(Q.bi_valid>0)Q.pending_buf[Q.pending++]=Q.bi_buf;Q.bi_buf=0,Q.bi_valid=0},Lq=(Q,Y,J,X)=>{const q=Y*2,G=J*2;return Q[q]<Q[G]||Q[q]===Q[G]&&X[Y]<=X[J]},v5=(Q,Y,J)=>{const X=Q.heap[J];let q=J<<1;while(q<=Q.heap_len){if(q<Q.heap_len&&Lq(Y,Q.heap[q+1],Q.heap[q],Q.depth))q++;if(Lq(Y,X,Q.heap[q],Q.depth))break;Q.heap[J]=Q.heap[q],J=q,q<<=1}Q.heap[J]=X},Hq=(Q,Y,J)=>{let X,q,G=0,U,W;if(Q.sym_next!==0)do if(X=Q.pending_buf[Q.sym_buf+G++]&255,X+=(Q.pending_buf[Q.sym_buf+G++]&255)<<8,q=Q.pending_buf[Q.sym_buf+G++],X===0)J8(Q,q,Y);else{if(U=MQ[q],J8(Q,U+LQ+1,Y),W=n5[U],W!==0)q-=qY[U],w0(Q,q,W);if(X--,U=Z7(X),J8(Q,U,J),W=CJ[U],W!==0)X-=TJ[U],w0(Q,X,W)}while(G<Q.sym_next);J8(Q,XY,Y)},i5=(Q,Y)=>{const J=Y.dyn_tree,X=Y.stat_desc.static_tree,q=Y.stat_desc.has_stree,G=Y.stat_desc.elems;let U,W,$=-1,V;Q.heap_len=0,Q.heap_max=X7;for(U=0;U<G;U++)if(J[U*2]!==0)Q.heap[++Q.heap_len]=$=U,Q.depth[U]=0;else J[U*2+1]=0;while(Q.heap_len<2)if(V=Q.heap[++Q.heap_len]=$<2?++$:0,J[V*2]=1,Q.depth[V]=0,Q.opt_len--,q)Q.static_len-=X[V*2+1];Y.max_code=$;for(U=Q.heap_len>>1;U>=1;U--)v5(Q,J,U);V=G;do U=Q.heap[1],Q.heap[1]=Q.heap[Q.heap_len--],v5(Q,J,1),W=Q.heap[1],Q.heap[--Q.heap_max]=U,Q.heap[--Q.heap_max]=W,J[V*2]=J[U*2]+J[W*2],Q.depth[V]=(Q.depth[U]>=Q.depth[W]?Q.depth[U]:Q.depth[W])+1,J[U*2+1]=J[W*2+1]=V,Q.heap[1]=V++,v5(Q,J,1);while(Q.heap_len>=2);Q.heap[--Q.heap_max]=Q.heap[1],mU(Q,Y),K7(J,$,Q.bl_count)},Rq=(Q,Y,J)=>{let X,q=-1,G,U=Y[1],W=0,$=7,V=4;if(U===0)$=138,V=3;Y[(J+1)*2+1]=65535;for(X=0;X<=J;X++){if(G=U,U=Y[(X+1)*2+1],++W<$&&G===U)continue;else if(W<V)Q.bl_tree[G*2]+=W;else if(G!==0){if(G!==q)Q.bl_tree[G*2]++;Q.bl_tree[q7*2]++}else if(W<=10)Q.bl_tree[G7*2]++;else Q.bl_tree[U7*2]++;if(W=0,q=G,U===0)$=138,V=3;else if(G===U)$=6,V=3;else $=7,V=4}},Pq=(Q,Y,J)=>{let X,q=-1,G,U=Y[1],W=0,$=7,V=4;if(U===0)$=138,V=3;for(X=0;X<=J;X++){if(G=U,U=Y[(X+1)*2+1],++W<$&&G===U)continue;else if(W<V)do J8(Q,G,Q.bl_tree);while(--W!==0);else if(G!==0){if(G!==q)J8(Q,G,Q.bl_tree),W--;J8(Q,q7,Q.bl_tree),w0(Q,W-3,2)}else if(W<=10)J8(Q,G7,Q.bl_tree),w0(Q,W-3,3);else J8(Q,U7,Q.bl_tree),w0(Q,W-11,7);if(W=0,q=G,U===0)$=138,V=3;else if(G===U)$=6,V=3;else $=7,V=4}},cU=(Q)=>{let Y;Rq(Q,Q.dyn_ltree,Q.l_desc.max_code),Rq(Q,Q.dyn_dtree,Q.d_desc.max_code),i5(Q,Q.bl_desc);for(Y=YY-1;Y>=3;Y--)if(Q.bl_tree[W7[Y]*2+1]!==0)break;return Q.opt_len+=3*(Y+1)+5+5+4,Y},pU=(Q,Y,J,X)=>{let q;w0(Q,Y-257,5),w0(Q,J-1,5),w0(Q,X-4,4);for(q=0;q<X;q++)w0(Q,Q.bl_tree[W7[q]*2+1],3);Pq(Q,Q.dyn_ltree,Y-1),Pq(Q,Q.dyn_dtree,J-1)},uU=(Q)=>{let Y=4093624447,J;for(J=0;J<=31;J++,Y>>>=1)if(Y&1&&Q.dyn_ltree[J*2]!==0)return 0;if(Q.dyn_ltree[18]!==0||Q.dyn_ltree[20]!==0||Q.dyn_ltree[26]!==0)return 1;for(J=32;J<LQ;J++)if(Q.dyn_ltree[J*2]!==0)return 1;return 0},Cq=!1,dU=(Q)=>{if(!Cq)_U(),Cq=!0;Q.l_desc=new b5(Q.dyn_ltree,V7),Q.d_desc=new b5(Q.dyn_dtree,$7),Q.bl_desc=new b5(Q.bl_tree,z7),Q.bi_buf=0,Q.bi_valid=0,j7(Q)},D7=(Q,Y,J,X)=>{if(w0(Q,(kU<<1)+(X?1:0),3),O7(Q),KQ(Q,J),KQ(Q,~J),J)Q.pending_buf.set(Q.window.subarray(Y,Y+J),Q.pending);Q.pending+=J},lU=(Q)=>{w0(Q,Y7<<1,3),J8(Q,XY,N8),hU(Q)},nU=(Q,Y,J,X)=>{let q,G,U=0;if(Q.level>0){if(Q.strm.data_type===2)Q.strm.data_type=uU(Q);if(i5(Q,Q.l_desc),i5(Q,Q.d_desc),U=cU(Q),q=Q.opt_len+3+7>>>3,G=Q.static_len+3+7>>>3,G<=q)q=G}else q=G=J+5;if(J+4<=q&&Y!==-1)D7(Q,Y,J,X);else if(Q.strategy===4||G===q)w0(Q,(Y7<<1)+(X?1:0),3),Hq(Q,N8,WQ);else w0(Q,(xU<<1)+(X?1:0),3),pU(Q,Q.l_desc.max_code+1,Q.d_desc.max_code+1,U+1),Hq(Q,Q.dyn_ltree,Q.dyn_dtree);if(j7(Q),X)O7(Q)},iU=(Q,Y,J)=>{if(Q.pending_buf[Q.sym_buf+Q.sym_next++]=Y,Q.pending_buf[Q.sym_buf+Q.sym_next++]=Y>>8,Q.pending_buf[Q.sym_buf+Q.sym_next++]=J,Y===0)Q.dyn_ltree[J*2]++;else Q.matches++,Y--,Q.dyn_ltree[(MQ[J]+LQ+1)*2]++,Q.dyn_dtree[Z7(Y)*2]++;return Q.sym_next===Q.sym_end},oU=dU,rU=D7,aU=nU,sU=iU,tU=lU,eU={_tr_init:oU,_tr_stored_block:rU,_tr_flush_block:aU,_tr_tally:sU,_tr_align:tU},QW=(Q,Y,J,X)=>{let q=Q&65535|0,G=Q>>>16&65535|0,U=0;while(J!==0){U=J>2000?2000:J,J-=U;do q=q+Y[X++]|0,G=G+q|0;while(--U);q%=65521,G%=65521}return q|G<<16|0},jQ=QW,JW=()=>{let Q,Y=[];for(var J=0;J<256;J++){Q=J;for(var X=0;X<8;X++)Q=Q&1?3988292384^Q>>>1:Q>>>1;Y[J]=Q}return Y},YW=new Uint32Array(JW()),XW=(Q,Y,J,X)=>{const q=YW,G=X+J;Q^=-1;for(let U=X;U<G;U++)Q=Q>>>8^q[(Q^Y[U])&255];return Q^-1},K0=XW,W9={2:"need dictionary",1:"stream end",0:"","-1":"file error","-2":"stream error","-3":"data error","-4":"insufficient memory","-5":"buffer error","-6":"incompatible version"},z9={Z_NO_FLUSH:0,Z_PARTIAL_FLUSH:1,Z_SYNC_FLUSH:2,Z_FULL_FLUSH:3,Z_FINISH:4,Z_BLOCK:5,Z_TREES:6,Z_OK:0,Z_STREAM_END:1,Z_NEED_DICT:2,Z_ERRNO:-1,Z_STREAM_ERROR:-2,Z_DATA_ERROR:-3,Z_MEM_ERROR:-4,Z_BUF_ERROR:-5,Z_NO_COMPRESSION:0,Z_BEST_SPEED:1,Z_BEST_COMPRESSION:9,Z_DEFAULT_COMPRESSION:-1,Z_FILTERED:1,Z_HUFFMAN_ONLY:2,Z_RLE:3,Z_FIXED:4,Z_DEFAULT_STRATEGY:0,Z_BINARY:0,Z_TEXT:1,Z_UNKNOWN:2,Z_DEFLATED:8},{_tr_init:qW,_tr_stored_block:o5,_tr_flush_block:GW,_tr_tally:h8,_tr_align:UW}=eU,{Z_NO_FLUSH:m8,Z_PARTIAL_FLUSH:WW,Z_FULL_FLUSH:VW,Z_FINISH:c0,Z_BLOCK:Tq,Z_OK:D0,Z_STREAM_END:Nq,Z_STREAM_ERROR:Y8,Z_DATA_ERROR:$W,Z_BUF_ERROR:g5,Z_DEFAULT_COMPRESSION:zW,Z_FILTERED:ZW,Z_HUFFMAN_ONLY:IJ,Z_RLE:MW,Z_FIXED:KW,Z_DEFAULT_STRATEGY:jW,Z_UNKNOWN:OW,Z_DEFLATED:FJ}=z9,DW=9,IW=15,LW=8,HW=29,RW=256,r5=RW+1+HW,PW=30,CW=19,TW=2*r5+1,NW=15,_=3,y8=258,X8=y8+_+1,wW=32,f9=42,GY=57,a5=69,s5=73,t5=91,e5=103,G9=113,GQ=666,C0=1,g9=2,V9=3,y9=4,FW=3,U9=(Q,Y)=>{return Q.msg=W9[Y],Y},wq=(Q)=>{return Q*2-(Q>4?9:0)},g8=(Q)=>{let Y=Q.length;while(--Y>=0)Q[Y]=0},BW=(Q)=>{let Y,J,X,q=Q.w_size;Y=Q.hash_size,X=Y;do J=Q.head[--X],Q.head[X]=J>=q?J-q:0;while(--Y);Y=q,X=Y;do J=Q.prev[--X],Q.prev[X]=J>=q?J-q:0;while(--Y)},EW=(Q,Y,J)=>(Y<<Q.hash_shift^J)&Q.hash_mask,_8=EW,x0=(Q)=>{const Y=Q.state;let J=Y.pending;if(J>Q.avail_out)J=Q.avail_out;if(J===0)return;if(Q.output.set(Y.pending_buf.subarray(Y.pending_out,Y.pending_out+J),Q.next_out),Q.next_out+=J,Y.pending_out+=J,Q.total_out+=J,Q.avail_out-=J,Y.pending-=J,Y.pending===0)Y.pending_out=0},f0=(Q,Y)=>{GW(Q,Q.block_start>=0?Q.block_start:-1,Q.strstart-Q.block_start,Y),Q.block_start=Q.strstart,x0(Q.strm)},i=(Q,Y)=>{Q.pending_buf[Q.pending++]=Y},qQ=(Q,Y)=>{Q.pending_buf[Q.pending++]=Y>>>8&255,Q.pending_buf[Q.pending++]=Y&255},QY=(Q,Y,J,X)=>{let q=Q.avail_in;if(q>X)q=X;if(q===0)return 0;if(Q.avail_in-=q,Y.set(Q.input.subarray(Q.next_in,Q.next_in+q),J),Q.state.wrap===1)Q.adler=jQ(Q.adler,Y,q,J);else if(Q.state.wrap===2)Q.adler=K0(Q.adler,Y,q,J);return Q.next_in+=q,Q.total_in+=q,q},I7=(Q,Y)=>{let{max_chain_length:J,strstart:X}=Q,q,G,U=Q.prev_length,W=Q.nice_match;const $=Q.strstart>Q.w_size-X8?Q.strstart-(Q.w_size-X8):0,V=Q.window,z=Q.w_mask,M=Q.prev,K=Q.strstart+y8;let j=V[X+U-1],Z=V[X+U];if(Q.prev_length>=Q.good_match)J>>=2;if(W>Q.lookahead)W=Q.lookahead;do{if(q=Y,V[q+U]!==Z||V[q+U-1]!==j||V[q]!==V[X]||V[++q]!==V[X+1])continue;X+=2,q++;do;while(V[++X]===V[++q]&&V[++X]===V[++q]&&V[++X]===V[++q]&&V[++X]===V[++q]&&V[++X]===V[++q]&&V[++X]===V[++q]&&V[++X]===V[++q]&&V[++X]===V[++q]&&X<K);if(G=y8-(K-X),X=K-y8,G>U){if(Q.match_start=Y,U=G,G>=W)break;j=V[X+U-1],Z=V[X+U]}}while((Y=M[Y&z])>$&&--J!==0);if(U<=Q.lookahead)return U;return Q.lookahead},b9=(Q)=>{const Y=Q.w_size;let J,X,q;do{if(X=Q.window_size-Q.lookahead-Q.strstart,Q.strstart>=Y+(Y-X8)){if(Q.window.set(Q.window.subarray(Y,Y+Y-X),0),Q.match_start-=Y,Q.strstart-=Y,Q.block_start-=Y,Q.insert>Q.strstart)Q.insert=Q.strstart;BW(Q),X+=Y}if(Q.strm.avail_in===0)break;if(J=QY(Q.strm,Q.window,Q.strstart+Q.lookahead,X),Q.lookahead+=J,Q.lookahead+Q.insert>=_){q=Q.strstart-Q.insert,Q.ins_h=Q.window[q],Q.ins_h=_8(Q,Q.ins_h,Q.window[q+1]);while(Q.insert)if(Q.ins_h=_8(Q,Q.ins_h,Q.window[q+_-1]),Q.prev[q&Q.w_mask]=Q.head[Q.ins_h],Q.head[Q.ins_h]=q,q++,Q.insert--,Q.lookahead+Q.insert<_)break}}while(Q.lookahead<X8&&Q.strm.avail_in!==0)},L7=(Q,Y)=>{let J=Q.pending_buf_size-5>Q.w_size?Q.w_size:Q.pending_buf_size-5,X,q,G,U=0,W=Q.strm.avail_in;do{if(X=65535,G=Q.bi_valid+42>>3,Q.strm.avail_out<G)break;if(G=Q.strm.avail_out-G,q=Q.strstart-Q.block_start,X>q+Q.strm.avail_in)X=q+Q.strm.avail_in;if(X>G)X=G;if(X<J&&(X===0&&Y!==c0||Y===m8||X!==q+Q.strm.avail_in))break;if(U=Y===c0&&X===q+Q.strm.avail_in?1:0,o5(Q,0,0,U),Q.pending_buf[Q.pending-4]=X,Q.pending_buf[Q.pending-3]=X>>8,Q.pending_buf[Q.pending-2]=~X,Q.pending_buf[Q.pending-1]=~X>>8,x0(Q.strm),q){if(q>X)q=X;Q.strm.output.set(Q.window.subarray(Q.block_start,Q.block_start+q),Q.strm.next_out),Q.strm.next_out+=q,Q.strm.avail_out-=q,Q.strm.total_out+=q,Q.block_start+=q,X-=q}if(X)QY(Q.strm,Q.strm.output,Q.strm.next_out,X),Q.strm.next_out+=X,Q.strm.avail_out-=X,Q.strm.total_out+=X}while(U===0);if(W-=Q.strm.avail_in,W){if(W>=Q.w_size)Q.matches=2,Q.window.set(Q.strm.input.subarray(Q.strm.next_in-Q.w_size,Q.strm.next_in),0),Q.strstart=Q.w_size,Q.insert=Q.strstart;else{if(Q.window_size-Q.strstart<=W){if(Q.strstart-=Q.w_size,Q.window.set(Q.window.subarray(Q.w_size,Q.w_size+Q.strstart),0),Q.matches<2)Q.matches++;if(Q.insert>Q.strstart)Q.insert=Q.strstart}Q.window.set(Q.strm.input.subarray(Q.strm.next_in-W,Q.strm.next_in),Q.strstart),Q.strstart+=W,Q.insert+=W>Q.w_size-Q.insert?Q.w_size-Q.insert:W}Q.block_start=Q.strstart}if(Q.high_water<Q.strstart)Q.high_water=Q.strstart;if(U)return y9;if(Y!==m8&&Y!==c0&&Q.strm.avail_in===0&&Q.strstart===Q.block_start)return g9;if(G=Q.window_size-Q.strstart,Q.strm.avail_in>G&&Q.block_start>=Q.w_size){if(Q.block_start-=Q.w_size,Q.strstart-=Q.w_size,Q.window.set(Q.window.subarray(Q.w_size,Q.w_size+Q.strstart),0),Q.matches<2)Q.matches++;if(G+=Q.w_size,Q.insert>Q.strstart)Q.insert=Q.strstart}if(G>Q.strm.avail_in)G=Q.strm.avail_in;if(G)QY(Q.strm,Q.window,Q.strstart,G),Q.strstart+=G,Q.insert+=G>Q.w_size-Q.insert?Q.w_size-Q.insert:G;if(Q.high_water<Q.strstart)Q.high_water=Q.strstart;if(G=Q.bi_valid+42>>3,G=Q.pending_buf_size-G>65535?65535:Q.pending_buf_size-G,J=G>Q.w_size?Q.w_size:G,q=Q.strstart-Q.block_start,q>=J||(q||Y===c0)&&Y!==m8&&Q.strm.avail_in===0&&q<=G)X=q>G?G:q,U=Y===c0&&Q.strm.avail_in===0&&X===q?1:0,o5(Q,Q.block_start,X,U),Q.block_start+=X,x0(Q.strm);return U?V9:C0},y5=(Q,Y)=>{let J,X;for(;;){if(Q.lookahead<X8){if(b9(Q),Q.lookahead<X8&&Y===m8)return C0;if(Q.lookahead===0)break}if(J=0,Q.lookahead>=_)Q.ins_h=_8(Q,Q.ins_h,Q.window[Q.strstart+_-1]),J=Q.prev[Q.strstart&Q.w_mask]=Q.head[Q.ins_h],Q.head[Q.ins_h]=Q.strstart;if(J!==0&&Q.strstart-J<=Q.w_size-X8)Q.match_length=I7(Q,J);if(Q.match_length>=_)if(X=h8(Q,Q.strstart-Q.match_start,Q.match_length-_),Q.lookahead-=Q.match_length,Q.match_length<=Q.max_lazy_match&&Q.lookahead>=_){Q.match_length--;do Q.strstart++,Q.ins_h=_8(Q,Q.ins_h,Q.window[Q.strstart+_-1]),J=Q.prev[Q.strstart&Q.w_mask]=Q.head[Q.ins_h],Q.head[Q.ins_h]=Q.strstart;while(--Q.match_length!==0);Q.strstart++}else Q.strstart+=Q.match_length,Q.match_length=0,Q.ins_h=Q.window[Q.strstart],Q.ins_h=_8(Q,Q.ins_h,Q.window[Q.strstart+1]);else X=h8(Q,0,Q.window[Q.strstart]),Q.lookahead--,Q.strstart++;if(X){if(f0(Q,!1),Q.strm.avail_out===0)return C0}}if(Q.insert=Q.strstart<_-1?Q.strstart:_-1,Y===c0){if(f0(Q,!0),Q.strm.avail_out===0)return V9;return y9}if(Q.sym_next){if(f0(Q,!1),Q.strm.avail_out===0)return C0}return g9},A9=(Q,Y)=>{let J,X,q;for(;;){if(Q.lookahead<X8){if(b9(Q),Q.lookahead<X8&&Y===m8)return C0;if(Q.lookahead===0)break}if(J=0,Q.lookahead>=_)Q.ins_h=_8(Q,Q.ins_h,Q.window[Q.strstart+_-1]),J=Q.prev[Q.strstart&Q.w_mask]=Q.head[Q.ins_h],Q.head[Q.ins_h]=Q.strstart;if(Q.prev_length=Q.match_length,Q.prev_match=Q.match_start,Q.match_length=_-1,J!==0&&Q.prev_length<Q.max_lazy_match&&Q.strstart-J<=Q.w_size-X8){if(Q.match_length=I7(Q,J),Q.match_length<=5&&(Q.strategy===ZW||Q.match_length===_&&Q.strstart-Q.match_start>4096))Q.match_length=_-1}if(Q.prev_length>=_&&Q.match_length<=Q.prev_length){q=Q.strstart+Q.lookahead-_,X=h8(Q,Q.strstart-1-Q.prev_match,Q.prev_length-_),Q.lookahead-=Q.prev_length-1,Q.prev_length-=2;do if(++Q.strstart<=q)Q.ins_h=_8(Q,Q.ins_h,Q.window[Q.strstart+_-1]),J=Q.prev[Q.strstart&Q.w_mask]=Q.head[Q.ins_h],Q.head[Q.ins_h]=Q.strstart;while(--Q.prev_length!==0);if(Q.match_available=0,Q.match_length=_-1,Q.strstart++,X){if(f0(Q,!1),Q.strm.avail_out===0)return C0}}else if(Q.match_available){if(X=h8(Q,0,Q.window[Q.strstart-1]),X)f0(Q,!1);if(Q.strstart++,Q.lookahead--,Q.strm.avail_out===0)return C0}else Q.match_available=1,Q.strstart++,Q.lookahead--}if(Q.match_available)X=h8(Q,0,Q.window[Q.strstart-1]),Q.match_available=0;if(Q.insert=Q.strstart<_-1?Q.strstart:_-1,Y===c0){if(f0(Q,!0),Q.strm.avail_out===0)return V9;return y9}if(Q.sym_next){if(f0(Q,!1),Q.strm.avail_out===0)return C0}return g9},SW=(Q,Y)=>{let J,X,q,G;const U=Q.window;for(;;){if(Q.lookahead<=y8){if(b9(Q),Q.lookahead<=y8&&Y===m8)return C0;if(Q.lookahead===0)break}if(Q.match_length=0,Q.lookahead>=_&&Q.strstart>0){if(q=Q.strstart-1,X=U[q],X===U[++q]&&X===U[++q]&&X===U[++q]){G=Q.strstart+y8;do;while(X===U[++q]&&X===U[++q]&&X===U[++q]&&X===U[++q]&&X===U[++q]&&X===U[++q]&&X===U[++q]&&X===U[++q]&&q<G);if(Q.match_length=y8-(G-q),Q.match_length>Q.lookahead)Q.match_length=Q.lookahead}}if(Q.match_length>=_)J=h8(Q,1,Q.match_length-_),Q.lookahead-=Q.match_length,Q.strstart+=Q.match_length,Q.match_length=0;else J=h8(Q,0,Q.window[Q.strstart]),Q.lookahead--,Q.strstart++;if(J){if(f0(Q,!1),Q.strm.avail_out===0)return C0}}if(Q.insert=0,Y===c0){if(f0(Q,!0),Q.strm.avail_out===0)return V9;return y9}if(Q.sym_next){if(f0(Q,!1),Q.strm.avail_out===0)return C0}return g9},AW=(Q,Y)=>{let J;for(;;){if(Q.lookahead===0){if(b9(Q),Q.lookahead===0){if(Y===m8)return C0;break}}if(Q.match_length=0,J=h8(Q,0,Q.window[Q.strstart]),Q.lookahead--,Q.strstart++,J){if(f0(Q,!1),Q.strm.avail_out===0)return C0}}if(Q.insert=0,Y===c0){if(f0(Q,!0),Q.strm.avail_out===0)return V9;return y9}if(Q.sym_next){if(f0(Q,!1),Q.strm.avail_out===0)return C0}return g9},UQ=[new Q8(0,0,0,0,L7),new Q8(4,4,8,4,y5),new Q8(4,5,16,8,y5),new Q8(4,6,32,32,y5),new Q8(4,4,16,16,A9),new Q8(8,16,32,32,A9),new Q8(8,16,128,128,A9),new Q8(8,32,128,256,A9),new Q8(32,128,258,1024,A9),new Q8(32,258,258,4096,A9)],kW=(Q)=>{Q.window_size=2*Q.w_size,g8(Q.head),Q.max_lazy_match=UQ[Q.level].max_lazy,Q.good_match=UQ[Q.level].good_length,Q.nice_match=UQ[Q.level].nice_length,Q.max_chain_length=UQ[Q.level].max_chain,Q.strstart=0,Q.block_start=0,Q.lookahead=0,Q.insert=0,Q.match_length=Q.prev_length=_-1,Q.match_available=0,Q.ins_h=0},HQ=(Q)=>{if(!Q)return 1;const Y=Q.state;if(!Y||Y.strm!==Q||Y.status!==f9&&Y.status!==GY&&Y.status!==a5&&Y.status!==s5&&Y.status!==t5&&Y.status!==e5&&Y.status!==G9&&Y.status!==GQ)return 1;return 0},H7=(Q)=>{if(HQ(Q))return U9(Q,Y8);Q.total_in=Q.total_out=0,Q.data_type=OW;const Y=Q.state;if(Y.pending=0,Y.pending_out=0,Y.wrap<0)Y.wrap=-Y.wrap;return Y.status=Y.wrap===2?GY:Y.wrap?f9:G9,Q.adler=Y.wrap===2?0:1,Y.last_flush=-2,qW(Y),D0},R7=(Q)=>{const Y=H7(Q);if(Y===D0)kW(Q.state);return Y},fW=(Q,Y)=>{if(HQ(Q)||Q.state.wrap!==2)return Y8;return Q.state.gzhead=Y,D0},P7=(Q,Y,J,X,q,G)=>{if(!Q)return Y8;let U=1;if(Y===zW)Y=6;if(X<0)U=0,X=-X;else if(X>15)U=2,X-=16;if(q<1||q>DW||J!==FJ||X<8||X>15||Y<0||Y>9||G<0||G>KW||X===8&&U!==1)return U9(Q,Y8);if(X===8)X=9;const W=new xW;return Q.state=W,W.strm=Q,W.status=f9,W.wrap=U,W.gzhead=null,W.w_bits=X,W.w_size=1<<W.w_bits,W.w_mask=W.w_size-1,W.hash_bits=q+7,W.hash_size=1<<W.hash_bits,W.hash_mask=W.hash_size-1,W.hash_shift=~~((W.hash_bits+_-1)/_),W.window=new Uint8Array(W.w_size*2),W.head=new Uint16Array(W.hash_size),W.prev=new Uint16Array(W.w_size),W.lit_bufsize=1<<q+6,W.pending_buf_size=W.lit_bufsize*4,W.pending_buf=new Uint8Array(W.pending_buf_size),W.sym_buf=W.lit_bufsize,W.sym_end=(W.lit_bufsize-1)*3,W.level=Y,W.strategy=G,W.method=J,R7(Q)},bW=(Q,Y)=>{return P7(Q,Y,FJ,IW,LW,jW)},vW=(Q,Y)=>{if(HQ(Q)||Y>Tq||Y<0)return Q?U9(Q,Y8):Y8;const J=Q.state;if(!Q.output||Q.avail_in!==0&&!Q.input||J.status===GQ&&Y!==c0)return U9(Q,Q.avail_out===0?g5:Y8);const X=J.last_flush;if(J.last_flush=Y,J.pending!==0){if(x0(Q),Q.avail_out===0)return J.last_flush=-1,D0}else if(Q.avail_in===0&&wq(Y)<=wq(X)&&Y!==c0)return U9(Q,g5);if(J.status===GQ&&Q.avail_in!==0)return U9(Q,g5);if(J.status===f9&&J.wrap===0)J.status=G9;if(J.status===f9){let q=FJ+(J.w_bits-8<<4)<<8,G=-1;if(J.strategy>=IJ||J.level<2)G=0;else if(J.level<6)G=1;else if(J.level===6)G=2;else G=3;if(q|=G<<6,J.strstart!==0)q|=wW;if(q+=31-q%31,qQ(J,q),J.strstart!==0)qQ(J,Q.adler>>>16),qQ(J,Q.adler&65535);if(Q.adler=1,J.status=G9,x0(Q),J.pending!==0)return J.last_flush=-1,D0}if(J.status===GY)if(Q.adler=0,i(J,31),i(J,139),i(J,8),!J.gzhead){if(i(J,0),i(J,0),i(J,0),i(J,0),i(J,0),i(J,J.level===9?2:J.strategy>=IJ||J.level<2?4:0),i(J,FW),J.status=G9,x0(Q),J.pending!==0)return J.last_flush=-1,D0}else{if(i(J,(J.gzhead.text?1:0)+(J.gzhead.hcrc?2:0)+(!J.gzhead.extra?0:4)+(!J.gzhead.name?0:8)+(!J.gzhead.comment?0:16)),i(J,J.gzhead.time&255),i(J,J.gzhead.time>>8&255),i(J,J.gzhead.time>>16&255),i(J,J.gzhead.time>>24&255),i(J,J.level===9?2:J.strategy>=IJ||J.level<2?4:0),i(J,J.gzhead.os&255),J.gzhead.extra&&J.gzhead.extra.length)i(J,J.gzhead.extra.length&255),i(J,J.gzhead.extra.length>>8&255);if(J.gzhead.hcrc)Q.adler=K0(Q.adler,J.pending_buf,J.pending,0);J.gzindex=0,J.status=a5}if(J.status===a5){if(J.gzhead.extra){let q=J.pending,G=(J.gzhead.extra.length&65535)-J.gzindex;while(J.pending+G>J.pending_buf_size){let W=J.pending_buf_size-J.pending;if(J.pending_buf.set(J.gzhead.extra.subarray(J.gzindex,J.gzindex+W),J.pending),J.pending=J.pending_buf_size,J.gzhead.hcrc&&J.pending>q)Q.adler=K0(Q.adler,J.pending_buf,J.pending-q,q);if(J.gzindex+=W,x0(Q),J.pending!==0)return J.last_flush=-1,D0;q=0,G-=W}let U=new Uint8Array(J.gzhead.extra);if(J.pending_buf.set(U.subarray(J.gzindex,J.gzindex+G),J.pending),J.pending+=G,J.gzhead.hcrc&&J.pending>q)Q.adler=K0(Q.adler,J.pending_buf,J.pending-q,q);J.gzindex=0}J.status=s5}if(J.status===s5){if(J.gzhead.name){let q=J.pending,G;do{if(J.pending===J.pending_buf_size){if(J.gzhead.hcrc&&J.pending>q)Q.adler=K0(Q.adler,J.pending_buf,J.pending-q,q);if(x0(Q),J.pending!==0)return J.last_flush=-1,D0;q=0}if(J.gzindex<J.gzhead.name.length)G=J.gzhead.name.charCodeAt(J.gzindex++)&255;else G=0;i(J,G)}while(G!==0);if(J.gzhead.hcrc&&J.pending>q)Q.adler=K0(Q.adler,J.pending_buf,J.pending-q,q);J.gzindex=0}J.status=t5}if(J.status===t5){if(J.gzhead.comment){let q=J.pending,G;do{if(J.pending===J.pending_buf_size){if(J.gzhead.hcrc&&J.pending>q)Q.adler=K0(Q.adler,J.pending_buf,J.pending-q,q);if(x0(Q),J.pending!==0)return J.last_flush=-1,D0;q=0}if(J.gzindex<J.gzhead.comment.length)G=J.gzhead.comment.charCodeAt(J.gzindex++)&255;else G=0;i(J,G)}while(G!==0);if(J.gzhead.hcrc&&J.pending>q)Q.adler=K0(Q.adler,J.pending_buf,J.pending-q,q)}J.status=e5}if(J.status===e5){if(J.gzhead.hcrc){if(J.pending+2>J.pending_buf_size){if(x0(Q),J.pending!==0)return J.last_flush=-1,D0}i(J,Q.adler&255),i(J,Q.adler>>8&255),Q.adler=0}if(J.status=G9,x0(Q),J.pending!==0)return J.last_flush=-1,D0}if(Q.avail_in!==0||J.lookahead!==0||Y!==m8&&J.status!==GQ){let q=J.level===0?L7(J,Y):J.strategy===IJ?AW(J,Y):J.strategy===MW?SW(J,Y):UQ[J.level].func(J,Y);if(q===V9||q===y9)J.status=GQ;if(q===C0||q===V9){if(Q.avail_out===0)J.last_flush=-1;return D0}if(q===g9){if(Y===WW)UW(J);else if(Y!==Tq){if(o5(J,0,0,!1),Y===VW){if(g8(J.head),J.lookahead===0)J.strstart=0,J.block_start=0,J.insert=0}}if(x0(Q),Q.avail_out===0)return J.last_flush=-1,D0}}if(Y!==c0)return D0;if(J.wrap<=0)return Nq;if(J.wrap===2)i(J,Q.adler&255),i(J,Q.adler>>8&255),i(J,Q.adler>>16&255),i(J,Q.adler>>24&255),i(J,Q.total_in&255),i(J,Q.total_in>>8&255),i(J,Q.total_in>>16&255),i(J,Q.total_in>>24&255);else qQ(J,Q.adler>>>16),qQ(J,Q.adler&65535);if(x0(Q),J.wrap>0)J.wrap=-J.wrap;return J.pending!==0?D0:Nq},gW=(Q)=>{if(HQ(Q))return Y8;const Y=Q.state.status;return Q.state=null,Y===G9?U9(Q,$W):D0},yW=(Q,Y)=>{let J=Y.length;if(HQ(Q))return Y8;const X=Q.state,q=X.wrap;if(q===2||q===1&&X.status!==f9||X.lookahead)return Y8;if(q===1)Q.adler=jQ(Q.adler,Y,J,0);if(X.wrap=0,J>=X.w_size){if(q===0)g8(X.head),X.strstart=0,X.block_start=0,X.insert=0;let $=new Uint8Array(X.w_size);$.set(Y.subarray(J-X.w_size,J),0),Y=$,J=X.w_size}const{avail_in:G,next_in:U,input:W}=Q;Q.avail_in=J,Q.next_in=0,Q.input=Y,b9(X);while(X.lookahead>=_){let $=X.strstart,V=X.lookahead-(_-1);do X.ins_h=_8(X,X.ins_h,X.window[$+_-1]),X.prev[$&X.w_mask]=X.head[X.ins_h],X.head[X.ins_h]=$,$++;while(--V);X.strstart=$,X.lookahead=_-1,b9(X)}return X.strstart+=X.lookahead,X.block_start=X.strstart,X.insert=X.lookahead,X.lookahead=0,X.match_length=X.prev_length=_-1,X.match_available=0,Q.next_in=U,Q.input=W,Q.avail_in=G,X.wrap=q,D0},hW=bW,mW=P7,_W=R7,cW=H7,pW=fW,uW=vW,dW=gW,lW=yW,nW="pako deflate (from Nodeca project)",VQ={deflateInit:hW,deflateInit2:mW,deflateReset:_W,deflateResetKeep:cW,deflateSetHeader:pW,deflate:uW,deflateEnd:dW,deflateSetDictionary:lW,deflateInfo:nW},iW=(Q,Y)=>{return Object.prototype.hasOwnProperty.call(Q,Y)},oW=function(Q){const Y=Array.prototype.slice.call(arguments,1);while(Y.length){const J=Y.shift();if(!J)continue;if(typeof J!=="object")throw new TypeError(J+"must be non-object");for(let X in J)if(iW(J,X))Q[X]=J[X]}return Q},rW=(Q)=>{let Y=0;for(let X=0,q=Q.length;X<q;X++)Y+=Q[X].length;const J=new Uint8Array(Y);for(let X=0,q=0,G=Q.length;X<G;X++){let U=Q[X];J.set(U,q),q+=U.length}return J},BJ={assign:oW,flattenChunks:rW},C7=!0;try{String.fromCharCode.apply(null,new Uint8Array(1))}catch(Q){C7=!1}var OQ=new Uint8Array(256);for(let Q=0;Q<256;Q++)OQ[Q]=Q>=252?6:Q>=248?5:Q>=240?4:Q>=224?3:Q>=192?2:1;OQ[254]=OQ[254]=1;var aW=(Q)=>{if(typeof TextEncoder==="function"&&TextEncoder.prototype.encode)return(new TextEncoder()).encode(Q);let Y,J,X,q,G,U=Q.length,W=0;for(q=0;q<U;q++){if(J=Q.charCodeAt(q),(J&64512)===55296&&q+1<U){if(X=Q.charCodeAt(q+1),(X&64512)===56320)J=65536+(J-55296<<10)+(X-56320),q++}W+=J<128?1:J<2048?2:J<65536?3:4}Y=new Uint8Array(W);for(G=0,q=0;G<W;q++){if(J=Q.charCodeAt(q),(J&64512)===55296&&q+1<U){if(X=Q.charCodeAt(q+1),(X&64512)===56320)J=65536+(J-55296<<10)+(X-56320),q++}if(J<128)Y[G++]=J;else if(J<2048)Y[G++]=192|J>>>6,Y[G++]=128|J&63;else if(J<65536)Y[G++]=224|J>>>12,Y[G++]=128|J>>>6&63,Y[G++]=128|J&63;else Y[G++]=240|J>>>18,Y[G++]=128|J>>>12&63,Y[G++]=128|J>>>6&63,Y[G++]=128|J&63}return Y},sW=(Q,Y)=>{if(Y<65534){if(Q.subarray&&C7)return String.fromCharCode.apply(null,Q.length===Y?Q:Q.subarray(0,Y))}let J="";for(let X=0;X<Y;X++)J+=String.fromCharCode(Q[X]);return J},tW=(Q,Y)=>{const J=Y||Q.length;if(typeof TextDecoder==="function"&&TextDecoder.prototype.decode)return(new TextDecoder()).decode(Q.subarray(0,Y));let X,q;const G=new Array(J*2);for(q=0,X=0;X<J;){let U=Q[X++];if(U<128){G[q++]=U;continue}let W=OQ[U];if(W>4){G[q++]=65533,X+=W-1;continue}U&=W===2?31:W===3?15:7;while(W>1&&X<J)U=U<<6|Q[X++]&63,W--;if(W>1){G[q++]=65533;continue}if(U<65536)G[q++]=U;else U-=65536,G[q++]=55296|U>>10&1023,G[q++]=56320|U&1023}return sW(G,q)},eW=(Q,Y)=>{if(Y=Y||Q.length,Y>Q.length)Y=Q.length;let J=Y-1;while(J>=0&&(Q[J]&192)===128)J--;if(J<0)return Y;if(J===0)return Y;return J+OQ[Q[J]]>Y?J:Y},DQ={string2buf:aW,buf2string:tW,utf8border:eW},T7=QV,N7=Object.prototype.toString,{Z_NO_FLUSH:JV,Z_SYNC_FLUSH:YV,Z_FULL_FLUSH:XV,Z_FINISH:qV,Z_OK:NJ,Z_STREAM_END:GV,Z_DEFAULT_COMPRESSION:UV,Z_DEFAULT_STRATEGY:WV,Z_DEFLATED:VV}=z9;RQ.prototype.push=function(Q,Y){const J=this.strm,X=this.options.chunkSize;let q,G;if(this.ended)return!1;if(Y===~~Y)G=Y;else G=Y===!0?qV:JV;if(typeof Q==="string")J.input=DQ.string2buf(Q);else if(N7.call(Q)==="[object ArrayBuffer]")J.input=new Uint8Array(Q);else J.input=Q;J.next_in=0,J.avail_in=J.input.length;for(;;){if(J.avail_out===0)J.output=new Uint8Array(X),J.next_out=0,J.avail_out=X;if((G===YV||G===XV)&&J.avail_out<=6){this.onData(J.output.subarray(0,J.next_out)),J.avail_out=0;continue}if(q=VQ.deflate(J,G),q===GV){if(J.next_out>0)this.onData(J.output.subarray(0,J.next_out));return q=VQ.deflateEnd(this.strm),this.onEnd(q),this.ended=!0,q===NJ}if(J.avail_out===0){this.onData(J.output);continue}if(G>0&&J.next_out>0){this.onData(J.output.subarray(0,J.next_out)),J.avail_out=0;continue}if(J.avail_in===0)break}return!0};RQ.prototype.onData=function(Q){this.chunks.push(Q)};RQ.prototype.onEnd=function(Q){if(Q===NJ)this.result=BJ.flattenChunks(this.chunks);this.chunks=[],this.err=Q,this.msg=this.strm.msg};var ZV=RQ,MV=UY,KV=$V,jV=zV,OV=z9,DV={Deflate:ZV,deflate:MV,deflateRaw:KV,gzip:jV,constants:OV},LJ=16209,IV=16191,LV=function Q(Y,J){let X,q,G,U,W,$,V,z,M,K,j,Z,D,I,L,R,F,H,C,E,P,f,S,B;const A=Y.state;X=Y.next_in,S=Y.input,q=X+(Y.avail_in-5),G=Y.next_out,B=Y.output,U=G-(J-Y.avail_out),W=G+(Y.avail_out-257),$=A.dmax,V=A.wsize,z=A.whave,M=A.wnext,K=A.window,j=A.hold,Z=A.bits,D=A.lencode,I=A.distcode,L=(1<<A.lenbits)-1,R=(1<<A.distbits)-1;Q:do{if(Z<15)j+=S[X++]<<Z,Z+=8,j+=S[X++]<<Z,Z+=8;F=D[j&L];J:for(;;){if(H=F>>>24,j>>>=H,Z-=H,H=F>>>16&255,H===0)B[G++]=F&65535;else if(H&16){if(C=F&65535,H&=15,H){if(Z<H)j+=S[X++]<<Z,Z+=8;C+=j&(1<<H)-1,j>>>=H,Z-=H}if(Z<15)j+=S[X++]<<Z,Z+=8,j+=S[X++]<<Z,Z+=8;F=I[j&R];Y:for(;;){if(H=F>>>24,j>>>=H,Z-=H,H=F>>>16&255,H&16){if(E=F&65535,H&=15,Z<H){if(j+=S[X++]<<Z,Z+=8,Z<H)j+=S[X++]<<Z,Z+=8}if(E+=j&(1<<H)-1,E>$){Y.msg="invalid distance too far back",A.mode=LJ;break Q}if(j>>>=H,Z-=H,H=G-U,E>H){if(H=E-H,H>z){if(A.sane){Y.msg="invalid distance too far back",A.mode=LJ;break Q}}if(P=0,f=K,M===0){if(P+=V-H,H<C){C-=H;do B[G++]=K[P++];while(--H);P=G-E,f=B}}else if(M<H){if(P+=V+M-H,H-=M,H<C){C-=H;do B[G++]=K[P++];while(--H);if(P=0,M<C){H=M,C-=H;do B[G++]=K[P++];while(--H);P=G-E,f=B}}}else if(P+=M-H,H<C){C-=H;do B[G++]=K[P++];while(--H);P=G-E,f=B}while(C>2)B[G++]=f[P++],B[G++]=f[P++],B[G++]=f[P++],C-=3;if(C){if(B[G++]=f[P++],C>1)B[G++]=f[P++]}}else{P=G-E;do B[G++]=B[P++],B[G++]=B[P++],B[G++]=B[P++],C-=3;while(C>2);if(C){if(B[G++]=B[P++],C>1)B[G++]=B[P++]}}}else if((H&64)===0){F=I[(F&65535)+(j&(1<<H)-1)];continue Y}else{Y.msg="invalid distance code",A.mode=LJ;break Q}break}}else if((H&64)===0){F=D[(F&65535)+(j&(1<<H)-1)];continue J}else if(H&32){A.mode=IV;break Q}else{Y.msg="invalid literal/length code",A.mode=LJ;break Q}break}}while(X<q&&G<W);C=Z>>3,X-=C,Z-=C<<3,j&=(1<<Z)-1,Y.next_in=X,Y.next_out=G,Y.avail_in=X<q?5+(q-X):5-(X-q),Y.avail_out=G<W?257+(W-G):257-(G-W),A.hold=j,A.bits=Z;return},k9=15,Fq=852,Bq=592,Eq=0,h5=1,Sq=2,HV=new Uint16Array([3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,0,0]),RV=new Uint8Array([16,16,16,16,16,16,16,16,17,17,17,17,18,18,18,18,19,19,19,19,20,20,20,20,21,21,21,21,16,72,78]),PV=new Uint16Array([1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,0,0]),CV=new Uint8Array([16,16,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,64,64]),TV=(Q,Y,J,X,q,G,U,W)=>{const $=W.bits;let V=0,z=0,M=0,K=0,j=0,Z=0,D=0,I=0,L=0,R=0,F,H,C,E,P,f=null,S;const B=new Uint16Array(k9+1),A=new Uint16Array(k9+1);let c=null,G0,p,w;for(V=0;V<=k9;V++)B[V]=0;for(z=0;z<X;z++)B[Y[J+z]]++;j=$;for(K=k9;K>=1;K--)if(B[K]!==0)break;if(j>K)j=K;if(K===0)return q[G++]=1<<24|64<<16|0,q[G++]=1<<24|64<<16|0,W.bits=1,0;for(M=1;M<K;M++)if(B[M]!==0)break;if(j<M)j=M;I=1;for(V=1;V<=k9;V++)if(I<<=1,I-=B[V],I<0)return-1;if(I>0&&(Q===Eq||K!==1))return-1;A[1]=0;for(V=1;V<k9;V++)A[V+1]=A[V]+B[V];for(z=0;z<X;z++)if(Y[J+z]!==0)U[A[Y[J+z]]++]=z;if(Q===Eq)f=c=U,S=20;else if(Q===h5)f=HV,c=RV,S=257;else f=PV,c=CV,S=0;if(R=0,z=0,V=M,P=G,Z=j,D=0,C=-1,L=1<<j,E=L-1,Q===h5&&L>Fq||Q===Sq&&L>Bq)return 1;for(;;){if(G0=V-D,U[z]+1<S)p=0,w=U[z];else if(U[z]>=S)p=c[U[z]-S],w=f[U[z]-S];else p=96,w=0;F=1<<V-D,H=1<<Z,M=H;do H-=F,q[P+(R>>D)+H]=G0<<24|p<<16|w|0;while(H!==0);F=1<<V-1;while(R&F)F>>=1;if(F!==0)R&=F-1,R+=F;else R=0;if(z++,--B[V]===0){if(V===K)break;V=Y[J+U[z]]}if(V>j&&(R&E)!==C){if(D===0)D=j;P+=M,Z=V-D,I=1<<Z;while(Z+D<K){if(I-=B[Z+D],I<=0)break;Z++,I<<=1}if(L+=1<<Z,Q===h5&&L>Fq||Q===Sq&&L>Bq)return 1;C=R&E,q[C]=j<<24|Z<<16|P-G|0}}if(R!==0)q[P+R]=V-D<<24|64<<16|0;return W.bits=j,0},$Q=TV,NV=0,w7=1,F7=2,{Z_FINISH:Aq,Z_BLOCK:wV,Z_TREES:HJ,Z_OK:$9,Z_STREAM_END:FV,Z_NEED_DICT:BV,Z_STREAM_ERROR:p0,Z_DATA_ERROR:B7,Z_MEM_ERROR:E7,Z_BUF_ERROR:EV,Z_DEFLATED:kq}=z9,EJ=16180,xq=16181,fq=16182,bq=16183,vq=16184,gq=16185,yq=16186,hq=16187,mq=16188,_q=16189,wJ=16190,T8=16191,m5=16192,cq=16193,_5=16194,pq=16195,uq=16196,dq=16197,lq=16198,RJ=16199,PJ=16200,nq=16201,iq=16202,oq=16203,rq=16204,aq=16205,c5=16206,sq=16207,tq=16208,Q0=16209,S7=16210,A7=16211,SV=852,AV=592,kV=15,xV=kV,eq=(Q)=>{return(Q>>>24&255)+(Q>>>8&65280)+((Q&65280)<<8)+((Q&255)<<24)},Z9=(Q)=>{if(!Q)return 1;const Y=Q.state;if(!Y||Y.strm!==Q||Y.mode<EJ||Y.mode>A7)return 1;return 0},k7=(Q)=>{if(Z9(Q))return p0;const Y=Q.state;if(Q.total_in=Q.total_out=Y.total=0,Q.msg="",Y.wrap)Q.adler=Y.wrap&1;return Y.mode=EJ,Y.last=0,Y.havedict=0,Y.flags=-1,Y.dmax=32768,Y.head=null,Y.hold=0,Y.bits=0,Y.lencode=Y.lendyn=new Int32Array(SV),Y.distcode=Y.distdyn=new Int32Array(AV),Y.sane=1,Y.back=-1,$9},x7=(Q)=>{if(Z9(Q))return p0;const Y=Q.state;return Y.wsize=0,Y.whave=0,Y.wnext=0,k7(Q)},f7=(Q,Y)=>{let J;if(Z9(Q))return p0;const X=Q.state;if(Y<0)J=0,Y=-Y;else if(J=(Y>>4)+5,Y<48)Y&=15;if(Y&&(Y<8||Y>15))return p0;if(X.window!==null&&X.wbits!==Y)X.window=null;return X.wrap=J,X.wbits=Y,x7(Q)},b7=(Q,Y)=>{if(!Q)return p0;const J=new fV;Q.state=J,J.strm=Q,J.window=null,J.mode=EJ;const X=f7(Q,Y);if(X!==$9)Q.state=null;return X},bV=(Q)=>{return b7(Q,xV)},Q7=!0,p5,u5,vV=(Q)=>{if(Q7){p5=new Int32Array(512),u5=new Int32Array(32);let Y=0;while(Y<144)Q.lens[Y++]=8;while(Y<256)Q.lens[Y++]=9;while(Y<280)Q.lens[Y++]=7;while(Y<288)Q.lens[Y++]=8;$Q(w7,Q.lens,0,288,p5,0,Q.work,{bits:9}),Y=0;while(Y<32)Q.lens[Y++]=5;$Q(F7,Q.lens,0,32,u5,0,Q.work,{bits:5}),Q7=!1}Q.lencode=p5,Q.lenbits=9,Q.distcode=u5,Q.distbits=5},v7=(Q,Y,J,X)=>{let q;const G=Q.state;if(G.window===null)G.wsize=1<<G.wbits,G.wnext=0,G.whave=0,G.window=new Uint8Array(G.wsize);if(X>=G.wsize)G.window.set(Y.subarray(J-G.wsize,J),0),G.wnext=0,G.whave=G.wsize;else{if(q=G.wsize-G.wnext,q>X)q=X;if(G.window.set(Y.subarray(J-X,J-X+q),G.wnext),X-=q,X)G.window.set(Y.subarray(J-X,J),0),G.wnext=X,G.whave=G.wsize;else{if(G.wnext+=q,G.wnext===G.wsize)G.wnext=0;if(G.whave<G.wsize)G.whave+=q}}return 0},gV=(Q,Y)=>{let J,X,q,G,U,W,$,V,z,M,K,j,Z,D,I=0,L,R,F,H,C,E,P,f;const S=new Uint8Array(4);let B,A;const c=new Uint8Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]);if(Z9(Q)||!Q.output||!Q.input&&Q.avail_in!==0)return p0;if(J=Q.state,J.mode===T8)J.mode=m5;U=Q.next_out,q=Q.output,$=Q.avail_out,G=Q.next_in,X=Q.input,W=Q.avail_in,V=J.hold,z=J.bits,M=W,K=$,f=$9;Q:for(;;)switch(J.mode){case EJ:if(J.wrap===0){J.mode=m5;break}while(z<16){if(W===0)break Q;W--,V+=X[G++]<<z,z+=8}if(J.wrap&2&&V===35615){if(J.wbits===0)J.wbits=15;J.check=0,S[0]=V&255,S[1]=V>>>8&255,J.check=K0(J.check,S,2,0),V=0,z=0,J.mode=xq;break}if(J.head)J.head.done=!1;if(!(J.wrap&1)||(((V&255)<<8)+(V>>8))%31){Q.msg="incorrect header check",J.mode=Q0;break}if((V&15)!==kq){Q.msg="unknown compression method",J.mode=Q0;break}if(V>>>=4,z-=4,P=(V&15)+8,J.wbits===0)J.wbits=P;if(P>15||P>J.wbits){Q.msg="invalid window size",J.mode=Q0;break}J.dmax=1<<J.wbits,J.flags=0,Q.adler=J.check=1,J.mode=V&512?_q:T8,V=0,z=0;break;case xq:while(z<16){if(W===0)break Q;W--,V+=X[G++]<<z,z+=8}if(J.flags=V,(J.flags&255)!==kq){Q.msg="unknown compression method",J.mode=Q0;break}if(J.flags&57344){Q.msg="unknown header flags set",J.mode=Q0;break}if(J.head)J.head.text=V>>8&1;if(J.flags&512&&J.wrap&4)S[0]=V&255,S[1]=V>>>8&255,J.check=K0(J.check,S,2,0);V=0,z=0,J.mode=fq;case fq:while(z<32){if(W===0)break Q;W--,V+=X[G++]<<z,z+=8}if(J.head)J.head.time=V;if(J.flags&512&&J.wrap&4)S[0]=V&255,S[1]=V>>>8&255,S[2]=V>>>16&255,S[3]=V>>>24&255,J.check=K0(J.check,S,4,0);V=0,z=0,J.mode=bq;case bq:while(z<16){if(W===0)break Q;W--,V+=X[G++]<<z,z+=8}if(J.head)J.head.xflags=V&255,J.head.os=V>>8;if(J.flags&512&&J.wrap&4)S[0]=V&255,S[1]=V>>>8&255,J.check=K0(J.check,S,2,0);V=0,z=0,J.mode=vq;case vq:if(J.flags&1024){while(z<16){if(W===0)break Q;W--,V+=X[G++]<<z,z+=8}if(J.length=V,J.head)J.head.extra_len=V;if(J.flags&512&&J.wrap&4)S[0]=V&255,S[1]=V>>>8&255,J.check=K0(J.check,S,2,0);V=0,z=0}else if(J.head)J.head.extra=null;J.mode=gq;case gq:if(J.flags&1024){if(j=J.length,j>W)j=W;if(j){if(J.head){if(P=J.head.extra_len-J.length,!J.head.extra)J.head.extra=new Uint8Array(J.head.extra_len);J.head.extra.set(X.subarray(G,G+j),P)}if(J.flags&512&&J.wrap&4)J.check=K0(J.check,X,j,G);W-=j,G+=j,J.length-=j}if(J.length)break Q}J.length=0,J.mode=yq;case yq:if(J.flags&2048){if(W===0)break Q;j=0;do if(P=X[G+j++],J.head&&P&&J.length<65536)J.head.name+=String.fromCharCode(P);while(P&&j<W);if(J.flags&512&&J.wrap&4)J.check=K0(J.check,X,j,G);if(W-=j,G+=j,P)break Q}else if(J.head)J.head.name=null;J.length=0,J.mode=hq;case hq:if(J.flags&4096){if(W===0)break Q;j=0;do if(P=X[G+j++],J.head&&P&&J.length<65536)J.head.comment+=String.fromCharCode(P);while(P&&j<W);if(J.flags&512&&J.wrap&4)J.check=K0(J.check,X,j,G);if(W-=j,G+=j,P)break Q}else if(J.head)J.head.comment=null;J.mode=mq;case mq:if(J.flags&512){while(z<16){if(W===0)break Q;W--,V+=X[G++]<<z,z+=8}if(J.wrap&4&&V!==(J.check&65535)){Q.msg="header crc mismatch",J.mode=Q0;break}V=0,z=0}if(J.head)J.head.hcrc=J.flags>>9&1,J.head.done=!0;Q.adler=J.check=0,J.mode=T8;break;case _q:while(z<32){if(W===0)break Q;W--,V+=X[G++]<<z,z+=8}Q.adler=J.check=eq(V),V=0,z=0,J.mode=wJ;case wJ:if(J.havedict===0)return Q.next_out=U,Q.avail_out=$,Q.next_in=G,Q.avail_in=W,J.hold=V,J.bits=z,BV;Q.adler=J.check=1,J.mode=T8;case T8:if(Y===wV||Y===HJ)break Q;case m5:if(J.last){V>>>=z&7,z-=z&7,J.mode=c5;break}while(z<3){if(W===0)break Q;W--,V+=X[G++]<<z,z+=8}switch(J.last=V&1,V>>>=1,z-=1,V&3){case 0:J.mode=cq;break;case 1:if(vV(J),J.mode=RJ,Y===HJ){V>>>=2,z-=2;break Q}break;case 2:J.mode=uq;break;case 3:Q.msg="invalid block type",J.mode=Q0}V>>>=2,z-=2;break;case cq:V>>>=z&7,z-=z&7;while(z<32){if(W===0)break Q;W--,V+=X[G++]<<z,z+=8}if((V&65535)!==(V>>>16^65535)){Q.msg="invalid stored block lengths",J.mode=Q0;break}if(J.length=V&65535,V=0,z=0,J.mode=_5,Y===HJ)break Q;case _5:J.mode=pq;case pq:if(j=J.length,j){if(j>W)j=W;if(j>$)j=$;if(j===0)break Q;q.set(X.subarray(G,G+j),U),W-=j,G+=j,$-=j,U+=j,J.length-=j;break}J.mode=T8;break;case uq:while(z<14){if(W===0)break Q;W--,V+=X[G++]<<z,z+=8}if(J.nlen=(V&31)+257,V>>>=5,z-=5,J.ndist=(V&31)+1,V>>>=5,z-=5,J.ncode=(V&15)+4,V>>>=4,z-=4,J.nlen>286||J.ndist>30){Q.msg="too many length or distance symbols",J.mode=Q0;break}J.have=0,J.mode=dq;case dq:while(J.have<J.ncode){while(z<3){if(W===0)break Q;W--,V+=X[G++]<<z,z+=8}J.lens[c[J.have++]]=V&7,V>>>=3,z-=3}while(J.have<19)J.lens[c[J.have++]]=0;if(J.lencode=J.lendyn,J.lenbits=7,B={bits:J.lenbits},f=$Q(NV,J.lens,0,19,J.lencode,0,J.work,B),J.lenbits=B.bits,f){Q.msg="invalid code lengths set",J.mode=Q0;break}J.have=0,J.mode=lq;case lq:while(J.have<J.nlen+J.ndist){for(;;){if(I=J.lencode[V&(1<<J.lenbits)-1],L=I>>>24,R=I>>>16&255,F=I&65535,L<=z)break;if(W===0)break Q;W--,V+=X[G++]<<z,z+=8}if(F<16)V>>>=L,z-=L,J.lens[J.have++]=F;else{if(F===16){A=L+2;while(z<A){if(W===0)break Q;W--,V+=X[G++]<<z,z+=8}if(V>>>=L,z-=L,J.have===0){Q.msg="invalid bit length repeat",J.mode=Q0;break}P=J.lens[J.have-1],j=3+(V&3),V>>>=2,z-=2}else if(F===17){A=L+3;while(z<A){if(W===0)break Q;W--,V+=X[G++]<<z,z+=8}V>>>=L,z-=L,P=0,j=3+(V&7),V>>>=3,z-=3}else{A=L+7;while(z<A){if(W===0)break Q;W--,V+=X[G++]<<z,z+=8}V>>>=L,z-=L,P=0,j=11+(V&127),V>>>=7,z-=7}if(J.have+j>J.nlen+J.ndist){Q.msg="invalid bit length repeat",J.mode=Q0;break}while(j--)J.lens[J.have++]=P}}if(J.mode===Q0)break;if(J.lens[256]===0){Q.msg="invalid code -- missing end-of-block",J.mode=Q0;break}if(J.lenbits=9,B={bits:J.lenbits},f=$Q(w7,J.lens,0,J.nlen,J.lencode,0,J.work,B),J.lenbits=B.bits,f){Q.msg="invalid literal/lengths set",J.mode=Q0;break}if(J.distbits=6,J.distcode=J.distdyn,B={bits:J.distbits},f=$Q(F7,J.lens,J.nlen,J.ndist,J.distcode,0,J.work,B),J.distbits=B.bits,f){Q.msg="invalid distances set",J.mode=Q0;break}if(J.mode=RJ,Y===HJ)break Q;case RJ:J.mode=PJ;case PJ:if(W>=6&&$>=258){if(Q.next_out=U,Q.avail_out=$,Q.next_in=G,Q.avail_in=W,J.hold=V,J.bits=z,LV(Q,K),U=Q.next_out,q=Q.output,$=Q.avail_out,G=Q.next_in,X=Q.input,W=Q.avail_in,V=J.hold,z=J.bits,J.mode===T8)J.back=-1;break}J.back=0;for(;;){if(I=J.lencode[V&(1<<J.lenbits)-1],L=I>>>24,R=I>>>16&255,F=I&65535,L<=z)break;if(W===0)break Q;W--,V+=X[G++]<<z,z+=8}if(R&&(R&240)===0){H=L,C=R,E=F;for(;;){if(I=J.lencode[E+((V&(1<<H+C)-1)>>H)],L=I>>>24,R=I>>>16&255,F=I&65535,H+L<=z)break;if(W===0)break Q;W--,V+=X[G++]<<z,z+=8}V>>>=H,z-=H,J.back+=H}if(V>>>=L,z-=L,J.back+=L,J.length=F,R===0){J.mode=aq;break}if(R&32){J.back=-1,J.mode=T8;break}if(R&64){Q.msg="invalid literal/length code",J.mode=Q0;break}J.extra=R&15,J.mode=nq;case nq:if(J.extra){A=J.extra;while(z<A){if(W===0)break Q;W--,V+=X[G++]<<z,z+=8}J.length+=V&(1<<J.extra)-1,V>>>=J.extra,z-=J.extra,J.back+=J.extra}J.was=J.length,J.mode=iq;case iq:for(;;){if(I=J.distcode[V&(1<<J.distbits)-1],L=I>>>24,R=I>>>16&255,F=I&65535,L<=z)break;if(W===0)break Q;W--,V+=X[G++]<<z,z+=8}if((R&240)===0){H=L,C=R,E=F;for(;;){if(I=J.distcode[E+((V&(1<<H+C)-1)>>H)],L=I>>>24,R=I>>>16&255,F=I&65535,H+L<=z)break;if(W===0)break Q;W--,V+=X[G++]<<z,z+=8}V>>>=H,z-=H,J.back+=H}if(V>>>=L,z-=L,J.back+=L,R&64){Q.msg="invalid distance code",J.mode=Q0;break}J.offset=F,J.extra=R&15,J.mode=oq;case oq:if(J.extra){A=J.extra;while(z<A){if(W===0)break Q;W--,V+=X[G++]<<z,z+=8}J.offset+=V&(1<<J.extra)-1,V>>>=J.extra,z-=J.extra,J.back+=J.extra}if(J.offset>J.dmax){Q.msg="invalid distance too far back",J.mode=Q0;break}J.mode=rq;case rq:if($===0)break Q;if(j=K-$,J.offset>j){if(j=J.offset-j,j>J.whave){if(J.sane){Q.msg="invalid distance too far back",J.mode=Q0;break}}if(j>J.wnext)j-=J.wnext,Z=J.wsize-j;else Z=J.wnext-j;if(j>J.length)j=J.length;D=J.window}else D=q,Z=U-J.offset,j=J.length;if(j>$)j=$;$-=j,J.length-=j;do q[U++]=D[Z++];while(--j);if(J.length===0)J.mode=PJ;break;case aq:if($===0)break Q;q[U++]=J.length,$--,J.mode=PJ;break;case c5:if(J.wrap){while(z<32){if(W===0)break Q;W--,V|=X[G++]<<z,z+=8}if(K-=$,Q.total_out+=K,J.total+=K,J.wrap&4&&K)Q.adler=J.check=J.flags?K0(J.check,q,K,U-K):jQ(J.check,q,K,U-K);if(K=$,J.wrap&4&&(J.flags?V:eq(V))!==J.check){Q.msg="incorrect data check",J.mode=Q0;break}V=0,z=0}J.mode=sq;case sq:if(J.wrap&&J.flags){while(z<32){if(W===0)break Q;W--,V+=X[G++]<<z,z+=8}if(J.wrap&4&&V!==(J.total&4294967295)){Q.msg="incorrect length check",J.mode=Q0;break}V=0,z=0}J.mode=tq;case tq:f=FV;break Q;case Q0:f=B7;break Q;case S7:return E7;case A7:default:return p0}if(Q.next_out=U,Q.avail_out=$,Q.next_in=G,Q.avail_in=W,J.hold=V,J.bits=z,J.wsize||K!==Q.avail_out&&J.mode<Q0&&(J.mode<c5||Y!==Aq)){if(v7(Q,Q.output,Q.next_out,K-Q.avail_out));}if(M-=Q.avail_in,K-=Q.avail_out,Q.total_in+=M,Q.total_out+=K,J.total+=K,J.wrap&4&&K)Q.adler=J.check=J.flags?K0(J.check,q,K,Q.next_out-K):jQ(J.check,q,K,Q.next_out-K);if(Q.data_type=J.bits+(J.last?64:0)+(J.mode===T8?128:0)+(J.mode===RJ||J.mode===_5?256:0),(M===0&&K===0||Y===Aq)&&f===$9)f=EV;return f},yV=(Q)=>{if(Z9(Q))return p0;let Y=Q.state;if(Y.window)Y.window=null;return Q.state=null,$9},hV=(Q,Y)=>{if(Z9(Q))return p0;const J=Q.state;if((J.wrap&2)===0)return p0;return J.head=Y,Y.done=!1,$9},mV=(Q,Y)=>{const J=Y.length;let X,q,G;if(Z9(Q))return p0;if(X=Q.state,X.wrap!==0&&X.mode!==wJ)return p0;if(X.mode===wJ){if(q=1,q=jQ(q,Y,J,0),q!==X.check)return B7}if(G=v7(Q,Y,J,J),G)return X.mode=S7,E7;return X.havedict=1,$9},_V=x7,cV=f7,pV=k7,uV=bV,dV=b7,lV=gV,nV=yV,iV=hV,oV=mV,rV="pako inflate (from Nodeca project)",w8={inflateReset:_V,inflateReset2:cV,inflateResetKeep:pV,inflateInit:uV,inflateInit2:dV,inflate:lV,inflateEnd:nV,inflateGetHeader:iV,inflateSetDictionary:oV,inflateInfo:rV},sV=aV,g7=Object.prototype.toString,{Z_NO_FLUSH:tV,Z_FINISH:eV,Z_OK:IQ,Z_STREAM_END:d5,Z_NEED_DICT:l5,Z_STREAM_ERROR:Q6,Z_DATA_ERROR:J7,Z_MEM_ERROR:J6}=z9;PQ.prototype.push=function(Q,Y){const J=this.strm,X=this.options.chunkSize,q=this.options.dictionary;let G,U,W;if(this.ended)return!1;if(Y===~~Y)U=Y;else U=Y===!0?eV:tV;if(g7.call(Q)==="[object ArrayBuffer]")J.input=new Uint8Array(Q);else J.input=Q;J.next_in=0,J.avail_in=J.input.length;for(;;){if(J.avail_out===0)J.output=new Uint8Array(X),J.next_out=0,J.avail_out=X;if(G=w8.inflate(J,U),G===l5&&q){if(G=w8.inflateSetDictionary(J,q),G===IQ)G=w8.inflate(J,U);else if(G===J7)G=l5}while(J.avail_in>0&&G===d5&&J.state.wrap>0&&Q[J.next_in]!==0)w8.inflateReset(J),G=w8.inflate(J,U);switch(G){case Q6:case J7:case l5:case J6:return this.onEnd(G),this.ended=!0,!1}if(W=J.avail_out,J.next_out){if(J.avail_out===0||G===d5)if(this.options.to==="string"){let $=DQ.utf8border(J.output,J.next_out),V=J.next_out-$,z=DQ.buf2string(J.output,$);if(J.next_out=V,J.avail_out=X-V,V)J.output.set(J.output.subarray($,$+V),0);this.onData(z)}else this.onData(J.output.length===J.next_out?J.output:J.output.subarray(0,J.next_out))}if(G===IQ&&W===0)continue;if(G===d5)return G=w8.inflateEnd(this.strm),this.onEnd(G),this.ended=!0,!0;if(J.avail_in===0)break}return!0};PQ.prototype.onData=function(Q){this.chunks.push(Q)};PQ.prototype.onEnd=function(Q){if(Q===IQ)if(this.options.to==="string")this.result=this.chunks.join("");else this.result=BJ.flattenChunks(this.chunks);this.chunks=[],this.err=Q,this.msg=this.strm.msg};var X6=PQ,q6=WY,G6=Y6,U6=WY,W6=z9,V6={Inflate:X6,inflate:q6,inflateRaw:G6,ungzip:U6,constants:W6},{Deflate:$6,deflate:z6,deflateRaw:Z6,gzip:M6}=DV,{Inflate:K6,inflate:j6,inflateRaw:O6,ungzip:D6}=V6,I6=$6,L6=z6,H6=Z6,R6=M6,P6=K6,C6=j6,T6=O6,N6=D6,w6=z9,VY={Deflate:I6,deflate:L6,deflateRaw:H6,gzip:R6,Inflate:P6,inflate:C6,inflateRaw:T6,ungzip:N6,constants:w6};class SJ{constructor(Q,Y,J,X=[]){if(this.signer=Q,this.dbInstance=Y,this.rbac=J,this.superAdminEthereumAddresses=(X||[]).map((q)=>{try{return y(q)}catch(G){return console.warn(`SSM: Invalid superadmin address skipped: ${q}`),null}}).filter(Boolean),this.localUserEthAddress=null,this._initializedPromise=this.signer&&typeof this.signer.getAddress==="function"?this._initializeAndGetAddress():Promise.resolve(),!this.signer)console.log("SSM: Instance ready for anonymous verification (no local signer).")}async _initializeAndGetAddress(){if(this.signer)this.localUserEthAddress=y(await this.signer.getAddress()),console.log(`SSM: Initialized with signer for ${this.localUserEthAddress}. SuperAdmins: ${this.superAdminEthereumAddresses.join(", ")}`)}async ready(){return this._initializedPromise}_canonicalizeDataForSigning(Q){return JSON.stringify(Q,Object.keys(Q).sort())}async signOutgoingOperations(Q){if(!this.signer||!this.localUserEthAddress)return console.error("SSM: Cannot sign operations. No active signer."),[];const Y=this.localUserEthAddress,J=[];for(let X of Q){const q={...X,originUser:Y},G=this._canonicalizeDataForSigning(q);try{const U=await this.signer.signMessage(z0(G));J.push({...X,originUser:Y,originEthAddress:Y,signature:U})}catch(U){console.error(`SSM: Error signing operation for ${Y}:`,U.message)}}return J}async verifyIncomingOperations(Q){const Y=[];for(let X of Q){let q=null,G=null;if(!X.signature||!X.originEthAddress||!X.originUser){console.warn("SSM: Incomplete op. DISCARDING.",X);continue}try{if(q=y(X.originEthAddress),y(X.originUser)!==q){console.warn("SSM: Address discrepancy. DISCARDING.",X);continue}}catch(j){console.warn("SSM: Invalid address format. DISCARDING.",j.message,X);continue}const{signature:U,originEthAddress:W,...$}=X;G=$;const V=this._canonicalizeDataForSigning(G);try{const j=XJ(z0(V),U);if(y(j)!==q){console.warn("SSM: INVALID signature. DISCARDING.",G);continue}}catch(j){console.error("SSM: Signature verification error. DISCARDING.",j.message,G);continue}let z;if(this.superAdminEthereumAddresses.includes(q))z="superadmin",console.log(`SSM: Sender ${q} recognized as a config Super Admin.`);else{const Z=(await this.dbInstance.get(`user:${q}`)).result?.value;if(Z&&Z.role&&!(Z.expiresAt&&new Date(Z.expiresAt)<new Date))z=Z.role;else z="guest"}const M=G.type,K=this.rbac.mapChangeTypeToRbacAction(M,G);if(this.rbac.can(z,K))Y.push(G);else console.warn(`SSM: Sender ${q} (role: ${z}) DENIED operation with action '${K}'.`,G)}return{validatedOperations:Y}}async encryptDataForCurrentUser(Q){if(await this.ready(),!this.signer)throw new Error("SSM Encrypt: User session (signer) required for encryption.");try{const Y=await this._deriveAesKeyInternal("ssm-encrypt-for-current-user-v1"),J=JSON.stringify(Q),X=z0(J),q=VY.deflate(X),G=W0(12),U=await crypto.subtle.encrypt({name:"AES-GCM",iv:G},Y,q);return JSON.stringify({iv:T(G),encrypted:T(new Uint8Array(U)),type:"aes-gcm-self-ssm-v2"})}catch(Y){throw console.error("SSM: Error in encryptDataForCurrentUser:",Y),new Error("SSM: Failed to encrypt personal data.")}}async decryptDataForCurrentUser(Q){if(await this.ready(),!this.signer)throw new Error("SSM Decrypt: User session (signer) required for decryption.");let Y;try{Y=JSON.parse(Q)}catch(J){throw new Error("SSM Decrypt: encryptedString is not valid JSON.")}if(Y.type!=="aes-gcm-self-ssm-v2")throw new Error("SSM Decrypt: Unsupported encryption type or incorrect version.");if(!Y.iv||!Y.encrypted)throw new Error("SSM Decrypt: Invalid encrypted data format.");try{const J=N(Y.iv),X=N(Y.encrypted),q=await this._deriveAesKeyInternal("ssm-encrypt-for-current-user-v1"),G=await crypto.subtle.decrypt({name:"AES-GCM",iv:J},q,X),U=VY.inflate(new Uint8Array(G));return JSON.parse(vQ(U))}catch(J){throw console.error("SSM: Error in decryptDataForCurrentUser:",J),new Error("SSM: Failed to decrypt personal data.")}}async _deriveAesKeyInternal(Q="ssm-default-aes-salt"){const Y=N(this.signer.privateKey),J=z0(Q),X=await crypto.subtle.importKey("raw",Y,{name:"PBKDF2"},!1,["deriveKey"]);return crypto.subtle.deriveKey({name:"PBKDF2",salt:J,iterations:1e5,hash:"SHA-256"},X,{name:"AES-GCM",length:256},!0,["encrypt","decrypt"])}}var h9=function(Q){if(!(Q instanceof ArrayBuffer))if(Q.buffer&&Q.buffer instanceof ArrayBuffer)Q=Q.buffer.slice(Q.byteOffset,Q.byteOffset+Q.byteLength);else throw console.error("arrayBufferToBase64Url: input is not ArrayBuffer nor TypedArray with .buffer",Q),new Error("arrayBufferToBase64Url: ArrayBuffer or TypedArray required.");return btoa(String.fromCharCode(...new Uint8Array(Q))).replace(/\+/g,"-").replace(/\//g,"_").replace(/=+$/,"")},m9=function(Q){let Y=Q.replace(/-/g,"+").replace(/_/g,"/");const J=atob(Y),X=new ArrayBuffer(J.length),q=new Uint8Array(X);for(let G=0;G<J.length;G++)q[G]=J.charCodeAt(G);return X},AJ="gdb_ethereum_material_encrypted_webauthn_v2",CQ="gdb_webauthn_registration_details_v2";class $Y{constructor(){this.signer=null,this.address=null,this.mnemonic=null,this.webAuthnCredentialId=null,this.webAuthnOriginalChallengeUsedForEncryption=null}async createNewEthereumIdentity(){const Q=_0.createRandom();return this.mnemonic=Q.mnemonic.phrase,console.log("SWM: New Ethereum identity generated (mnemonic and private key in memory)."),{address:await Q.getAddress(),mnemonic:this.mnemonic,privateKey:Q.privateKey}}async _encryptEthereumPrivateKey(Q,Y){const J=W0(12),X=N(Q),q=await window.crypto.subtle.encrypt({name:"AES-GCM",iv:J},Y,X);return JSON.stringify({iv:h9(J.buffer.slice(J.byteOffset,J.byteOffset+J.byteLength)),ciphertext:h9(q)})}async _decryptEthereumPrivateKey(Q,Y){const{iv:J,ciphertext:X}=JSON.parse(Q),q=m9(J),G=m9(X),U=await window.crypto.subtle.decrypt({name:"AES-GCM",iv:new Uint8Array(q)},Y,G);return T(new Uint8Array(U))}async _deriveAesGcmKeyFromWebAuthn(Q,Y){const J=await window.crypto.subtle.importKey("raw",Y,{name:"PBKDF2"},!1,["deriveKey"]);return window.crypto.subtle.deriveKey({name:"PBKDF2",salt:Q,iterations:200000,hash:"SHA-256"},J,{name:"AES-GCM",length:256},!0,["encrypt","decrypt"])}async _loadAndDecryptWalletFromWebAuthnMaterial(Q,Y){const J=localStorage.getItem(AJ);if(!J)return console.warn("SWM (_loadAndDecrypt): No encrypted Ethereum material found."),this.logout(),null;try{const X=await this._deriveAesGcmKeyFromWebAuthn(Q,Y),q=await this._decryptEthereumPrivateKey(J,X),G=new _0(q);return this.signer=G,this.address=await G.getAddress(),this.mnemonic=null,this.webAuthnCredentialId=Q,this.webAuthnOriginalChallengeUsedForEncryption=Y,console.log(`SWM (_loadAndDecrypt): Session established for ${this.address}`),this.address}catch(X){return console.error("SWM (_loadAndDecrypt): Error (decryption/wallet loading):",X),this.logout(),null}}async registerAndProtectWithWebAuthn(Q){if(!window.navigator.credentials||!window.navigator.credentials.create)return console.error("SWM: WebAuthn is not supported by this browser."),alert("WebAuthn is not supported by this browser."),!1;const Y=W0(32),J=Y.buffer.slice(Y.byteOffset,Y.byteOffset+Y.byteLength);try{const X=q0.computePublicKey(Q,!1),q=N(X),G=N(n(q)),W=G.buffer.slice(G.byteOffset,G.byteOffset+Math.min(G.length,64)),V=new _0(Q).address.slice(0,10),z={challenge:J,rp:{name:"GDB WebAuthn App",id:window.location.hostname},user:{id:W,name:`user-${V}`,displayName:"GDB User"},pubKeyCredParams:[{type:"public-key",alg:-7},{type:"public-key",alg:-257}],authenticatorSelection:{authenticatorAttachment:"platform",userVerification:"preferred",residentKey:"preferred",requireResidentKey:!1},timeout:60000,attestation:"none"},M=await window.navigator.credentials.create({publicKey:z});if(!M||!M.rawId||!M.id)throw new Error("WebAuthn registration failed or was canceled (no credential).");const K=M.rawId,j=await this._deriveAesGcmKeyFromWebAuthn(K,J),Z=await this._encryptEthereumPrivateKey(Q,j);return localStorage.setItem(AJ,Z),localStorage.setItem(CQ,JSON.stringify({credentialIdBase64Url:h9(K),originalChallengeBase64Url:h9(J)})),console.log("SWM: WebAuthn registered and Ethereum key encrypted and saved."),await this._loadAndDecryptWalletFromWebAuthnMaterial(K,J)}catch(X){return console.error("SWM: Error during WebAuthn registration:",X),this.logout(),localStorage.removeItem(AJ),localStorage.removeItem(CQ),alert(`WebAuthn registration error: ${X.message||"Unknown. Check console."}`),!1}}async loginWithWebAuthn(){if(!window.navigator.credentials||!window.navigator.credentials.get)return console.error("SWM: WebAuthn is not supported."),alert("WebAuthn is not supported by this browser."),null;const Q=localStorage.getItem(CQ);if(!Q)return console.warn("SWM: No WebAuthn registration details saved."),null;let Y;try{Y=JSON.parse(Q)}catch(U){return console.error("SWM: Error parsing WebAuthn registration details from localStorage:",U),null}if(!Y.credentialIdBase64Url||!Y.originalChallengeBase64Url)return console.error("SWM: WebAuthn registration details in localStorage are incomplete."),null;const J=m9(Y.credentialIdBase64Url),X=m9(Y.originalChallengeBase64Url),q=W0(32),G=q.buffer.slice(q.byteOffset,q.byteOffset+q.byteLength);try{const U={challenge:G,allowCredentials:[{type:"public-key",id:J}],userVerification:"preferred",timeout:60000},W=await window.navigator.credentials.get({publicKey:U});if(!W||!W.rawId||!W.response||!W.response.authenticatorData||!W.response.signature||!W.response.clientDataJSON)throw new Error("WebAuthn authentication failed or was canceled (incomplete assertion).");if(h9(W.rawId)!==Y.credentialIdBase64Url)throw new Error("WebAuthn credential ID in assertion does not match stored ID.");const $=JSON.parse((new TextDecoder()).decode(W.response.clientDataJSON));if($.challenge!==h9(G))throw new Error("WebAuthn assertion challenge mismatch.");if($.origin!==`https://${window.location.hostname}`&&$.origin!==`http://${window.location.hostname}`){let V=window.location.protocol+"//";if($.origin.startsWith(V+window.location.hostname));else if(window.location.hostname==="localhost"&&$.origin.startsWith(V+"localhost"));else console.warn("WebAuthn assertion origin mismatch. Expected based on hostname:",window.location.hostname,"Got:",$.origin)}return console.log("SWM: Interactive WebAuthn assertion received and validated."),await this._loadAndDecryptWalletFromWebAuthnMaterial(W.rawId,X)}catch(U){return console.error("SWM: Error during interactive WebAuthn login:",U),this.logout(),null}}async trySilentWebAuthnLogin(){console.log("SWM: Attempting silent WebAuthn login...");const Q=localStorage.getItem(CQ);if(!Q)return console.warn("SWM Silent Login: No WebAuthn registration details."),null;let Y;try{Y=JSON.parse(Q)}catch(J){return console.error("SWM Silent Login: Error parsing registration details:",J),null}if(!Y.credentialIdBase64Url||!Y.originalChallengeBase64Url)return console.error("SWM Silent Login: Incomplete WebAuthn registration details."),null;try{const J=m9(Y.credentialIdBase64Url),X=m9(Y.originalChallengeBase64Url),q=await this._loadAndDecryptWalletFromWebAuthnMaterial(J,X);if(q)return console.log(`SWM Silent Login: Success for ${q}.`),q;else return console.warn("SWM Silent Login: _loadAndDecryptWalletFromWebAuthnMaterial failed."),null}catch(J){return console.error("SWM Silent Login: Error during silent login attempt:",J),this.logout(),null}}async loadWalletFromMnemonic(Q){try{const Y=_0.fromPhrase(Q);return this.signer=Y,this.address=await Y.getAddress(),this.mnemonic=Q,this.webAuthnCredentialId=null,this.webAuthnOriginalChallengeUsedForEncryption=null,console.log(`SWM: Wallet loaded from mnemonic for ${this.address}. Signer set.`),{address:this.address,privateKey:Y.privateKey,mnemonic:Q}}catch(Y){return console.error("SWM: Error loading wallet from mnemonic:",Y),this.logout(),null}}hasWebAuthnRegistration(){return localStorage.getItem(CQ)!==null&&localStorage.getItem(AJ)!==null}logout(){this.signer=null,this.address=null,this.mnemonic=null,this.webAuthnCredentialId=null,this.webAuthnOriginalChallengeUsedForEncryption=null,console.log("SWM: Wallet session closed (SWM internal state cleared).")}getSigner(){return this.signer}getAddress(){return this.address}getMnemonicForDisplay(){if(this.mnemonic&&(!this.webAuthnCredentialId||!this.webAuthnOriginalChallengeUsedForEncryption))return this.mnemonic;return null}isSessionWebAuthnProtected(){return!!(this.signer&&this.webAuthnCredentialId&&this.webAuthnOriginalChallengeUsedForEncryption)}}function LK(Q){if(typeof Q!=="object"||Q===null||Array.isArray(Q))throw new Error("RBAC: Custom roles must be a valid object.");zY=Q,console.log("RBAC: Custom roles set.")}function kJ(Q,Y,J=new Set){const X=zY;if(!Q||!X[Q])return!1;if(J.has(Q))return console.warn(`RBAC: Inheritance loop detected involving role '${Q}'.`),!1;if(J.add(Q),X[Q].can&&X[Q].can.includes(Y))return J.delete(Q),!0;if(X[Q].inherits&&Array.isArray(X[Q].inherits)){if(X[Q].inherits.some((q)=>kJ(q,Y,new Set(J))))return J.delete(Q),!0}return J.delete(Q),!1}function y7(Q,Y={}){if(Q==="upsert")return"write";if(Q==="remove")return"delete";if(Q==="link")return"link";if(Q==="sync"||Q==="syncReceive"||Q==="deltaSync")return"sync";return console.warn(`RBAC mapChangeTypeToRbacAction: Unknown change type '${Q}'.`),"unknown"}function HK(Q){if(typeof Q==="function")xJ=Q;else if(Q===null)xJ=null;else console.warn("RBAC: Attempted to set invalid state change callback.")}var i0=function(){if(xJ)xJ({isActive:B0,activeAddress:k?.securityManager?.localUserEthAddress||J0.getAddress(),isWebAuthnProtected:n0,hasVolatileIdentity:!!F0,hasWebAuthnHardwareRegistration:J0.hasWebAuthnRegistration()})};async function RK(){if(B0)await bJ();J0.logout(),F0=null,n0=!1,localStorage.removeItem(q8);try{const Q=await J0.createNewEthereumIdentity();if(Q)F0=Q;return i0(),Q}catch(Q){throw F0=null,i0(),Q}}async function PK(Q){const Y=Q||F0?.privateKey;if(!Y)return alert("RBAC Error: No volatile ETH identity to protect."),null;if(B0&&n0&&k?.securityManager?.signer)return k.securityManager.localUserEthAddress;if(B0)await bJ();J0.logout();const J=await J0.registerAndProtectWithWebAuthn(Y);if(J&&J0.getSigner()){if(F0=null,n0=!0,localStorage.setItem(q8,"true"),k)await fJ(J0.getSigner());else console.warn("RBAC: Identity protected, but GDB not configured. Global RBAC signing not active.");return J}else return n0=!1,localStorage.removeItem(q8),i0(),null}async function CK(){if(B0)await bJ();J0.logout(),F0=null;const Q=await J0.loginWithWebAuthn();if(Q&&J0.getSigner()){if(n0=!0,localStorage.setItem(q8,"true"),k)await fJ(J0.getSigner());else console.warn("RBAC: WebAuthn login OK, but GDB not configured for full security activation.");return Q}else return n0=!1,localStorage.removeItem(q8),i0(),null}async function TK(Q){if(B0)await bJ();J0.logout(),F0=null;const Y=await J0.loadWalletFromMnemonic(Q);if(Y&&Y.address&&J0.getSigner()){if(F0=Y,n0=!1,localStorage.removeItem(q8),k)await fJ(J0.getSigner());else console.warn("RBAC: Mnemonic loaded, but GDB not configured for full security activation.");return F0}else return i0(),null}async function NK(Q,Y=[]){if(!Q){console.error("RBAC: GDB instance is required.");return}if(k=Q,TQ=(Y||[]).map((J)=>{try{return y(J)}catch(X){return console.warn(`RBAC: Invalid superadmin address skipped: ${J}`),null}}).filter(Boolean),!k.securityManager||!(k.securityManager instanceof SJ))k.securityManager=new SJ(null,k,{can:kJ,mapChangeTypeToRbacAction:y7},TQ),console.log("RBAC: ANONYMOUS/VERIFIER SecurityManager configured on GDB instance by RBAC.");else console.log("RBAC: GDB instance already had a SecurityManager. RBAC will use it."),k.securityManager.rbac={can:kJ,mapChangeTypeToRbacAction:y7},k.securityManager.superAdminEthereumAddresses=TQ,k.securityManager.dbInstance=k;if(console.log("RBAC: Security context (GDB & SuperAdmins) established. GDB SM is ready for verification."),localStorage.getItem(q8)==="true"&&J0.hasWebAuthnRegistration()){console.log("RBAC: Previous WebAuthn session detected. Attempting silent login...");try{const J=await J0.trySilentWebAuthnLogin();if(J&&J0.getSigner())n0=!0,await fJ(J0.getSigner()),console.log(`RBAC: Silent WebAuthn login successful for ${J}.`);else console.warn("RBAC: Silent WebAuthn login failed or no signer obtained. Manual login required."),localStorage.removeItem(q8),i0()}catch(J){console.error("RBAC: Error during silent WebAuthn login attempt:",J),localStorage.removeItem(q8),i0()}}else i0()}async function fJ(Q){if(!k||!k.securityManager||!Q)return console.error("RBAC Internal: GDB, GDB's SecurityManager, or signer missing for security activation."),B0=!1,i0(),!1;const Y=k.securityManager;if(Y.signer=Q,await Y._initializeAndGetAddress(),console.log(`RBAC: Signer activated on GDB.SecurityManager for ETH: ${Y.localUserEthAddress}`),k.sendData&&!k._originalSendDataBySoftwareRBAC)k._originalSendDataBySoftwareRBAC=k.sendData.bind(k),k.sendData=async(q)=>{const G=await k.securityManager.signOutgoingOperations(q);return k._originalSendDataBySoftwareRBAC(G)},console.log("RBAC: gdbInstance.sendData wrapped for signing.");const J=Y.localUserEthAddress,X=`user:${J}`;try{await k.ready;const q=await k.get(X),G=q.result?.value||{};let U=G.role;if(!U)U=TQ.includes(J)?"superadmin":"user";if(G.role!==U||!q.result||G.ethAddress!==J){const W=k.hybridClock.now();await k.graph.upsert(X,{...G,ethAddress:J,role:U},W),k.sendData([{type:"sync",timestamp:null}]),console.log(`RBAC: User node for ${J} (role '${U}') ensured in GDB.`)}}catch(q){console.error(`RBAC: Error ensuring user node for ${J}:`,q)}return B0=!0,i0(),console.log(`RBAC: P2P signing security ACTIVE for ${J}. GDB's SM will verify all incoming ops.`),!0}async function bJ(){if(console.log("RBAC: Clearing active signing session..."),k&&k._originalSendDataBySoftwareRBAC)k.sendData=k._originalSendDataBySoftwareRBAC,delete k._originalSendDataBySoftwareRBAC,console.log("RBAC: gdbInstance.sendData restored to original.");if(J0.logout(),k&&k.securityManager)k.securityManager.signer=null,k.securityManager.localUserEthAddress=null,console.log("RBAC: Signer removed from GDB.SecurityManager. It now operates in anonymous/verifier mode.");F0=null,n0=!1,localStorage.removeItem(q8),B0=!1,i0(),console.log("RBAC: Signing session closed. GDB.SecurityManager continues to verify incoming P2P operations.")}async function wK(Q,Y){let J="RBAC_ID_PREFIX_"+Y;if(!k)throw new Error("RBAC.put: Not initialized");if(!k.securityManager?.signer)throw new Error("RBAC.put: Session not active");const{result:X}=await F6(J);if(X&&X.decrypted===!1)throw new Error(`RBAC.put: Cannot overwrite encrypted data on node ID '${Y}' owned by another user. DENIED.`);const q=k.securityManager;let G,U;try{const $=await q.encryptDataForCurrentUser(Q),V=JSON.parse($);G=V.encrypted,U={owner:q.localUserEthAddress,encType:V.type,iv:V.iv}}catch($){throw console.error(`RBAC.put: Encryption failed for ID ${Y||"(new)"}: ${$.message}`),$}const W={_gdbWrapperType:h7,_payload:G,_meta:U};return console.log(`RBAC.put: Storing wrapped secure payload for ID: ${Y||"(new)"}`),(await k.put(W,J)).replace(/^RBAC_ID_PREFIX_/,"")}async function F6(Q,Y=null){let J="RBAC_ID_PREFIX_"+Q;if(!k)throw new Error("RBAC.get: Not initialized");const X=k.securityManager,q=async($)=>{if(!$)return null;let V=$.value,z=!1;if(V&&V._gdbWrapperType===h7){const M=V,K=M._payload,j=M._meta;if(V=typeof K==="string"?K:M,j&&j.owner&&X&&X.signer&&j.owner===X.localUserEthAddress)try{const Z=JSON.stringify({iv:j.iv,encrypted:K,type:j.encType});V=await X.decryptDataForCurrentUser(Z),z=!0}catch(Z){console.error(`RBAC.get: Decryption failed for node ${$.id}. User: ${X.localUserEthAddress}, Owner: ${j.owner}. Error: ${Z.message}`)}else if(j&&j.owner)console.warn(`RBAC.get: Decryption not attempted for node ${$.id}. Owner: ${j.owner}. Session active: ${!!(X&&X.signer)}`);else console.warn(`RBAC.get: Secure payload wrapper for node ${$.id} lacks sufficient metadata for decryption.`)}return{id:Q,value:V,edges:$.edges||[],timestamp:$.timestamp,decrypted:z}};if(!Y){const $=await k.get(J,null);return{result:await q($?$.result:null)}}let G=null;const U=await k.get(J,null);if(G=await q(U?U.result:null),typeof Y==="function")Y(G);const{unsubscribe:W}=await k.get(J,async($)=>{const V=await q($),z=V&&G&&k.hybridClock?.compare(V.timestamp,G.timestamp)>0,M=JSON.stringify(V?V.value:null)!==JSON.stringify(G?G.value:null);if(!V&&G){if(G=null,typeof Y==="function")Y(null)}else if(V&&(!G||z||M)){if(G=V,typeof Y==="function")Y(V)}});return{result:G,unsubscribe:()=>{if(W)W()}}}var m7=function(){if(!B0||!k?.securityManager?.localUserEthAddress)throw new Error("RBAC Operation: Security not active or no local user ETH identified in SecurityManager.");return k.securityManager.localUserEthAddress};async function FK(Q,Y,J=null){if(!Q||!Y)throw new Error("RBAC assignRole: targetUserEthAddress, and role are required.");let X;try{X=y(Q)}catch(V){throw new Error(`RBAC assignRole: targetUserEthAddress '${Q}' is invalid.`)}if(!zY[Y])throw new Error(`RBAC assignRole: Role '${Y}' is not a defined role.`);const q=m7(),G=`user:${X}`,$={...(await k.get(G)).result?.value||{},ethAddress:X,role:Y,assignedByEthAddress:q,expiresAt:J?new Date(J).toISOString():null};await k.put($,G),console.log(`RBAC: Role '${Y}' for ${Q} by ${q} written.`)}async function B6(){if(!B0||!k?.securityManager?.localUserEthAddress)return!1;return TQ.includes(k.securityManager.localUserEthAddress)}async function E6(Q,Y="unknown"){let J;try{J=y(Q)}catch(G){throw new Error(`RBAC: Invalid ETH address '${Q}' when verifying role for op '${Y}'.`)}const X=await k.get(`user:${J}`);if(!X.result?.value?.role)throw console.warn(`RBAC verifyUserRoleLocal: Node/role not found for ETH ${J}. Op: ${Y}. Data:`,X.result?.value),new Error(`RBAC: Role not found for ETH ${J} (operation: ${Y}).`);const q=X.result.value;if(q.expiresAt&&new Date(q.expiresAt)<new Date)throw new Error(`RBAC: Role for ETH ${J} has expired.`);return q.role}async function S6(Q,Y){const J=await E6(Q,Y);if(!kJ(J,Y))throw new Error(`RBAC: ETH User ${Q} (role ${J}) does not have permission for '${Y}'.`)}async function BK(Q){if(!Q)throw new Error("RBAC executeWithPermission: operationName is required.");const Y=m7();if(!(Q==="assignRole"&&await B6()))await S6(Y,Q);return Y}function EK(){return B0?k?.securityManager?.localUserEthAddress:null}function _7(){return B0&&!!k?.securityManager?.signer}function SK(){return B0&&n0}function AK(){return J0.hasWebAuthnRegistration()}function kK(){if(F0&&F0.mnemonic&&!J0.isSessionWebAuthnProtected())return F0.mnemonic;return J0.getMnemonicForDisplay()}async function xK(Q){if(!_7()||!k?.securityManager)throw new Error("RBAC Encryption: Local signing security not active or SecurityManager not available.");return await k.securityManager.encryptDataForCurrentUser(Q)}async function fK(Q){if(!_7()||!k?.securityManager)throw new Error("RBAC Decryption: Local signing security not active or SecurityManager not available.");return await k.securityManager.decryptDataForCurrentUser(Q)}var zY={superadmin:{can:["assignRole","deleteAny"],inherits:["admin"]},admin:{can:["delete"],inherits:["manager"]},manager:{can:["publish"],inherits:["user"]},user:{can:["write","link","sync"],inherits:["guest"]},guest:{can:["read","sync"]}},q8="gdb_rbac_last_session_was_webauthn",k=null,J0=new $Y,TQ=[],B0=!1,F0=null,n0=!1,xJ=null,h7="_gdbSecurePayloadV1";export{RK as startNewUserRegistration,HK as setSecurityStateChangeCallback,LK as setCustomRoles,wK as put,PK as protectCurrentIdentityWithWebAuthn,y7 as mapChangeTypeToRbacAction,TK as loginOrRecoverUserWithMnemonic,CK as loginCurrentUserWithWebAuthn,_7 as isSecurityActive,SK as isCurrentSessionProtectedByWebAuthn,AK as hasExistingWebAuthnRegistration,kK as getMnemonicForDisplayAfterRegistrationOrRecovery,EK as getActiveEthAddress,F6 as get,BK as executeWithPermission,xK as encryptDataForCurrentUser,fK as decryptDataForCurrentUser,NK as createSecurityContext,bJ as clearSecurity,kJ as can,FK as assignRole};
