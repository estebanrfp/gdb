var A0=typeof globalThis==="object"&&("crypto"in globalThis)?globalThis.crypto:void 0;function w0($){return $ instanceof Uint8Array||ArrayBuffer.isView($)&&$.constructor.name==="Uint8Array"}function c0($){if(!Number.isSafeInteger($)||$<0)throw new Error("positive integer expected, got "+$)}function $0($,...J){if(!w0($))throw new Error("Uint8Array expected");if(J.length>0&&!J.includes($.length))throw new Error("Uint8Array expected of length "+J+", got length="+$.length)}function Y8($){if(typeof $!=="function"||typeof $.create!=="function")throw new Error("Hash should be wrapped by utils.createHasher");c0($.outputLen),c0($.blockLen)}function b0($,J=!0){if($.destroyed)throw new Error("Hash instance has been destroyed");if(J&&$.finished)throw new Error("Hash#digest() has already been called")}function q$($,J){$0($);const q=J.outputLen;if($.length<q)throw new Error("digestInto() expects output buffer of length at least "+q)}function I0(...$){for(let J=0;J<$.length;J++)$[J].fill(0)}function j8($){return new DataView($.buffer,$.byteOffset,$.byteLength)}function Q0($,J){return $<<32-J|$>>>J}function K0($){if($0($),G$)return $.toHex();let J="";for(let q=0;q<$.length;q++)J+=TQ[$[q]];return J}var J$=function($){if($>=Z0._0&&$<=Z0._9)return $-Z0._0;if($>=Z0.A&&$<=Z0.F)return $-(Z0.A-10);if($>=Z0.a&&$<=Z0.f)return $-(Z0.a-10);return};function k0($){if(typeof $!=="string")throw new Error("hex string expected, got "+typeof $);if(G$)return Uint8Array.fromHex($);const J=$.length,q=J/2;if(J%2)throw new Error("hex string expected, got unpadded hex of length "+J);const Q=new Uint8Array(q);for(let G=0,z=0;G<q;G++,z+=2){const U=J$($.charCodeAt(z)),Z=J$($.charCodeAt(z+1));if(U===void 0||Z===void 0){const j=$[z]+$[z+1];throw new Error('hex string expected, got non-hex character "'+j+'" at index '+z)}Q[G]=U*16+Z}return Q}function X8($){if(typeof $!=="string")throw new Error("string expected");return new Uint8Array((new TextEncoder()).encode($))}function d0($){if(typeof $==="string")$=X8($);return $0($),$}function r(...$){let J=0;for(let Q=0;Q<$.length;Q++){const G=$[Q];$0(G),J+=G.length}const q=new Uint8Array(J);for(let Q=0,G=0;Q<$.length;Q++){const z=$[Q];q.set(z,G),G+=z.length}return q}function z$($){const J=(Q)=>$().update(d0(Q)).digest(),q=$();return J.outputLen=q.outputLen,J.blockLen=q.blockLen,J.create=()=>$(),J}function S0($=32){if(A0&&typeof A0.getRandomValues==="function")return A0.getRandomValues(new Uint8Array($));if(A0&&typeof A0.randomBytes==="function")return Uint8Array.from(A0.randomBytes($));throw new Error("crypto.getRandomValues must be defined")}/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */var G$=(()=>typeof Uint8Array.from([]).toHex==="function"&&typeof Uint8Array.fromHex==="function")(),TQ=Array.from({length:256},($,J)=>J.toString(16).padStart(2,"0")),Z0={_0:48,_9:57,A:65,F:70,a:97,f:102};class o0{}function HQ($,J,q,Q){if(typeof $.setBigUint64==="function")return $.setBigUint64(J,q,Q);const G=BigInt(32),z=BigInt(4294967295),U=Number(q>>G&z),Z=Number(q&z),j=Q?4:0,V=Q?0:4;$.setUint32(J+j,U,Q),$.setUint32(J+V,Z,Q)}function U$($,J,q){return $&J^~$&q}function Y$($,J,q){return $&J^$&q^J&q}class S8 extends o0{constructor($,J,q,Q){super();this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.blockLen=$,this.outputLen=J,this.padOffset=q,this.isLE=Q,this.buffer=new Uint8Array($),this.view=j8(this.buffer)}update($){b0(this),$=d0($),$0($);const{view:J,buffer:q,blockLen:Q}=this,G=$.length;for(let z=0;z<G;){const U=Math.min(Q-this.pos,G-z);if(U===Q){const Z=j8($);for(;Q<=G-z;z+=Q)this.process(Z,z);continue}if(q.set($.subarray(z,z+U),this.pos),this.pos+=U,z+=U,this.pos===Q)this.process(J,0),this.pos=0}return this.length+=$.length,this.roundClean(),this}digestInto($){b0(this),q$($,this),this.finished=!0;const{buffer:J,view:q,blockLen:Q,isLE:G}=this;let{pos:z}=this;if(J[z++]=128,I0(this.buffer.subarray(z)),this.padOffset>Q-z)this.process(q,0),z=0;for(let N=z;N<Q;N++)J[N]=0;HQ(q,Q-8,BigInt(this.length*8),G),this.process(q,0);const U=j8($),Z=this.outputLen;if(Z%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const j=Z/4,V=this.get();if(j>V.length)throw new Error("_sha2: outputLen bigger than state");for(let N=0;N<j;N++)U.setUint32(4*N,V[N],G)}digest(){const{buffer:$,outputLen:J}=this;this.digestInto($);const q=$.slice(0,J);return this.destroy(),q}_cloneInto($){$||($=new this.constructor),$.set(...this.get());const{blockLen:J,buffer:q,length:Q,finished:G,destroyed:z,pos:U}=this;if($.destroyed=z,$.finished=G,$.length=Q,$.pos=U,Q%J)$.buffer.set(q);return $}clone(){return this._cloneInto()}}var M0=Uint32Array.from([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]);var OQ=Uint32Array.from([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),R0=new Uint32Array(64);class j$ extends S8{constructor($=32){super(64,$,8,!1);this.A=M0[0]|0,this.B=M0[1]|0,this.C=M0[2]|0,this.D=M0[3]|0,this.E=M0[4]|0,this.F=M0[5]|0,this.G=M0[6]|0,this.H=M0[7]|0}get(){const{A:$,B:J,C:q,D:Q,E:G,F:z,G:U,H:Z}=this;return[$,J,q,Q,G,z,U,Z]}set($,J,q,Q,G,z,U,Z){this.A=$|0,this.B=J|0,this.C=q|0,this.D=Q|0,this.E=G|0,this.F=z|0,this.G=U|0,this.H=Z|0}process($,J){for(let N=0;N<16;N++,J+=4)R0[N]=$.getUint32(J,!1);for(let N=16;N<64;N++){const L=R0[N-15],Y=R0[N-2],K=Q0(L,7)^Q0(L,18)^L>>>3,H=Q0(Y,17)^Q0(Y,19)^Y>>>10;R0[N]=H+R0[N-7]+K+R0[N-16]|0}let{A:q,B:Q,C:G,D:z,E:U,F:Z,G:j,H:V}=this;for(let N=0;N<64;N++){const L=Q0(U,6)^Q0(U,11)^Q0(U,25),Y=V+L+U$(U,Z,j)+OQ[N]+R0[N]|0,H=(Q0(q,2)^Q0(q,13)^Q0(q,22))+Y$(q,Q,G)|0;V=j,j=Z,Z=U,U=z+Y|0,z=G,G=Q,Q=q,q=Y+H|0}q=q+this.A|0,Q=Q+this.B|0,G=G+this.C|0,z=z+this.D|0,U=U+this.E|0,Z=Z+this.F|0,j=j+this.G|0,V=V+this.H|0,this.set(q,Q,G,z,U,Z,j,V)}roundClean(){I0(R0)}destroy(){this.set(0,0,0,0,0,0,0,0),I0(this.buffer)}}var Z8=z$(()=>new j$);class P8 extends o0{constructor($,J){super();this.finished=!1,this.destroyed=!1,Y8($);const q=d0(J);if(this.iHash=$.create(),typeof this.iHash.update!=="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const Q=this.blockLen,G=new Uint8Array(Q);G.set(q.length>Q?$.create().update(q).digest():q);for(let z=0;z<G.length;z++)G[z]^=54;this.iHash.update(G),this.oHash=$.create();for(let z=0;z<G.length;z++)G[z]^=54^92;this.oHash.update(G),I0(G)}update($){return b0(this),this.iHash.update($),this}digestInto($){b0(this),$0($,this.outputLen),this.finished=!0,this.iHash.digestInto($),this.oHash.update($),this.oHash.digestInto($),this.destroy()}digest(){const $=new Uint8Array(this.oHash.outputLen);return this.digestInto($),$}_cloneInto($){$||($=Object.create(Object.getPrototypeOf(this),{}));const{oHash:J,iHash:q,finished:Q,destroyed:G,blockLen:z,outputLen:U}=this;return $=$,$.finished=Q,$.destroyed=G,$.blockLen=z,$.outputLen=U,$.oHash=J._cloneInto($.oHash),$.iHash=q._cloneInto($.iHash),$}clone(){return this._cloneInto()}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}var E8=($,J,q)=>new P8($,J).update(q).digest();E8.create=($,J)=>new P8($,J);function r0($,J=""){if(typeof $!=="boolean"){const q=J&&`"${J}"`;throw new Error(q+"expected boolean, got type="+typeof $)}return $}function T0($,J,q=""){const Q=w0($),G=$?.length,z=J!==void 0;if(!Q||z&&G!==J){const U=q&&`"${q}" `,Z=z?` of length ${J}`:"",j=Q?`length=${G}`:`type=${typeof $}`;throw new Error(U+"expected Uint8Array"+Z+", got "+j)}return $}function p0($){const J=$.toString(16);return J.length&1?"0"+J:J}function X$($){if(typeof $!=="string")throw new Error("hex string expected, got "+typeof $);return $===""?b8:BigInt("0x"+$)}function D0($){return X$(K0($))}function _8($){return $0($),X$(K0(Uint8Array.from($).reverse()))}function _0($,J){return k0($.toString(16).padStart(J*2,"0"))}function g8($,J){return _0($,J).reverse()}function m($,J,q){let Q;if(typeof J==="string")try{Q=k0(J)}catch(z){throw new Error($+" must be hex string or Uint8Array, cause: "+z)}else if(w0(J))Q=Uint8Array.from(J);else throw new Error($+" must be hex string or Uint8Array");const G=Q.length;if(typeof q==="number"&&G!==q)throw new Error($+" of length "+q+" expected, got "+G);return Q}function i0($,J,q){return v8($)&&v8(J)&&v8(q)&&J<=$&&$<q}function Z$($,J,q,Q){if(!i0(J,q,Q))throw new Error("expected valid "+$+": "+q+" <= n < "+Q+", got "+J)}function K8($){let J;for(J=0;$>b8;$>>=f8,J+=1);return J}function K$($,J,q){if(typeof $!=="number"||$<2)throw new Error("hashLen must be a number");if(typeof J!=="number"||J<2)throw new Error("qByteLen must be a number");if(typeof q!=="function")throw new Error("hmacFn must be a function");const Q=(K)=>new Uint8Array(K),G=(K)=>Uint8Array.of(K);let z=Q($),U=Q($),Z=0;const j=()=>{z.fill(1),U.fill(0),Z=0},V=(...K)=>q(U,z,...K),N=(K=Q(0))=>{if(U=V(G(0),K),z=V(),K.length===0)return;U=V(G(1),K),z=V()},L=()=>{if(Z++>=1000)throw new Error("drbg: tried 1000 values");let K=0;const H=[];while(K<J){z=V();const A=z.slice();H.push(A),K+=z.length}return r(...H)};return(K,H)=>{j(),N(K);let A=void 0;while(!(A=H(L())))N();return j(),A}}function a0($,J,q={}){if(!$||typeof $!=="object")throw new Error("expected valid options object");function Q(G,z,U){const Z=$[G];if(U&&Z===void 0)return;const j=typeof Z;if(j!==z||Z===null)throw new Error(`param "${G}" is invalid: expected ${z}, got ${j}`)}Object.entries(J).forEach(([G,z])=>Q(G,z,!1)),Object.entries(q).forEach(([G,z])=>Q(G,z,!0))}function y8($){const J=new WeakMap;return(q,...Q)=>{const G=J.get(q);if(G!==void 0)return G;const z=$(q,...Q);return J.set(q,z),z}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */var b8=BigInt(0),f8=BigInt(1),v8=($)=>typeof $==="bigint"&&b8<=$,H0=($)=>(f8<<BigInt($))-f8;function i($,J){const q=$%J;return q>=l?q:J+q}function a($,J,q){let Q=$;while(J-- >l)Q*=Q,Q%=q;return Q}function M$($,J){if($===l)throw new Error("invert: expected non-zero number");if(J<=l)throw new Error("invert: expected positive modulus, got "+J);let q=i($,J),Q=J,G=l,z=h,U=h,Z=l;while(q!==l){const V=Q/q,N=Q%q,L=G-U*V,Y=z-Z*V;Q=q,q=N,G=U,z=Z,U=L,Z=Y}if(Q!==h)throw new Error("invert: does not exist");return i(G,J)}var u8=function($,J,q){if(!$.eql($.sqr(J),q))throw new Error("Cannot find square root")},R$=function($,J){const q=($.ORDER+h)/N$,Q=$.pow(J,q);return u8($,Q,J),Q},AQ=function($,J){const q=($.ORDER-V$)/C$,Q=$.mul(J,P0),G=$.pow(Q,q),z=$.mul(J,G),U=$.mul($.mul(z,P0),G),Z=$.mul(z,$.sub(U,$.ONE));return u8($,Z,J),Z},wQ=function($){const J=O0($),q=T$($),Q=q(J,J.neg(J.ONE)),G=q(J,Q),z=q(J,J.neg(Q)),U=($+xQ)/B$;return(Z,j)=>{let V=Z.pow(j,U),N=Z.mul(V,Q);const L=Z.mul(V,G),Y=Z.mul(V,z),K=Z.eql(Z.sqr(N),j),H=Z.eql(Z.sqr(L),j);V=Z.cmov(V,N,K),N=Z.cmov(Y,L,H);const A=Z.eql(Z.sqr(N),j),E=Z.cmov(V,N,A);return u8(Z,E,j),E}};function T$($){if($<W$)throw new Error("sqrt is not defined for small field");let J=$-h,q=0;while(J%P0===l)J/=P0,q++;let Q=P0;const G=O0($);while(D$(G,Q)===1)if(Q++>1000)throw new Error("Cannot find square root: probably non-prime P");if(q===1)return R$;let z=G.pow(Q,J);const U=(J+h)/P0;return function Z(j,V){if(j.is0(V))return V;if(D$(j,V)!==1)throw new Error("Cannot find square root");let N=q,L=j.mul(j.ONE,z),Y=j.pow(V,J),K=j.pow(V,U);while(!j.eql(Y,j.ONE)){if(j.is0(Y))return j.ZERO;let H=1,A=j.sqr(Y);while(!j.eql(A,j.ONE))if(H++,A=j.sqr(A),H===N)throw new Error("Cannot find square root");const E=h<<BigInt(N-H-1),f=j.pow(L,E);N=H,L=j.sqr(f),Y=j.mul(Y,L),K=j.mul(K,f)}return K}}function IQ($){if($%N$===W$)return R$;if($%C$===V$)return AQ;if($%B$===LQ)return wQ($);return T$($)}function m8($){const J={ORDER:"bigint",MASK:"bigint",BYTES:"number",BITS:"number"},q=kQ.reduce((Q,G)=>{return Q[G]="function",Q},J);return a0($,q),$}function SQ($,J,q){if(q<l)throw new Error("invalid exponent, negatives unsupported");if(q===l)return $.ONE;if(q===h)return J;let Q=$.ONE,G=J;while(q>l){if(q&h)Q=$.mul(Q,G);G=$.sqr(G),q>>=h}return Q}function M8($,J,q=!1){const Q=new Array(J.length).fill(q?$.ZERO:void 0),G=J.reduce((U,Z,j)=>{if($.is0(Z))return U;return Q[j]=U,$.mul(U,Z)},$.ONE),z=$.inv(G);return J.reduceRight((U,Z,j)=>{if($.is0(Z))return U;return Q[j]=$.mul(U,Q[j]),$.mul(U,Z)},z),Q}function D$($,J){const q=($.ORDER-h)/P0,Q=$.pow(J,q),G=$.eql(Q,$.ONE),z=$.eql(Q,$.ZERO),U=$.eql(Q,$.neg($.ONE));if(!G&&!z&&!U)throw new Error("invalid Legendre symbol result");return G?1:z?0:-1}function D8($,J){if(J!==void 0)c0(J);const q=J!==void 0?J:$.toString(2).length,Q=Math.ceil(q/8);return{nBitLength:q,nByteLength:Q}}function O0($,J,q=!1,Q={}){if($<=l)throw new Error("invalid field: expected ORDER > 0, got "+$);let G=void 0,z=void 0,U=!1,Z=void 0;if(typeof J==="object"&&J!=null){if(Q.sqrt||q)throw new Error("cannot specify opts in two arguments");const Y=J;if(Y.BITS)G=Y.BITS;if(Y.sqrt)z=Y.sqrt;if(typeof Y.isLE==="boolean")q=Y.isLE;if(typeof Y.modFromBytes==="boolean")U=Y.modFromBytes;Z=Y.allowedLengths}else{if(typeof J==="number")G=J;if(Q.sqrt)z=Q.sqrt}const{nBitLength:j,nByteLength:V}=D8($,G);if(V>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let N;const L=Object.freeze({ORDER:$,isLE:q,BITS:j,BYTES:V,MASK:H0(j),ZERO:l,ONE:h,allowedLengths:Z,create:(Y)=>i(Y,$),isValid:(Y)=>{if(typeof Y!=="bigint")throw new Error("invalid field element: expected bigint, got "+typeof Y);return l<=Y&&Y<$},is0:(Y)=>Y===l,isValidNot0:(Y)=>!L.is0(Y)&&L.isValid(Y),isOdd:(Y)=>(Y&h)===h,neg:(Y)=>i(-Y,$),eql:(Y,K)=>Y===K,sqr:(Y)=>i(Y*Y,$),add:(Y,K)=>i(Y+K,$),sub:(Y,K)=>i(Y-K,$),mul:(Y,K)=>i(Y*K,$),pow:(Y,K)=>SQ(L,Y,K),div:(Y,K)=>i(Y*M$(K,$),$),sqrN:(Y)=>Y*Y,addN:(Y,K)=>Y+K,subN:(Y,K)=>Y-K,mulN:(Y,K)=>Y*K,inv:(Y)=>M$(Y,$),sqrt:z||((Y)=>{if(!N)N=IQ($);return N(L,Y)}),toBytes:(Y)=>q?g8(Y,V):_0(Y,V),fromBytes:(Y,K=!0)=>{if(Z){if(!Z.includes(Y.length)||Y.length>V)throw new Error("Field.fromBytes: expected "+Z+" bytes, got "+Y.length);const A=new Uint8Array(V);A.set(Y,q?0:A.length-Y.length),Y=A}if(Y.length!==V)throw new Error("Field.fromBytes: expected "+V+" bytes, got "+Y.length);let H=q?_8(Y):D0(Y);if(U)H=i(H,$);if(!K){if(!L.isValid(H))throw new Error("invalid field element: outside of range 0..ORDER")}return H},invertBatch:(Y)=>M8(L,Y),cmov:(Y,K,H)=>H?K:Y});return Object.freeze(L)}function H$($){if(typeof $!=="bigint")throw new Error("field order must be bigint");const J=$.toString(2).length;return Math.ceil(J/8)}function F8($){const J=H$($);return J+Math.ceil(J/2)}function W8($,J,q=!1){const Q=$.length,G=H$(J),z=F8(J);if(Q<16||Q<z||Q>1024)throw new Error("expected "+z+"-1024 bytes of input, got "+Q);const U=q?_8($):D0($),Z=i(U,J-h)+h;return q?g8(Z,G):_0(Z,G)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */var l=BigInt(0),h=BigInt(1),P0=BigInt(2),W$=BigInt(3),N$=BigInt(4),V$=BigInt(5),xQ=BigInt(7),C$=BigInt(8),LQ=BigInt(9),B$=BigInt(16);var kQ=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function n0($,J){const q=J.negate();return $?q:J}function N8($,J){const q=M8($.Fp,J.map((Q)=>Q.Z));return J.map((Q,G)=>$.fromAffine(Q.toAffine(q[G])))}var A$=function($,J){if(!Number.isSafeInteger($)||$<=0||$>J)throw new Error("invalid window size, expected [1.."+J+"], got W="+$)},h8=function($,J){A$($,J);const q=Math.ceil(J/$)+1,Q=2**($-1),G=2**$,z=H0($),U=BigInt($);return{windows:q,windowSize:Q,mask:z,maxNumber:G,shiftBy:U}},O$=function($,J,q){const{windowSize:Q,mask:G,maxNumber:z,shiftBy:U}=q;let Z=Number($&G),j=$>>U;if(Z>Q)Z-=z,j+=E0;const V=J*Q,N=V+Math.abs(Z)-1,L=Z===0,Y=Z<0,K=J%2!==0;return{nextN:j,offset:N,isZero:L,isNeg:Y,isNegF:K,offsetF:V}},PQ=function($,J){if(!Array.isArray($))throw new Error("array expected");$.forEach((q,Q)=>{if(!(q instanceof J))throw new Error("invalid point at index "+Q)})},EQ=function($,J){if(!Array.isArray($))throw new Error("array of scalars expected");$.forEach((q,Q)=>{if(!J.isValid(q))throw new Error("invalid scalar at index "+Q)})},c8=function($){return w$.get($)||1},x$=function($){if($!==g0)throw new Error("invalid wNAF")};function I$($,J,q,Q){let G=J,z=$.ZERO,U=$.ZERO;while(q>g0||Q>g0){if(q&E0)z=z.add(G);if(Q&E0)U=U.add(G);G=G.double(),q>>=E0,Q>>=E0}return{p1:z,p2:U}}function k$($,J,q,Q){PQ(q,$),EQ(Q,J);const G=q.length,z=Q.length;if(G!==z)throw new Error("arrays of points and scalars must have equal length");const U=$.ZERO,Z=K8(BigInt(G));let j=1;if(Z>12)j=Z-3;else if(Z>4)j=Z-2;else if(Z>0)j=2;const V=H0(j),N=new Array(Number(V)+1).fill(U),L=Math.floor((J.BITS-1)/j)*j;let Y=U;for(let K=L;K>=0;K-=j){N.fill(U);for(let A=0;A<z;A++){const E=Q[A],f=Number(E>>BigInt(K)&V);N[f]=N[f].add(q[A])}let H=U;for(let A=N.length-1,E=U;A>0;A--)E=E.add(N[A]),H=H.add(E);if(Y=Y.add(H),K!==0)for(let A=0;A<j;A++)Y=Y.double()}return Y}var L$=function($,J,q){if(J){if(J.ORDER!==$)throw new Error("Field.ORDER must match order: Fp == p, Fn == n");return m8(J),J}else return O0($,{isLE:q})};function S$($,J,q={},Q){if(Q===void 0)Q=$==="edwards";if(!J||typeof J!=="object")throw new Error(`expected valid ${$} CURVE object`);for(let j of["p","n","h"]){const V=J[j];if(!(typeof V==="bigint"&&V>g0))throw new Error(`CURVE.${j} must be positive bigint`)}const G=L$(J.p,q.Fp,Q),z=L$(J.n,q.Fn,Q),Z=["Gx","Gy","a",$==="weierstrass"?"b":"d"];for(let j of Z)if(!G.isValid(J[j]))throw new Error(`CURVE.${j} must be valid field element of CURVE.Fp`);return J=Object.freeze(Object.assign({},J)),{CURVE:J,Fp:G,Fn:z}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */var g0=BigInt(0),E0=BigInt(1),l8=new WeakMap,w$=new WeakMap;class d8{constructor($,J){this.BASE=$.BASE,this.ZERO=$.ZERO,this.Fn=$.Fn,this.bits=J}_unsafeLadder($,J,q=this.ZERO){let Q=$;while(J>g0){if(J&E0)q=q.add(Q);Q=Q.double(),J>>=E0}return q}precomputeWindow($,J){const{windows:q,windowSize:Q}=h8(J,this.bits),G=[];let z=$,U=z;for(let Z=0;Z<q;Z++){U=z,G.push(U);for(let j=1;j<Q;j++)U=U.add(z),G.push(U);z=U.double()}return G}wNAF($,J,q){if(!this.Fn.isValid(q))throw new Error("invalid scalar");let Q=this.ZERO,G=this.BASE;const z=h8($,this.bits);for(let U=0;U<z.windows;U++){const{nextN:Z,offset:j,isZero:V,isNeg:N,isNegF:L,offsetF:Y}=O$(q,U,z);if(q=Z,V)G=G.add(n0(L,J[Y]));else Q=Q.add(n0(N,J[j]))}return x$(q),{p:Q,f:G}}wNAFUnsafe($,J,q,Q=this.ZERO){const G=h8($,this.bits);for(let z=0;z<G.windows;z++){if(q===g0)break;const{nextN:U,offset:Z,isZero:j,isNeg:V}=O$(q,z,G);if(q=U,j)continue;else{const N=J[Z];Q=Q.add(V?N.negate():N)}}return x$(q),Q}getPrecomputes($,J,q){let Q=l8.get(J);if(!Q){if(Q=this.precomputeWindow(J,$),$!==1){if(typeof q==="function")Q=q(Q);l8.set(J,Q)}}return Q}cached($,J,q){const Q=c8($);return this.wNAF(Q,this.getPrecomputes(Q,$,q),J)}unsafe($,J,q,Q){const G=c8($);if(G===1)return this._unsafeLadder($,J,Q);return this.wNAFUnsafe(G,this.getPrecomputes(G,$,q),J,Q)}createCache($,J){A$(J,this.bits),w$.set($,J),l8.delete($)}hasCache($){return c8($)!==1}}function vQ($,J,q){const[[Q,G],[z,U]]=J,Z=P$(U*$,q),j=P$(-G*$,q);let V=$-Z*Q-j*z,N=-Z*G-j*U;const L=V<N0,Y=N<N0;if(L)V=-V;if(Y)N=-N;const K=H0(Math.ceil(K8(q)/2))+y0;if(V<N0||V>=K||N<N0||N>=K)throw new Error("splitScalar (endomorphism): failed, k="+$);return{k1neg:L,k1:V,k2neg:Y,k2:N}}var r8=function($){if(!["compact","recovered","der"].includes($))throw new Error('Signature format must be "compact", "recovered", or "der"');return $},o8=function($,J){const q={};for(let Q of Object.keys(J))q[Q]=$[Q]===void 0?J[Q]:$[Q];if(r0(q.lowS,"lowS"),r0(q.prehash,"prehash"),q.format!==void 0)r8(q.format);return q};function x0($,J){const{BYTES:q}=$;let Q;if(typeof J==="bigint")Q=J;else{let G=m("private key",J);try{Q=$.fromBytes(G)}catch(z){throw new Error(`invalid private key: expected ui8a of size ${q}, got ${typeof J}`)}}if(!$.isValidNot0(Q))throw new Error("invalid private key: out of range [1..N-1]");return Q}function bQ($,J={}){const q=S$("weierstrass",$,J),{Fp:Q,Fn:G}=q;let z=q.CURVE;const{h:U,n:Z}=z;a0(J,{},{allowInfinityPoint:"boolean",clearCofactor:"function",isTorsionFree:"function",fromBytes:"function",toBytes:"function",endo:"object",wrapPrivateKey:"boolean"});const{endo:j}=J;if(j){if(!Q.is0(z.a)||typeof j.beta!=="bigint"||!Array.isArray(j.basises))throw new Error('invalid endo: expected "beta": bigint and "basises": array')}const V=b$(Q,G);function N(){if(!Q.isOdd)throw new Error("compression is not supported: Field does not have .isOdd()")}function L(W,O,M){const{x:R,y:X}=O.toAffine(),D=Q.toBytes(R);if(r0(M,"isCompressed"),M){N();const C=!Q.isOdd(X);return r(f$(C),D)}else return r(Uint8Array.of(4),D,Q.toBytes(X))}function Y(W){T0(W,void 0,"Point");const{publicKey:O,publicKeyUncompressed:M}=V,R=W.length,X=W[0],D=W.subarray(1);if(R===O&&(X===2||X===3)){const C=Q.fromBytes(D);if(!Q.isValid(C))throw new Error("bad point: is not on curve, wrong x");const T=A(C);let B;try{B=Q.sqrt(T)}catch(k){const w=k instanceof Error?": "+k.message:"";throw new Error("bad point: is not on curve, sqrt error"+w)}N();const x=Q.isOdd(B);if((X&1)===1!==x)B=Q.neg(B);return{x:C,y:B}}else if(R===M&&X===4){const C=Q.BYTES,T=Q.fromBytes(D.subarray(0,C)),B=Q.fromBytes(D.subarray(C,C*2));if(!E(T,B))throw new Error("bad point: is not on curve");return{x:T,y:B}}else throw new Error(`bad point: got length ${R}, expected compressed=${O} or uncompressed=${M}`)}const K=J.toBytes||L,H=J.fromBytes||Y;function A(W){const O=Q.sqr(W),M=Q.mul(O,W);return Q.add(Q.add(M,Q.mul(W,z.a)),z.b)}function E(W,O){const M=Q.sqr(O),R=A(W);return Q.eql(M,R)}if(!E(z.Gx,z.Gy))throw new Error("bad curve params: generator point");const f=Q.mul(Q.pow(z.a,V8),fQ),q0=Q.mul(Q.sqr(z.b),BigInt(27));if(Q.is0(Q.add(f,q0)))throw new Error("bad curve params: a or b");function _(W,O,M=!1){if(!Q.isValid(O)||M&&Q.is0(O))throw new Error(`bad point coordinate ${W}`);return O}function n(W){if(!(W instanceof I))throw new Error("ProjectivePoint expected")}function d(W){if(!j||!j.basises)throw new Error("no endo");return vQ(W,j.basises,G.ORDER)}const s=y8((W,O)=>{const{X:M,Y:R,Z:X}=W;if(Q.eql(X,Q.ONE))return{x:M,y:R};const D=W.is0();if(O==null)O=D?Q.ONE:Q.inv(X);const C=Q.mul(M,O),T=Q.mul(R,O),B=Q.mul(X,O);if(D)return{x:Q.ZERO,y:Q.ZERO};if(!Q.eql(B,Q.ONE))throw new Error("invZ was invalid");return{x:C,y:T}}),C0=y8((W)=>{if(W.is0()){if(J.allowInfinityPoint&&!Q.is0(W.Y))return;throw new Error("bad point: ZERO")}const{x:O,y:M}=W.toAffine();if(!Q.isValid(O)||!Q.isValid(M))throw new Error("bad point: x or y not field elements");if(!E(O,M))throw new Error("bad point: equation left != right");if(!W.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});function G0(W,O,M,R,X){return M=new I(Q.mul(M.X,W),M.Y,M.Z),O=n0(R,O),M=n0(X,M),O.add(M)}class I{constructor(W,O,M){this.X=_("x",W),this.Y=_("y",O,!0),this.Z=_("z",M),Object.freeze(this)}static CURVE(){return z}static fromAffine(W){const{x:O,y:M}=W||{};if(!W||!Q.isValid(O)||!Q.isValid(M))throw new Error("invalid affine point");if(W instanceof I)throw new Error("projective point not allowed");if(Q.is0(O)&&Q.is0(M))return I.ZERO;return new I(O,M,Q.ONE)}static fromBytes(W){const O=I.fromAffine(H(T0(W,void 0,"point")));return O.assertValidity(),O}static fromHex(W){return I.fromBytes(m("pointHex",W))}get x(){return this.toAffine().x}get y(){return this.toAffine().y}precompute(W=8,O=!0){if(S.createCache(this,W),!O)this.multiply(V8);return this}assertValidity(){C0(this)}hasEvenY(){const{y:W}=this.toAffine();if(!Q.isOdd)throw new Error("Field doesn't support isOdd");return!Q.isOdd(W)}equals(W){n(W);const{X:O,Y:M,Z:R}=this,{X,Y:D,Z:C}=W,T=Q.eql(Q.mul(O,C),Q.mul(X,R)),B=Q.eql(Q.mul(M,C),Q.mul(D,R));return T&&B}negate(){return new I(this.X,Q.neg(this.Y),this.Z)}double(){const{a:W,b:O}=z,M=Q.mul(O,V8),{X:R,Y:X,Z:D}=this;let{ZERO:C,ZERO:T,ZERO:B}=Q,x=Q.mul(R,R),g=Q.mul(X,X),k=Q.mul(D,D),w=Q.mul(R,X);return w=Q.add(w,w),B=Q.mul(R,D),B=Q.add(B,B),C=Q.mul(W,B),T=Q.mul(M,k),T=Q.add(C,T),C=Q.sub(g,T),T=Q.add(g,T),T=Q.mul(C,T),C=Q.mul(w,C),B=Q.mul(M,B),k=Q.mul(W,k),w=Q.sub(x,k),w=Q.mul(W,w),w=Q.add(w,B),B=Q.add(x,x),x=Q.add(B,x),x=Q.add(x,k),x=Q.mul(x,w),T=Q.add(T,x),k=Q.mul(X,D),k=Q.add(k,k),x=Q.mul(k,w),C=Q.sub(C,x),B=Q.mul(k,g),B=Q.add(B,B),B=Q.add(B,B),new I(C,T,B)}add(W){n(W);const{X:O,Y:M,Z:R}=this,{X,Y:D,Z:C}=W;let{ZERO:T,ZERO:B,ZERO:x}=Q;const g=z.a,k=Q.mul(z.b,V8);let w=Q.mul(O,X),P=Q.mul(M,D),v=Q.mul(R,C),b=Q.add(O,M),y=Q.add(X,D);b=Q.mul(b,y),y=Q.add(w,P),b=Q.sub(b,y),y=Q.add(O,R);let u=Q.add(X,C);return y=Q.mul(y,u),u=Q.add(w,v),y=Q.sub(y,u),u=Q.add(M,R),T=Q.add(D,C),u=Q.mul(u,T),T=Q.add(P,v),u=Q.sub(u,T),x=Q.mul(g,y),T=Q.mul(k,v),x=Q.add(T,x),T=Q.sub(P,x),x=Q.add(P,x),B=Q.mul(T,x),P=Q.add(w,w),P=Q.add(P,w),v=Q.mul(g,v),y=Q.mul(k,y),P=Q.add(P,v),v=Q.sub(w,v),v=Q.mul(g,v),y=Q.add(y,v),w=Q.mul(P,y),B=Q.add(B,w),w=Q.mul(u,y),T=Q.mul(b,T),T=Q.sub(T,w),w=Q.mul(b,P),x=Q.mul(u,x),x=Q.add(x,w),new I(T,B,x)}subtract(W){return this.add(W.negate())}is0(){return this.equals(I.ZERO)}multiply(W){const{endo:O}=J;if(!G.isValidNot0(W))throw new Error("invalid scalar: out of range");let M,R;const X=(D)=>S.cached(this,D,(C)=>N8(I,C));if(O){const{k1neg:D,k1:C,k2neg:T,k2:B}=d(W),{p:x,f:g}=X(C),{p:k,f:w}=X(B);R=g.add(w),M=G0(O.beta,x,k,D,T)}else{const{p:D,f:C}=X(W);M=D,R=C}return N8(I,[M,R])[0]}multiplyUnsafe(W){const{endo:O}=J,M=this;if(!G.isValid(W))throw new Error("invalid scalar: out of range");if(W===N0||M.is0())return I.ZERO;if(W===y0)return M;if(S.hasCache(this))return this.multiply(W);if(O){const{k1neg:R,k1:X,k2neg:D,k2:C}=d(W),{p1:T,p2:B}=I$(I,M,X,C);return G0(O.beta,T,B,R,D)}else return S.unsafe(M,W)}multiplyAndAddUnsafe(W,O,M){const R=this.multiplyUnsafe(O).add(W.multiplyUnsafe(M));return R.is0()?void 0:R}toAffine(W){return s(this,W)}isTorsionFree(){const{isTorsionFree:W}=J;if(U===y0)return!0;if(W)return W(I,this);return S.unsafe(this,Z).is0()}clearCofactor(){const{clearCofactor:W}=J;if(U===y0)return this;if(W)return W(I,this);return this.multiplyUnsafe(U)}isSmallOrder(){return this.multiplyUnsafe(U).is0()}toBytes(W=!0){return r0(W,"isCompressed"),this.assertValidity(),K(I,this,W)}toHex(W=!0){return K0(this.toBytes(W))}toString(){return`<Point ${this.is0()?"ZERO":this.toHex()}>`}get px(){return this.X}get py(){return this.X}get pz(){return this.Z}toRawBytes(W=!0){return this.toBytes(W)}_setWindowSize(W){this.precompute(W)}static normalizeZ(W){return N8(I,W)}static msm(W,O){return k$(I,G,W,O)}static fromPrivateKey(W){return I.BASE.multiply(x0(G,W))}}I.BASE=new I(z.Gx,z.Gy,Q.ONE),I.ZERO=new I(Q.ZERO,Q.ONE,Q.ZERO),I.Fp=Q,I.Fn=G;const X0=G.BITS,S=new d8(I,J.endo?Math.ceil(X0/2):X0);return I.BASE.precompute(8),I}var f$=function($){return Uint8Array.of($?2:3)};var b$=function($,J){return{secretKey:J.BYTES,publicKey:1+$.BYTES,publicKeyUncompressed:1+2*$.BYTES,publicKeyHasPrefix:!0,signature:2*J.BYTES}};function _Q($,J={}){const{Fn:q}=$,Q=J.randomBytes||S0,G=Object.assign(b$($.Fp,q),{seed:F8(q.ORDER)});function z(K){try{return!!x0(q,K)}catch(H){return!1}}function U(K,H){const{publicKey:A,publicKeyUncompressed:E}=G;try{const f=K.length;if(H===!0&&f!==A)return!1;if(H===!1&&f!==E)return!1;return!!$.fromBytes(K)}catch(f){return!1}}function Z(K=Q(G.seed)){return W8(T0(K,G.seed,"seed"),q.ORDER)}function j(K,H=!0){return $.BASE.multiply(x0(q,K)).toBytes(H)}function V(K){const H=Z(K);return{secretKey:H,publicKey:j(H)}}function N(K){if(typeof K==="bigint")return!1;if(K instanceof $)return!0;const{secretKey:H,publicKey:A,publicKeyUncompressed:E}=G;if(q.allowedLengths||H===A)return;const f=m("key",K).length;return f===A||f===E}function L(K,H,A=!0){if(N(K)===!0)throw new Error("first arg must be private key");if(N(H)===!1)throw new Error("second arg must be public key");const E=x0(q,K);return $.fromHex(H).multiply(E).toBytes(A)}return Object.freeze({getPublicKey:j,getSharedSecret:L,keygen:V,Point:$,utils:{isValidSecretKey:z,isValidPublicKey:U,randomSecretKey:Z,isValidPrivateKey:z,randomPrivateKey:Z,normPrivateKeyToScalar:(K)=>x0(q,K),precompute(K=8,H=$.BASE){return H.precompute(K,!1)}},lengths:G})}function gQ($,J,q={}){Y8(J),a0(q,{},{hmac:"function",lowS:"boolean",randomBytes:"function",bits2int:"function",bits2int_modN:"function"});const Q=q.randomBytes||S0,G=q.hmac||((M,...R)=>E8(J,M,r(...R))),{Fp:z,Fn:U}=$,{ORDER:Z,BITS:j}=U,{keygen:V,getPublicKey:N,getSharedSecret:L,utils:Y,lengths:K}=_Q($,q),H={prehash:!1,lowS:typeof q.lowS==="boolean"?q.lowS:!1,format:void 0,extraEntropy:!1},A="compact";function E(M){const R=Z>>y0;return M>R}function f(M,R){if(!U.isValidNot0(R))throw new Error(`invalid signature ${M}: out of range 1..Point.Fn.ORDER`);return R}function q0(M,R){r8(R);const X=K.signature,D=R==="compact"?X:R==="recovered"?X+1:void 0;return T0(M,D,`${R} signature`)}class _{constructor(M,R,X){if(this.r=f("r",M),this.s=f("s",R),X!=null)this.recovery=X;Object.freeze(this)}static fromBytes(M,R=A){q0(M,R);let X;if(R==="der"){const{r:B,s:x}=W0.toSig(T0(M));return new _(B,x)}if(R==="recovered")X=M[0],R="compact",M=M.subarray(1);const D=U.BYTES,C=M.subarray(0,D),T=M.subarray(D,D*2);return new _(U.fromBytes(C),U.fromBytes(T),X)}static fromHex(M,R){return this.fromBytes(k0(M),R)}addRecoveryBit(M){return new _(this.r,this.s,M)}recoverPublicKey(M){const R=z.ORDER,{r:X,s:D,recovery:C}=this;if(C==null||![0,1,2,3].includes(C))throw new Error("recovery id invalid");if(Z*v$<R&&C>1)throw new Error("recovery id is ambiguous for h>1 curve");const B=C===2||C===3?X+Z:X;if(!z.isValid(B))throw new Error("recovery id 2 or 3 invalid");const x=z.toBytes(B),g=$.fromBytes(r(f$((C&1)===0),x)),k=U.inv(B),w=d(m("msgHash",M)),P=U.create(-w*k),v=U.create(D*k),b=$.BASE.multiplyUnsafe(P).add(g.multiplyUnsafe(v));if(b.is0())throw new Error("point at infinify");return b.assertValidity(),b}hasHighS(){return E(this.s)}toBytes(M=A){if(r8(M),M==="der")return k0(W0.hexFromSig(this));const R=U.toBytes(this.r),X=U.toBytes(this.s);if(M==="recovered"){if(this.recovery==null)throw new Error("recovery bit must be present");return r(Uint8Array.of(this.recovery),R,X)}return r(R,X)}toHex(M){return K0(this.toBytes(M))}assertValidity(){}static fromCompact(M){return _.fromBytes(m("sig",M),"compact")}static fromDER(M){return _.fromBytes(m("sig",M),"der")}normalizeS(){return this.hasHighS()?new _(this.r,U.neg(this.s),this.recovery):this}toDERRawBytes(){return this.toBytes("der")}toDERHex(){return K0(this.toBytes("der"))}toCompactRawBytes(){return this.toBytes("compact")}toCompactHex(){return K0(this.toBytes("compact"))}}const n=q.bits2int||function M(R){if(R.length>8192)throw new Error("input is too large");const X=D0(R),D=R.length*8-j;return D>0?X>>BigInt(D):X},d=q.bits2int_modN||function M(R){return U.create(n(R))},s=H0(j);function C0(M){return Z$("num < 2^"+j,M,N0,s),U.toBytes(M)}function G0(M,R){return T0(M,void 0,"message"),R?T0(J(M),void 0,"prehashed message"):M}function I(M,R,X){if(["recovered","canonical"].some((v)=>(v in X)))throw new Error("sign() legacy options not supported");const{lowS:D,prehash:C,extraEntropy:T}=o8(X,H);M=G0(M,C);const B=d(M),x=x0(U,R),g=[C0(x),C0(B)];if(T!=null&&T!==!1){const v=T===!0?Q(K.secretKey):T;g.push(m("extraEntropy",v))}const k=r(...g),w=B;function P(v){const b=n(v);if(!U.isValidNot0(b))return;const y=U.inv(b),u=$.BASE.multiply(b).toAffine(),F=U.create(u.x);if(F===N0)return;const t=U.create(y*U.create(w+F*x));if(t===N0)return;let z0=(u.x===F?0:2)|Number(u.y&y0),p=t;if(D&&E(t))p=U.neg(t),z0^=1;return new _(F,p,z0)}return{seed:k,k2sig:P}}function X0(M,R,X={}){M=m("message",M);const{seed:D,k2sig:C}=I(M,R,X);return K$(J.outputLen,U.BYTES,G)(D,C)}function S(M){let R=void 0;const X=typeof M==="string"||w0(M),D=!X&&M!==null&&typeof M==="object"&&typeof M.r==="bigint"&&typeof M.s==="bigint";if(!X&&!D)throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");if(D)R=new _(M.r,M.s);else if(X){try{R=_.fromBytes(m("sig",M),"der")}catch(C){if(!(C instanceof W0.Err))throw C}if(!R)try{R=_.fromBytes(m("sig",M),"compact")}catch(C){return!1}}if(!R)return!1;return R}function W(M,R,X,D={}){const{lowS:C,prehash:T,format:B}=o8(D,H);if(X=m("publicKey",X),R=G0(m("message",R),T),("strict"in D))throw new Error("options.strict was renamed to lowS");const x=B===void 0?S(M):_.fromBytes(m("sig",M),B);if(x===!1)return!1;try{const g=$.fromBytes(X);if(C&&x.hasHighS())return!1;const{r:k,s:w}=x,P=d(R),v=U.inv(w),b=U.create(P*v),y=U.create(k*v),u=$.BASE.multiplyUnsafe(b).add(g.multiplyUnsafe(y));if(u.is0())return!1;return U.create(u.x)===k}catch(g){return!1}}function O(M,R,X={}){const{prehash:D}=o8(X,H);return R=G0(R,D),_.fromBytes(M,"recovered").recoverPublicKey(R).toBytes()}return Object.freeze({keygen:V,getPublicKey:N,getSharedSecret:L,utils:Y,lengths:K,Point:$,sign:X0,verify:W,recoverPublicKey:O,Signature:_,hash:J})}var yQ=function($){const J={a:$.a,b:$.b,p:$.Fp.ORDER,n:$.n,h:$.h,Gx:$.Gx,Gy:$.Gy},q=$.Fp;let Q=$.allowedPrivateKeyLengths?Array.from(new Set($.allowedPrivateKeyLengths.map((U)=>Math.ceil(U/2)))):void 0;const G=O0(J.n,{BITS:$.nBitLength,allowedLengths:Q,modFromBytes:$.wrapPrivateKey}),z={Fp:q,Fn:G,allowInfinityPoint:$.allowInfinityPoint,endo:$.endo,isTorsionFree:$.isTorsionFree,clearCofactor:$.clearCofactor,fromBytes:$.fromBytes,toBytes:$.toBytes};return{CURVE:J,curveOpts:z}},uQ=function($){const{CURVE:J,curveOpts:q}=yQ($),Q={hmac:$.hmac,randomBytes:$.randomBytes,lowS:$.lowS,bits2int:$.bits2int,bits2int_modN:$.bits2int_modN};return{CURVE:J,curveOpts:q,hash:$.hash,ecdsaOpts:Q}};var mQ=function($,J){const q=J.Point;return Object.assign({},J,{ProjectivePoint:q,CURVE:Object.assign({},$,D8(q.Fn.ORDER,q.Fn.BITS))})};function _$($){const{CURVE:J,curveOpts:q,hash:Q,ecdsaOpts:G}=uQ($),z=bQ(J,q),U=gQ(z,Q,G);return mQ($,U)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */var P$=($,J)=>($+($>=0?J:-J)/v$)/J;class E$ extends Error{constructor($=""){super($)}}var W0={Err:E$,_tlv:{encode:($,J)=>{const{Err:q}=W0;if($<0||$>256)throw new q("tlv.encode: wrong tag");if(J.length&1)throw new q("tlv.encode: unpadded data");const Q=J.length/2,G=p0(Q);if(G.length/2&128)throw new q("tlv.encode: long form length too big");const z=Q>127?p0(G.length/2|128):"";return p0($)+z+G+J},decode($,J){const{Err:q}=W0;let Q=0;if($<0||$>256)throw new q("tlv.encode: wrong tag");if(J.length<2||J[Q++]!==$)throw new q("tlv.decode: wrong tlv");const G=J[Q++],z=!!(G&128);let U=0;if(!z)U=G;else{const j=G&127;if(!j)throw new q("tlv.decode(long): indefinite length not supported");if(j>4)throw new q("tlv.decode(long): byte length is too big");const V=J.subarray(Q,Q+j);if(V.length!==j)throw new q("tlv.decode: length bytes not complete");if(V[0]===0)throw new q("tlv.decode(long): zero leftmost byte");for(let N of V)U=U<<8|N;if(Q+=j,U<128)throw new q("tlv.decode(long): not minimal encoding")}const Z=J.subarray(Q,Q+U);if(Z.length!==U)throw new q("tlv.decode: wrong value length");return{v:Z,l:J.subarray(Q+U)}}},_int:{encode($){const{Err:J}=W0;if($<N0)throw new J("integer: negative integers are not allowed");let q=p0($);if(Number.parseInt(q[0],16)&8)q="00"+q;if(q.length&1)throw new J("unexpected DER parsing assertion: unpadded hex");return q},decode($){const{Err:J}=W0;if($[0]&128)throw new J("invalid signature integer: negative");if($[0]===0&&!($[1]&128))throw new J("invalid signature integer: unnecessary leading zero");return D0($)}},toSig($){const{Err:J,_int:q,_tlv:Q}=W0,G=m("signature",$),{v:z,l:U}=Q.decode(48,G);if(U.length)throw new J("invalid signature: left bytes after parsing");const{v:Z,l:j}=Q.decode(2,z),{v:V,l:N}=Q.decode(2,j);if(N.length)throw new J("invalid signature: left bytes after parsing");return{r:q.decode(Z),s:q.decode(V)}},hexFromSig($){const{_tlv:J,_int:q}=W0,Q=J.encode(2,q.encode($.r)),G=J.encode(2,q.encode($.s)),z=Q+G;return J.encode(48,z)}},N0=BigInt(0),y0=BigInt(1),v$=BigInt(2),V8=BigInt(3),fQ=BigInt(4);function g$($,J){const q=(Q)=>_$({...$,hash:Q});return{...q(J),create:q}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */var lQ=function($){const J=u0.p,q=BigInt(3),Q=BigInt(6),G=BigInt(11),z=BigInt(22),U=BigInt(23),Z=BigInt(44),j=BigInt(88),V=$*$*$%J,N=V*V*$%J,L=a(N,q,J)*N%J,Y=a(L,q,J)*N%J,K=a(Y,p8,J)*V%J,H=a(K,G,J)*K%J,A=a(H,z,J)*H%J,E=a(A,Z,J)*A%J,f=a(E,j,J)*E%J,q0=a(f,Z,J)*A%J,_=a(q0,q,J)*N%J,n=a(_,U,J)*H%J,d=a(n,Q,J)*V%J,s=a(d,p8,J);if(!C8.eql(C8.sqr(s),$))throw new Error("Cannot find square root");return s},B8=function($,...J){let q=u$[$];if(q===void 0){const Q=Z8(X8($));q=r(Q,Q),u$[$]=q}return Z8(r(q,...J))},i8=function($){const{Fn:J,BASE:q}=m0,Q=x0(J,$),G=q.multiply(Q);return{scalar:n8(G.y)?Q:J.neg(Q),bytes:a8(G)}},h$=function($){const J=C8;if(!J.isValidNot0($))throw new Error("invalid x: Fail if x \u2265 p");const q=J.create($*$),Q=J.create(q*$+BigInt(7));let G=J.sqrt(Q);if(!n8(G))G=J.neg(G);const z=m0.fromAffine({x:$,y:G});return z.assertValidity(),z},l$=function(...$){return m0.Fn.create(s0(B8("BIP0340/challenge",...$)))},m$=function($){return i8($).bytes},cQ=function($,J,q=S0(32)){const{Fn:Q}=m0,G=m("message",$),{bytes:z,scalar:U}=i8(J),Z=m("auxRand",q,32),j=Q.toBytes(U^s0(B8("BIP0340/aux",Z))),V=B8("BIP0340/nonce",j,z,G),{bytes:N,scalar:L}=i8(V),Y=l$(N,z,G),K=new Uint8Array(64);if(K.set(N,0),K.set(Q.toBytes(Q.create(L+Y*U)),32),!c$(K,G,z))throw new Error("sign: Invalid signature produced");return K},c$=function($,J,q){const{Fn:Q,BASE:G}=m0,z=m("signature",$,64),U=m("message",J),Z=m("publicKey",q,32);try{const j=h$(s0(Z)),V=s0(z.subarray(0,32));if(!i0(V,y$,u0.p))return!1;const N=s0(z.subarray(32,64));if(!i0(N,y$,u0.n))return!1;const L=l$(Q.toBytes(V),a8(j),U),Y=G.multiplyUnsafe(N).add(j.multiplyUnsafe(Q.neg(L))),{x:K,y:H}=Y.toAffine();if(Y.is0()||!n8(H)||K!==V)return!1;return!0}catch(j){return!1}};/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */var u0={p:BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),n:BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),h:BigInt(1),a:BigInt(0),b:BigInt(7),Gx:BigInt("0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),Gy:BigInt("0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8")},FQ={beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),basises:[[BigInt("0x3086d221a7d46bcde86c90e49284eb15"),-BigInt("0xe4437ed6010e88286f547fa90abfe4c3")],[BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),BigInt("0x3086d221a7d46bcde86c90e49284eb15")]]},hQ=BigInt(0),y$=BigInt(1),p8=BigInt(2),C8=O0(u0.p,{sqrt:lQ}),F$=g$({...u0,Fp:C8,lowS:!0,endo:FQ},Z8),u$={},a8=($)=>$.toBytes(!0).slice(1),m0=(()=>F$.Point)(),n8=($)=>$%p8===hQ,s0=D0,R8=(()=>{const q=(G=S0(48))=>{return W8(G,u0.n)};F$.utils.randomSecretKey;function Q(G){const z=q(G);return{secretKey:z,publicKey:m$(z)}}return{keygen:Q,getPublicKey:m$,sign:cQ,verify:c$,Point:m0,utils:{randomSecretKey:q,randomPrivateKey:q,taggedHash:B8,lift_x:h$,pointToBytes:a8,numberToBytesBE:_0,bytesToNumberBE:D0,mod:i},lengths:{secretKey:32,publicKey:32,publicKeyHasPrefix:!1,signature:64,seed:48}}})();var dQ=new TextEncoder,oQ=new TextDecoder,Y0=($)=>dQ.encode($),v0=($)=>oQ.decode($),T8=($)=>Array.from($,(J)=>J.toString(16).padStart(2,"0")).join(""),e=JSON.stringify,f0=JSON.parse,H8=($,J=Number.MAX_SAFE_INTEGER)=>$.split("").reduce((q,Q)=>q+Q.charCodeAt(0),0)%J;var s8="AES-GCM",rQ={},d$="$",o$=",",pQ=($)=>{const J=new Uint8Array($);let Q="";for(let G=0;G<J.length;G+=32768)Q+=String.fromCharCode(...J.subarray(G,G+32768));return btoa(Q)},iQ=($)=>Uint8Array.from(atob($),(J)=>J.charCodeAt(0)).buffer,t0=($)=>rQ[$]??=crypto.subtle.digest("SHA-1",Y0($)).then((J)=>{const q=new Uint8Array(J);let Q="";for(let G of q)Q+=G.toString(36);return Q}),r$=async($,J,q)=>{const Q=await crypto.subtle.digest("SHA-256",Y0(`${$}:${J}:${q}`));return crypto.subtle.importKey("raw",Q,{name:s8},!1,["encrypt","decrypt"])},p$=async($,J)=>{const q=crypto.getRandomValues(new Uint8Array(12)),Q=await $,G=await crypto.subtle.encrypt({name:s8,iv:q},Q,Y0(J));return`${q.join(o$)}${d$}${pQ(G)}`},i$=async($,J)=>{const[q,Q]=J.split(d$);if(!q||!Q)throw new Error("Invalid encrypted payload format");const G=Uint8Array.from(q.split(o$),Number),z=await $,U=await crypto.subtle.decrypt({name:s8,iv:G},z,iQ(Q));return v0(U)};var c="GenosRTC",F0=($,J)=>Array.from({length:$},J);var e0=($)=>Array.from(crypto.getRandomValues(new Uint8Array($)),(J)=>"0123456789AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz"[J%"0123456789AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz".length]).join(""),j0=e0(20),V0=Promise.all.bind(Promise),a$=typeof window!=="undefined",{entries:n$,fromEntries:O8,keys:sJ}=Object,s$=()=>{},J0=($)=>new Error(`GenosRTC: ${$}`),$8=(...$)=>$.join("@"),t$=($,J)=>{const q=[...$];let Q=q.length;const G=()=>{const z=Math.sin(J++)*1e4;return z-Math.floor(z)};while(Q){const z=Math.floor(G()*Q--);[q[Q],q[z]]=[q[z],q[Q]]}return q};var aQ=5000,e$="icegatheringstatechange",$Q="offer",nQ="answer",sQ=[...F0(3,($,J)=>`stun:stun${J||""}.l.google.com:19302`),"stun:stun.cloudflare.com:3478"].map(($)=>({urls:$})),x8=($,{rtcConfig:J,rtcPolyfill:q,turnConfig:Q})=>{const G=new(q||RTCPeerConnection)({iceServers:[...sQ,...Q||[]],...J}),z={};let U=!1,Z=!1,j;const V=(Y)=>Object.assign(Y,{binaryType:"arraybuffer",bufferedAmountLowThreshold:65535,onmessage:(K)=>z.data?.(K.data),onopen:()=>z.connect?.(),onclose:()=>z.close?.(),onerror:(K)=>!K?.error?.message?.includes("User-Initiated Abort")&&z.error?.(K)}),N=()=>Promise.race([new Promise((Y)=>{const K=()=>{if(G.iceGatheringState==="complete")G.removeEventListener(e$,K),Y()};G.addEventListener(e$,K),K()}),new Promise((Y)=>setTimeout(Y,aQ))]).then(()=>({type:G.localDescription.type,sdp:G.localDescription.sdp.replace(/a=ice-options:trickle\s\n/g,"")}));if($?V(j=G.createDataChannel("data")):G.ondatachannel=({channel:Y})=>V(j=Y),G.onnegotiationneeded=async()=>{try{U=!0,await G.setLocalDescription(),z.signal?.(await N())}catch(Y){z.error?.(Y)}finally{U=!1}},G.onconnectionstatechange=()=>{if(["disconnected","failed","closed"].includes(G.connectionState))z.close?.()},G.ontrack=(Y)=>{z.track?.(Y.track,Y.streams[0]),z.stream?.(Y.streams[0])},G.onremovestream=(Y)=>z.stream?.(Y.stream),$&&!G.canTrickleIceCandidates)G.onnegotiationneeded();const L=()=>G.getSenders();return{created:Date.now(),connection:G,get channel(){return j},get isDead(){return G.connectionState==="closed"},async signal(Y){if(j?.readyState==="open"&&!Y.sdp?.includes("a=rtpmap"))return;try{if(Y.type===$Q){if(U||G.signalingState!=="stable"&&!Z){if($)return;await V0([G.setLocalDescription({type:"rollback"}),G.setRemoteDescription(Y)])}else await G.setRemoteDescription(Y);await G.setLocalDescription();const K=await N();return z.signal?.(K),K}if(Y.type===nQ){Z=!0;try{await G.setRemoteDescription(Y)}finally{Z=!1}}}catch(K){z.error?.(K)}},sendData:(Y)=>j.send(Y),destroy:()=>{j?.close(),G.close(),U=Z=!1},setHandlers:(Y)=>Object.assign(z,Y),offerPromise:$?new Promise((Y)=>z.signal=(K)=>K.type===$Q&&Y(K)):Promise.resolve(),addStream:(Y)=>Y.getTracks().forEach((K)=>G.addTrack(K,Y)),removeStream:(Y)=>L().filter((K)=>Y.getTracks().includes(K.track)).forEach((K)=>G.removeTrack(K)),addTrack:(Y,K)=>G.addTrack(Y,K),removeTrack:(Y)=>{const K=L().find((H)=>H.track===Y);if(K)G.removeTrack(K)},replaceTrack:(Y,K)=>L().find((H)=>H.track===Y)?.replaceTrack(K)}};var tQ=Object.getPrototypeOf(Uint8Array),A8=12,QQ=0,w8=QQ+A8,I8=w8+1,J8=I8+1,q8=J8+1,Q8=16384-q8,L8=255,t8="bufferedamountlow",h0=($)=>`@_${$}`,e8=100,eQ=3,$J=200,JQ=($,J,q)=>{const Q=new Map,G=new Map,z=new Map,U={},Z={},j={},V={},N=new Map,L=(X,D)=>{if(!N.has(X))N.set(X,new Set);N.get(X).add(D)},Y=(X,D)=>N.get(X)?.delete(D),K=(X,...D)=>N.get(X)?.forEach((C)=>C(...D)),H=(X,D)=>{const C=X?Array.isArray(X)?X:[X]:Q.keys();return Array.from(C,(T)=>{const B=Q.get(T);if(!B)return console.warn(`${c}: no peer with id ${T}`),null;return D(T,B)}).filter(Boolean)},A=(X)=>{if(!Q.has(X))return;Q.delete(X),delete U[X],delete Z[X],delete j[X],delete V[X],K("peer:leave",X),J(X)},E=(X)=>new Promise((D,C)=>{let T=setTimeout(()=>{X.removeEventListener(t8,B),C(new Error(`${c}: bufferLow timeout`))},5000);function B(){clearTimeout(T),X.removeEventListener(t8,B),D()}X.addEventListener(t8,B)}),f=(X)=>{if(z.has(X))return z.get(X);if(!X)throw J0("action type is required");const D=Y0(X);if(D.byteLength>A8)throw J0(`"${X}" exceeds ${A8} bytes`);const C=new Uint8Array(A8).map((P,v)=>D[v]||0);let T=0;const B=new Map([["message",new Set],["progress",new Set]]),x=(P,v)=>B.get(P)?.add(v),g=(P,v)=>B.get(P)?.delete(v),k=async(P,v,b,y)=>{if(b&&typeof b!=="object")throw J0("meta must be object");if(P===void 0)throw J0("data cannot be undefined");const u=P instanceof Blob,F=u||P instanceof ArrayBuffer||P instanceof tQ,t=typeof P!=="string";if(b&&!F)throw J0("meta only allowed with binary");const z0=F?new Uint8Array(u?await P.arrayBuffer():P):Y0(t?e(P):P),p=b?Y0(e(b)):null,o=Math.ceil(z0.byteLength/Q8)+(b?1:0)||1;if(o>e8)throw J0(`Message too large, exceeds max chunks ${e8}`);const Q$=F0(o,(z8,U0)=>{const l0=U0===o-1,L0=b&&U0===0,U8=L0?p:z0.subarray(b?(U0-1)*Q8:U0*Q8,b?U0*Q8:(U0+1)*Q8),B0=new Uint8Array(q8+U8.byteLength);return B0.set(C),B0.set([T],w8),B0.set([l0|L0<<1|F<<2|t<<3],I8),B0.set([Math.round((U0+1)/o*L8)],J8),B0.set(U8,q8),B0});return T=T+1&L8,V0(H(v,async(z8,U0)=>{const{channel:l0}=U0;for(let L0=0;L0<o;L0++){let U8=0;while(l0.bufferedAmount>l0.bufferedAmountLowThreshold){if(U8++>eQ)throw J0(`${c}: send buffer full, max retries reached for peer ${z8}`);try{await E(l0)}catch(B0){console.warn(B0.message),await new Promise((RQ)=>setTimeout(RQ,$J))}}if(!Q.has(z8))break;U0.sendData(Q$[L0]),y?.(Q$[L0][J8]/L8,z8,b)}}))};G.set(X,{listeners:B,send:k});const w={send:k,on:x,off:g};return z.set(X,w),w},q0=(X,D)=>{try{const C=new Uint8Array(D),T=v0(C.subarray(QQ,w8)).replace(/ /g,"");if(!G.has(T))return console.warn(`${c}: unregistered type (${T})`);const[B]=C.subarray(w8,I8),[x]=C.subarray(I8,J8),[g]=C.subarray(J8,q8),k=C.subarray(q8),w=Boolean(x&1),P=Boolean(x&2),v=Boolean(x&4),b=Boolean(x&8),y=G.get(T),u=(U[X]||={})[T]||={};if(u[B]?.chunks?.length>e8){console.warn(`${c}: peer ${X} sent too many chunks for nonce ${B}, ignoring.`);return}const F=u[B]||={chunks:[]};if(P)try{F.meta=f0(v0(k))}catch{console.warn(`${c}: failed to parse meta from peer ${X} for type ${T}`);return}else F.chunks.push(k);if(y.listeners.get("progress").forEach((p)=>{try{p(g/L8,X,F.meta)}catch(o){console.error(o)}}),!w)return;const t=new Uint8Array(F.chunks.reduce((p,o)=>p+o.byteLength,0));F.chunks.reduce((p,o)=>(t.set(o,p),p+o.byteLength),0),delete u[B];let z0;if(v)z0=t;else if(b)try{z0=f0(v0(t))}catch{console.warn(`${c}: failed to parse JSON message data from peer ${X} for type ${T}`);return}else z0=v0(t);y.listeners.get("message").forEach((p)=>{try{p(z0,X,F.meta)}catch(o){console.error(o)}})}catch(C){console.error(`${c}: error handling data from peer ${X}:`,C)}},_=async()=>{try{await M(""),await new Promise((X)=>setTimeout(X,99))}catch(X){console.warn(`${c}: error sending leave`,X)}for(let[X,D]of Q){try{D.destroy()}catch{}Q.delete(X)}q()},{send:n,on:d}=f(h0("ping")),{send:s,on:C0}=f(h0("pong")),{send:G0,on:I}=f(h0("signal")),{send:X0,on:S}=f(h0("stream")),{send:W,on:O}=f(h0("track")),{send:M,on:R}=f(h0("leave"));if($((X,D)=>{if(Q.has(D))return;Q.set(D,X),X.setHandlers({data:(C)=>q0(D,C),stream:(C)=>{K("stream:add",C,D,j[D]),delete j[D]},track:(C,T)=>{K("track:add",C,T,D,V[D]),delete V[D]},signal:(C)=>G0(C,D),close:()=>A(D),error:(C)=>{console.error(`${c}: peer error for ${D}`,C),A(D)}}),K("peer:join",D)}),d("message",(X,D)=>s("",D)),C0("message",(X,D)=>{Z[D]?.(),delete Z[D]}),I("message",(X,D)=>Q.get(D)?.signal(X)),S("message",(X,D)=>j[D]=X),O("message",(X,D)=>V[D]=X),R("message",(X,D)=>A(D)),a$)addEventListener("beforeunload",_);return{on:L,off:Y,channel:f,leave:_,ping:async(X)=>{if(!X)throw J0("ping() requires target peer ID");const D=Date.now();return n("",X),await new Promise((C)=>Z[X]=C),Date.now()-D},getPeers:()=>O8(Array.from(Q,([X,D])=>[X,D.connection])),addStream:(X,D,C)=>H(D,async(T,B)=>{if(C)await X0(C,T);B.addStream(X)}),removeStream:(X,D)=>H(D,(C,T)=>T.removeStream(X)),addTrack:(X,D,C,T)=>H(C,async(B,x)=>{if(T)await W(T,B);x.addTrack(X,D)}),removeTrack:(X,D)=>H(D,(C,T)=>T.removeTrack(X)),replaceTrack:(X,D,C,T)=>H(C,async(B,x)=>{if(T)await W(T,B);x.replaceTrack(X,D)})}};var QJ=20,JJ=5333,qQ=57333,GQ=({init:$,subscribe:J,announce:q})=>{const Q={};let G=!1,z,U;return(Z,j,V)=>{const{appId:N}=Z;if(Q[N]?.[j])return Q[N][j];if(!Z||!j||!N&&!Z.firebaseApp)throw J0(!Z?"config required":!j?"roomId required":"appId missing");let L=s$;if(!G){const S=$(Z);U=F0(QJ,()=>x8(!0,Z)),z=Array.isArray(S)?S:[S];const W=setInterval(()=>{U=U.filter((O)=>{const M=Date.now()-O.created<qQ;if(!M)O.destroy();return M})},qQ);Q.offerCleanupTimer||=W,G=!0}const Y={},K={},H=$8(c,N,j),A=t0(H),E=t0($8(H,j0)),f=r$(Z.password||"",N,j),q0=(S)=>async(W)=>({type:W.type,sdp:await S(f,W.sdp)}),_=q0(i$),n=q0(p$),d=(S,W)=>{if(K[W]===S)return;K[W]?.destroy(),K[W]=S,L(S,W),Y[W]?.forEach((O)=>O!==S&&O.destroy()),delete Y[W]},s=(S,W)=>{if(K[W]===S)delete K[W]},C0=(S)=>async(W,O,M)=>{const[R,X]=await V0([A,E]);if(W!==R&&W!==X)return;const{peerId:D,offer:C,answer:T}=typeof O==="string"?f0(O):O;if(D===j0||K[D])return;if(C){if(Y[D]?.[S]&&j0>D)return;const B=x8(!1,Z);B.setHandlers({connect:()=>d(B,D),close:()=>s(B,D)});try{const x=await _(C);if(B.isDead)return;const[g,k]=await V0([t0($8(H,D)),B.signal(x).then(n)]);M(g,e({peerId:j0,answer:k}))}catch{V?.({error:"decryption failed (offer)",appId:N,peerId:D,roomId:j})}}else if(T){const B=Y[D]?.[S];if(!B||B.isDead)return;B.setHandlers({connect:()=>d(B,D),close:()=>s(B,D)});try{B.signal(await _(T))}catch{V?.({error:"decryption failed (answer)",appId:N,peerId:D,roomId:j})}}else{if(Y[D]?.[S])return;const B=U.pop()||x8(!0,Z),[x,{offer:g}]=await V0([t0($8(H,D)),B.offerPromise.then(n).then((k)=>({offer:k}))]);Y[D]||=[],Y[D][S]=B,B.setHandlers({connect:()=>d(B,D),close:()=>s(B,D)}),M(x,e({peerId:j0,offer:g,peer:B}))}},G0=V0(z.map(async(S,W)=>J(await S,await A,await E,C0(W)))),I=[];G0.then((S)=>{z.forEach((W,O)=>{const M=async()=>{const R=await q(await W,await A,await E);I[O]=setTimeout(M,typeof R==="number"?R:JJ)};M()}),Q[N][j].onCleanup=()=>{if(delete Q[N][j],I.forEach(clearTimeout),S.forEach((W)=>W()),Object.keys(Q).length===0)clearInterval(Q.offerCleanupTimer),delete Q.offerCleanupTimer}}),Q[N]||={};const X0=JQ((S)=>L=S,(S)=>delete K[S],()=>X0.onCleanup?.());return Q[N][j]=X0}};var zQ=3333,k8={},UQ={},YQ=($,J)=>{const q={};let Q=null;const G=()=>{if(Q)clearTimeout(Q),Q=null;const z=new WebSocket($);z.onclose=()=>{k8[$]??=zQ,Q=setTimeout(G,k8[$]),k8[$]*=2},z.onmessage=(U)=>J(U.data),q.socket=z,q.url=z.url,q.ready=new Promise((U)=>{z.onopen=()=>{k8[$]=zQ,U(q)}}),q.send=(U)=>{if(z.readyState===1)z.send(U)}};return q.forceReconnect=G,G(),UQ[$]=q,q};if(typeof window!=="undefined"){const $=()=>{console.info("\u26A1 [GenosRTC] Network event detected. Forcing reconnection\u2026"),Object.values(UQ).forEach((J)=>{if(J.socket&&J.socket.readyState!==WebSocket.OPEN&&J.socket.readyState!==WebSocket.CONNECTING)J.forceReconnect()})};window.addEventListener("online",()=>{console.info("\u2705 Reconnected to the network."),$()}),window.addEventListener("offline",async()=>{console.info("\u274C Disconnected from the network.")}),document.addEventListener("visibilitychange",()=>{if(document.visibilityState==="visible")$()})}var jQ=($)=>()=>O8(n$($).map(([J,q])=>[J,q.socket])),XQ=($,J,q,Q)=>($.relayUrls??(Q?t$(J,H8($.appId)):J)).slice(0,$.relayUrls?.length??$.relayRedundancy??q);var DQ={},qJ=5,WQ="x",NQ="EVENT",VQ=R8.utils.randomSecretKey(),GJ=T8(R8.getPublicKey(VQ)),$$={},G8={},zJ={},CQ=()=>Math.floor(Date.now()/1000),BQ=($)=>zJ[$]??=H8($,1e4)+20000,ZQ=async($,J)=>{const q={kind:BQ($),content:J,pubkey:GJ,created_at:CQ(),tags:[[WQ,$]]},Q=new Uint8Array(await crypto.subtle.digest("SHA-256",Y0(e([0,q.pubkey,q.created_at,q.kind,q.tags,q.content])))),G=R8.sign(Q,VQ);return e([NQ,{...q,id:T8(Q),sig:T8(G)}])},KQ=($,J)=>{return $$[$]=J,e(["REQ",$,{kinds:[BQ(J)],since:CQ(),["#"+WQ]:[J]}])},MQ=($)=>{return delete $$[$],e(["CLOSE",$])},UJ=GQ({init:($)=>XQ($,jJ,qJ,!0).map((J)=>{const q=YQ(J,(Q)=>{const[G,z,U,Z]=f0(Q);if(G!==NQ){const j=`${c}: relay failure from ${q.url} - `;if(G==="NOTICE")console.warn(j+z);else if(G==="OK"&&!U)console.warn(j+Z);return}G8[z]?.($$[z],U.content)});return DQ[J]=q,q.ready}),subscribe:($,J,q,Q)=>{const G=e0(64),z=e0(64);return G8[G]=G8[z]=(U,Z)=>Q(U,Z,async(j,V)=>$.send(await ZQ(j,V))),$.send(KQ(G,J)),$.send(KQ(z,q)),()=>{$.send(MQ(G)),$.send(MQ(z)),delete G8[G],delete G8[z]}},announce:async($,J)=>$.send(await ZQ(J,e({peerId:j0})))}),YJ=jQ(DQ),jJ=["black.nostrcity.club","eu.purplerelay.com","ftp.halifax.rwth-aachen.de/nostr","nostr.cool110.xyz","nostr.data.haus","nostr.mom","nostr.oxtr.dev","nostr.sathoarder.com","nostr.vulpem.com","playground.nostrcheck.me/relay","relay.agorist.space","relay.binaryrobot.com","relay.fountain.fm","relay.mostro.network","relay.nostraddress.com","relay.nostrdice.com","relay.nostromo.social","relay.oldenburg.cool","relay.snort.social","relay.verified-nostr.com","sendit.nosflare.com","yabu.me/v2","relay.damus.io"].map(($)=>"wss://"+$);export{j0 as selfId,UJ as join,YJ as getRelaySockets};
