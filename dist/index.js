function H8(W){const Q=W.length;let J=0,V=0;while(V<Q){let G=W.charCodeAt(V++);if((G&4294967168)===0){J++;continue}else if((G&4294965248)===0)J+=2;else{if(G>=55296&&G<=56319){if(V<Q){const X=W.charCodeAt(V);if((X&64512)===56320)++V,G=((G&1023)<<10)+(X&1023)+65536}}if((G&4294901760)===0)J+=3;else J+=4}}return J}function s6(W,Q,J){const V=W.length;let G=J,X=0;while(X<V){let Y=W.charCodeAt(X++);if((Y&4294967168)===0){Q[G++]=Y;continue}else if((Y&4294965248)===0)Q[G++]=Y>>6&31|192;else{if(Y>=55296&&Y<=56319){if(X<V){const U=W.charCodeAt(X);if((U&64512)===56320)++X,Y=((Y&1023)<<10)+(U&1023)+65536}}if((Y&4294901760)===0)Q[G++]=Y>>12&15|224,Q[G++]=Y>>6&63|128;else Q[G++]=Y>>18&7|240,Q[G++]=Y>>12&63|128,Q[G++]=Y>>6&63|128}Q[G++]=Y&63|128}}function JW(W,Q,J){e6.encodeInto(W,Q.subarray(J))}function k8(W,Q,J){if(W.length>WW)JW(W,Q,J);else s6(W,Q,J)}function v1(W,Q,J){let V=Q;const G=V+J,X=[];let Y="";while(V<G){const U=W[V++];if((U&128)===0)X.push(U);else if((U&224)===192){const z=W[V++]&63;X.push((U&31)<<6|z)}else if((U&240)===224){const z=W[V++]&63,q=W[V++]&63;X.push((U&31)<<12|z<<6|q)}else if((U&248)===240){const z=W[V++]&63,q=W[V++]&63,P=W[V++]&63;let B=(U&7)<<18|z<<12|q<<6|P;if(B>65535)B-=65536,X.push(B>>>10&1023|55296),B=56320|B&1023;X.push(B)}else X.push(U);if(X.length>=QW)Y+=String.fromCharCode(...X),X.length=0}if(X.length>0)Y+=String.fromCharCode(...X);return Y}function XW(W,Q,J){const V=W.subarray(Q,Q+J);return VW.decode(V)}function $8(W,Q,J){if(J>GW)return XW(W,Q,J);else return v1(W,Q,J)}var e6=new TextEncoder,WW=50,QW=4096,VW=new TextDecoder,GW=200;class D0{constructor(W,Q){this.type=W,this.data=Q}}class i extends Error{constructor(W){super(W);const Q=Object.create(i.prototype);Object.setPrototypeOf(this,Q),Object.defineProperty(this,"name",{configurable:!0,enumerable:!1,value:i.name})}}function B8(W,Q,J){const V=J/4294967296,G=J;W.setUint32(Q,V),W.setUint32(Q+4,G)}function P1(W,Q,J){const V=Math.floor(J/4294967296),G=J;W.setUint32(Q,V),W.setUint32(Q+4,G)}function K1(W,Q){const J=W.getInt32(Q),V=W.getUint32(Q+4);return J*4294967296+V}function j8(W,Q){const J=W.getUint32(Q),V=W.getUint32(Q+4);return J*4294967296+V}var A0=4294967295;function PW({sec:W,nsec:Q}){if(W>=0&&Q>=0&&W<=YW)if(Q===0&&W<=UW){const J=new Uint8Array(4);return new DataView(J.buffer).setUint32(0,W),J}else{const J=W/4294967296,V=W&4294967295,G=new Uint8Array(8),X=new DataView(G.buffer);return X.setUint32(0,Q<<2|J&3),X.setUint32(4,V),G}else{const J=new Uint8Array(12),V=new DataView(J.buffer);return V.setUint32(0,Q),P1(V,4,W),J}}function KW(W){const Q=W.getTime(),J=Math.floor(Q/1000),V=(Q-J*1000)*1e6,G=Math.floor(V/1e9);return{sec:J+G,nsec:V-G*1e9}}function FW(W){if(W instanceof Date){const Q=KW(W);return PW(Q)}else return null}function zW(W){const Q=new DataView(W.buffer,W.byteOffset,W.byteLength);switch(W.byteLength){case 4:return{sec:Q.getUint32(0),nsec:0};case 8:{const J=Q.getUint32(0),V=Q.getUint32(4),G=(J&3)*4294967296+V,X=J>>>2;return{sec:G,nsec:X}}case 12:{const J=K1(Q,4),V=Q.getUint32(0);return{sec:J,nsec:V}}default:throw new i(`Unrecognized data size for timestamp (expected 4, 8, or 12): ${W.length}`)}}function ZW(W){const Q=zW(W);return new Date(Q.sec*1000+Q.nsec/1e6)}var qW=-1,UW=4294967295,YW=17179869183,C8={type:qW,encode:FW,decode:ZW};class B0{constructor(){this.builtInEncoders=[],this.builtInDecoders=[],this.encoders=[],this.decoders=[],this.register(C8)}register({type:W,encode:Q,decode:J}){if(W>=0)this.encoders[W]=Q,this.decoders[W]=J;else{const V=-1-W;this.builtInEncoders[V]=Q,this.builtInDecoders[V]=J}}tryToEncode(W,Q){for(let J=0;J<this.builtInEncoders.length;J++){const V=this.builtInEncoders[J];if(V!=null){const G=V(W,Q);if(G!=null){const X=-1-J;return new D0(X,G)}}}for(let J=0;J<this.encoders.length;J++){const V=this.encoders[J];if(V!=null){const G=V(W,Q);if(G!=null)return new D0(J,G)}}if(W instanceof D0)return W;return null}decode(W,Q,J){const V=Q<0?this.builtInDecoders[-1-Q]:this.decoders[Q];if(V)return V(W,Q,J);else return new D0(Q,W)}}B0.defaultCodec=new B0;var HW=function(W){return W instanceof ArrayBuffer||typeof SharedArrayBuffer!=="undefined"&&W instanceof SharedArrayBuffer};function h0(W){if(W instanceof Uint8Array)return W;else if(ArrayBuffer.isView(W))return new Uint8Array(W.buffer,W.byteOffset,W.byteLength);else if(HW(W))return new Uint8Array(W);else return Uint8Array.from(W)}var kW=100,$W=2048;class F1{constructor(W){this.entered=!1,this.extensionCodec=W?.extensionCodec??B0.defaultCodec,this.context=W?.context,this.useBigInt64=W?.useBigInt64??!1,this.maxDepth=W?.maxDepth??kW,this.initialBufferSize=W?.initialBufferSize??$W,this.sortKeys=W?.sortKeys??!1,this.forceFloat32=W?.forceFloat32??!1,this.ignoreUndefined=W?.ignoreUndefined??!1,this.forceIntegerToFloat=W?.forceIntegerToFloat??!1,this.pos=0,this.view=new DataView(new ArrayBuffer(this.initialBufferSize)),this.bytes=new Uint8Array(this.view.buffer)}clone(){return new F1({extensionCodec:this.extensionCodec,context:this.context,useBigInt64:this.useBigInt64,maxDepth:this.maxDepth,initialBufferSize:this.initialBufferSize,sortKeys:this.sortKeys,forceFloat32:this.forceFloat32,ignoreUndefined:this.ignoreUndefined,forceIntegerToFloat:this.forceIntegerToFloat})}reinitializeState(){this.pos=0}encodeSharedRef(W){if(this.entered)return this.clone().encodeSharedRef(W);try{return this.entered=!0,this.reinitializeState(),this.doEncode(W,1),this.bytes.subarray(0,this.pos)}finally{this.entered=!1}}encode(W){if(this.entered)return this.clone().encode(W);try{return this.entered=!0,this.reinitializeState(),this.doEncode(W,1),this.bytes.slice(0,this.pos)}finally{this.entered=!1}}doEncode(W,Q){if(Q>this.maxDepth)throw new Error(`Too deep objects in depth ${Q}`);if(W==null)this.encodeNil();else if(typeof W==="boolean")this.encodeBoolean(W);else if(typeof W==="number")if(!this.forceIntegerToFloat)this.encodeNumber(W);else this.encodeNumberAsFloat(W);else if(typeof W==="string")this.encodeString(W);else if(this.useBigInt64&&typeof W==="bigint")this.encodeBigInt64(W);else this.encodeObject(W,Q)}ensureBufferSizeToWrite(W){const Q=this.pos+W;if(this.view.byteLength<Q)this.resizeBuffer(Q*2)}resizeBuffer(W){const Q=new ArrayBuffer(W),J=new Uint8Array(Q),V=new DataView(Q);J.set(this.bytes),this.view=V,this.bytes=J}encodeNil(){this.writeU8(192)}encodeBoolean(W){if(W===!1)this.writeU8(194);else this.writeU8(195)}encodeNumber(W){if(!this.forceIntegerToFloat&&Number.isSafeInteger(W))if(W>=0)if(W<128)this.writeU8(W);else if(W<256)this.writeU8(204),this.writeU8(W);else if(W<65536)this.writeU8(205),this.writeU16(W);else if(W<4294967296)this.writeU8(206),this.writeU32(W);else if(!this.useBigInt64)this.writeU8(207),this.writeU64(W);else this.encodeNumberAsFloat(W);else if(W>=-32)this.writeU8(224|W+32);else if(W>=-128)this.writeU8(208),this.writeI8(W);else if(W>=-32768)this.writeU8(209),this.writeI16(W);else if(W>=-2147483648)this.writeU8(210),this.writeI32(W);else if(!this.useBigInt64)this.writeU8(211),this.writeI64(W);else this.encodeNumberAsFloat(W);else this.encodeNumberAsFloat(W)}encodeNumberAsFloat(W){if(this.forceFloat32)this.writeU8(202),this.writeF32(W);else this.writeU8(203),this.writeF64(W)}encodeBigInt64(W){if(W>=BigInt(0))this.writeU8(207),this.writeBigUint64(W);else this.writeU8(211),this.writeBigInt64(W)}writeStringHeader(W){if(W<32)this.writeU8(160+W);else if(W<256)this.writeU8(217),this.writeU8(W);else if(W<65536)this.writeU8(218),this.writeU16(W);else if(W<4294967296)this.writeU8(219),this.writeU32(W);else throw new Error(`Too long string: ${W} bytes in UTF-8`)}encodeString(W){const J=H8(W);this.ensureBufferSizeToWrite(5+J),this.writeStringHeader(J),k8(W,this.bytes,this.pos),this.pos+=J}encodeObject(W,Q){const J=this.extensionCodec.tryToEncode(W,this.context);if(J!=null)this.encodeExtension(J);else if(Array.isArray(W))this.encodeArray(W,Q);else if(ArrayBuffer.isView(W))this.encodeBinary(W);else if(typeof W==="object")this.encodeMap(W,Q);else throw new Error(`Unrecognized object: ${Object.prototype.toString.apply(W)}`)}encodeBinary(W){const Q=W.byteLength;if(Q<256)this.writeU8(196),this.writeU8(Q);else if(Q<65536)this.writeU8(197),this.writeU16(Q);else if(Q<4294967296)this.writeU8(198),this.writeU32(Q);else throw new Error(`Too large binary: ${Q}`);const J=h0(W);this.writeU8a(J)}encodeArray(W,Q){const J=W.length;if(J<16)this.writeU8(144+J);else if(J<65536)this.writeU8(220),this.writeU16(J);else if(J<4294967296)this.writeU8(221),this.writeU32(J);else throw new Error(`Too large array: ${J}`);for(let V of W)this.doEncode(V,Q+1)}countWithoutUndefined(W,Q){let J=0;for(let V of Q)if(W[V]!==void 0)J++;return J}encodeMap(W,Q){const J=Object.keys(W);if(this.sortKeys)J.sort();const V=this.ignoreUndefined?this.countWithoutUndefined(W,J):J.length;if(V<16)this.writeU8(128+V);else if(V<65536)this.writeU8(222),this.writeU16(V);else if(V<4294967296)this.writeU8(223),this.writeU32(V);else throw new Error(`Too large map object: ${V}`);for(let G of J){const X=W[G];if(!(this.ignoreUndefined&&X===void 0))this.encodeString(G),this.doEncode(X,Q+1)}}encodeExtension(W){if(typeof W.data==="function"){const J=W.data(this.pos+6),V=J.length;if(V>=4294967296)throw new Error(`Too large extension object: ${V}`);this.writeU8(201),this.writeU32(V),this.writeI8(W.type),this.writeU8a(J);return}const Q=W.data.length;if(Q===1)this.writeU8(212);else if(Q===2)this.writeU8(213);else if(Q===4)this.writeU8(214);else if(Q===8)this.writeU8(215);else if(Q===16)this.writeU8(216);else if(Q<256)this.writeU8(199),this.writeU8(Q);else if(Q<65536)this.writeU8(200),this.writeU16(Q);else if(Q<4294967296)this.writeU8(201),this.writeU32(Q);else throw new Error(`Too large extension object: ${Q}`);this.writeI8(W.type),this.writeU8a(W.data)}writeU8(W){this.ensureBufferSizeToWrite(1),this.view.setUint8(this.pos,W),this.pos++}writeU8a(W){const Q=W.length;this.ensureBufferSizeToWrite(Q),this.bytes.set(W,this.pos),this.pos+=Q}writeI8(W){this.ensureBufferSizeToWrite(1),this.view.setInt8(this.pos,W),this.pos++}writeU16(W){this.ensureBufferSizeToWrite(2),this.view.setUint16(this.pos,W),this.pos+=2}writeI16(W){this.ensureBufferSizeToWrite(2),this.view.setInt16(this.pos,W),this.pos+=2}writeU32(W){this.ensureBufferSizeToWrite(4),this.view.setUint32(this.pos,W),this.pos+=4}writeI32(W){this.ensureBufferSizeToWrite(4),this.view.setInt32(this.pos,W),this.pos+=4}writeF32(W){this.ensureBufferSizeToWrite(4),this.view.setFloat32(this.pos,W),this.pos+=4}writeF64(W){this.ensureBufferSizeToWrite(8),this.view.setFloat64(this.pos,W),this.pos+=8}writeU64(W){this.ensureBufferSizeToWrite(8),B8(this.view,this.pos,W),this.pos+=8}writeI64(W){this.ensureBufferSizeToWrite(8),P1(this.view,this.pos,W),this.pos+=8}writeBigUint64(W){this.ensureBufferSizeToWrite(8),this.view.setBigUint64(this.pos,W),this.pos+=8}writeBigInt64(W){this.ensureBufferSizeToWrite(8),this.view.setBigInt64(this.pos,W),this.pos+=8}}function b0(W,Q){return new F1(Q).encodeSharedRef(W)}function z1(W){return`${W<0?"-":""}0x${Math.abs(W).toString(16).padStart(2,"0")}`}var BW=16,jW=16;class T1{constructor(W=BW,Q=jW){this.hit=0,this.miss=0,this.maxKeyLength=W,this.maxLengthPerKey=Q,this.caches=[];for(let J=0;J<this.maxKeyLength;J++)this.caches.push([])}canBeCached(W){return W>0&&W<=this.maxKeyLength}find(W,Q,J){const V=this.caches[J-1];W:for(let G of V){const X=G.bytes;for(let Y=0;Y<J;Y++)if(X[Y]!==W[Q+Y])continue W;return G.str}return null}store(W,Q){const J=this.caches[W.length-1],V={bytes:W,str:Q};if(J.length>=this.maxLengthPerKey)J[Math.random()*J.length|0]=V;else J.push(V)}decode(W,Q,J){const V=this.find(W,Q,J);if(V!=null)return this.hit++,V;this.miss++;const G=v1(W,Q,J),X=Uint8Array.prototype.slice.call(W,Q,Q+J);return this.store(X,G),G}}var g1="array",m0="map_key",M8="map_value",CW=(W)=>{if(typeof W==="string"||typeof W==="number")return W;throw new i("The type of key must be string or number but "+typeof W)};class L8{constructor(){this.stack=[],this.stackHeadPosition=-1}get length(){return this.stackHeadPosition+1}top(){return this.stack[this.stackHeadPosition]}pushArrayState(W){const Q=this.getUninitializedStateFromPool();Q.type=g1,Q.position=0,Q.size=W,Q.array=new Array(W)}pushMapState(W){const Q=this.getUninitializedStateFromPool();Q.type=m0,Q.readCount=0,Q.size=W,Q.map={}}getUninitializedStateFromPool(){if(this.stackHeadPosition++,this.stackHeadPosition===this.stack.length){const W={type:void 0,size:0,array:void 0,position:0,readCount:0,map:void 0,key:null};this.stack.push(W)}return this.stack[this.stackHeadPosition]}release(W){if(this.stack[this.stackHeadPosition]!==W)throw new Error("Invalid stack state. Released state is not on top of the stack.");if(W.type===g1){const J=W;J.size=0,J.array=void 0,J.position=0,J.type=void 0}if(W.type===m0||W.type===M8){const J=W;J.size=0,J.map=void 0,J.readCount=0,J.type=void 0}this.stackHeadPosition--}reset(){this.stack.length=0,this.stackHeadPosition=-1}}var u0=-1,y1=new DataView(new ArrayBuffer(0)),RW=new Uint8Array(y1.buffer);try{y1.getInt8(0)}catch(W){if(!(W instanceof RangeError))throw new Error("This module is not supported in the current JavaScript engine because DataView does not throw RangeError on out-of-bounds access")}var R8=new RangeError("Insufficient data"),MW=new T1;class Z1{constructor(W){this.totalPos=0,this.pos=0,this.view=y1,this.bytes=RW,this.headByte=u0,this.stack=new L8,this.entered=!1,this.extensionCodec=W?.extensionCodec??B0.defaultCodec,this.context=W?.context,this.useBigInt64=W?.useBigInt64??!1,this.rawStrings=W?.rawStrings??!1,this.maxStrLength=W?.maxStrLength??A0,this.maxBinLength=W?.maxBinLength??A0,this.maxArrayLength=W?.maxArrayLength??A0,this.maxMapLength=W?.maxMapLength??A0,this.maxExtLength=W?.maxExtLength??A0,this.keyDecoder=W?.keyDecoder!==void 0?W.keyDecoder:MW,this.mapKeyConverter=W?.mapKeyConverter??CW}clone(){return new Z1({extensionCodec:this.extensionCodec,context:this.context,useBigInt64:this.useBigInt64,rawStrings:this.rawStrings,maxStrLength:this.maxStrLength,maxBinLength:this.maxBinLength,maxArrayLength:this.maxArrayLength,maxMapLength:this.maxMapLength,maxExtLength:this.maxExtLength,keyDecoder:this.keyDecoder})}reinitializeState(){this.totalPos=0,this.headByte=u0,this.stack.reset()}setBuffer(W){const Q=h0(W);this.bytes=Q,this.view=new DataView(Q.buffer,Q.byteOffset,Q.byteLength),this.pos=0}appendBuffer(W){if(this.headByte===u0&&!this.hasRemaining(1))this.setBuffer(W);else{const Q=this.bytes.subarray(this.pos),J=h0(W),V=new Uint8Array(Q.length+J.length);V.set(Q),V.set(J,Q.length),this.setBuffer(V)}}hasRemaining(W){return this.view.byteLength-this.pos>=W}createExtraByteError(W){const{view:Q,pos:J}=this;return new RangeError(`Extra ${Q.byteLength-J} of ${Q.byteLength} byte(s) found at buffer[${W}]`)}decode(W){if(this.entered)return this.clone().decode(W);try{this.entered=!0,this.reinitializeState(),this.setBuffer(W);const Q=this.doDecodeSync();if(this.hasRemaining(1))throw this.createExtraByteError(this.pos);return Q}finally{this.entered=!1}}*decodeMulti(W){if(this.entered){yield*this.clone().decodeMulti(W);return}try{this.entered=!0,this.reinitializeState(),this.setBuffer(W);while(this.hasRemaining(1))yield this.doDecodeSync()}finally{this.entered=!1}}async decodeAsync(W){if(this.entered)return this.clone().decodeAsync(W);try{this.entered=!0;let Q=!1,J;for await(let Y of W){if(Q)throw this.entered=!1,this.createExtraByteError(this.totalPos);this.appendBuffer(Y);try{J=this.doDecodeSync(),Q=!0}catch(U){if(!(U instanceof RangeError))throw U}this.totalPos+=this.pos}if(Q){if(this.hasRemaining(1))throw this.createExtraByteError(this.totalPos);return J}const{headByte:V,pos:G,totalPos:X}=this;throw new RangeError(`Insufficient data in parsing ${z1(V)} at ${X} (${G} in the current buffer)`)}finally{this.entered=!1}}decodeArrayStream(W){return this.decodeMultiAsync(W,!0)}decodeStream(W){return this.decodeMultiAsync(W,!1)}async*decodeMultiAsync(W,Q){if(this.entered){yield*this.clone().decodeMultiAsync(W,Q);return}try{this.entered=!0;let J=Q,V=-1;for await(let G of W){if(Q&&V===0)throw this.createExtraByteError(this.totalPos);if(this.appendBuffer(G),J)V=this.readArraySize(),J=!1,this.complete();try{while(!0)if(yield this.doDecodeSync(),--V===0)break}catch(X){if(!(X instanceof RangeError))throw X}this.totalPos+=this.pos}}finally{this.entered=!1}}doDecodeSync(){W:while(!0){const W=this.readHeadByte();let Q;if(W>=224)Q=W-256;else if(W<192)if(W<128)Q=W;else if(W<144){const V=W-128;if(V!==0){this.pushMapState(V),this.complete();continue W}else Q={}}else if(W<160){const V=W-144;if(V!==0){this.pushArrayState(V),this.complete();continue W}else Q=[]}else{const V=W-160;Q=this.decodeString(V,0)}else if(W===192)Q=null;else if(W===194)Q=!1;else if(W===195)Q=!0;else if(W===202)Q=this.readF32();else if(W===203)Q=this.readF64();else if(W===204)Q=this.readU8();else if(W===205)Q=this.readU16();else if(W===206)Q=this.readU32();else if(W===207)if(this.useBigInt64)Q=this.readU64AsBigInt();else Q=this.readU64();else if(W===208)Q=this.readI8();else if(W===209)Q=this.readI16();else if(W===210)Q=this.readI32();else if(W===211)if(this.useBigInt64)Q=this.readI64AsBigInt();else Q=this.readI64();else if(W===217){const V=this.lookU8();Q=this.decodeString(V,1)}else if(W===218){const V=this.lookU16();Q=this.decodeString(V,2)}else if(W===219){const V=this.lookU32();Q=this.decodeString(V,4)}else if(W===220){const V=this.readU16();if(V!==0){this.pushArrayState(V),this.complete();continue W}else Q=[]}else if(W===221){const V=this.readU32();if(V!==0){this.pushArrayState(V),this.complete();continue W}else Q=[]}else if(W===222){const V=this.readU16();if(V!==0){this.pushMapState(V),this.complete();continue W}else Q={}}else if(W===223){const V=this.readU32();if(V!==0){this.pushMapState(V),this.complete();continue W}else Q={}}else if(W===196){const V=this.lookU8();Q=this.decodeBinary(V,1)}else if(W===197){const V=this.lookU16();Q=this.decodeBinary(V,2)}else if(W===198){const V=this.lookU32();Q=this.decodeBinary(V,4)}else if(W===212)Q=this.decodeExtension(1,0);else if(W===213)Q=this.decodeExtension(2,0);else if(W===214)Q=this.decodeExtension(4,0);else if(W===215)Q=this.decodeExtension(8,0);else if(W===216)Q=this.decodeExtension(16,0);else if(W===199){const V=this.lookU8();Q=this.decodeExtension(V,1)}else if(W===200){const V=this.lookU16();Q=this.decodeExtension(V,2)}else if(W===201){const V=this.lookU32();Q=this.decodeExtension(V,4)}else throw new i(`Unrecognized type byte: ${z1(W)}`);this.complete();const J=this.stack;while(J.length>0){const V=J.top();if(V.type===g1)if(V.array[V.position]=Q,V.position++,V.position===V.size)Q=V.array,J.release(V);else continue W;else if(V.type===m0){if(Q==="__proto__")throw new i("The key __proto__ is not allowed");V.key=this.mapKeyConverter(Q),V.type=M8;continue W}else if(V.map[V.key]=Q,V.readCount++,V.readCount===V.size)Q=V.map,J.release(V);else{V.key=null,V.type=m0;continue W}}return Q}}readHeadByte(){if(this.headByte===u0)this.headByte=this.readU8();return this.headByte}complete(){this.headByte=u0}readArraySize(){const W=this.readHeadByte();switch(W){case 220:return this.readU16();case 221:return this.readU32();default:if(W<160)return W-144;else throw new i(`Unrecognized array type byte: ${z1(W)}`)}}pushMapState(W){if(W>this.maxMapLength)throw new i(`Max length exceeded: map length (${W}) > maxMapLengthLength (${this.maxMapLength})`);this.stack.pushMapState(W)}pushArrayState(W){if(W>this.maxArrayLength)throw new i(`Max length exceeded: array length (${W}) > maxArrayLength (${this.maxArrayLength})`);this.stack.pushArrayState(W)}decodeString(W,Q){if(!this.rawStrings||this.stateIsMapKey())return this.decodeUtf8String(W,Q);return this.decodeBinary(W,Q)}decodeUtf8String(W,Q){if(W>this.maxStrLength)throw new i(`Max length exceeded: UTF-8 byte length (${W}) > maxStrLength (${this.maxStrLength})`);if(this.bytes.byteLength<this.pos+Q+W)throw R8;const J=this.pos+Q;let V;if(this.stateIsMapKey()&&this.keyDecoder?.canBeCached(W))V=this.keyDecoder.decode(this.bytes,J,W);else V=$8(this.bytes,J,W);return this.pos+=Q+W,V}stateIsMapKey(){if(this.stack.length>0)return this.stack.top().type===m0;return!1}decodeBinary(W,Q){if(W>this.maxBinLength)throw new i(`Max length exceeded: bin length (${W}) > maxBinLength (${this.maxBinLength})`);if(!this.hasRemaining(W+Q))throw R8;const J=this.pos+Q,V=this.bytes.subarray(J,J+W);return this.pos+=Q+W,V}decodeExtension(W,Q){if(W>this.maxExtLength)throw new i(`Max length exceeded: ext length (${W}) > maxExtLength (${this.maxExtLength})`);const J=this.view.getInt8(this.pos+Q),V=this.decodeBinary(W,Q+1);return this.extensionCodec.decode(V,J,this.context)}lookU8(){return this.view.getUint8(this.pos)}lookU16(){return this.view.getUint16(this.pos)}lookU32(){return this.view.getUint32(this.pos)}readU8(){const W=this.view.getUint8(this.pos);return this.pos++,W}readI8(){const W=this.view.getInt8(this.pos);return this.pos++,W}readU16(){const W=this.view.getUint16(this.pos);return this.pos+=2,W}readI16(){const W=this.view.getInt16(this.pos);return this.pos+=2,W}readU32(){const W=this.view.getUint32(this.pos);return this.pos+=4,W}readI32(){const W=this.view.getInt32(this.pos);return this.pos+=4,W}readU64(){const W=j8(this.view,this.pos);return this.pos+=8,W}readI64(){const W=K1(this.view,this.pos);return this.pos+=8,W}readU64AsBigInt(){const W=this.view.getBigUint64(this.pos);return this.pos+=8,W}readI64AsBigInt(){const W=this.view.getBigInt64(this.pos);return this.pos+=8,W}readF32(){const W=this.view.getFloat32(this.pos);return this.pos+=4,W}readF64(){const W=this.view.getFloat64(this.pos);return this.pos+=8,W}}function c0(W,Q){return new Z1(Q).decode(W)}var y0=function(W){let Q=W.length;while(--Q>=0)W[Q]=0},f1=function(W,Q,J,V,G){this.static_tree=W,this.extra_bits=Q,this.extra_base=J,this.elems=V,this.max_length=G,this.has_stree=W&&W.length},p1=function(W,Q){this.dyn_tree=W,this.max_code=0,this.stat_desc=Q},W0=function(W,Q,J,V,G){this.good_length=W,this.max_lazy=Q,this.nice_length=J,this.max_chain=V,this.func=G},x5=function(){this.strm=null,this.status=0,this.pending_buf=null,this.pending_buf_size=0,this.pending_out=0,this.pending=0,this.wrap=0,this.gzhead=null,this.gzindex=0,this.method=x1,this.last_flush=-1,this.w_size=0,this.w_bits=0,this.w_mask=0,this.window=null,this.window_size=0,this.prev=null,this.head=null,this.ins_h=0,this.hash_size=0,this.hash_bits=0,this.hash_mask=0,this.hash_shift=0,this.block_start=0,this.match_length=0,this.prev_match=0,this.match_available=0,this.strstart=0,this.match_start=0,this.lookahead=0,this.prev_length=0,this.max_chain_length=0,this.max_lazy_match=0,this.level=0,this.strategy=0,this.good_match=0,this.nice_match=0,this.dyn_ltree=new Uint16Array(H5*2),this.dyn_dtree=new Uint16Array((2*z5+1)*2),this.bl_tree=new Uint16Array((2*Z5+1)*2),P0(this.dyn_ltree),P0(this.dyn_dtree),P0(this.bl_tree),this.l_desc=null,this.d_desc=null,this.bl_desc=null,this.bl_count=new Uint16Array(k5+1),this.heap=new Uint16Array(2*s1+1),P0(this.heap),this.heap_len=0,this.heap_max=0,this.depth=new Uint16Array(2*s1+1),P0(this.depth),this.sym_buf=0,this.lit_bufsize=0,this.sym_next=0,this.sym_end=0,this.opt_len=0,this.static_len=0,this.matches=0,this.insert=0,this.bi_buf=0,this.bi_valid=0},i5=function(){this.input=null,this.next_in=0,this.avail_in=0,this.total_in=0,this.output=null,this.next_out=0,this.avail_out=0,this.total_out=0,this.msg="",this.state=null,this.data_type=2,this.adler=0},X1=function(W){this.options=I1.assign({level:t5,method:e5,chunkSize:16384,windowBits:15,memLevel:8,strategy:s5},W||{});let Q=this.options;if(Q.raw&&Q.windowBits>0)Q.windowBits=-Q.windowBits;else if(Q.gzip&&Q.windowBits>0&&Q.windowBits<16)Q.windowBits+=16;this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new A6,this.strm.avail_out=0;let J=r0.deflateInit2(this.strm,Q.level,Q.method,Q.windowBits,Q.memLevel,Q.strategy);if(J!==M1)throw new Error(M0[J]);if(Q.header)r0.deflateSetHeader(this.strm,Q.header);if(Q.dictionary){let V;if(typeof Q.dictionary==="string")V=J1.string2buf(Q.dictionary);else if(N6.call(Q.dictionary)==="[object ArrayBuffer]")V=new Uint8Array(Q.dictionary);else V=Q.dictionary;if(J=r0.deflateSetDictionary(this.strm,V),J!==M1)throw new Error(M0[J]);this._dict_set=!0}},P8=function(W,Q){const J=new X1(Q);if(J.push(W,!0),J.err)throw J.msg||M0[J.err];return J.result},WJ=function(W,Q){return Q=Q||{},Q.raw=!0,P8(W,Q)},JJ=function(W,Q){return Q=Q||{},Q.gzip=!0,P8(W,Q)},IJ=function(){this.strm=null,this.mode=0,this.last=!1,this.wrap=0,this.havedict=!1,this.flags=0,this.dmax=0,this.check=0,this.total=0,this.head=null,this.wbits=0,this.wsize=0,this.whave=0,this.wnext=0,this.window=null,this.hold=0,this.bits=0,this.length=0,this.offset=0,this.extra=0,this.lencode=null,this.distcode=null,this.lenbits=0,this.distbits=0,this.ncode=0,this.nlen=0,this.ndist=0,this.have=0,this.next=null,this.lens=new Uint16Array(320),this.work=new Uint16Array(288),this.lendyn=null,this.distdyn=null,this.sane=0,this.back=0,this.was=0},mJ=function(){this.text=0,this.time=0,this.xflags=0,this.os=0,this.extra=null,this.extra_len=0,this.name="",this.comment="",this.hcrc=0,this.done=!1},q1=function(W){this.options=I1.assign({chunkSize:65536,windowBits:15,to:""},W||{});const Q=this.options;if(Q.raw&&Q.windowBits>=0&&Q.windowBits<16){if(Q.windowBits=-Q.windowBits,Q.windowBits===0)Q.windowBits=-15}if(Q.windowBits>=0&&Q.windowBits<16&&!(W&&W.windowBits))Q.windowBits+=32;if(Q.windowBits>15&&Q.windowBits<48){if((Q.windowBits&15)===0)Q.windowBits|=15}this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new A6,this.strm.avail_out=0;let J=q0.inflateInit2(this.strm,Q.windowBits);if(J!==Q1)throw new Error(M0[J]);if(this.header=new cJ,q0.inflateGetHeader(this.strm,this.header),Q.dictionary){if(typeof Q.dictionary==="string")Q.dictionary=J1.string2buf(Q.dictionary);else if(m6.call(Q.dictionary)==="[object ArrayBuffer]")Q.dictionary=new Uint8Array(Q.dictionary);if(Q.raw){if(J=q0.inflateSetDictionary(this.strm,Q.dictionary),J!==Q1)throw new Error(M0[J])}}},K8=function(W,Q){const J=new q1(Q);if(J.push(W),J.err)throw J.msg||M0[J.err];return J.result},rJ=function(W,Q){return Q=Q||{},Q.raw=!0,K8(W,Q)};/*! pako 2.1.0 https://github.com/nodeca/pako @license (MIT AND Zlib) */var LW=0,U6=1,xW=2,IW=3,OW=258,G8=29,V1=256,o0=V1+1+G8,v0=30,X8=19,Y6=2*o0+1,j0=15,E1=16,wW=7,q8=256,P6=16,K6=17,F6=18,o1=new Uint8Array([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0]),C1=new Uint8Array([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13]),DW=new Uint8Array([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7]),z6=new Uint8Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),AW=512,X0=new Array((o0+2)*2);y0(X0);var l0=new Array(v0*2);y0(l0);var a0=new Array(AW);y0(a0);var t0=new Array(OW-IW+1);y0(t0);var U8=new Array(G8);y0(U8);var R1=new Array(v0);y0(R1);var Z6,H6,k6,$6=(W)=>{return W<256?a0[W]:a0[256+(W>>>7)]},s0=(W,Q)=>{W.pending_buf[W.pending++]=Q&255,W.pending_buf[W.pending++]=Q>>>8&255},n=(W,Q,J)=>{if(W.bi_valid>E1-J)W.bi_buf|=Q<<W.bi_valid&65535,s0(W,W.bi_buf),W.bi_buf=Q>>E1-W.bi_valid,W.bi_valid+=J-E1;else W.bi_buf|=Q<<W.bi_valid&65535,W.bi_valid+=J},J0=(W,Q,J)=>{n(W,J[Q*2],J[Q*2+1])},B6=(W,Q)=>{let J=0;do J|=W&1,W>>>=1,J<<=1;while(--Q>0);return J>>>1},NW=(W)=>{if(W.bi_valid===16)s0(W,W.bi_buf),W.bi_buf=0,W.bi_valid=0;else if(W.bi_valid>=8)W.pending_buf[W.pending++]=W.bi_buf&255,W.bi_buf>>=8,W.bi_valid-=8},SW=(W,Q)=>{const{dyn_tree:J,max_code:V}=Q,G=Q.stat_desc.static_tree,X=Q.stat_desc.has_stree,Y=Q.stat_desc.extra_bits,U=Q.stat_desc.extra_base,z=Q.stat_desc.max_length;let q,P,B,F,K,H,S=0;for(F=0;F<=j0;F++)W.bl_count[F]=0;J[W.heap[W.heap_max]*2+1]=0;for(q=W.heap_max+1;q<Y6;q++){if(P=W.heap[q],F=J[J[P*2+1]*2+1]+1,F>z)F=z,S++;if(J[P*2+1]=F,P>V)continue;if(W.bl_count[F]++,K=0,P>=U)K=Y[P-U];if(H=J[P*2],W.opt_len+=H*(F+K),X)W.static_len+=H*(G[P*2+1]+K)}if(S===0)return;do{F=z-1;while(W.bl_count[F]===0)F--;W.bl_count[F]--,W.bl_count[F+1]+=2,W.bl_count[z]--,S-=2}while(S>0);for(F=z;F!==0;F--){P=W.bl_count[F];while(P!==0){if(B=W.heap[--q],B>V)continue;if(J[B*2+1]!==F)W.opt_len+=(F-J[B*2+1])*J[B*2],J[B*2+1]=F;P--}}},j6=(W,Q,J)=>{const V=new Array(j0+1);let G=0,X,Y;for(X=1;X<=j0;X++)G=G+J[X-1]<<1,V[X]=G;for(Y=0;Y<=Q;Y++){let U=W[Y*2+1];if(U===0)continue;W[Y*2]=B6(V[U]++,U)}},vW=()=>{let W,Q,J,V,G;const X=new Array(j0+1);J=0;for(V=0;V<G8-1;V++){U8[V]=J;for(W=0;W<1<<o1[V];W++)t0[J++]=V}t0[J-1]=V,G=0;for(V=0;V<16;V++){R1[V]=G;for(W=0;W<1<<C1[V];W++)a0[G++]=V}G>>=7;for(;V<v0;V++){R1[V]=G<<7;for(W=0;W<1<<C1[V]-7;W++)a0[256+G++]=V}for(Q=0;Q<=j0;Q++)X[Q]=0;W=0;while(W<=143)X0[W*2+1]=8,W++,X[8]++;while(W<=255)X0[W*2+1]=9,W++,X[9]++;while(W<=279)X0[W*2+1]=7,W++,X[7]++;while(W<=287)X0[W*2+1]=8,W++,X[8]++;j6(X0,o0+1,X);for(W=0;W<v0;W++)l0[W*2+1]=5,l0[W*2]=B6(W,5);Z6=new f1(X0,o1,V1+1,o0,j0),H6=new f1(l0,C1,0,v0,j0),k6=new f1(new Array(0),DW,0,X8,wW)},C6=(W)=>{let Q;for(Q=0;Q<o0;Q++)W.dyn_ltree[Q*2]=0;for(Q=0;Q<v0;Q++)W.dyn_dtree[Q*2]=0;for(Q=0;Q<X8;Q++)W.bl_tree[Q*2]=0;W.dyn_ltree[q8*2]=1,W.opt_len=W.static_len=0,W.sym_next=W.matches=0},R6=(W)=>{if(W.bi_valid>8)s0(W,W.bi_buf);else if(W.bi_valid>0)W.pending_buf[W.pending++]=W.bi_buf;W.bi_buf=0,W.bi_valid=0},x8=(W,Q,J,V)=>{const G=Q*2,X=J*2;return W[G]<W[X]||W[G]===W[X]&&V[Q]<=V[J]},h1=(W,Q,J)=>{const V=W.heap[J];let G=J<<1;while(G<=W.heap_len){if(G<W.heap_len&&x8(Q,W.heap[G+1],W.heap[G],W.depth))G++;if(x8(Q,V,W.heap[G],W.depth))break;W.heap[J]=W.heap[G],J=G,G<<=1}W.heap[J]=V},I8=(W,Q,J)=>{let V,G,X=0,Y,U;if(W.sym_next!==0)do if(V=W.pending_buf[W.sym_buf+X++]&255,V+=(W.pending_buf[W.sym_buf+X++]&255)<<8,G=W.pending_buf[W.sym_buf+X++],V===0)J0(W,G,Q);else{if(Y=t0[G],J0(W,Y+V1+1,Q),U=o1[Y],U!==0)G-=U8[Y],n(W,G,U);if(V--,Y=$6(V),J0(W,Y,J),U=C1[Y],U!==0)V-=R1[Y],n(W,V,U)}while(X<W.sym_next);J0(W,q8,Q)},a1=(W,Q)=>{const J=Q.dyn_tree,V=Q.stat_desc.static_tree,G=Q.stat_desc.has_stree,X=Q.stat_desc.elems;let Y,U,z=-1,q;W.heap_len=0,W.heap_max=Y6;for(Y=0;Y<X;Y++)if(J[Y*2]!==0)W.heap[++W.heap_len]=z=Y,W.depth[Y]=0;else J[Y*2+1]=0;while(W.heap_len<2)if(q=W.heap[++W.heap_len]=z<2?++z:0,J[q*2]=1,W.depth[q]=0,W.opt_len--,G)W.static_len-=V[q*2+1];Q.max_code=z;for(Y=W.heap_len>>1;Y>=1;Y--)h1(W,J,Y);q=X;do Y=W.heap[1],W.heap[1]=W.heap[W.heap_len--],h1(W,J,1),U=W.heap[1],W.heap[--W.heap_max]=Y,W.heap[--W.heap_max]=U,J[q*2]=J[Y*2]+J[U*2],W.depth[q]=(W.depth[Y]>=W.depth[U]?W.depth[Y]:W.depth[U])+1,J[Y*2+1]=J[U*2+1]=q,W.heap[1]=q++,h1(W,J,1);while(W.heap_len>=2);W.heap[--W.heap_max]=W.heap[1],SW(W,Q),j6(J,z,W.bl_count)},O8=(W,Q,J)=>{let V,G=-1,X,Y=Q[1],U=0,z=7,q=4;if(Y===0)z=138,q=3;Q[(J+1)*2+1]=65535;for(V=0;V<=J;V++){if(X=Y,Y=Q[(V+1)*2+1],++U<z&&X===Y)continue;else if(U<q)W.bl_tree[X*2]+=U;else if(X!==0){if(X!==G)W.bl_tree[X*2]++;W.bl_tree[P6*2]++}else if(U<=10)W.bl_tree[K6*2]++;else W.bl_tree[F6*2]++;if(U=0,G=X,Y===0)z=138,q=3;else if(X===Y)z=6,q=3;else z=7,q=4}},w8=(W,Q,J)=>{let V,G=-1,X,Y=Q[1],U=0,z=7,q=4;if(Y===0)z=138,q=3;for(V=0;V<=J;V++){if(X=Y,Y=Q[(V+1)*2+1],++U<z&&X===Y)continue;else if(U<q)do J0(W,X,W.bl_tree);while(--U!==0);else if(X!==0){if(X!==G)J0(W,X,W.bl_tree),U--;J0(W,P6,W.bl_tree),n(W,U-3,2)}else if(U<=10)J0(W,K6,W.bl_tree),n(W,U-3,3);else J0(W,F6,W.bl_tree),n(W,U-11,7);if(U=0,G=X,Y===0)z=138,q=3;else if(X===Y)z=6,q=3;else z=7,q=4}},TW=(W)=>{let Q;O8(W,W.dyn_ltree,W.l_desc.max_code),O8(W,W.dyn_dtree,W.d_desc.max_code),a1(W,W.bl_desc);for(Q=X8-1;Q>=3;Q--)if(W.bl_tree[z6[Q]*2+1]!==0)break;return W.opt_len+=3*(Q+1)+5+5+4,Q},gW=(W,Q,J,V)=>{let G;n(W,Q-257,5),n(W,J-1,5),n(W,V-4,4);for(G=0;G<V;G++)n(W,W.bl_tree[z6[G]*2+1],3);w8(W,W.dyn_ltree,Q-1),w8(W,W.dyn_dtree,J-1)},yW=(W)=>{let Q=4093624447,J;for(J=0;J<=31;J++,Q>>>=1)if(Q&1&&W.dyn_ltree[J*2]!==0)return 0;if(W.dyn_ltree[18]!==0||W.dyn_ltree[20]!==0||W.dyn_ltree[26]!==0)return 1;for(J=32;J<V1;J++)if(W.dyn_ltree[J*2]!==0)return 1;return 0},D8=!1,EW=(W)=>{if(!D8)vW(),D8=!0;W.l_desc=new p1(W.dyn_ltree,Z6),W.d_desc=new p1(W.dyn_dtree,H6),W.bl_desc=new p1(W.bl_tree,k6),W.bi_buf=0,W.bi_valid=0,C6(W)},M6=(W,Q,J,V)=>{if(n(W,(LW<<1)+(V?1:0),3),R6(W),s0(W,J),s0(W,~J),J)W.pending_buf.set(W.window.subarray(Q,Q+J),W.pending);W.pending+=J},fW=(W)=>{n(W,U6<<1,3),J0(W,q8,X0),NW(W)},pW=(W,Q,J,V)=>{let G,X,Y=0;if(W.level>0){if(W.strm.data_type===2)W.strm.data_type=yW(W);if(a1(W,W.l_desc),a1(W,W.d_desc),Y=TW(W),G=W.opt_len+3+7>>>3,X=W.static_len+3+7>>>3,X<=G)G=X}else G=X=J+5;if(J+4<=G&&Q!==-1)M6(W,Q,J,V);else if(W.strategy===4||X===G)n(W,(U6<<1)+(V?1:0),3),I8(W,X0,l0);else n(W,(xW<<1)+(V?1:0),3),gW(W,W.l_desc.max_code+1,W.d_desc.max_code+1,Y+1),I8(W,W.dyn_ltree,W.dyn_dtree);if(C6(W),V)R6(W)},hW=(W,Q,J)=>{if(W.pending_buf[W.sym_buf+W.sym_next++]=Q,W.pending_buf[W.sym_buf+W.sym_next++]=Q>>8,W.pending_buf[W.sym_buf+W.sym_next++]=J,Q===0)W.dyn_ltree[J*2]++;else W.matches++,Q--,W.dyn_ltree[(t0[J]+V1+1)*2]++,W.dyn_dtree[$6(Q)*2]++;return W.sym_next===W.sym_end},bW=EW,uW=M6,mW=pW,cW=hW,_W=fW,dW={_tr_init:bW,_tr_stored_block:uW,_tr_flush_block:mW,_tr_tally:cW,_tr_align:_W},iW=(W,Q,J,V)=>{let G=W&65535|0,X=W>>>16&65535|0,Y=0;while(J!==0){Y=J>2000?2000:J,J-=Y;do G=G+Q[V++]|0,X=X+G|0;while(--Y);G%=65521,X%=65521}return G|X<<16|0},e0=iW,lW=()=>{let W,Q=[];for(var J=0;J<256;J++){W=J;for(var V=0;V<8;V++)W=W&1?3988292384^W>>>1:W>>>1;Q[J]=W}return Q},rW=new Uint32Array(lW()),nW=(W,Q,J,V)=>{const G=rW,X=V+J;W^=-1;for(let Y=V;Y<X;Y++)W=W>>>8^G[(W^Q[Y])&255];return W^-1},_=nW,M0={2:"need dictionary",1:"stream end",0:"","-1":"file error","-2":"stream error","-3":"data error","-4":"insufficient memory","-5":"buffer error","-6":"incompatible version"},I0={Z_NO_FLUSH:0,Z_PARTIAL_FLUSH:1,Z_SYNC_FLUSH:2,Z_FULL_FLUSH:3,Z_FINISH:4,Z_BLOCK:5,Z_TREES:6,Z_OK:0,Z_STREAM_END:1,Z_NEED_DICT:2,Z_ERRNO:-1,Z_STREAM_ERROR:-2,Z_DATA_ERROR:-3,Z_MEM_ERROR:-4,Z_BUF_ERROR:-5,Z_NO_COMPRESSION:0,Z_BEST_SPEED:1,Z_BEST_COMPRESSION:9,Z_DEFAULT_COMPRESSION:-1,Z_FILTERED:1,Z_HUFFMAN_ONLY:2,Z_RLE:3,Z_FIXED:4,Z_DEFAULT_STRATEGY:0,Z_BINARY:0,Z_TEXT:1,Z_UNKNOWN:2,Z_DEFLATED:8},{_tr_init:oW,_tr_stored_block:t1,_tr_flush_block:aW,_tr_tally:F0,_tr_align:tW}=dW,{Z_NO_FLUSH:z0,Z_PARTIAL_FLUSH:sW,Z_FULL_FLUSH:eW,Z_FINISH:t,Z_BLOCK:A8,Z_OK:d,Z_STREAM_END:N8,Z_STREAM_ERROR:Q0,Z_DATA_ERROR:W5,Z_BUF_ERROR:b1,Z_DEFAULT_COMPRESSION:J5,Z_FILTERED:Q5,Z_HUFFMAN_ONLY:H1,Z_RLE:V5,Z_FIXED:G5,Z_DEFAULT_STRATEGY:X5,Z_UNKNOWN:q5,Z_DEFLATED:x1}=I0,U5=9,Y5=15,P5=8,K5=29,F5=256,s1=F5+1+K5,z5=30,Z5=19,H5=2*s1+1,k5=15,g=3,K0=258,V0=K0+g+1,$5=32,T0=42,Y8=57,e1=69,W8=73,J8=91,Q8=103,C0=113,d0=666,l=1,E0=2,L0=3,f0=4,B5=3,R0=(W,Q)=>{return W.msg=M0[Q],Q},S8=(W)=>{return W*2-(W>4?9:0)},P0=(W)=>{let Q=W.length;while(--Q>=0)W[Q]=0},j5=(W)=>{let Q,J,V,G=W.w_size;Q=W.hash_size,V=Q;do J=W.head[--V],W.head[V]=J>=G?J-G:0;while(--Q);Q=G,V=Q;do J=W.prev[--V],W.prev[V]=J>=G?J-G:0;while(--Q)},C5=(W,Q,J)=>(Q<<W.hash_shift^J)&W.hash_mask,Z0=C5,o=(W)=>{const Q=W.state;let J=Q.pending;if(J>W.avail_out)J=W.avail_out;if(J===0)return;if(W.output.set(Q.pending_buf.subarray(Q.pending_out,Q.pending_out+J),W.next_out),W.next_out+=J,Q.pending_out+=J,W.total_out+=J,W.avail_out-=J,Q.pending-=J,Q.pending===0)Q.pending_out=0},a=(W,Q)=>{aW(W,W.block_start>=0?W.block_start:-1,W.strstart-W.block_start,Q),W.block_start=W.strstart,o(W.strm)},f=(W,Q)=>{W.pending_buf[W.pending++]=Q},_0=(W,Q)=>{W.pending_buf[W.pending++]=Q>>>8&255,W.pending_buf[W.pending++]=Q&255},V8=(W,Q,J,V)=>{let G=W.avail_in;if(G>V)G=V;if(G===0)return 0;if(W.avail_in-=G,Q.set(W.input.subarray(W.next_in,W.next_in+G),J),W.state.wrap===1)W.adler=e0(W.adler,Q,G,J);else if(W.state.wrap===2)W.adler=_(W.adler,Q,G,J);return W.next_in+=G,W.total_in+=G,G},L6=(W,Q)=>{let{max_chain_length:J,strstart:V}=W,G,X,Y=W.prev_length,U=W.nice_match;const z=W.strstart>W.w_size-V0?W.strstart-(W.w_size-V0):0,q=W.window,P=W.w_mask,B=W.prev,F=W.strstart+K0;let K=q[V+Y-1],H=q[V+Y];if(W.prev_length>=W.good_match)J>>=2;if(U>W.lookahead)U=W.lookahead;do{if(G=Q,q[G+Y]!==H||q[G+Y-1]!==K||q[G]!==q[V]||q[++G]!==q[V+1])continue;V+=2,G++;do;while(q[++V]===q[++G]&&q[++V]===q[++G]&&q[++V]===q[++G]&&q[++V]===q[++G]&&q[++V]===q[++G]&&q[++V]===q[++G]&&q[++V]===q[++G]&&q[++V]===q[++G]&&V<F);if(X=K0-(F-V),V=F-K0,X>Y){if(W.match_start=Q,Y=X,X>=U)break;K=q[V+Y-1],H=q[V+Y]}}while((Q=B[Q&P])>z&&--J!==0);if(Y<=W.lookahead)return Y;return W.lookahead},g0=(W)=>{const Q=W.w_size;let J,V,G;do{if(V=W.window_size-W.lookahead-W.strstart,W.strstart>=Q+(Q-V0)){if(W.window.set(W.window.subarray(Q,Q+Q-V),0),W.match_start-=Q,W.strstart-=Q,W.block_start-=Q,W.insert>W.strstart)W.insert=W.strstart;j5(W),V+=Q}if(W.strm.avail_in===0)break;if(J=V8(W.strm,W.window,W.strstart+W.lookahead,V),W.lookahead+=J,W.lookahead+W.insert>=g){G=W.strstart-W.insert,W.ins_h=W.window[G],W.ins_h=Z0(W,W.ins_h,W.window[G+1]);while(W.insert)if(W.ins_h=Z0(W,W.ins_h,W.window[G+g-1]),W.prev[G&W.w_mask]=W.head[W.ins_h],W.head[W.ins_h]=G,G++,W.insert--,W.lookahead+W.insert<g)break}}while(W.lookahead<V0&&W.strm.avail_in!==0)},x6=(W,Q)=>{let J=W.pending_buf_size-5>W.w_size?W.w_size:W.pending_buf_size-5,V,G,X,Y=0,U=W.strm.avail_in;do{if(V=65535,X=W.bi_valid+42>>3,W.strm.avail_out<X)break;if(X=W.strm.avail_out-X,G=W.strstart-W.block_start,V>G+W.strm.avail_in)V=G+W.strm.avail_in;if(V>X)V=X;if(V<J&&(V===0&&Q!==t||Q===z0||V!==G+W.strm.avail_in))break;if(Y=Q===t&&V===G+W.strm.avail_in?1:0,t1(W,0,0,Y),W.pending_buf[W.pending-4]=V,W.pending_buf[W.pending-3]=V>>8,W.pending_buf[W.pending-2]=~V,W.pending_buf[W.pending-1]=~V>>8,o(W.strm),G){if(G>V)G=V;W.strm.output.set(W.window.subarray(W.block_start,W.block_start+G),W.strm.next_out),W.strm.next_out+=G,W.strm.avail_out-=G,W.strm.total_out+=G,W.block_start+=G,V-=G}if(V)V8(W.strm,W.strm.output,W.strm.next_out,V),W.strm.next_out+=V,W.strm.avail_out-=V,W.strm.total_out+=V}while(Y===0);if(U-=W.strm.avail_in,U){if(U>=W.w_size)W.matches=2,W.window.set(W.strm.input.subarray(W.strm.next_in-W.w_size,W.strm.next_in),0),W.strstart=W.w_size,W.insert=W.strstart;else{if(W.window_size-W.strstart<=U){if(W.strstart-=W.w_size,W.window.set(W.window.subarray(W.w_size,W.w_size+W.strstart),0),W.matches<2)W.matches++;if(W.insert>W.strstart)W.insert=W.strstart}W.window.set(W.strm.input.subarray(W.strm.next_in-U,W.strm.next_in),W.strstart),W.strstart+=U,W.insert+=U>W.w_size-W.insert?W.w_size-W.insert:U}W.block_start=W.strstart}if(W.high_water<W.strstart)W.high_water=W.strstart;if(Y)return f0;if(Q!==z0&&Q!==t&&W.strm.avail_in===0&&W.strstart===W.block_start)return E0;if(X=W.window_size-W.strstart,W.strm.avail_in>X&&W.block_start>=W.w_size){if(W.block_start-=W.w_size,W.strstart-=W.w_size,W.window.set(W.window.subarray(W.w_size,W.w_size+W.strstart),0),W.matches<2)W.matches++;if(X+=W.w_size,W.insert>W.strstart)W.insert=W.strstart}if(X>W.strm.avail_in)X=W.strm.avail_in;if(X)V8(W.strm,W.window,W.strstart,X),W.strstart+=X,W.insert+=X>W.w_size-W.insert?W.w_size-W.insert:X;if(W.high_water<W.strstart)W.high_water=W.strstart;if(X=W.bi_valid+42>>3,X=W.pending_buf_size-X>65535?65535:W.pending_buf_size-X,J=X>W.w_size?W.w_size:X,G=W.strstart-W.block_start,G>=J||(G||Q===t)&&Q!==z0&&W.strm.avail_in===0&&G<=X)V=G>X?X:G,Y=Q===t&&W.strm.avail_in===0&&V===G?1:0,t1(W,W.block_start,V,Y),W.block_start+=V,o(W.strm);return Y?L0:l},u1=(W,Q)=>{let J,V;for(;;){if(W.lookahead<V0){if(g0(W),W.lookahead<V0&&Q===z0)return l;if(W.lookahead===0)break}if(J=0,W.lookahead>=g)W.ins_h=Z0(W,W.ins_h,W.window[W.strstart+g-1]),J=W.prev[W.strstart&W.w_mask]=W.head[W.ins_h],W.head[W.ins_h]=W.strstart;if(J!==0&&W.strstart-J<=W.w_size-V0)W.match_length=L6(W,J);if(W.match_length>=g)if(V=F0(W,W.strstart-W.match_start,W.match_length-g),W.lookahead-=W.match_length,W.match_length<=W.max_lazy_match&&W.lookahead>=g){W.match_length--;do W.strstart++,W.ins_h=Z0(W,W.ins_h,W.window[W.strstart+g-1]),J=W.prev[W.strstart&W.w_mask]=W.head[W.ins_h],W.head[W.ins_h]=W.strstart;while(--W.match_length!==0);W.strstart++}else W.strstart+=W.match_length,W.match_length=0,W.ins_h=W.window[W.strstart],W.ins_h=Z0(W,W.ins_h,W.window[W.strstart+1]);else V=F0(W,0,W.window[W.strstart]),W.lookahead--,W.strstart++;if(V){if(a(W,!1),W.strm.avail_out===0)return l}}if(W.insert=W.strstart<g-1?W.strstart:g-1,Q===t){if(a(W,!0),W.strm.avail_out===0)return L0;return f0}if(W.sym_next){if(a(W,!1),W.strm.avail_out===0)return l}return E0},N0=(W,Q)=>{let J,V,G;for(;;){if(W.lookahead<V0){if(g0(W),W.lookahead<V0&&Q===z0)return l;if(W.lookahead===0)break}if(J=0,W.lookahead>=g)W.ins_h=Z0(W,W.ins_h,W.window[W.strstart+g-1]),J=W.prev[W.strstart&W.w_mask]=W.head[W.ins_h],W.head[W.ins_h]=W.strstart;if(W.prev_length=W.match_length,W.prev_match=W.match_start,W.match_length=g-1,J!==0&&W.prev_length<W.max_lazy_match&&W.strstart-J<=W.w_size-V0){if(W.match_length=L6(W,J),W.match_length<=5&&(W.strategy===Q5||W.match_length===g&&W.strstart-W.match_start>4096))W.match_length=g-1}if(W.prev_length>=g&&W.match_length<=W.prev_length){G=W.strstart+W.lookahead-g,V=F0(W,W.strstart-1-W.prev_match,W.prev_length-g),W.lookahead-=W.prev_length-1,W.prev_length-=2;do if(++W.strstart<=G)W.ins_h=Z0(W,W.ins_h,W.window[W.strstart+g-1]),J=W.prev[W.strstart&W.w_mask]=W.head[W.ins_h],W.head[W.ins_h]=W.strstart;while(--W.prev_length!==0);if(W.match_available=0,W.match_length=g-1,W.strstart++,V){if(a(W,!1),W.strm.avail_out===0)return l}}else if(W.match_available){if(V=F0(W,0,W.window[W.strstart-1]),V)a(W,!1);if(W.strstart++,W.lookahead--,W.strm.avail_out===0)return l}else W.match_available=1,W.strstart++,W.lookahead--}if(W.match_available)V=F0(W,0,W.window[W.strstart-1]),W.match_available=0;if(W.insert=W.strstart<g-1?W.strstart:g-1,Q===t){if(a(W,!0),W.strm.avail_out===0)return L0;return f0}if(W.sym_next){if(a(W,!1),W.strm.avail_out===0)return l}return E0},R5=(W,Q)=>{let J,V,G,X;const Y=W.window;for(;;){if(W.lookahead<=K0){if(g0(W),W.lookahead<=K0&&Q===z0)return l;if(W.lookahead===0)break}if(W.match_length=0,W.lookahead>=g&&W.strstart>0){if(G=W.strstart-1,V=Y[G],V===Y[++G]&&V===Y[++G]&&V===Y[++G]){X=W.strstart+K0;do;while(V===Y[++G]&&V===Y[++G]&&V===Y[++G]&&V===Y[++G]&&V===Y[++G]&&V===Y[++G]&&V===Y[++G]&&V===Y[++G]&&G<X);if(W.match_length=K0-(X-G),W.match_length>W.lookahead)W.match_length=W.lookahead}}if(W.match_length>=g)J=F0(W,1,W.match_length-g),W.lookahead-=W.match_length,W.strstart+=W.match_length,W.match_length=0;else J=F0(W,0,W.window[W.strstart]),W.lookahead--,W.strstart++;if(J){if(a(W,!1),W.strm.avail_out===0)return l}}if(W.insert=0,Q===t){if(a(W,!0),W.strm.avail_out===0)return L0;return f0}if(W.sym_next){if(a(W,!1),W.strm.avail_out===0)return l}return E0},M5=(W,Q)=>{let J;for(;;){if(W.lookahead===0){if(g0(W),W.lookahead===0){if(Q===z0)return l;break}}if(W.match_length=0,J=F0(W,0,W.window[W.strstart]),W.lookahead--,W.strstart++,J){if(a(W,!1),W.strm.avail_out===0)return l}}if(W.insert=0,Q===t){if(a(W,!0),W.strm.avail_out===0)return L0;return f0}if(W.sym_next){if(a(W,!1),W.strm.avail_out===0)return l}return E0},i0=[new W0(0,0,0,0,x6),new W0(4,4,8,4,u1),new W0(4,5,16,8,u1),new W0(4,6,32,32,u1),new W0(4,4,16,16,N0),new W0(8,16,32,32,N0),new W0(8,16,128,128,N0),new W0(8,32,128,256,N0),new W0(32,128,258,1024,N0),new W0(32,258,258,4096,N0)],L5=(W)=>{W.window_size=2*W.w_size,P0(W.head),W.max_lazy_match=i0[W.level].max_lazy,W.good_match=i0[W.level].good_length,W.nice_match=i0[W.level].nice_length,W.max_chain_length=i0[W.level].max_chain,W.strstart=0,W.block_start=0,W.lookahead=0,W.insert=0,W.match_length=W.prev_length=g-1,W.match_available=0,W.ins_h=0},G1=(W)=>{if(!W)return 1;const Q=W.state;if(!Q||Q.strm!==W||Q.status!==T0&&Q.status!==Y8&&Q.status!==e1&&Q.status!==W8&&Q.status!==J8&&Q.status!==Q8&&Q.status!==C0&&Q.status!==d0)return 1;return 0},I6=(W)=>{if(G1(W))return R0(W,Q0);W.total_in=W.total_out=0,W.data_type=q5;const Q=W.state;if(Q.pending=0,Q.pending_out=0,Q.wrap<0)Q.wrap=-Q.wrap;return Q.status=Q.wrap===2?Y8:Q.wrap?T0:C0,W.adler=Q.wrap===2?0:1,Q.last_flush=-2,oW(Q),d},O6=(W)=>{const Q=I6(W);if(Q===d)L5(W.state);return Q},I5=(W,Q)=>{if(G1(W)||W.state.wrap!==2)return Q0;return W.state.gzhead=Q,d},w6=(W,Q,J,V,G,X)=>{if(!W)return Q0;let Y=1;if(Q===J5)Q=6;if(V<0)Y=0,V=-V;else if(V>15)Y=2,V-=16;if(G<1||G>U5||J!==x1||V<8||V>15||Q<0||Q>9||X<0||X>G5||V===8&&Y!==1)return R0(W,Q0);if(V===8)V=9;const U=new x5;return W.state=U,U.strm=W,U.status=T0,U.wrap=Y,U.gzhead=null,U.w_bits=V,U.w_size=1<<U.w_bits,U.w_mask=U.w_size-1,U.hash_bits=G+7,U.hash_size=1<<U.hash_bits,U.hash_mask=U.hash_size-1,U.hash_shift=~~((U.hash_bits+g-1)/g),U.window=new Uint8Array(U.w_size*2),U.head=new Uint16Array(U.hash_size),U.prev=new Uint16Array(U.w_size),U.lit_bufsize=1<<G+6,U.pending_buf_size=U.lit_bufsize*4,U.pending_buf=new Uint8Array(U.pending_buf_size),U.sym_buf=U.lit_bufsize,U.sym_end=(U.lit_bufsize-1)*3,U.level=Q,U.strategy=X,U.method=J,O6(W)},O5=(W,Q)=>{return w6(W,Q,x1,Y5,P5,X5)},w5=(W,Q)=>{if(G1(W)||Q>A8||Q<0)return W?R0(W,Q0):Q0;const J=W.state;if(!W.output||W.avail_in!==0&&!W.input||J.status===d0&&Q!==t)return R0(W,W.avail_out===0?b1:Q0);const V=J.last_flush;if(J.last_flush=Q,J.pending!==0){if(o(W),W.avail_out===0)return J.last_flush=-1,d}else if(W.avail_in===0&&S8(Q)<=S8(V)&&Q!==t)return R0(W,b1);if(J.status===d0&&W.avail_in!==0)return R0(W,b1);if(J.status===T0&&J.wrap===0)J.status=C0;if(J.status===T0){let G=x1+(J.w_bits-8<<4)<<8,X=-1;if(J.strategy>=H1||J.level<2)X=0;else if(J.level<6)X=1;else if(J.level===6)X=2;else X=3;if(G|=X<<6,J.strstart!==0)G|=$5;if(G+=31-G%31,_0(J,G),J.strstart!==0)_0(J,W.adler>>>16),_0(J,W.adler&65535);if(W.adler=1,J.status=C0,o(W),J.pending!==0)return J.last_flush=-1,d}if(J.status===Y8)if(W.adler=0,f(J,31),f(J,139),f(J,8),!J.gzhead){if(f(J,0),f(J,0),f(J,0),f(J,0),f(J,0),f(J,J.level===9?2:J.strategy>=H1||J.level<2?4:0),f(J,B5),J.status=C0,o(W),J.pending!==0)return J.last_flush=-1,d}else{if(f(J,(J.gzhead.text?1:0)+(J.gzhead.hcrc?2:0)+(!J.gzhead.extra?0:4)+(!J.gzhead.name?0:8)+(!J.gzhead.comment?0:16)),f(J,J.gzhead.time&255),f(J,J.gzhead.time>>8&255),f(J,J.gzhead.time>>16&255),f(J,J.gzhead.time>>24&255),f(J,J.level===9?2:J.strategy>=H1||J.level<2?4:0),f(J,J.gzhead.os&255),J.gzhead.extra&&J.gzhead.extra.length)f(J,J.gzhead.extra.length&255),f(J,J.gzhead.extra.length>>8&255);if(J.gzhead.hcrc)W.adler=_(W.adler,J.pending_buf,J.pending,0);J.gzindex=0,J.status=e1}if(J.status===e1){if(J.gzhead.extra){let G=J.pending,X=(J.gzhead.extra.length&65535)-J.gzindex;while(J.pending+X>J.pending_buf_size){let U=J.pending_buf_size-J.pending;if(J.pending_buf.set(J.gzhead.extra.subarray(J.gzindex,J.gzindex+U),J.pending),J.pending=J.pending_buf_size,J.gzhead.hcrc&&J.pending>G)W.adler=_(W.adler,J.pending_buf,J.pending-G,G);if(J.gzindex+=U,o(W),J.pending!==0)return J.last_flush=-1,d;G=0,X-=U}let Y=new Uint8Array(J.gzhead.extra);if(J.pending_buf.set(Y.subarray(J.gzindex,J.gzindex+X),J.pending),J.pending+=X,J.gzhead.hcrc&&J.pending>G)W.adler=_(W.adler,J.pending_buf,J.pending-G,G);J.gzindex=0}J.status=W8}if(J.status===W8){if(J.gzhead.name){let G=J.pending,X;do{if(J.pending===J.pending_buf_size){if(J.gzhead.hcrc&&J.pending>G)W.adler=_(W.adler,J.pending_buf,J.pending-G,G);if(o(W),J.pending!==0)return J.last_flush=-1,d;G=0}if(J.gzindex<J.gzhead.name.length)X=J.gzhead.name.charCodeAt(J.gzindex++)&255;else X=0;f(J,X)}while(X!==0);if(J.gzhead.hcrc&&J.pending>G)W.adler=_(W.adler,J.pending_buf,J.pending-G,G);J.gzindex=0}J.status=J8}if(J.status===J8){if(J.gzhead.comment){let G=J.pending,X;do{if(J.pending===J.pending_buf_size){if(J.gzhead.hcrc&&J.pending>G)W.adler=_(W.adler,J.pending_buf,J.pending-G,G);if(o(W),J.pending!==0)return J.last_flush=-1,d;G=0}if(J.gzindex<J.gzhead.comment.length)X=J.gzhead.comment.charCodeAt(J.gzindex++)&255;else X=0;f(J,X)}while(X!==0);if(J.gzhead.hcrc&&J.pending>G)W.adler=_(W.adler,J.pending_buf,J.pending-G,G)}J.status=Q8}if(J.status===Q8){if(J.gzhead.hcrc){if(J.pending+2>J.pending_buf_size){if(o(W),J.pending!==0)return J.last_flush=-1,d}f(J,W.adler&255),f(J,W.adler>>8&255),W.adler=0}if(J.status=C0,o(W),J.pending!==0)return J.last_flush=-1,d}if(W.avail_in!==0||J.lookahead!==0||Q!==z0&&J.status!==d0){let G=J.level===0?x6(J,Q):J.strategy===H1?M5(J,Q):J.strategy===V5?R5(J,Q):i0[J.level].func(J,Q);if(G===L0||G===f0)J.status=d0;if(G===l||G===L0){if(W.avail_out===0)J.last_flush=-1;return d}if(G===E0){if(Q===sW)tW(J);else if(Q!==A8){if(t1(J,0,0,!1),Q===eW){if(P0(J.head),J.lookahead===0)J.strstart=0,J.block_start=0,J.insert=0}}if(o(W),W.avail_out===0)return J.last_flush=-1,d}}if(Q!==t)return d;if(J.wrap<=0)return N8;if(J.wrap===2)f(J,W.adler&255),f(J,W.adler>>8&255),f(J,W.adler>>16&255),f(J,W.adler>>24&255),f(J,W.total_in&255),f(J,W.total_in>>8&255),f(J,W.total_in>>16&255),f(J,W.total_in>>24&255);else _0(J,W.adler>>>16),_0(J,W.adler&65535);if(o(W),J.wrap>0)J.wrap=-J.wrap;return J.pending!==0?d:N8},D5=(W)=>{if(G1(W))return Q0;const Q=W.state.status;return W.state=null,Q===C0?R0(W,W5):d},A5=(W,Q)=>{let J=Q.length;if(G1(W))return Q0;const V=W.state,G=V.wrap;if(G===2||G===1&&V.status!==T0||V.lookahead)return Q0;if(G===1)W.adler=e0(W.adler,Q,J,0);if(V.wrap=0,J>=V.w_size){if(G===0)P0(V.head),V.strstart=0,V.block_start=0,V.insert=0;let z=new Uint8Array(V.w_size);z.set(Q.subarray(J-V.w_size,J),0),Q=z,J=V.w_size}const{avail_in:X,next_in:Y,input:U}=W;W.avail_in=J,W.next_in=0,W.input=Q,g0(V);while(V.lookahead>=g){let z=V.strstart,q=V.lookahead-(g-1);do V.ins_h=Z0(V,V.ins_h,V.window[z+g-1]),V.prev[z&V.w_mask]=V.head[V.ins_h],V.head[V.ins_h]=z,z++;while(--q);V.strstart=z,V.lookahead=g-1,g0(V)}return V.strstart+=V.lookahead,V.block_start=V.strstart,V.insert=V.lookahead,V.lookahead=0,V.match_length=V.prev_length=g-1,V.match_available=0,W.next_in=Y,W.input=U,W.avail_in=X,V.wrap=G,d},N5=O5,S5=w6,v5=O6,T5=I6,g5=I5,y5=w5,E5=D5,f5=A5,p5="pako deflate (from Nodeca project)",r0={deflateInit:N5,deflateInit2:S5,deflateReset:v5,deflateResetKeep:T5,deflateSetHeader:g5,deflate:y5,deflateEnd:E5,deflateSetDictionary:f5,deflateInfo:p5},h5=(W,Q)=>{return Object.prototype.hasOwnProperty.call(W,Q)},b5=function(W){const Q=Array.prototype.slice.call(arguments,1);while(Q.length){const J=Q.shift();if(!J)continue;if(typeof J!=="object")throw new TypeError(J+"must be non-object");for(let V in J)if(h5(J,V))W[V]=J[V]}return W},u5=(W)=>{let Q=0;for(let V=0,G=W.length;V<G;V++)Q+=W[V].length;const J=new Uint8Array(Q);for(let V=0,G=0,X=W.length;V<X;V++){let Y=W[V];J.set(Y,G),G+=Y.length}return J},I1={assign:b5,flattenChunks:u5},D6=!0;try{String.fromCharCode.apply(null,new Uint8Array(1))}catch(W){D6=!1}var W1=new Uint8Array(256);for(let W=0;W<256;W++)W1[W]=W>=252?6:W>=248?5:W>=240?4:W>=224?3:W>=192?2:1;W1[254]=W1[254]=1;var m5=(W)=>{if(typeof TextEncoder==="function"&&TextEncoder.prototype.encode)return(new TextEncoder()).encode(W);let Q,J,V,G,X,Y=W.length,U=0;for(G=0;G<Y;G++){if(J=W.charCodeAt(G),(J&64512)===55296&&G+1<Y){if(V=W.charCodeAt(G+1),(V&64512)===56320)J=65536+(J-55296<<10)+(V-56320),G++}U+=J<128?1:J<2048?2:J<65536?3:4}Q=new Uint8Array(U);for(X=0,G=0;X<U;G++){if(J=W.charCodeAt(G),(J&64512)===55296&&G+1<Y){if(V=W.charCodeAt(G+1),(V&64512)===56320)J=65536+(J-55296<<10)+(V-56320),G++}if(J<128)Q[X++]=J;else if(J<2048)Q[X++]=192|J>>>6,Q[X++]=128|J&63;else if(J<65536)Q[X++]=224|J>>>12,Q[X++]=128|J>>>6&63,Q[X++]=128|J&63;else Q[X++]=240|J>>>18,Q[X++]=128|J>>>12&63,Q[X++]=128|J>>>6&63,Q[X++]=128|J&63}return Q},c5=(W,Q)=>{if(Q<65534){if(W.subarray&&D6)return String.fromCharCode.apply(null,W.length===Q?W:W.subarray(0,Q))}let J="";for(let V=0;V<Q;V++)J+=String.fromCharCode(W[V]);return J},_5=(W,Q)=>{const J=Q||W.length;if(typeof TextDecoder==="function"&&TextDecoder.prototype.decode)return(new TextDecoder()).decode(W.subarray(0,Q));let V,G;const X=new Array(J*2);for(G=0,V=0;V<J;){let Y=W[V++];if(Y<128){X[G++]=Y;continue}let U=W1[Y];if(U>4){X[G++]=65533,V+=U-1;continue}Y&=U===2?31:U===3?15:7;while(U>1&&V<J)Y=Y<<6|W[V++]&63,U--;if(U>1){X[G++]=65533;continue}if(Y<65536)X[G++]=Y;else Y-=65536,X[G++]=55296|Y>>10&1023,X[G++]=56320|Y&1023}return c5(X,G)},d5=(W,Q)=>{if(Q=Q||W.length,Q>W.length)Q=W.length;let J=Q-1;while(J>=0&&(W[J]&192)===128)J--;if(J<0)return Q;if(J===0)return Q;return J+W1[W[J]]>Q?J:Q},J1={string2buf:m5,buf2string:_5,utf8border:d5},A6=i5,N6=Object.prototype.toString,{Z_NO_FLUSH:l5,Z_SYNC_FLUSH:r5,Z_FULL_FLUSH:n5,Z_FINISH:o5,Z_OK:M1,Z_STREAM_END:a5,Z_DEFAULT_COMPRESSION:t5,Z_DEFAULT_STRATEGY:s5,Z_DEFLATED:e5}=I0;X1.prototype.push=function(W,Q){const J=this.strm,V=this.options.chunkSize;let G,X;if(this.ended)return!1;if(Q===~~Q)X=Q;else X=Q===!0?o5:l5;if(typeof W==="string")J.input=J1.string2buf(W);else if(N6.call(W)==="[object ArrayBuffer]")J.input=new Uint8Array(W);else J.input=W;J.next_in=0,J.avail_in=J.input.length;for(;;){if(J.avail_out===0)J.output=new Uint8Array(V),J.next_out=0,J.avail_out=V;if((X===r5||X===n5)&&J.avail_out<=6){this.onData(J.output.subarray(0,J.next_out)),J.avail_out=0;continue}if(G=r0.deflate(J,X),G===a5){if(J.next_out>0)this.onData(J.output.subarray(0,J.next_out));return G=r0.deflateEnd(this.strm),this.onEnd(G),this.ended=!0,G===M1}if(J.avail_out===0){this.onData(J.output);continue}if(X>0&&J.next_out>0){this.onData(J.output.subarray(0,J.next_out)),J.avail_out=0;continue}if(J.avail_in===0)break}return!0};X1.prototype.onData=function(W){this.chunks.push(W)};X1.prototype.onEnd=function(W){if(W===M1)this.result=I1.flattenChunks(this.chunks);this.chunks=[],this.err=W,this.msg=this.strm.msg};var QJ=X1,VJ=P8,GJ=WJ,XJ=JJ,qJ=I0,UJ={Deflate:QJ,deflate:VJ,deflateRaw:GJ,gzip:XJ,constants:qJ},k1=16209,YJ=16191,PJ=function W(Q,J){let V,G,X,Y,U,z,q,P,B,F,K,H,S,L,M,w,O,Z,y,h,j,v,A,x;const N=Q.state;V=Q.next_in,A=Q.input,G=V+(Q.avail_in-5),X=Q.next_out,x=Q.output,Y=X-(J-Q.avail_out),U=X+(Q.avail_out-257),z=N.dmax,q=N.wsize,P=N.whave,B=N.wnext,F=N.window,K=N.hold,H=N.bits,S=N.lencode,L=N.distcode,M=(1<<N.lenbits)-1,w=(1<<N.distbits)-1;W:do{if(H<15)K+=A[V++]<<H,H+=8,K+=A[V++]<<H,H+=8;O=S[K&M];J:for(;;){if(Z=O>>>24,K>>>=Z,H-=Z,Z=O>>>16&255,Z===0)x[X++]=O&65535;else if(Z&16){if(y=O&65535,Z&=15,Z){if(H<Z)K+=A[V++]<<H,H+=8;y+=K&(1<<Z)-1,K>>>=Z,H-=Z}if(H<15)K+=A[V++]<<H,H+=8,K+=A[V++]<<H,H+=8;O=L[K&w];Q:for(;;){if(Z=O>>>24,K>>>=Z,H-=Z,Z=O>>>16&255,Z&16){if(h=O&65535,Z&=15,H<Z){if(K+=A[V++]<<H,H+=8,H<Z)K+=A[V++]<<H,H+=8}if(h+=K&(1<<Z)-1,h>z){Q.msg="invalid distance too far back",N.mode=k1;break W}if(K>>>=Z,H-=Z,Z=X-Y,h>Z){if(Z=h-Z,Z>P){if(N.sane){Q.msg="invalid distance too far back",N.mode=k1;break W}}if(j=0,v=F,B===0){if(j+=q-Z,Z<y){y-=Z;do x[X++]=F[j++];while(--Z);j=X-h,v=x}}else if(B<Z){if(j+=q+B-Z,Z-=B,Z<y){y-=Z;do x[X++]=F[j++];while(--Z);if(j=0,B<y){Z=B,y-=Z;do x[X++]=F[j++];while(--Z);j=X-h,v=x}}}else if(j+=B-Z,Z<y){y-=Z;do x[X++]=F[j++];while(--Z);j=X-h,v=x}while(y>2)x[X++]=v[j++],x[X++]=v[j++],x[X++]=v[j++],y-=3;if(y){if(x[X++]=v[j++],y>1)x[X++]=v[j++]}}else{j=X-h;do x[X++]=x[j++],x[X++]=x[j++],x[X++]=x[j++],y-=3;while(y>2);if(y){if(x[X++]=x[j++],y>1)x[X++]=x[j++]}}}else if((Z&64)===0){O=L[(O&65535)+(K&(1<<Z)-1)];continue Q}else{Q.msg="invalid distance code",N.mode=k1;break W}break}}else if((Z&64)===0){O=S[(O&65535)+(K&(1<<Z)-1)];continue J}else if(Z&32){N.mode=YJ;break W}else{Q.msg="invalid literal/length code",N.mode=k1;break W}break}}while(V<G&&X<U);y=H>>3,V-=y,H-=y<<3,K&=(1<<H)-1,Q.next_in=V,Q.next_out=X,Q.avail_in=V<G?5+(G-V):5-(V-G),Q.avail_out=X<U?257+(U-X):257-(X-U),N.hold=K,N.bits=H;return},S0=15,v8=852,T8=592,g8=0,m1=1,y8=2,KJ=new Uint16Array([3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,0,0]),FJ=new Uint8Array([16,16,16,16,16,16,16,16,17,17,17,17,18,18,18,18,19,19,19,19,20,20,20,20,21,21,21,21,16,72,78]),zJ=new Uint16Array([1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,0,0]),ZJ=new Uint8Array([16,16,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,64,64]),HJ=(W,Q,J,V,G,X,Y,U)=>{const z=U.bits;let q=0,P=0,B=0,F=0,K=0,H=0,S=0,L=0,M=0,w=0,O,Z,y,h,j,v=null,A;const x=new Uint16Array(S0+1),N=new Uint16Array(S0+1);let e=null,H0,U0,k0;for(q=0;q<=S0;q++)x[q]=0;for(P=0;P<V;P++)x[Q[J+P]]++;K=z;for(F=S0;F>=1;F--)if(x[F]!==0)break;if(K>F)K=F;if(F===0)return G[X++]=1<<24|64<<16|0,G[X++]=1<<24|64<<16|0,U.bits=1,0;for(B=1;B<F;B++)if(x[B]!==0)break;if(K<B)K=B;L=1;for(q=1;q<=S0;q++)if(L<<=1,L-=x[q],L<0)return-1;if(L>0&&(W===g8||F!==1))return-1;N[1]=0;for(q=1;q<S0;q++)N[q+1]=N[q]+x[q];for(P=0;P<V;P++)if(Q[J+P]!==0)Y[N[Q[J+P]]++]=P;if(W===g8)v=e=Y,A=20;else if(W===m1)v=KJ,e=FJ,A=257;else v=zJ,e=ZJ,A=0;if(w=0,P=0,q=B,j=X,H=K,S=0,y=-1,M=1<<K,h=M-1,W===m1&&M>v8||W===y8&&M>T8)return 1;for(;;){if(H0=q-S,Y[P]+1<A)U0=0,k0=Y[P];else if(Y[P]>=A)U0=e[Y[P]-A],k0=v[Y[P]-A];else U0=96,k0=0;O=1<<q-S,Z=1<<H,B=Z;do Z-=O,G[j+(w>>S)+Z]=H0<<24|U0<<16|k0|0;while(Z!==0);O=1<<q-1;while(w&O)O>>=1;if(O!==0)w&=O-1,w+=O;else w=0;if(P++,--x[q]===0){if(q===F)break;q=Q[J+Y[P]]}if(q>K&&(w&h)!==y){if(S===0)S=K;j+=B,H=q-S,L=1<<H;while(H+S<F){if(L-=x[H+S],L<=0)break;H++,L<<=1}if(M+=1<<H,W===m1&&M>v8||W===y8&&M>T8)return 1;y=w&h,G[y]=K<<24|H<<16|j-X|0}}if(w!==0)G[j+w]=q-S<<24|64<<16|0;return U.bits=K,0},n0=HJ,kJ=0,S6=1,v6=2,{Z_FINISH:E8,Z_BLOCK:$J,Z_TREES:$1,Z_OK:x0,Z_STREAM_END:BJ,Z_NEED_DICT:jJ,Z_STREAM_ERROR:s,Z_DATA_ERROR:T6,Z_MEM_ERROR:g6,Z_BUF_ERROR:CJ,Z_DEFLATED:f8}=I0,O1=16180,p8=16181,h8=16182,b8=16183,u8=16184,m8=16185,c8=16186,_8=16187,d8=16188,i8=16189,L1=16190,G0=16191,c1=16192,l8=16193,_1=16194,r8=16195,n8=16196,o8=16197,a8=16198,B1=16199,j1=16200,t8=16201,s8=16202,e8=16203,W6=16204,J6=16205,d1=16206,Q6=16207,V6=16208,b=16209,y6=16210,E6=16211,RJ=852,MJ=592,LJ=15,xJ=LJ,G6=(W)=>{return(W>>>24&255)+(W>>>8&65280)+((W&65280)<<8)+((W&255)<<24)},O0=(W)=>{if(!W)return 1;const Q=W.state;if(!Q||Q.strm!==W||Q.mode<O1||Q.mode>E6)return 1;return 0},f6=(W)=>{if(O0(W))return s;const Q=W.state;if(W.total_in=W.total_out=Q.total=0,W.msg="",Q.wrap)W.adler=Q.wrap&1;return Q.mode=O1,Q.last=0,Q.havedict=0,Q.flags=-1,Q.dmax=32768,Q.head=null,Q.hold=0,Q.bits=0,Q.lencode=Q.lendyn=new Int32Array(RJ),Q.distcode=Q.distdyn=new Int32Array(MJ),Q.sane=1,Q.back=-1,x0},p6=(W)=>{if(O0(W))return s;const Q=W.state;return Q.wsize=0,Q.whave=0,Q.wnext=0,f6(W)},h6=(W,Q)=>{let J;if(O0(W))return s;const V=W.state;if(Q<0)J=0,Q=-Q;else if(J=(Q>>4)+5,Q<48)Q&=15;if(Q&&(Q<8||Q>15))return s;if(V.window!==null&&V.wbits!==Q)V.window=null;return V.wrap=J,V.wbits=Q,p6(W)},b6=(W,Q)=>{if(!W)return s;const J=new IJ;W.state=J,J.strm=W,J.window=null,J.mode=O1;const V=h6(W,Q);if(V!==x0)W.state=null;return V},OJ=(W)=>{return b6(W,xJ)},X6=!0,i1,l1,wJ=(W)=>{if(X6){i1=new Int32Array(512),l1=new Int32Array(32);let Q=0;while(Q<144)W.lens[Q++]=8;while(Q<256)W.lens[Q++]=9;while(Q<280)W.lens[Q++]=7;while(Q<288)W.lens[Q++]=8;n0(S6,W.lens,0,288,i1,0,W.work,{bits:9}),Q=0;while(Q<32)W.lens[Q++]=5;n0(v6,W.lens,0,32,l1,0,W.work,{bits:5}),X6=!1}W.lencode=i1,W.lenbits=9,W.distcode=l1,W.distbits=5},u6=(W,Q,J,V)=>{let G;const X=W.state;if(X.window===null)X.wsize=1<<X.wbits,X.wnext=0,X.whave=0,X.window=new Uint8Array(X.wsize);if(V>=X.wsize)X.window.set(Q.subarray(J-X.wsize,J),0),X.wnext=0,X.whave=X.wsize;else{if(G=X.wsize-X.wnext,G>V)G=V;if(X.window.set(Q.subarray(J-V,J-V+G),X.wnext),V-=G,V)X.window.set(Q.subarray(J-V,J),0),X.wnext=V,X.whave=X.wsize;else{if(X.wnext+=G,X.wnext===X.wsize)X.wnext=0;if(X.whave<X.wsize)X.whave+=G}}return 0},DJ=(W,Q)=>{let J,V,G,X,Y,U,z,q,P,B,F,K,H,S,L=0,M,w,O,Z,y,h,j,v;const A=new Uint8Array(4);let x,N;const e=new Uint8Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]);if(O0(W)||!W.output||!W.input&&W.avail_in!==0)return s;if(J=W.state,J.mode===G0)J.mode=c1;Y=W.next_out,G=W.output,z=W.avail_out,X=W.next_in,V=W.input,U=W.avail_in,q=J.hold,P=J.bits,B=U,F=z,v=x0;W:for(;;)switch(J.mode){case O1:if(J.wrap===0){J.mode=c1;break}while(P<16){if(U===0)break W;U--,q+=V[X++]<<P,P+=8}if(J.wrap&2&&q===35615){if(J.wbits===0)J.wbits=15;J.check=0,A[0]=q&255,A[1]=q>>>8&255,J.check=_(J.check,A,2,0),q=0,P=0,J.mode=p8;break}if(J.head)J.head.done=!1;if(!(J.wrap&1)||(((q&255)<<8)+(q>>8))%31){W.msg="incorrect header check",J.mode=b;break}if((q&15)!==f8){W.msg="unknown compression method",J.mode=b;break}if(q>>>=4,P-=4,j=(q&15)+8,J.wbits===0)J.wbits=j;if(j>15||j>J.wbits){W.msg="invalid window size",J.mode=b;break}J.dmax=1<<J.wbits,J.flags=0,W.adler=J.check=1,J.mode=q&512?i8:G0,q=0,P=0;break;case p8:while(P<16){if(U===0)break W;U--,q+=V[X++]<<P,P+=8}if(J.flags=q,(J.flags&255)!==f8){W.msg="unknown compression method",J.mode=b;break}if(J.flags&57344){W.msg="unknown header flags set",J.mode=b;break}if(J.head)J.head.text=q>>8&1;if(J.flags&512&&J.wrap&4)A[0]=q&255,A[1]=q>>>8&255,J.check=_(J.check,A,2,0);q=0,P=0,J.mode=h8;case h8:while(P<32){if(U===0)break W;U--,q+=V[X++]<<P,P+=8}if(J.head)J.head.time=q;if(J.flags&512&&J.wrap&4)A[0]=q&255,A[1]=q>>>8&255,A[2]=q>>>16&255,A[3]=q>>>24&255,J.check=_(J.check,A,4,0);q=0,P=0,J.mode=b8;case b8:while(P<16){if(U===0)break W;U--,q+=V[X++]<<P,P+=8}if(J.head)J.head.xflags=q&255,J.head.os=q>>8;if(J.flags&512&&J.wrap&4)A[0]=q&255,A[1]=q>>>8&255,J.check=_(J.check,A,2,0);q=0,P=0,J.mode=u8;case u8:if(J.flags&1024){while(P<16){if(U===0)break W;U--,q+=V[X++]<<P,P+=8}if(J.length=q,J.head)J.head.extra_len=q;if(J.flags&512&&J.wrap&4)A[0]=q&255,A[1]=q>>>8&255,J.check=_(J.check,A,2,0);q=0,P=0}else if(J.head)J.head.extra=null;J.mode=m8;case m8:if(J.flags&1024){if(K=J.length,K>U)K=U;if(K){if(J.head){if(j=J.head.extra_len-J.length,!J.head.extra)J.head.extra=new Uint8Array(J.head.extra_len);J.head.extra.set(V.subarray(X,X+K),j)}if(J.flags&512&&J.wrap&4)J.check=_(J.check,V,K,X);U-=K,X+=K,J.length-=K}if(J.length)break W}J.length=0,J.mode=c8;case c8:if(J.flags&2048){if(U===0)break W;K=0;do if(j=V[X+K++],J.head&&j&&J.length<65536)J.head.name+=String.fromCharCode(j);while(j&&K<U);if(J.flags&512&&J.wrap&4)J.check=_(J.check,V,K,X);if(U-=K,X+=K,j)break W}else if(J.head)J.head.name=null;J.length=0,J.mode=_8;case _8:if(J.flags&4096){if(U===0)break W;K=0;do if(j=V[X+K++],J.head&&j&&J.length<65536)J.head.comment+=String.fromCharCode(j);while(j&&K<U);if(J.flags&512&&J.wrap&4)J.check=_(J.check,V,K,X);if(U-=K,X+=K,j)break W}else if(J.head)J.head.comment=null;J.mode=d8;case d8:if(J.flags&512){while(P<16){if(U===0)break W;U--,q+=V[X++]<<P,P+=8}if(J.wrap&4&&q!==(J.check&65535)){W.msg="header crc mismatch",J.mode=b;break}q=0,P=0}if(J.head)J.head.hcrc=J.flags>>9&1,J.head.done=!0;W.adler=J.check=0,J.mode=G0;break;case i8:while(P<32){if(U===0)break W;U--,q+=V[X++]<<P,P+=8}W.adler=J.check=G6(q),q=0,P=0,J.mode=L1;case L1:if(J.havedict===0)return W.next_out=Y,W.avail_out=z,W.next_in=X,W.avail_in=U,J.hold=q,J.bits=P,jJ;W.adler=J.check=1,J.mode=G0;case G0:if(Q===$J||Q===$1)break W;case c1:if(J.last){q>>>=P&7,P-=P&7,J.mode=d1;break}while(P<3){if(U===0)break W;U--,q+=V[X++]<<P,P+=8}switch(J.last=q&1,q>>>=1,P-=1,q&3){case 0:J.mode=l8;break;case 1:if(wJ(J),J.mode=B1,Q===$1){q>>>=2,P-=2;break W}break;case 2:J.mode=n8;break;case 3:W.msg="invalid block type",J.mode=b}q>>>=2,P-=2;break;case l8:q>>>=P&7,P-=P&7;while(P<32){if(U===0)break W;U--,q+=V[X++]<<P,P+=8}if((q&65535)!==(q>>>16^65535)){W.msg="invalid stored block lengths",J.mode=b;break}if(J.length=q&65535,q=0,P=0,J.mode=_1,Q===$1)break W;case _1:J.mode=r8;case r8:if(K=J.length,K){if(K>U)K=U;if(K>z)K=z;if(K===0)break W;G.set(V.subarray(X,X+K),Y),U-=K,X+=K,z-=K,Y+=K,J.length-=K;break}J.mode=G0;break;case n8:while(P<14){if(U===0)break W;U--,q+=V[X++]<<P,P+=8}if(J.nlen=(q&31)+257,q>>>=5,P-=5,J.ndist=(q&31)+1,q>>>=5,P-=5,J.ncode=(q&15)+4,q>>>=4,P-=4,J.nlen>286||J.ndist>30){W.msg="too many length or distance symbols",J.mode=b;break}J.have=0,J.mode=o8;case o8:while(J.have<J.ncode){while(P<3){if(U===0)break W;U--,q+=V[X++]<<P,P+=8}J.lens[e[J.have++]]=q&7,q>>>=3,P-=3}while(J.have<19)J.lens[e[J.have++]]=0;if(J.lencode=J.lendyn,J.lenbits=7,x={bits:J.lenbits},v=n0(kJ,J.lens,0,19,J.lencode,0,J.work,x),J.lenbits=x.bits,v){W.msg="invalid code lengths set",J.mode=b;break}J.have=0,J.mode=a8;case a8:while(J.have<J.nlen+J.ndist){for(;;){if(L=J.lencode[q&(1<<J.lenbits)-1],M=L>>>24,w=L>>>16&255,O=L&65535,M<=P)break;if(U===0)break W;U--,q+=V[X++]<<P,P+=8}if(O<16)q>>>=M,P-=M,J.lens[J.have++]=O;else{if(O===16){N=M+2;while(P<N){if(U===0)break W;U--,q+=V[X++]<<P,P+=8}if(q>>>=M,P-=M,J.have===0){W.msg="invalid bit length repeat",J.mode=b;break}j=J.lens[J.have-1],K=3+(q&3),q>>>=2,P-=2}else if(O===17){N=M+3;while(P<N){if(U===0)break W;U--,q+=V[X++]<<P,P+=8}q>>>=M,P-=M,j=0,K=3+(q&7),q>>>=3,P-=3}else{N=M+7;while(P<N){if(U===0)break W;U--,q+=V[X++]<<P,P+=8}q>>>=M,P-=M,j=0,K=11+(q&127),q>>>=7,P-=7}if(J.have+K>J.nlen+J.ndist){W.msg="invalid bit length repeat",J.mode=b;break}while(K--)J.lens[J.have++]=j}}if(J.mode===b)break;if(J.lens[256]===0){W.msg="invalid code -- missing end-of-block",J.mode=b;break}if(J.lenbits=9,x={bits:J.lenbits},v=n0(S6,J.lens,0,J.nlen,J.lencode,0,J.work,x),J.lenbits=x.bits,v){W.msg="invalid literal/lengths set",J.mode=b;break}if(J.distbits=6,J.distcode=J.distdyn,x={bits:J.distbits},v=n0(v6,J.lens,J.nlen,J.ndist,J.distcode,0,J.work,x),J.distbits=x.bits,v){W.msg="invalid distances set",J.mode=b;break}if(J.mode=B1,Q===$1)break W;case B1:J.mode=j1;case j1:if(U>=6&&z>=258){if(W.next_out=Y,W.avail_out=z,W.next_in=X,W.avail_in=U,J.hold=q,J.bits=P,PJ(W,F),Y=W.next_out,G=W.output,z=W.avail_out,X=W.next_in,V=W.input,U=W.avail_in,q=J.hold,P=J.bits,J.mode===G0)J.back=-1;break}J.back=0;for(;;){if(L=J.lencode[q&(1<<J.lenbits)-1],M=L>>>24,w=L>>>16&255,O=L&65535,M<=P)break;if(U===0)break W;U--,q+=V[X++]<<P,P+=8}if(w&&(w&240)===0){Z=M,y=w,h=O;for(;;){if(L=J.lencode[h+((q&(1<<Z+y)-1)>>Z)],M=L>>>24,w=L>>>16&255,O=L&65535,Z+M<=P)break;if(U===0)break W;U--,q+=V[X++]<<P,P+=8}q>>>=Z,P-=Z,J.back+=Z}if(q>>>=M,P-=M,J.back+=M,J.length=O,w===0){J.mode=J6;break}if(w&32){J.back=-1,J.mode=G0;break}if(w&64){W.msg="invalid literal/length code",J.mode=b;break}J.extra=w&15,J.mode=t8;case t8:if(J.extra){N=J.extra;while(P<N){if(U===0)break W;U--,q+=V[X++]<<P,P+=8}J.length+=q&(1<<J.extra)-1,q>>>=J.extra,P-=J.extra,J.back+=J.extra}J.was=J.length,J.mode=s8;case s8:for(;;){if(L=J.distcode[q&(1<<J.distbits)-1],M=L>>>24,w=L>>>16&255,O=L&65535,M<=P)break;if(U===0)break W;U--,q+=V[X++]<<P,P+=8}if((w&240)===0){Z=M,y=w,h=O;for(;;){if(L=J.distcode[h+((q&(1<<Z+y)-1)>>Z)],M=L>>>24,w=L>>>16&255,O=L&65535,Z+M<=P)break;if(U===0)break W;U--,q+=V[X++]<<P,P+=8}q>>>=Z,P-=Z,J.back+=Z}if(q>>>=M,P-=M,J.back+=M,w&64){W.msg="invalid distance code",J.mode=b;break}J.offset=O,J.extra=w&15,J.mode=e8;case e8:if(J.extra){N=J.extra;while(P<N){if(U===0)break W;U--,q+=V[X++]<<P,P+=8}J.offset+=q&(1<<J.extra)-1,q>>>=J.extra,P-=J.extra,J.back+=J.extra}if(J.offset>J.dmax){W.msg="invalid distance too far back",J.mode=b;break}J.mode=W6;case W6:if(z===0)break W;if(K=F-z,J.offset>K){if(K=J.offset-K,K>J.whave){if(J.sane){W.msg="invalid distance too far back",J.mode=b;break}}if(K>J.wnext)K-=J.wnext,H=J.wsize-K;else H=J.wnext-K;if(K>J.length)K=J.length;S=J.window}else S=G,H=Y-J.offset,K=J.length;if(K>z)K=z;z-=K,J.length-=K;do G[Y++]=S[H++];while(--K);if(J.length===0)J.mode=j1;break;case J6:if(z===0)break W;G[Y++]=J.length,z--,J.mode=j1;break;case d1:if(J.wrap){while(P<32){if(U===0)break W;U--,q|=V[X++]<<P,P+=8}if(F-=z,W.total_out+=F,J.total+=F,J.wrap&4&&F)W.adler=J.check=J.flags?_(J.check,G,F,Y-F):e0(J.check,G,F,Y-F);if(F=z,J.wrap&4&&(J.flags?q:G6(q))!==J.check){W.msg="incorrect data check",J.mode=b;break}q=0,P=0}J.mode=Q6;case Q6:if(J.wrap&&J.flags){while(P<32){if(U===0)break W;U--,q+=V[X++]<<P,P+=8}if(J.wrap&4&&q!==(J.total&4294967295)){W.msg="incorrect length check",J.mode=b;break}q=0,P=0}J.mode=V6;case V6:v=BJ;break W;case b:v=T6;break W;case y6:return g6;case E6:default:return s}if(W.next_out=Y,W.avail_out=z,W.next_in=X,W.avail_in=U,J.hold=q,J.bits=P,J.wsize||F!==W.avail_out&&J.mode<b&&(J.mode<d1||Q!==E8)){if(u6(W,W.output,W.next_out,F-W.avail_out));}if(B-=W.avail_in,F-=W.avail_out,W.total_in+=B,W.total_out+=F,J.total+=F,J.wrap&4&&F)W.adler=J.check=J.flags?_(J.check,G,F,W.next_out-F):e0(J.check,G,F,W.next_out-F);if(W.data_type=J.bits+(J.last?64:0)+(J.mode===G0?128:0)+(J.mode===B1||J.mode===_1?256:0),(B===0&&F===0||Q===E8)&&v===x0)v=CJ;return v},AJ=(W)=>{if(O0(W))return s;let Q=W.state;if(Q.window)Q.window=null;return W.state=null,x0},NJ=(W,Q)=>{if(O0(W))return s;const J=W.state;if((J.wrap&2)===0)return s;return J.head=Q,Q.done=!1,x0},SJ=(W,Q)=>{const J=Q.length;let V,G,X;if(O0(W))return s;if(V=W.state,V.wrap!==0&&V.mode!==L1)return s;if(V.mode===L1){if(G=1,G=e0(G,Q,J,0),G!==V.check)return T6}if(X=u6(W,Q,J,J),X)return V.mode=y6,g6;return V.havedict=1,x0},vJ=p6,TJ=h6,gJ=f6,yJ=OJ,EJ=b6,fJ=DJ,pJ=AJ,hJ=NJ,bJ=SJ,uJ="pako inflate (from Nodeca project)",q0={inflateReset:vJ,inflateReset2:TJ,inflateResetKeep:gJ,inflateInit:yJ,inflateInit2:EJ,inflate:fJ,inflateEnd:pJ,inflateGetHeader:hJ,inflateSetDictionary:bJ,inflateInfo:uJ},cJ=mJ,m6=Object.prototype.toString,{Z_NO_FLUSH:_J,Z_FINISH:dJ,Z_OK:Q1,Z_STREAM_END:r1,Z_NEED_DICT:n1,Z_STREAM_ERROR:iJ,Z_DATA_ERROR:q6,Z_MEM_ERROR:lJ}=I0;q1.prototype.push=function(W,Q){const J=this.strm,V=this.options.chunkSize,G=this.options.dictionary;let X,Y,U;if(this.ended)return!1;if(Q===~~Q)Y=Q;else Y=Q===!0?dJ:_J;if(m6.call(W)==="[object ArrayBuffer]")J.input=new Uint8Array(W);else J.input=W;J.next_in=0,J.avail_in=J.input.length;for(;;){if(J.avail_out===0)J.output=new Uint8Array(V),J.next_out=0,J.avail_out=V;if(X=q0.inflate(J,Y),X===n1&&G){if(X=q0.inflateSetDictionary(J,G),X===Q1)X=q0.inflate(J,Y);else if(X===q6)X=n1}while(J.avail_in>0&&X===r1&&J.state.wrap>0&&W[J.next_in]!==0)q0.inflateReset(J),X=q0.inflate(J,Y);switch(X){case iJ:case q6:case n1:case lJ:return this.onEnd(X),this.ended=!0,!1}if(U=J.avail_out,J.next_out){if(J.avail_out===0||X===r1)if(this.options.to==="string"){let z=J1.utf8border(J.output,J.next_out),q=J.next_out-z,P=J1.buf2string(J.output,z);if(J.next_out=q,J.avail_out=V-q,q)J.output.set(J.output.subarray(z,z+q),0);this.onData(P)}else this.onData(J.output.length===J.next_out?J.output:J.output.subarray(0,J.next_out))}if(X===Q1&&U===0)continue;if(X===r1)return X=q0.inflateEnd(this.strm),this.onEnd(X),this.ended=!0,!0;if(J.avail_in===0)break}return!0};q1.prototype.onData=function(W){this.chunks.push(W)};q1.prototype.onEnd=function(W){if(W===Q1)if(this.options.to==="string")this.result=this.chunks.join("");else this.result=I1.flattenChunks(this.chunks);this.chunks=[],this.err=W,this.msg=this.strm.msg};var nJ=q1,oJ=K8,aJ=rJ,tJ=K8,sJ=I0,eJ={Inflate:nJ,inflate:oJ,inflateRaw:aJ,ungzip:tJ,constants:sJ},{Deflate:W7,deflate:J7,deflateRaw:Q7,gzip:V7}=UJ,{Inflate:G7,inflate:X7,inflateRaw:q7,ungzip:U7}=eJ,Y7=W7,P7=J7,K7=Q7,F7=V7,z7=G7,Z7=X7,H7=q7,k7=U7,$7=I0,p0={Deflate:Y7,deflate:P7,deflateRaw:K7,gzip:F7,Inflate:z7,inflate:Z7,inflateRaw:H7,ungzip:k7,constants:$7};function c6(W,Q,J){let V=Q.timestamp;if(V?.physical>Date.now()+7200000)V={physical:Date.now()+7200000,logical:V.logical};if(Q.value.priority)return{resolved:!0,value:Q.value,timestamp:V};if(Q.value.priority=!1,!W?.timestamp)return{resolved:!0,value:Q.value,timestamp:V};if(J.compare(V,W.timestamp)<=0)return{resolved:!1};return{resolved:!0,value:Q.value,timestamp:V}}function _6(W,Q=50){const J=`gdb_oplog_${W}`;let V=[];function G(){try{const Y=localStorage.getItem(J);V=Y?JSON.parse(Y):[]}catch(Y){console.error("\u274C GDB: Failed to load oplog from localStorage:",Y),V=[]}}function X(){try{localStorage.setItem(J,JSON.stringify(V))}catch(Y){console.error("\u274C GDB: Failed to save oplog to localStorage:",Y)}}return G(),{remove(Y){V=V.filter((U)=>U.id!==Y),X()},add(Y){if(V.push(Y),V.length>Q)V.shift();X()},getDelta(Y,U){if(!Y)return[...V];return V.filter((z)=>U(z.timestamp,Y)>0)},getOldest(){return V[0]},clear(){V=[],localStorage.removeItem(J)}}}var B7=()=>{const W=new Map,Q=async()=>{try{const z=await navigator.storage.getDirectory(),P=await(await z.getFileHandle("~opfs-sync-test",{create:!0})).createSyncAccessHandle?.();return await P?.close(),await z.removeEntry("~opfs-sync-test"),!!P}catch{return!1}};let J="idb";const V=(async()=>{if(await Q())J="sync";else try{const z=await navigator.storage.getDirectory(),P=await(await z.getFileHandle("~opfs-async-test",{create:!0})).createWritable?.();if(await P?.close(),await z.removeEntry("~opfs-async-test"),P)J="async";else J="idb"}catch{J="idb"}})(),G=async(z,q)=>{if(!W.has(z))W.set(z,[]);const P=W.get(z),B=P[P.length-1]||Promise.resolve();let F;const K=new Promise((H)=>F=H);P.push(K);try{return await B,await q()}finally{if(P.shift(),F(),P.length===0)W.delete(z)}},X=(()=>{let z;const q=async()=>{if(!z)z=new Promise((P,B)=>{const F=indexedDB.open("opfs-fallback-db",1);F.onupgradeneeded=()=>F.result.createObjectStore("files"),F.onsuccess=()=>P(F.result),F.onerror=()=>B(F.error)});return z};return{getDB:q,get:async(P)=>{const B=await q();return new Promise((F,K)=>{const S=B.transaction("files","readonly").objectStore("files").get(P);S.onsuccess=()=>F(S.result||new Uint8Array),S.onerror=()=>K(S.error)})},set:async(P,B)=>{const F=await q();return new Promise((K,H)=>{const L=F.transaction("files","readwrite").objectStore("files").put(B,P);L.onsuccess=()=>K(),L.onerror=()=>H(L.error)})}}})(),Y=async(z)=>{await V;try{if(J==="idb"){const K=await X.get(z);return{type:"loaded",name:z,data:K}}const P=await(await navigator.storage.getDirectory()).getFileHandle(z);if(J==="sync"){let K;try{K=await P.createSyncAccessHandle();const H=K.getSize(),S=new Uint8Array(H),L=K.read(S,{at:0});return{type:"loaded",name:z,data:S.slice(0,L)}}finally{K?.close()}}const B=await P.getFile(),F=new Uint8Array(await B.arrayBuffer());return{type:"loaded",name:z,data:F}}catch(q){if(q.name==="NotFoundError")return{type:"loaded",name:z,data:new Uint8Array};return console.error(`\u274C Worker file load error for '${z}':`,q),{type:"error",name:z,message:q.message||"Error reading file"}}},U=async(z,q)=>{if(await V,!(q instanceof Uint8Array))return{type:"error",name:z,message:"Content must be a Uint8Array"};return G(z,async()=>{try{if(J==="idb")return await X.set(z,q),{type:"saved",name:z};const B=await(await navigator.storage.getDirectory()).getFileHandle(z,{create:!0});if(J==="sync"){let F;try{F=await B.createSyncAccessHandle(),F.truncate(0),F.write(q,{at:0}),F.flush()}finally{F?.close()}}else{let F;try{F=await B.createWritable(),await F.write(q)}finally{await F?.close()}}return{type:"saved",name:z}}catch(P){return{type:"error",name:z,message:P.message||"Error saving file"}}})};self.onmessage=async({data:z})=>{const{type:q,name:P,content:B}=z;await V;const F={load:()=>Y(P),save:()=>U(P,B)};try{const K=F[q],H=K?await K():{type:"error",message:`Unrecognized action type: ${q}`};self.postMessage(H)}catch(K){console.error("\u274C Worker unexpected error:",K),self.postMessage({type:"error",name:P,message:K.message||"Unexpected worker error"})}}},d6=B7;var U1={$eq:(W,Q)=>W===Q,$ne:(W,Q)=>W!==Q,$gt:(W,Q)=>W>Q,$gte:(W,Q)=>W>=Q,$lt:(W,Q)=>W<Q,$lte:(W,Q)=>W<=Q,$in:(W,Q)=>Array.isArray(Q)&&(Array.isArray(W)?W.some((J)=>Q.includes(J)):Q.includes(W)),$between:(W,[Q,J])=>W>=Q&&W<=J,$exists:(W,Q)=>Q?W!==void 0:W===void 0,$startsWith:(W,Q)=>typeof W==="string"&&W.startsWith(Q),$endsWith:(W,Q)=>typeof W==="string"&&W.endsWith(Q),$contains:(W,Q)=>typeof W==="string"&&W.includes(Q),$text:{global:(W,Q)=>{const J=(G)=>String(G).normalize("NFD").replace(/[\u0300-\u036f]/g,"").toLowerCase().replace(/[^\w\s]/g,""),V=J(Q);return Object.values(W).some((G)=>typeof G==="object"?null.fieldSearch(G,V):J(G).includes(V))},field:(W,Q)=>{const J=(G)=>String(G).normalize("NFD").replace(/[\u0300-\u036f]/g,"").toLowerCase().replace(/[^\w\s]/g,""),V=J(Q);return Array.isArray(W)?W.some((G)=>J(G).includes(V)):J(W).includes(V)}},$like:(W,Q)=>typeof W==="string"&&typeof Q==="string"&&new RegExp(`^${Q.replace(/%/g,".*").replace(/_/g,".")}\$`,"i").test(W),$regex:(W,Q)=>typeof W==="string"&&new RegExp(Q.$regex||Q,"i").test(W),$and:(W,Q,J)=>Q.every((V)=>J.createFilter(V,J.allNodes)(W)),$or:(W,Q,J)=>Q.some((V)=>J.createFilter(V,J.allNodes)(W)),$not:(W,Q,J)=>!J.createFilter(Q,J.allNodes)(W),$edge:(W,Q,J)=>{if(!W.edges?.length||typeof Q!=="object"||Q===null)return!1;const V=J.createFilter(Q,J.allNodes),G=[...W.edges],X=new Set(G).add(W.id),Y=[];while(G.length){const U=G.shift(),z=J.allNodes[U];if(!z)continue;if(V(z))Y.push(z);z.edges?.forEach((q)=>!X.has(q)&&X.add(q)&&G.push(q))}if(Y.length)W._edgeResult=Y;return Y.length>0}},w1=(W,Q)=>Q.split(".").reduce((J,V)=>J&&typeof J==="object"&&(V in J)?J[V]:void 0,W),D1=(W,Q)=>{if(Object.keys(W).length===0)return()=>!0;return(J)=>Object.entries(W).every(([V,G])=>{if(V.startsWith("$"))return U1[V](J,G,{createFilter:D1,allNodes:Q});let X=w1(J.value,V);if(X===void 0)X=w1(J,V);if(typeof G!=="object"||G===null)return U1.$eq(X,G);return Object.entries(G).every(([Y,U])=>{if(Y==="$text")return U1.$text.field(X,U);if(Y==="$between"&&U.every((z)=>z instanceof Date))return U1.$between(new Date(X),U);return U1[Y]?.(X,U,{createFilter:D1,allNodes:Q})??!1})})},F8=(W,Q)=>{const{$edge:J,...V}=Q.query||{},G=D1(V,W),X=Object.values(W).filter(G);let U=[...J?(()=>{const z=D1({$edge:J},W);X.forEach((P)=>z(P));const q=new Map;return X.forEach((P)=>{if(P._edgeResult)P._edgeResult.forEach((B)=>q.set(B.id,B)),delete P._edgeResult}),Array.from(q.values())})():X];if(Q.field){const z=Q.order==="asc"?1:-1;U.sort((q,P)=>{const B=w1(q.value,Q.field),F=w1(P.value,Q.field);if(typeof B==="string"&&typeof F==="string")return B.localeCompare(F)*z;return((B??0)-(F??0))*z})}if(Q.$after){const z=U.findIndex((q)=>q.id===Q.$after);U=z>=0?U.slice(z+1):[]}if(Q.$before){const z=U.findIndex((q)=>q.id===Q.$before);U=z>=0?U.slice(0,z):[]}if(Q.$limit)U=U.slice(0,Q.$limit);return U};function i6(){let W=Date.now(),Q=0;return{now(){const J=Date.now();return W=Math.max(W,J),Q++,{physical:W,logical:Q}},update(J){if(!J||typeof J.physical!=="number"||typeof J.logical!=="number"){console.warn("\u26A0\uFE0F HybridClock.update received an invalid remote timestamp.",J);return}W=Math.max(W,J.physical),Q=Math.max(Q,J.logical)+1},compare(J,V){if(!J&&!V)return 0;if(!J)return-1;if(!V)return 1;if(J.physical>V.physical)return 1;if(J.physical<V.physical)return-1;if(J.logical>V.logical)return 1;if(J.logical<V.logical)return-1;return 0}}}var l6=function(W,Q){return W.length===Q.length&&W.every((J,V)=>J===Q[V])};async function C7(){if(console.info(navigator?.storage?.getDirectory?"\u2705 OPFS is enabled.":"\uD83D\uDEAB OPFS is not available."),navigator?.storage?.getDirectory)await navigator.storage.getDirectory()}var R7=function(){const W={nodes:{}};return{get nodes(){return W.nodes},set nodes(J){W.nodes=J||{}},upsert(J,V,G){const X=W.nodes[J];W.nodes[J]={id:J,value:V&&typeof V==="object"?z8(V):V,edges:X?.edges?[...X.edges]:[],timestamp:G}},get(J){return W.nodes[J]||null},link(J,V,G){const X=W.nodes[J],Y=W.nodes[V];if(X&&Y&&!X.edges.includes(V))W.nodes[J]={...X,edges:[...X.edges,V],timestamp:G}},getAllNodes(){return Object.values(W.nodes)},serialize(){return p0.deflate(b0(W.nodes))},deserialize(J){W.nodes=c0(p0.inflate(new Uint8Array(J)))}}};async function n6(W,Q={}){console.info("\x1B[36m\u26A1 GenosDB: Empowering distributed graph databases with real-time synchronization and scalability. Learn more: https://github.com/estebanrfp/gdb \u26A1\x1B[0m");const{rtc:J=!1,password:V,sm:G=!1,audit:X=!1,ii:Y=!1,rx:U=!1,ai:z=!1,geo:q=!1,saveDelay:P=200,oplogSize:B=20}=Q,F=R7(),K=i6(),H=_6(W,B),S=[];let L=null,M=[],w=null,O=null,Z=null,y=null;const h=[],j={};Object.defineProperties(j,{syncChannel:{get:()=>O},broadcastChannel:{get:()=>Z},hybridClock:{get:()=>K},graph:{get:()=>({getAllNodes:()=>F.getAllNodes(),get:($)=>F.get($)})},worker:{get:()=>w},oplog:{get:()=>H},options:{get:()=>Q},pako:{get:()=>p0},encode:{get:()=>b0},decode:{get:()=>c0},deepClone:{get:()=>z8}});async function v($,I){try{const C=await import(new URL(`./${$}.min.js`,import.meta.url).href),p=I&&typeof I==="object"?I:{},k=await C.init?.(j,C,p);if(k)Object.assign(j,k);return C}catch(C){throw console.error(`\u274C Initialization of ${$} failed:`,C),C}}function A(){const $=localStorage.getItem(`${W}_time`);L=$?JSON.parse($):null}function x($){L=$,localStorage.setItem(`${W}_time`,JSON.stringify($))}function N(){try{const $=URL.createObjectURL(new Blob([`(${d6.toString()})()`],{type:"application/javascript"}));w=new Worker($),URL.revokeObjectURL($),w.addEventListener("message",({data:I})=>console.info(`\uD83D\uDCBE ${I.name} ${I.type}`)),console.info("\u2699\uFE0F Worker initialized successfully.")}catch({message:$}){console.error("\u274C Failed to initialize worker:",$)}}function e(){const $={...F.nodes};M.forEach((I)=>I($))}const H0=j7(()=>e()),U0=r6(async()=>{const $=h.splice(0,h.length);if(!$.length)return!1;return await O.send($),!0},16);async function k0(){try{const I=await((C)=>new Promise((p,k)=>{const D=async({data:R})=>{if(R.type==="loaded"&&R.name===C)w.removeEventListener("message",D),p(new Uint8Array(R.data));else if(R.type==="error")w.removeEventListener("message",D),k(new Error(R.message||"Unknown error"))};w.addEventListener("message",D),w.postMessage({type:"load",name:C})}))(`${W}_graph.msgpack`).catch(()=>new Uint8Array);I.byteLength>0?F.deserialize(I):console.info("\uD83D\uDCBE New database. File will be created on first save.")}catch({message:$}){console.error("\u274C Error loading the graph:",$)}}async function A1(){try{const $=F.serialize();return await((C,p)=>new Promise((k,D)=>{const R=({data:T})=>{if(T.type==="saved"&&T.name===C)w.removeEventListener("message",R),k();else if(T.type==="error")w.removeEventListener("message",R),D(new Error(T.message||"Save error"))};w.addEventListener("message",R),w.postMessage({type:"save",name:C,content:p})}))(`${W}_graph.msgpack`,$),Z.postMessage("update"),!0}catch({message:$}){throw console.error("\u274C Save error:",$),new Error("Save failed")}}const N1=r6(()=>A1(),P);async function o6($){try{console.info("\uD83D\uDD04 Applying full graph from remote..."),F.nodes={...$.nodes},await A1()}catch({message:I}){console.error(`\u274C Error applying the full graph: ${I}`)}}async function a6($){let I=!1,C=null;const p={upsert:(k)=>{const D=F.get(k.id),R=c6(D,k,K);if(R.resolved){if(F.upsert(k.id,R.value,R.timestamp),K.update(R.timestamp),H.add({type:"upsert",id:k.id,timestamp:R.timestamp}),I=!0,!C||K.compare(R.timestamp,C)>0)C=R.timestamp}},remove:(k)=>{const D=F.get(k.id);if(D&&K.compare(D.timestamp,k.timestamp)<0){if(delete F.nodes[k.id],K.update(k.timestamp),H.add({type:"remove",id:k.id,timestamp:k.timestamp}),I=!0,!C||K.compare(k.timestamp,C)>0)C=k.timestamp}},link:(k)=>{const D=F.get(k.sourceId),R=F.get(k.targetId);if(D&&R&&K.compare(D.timestamp,k.timestamp)<0){if(F.link(k.sourceId,k.targetId,k.timestamp),K.update(k.timestamp),H.add({type:"link",sourceId:k.sourceId,targetId:k.targetId,timestamp:k.timestamp}),I=!0,!C||K.compare(k.timestamp,C)>0)C=k.timestamp}},sync:async(k)=>{const D=k.timestamp;if(D===null){console.info("\uD83D\uDCEC [SYNC REQUEST] from new peer (no timestamp). Sending full graph."),await O.send([{type:"syncReceive",graph:F}]);return}console.info("\uD83D\uDCEC [SYNC REQUEST] since:",new Date(D.physical).toLocaleString());const R=H.getOldest();if(R&&K.compare(D,R.timestamp)<0){console.info("\uD83D\uDCA5 [FALLBACK TRIGGERED] Peer is too far behind. Sending FULL graph state."),await O.send([{type:"syncReceive",graph:F}]);return}const T=H.getDelta(D,K.compare);if(T.length>0){const E=T.map((u)=>{if(u.type==="upsert"){const r=F.get(u.id);return{...u,value:r?r.value:null}}return u}),c=p0.deflate(b0(E));console.info(`\uD83D\uDE80 [DELTA SYNC SENDING] Found ${T.length} new operations to send.`),await O.send([{type:"deltaSync",operations:c}])}else console.info("\u2705 [ALREADY SYNCED] Peer is up-to-date. Nothing to send.")},deltaSync:(k)=>{const D=c0(p0.inflate(k.operations));console.info(`\uD83D\uDEF0\uFE0F [DELTA SYNC RECEIVED] Applying ${D.length} operations from a peer.`);for(let R of D)p[R.type]?.(R)},syncReceive:async(k)=>{console.info("\uD83D\uDCE6 [FULL SYNC RECEIVED] Overwriting local state with full graph from a peer.");const D=L;let R=null;if(k.graph&&k.graph.nodes)for(let T in k.graph.nodes){const E=k.graph.nodes[T];if(E.timestamp&&(!R||K.compare(E.timestamp,R)>0))R=E.timestamp}if(D&&R&&K.compare(D,R)>0){console.log("Local state is newer, ignoring full sync from peer");return}if(k.graph&&k.graph.nodes){await o6(k.graph),H.clear(),console.info("\uD83D\uDD12 Oplog has been cleared due to full sync."),I=!0;let T=null;for(let E in k.graph.nodes){const c=k.graph.nodes[E];if(c.timestamp&&(!T||K.compare(c.timestamp,T)>0))T=c.timestamp}if(T)console.info("\uD83D\uDCC8 [GLOBAL TIMESTAMP] Updated from full sync."),C=T,K.update(T)}else console.error("\u274C Full sync failed: received graph data is invalid.",k.graph)}};for(let k of $)if(p[k.type])await p[k.type](k);else console.warn(`\uD83E\uDD37\u200D\u2640\uFE0F [UNKNOWN MESSAGE TYPE] Received unhandled message type: "${k.type}"`);if(C){if(!L||K.compare(C,L)>0)console.info(`\uD83D\uDCC8 [GLOBAL TIMESTAMP] Advanced from ${L?.logical} to ${C.logical}.`),x(C)}if(I)console.info("\uD83D\uDCBE [STATE CHANGED] Saving state and emitting update."),await A1(),e()}Object.assign(j,{use($){if(typeof $==="function")S.push($)},async put($,I){const C=K.now();x(C),I??=crypto.randomUUID(),F.upsert(I,$,C),H.add({type:"upsert",id:I,timestamp:C}),N1();try{h.push({type:"upsert",id:I,value:$,timestamp:C}),U0().catch(()=>{})}finally{H0()}return I},async link($,I){const C=K.now();if(!F.nodes[$]||!F.nodes[I]){console.warn(`\u26A0\uFE0F One or both nodes (${$}, ${I}) do not exist.`);return}F.link($,I,C),H.add({type:"link",sourceId:$,targetId:I,timestamp:C}),N1(),x(C);try{h.push({type:"link",sourceId:$,targetId:I,timestamp:C}),U0().catch(()=>{})}finally{H0()}},async remove($){const I=K.now(),C=F.get($);if(!C)return console.warn(`\u26A0\uFE0F Node with ID '${$}' not found.`);delete F.nodes[$],H.add({type:"remove",id:$,timestamp:I}),Object.values(F.nodes).forEach((p)=>p.edges=p.edges.filter((k)=>k!==$)),N1(),x(I);try{h.push({type:"remove",id:$,value:C.value,timestamp:I}),U0().catch(()=>{})}finally{H0()}},async get($,I=null){if(typeof $!=="string")return{result:null};const C=F.get($);if(!C){if(I)I(null);return{result:null}}const p=(R)=>{if(!R)return null;const T=R.value!==null&&typeof R.value==="object"?{...R.value}:R.value;return{...R,value:T}};if(!I)return{result:p(C)};let k=C.timestamp;I(p(C));const D=(R)=>{const T=R[$];if(T){if(K.compare(T.timestamp,k)>0)k=T.timestamp,I(p(T))}else I(null),M.splice(M.indexOf(D),1)};return M.push(D),{result:p(C),unsubscribe:()=>{const R=M.indexOf(D);if(R>-1)M.splice(R,1)}}},async map(...$){let C={...{realtime:!1,query:{},field:null,order:"asc",$limit:null,$after:null,$before:null}},p=null,k=!1;$.forEach((E)=>typeof E==="function"?p=E:E&&typeof E==="object"&&(k||=("realtime"in E),Object.assign(C,E))),p&&!k&&(C.realtime=!0);let D=F8(F.nodes,C),R=null;const T=(E)=>{const c=new Map(D.map((m)=>[m.id,m])),u=new Map(E.map((m)=>[m.id,m])),r=[],w0=[],Z8=[];for(let[m,Y0]of u){const Y1=c.get(m);if(!Y1)r.push(Y0);else if((Y0.timestamp?.physical||0)!==(Y1.timestamp?.physical||0)||(Y0.timestamp?.logical||0)!==(Y1.timestamp?.logical||0)||!l6(Y0.edges||[],Y1.edges||[]))w0.push(Y0)}for(let[m]of c)if(!u.has(m))Z8.push(c.get(m));const S1=(m,Y0)=>p({id:m.id,value:Y0==="removed"?null:m.value,edges:m.edges||[],timestamp:m.timestamp||null,action:Y0});r.forEach((m)=>S1(m,"added")),Z8.forEach((m)=>S1(m,"removed")),w0.forEach((m)=>S1(m,"updated"))};if(p){if(D.forEach((E)=>{p({id:E.id,value:E.value,edges:E.edges,timestamp:E.timestamp,action:"initial"})}),C.realtime){const E=(c)=>{const u=c.timestamp?.physical||0,r=c.timestamp?.logical||0,w0=(c.edges||[]).join(",");return`${c.id}:${u}:${r}:${w0}`};R=(c)=>{const u=F8(c,C);if(u.length!==D.length)T(u),D=u;else{const r=u.map(E),w0=D.map(E);if(!l6(r,w0))T(u),D=u}},M.push(R)}}return{results:D,...C.realtime&&p&&R&&{unsubscribe:()=>{const E=M.indexOf(R);E>-1&&M.splice(E,1)}}}},async clear(){F.nodes={};try{await(await navigator.storage.getDirectory()).removeEntry(`${W}_graph.msgpack`)}catch({message:$}){console.warn(`\u26A0\uFE0F Error deleting _graph.msgpack: ${$}`)}e(),console.info("\u2705 All data has been deleted.")}}),N(),A(),await C7(),await k0();const $0=[];if(G)$0.push(v("sm",G));if(z)$0.push(v("AIQuery",z));if(U)$0.push(v("radixindex",U));if(Y)$0.push(v("invertedindex",Y));if(X)$0.push(v("audit",X));if(q)$0.push(v("geo",q));await Promise.all($0);const t6=`graph-sync-room-${W}`;if(J){const{join:$}=await v("genosrtc"),{relayUrls:I,turnConfig:C}=J?.constructor===Object?J:{},p={appId:"1234",...V&&{password:V}};if(I)p.relayUrls=I;if(C)p.turnConfig=C;const k=$(p,t6);O=k.channel("syncGraph"),y=$(p,`app-sync-${W}`),j.room=y,k.on("peer:join",async(R)=>{console.info("\u26A1 New peer connected:",R),O.send([{type:"sync",timestamp:L}])}),k.on("peer:leave",(R)=>{console.info("\u26A1 Peer disconnected:",R)});const D=(R,T)=>{const E=["id","sourceId","targetId"],c=new Set(R.flatMap((u)=>E.map((r)=>u[r]).filter(Boolean)));return new Map([...c].map((u)=>{const r=T.get(u);return r?[u,z8(r)]:null}).filter(Boolean))};O.on("message",async(R)=>{let T=R;const E=D(T,F);for(let c of S)try{if(T=await c(T,E),!T?.length)return}catch(u){console.error("\u274C GDB: Middleware error, discarding message.",u);return}await a6(T)})}return Z=new BroadcastChannel(`graphdb_sync_${W}`),Z.onmessage=async($)=>{if($.data==="update")console.info("\uD83D\uDD04 Update received from another tab..."),await k0(),A(),H0()},console.info(`\u2705 GenosDB [ \x1B[32m${W}\x1B[0m ] instance is ready.`),j}var z8=(W)=>{if(W===null||typeof W!=="object")return W;if(typeof structuredClone==="function")return structuredClone(W);return JSON.parse(JSON.stringify(W))},r6=(W,Q=16)=>{let J=null,V=null;return(...G)=>{if(!V)V={},V.promise=new Promise((Y,U)=>(V.resolve=Y,V.reject=U));if(J)("cancelIdleCallback"in window?cancelIdleCallback:clearTimeout)(J);const X=async()=>{J=null;try{V.resolve(await W(...G))}catch(Y){V.reject(Y)}finally{V=null}};return J=("requestIdleCallback"in window)?requestIdleCallback(X,{timeout:Q}):setTimeout(X,Q),V.promise}},j7=(W)=>{let Q=null;return()=>{if(Q!==null)return;Q=requestAnimationFrame(()=>{Q=null,W()})}};var jQ=n6;class M7{constructor(){throw new Error("\u26A0\uFE0F WARNING: `new GDB()` is deprecated and will be removed. "+"Migrate to async factory function `const db = await gdb(...)`.\nMigration Guide: https://github.com/estebanrfp/gdb/wiki/Migration-Guide\nWiki: https://github.com/estebanrfp/gdb/wiki")}}export{jQ as gdb,M7 as GDB};
