var e5=Object.defineProperty;var JG=(J,G)=>{for(var Q in G)e5(J,Q,{get:G[Q],enumerable:!0,configurable:!0,set:(q)=>G[Q]=()=>q})};function HQ(J){const G=J.length;let Q=0,q=0;while(q<G){let X=J.charCodeAt(q++);if((X&4294967168)===0){Q++;continue}else if((X&4294965248)===0)Q+=2;else{if(X>=55296&&X<=56319){if(q<G){const W=J.charCodeAt(q);if((W&64512)===56320)++q,X=((X&1023)<<10)+(W&1023)+65536}}if((X&4294901760)===0)Q+=3;else Q+=4}}return Q}function QG(J,G,Q){const q=J.length;let X=Q,W=0;while(W<q){let Y=J.charCodeAt(W++);if((Y&4294967168)===0){G[X++]=Y;continue}else if((Y&4294965248)===0)G[X++]=Y>>6&31|192;else{if(Y>=55296&&Y<=56319){if(W<q){const U=J.charCodeAt(W);if((U&64512)===56320)++W,Y=((Y&1023)<<10)+(U&1023)+65536}}if((Y&4294901760)===0)G[X++]=Y>>12&15|224,G[X++]=Y>>6&63|128;else G[X++]=Y>>18&7|240,G[X++]=Y>>12&63|128,G[X++]=Y>>6&63|128}G[X++]=Y&63|128}}function XG(J,G,Q){GG.encodeInto(J,G.subarray(Q))}function PQ(J,G,Q){if(J.length>qG)XG(J,G,Q);else QG(J,G,Q)}function r1(J,G,Q){let q=G;const X=q+Q,W=[];let Y="";while(q<X){const U=J[q++];if((U&128)===0)W.push(U);else if((U&224)===192){const K=J[q++]&63;W.push((U&31)<<6|K)}else if((U&240)===224){const K=J[q++]&63,V=J[q++]&63;W.push((U&31)<<12|K<<6|V)}else if((U&248)===240){const K=J[q++]&63,V=J[q++]&63,Z=J[q++]&63;let j=(U&7)<<18|K<<12|V<<6|Z;if(j>65535)j-=65536,W.push(j>>>10&1023|55296),j=56320|j&1023;W.push(j)}else W.push(U);if(W.length>=WG)Y+=String.fromCharCode(...W),W.length=0}if(W.length>0)Y+=String.fromCharCode(...W);return Y}function VG(J,G,Q){const q=J.subarray(G,G+Q);return YG.decode(q)}function CQ(J,G,Q){if(Q>UG)return VG(J,G,Q);else return r1(J,G,Q)}var GG=new TextEncoder,qG=50,WG=4096,YG=new TextDecoder,UG=200;class j8{constructor(J,G){this.type=J,this.data=G}}class q0 extends Error{constructor(J){super(J);const G=Object.create(q0.prototype);Object.setPrototypeOf(this,G),Object.defineProperty(this,"name",{configurable:!0,enumerable:!1,value:q0.name})}}function DQ(J,G,Q){const q=Q/4294967296,X=Q;J.setUint32(G,q),J.setUint32(G+4,X)}function U1(J,G,Q){const q=Math.floor(Q/4294967296),X=Q;J.setUint32(G,q),J.setUint32(G+4,X)}function V1(J,G){const Q=J.getInt32(G),q=J.getUint32(G+4);return Q*4294967296+q}function NQ(J,G){const Q=J.getUint32(G),q=J.getUint32(G+4);return Q*4294967296+q}var M8=4294967295;function zG({sec:J,nsec:G}){if(J>=0&&G>=0&&J<=$G)if(G===0&&J<=ZG){const Q=new Uint8Array(4);return new DataView(Q.buffer).setUint32(0,J),Q}else{const Q=J/4294967296,q=J&4294967295,X=new Uint8Array(8),W=new DataView(X.buffer);return W.setUint32(0,G<<2|Q&3),W.setUint32(4,q),X}else{const Q=new Uint8Array(12),q=new DataView(Q.buffer);return q.setUint32(0,G),U1(q,4,J),Q}}function jG(J){const G=J.getTime(),Q=Math.floor(G/1000),q=(G-Q*1000)*1e6,X=Math.floor(q/1e9);return{sec:Q+X,nsec:q-X*1e9}}function MG(J){if(J instanceof Date){const G=jG(J);return zG(G)}else return null}function HG(J){const G=new DataView(J.buffer,J.byteOffset,J.byteLength);switch(J.byteLength){case 4:return{sec:G.getUint32(0),nsec:0};case 8:{const Q=G.getUint32(0),q=G.getUint32(4),X=(Q&3)*4294967296+q,W=Q>>>2;return{sec:X,nsec:W}}case 12:{const Q=V1(G,4),q=G.getUint32(0);return{sec:Q,nsec:q}}default:throw new q0(`Unrecognized data size for timestamp (expected 4, 8, or 12): ${J.length}`)}}function PG(J){const G=HG(J);return new Date(G.sec*1000+G.nsec/1e6)}var KG=-1,ZG=4294967295,$G=17179869183,OQ={type:KG,encode:MG,decode:PG};class o0{constructor(){this.builtInEncoders=[],this.builtInDecoders=[],this.encoders=[],this.decoders=[],this.register(OQ)}register({type:J,encode:G,decode:Q}){if(J>=0)this.encoders[J]=G,this.decoders[J]=Q;else{const q=-1-J;this.builtInEncoders[q]=G,this.builtInDecoders[q]=Q}}tryToEncode(J,G){for(let Q=0;Q<this.builtInEncoders.length;Q++){const q=this.builtInEncoders[Q];if(q!=null){const X=q(J,G);if(X!=null){const W=-1-Q;return new j8(W,X)}}}for(let Q=0;Q<this.encoders.length;Q++){const q=this.encoders[Q];if(q!=null){const X=q(J,G);if(X!=null)return new j8(Q,X)}}if(J instanceof j8)return J;return null}decode(J,G,Q){const q=G<0?this.builtInDecoders[-1-G]:this.decoders[G];if(q)return q(J,G,Q);else return new j8(G,J)}}o0.defaultCodec=new o0;var CG=function(J){return J instanceof ArrayBuffer||typeof SharedArrayBuffer!=="undefined"&&J instanceof SharedArrayBuffer};function T8(J){if(J instanceof Uint8Array)return J;else if(ArrayBuffer.isView(J))return new Uint8Array(J.buffer,J.byteOffset,J.byteLength);else if(CG(J))return new Uint8Array(J);else return Uint8Array.from(J)}var DG=100,NG=2048;class K1{constructor(J){this.entered=!1,this.extensionCodec=J?.extensionCodec??o0.defaultCodec,this.context=J?.context,this.useBigInt64=J?.useBigInt64??!1,this.maxDepth=J?.maxDepth??DG,this.initialBufferSize=J?.initialBufferSize??NG,this.sortKeys=J?.sortKeys??!1,this.forceFloat32=J?.forceFloat32??!1,this.ignoreUndefined=J?.ignoreUndefined??!1,this.forceIntegerToFloat=J?.forceIntegerToFloat??!1,this.pos=0,this.view=new DataView(new ArrayBuffer(this.initialBufferSize)),this.bytes=new Uint8Array(this.view.buffer)}clone(){return new K1({extensionCodec:this.extensionCodec,context:this.context,useBigInt64:this.useBigInt64,maxDepth:this.maxDepth,initialBufferSize:this.initialBufferSize,sortKeys:this.sortKeys,forceFloat32:this.forceFloat32,ignoreUndefined:this.ignoreUndefined,forceIntegerToFloat:this.forceIntegerToFloat})}reinitializeState(){this.pos=0}encodeSharedRef(J){if(this.entered)return this.clone().encodeSharedRef(J);try{return this.entered=!0,this.reinitializeState(),this.doEncode(J,1),this.bytes.subarray(0,this.pos)}finally{this.entered=!1}}encode(J){if(this.entered)return this.clone().encode(J);try{return this.entered=!0,this.reinitializeState(),this.doEncode(J,1),this.bytes.slice(0,this.pos)}finally{this.entered=!1}}doEncode(J,G){if(G>this.maxDepth)throw new Error(`Too deep objects in depth ${G}`);if(J==null)this.encodeNil();else if(typeof J==="boolean")this.encodeBoolean(J);else if(typeof J==="number")if(!this.forceIntegerToFloat)this.encodeNumber(J);else this.encodeNumberAsFloat(J);else if(typeof J==="string")this.encodeString(J);else if(this.useBigInt64&&typeof J==="bigint")this.encodeBigInt64(J);else this.encodeObject(J,G)}ensureBufferSizeToWrite(J){const G=this.pos+J;if(this.view.byteLength<G)this.resizeBuffer(G*2)}resizeBuffer(J){const G=new ArrayBuffer(J),Q=new Uint8Array(G),q=new DataView(G);Q.set(this.bytes),this.view=q,this.bytes=Q}encodeNil(){this.writeU8(192)}encodeBoolean(J){if(J===!1)this.writeU8(194);else this.writeU8(195)}encodeNumber(J){if(!this.forceIntegerToFloat&&Number.isSafeInteger(J))if(J>=0)if(J<128)this.writeU8(J);else if(J<256)this.writeU8(204),this.writeU8(J);else if(J<65536)this.writeU8(205),this.writeU16(J);else if(J<4294967296)this.writeU8(206),this.writeU32(J);else if(!this.useBigInt64)this.writeU8(207),this.writeU64(J);else this.encodeNumberAsFloat(J);else if(J>=-32)this.writeU8(224|J+32);else if(J>=-128)this.writeU8(208),this.writeI8(J);else if(J>=-32768)this.writeU8(209),this.writeI16(J);else if(J>=-2147483648)this.writeU8(210),this.writeI32(J);else if(!this.useBigInt64)this.writeU8(211),this.writeI64(J);else this.encodeNumberAsFloat(J);else this.encodeNumberAsFloat(J)}encodeNumberAsFloat(J){if(this.forceFloat32)this.writeU8(202),this.writeF32(J);else this.writeU8(203),this.writeF64(J)}encodeBigInt64(J){if(J>=BigInt(0))this.writeU8(207),this.writeBigUint64(J);else this.writeU8(211),this.writeBigInt64(J)}writeStringHeader(J){if(J<32)this.writeU8(160+J);else if(J<256)this.writeU8(217),this.writeU8(J);else if(J<65536)this.writeU8(218),this.writeU16(J);else if(J<4294967296)this.writeU8(219),this.writeU32(J);else throw new Error(`Too long string: ${J} bytes in UTF-8`)}encodeString(J){const Q=HQ(J);this.ensureBufferSizeToWrite(5+Q),this.writeStringHeader(Q),PQ(J,this.bytes,this.pos),this.pos+=Q}encodeObject(J,G){const Q=this.extensionCodec.tryToEncode(J,this.context);if(Q!=null)this.encodeExtension(Q);else if(Array.isArray(J))this.encodeArray(J,G);else if(ArrayBuffer.isView(J))this.encodeBinary(J);else if(typeof J==="object")this.encodeMap(J,G);else throw new Error(`Unrecognized object: ${Object.prototype.toString.apply(J)}`)}encodeBinary(J){const G=J.byteLength;if(G<256)this.writeU8(196),this.writeU8(G);else if(G<65536)this.writeU8(197),this.writeU16(G);else if(G<4294967296)this.writeU8(198),this.writeU32(G);else throw new Error(`Too large binary: ${G}`);const Q=T8(J);this.writeU8a(Q)}encodeArray(J,G){const Q=J.length;if(Q<16)this.writeU8(144+Q);else if(Q<65536)this.writeU8(220),this.writeU16(Q);else if(Q<4294967296)this.writeU8(221),this.writeU32(Q);else throw new Error(`Too large array: ${Q}`);for(let q of J)this.doEncode(q,G+1)}countWithoutUndefined(J,G){let Q=0;for(let q of G)if(J[q]!==void 0)Q++;return Q}encodeMap(J,G){const Q=Object.keys(J);if(this.sortKeys)Q.sort();const q=this.ignoreUndefined?this.countWithoutUndefined(J,Q):Q.length;if(q<16)this.writeU8(128+q);else if(q<65536)this.writeU8(222),this.writeU16(q);else if(q<4294967296)this.writeU8(223),this.writeU32(q);else throw new Error(`Too large map object: ${q}`);for(let X of Q){const W=J[X];if(!(this.ignoreUndefined&&W===void 0))this.encodeString(X),this.doEncode(W,G+1)}}encodeExtension(J){if(typeof J.data==="function"){const Q=J.data(this.pos+6),q=Q.length;if(q>=4294967296)throw new Error(`Too large extension object: ${q}`);this.writeU8(201),this.writeU32(q),this.writeI8(J.type),this.writeU8a(Q);return}const G=J.data.length;if(G===1)this.writeU8(212);else if(G===2)this.writeU8(213);else if(G===4)this.writeU8(214);else if(G===8)this.writeU8(215);else if(G===16)this.writeU8(216);else if(G<256)this.writeU8(199),this.writeU8(G);else if(G<65536)this.writeU8(200),this.writeU16(G);else if(G<4294967296)this.writeU8(201),this.writeU32(G);else throw new Error(`Too large extension object: ${G}`);this.writeI8(J.type),this.writeU8a(J.data)}writeU8(J){this.ensureBufferSizeToWrite(1),this.view.setUint8(this.pos,J),this.pos++}writeU8a(J){const G=J.length;this.ensureBufferSizeToWrite(G),this.bytes.set(J,this.pos),this.pos+=G}writeI8(J){this.ensureBufferSizeToWrite(1),this.view.setInt8(this.pos,J),this.pos++}writeU16(J){this.ensureBufferSizeToWrite(2),this.view.setUint16(this.pos,J),this.pos+=2}writeI16(J){this.ensureBufferSizeToWrite(2),this.view.setInt16(this.pos,J),this.pos+=2}writeU32(J){this.ensureBufferSizeToWrite(4),this.view.setUint32(this.pos,J),this.pos+=4}writeI32(J){this.ensureBufferSizeToWrite(4),this.view.setInt32(this.pos,J),this.pos+=4}writeF32(J){this.ensureBufferSizeToWrite(4),this.view.setFloat32(this.pos,J),this.pos+=4}writeF64(J){this.ensureBufferSizeToWrite(8),this.view.setFloat64(this.pos,J),this.pos+=8}writeU64(J){this.ensureBufferSizeToWrite(8),DQ(this.view,this.pos,J),this.pos+=8}writeI64(J){this.ensureBufferSizeToWrite(8),U1(this.view,this.pos,J),this.pos+=8}writeBigUint64(J){this.ensureBufferSizeToWrite(8),this.view.setBigUint64(this.pos,J),this.pos+=8}writeBigInt64(J){this.ensureBufferSizeToWrite(8),this.view.setBigInt64(this.pos,J),this.pos+=8}}function E0(J,G){return new K1(G).encodeSharedRef(J)}function Z1(J){return`${J<0?"-":""}0x${Math.abs(J).toString(16).padStart(2,"0")}`}var OG=16,BG=16;class o1{constructor(J=OG,G=BG){this.hit=0,this.miss=0,this.maxKeyLength=J,this.maxLengthPerKey=G,this.caches=[];for(let Q=0;Q<this.maxKeyLength;Q++)this.caches.push([])}canBeCached(J){return J>0&&J<=this.maxKeyLength}find(J,G,Q){const q=this.caches[Q-1];J:for(let X of q){const W=X.bytes;for(let Y=0;Y<Q;Y++)if(W[Y]!==J[G+Y])continue J;return X.str}return null}store(J,G){const Q=this.caches[J.length-1],q={bytes:J,str:G};if(Q.length>=this.maxLengthPerKey)Q[Math.random()*Q.length|0]=q;else Q.push(q)}decode(J,G,Q){const q=this.find(J,G,Q);if(q!=null)return this.hit++,q;this.miss++;const X=r1(J,G,Q),W=Uint8Array.prototype.slice.call(J,G,G+Q);return this.store(W,X),X}}var n1="array",F8="map_key",LQ="map_value",LG=(J)=>{if(typeof J==="string"||typeof J==="number")return J;throw new q0("The type of key must be string or number but "+typeof J)};class AQ{constructor(){this.stack=[],this.stackHeadPosition=-1}get length(){return this.stackHeadPosition+1}top(){return this.stack[this.stackHeadPosition]}pushArrayState(J){const G=this.getUninitializedStateFromPool();G.type=n1,G.position=0,G.size=J,G.array=new Array(J)}pushMapState(J){const G=this.getUninitializedStateFromPool();G.type=F8,G.readCount=0,G.size=J,G.map={}}getUninitializedStateFromPool(){if(this.stackHeadPosition++,this.stackHeadPosition===this.stack.length){const J={type:void 0,size:0,array:void 0,position:0,readCount:0,map:void 0,key:null};this.stack.push(J)}return this.stack[this.stackHeadPosition]}release(J){if(this.stack[this.stackHeadPosition]!==J)throw new Error("Invalid stack state. Released state is not on top of the stack.");if(J.type===n1){const Q=J;Q.size=0,Q.array=void 0,Q.position=0,Q.type=void 0}if(J.type===F8||J.type===LQ){const Q=J;Q.size=0,Q.map=void 0,Q.readCount=0,Q.type=void 0}this.stackHeadPosition--}reset(){this.stack.length=0,this.stackHeadPosition=-1}}var S8=-1,a1=new DataView(new ArrayBuffer(0)),AG=new Uint8Array(a1.buffer);try{a1.getInt8(0)}catch(J){if(!(J instanceof RangeError))throw new Error("This module is not supported in the current JavaScript engine because DataView does not throw RangeError on out-of-bounds access")}var BQ=new RangeError("Insufficient data"),kG=new o1;class $1{constructor(J){this.totalPos=0,this.pos=0,this.view=a1,this.bytes=AG,this.headByte=S8,this.stack=new AQ,this.entered=!1,this.extensionCodec=J?.extensionCodec??o0.defaultCodec,this.context=J?.context,this.useBigInt64=J?.useBigInt64??!1,this.rawStrings=J?.rawStrings??!1,this.maxStrLength=J?.maxStrLength??M8,this.maxBinLength=J?.maxBinLength??M8,this.maxArrayLength=J?.maxArrayLength??M8,this.maxMapLength=J?.maxMapLength??M8,this.maxExtLength=J?.maxExtLength??M8,this.keyDecoder=J?.keyDecoder!==void 0?J.keyDecoder:kG,this.mapKeyConverter=J?.mapKeyConverter??LG}clone(){return new $1({extensionCodec:this.extensionCodec,context:this.context,useBigInt64:this.useBigInt64,rawStrings:this.rawStrings,maxStrLength:this.maxStrLength,maxBinLength:this.maxBinLength,maxArrayLength:this.maxArrayLength,maxMapLength:this.maxMapLength,maxExtLength:this.maxExtLength,keyDecoder:this.keyDecoder})}reinitializeState(){this.totalPos=0,this.headByte=S8,this.stack.reset()}setBuffer(J){const G=T8(J);this.bytes=G,this.view=new DataView(G.buffer,G.byteOffset,G.byteLength),this.pos=0}appendBuffer(J){if(this.headByte===S8&&!this.hasRemaining(1))this.setBuffer(J);else{const G=this.bytes.subarray(this.pos),Q=T8(J),q=new Uint8Array(G.length+Q.length);q.set(G),q.set(Q,G.length),this.setBuffer(q)}}hasRemaining(J){return this.view.byteLength-this.pos>=J}createExtraByteError(J){const{view:G,pos:Q}=this;return new RangeError(`Extra ${G.byteLength-Q} of ${G.byteLength} byte(s) found at buffer[${J}]`)}decode(J){if(this.entered)return this.clone().decode(J);try{this.entered=!0,this.reinitializeState(),this.setBuffer(J);const G=this.doDecodeSync();if(this.hasRemaining(1))throw this.createExtraByteError(this.pos);return G}finally{this.entered=!1}}*decodeMulti(J){if(this.entered){yield*this.clone().decodeMulti(J);return}try{this.entered=!0,this.reinitializeState(),this.setBuffer(J);while(this.hasRemaining(1))yield this.doDecodeSync()}finally{this.entered=!1}}async decodeAsync(J){if(this.entered)return this.clone().decodeAsync(J);try{this.entered=!0;let G=!1,Q;for await(let Y of J){if(G)throw this.entered=!1,this.createExtraByteError(this.totalPos);this.appendBuffer(Y);try{Q=this.doDecodeSync(),G=!0}catch(U){if(!(U instanceof RangeError))throw U}this.totalPos+=this.pos}if(G){if(this.hasRemaining(1))throw this.createExtraByteError(this.totalPos);return Q}const{headByte:q,pos:X,totalPos:W}=this;throw new RangeError(`Insufficient data in parsing ${Z1(q)} at ${W} (${X} in the current buffer)`)}finally{this.entered=!1}}decodeArrayStream(J){return this.decodeMultiAsync(J,!0)}decodeStream(J){return this.decodeMultiAsync(J,!1)}async*decodeMultiAsync(J,G){if(this.entered){yield*this.clone().decodeMultiAsync(J,G);return}try{this.entered=!0;let Q=G,q=-1;for await(let X of J){if(G&&q===0)throw this.createExtraByteError(this.totalPos);if(this.appendBuffer(X),Q)q=this.readArraySize(),Q=!1,this.complete();try{while(!0)if(yield this.doDecodeSync(),--q===0)break}catch(W){if(!(W instanceof RangeError))throw W}this.totalPos+=this.pos}}finally{this.entered=!1}}doDecodeSync(){J:while(!0){const J=this.readHeadByte();let G;if(J>=224)G=J-256;else if(J<192)if(J<128)G=J;else if(J<144){const q=J-128;if(q!==0){this.pushMapState(q),this.complete();continue J}else G={}}else if(J<160){const q=J-144;if(q!==0){this.pushArrayState(q),this.complete();continue J}else G=[]}else{const q=J-160;G=this.decodeString(q,0)}else if(J===192)G=null;else if(J===194)G=!1;else if(J===195)G=!0;else if(J===202)G=this.readF32();else if(J===203)G=this.readF64();else if(J===204)G=this.readU8();else if(J===205)G=this.readU16();else if(J===206)G=this.readU32();else if(J===207)if(this.useBigInt64)G=this.readU64AsBigInt();else G=this.readU64();else if(J===208)G=this.readI8();else if(J===209)G=this.readI16();else if(J===210)G=this.readI32();else if(J===211)if(this.useBigInt64)G=this.readI64AsBigInt();else G=this.readI64();else if(J===217){const q=this.lookU8();G=this.decodeString(q,1)}else if(J===218){const q=this.lookU16();G=this.decodeString(q,2)}else if(J===219){const q=this.lookU32();G=this.decodeString(q,4)}else if(J===220){const q=this.readU16();if(q!==0){this.pushArrayState(q),this.complete();continue J}else G=[]}else if(J===221){const q=this.readU32();if(q!==0){this.pushArrayState(q),this.complete();continue J}else G=[]}else if(J===222){const q=this.readU16();if(q!==0){this.pushMapState(q),this.complete();continue J}else G={}}else if(J===223){const q=this.readU32();if(q!==0){this.pushMapState(q),this.complete();continue J}else G={}}else if(J===196){const q=this.lookU8();G=this.decodeBinary(q,1)}else if(J===197){const q=this.lookU16();G=this.decodeBinary(q,2)}else if(J===198){const q=this.lookU32();G=this.decodeBinary(q,4)}else if(J===212)G=this.decodeExtension(1,0);else if(J===213)G=this.decodeExtension(2,0);else if(J===214)G=this.decodeExtension(4,0);else if(J===215)G=this.decodeExtension(8,0);else if(J===216)G=this.decodeExtension(16,0);else if(J===199){const q=this.lookU8();G=this.decodeExtension(q,1)}else if(J===200){const q=this.lookU16();G=this.decodeExtension(q,2)}else if(J===201){const q=this.lookU32();G=this.decodeExtension(q,4)}else throw new q0(`Unrecognized type byte: ${Z1(J)}`);this.complete();const Q=this.stack;while(Q.length>0){const q=Q.top();if(q.type===n1)if(q.array[q.position]=G,q.position++,q.position===q.size)G=q.array,Q.release(q);else continue J;else if(q.type===F8){if(G==="__proto__")throw new q0("The key __proto__ is not allowed");q.key=this.mapKeyConverter(G),q.type=LQ;continue J}else if(q.map[q.key]=G,q.readCount++,q.readCount===q.size)G=q.map,Q.release(q);else{q.key=null,q.type=F8;continue J}}return G}}readHeadByte(){if(this.headByte===S8)this.headByte=this.readU8();return this.headByte}complete(){this.headByte=S8}readArraySize(){const J=this.readHeadByte();switch(J){case 220:return this.readU16();case 221:return this.readU32();default:if(J<160)return J-144;else throw new q0(`Unrecognized array type byte: ${Z1(J)}`)}}pushMapState(J){if(J>this.maxMapLength)throw new q0(`Max length exceeded: map length (${J}) > maxMapLengthLength (${this.maxMapLength})`);this.stack.pushMapState(J)}pushArrayState(J){if(J>this.maxArrayLength)throw new q0(`Max length exceeded: array length (${J}) > maxArrayLength (${this.maxArrayLength})`);this.stack.pushArrayState(J)}decodeString(J,G){if(!this.rawStrings||this.stateIsMapKey())return this.decodeUtf8String(J,G);return this.decodeBinary(J,G)}decodeUtf8String(J,G){if(J>this.maxStrLength)throw new q0(`Max length exceeded: UTF-8 byte length (${J}) > maxStrLength (${this.maxStrLength})`);if(this.bytes.byteLength<this.pos+G+J)throw BQ;const Q=this.pos+G;let q;if(this.stateIsMapKey()&&this.keyDecoder?.canBeCached(J))q=this.keyDecoder.decode(this.bytes,Q,J);else q=CQ(this.bytes,Q,J);return this.pos+=G+J,q}stateIsMapKey(){if(this.stack.length>0)return this.stack.top().type===F8;return!1}decodeBinary(J,G){if(J>this.maxBinLength)throw new q0(`Max length exceeded: bin length (${J}) > maxBinLength (${this.maxBinLength})`);if(!this.hasRemaining(J+G))throw BQ;const Q=this.pos+G,q=this.bytes.subarray(Q,Q+J);return this.pos+=G+J,q}decodeExtension(J,G){if(J>this.maxExtLength)throw new q0(`Max length exceeded: ext length (${J}) > maxExtLength (${this.maxExtLength})`);const Q=this.view.getInt8(this.pos+G),q=this.decodeBinary(J,G+1);return this.extensionCodec.decode(q,Q,this.context)}lookU8(){return this.view.getUint8(this.pos)}lookU16(){return this.view.getUint16(this.pos)}lookU32(){return this.view.getUint32(this.pos)}readU8(){const J=this.view.getUint8(this.pos);return this.pos++,J}readI8(){const J=this.view.getInt8(this.pos);return this.pos++,J}readU16(){const J=this.view.getUint16(this.pos);return this.pos+=2,J}readI16(){const J=this.view.getInt16(this.pos);return this.pos+=2,J}readU32(){const J=this.view.getUint32(this.pos);return this.pos+=4,J}readI32(){const J=this.view.getInt32(this.pos);return this.pos+=4,J}readU64(){const J=NQ(this.view,this.pos);return this.pos+=8,J}readI64(){const J=V1(this.view,this.pos);return this.pos+=8,J}readU64AsBigInt(){const J=this.view.getBigUint64(this.pos);return this.pos+=8,J}readI64AsBigInt(){const J=this.view.getBigInt64(this.pos);return this.pos+=8,J}readF32(){const J=this.view.getFloat32(this.pos);return this.pos+=4,J}readF64(){const J=this.view.getFloat64(this.pos);return this.pos+=8,J}}function s1(J,G){return new $1(G).decode(J)}var O8=function(J){let G=J.length;while(--G>=0)J[G]=0},e1=function(J,G,Q,q,X){this.static_tree=J,this.extra_bits=G,this.extra_base=Q,this.elems=q,this.max_length=X,this.has_stree=J&&J.length},JJ=function(J,G){this.dyn_tree=J,this.max_code=0,this.stat_desc=G},D0=function(J,G,Q,q,X){this.good_length=J,this.max_lazy=G,this.nice_length=Q,this.max_chain=q,this.func=X},Iq=function(){this.strm=null,this.status=0,this.pending_buf=null,this.pending_buf_size=0,this.pending_out=0,this.pending=0,this.wrap=0,this.gzhead=null,this.gzindex=0,this.method=B1,this.last_flush=-1,this.w_size=0,this.w_bits=0,this.w_mask=0,this.window=null,this.window_size=0,this.prev=null,this.head=null,this.ins_h=0,this.hash_size=0,this.hash_bits=0,this.hash_mask=0,this.hash_shift=0,this.block_start=0,this.match_length=0,this.prev_match=0,this.match_available=0,this.strstart=0,this.match_start=0,this.lookahead=0,this.prev_length=0,this.max_chain_length=0,this.max_lazy_match=0,this.level=0,this.strategy=0,this.good_match=0,this.nice_match=0,this.dyn_ltree=new Uint16Array(Cq*2),this.dyn_dtree=new Uint16Array((2*Hq+1)*2),this.bl_tree=new Uint16Array((2*Pq+1)*2),y0(this.dyn_ltree),y0(this.dyn_dtree),y0(this.bl_tree),this.l_desc=null,this.d_desc=null,this.bl_desc=null,this.bl_count=new Uint16Array(Dq+1),this.heap=new Uint16Array(2*HJ+1),y0(this.heap),this.heap_len=0,this.heap_max=0,this.depth=new Uint16Array(2*HJ+1),y0(this.depth),this.sym_buf=0,this.lit_bufsize=0,this.sym_next=0,this.sym_end=0,this.opt_len=0,this.static_len=0,this.matches=0,this.insert=0,this.bi_buf=0,this.bi_valid=0},oq=function(){this.input=null,this.next_in=0,this.avail_in=0,this.total_in=0,this.output=null,this.next_out=0,this.avail_out=0,this.total_out=0,this.msg="",this.state=null,this.data_type=2,this.adler=0},o8=function(J){this.options=L1.assign({level:J6,method:G6,chunkSize:16384,windowBits:15,memLevel:8,strategy:Q6},J||{});let G=this.options;if(G.raw&&G.windowBits>0)G.windowBits=-G.windowBits;else if(G.gzip&&G.windowBits>0&&G.windowBits<16)G.windowBits+=16;this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new T9,this.strm.avail_out=0;let Q=f8.deflateInit2(this.strm,G.level,G.method,G.windowBits,G.memLevel,G.strategy);if(Q!==N1)throw new Error(t0[Q]);if(G.header)f8.deflateSetHeader(this.strm,G.header);if(G.dictionary){let q;if(typeof G.dictionary==="string")q=l8.string2buf(G.dictionary);else if(S9.call(G.dictionary)==="[object ArrayBuffer]")q=new Uint8Array(G.dictionary);else q=G.dictionary;if(Q=f8.deflateSetDictionary(this.strm,q),Q!==N1)throw new Error(t0[Q]);this._dict_set=!0}},IJ=function(J,G){const Q=new o8(G);if(Q.push(J,!0),Q.err)throw Q.msg||t0[Q.err];return Q.result},q6=function(J,G){return G=G||{},G.raw=!0,IJ(J,G)},X6=function(J,G){return G=G||{},G.gzip=!0,IJ(J,G)},w6=function(){this.strm=null,this.mode=0,this.last=!1,this.wrap=0,this.havedict=!1,this.flags=0,this.dmax=0,this.check=0,this.total=0,this.head=null,this.wbits=0,this.wsize=0,this.whave=0,this.wnext=0,this.window=null,this.hold=0,this.bits=0,this.length=0,this.offset=0,this.extra=0,this.lencode=null,this.distcode=null,this.lenbits=0,this.distbits=0,this.ncode=0,this.nlen=0,this.ndist=0,this.have=0,this.next=null,this.lens=new Uint16Array(320),this.work=new Uint16Array(288),this.lendyn=null,this.distdyn=null,this.sane=0,this.back=0,this.was=0},l6=function(){this.text=0,this.time=0,this.xflags=0,this.os=0,this.extra=null,this.extra_len=0,this.name="",this.comment="",this.hcrc=0,this.done=!1},n8=function(J){this.options=L1.assign({chunkSize:65536,windowBits:15,to:""},J||{});const G=this.options;if(G.raw&&G.windowBits>=0&&G.windowBits<16){if(G.windowBits=-G.windowBits,G.windowBits===0)G.windowBits=-15}if(G.windowBits>=0&&G.windowBits<16&&!(J&&J.windowBits))G.windowBits+=32;if(G.windowBits>15&&G.windowBits<48){if((G.windowBits&15)===0)G.windowBits|=15}this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new T9,this.strm.avail_out=0;let Q=x0.inflateInit2(this.strm,G.windowBits);if(Q!==d8)throw new Error(t0[Q]);if(this.header=new d6,x0.inflateGetHeader(this.strm,this.header),G.dictionary){if(typeof G.dictionary==="string")G.dictionary=l8.string2buf(G.dictionary);else if(c9.call(G.dictionary)==="[object ArrayBuffer]")G.dictionary=new Uint8Array(G.dictionary);if(G.raw){if(Q=x0.inflateSetDictionary(this.strm,G.dictionary),Q!==d8)throw new Error(t0[Q])}}},wJ=function(J,G){const Q=new n8(G);if(Q.push(J),Q.err)throw Q.msg||t0[Q.err];return Q.result},a6=function(J,G){return G=G||{},G.raw=!0,wJ(J,G)};/*! pako 2.1.0 https://github.com/nodeca/pako @license (MIT AND Zlib) */var RG=0,V9=1,IG=2,wG=3,xG=258,BJ=29,i8=256,h8=i8+1+BJ,C8=30,LJ=19,K9=2*h8+1,n0=15,t1=16,TG=7,AJ=256,Z9=16,$9=17,z9=18,zJ=new Uint8Array([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0]),C1=new Uint8Array([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13]),SG=new Uint8Array([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7]),j9=new Uint8Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),FG=512,w0=new Array((h8+2)*2);O8(w0);var y8=new Array(C8*2);O8(y8);var m8=new Array(FG);O8(m8);var _8=new Array(xG-wG+1);O8(_8);var kJ=new Array(BJ);O8(kJ);var D1=new Array(C8);O8(D1);var M9,H9,P9,C9=(J)=>{return J<256?m8[J]:m8[256+(J>>>7)]},u8=(J,G)=>{J.pending_buf[J.pending++]=G&255,J.pending_buf[J.pending++]=G>>>8&255},W0=(J,G,Q)=>{if(J.bi_valid>t1-Q)J.bi_buf|=G<<J.bi_valid&65535,u8(J,J.bi_buf),J.bi_buf=G>>t1-J.bi_valid,J.bi_valid+=Q-t1;else J.bi_buf|=G<<J.bi_valid&65535,J.bi_valid+=Q},N0=(J,G,Q)=>{W0(J,Q[G*2],Q[G*2+1])},D9=(J,G)=>{let Q=0;do Q|=J&1,J>>>=1,Q<<=1;while(--G>0);return Q>>>1},vG=(J)=>{if(J.bi_valid===16)u8(J,J.bi_buf),J.bi_buf=0,J.bi_valid=0;else if(J.bi_valid>=8)J.pending_buf[J.pending++]=J.bi_buf&255,J.bi_buf>>=8,J.bi_valid-=8},gG=(J,G)=>{const{dyn_tree:Q,max_code:q}=G,X=G.stat_desc.static_tree,W=G.stat_desc.has_stree,Y=G.stat_desc.extra_bits,U=G.stat_desc.extra_base,K=G.stat_desc.max_length;let V,Z,j,z,$,N,M=0;for(z=0;z<=n0;z++)J.bl_count[z]=0;Q[J.heap[J.heap_max]*2+1]=0;for(V=J.heap_max+1;V<K9;V++){if(Z=J.heap[V],z=Q[Q[Z*2+1]*2+1]+1,z>K)z=K,M++;if(Q[Z*2+1]=z,Z>q)continue;if(J.bl_count[z]++,$=0,Z>=U)$=Y[Z-U];if(N=Q[Z*2],J.opt_len+=N*(z+$),W)J.static_len+=N*(X[Z*2+1]+$)}if(M===0)return;do{z=K-1;while(J.bl_count[z]===0)z--;J.bl_count[z]--,J.bl_count[z+1]+=2,J.bl_count[K]--,M-=2}while(M>0);for(z=K;z!==0;z--){Z=J.bl_count[z];while(Z!==0){if(j=J.heap[--V],j>q)continue;if(Q[j*2+1]!==z)J.opt_len+=(z-Q[j*2+1])*Q[j*2],Q[j*2+1]=z;Z--}}},N9=(J,G,Q)=>{const q=new Array(n0+1);let X=0,W,Y;for(W=1;W<=n0;W++)X=X+Q[W-1]<<1,q[W]=X;for(Y=0;Y<=G;Y++){let U=J[Y*2+1];if(U===0)continue;J[Y*2]=D9(q[U]++,U)}},EG=()=>{let J,G,Q,q,X;const W=new Array(n0+1);Q=0;for(q=0;q<BJ-1;q++){kJ[q]=Q;for(J=0;J<1<<zJ[q];J++)_8[Q++]=q}_8[Q-1]=q,X=0;for(q=0;q<16;q++){D1[q]=X;for(J=0;J<1<<C1[q];J++)m8[X++]=q}X>>=7;for(;q<C8;q++){D1[q]=X<<7;for(J=0;J<1<<C1[q]-7;J++)m8[256+X++]=q}for(G=0;G<=n0;G++)W[G]=0;J=0;while(J<=143)w0[J*2+1]=8,J++,W[8]++;while(J<=255)w0[J*2+1]=9,J++,W[9]++;while(J<=279)w0[J*2+1]=7,J++,W[7]++;while(J<=287)w0[J*2+1]=8,J++,W[8]++;N9(w0,h8+1,W);for(J=0;J<C8;J++)y8[J*2+1]=5,y8[J*2]=D9(J,5);M9=new e1(w0,zJ,i8+1,h8,n0),H9=new e1(y8,C1,0,C8,n0),P9=new e1(new Array(0),SG,0,LJ,TG)},O9=(J)=>{let G;for(G=0;G<h8;G++)J.dyn_ltree[G*2]=0;for(G=0;G<C8;G++)J.dyn_dtree[G*2]=0;for(G=0;G<LJ;G++)J.bl_tree[G*2]=0;J.dyn_ltree[AJ*2]=1,J.opt_len=J.static_len=0,J.sym_next=J.matches=0},B9=(J)=>{if(J.bi_valid>8)u8(J,J.bi_buf);else if(J.bi_valid>0)J.pending_buf[J.pending++]=J.bi_buf;J.bi_buf=0,J.bi_valid=0},kQ=(J,G,Q,q)=>{const X=G*2,W=Q*2;return J[X]<J[W]||J[X]===J[W]&&q[G]<=q[Q]},QJ=(J,G,Q)=>{const q=J.heap[Q];let X=Q<<1;while(X<=J.heap_len){if(X<J.heap_len&&kQ(G,J.heap[X+1],J.heap[X],J.depth))X++;if(kQ(G,q,J.heap[X],J.depth))break;J.heap[Q]=J.heap[X],Q=X,X<<=1}J.heap[Q]=q},RQ=(J,G,Q)=>{let q,X,W=0,Y,U;if(J.sym_next!==0)do if(q=J.pending_buf[J.sym_buf+W++]&255,q+=(J.pending_buf[J.sym_buf+W++]&255)<<8,X=J.pending_buf[J.sym_buf+W++],q===0)N0(J,X,G);else{if(Y=_8[X],N0(J,Y+i8+1,G),U=zJ[Y],U!==0)X-=kJ[Y],W0(J,X,U);if(q--,Y=C9(q),N0(J,Y,Q),U=C1[Y],U!==0)q-=D1[Y],W0(J,q,U)}while(W<J.sym_next);N0(J,AJ,G)},jJ=(J,G)=>{const Q=G.dyn_tree,q=G.stat_desc.static_tree,X=G.stat_desc.has_stree,W=G.stat_desc.elems;let Y,U,K=-1,V;J.heap_len=0,J.heap_max=K9;for(Y=0;Y<W;Y++)if(Q[Y*2]!==0)J.heap[++J.heap_len]=K=Y,J.depth[Y]=0;else Q[Y*2+1]=0;while(J.heap_len<2)if(V=J.heap[++J.heap_len]=K<2?++K:0,Q[V*2]=1,J.depth[V]=0,J.opt_len--,X)J.static_len-=q[V*2+1];G.max_code=K;for(Y=J.heap_len>>1;Y>=1;Y--)QJ(J,Q,Y);V=W;do Y=J.heap[1],J.heap[1]=J.heap[J.heap_len--],QJ(J,Q,1),U=J.heap[1],J.heap[--J.heap_max]=Y,J.heap[--J.heap_max]=U,Q[V*2]=Q[Y*2]+Q[U*2],J.depth[V]=(J.depth[Y]>=J.depth[U]?J.depth[Y]:J.depth[U])+1,Q[Y*2+1]=Q[U*2+1]=V,J.heap[1]=V++,QJ(J,Q,1);while(J.heap_len>=2);J.heap[--J.heap_max]=J.heap[1],gG(J,G),N9(Q,K,J.bl_count)},IQ=(J,G,Q)=>{let q,X=-1,W,Y=G[1],U=0,K=7,V=4;if(Y===0)K=138,V=3;G[(Q+1)*2+1]=65535;for(q=0;q<=Q;q++){if(W=Y,Y=G[(q+1)*2+1],++U<K&&W===Y)continue;else if(U<V)J.bl_tree[W*2]+=U;else if(W!==0){if(W!==X)J.bl_tree[W*2]++;J.bl_tree[Z9*2]++}else if(U<=10)J.bl_tree[$9*2]++;else J.bl_tree[z9*2]++;if(U=0,X=W,Y===0)K=138,V=3;else if(W===Y)K=6,V=3;else K=7,V=4}},wQ=(J,G,Q)=>{let q,X=-1,W,Y=G[1],U=0,K=7,V=4;if(Y===0)K=138,V=3;for(q=0;q<=Q;q++){if(W=Y,Y=G[(q+1)*2+1],++U<K&&W===Y)continue;else if(U<V)do N0(J,W,J.bl_tree);while(--U!==0);else if(W!==0){if(W!==X)N0(J,W,J.bl_tree),U--;N0(J,Z9,J.bl_tree),W0(J,U-3,2)}else if(U<=10)N0(J,$9,J.bl_tree),W0(J,U-3,3);else N0(J,z9,J.bl_tree),W0(J,U-11,7);if(U=0,X=W,Y===0)K=138,V=3;else if(W===Y)K=6,V=3;else K=7,V=4}},yG=(J)=>{let G;IQ(J,J.dyn_ltree,J.l_desc.max_code),IQ(J,J.dyn_dtree,J.d_desc.max_code),jJ(J,J.bl_desc);for(G=LJ-1;G>=3;G--)if(J.bl_tree[j9[G]*2+1]!==0)break;return J.opt_len+=3*(G+1)+5+5+4,G},fG=(J,G,Q,q)=>{let X;W0(J,G-257,5),W0(J,Q-1,5),W0(J,q-4,4);for(X=0;X<q;X++)W0(J,J.bl_tree[j9[X]*2+1],3);wQ(J,J.dyn_ltree,G-1),wQ(J,J.dyn_dtree,Q-1)},bG=(J)=>{let G=4093624447,Q;for(Q=0;Q<=31;Q++,G>>>=1)if(G&1&&J.dyn_ltree[Q*2]!==0)return 0;if(J.dyn_ltree[18]!==0||J.dyn_ltree[20]!==0||J.dyn_ltree[26]!==0)return 1;for(Q=32;Q<i8;Q++)if(J.dyn_ltree[Q*2]!==0)return 1;return 0},xQ=!1,hG=(J)=>{if(!xQ)EG(),xQ=!0;J.l_desc=new JJ(J.dyn_ltree,M9),J.d_desc=new JJ(J.dyn_dtree,H9),J.bl_desc=new JJ(J.bl_tree,P9),J.bi_buf=0,J.bi_valid=0,O9(J)},L9=(J,G,Q,q)=>{if(W0(J,(RG<<1)+(q?1:0),3),B9(J),u8(J,Q),u8(J,~Q),Q)J.pending_buf.set(J.window.subarray(G,G+Q),J.pending);J.pending+=Q},mG=(J)=>{W0(J,V9<<1,3),N0(J,AJ,w0),vG(J)},_G=(J,G,Q,q)=>{let X,W,Y=0;if(J.level>0){if(J.strm.data_type===2)J.strm.data_type=bG(J);if(jJ(J,J.l_desc),jJ(J,J.d_desc),Y=yG(J),X=J.opt_len+3+7>>>3,W=J.static_len+3+7>>>3,W<=X)X=W}else X=W=Q+5;if(Q+4<=X&&G!==-1)L9(J,G,Q,q);else if(J.strategy===4||W===X)W0(J,(V9<<1)+(q?1:0),3),RQ(J,w0,y8);else W0(J,(IG<<1)+(q?1:0),3),fG(J,J.l_desc.max_code+1,J.d_desc.max_code+1,Y+1),RQ(J,J.dyn_ltree,J.dyn_dtree);if(O9(J),q)B9(J)},uG=(J,G,Q)=>{if(J.pending_buf[J.sym_buf+J.sym_next++]=G,J.pending_buf[J.sym_buf+J.sym_next++]=G>>8,J.pending_buf[J.sym_buf+J.sym_next++]=Q,G===0)J.dyn_ltree[Q*2]++;else J.matches++,G--,J.dyn_ltree[(_8[Q]+i8+1)*2]++,J.dyn_dtree[C9(G)*2]++;return J.sym_next===J.sym_end},cG=hG,pG=L9,lG=_G,dG=uG,iG=mG,rG={_tr_init:cG,_tr_stored_block:pG,_tr_flush_block:lG,_tr_tally:dG,_tr_align:iG},oG=(J,G,Q,q)=>{let X=J&65535|0,W=J>>>16&65535|0,Y=0;while(Q!==0){Y=Q>2000?2000:Q,Q-=Y;do X=X+G[q++]|0,W=W+X|0;while(--Y);X%=65521,W%=65521}return X|W<<16|0},c8=oG,nG=()=>{let J,G=[];for(var Q=0;Q<256;Q++){J=Q;for(var q=0;q<8;q++)J=J&1?3988292384^J>>>1:J>>>1;G[Q]=J}return G},aG=new Uint32Array(nG()),sG=(J,G,Q,q)=>{const X=aG,W=q+Q;J^=-1;for(let Y=q;Y<W;Y++)J=J>>>8^X[(J^G[Y])&255];return J^-1},t=sG,t0={2:"need dictionary",1:"stream end",0:"","-1":"file error","-2":"stream error","-3":"data error","-4":"insufficient memory","-5":"buffer error","-6":"incompatible version"},Q8={Z_NO_FLUSH:0,Z_PARTIAL_FLUSH:1,Z_SYNC_FLUSH:2,Z_FULL_FLUSH:3,Z_FINISH:4,Z_BLOCK:5,Z_TREES:6,Z_OK:0,Z_STREAM_END:1,Z_NEED_DICT:2,Z_ERRNO:-1,Z_STREAM_ERROR:-2,Z_DATA_ERROR:-3,Z_MEM_ERROR:-4,Z_BUF_ERROR:-5,Z_NO_COMPRESSION:0,Z_BEST_SPEED:1,Z_BEST_COMPRESSION:9,Z_DEFAULT_COMPRESSION:-1,Z_FILTERED:1,Z_HUFFMAN_ONLY:2,Z_RLE:3,Z_FIXED:4,Z_DEFAULT_STRATEGY:0,Z_BINARY:0,Z_TEXT:1,Z_UNKNOWN:2,Z_DEFLATED:8},{_tr_init:tG,_tr_stored_block:MJ,_tr_flush_block:eG,_tr_tally:b0,_tr_align:Jq}=rG,{Z_NO_FLUSH:h0,Z_PARTIAL_FLUSH:Qq,Z_FULL_FLUSH:Gq,Z_FINISH:$0,Z_BLOCK:TQ,Z_OK:Q0,Z_STREAM_END:SQ,Z_STREAM_ERROR:O0,Z_DATA_ERROR:qq,Z_BUF_ERROR:GJ,Z_DEFAULT_COMPRESSION:Xq,Z_FILTERED:Wq,Z_HUFFMAN_ONLY:z1,Z_RLE:Yq,Z_FIXED:Uq,Z_DEFAULT_STRATEGY:Vq,Z_UNKNOWN:Kq,Z_DEFLATED:B1}=Q8,Zq=9,$q=15,zq=8,jq=29,Mq=256,HJ=Mq+1+jq,Hq=30,Pq=19,Cq=2*HJ+1,Dq=15,b=3,f0=258,B0=f0+b+1,Nq=32,D8=42,RJ=57,PJ=69,CJ=73,DJ=91,NJ=103,a0=113,g8=666,X0=1,B8=2,e0=3,L8=4,Oq=3,s0=(J,G)=>{return J.msg=t0[G],G},FQ=(J)=>{return J*2-(J>4?9:0)},y0=(J)=>{let G=J.length;while(--G>=0)J[G]=0},Bq=(J)=>{let G,Q,q,X=J.w_size;G=J.hash_size,q=G;do Q=J.head[--q],J.head[q]=Q>=X?Q-X:0;while(--G);G=X,q=G;do Q=J.prev[--q],J.prev[q]=Q>=X?Q-X:0;while(--G)},Lq=(J,G,Q)=>(G<<J.hash_shift^Q)&J.hash_mask,m0=Lq,V0=(J)=>{const G=J.state;let Q=G.pending;if(Q>J.avail_out)Q=J.avail_out;if(Q===0)return;if(J.output.set(G.pending_buf.subarray(G.pending_out,G.pending_out+Q),J.next_out),J.next_out+=Q,G.pending_out+=Q,J.total_out+=Q,J.avail_out-=Q,G.pending-=Q,G.pending===0)G.pending_out=0},K0=(J,G)=>{eG(J,J.block_start>=0?J.block_start:-1,J.strstart-J.block_start,G),J.block_start=J.strstart,V0(J.strm)},h=(J,G)=>{J.pending_buf[J.pending++]=G},v8=(J,G)=>{J.pending_buf[J.pending++]=G>>>8&255,J.pending_buf[J.pending++]=G&255},OJ=(J,G,Q,q)=>{let X=J.avail_in;if(X>q)X=q;if(X===0)return 0;if(J.avail_in-=X,G.set(J.input.subarray(J.next_in,J.next_in+X),Q),J.state.wrap===1)J.adler=c8(J.adler,G,X,Q);else if(J.state.wrap===2)J.adler=t(J.adler,G,X,Q);return J.next_in+=X,J.total_in+=X,X},A9=(J,G)=>{let{max_chain_length:Q,strstart:q}=J,X,W,Y=J.prev_length,U=J.nice_match;const K=J.strstart>J.w_size-B0?J.strstart-(J.w_size-B0):0,V=J.window,Z=J.w_mask,j=J.prev,z=J.strstart+f0;let $=V[q+Y-1],N=V[q+Y];if(J.prev_length>=J.good_match)Q>>=2;if(U>J.lookahead)U=J.lookahead;do{if(X=G,V[X+Y]!==N||V[X+Y-1]!==$||V[X]!==V[q]||V[++X]!==V[q+1])continue;q+=2,X++;do;while(V[++q]===V[++X]&&V[++q]===V[++X]&&V[++q]===V[++X]&&V[++q]===V[++X]&&V[++q]===V[++X]&&V[++q]===V[++X]&&V[++q]===V[++X]&&V[++q]===V[++X]&&q<z);if(W=f0-(z-q),q=z-f0,W>Y){if(J.match_start=G,Y=W,W>=U)break;$=V[q+Y-1],N=V[q+Y]}}while((G=j[G&Z])>K&&--Q!==0);if(Y<=J.lookahead)return Y;return J.lookahead},N8=(J)=>{const G=J.w_size;let Q,q,X;do{if(q=J.window_size-J.lookahead-J.strstart,J.strstart>=G+(G-B0)){if(J.window.set(J.window.subarray(G,G+G-q),0),J.match_start-=G,J.strstart-=G,J.block_start-=G,J.insert>J.strstart)J.insert=J.strstart;Bq(J),q+=G}if(J.strm.avail_in===0)break;if(Q=OJ(J.strm,J.window,J.strstart+J.lookahead,q),J.lookahead+=Q,J.lookahead+J.insert>=b){X=J.strstart-J.insert,J.ins_h=J.window[X],J.ins_h=m0(J,J.ins_h,J.window[X+1]);while(J.insert)if(J.ins_h=m0(J,J.ins_h,J.window[X+b-1]),J.prev[X&J.w_mask]=J.head[J.ins_h],J.head[J.ins_h]=X,X++,J.insert--,J.lookahead+J.insert<b)break}}while(J.lookahead<B0&&J.strm.avail_in!==0)},k9=(J,G)=>{let Q=J.pending_buf_size-5>J.w_size?J.w_size:J.pending_buf_size-5,q,X,W,Y=0,U=J.strm.avail_in;do{if(q=65535,W=J.bi_valid+42>>3,J.strm.avail_out<W)break;if(W=J.strm.avail_out-W,X=J.strstart-J.block_start,q>X+J.strm.avail_in)q=X+J.strm.avail_in;if(q>W)q=W;if(q<Q&&(q===0&&G!==$0||G===h0||q!==X+J.strm.avail_in))break;if(Y=G===$0&&q===X+J.strm.avail_in?1:0,MJ(J,0,0,Y),J.pending_buf[J.pending-4]=q,J.pending_buf[J.pending-3]=q>>8,J.pending_buf[J.pending-2]=~q,J.pending_buf[J.pending-1]=~q>>8,V0(J.strm),X){if(X>q)X=q;J.strm.output.set(J.window.subarray(J.block_start,J.block_start+X),J.strm.next_out),J.strm.next_out+=X,J.strm.avail_out-=X,J.strm.total_out+=X,J.block_start+=X,q-=X}if(q)OJ(J.strm,J.strm.output,J.strm.next_out,q),J.strm.next_out+=q,J.strm.avail_out-=q,J.strm.total_out+=q}while(Y===0);if(U-=J.strm.avail_in,U){if(U>=J.w_size)J.matches=2,J.window.set(J.strm.input.subarray(J.strm.next_in-J.w_size,J.strm.next_in),0),J.strstart=J.w_size,J.insert=J.strstart;else{if(J.window_size-J.strstart<=U){if(J.strstart-=J.w_size,J.window.set(J.window.subarray(J.w_size,J.w_size+J.strstart),0),J.matches<2)J.matches++;if(J.insert>J.strstart)J.insert=J.strstart}J.window.set(J.strm.input.subarray(J.strm.next_in-U,J.strm.next_in),J.strstart),J.strstart+=U,J.insert+=U>J.w_size-J.insert?J.w_size-J.insert:U}J.block_start=J.strstart}if(J.high_water<J.strstart)J.high_water=J.strstart;if(Y)return L8;if(G!==h0&&G!==$0&&J.strm.avail_in===0&&J.strstart===J.block_start)return B8;if(W=J.window_size-J.strstart,J.strm.avail_in>W&&J.block_start>=J.w_size){if(J.block_start-=J.w_size,J.strstart-=J.w_size,J.window.set(J.window.subarray(J.w_size,J.w_size+J.strstart),0),J.matches<2)J.matches++;if(W+=J.w_size,J.insert>J.strstart)J.insert=J.strstart}if(W>J.strm.avail_in)W=J.strm.avail_in;if(W)OJ(J.strm,J.window,J.strstart,W),J.strstart+=W,J.insert+=W>J.w_size-J.insert?J.w_size-J.insert:W;if(J.high_water<J.strstart)J.high_water=J.strstart;if(W=J.bi_valid+42>>3,W=J.pending_buf_size-W>65535?65535:J.pending_buf_size-W,Q=W>J.w_size?J.w_size:W,X=J.strstart-J.block_start,X>=Q||(X||G===$0)&&G!==h0&&J.strm.avail_in===0&&X<=W)q=X>W?W:X,Y=G===$0&&J.strm.avail_in===0&&q===X?1:0,MJ(J,J.block_start,q,Y),J.block_start+=q,V0(J.strm);return Y?e0:X0},qJ=(J,G)=>{let Q,q;for(;;){if(J.lookahead<B0){if(N8(J),J.lookahead<B0&&G===h0)return X0;if(J.lookahead===0)break}if(Q=0,J.lookahead>=b)J.ins_h=m0(J,J.ins_h,J.window[J.strstart+b-1]),Q=J.prev[J.strstart&J.w_mask]=J.head[J.ins_h],J.head[J.ins_h]=J.strstart;if(Q!==0&&J.strstart-Q<=J.w_size-B0)J.match_length=A9(J,Q);if(J.match_length>=b)if(q=b0(J,J.strstart-J.match_start,J.match_length-b),J.lookahead-=J.match_length,J.match_length<=J.max_lazy_match&&J.lookahead>=b){J.match_length--;do J.strstart++,J.ins_h=m0(J,J.ins_h,J.window[J.strstart+b-1]),Q=J.prev[J.strstart&J.w_mask]=J.head[J.ins_h],J.head[J.ins_h]=J.strstart;while(--J.match_length!==0);J.strstart++}else J.strstart+=J.match_length,J.match_length=0,J.ins_h=J.window[J.strstart],J.ins_h=m0(J,J.ins_h,J.window[J.strstart+1]);else q=b0(J,0,J.window[J.strstart]),J.lookahead--,J.strstart++;if(q){if(K0(J,!1),J.strm.avail_out===0)return X0}}if(J.insert=J.strstart<b-1?J.strstart:b-1,G===$0){if(K0(J,!0),J.strm.avail_out===0)return e0;return L8}if(J.sym_next){if(K0(J,!1),J.strm.avail_out===0)return X0}return B8},H8=(J,G)=>{let Q,q,X;for(;;){if(J.lookahead<B0){if(N8(J),J.lookahead<B0&&G===h0)return X0;if(J.lookahead===0)break}if(Q=0,J.lookahead>=b)J.ins_h=m0(J,J.ins_h,J.window[J.strstart+b-1]),Q=J.prev[J.strstart&J.w_mask]=J.head[J.ins_h],J.head[J.ins_h]=J.strstart;if(J.prev_length=J.match_length,J.prev_match=J.match_start,J.match_length=b-1,Q!==0&&J.prev_length<J.max_lazy_match&&J.strstart-Q<=J.w_size-B0){if(J.match_length=A9(J,Q),J.match_length<=5&&(J.strategy===Wq||J.match_length===b&&J.strstart-J.match_start>4096))J.match_length=b-1}if(J.prev_length>=b&&J.match_length<=J.prev_length){X=J.strstart+J.lookahead-b,q=b0(J,J.strstart-1-J.prev_match,J.prev_length-b),J.lookahead-=J.prev_length-1,J.prev_length-=2;do if(++J.strstart<=X)J.ins_h=m0(J,J.ins_h,J.window[J.strstart+b-1]),Q=J.prev[J.strstart&J.w_mask]=J.head[J.ins_h],J.head[J.ins_h]=J.strstart;while(--J.prev_length!==0);if(J.match_available=0,J.match_length=b-1,J.strstart++,q){if(K0(J,!1),J.strm.avail_out===0)return X0}}else if(J.match_available){if(q=b0(J,0,J.window[J.strstart-1]),q)K0(J,!1);if(J.strstart++,J.lookahead--,J.strm.avail_out===0)return X0}else J.match_available=1,J.strstart++,J.lookahead--}if(J.match_available)q=b0(J,0,J.window[J.strstart-1]),J.match_available=0;if(J.insert=J.strstart<b-1?J.strstart:b-1,G===$0){if(K0(J,!0),J.strm.avail_out===0)return e0;return L8}if(J.sym_next){if(K0(J,!1),J.strm.avail_out===0)return X0}return B8},Aq=(J,G)=>{let Q,q,X,W;const Y=J.window;for(;;){if(J.lookahead<=f0){if(N8(J),J.lookahead<=f0&&G===h0)return X0;if(J.lookahead===0)break}if(J.match_length=0,J.lookahead>=b&&J.strstart>0){if(X=J.strstart-1,q=Y[X],q===Y[++X]&&q===Y[++X]&&q===Y[++X]){W=J.strstart+f0;do;while(q===Y[++X]&&q===Y[++X]&&q===Y[++X]&&q===Y[++X]&&q===Y[++X]&&q===Y[++X]&&q===Y[++X]&&q===Y[++X]&&X<W);if(J.match_length=f0-(W-X),J.match_length>J.lookahead)J.match_length=J.lookahead}}if(J.match_length>=b)Q=b0(J,1,J.match_length-b),J.lookahead-=J.match_length,J.strstart+=J.match_length,J.match_length=0;else Q=b0(J,0,J.window[J.strstart]),J.lookahead--,J.strstart++;if(Q){if(K0(J,!1),J.strm.avail_out===0)return X0}}if(J.insert=0,G===$0){if(K0(J,!0),J.strm.avail_out===0)return e0;return L8}if(J.sym_next){if(K0(J,!1),J.strm.avail_out===0)return X0}return B8},kq=(J,G)=>{let Q;for(;;){if(J.lookahead===0){if(N8(J),J.lookahead===0){if(G===h0)return X0;break}}if(J.match_length=0,Q=b0(J,0,J.window[J.strstart]),J.lookahead--,J.strstart++,Q){if(K0(J,!1),J.strm.avail_out===0)return X0}}if(J.insert=0,G===$0){if(K0(J,!0),J.strm.avail_out===0)return e0;return L8}if(J.sym_next){if(K0(J,!1),J.strm.avail_out===0)return X0}return B8},E8=[new D0(0,0,0,0,k9),new D0(4,4,8,4,qJ),new D0(4,5,16,8,qJ),new D0(4,6,32,32,qJ),new D0(4,4,16,16,H8),new D0(8,16,32,32,H8),new D0(8,16,128,128,H8),new D0(8,32,128,256,H8),new D0(32,128,258,1024,H8),new D0(32,258,258,4096,H8)],Rq=(J)=>{J.window_size=2*J.w_size,y0(J.head),J.max_lazy_match=E8[J.level].max_lazy,J.good_match=E8[J.level].good_length,J.nice_match=E8[J.level].nice_length,J.max_chain_length=E8[J.level].max_chain,J.strstart=0,J.block_start=0,J.lookahead=0,J.insert=0,J.match_length=J.prev_length=b-1,J.match_available=0,J.ins_h=0},r8=(J)=>{if(!J)return 1;const G=J.state;if(!G||G.strm!==J||G.status!==D8&&G.status!==RJ&&G.status!==PJ&&G.status!==CJ&&G.status!==DJ&&G.status!==NJ&&G.status!==a0&&G.status!==g8)return 1;return 0},R9=(J)=>{if(r8(J))return s0(J,O0);J.total_in=J.total_out=0,J.data_type=Kq;const G=J.state;if(G.pending=0,G.pending_out=0,G.wrap<0)G.wrap=-G.wrap;return G.status=G.wrap===2?RJ:G.wrap?D8:a0,J.adler=G.wrap===2?0:1,G.last_flush=-2,tG(G),Q0},I9=(J)=>{const G=R9(J);if(G===Q0)Rq(J.state);return G},wq=(J,G)=>{if(r8(J)||J.state.wrap!==2)return O0;return J.state.gzhead=G,Q0},w9=(J,G,Q,q,X,W)=>{if(!J)return O0;let Y=1;if(G===Xq)G=6;if(q<0)Y=0,q=-q;else if(q>15)Y=2,q-=16;if(X<1||X>Zq||Q!==B1||q<8||q>15||G<0||G>9||W<0||W>Uq||q===8&&Y!==1)return s0(J,O0);if(q===8)q=9;const U=new Iq;return J.state=U,U.strm=J,U.status=D8,U.wrap=Y,U.gzhead=null,U.w_bits=q,U.w_size=1<<U.w_bits,U.w_mask=U.w_size-1,U.hash_bits=X+7,U.hash_size=1<<U.hash_bits,U.hash_mask=U.hash_size-1,U.hash_shift=~~((U.hash_bits+b-1)/b),U.window=new Uint8Array(U.w_size*2),U.head=new Uint16Array(U.hash_size),U.prev=new Uint16Array(U.w_size),U.lit_bufsize=1<<X+6,U.pending_buf_size=U.lit_bufsize*4,U.pending_buf=new Uint8Array(U.pending_buf_size),U.sym_buf=U.lit_bufsize,U.sym_end=(U.lit_bufsize-1)*3,U.level=G,U.strategy=W,U.method=Q,I9(J)},xq=(J,G)=>{return w9(J,G,B1,$q,zq,Vq)},Tq=(J,G)=>{if(r8(J)||G>TQ||G<0)return J?s0(J,O0):O0;const Q=J.state;if(!J.output||J.avail_in!==0&&!J.input||Q.status===g8&&G!==$0)return s0(J,J.avail_out===0?GJ:O0);const q=Q.last_flush;if(Q.last_flush=G,Q.pending!==0){if(V0(J),J.avail_out===0)return Q.last_flush=-1,Q0}else if(J.avail_in===0&&FQ(G)<=FQ(q)&&G!==$0)return s0(J,GJ);if(Q.status===g8&&J.avail_in!==0)return s0(J,GJ);if(Q.status===D8&&Q.wrap===0)Q.status=a0;if(Q.status===D8){let X=B1+(Q.w_bits-8<<4)<<8,W=-1;if(Q.strategy>=z1||Q.level<2)W=0;else if(Q.level<6)W=1;else if(Q.level===6)W=2;else W=3;if(X|=W<<6,Q.strstart!==0)X|=Nq;if(X+=31-X%31,v8(Q,X),Q.strstart!==0)v8(Q,J.adler>>>16),v8(Q,J.adler&65535);if(J.adler=1,Q.status=a0,V0(J),Q.pending!==0)return Q.last_flush=-1,Q0}if(Q.status===RJ)if(J.adler=0,h(Q,31),h(Q,139),h(Q,8),!Q.gzhead){if(h(Q,0),h(Q,0),h(Q,0),h(Q,0),h(Q,0),h(Q,Q.level===9?2:Q.strategy>=z1||Q.level<2?4:0),h(Q,Oq),Q.status=a0,V0(J),Q.pending!==0)return Q.last_flush=-1,Q0}else{if(h(Q,(Q.gzhead.text?1:0)+(Q.gzhead.hcrc?2:0)+(!Q.gzhead.extra?0:4)+(!Q.gzhead.name?0:8)+(!Q.gzhead.comment?0:16)),h(Q,Q.gzhead.time&255),h(Q,Q.gzhead.time>>8&255),h(Q,Q.gzhead.time>>16&255),h(Q,Q.gzhead.time>>24&255),h(Q,Q.level===9?2:Q.strategy>=z1||Q.level<2?4:0),h(Q,Q.gzhead.os&255),Q.gzhead.extra&&Q.gzhead.extra.length)h(Q,Q.gzhead.extra.length&255),h(Q,Q.gzhead.extra.length>>8&255);if(Q.gzhead.hcrc)J.adler=t(J.adler,Q.pending_buf,Q.pending,0);Q.gzindex=0,Q.status=PJ}if(Q.status===PJ){if(Q.gzhead.extra){let X=Q.pending,W=(Q.gzhead.extra.length&65535)-Q.gzindex;while(Q.pending+W>Q.pending_buf_size){let U=Q.pending_buf_size-Q.pending;if(Q.pending_buf.set(Q.gzhead.extra.subarray(Q.gzindex,Q.gzindex+U),Q.pending),Q.pending=Q.pending_buf_size,Q.gzhead.hcrc&&Q.pending>X)J.adler=t(J.adler,Q.pending_buf,Q.pending-X,X);if(Q.gzindex+=U,V0(J),Q.pending!==0)return Q.last_flush=-1,Q0;X=0,W-=U}let Y=new Uint8Array(Q.gzhead.extra);if(Q.pending_buf.set(Y.subarray(Q.gzindex,Q.gzindex+W),Q.pending),Q.pending+=W,Q.gzhead.hcrc&&Q.pending>X)J.adler=t(J.adler,Q.pending_buf,Q.pending-X,X);Q.gzindex=0}Q.status=CJ}if(Q.status===CJ){if(Q.gzhead.name){let X=Q.pending,W;do{if(Q.pending===Q.pending_buf_size){if(Q.gzhead.hcrc&&Q.pending>X)J.adler=t(J.adler,Q.pending_buf,Q.pending-X,X);if(V0(J),Q.pending!==0)return Q.last_flush=-1,Q0;X=0}if(Q.gzindex<Q.gzhead.name.length)W=Q.gzhead.name.charCodeAt(Q.gzindex++)&255;else W=0;h(Q,W)}while(W!==0);if(Q.gzhead.hcrc&&Q.pending>X)J.adler=t(J.adler,Q.pending_buf,Q.pending-X,X);Q.gzindex=0}Q.status=DJ}if(Q.status===DJ){if(Q.gzhead.comment){let X=Q.pending,W;do{if(Q.pending===Q.pending_buf_size){if(Q.gzhead.hcrc&&Q.pending>X)J.adler=t(J.adler,Q.pending_buf,Q.pending-X,X);if(V0(J),Q.pending!==0)return Q.last_flush=-1,Q0;X=0}if(Q.gzindex<Q.gzhead.comment.length)W=Q.gzhead.comment.charCodeAt(Q.gzindex++)&255;else W=0;h(Q,W)}while(W!==0);if(Q.gzhead.hcrc&&Q.pending>X)J.adler=t(J.adler,Q.pending_buf,Q.pending-X,X)}Q.status=NJ}if(Q.status===NJ){if(Q.gzhead.hcrc){if(Q.pending+2>Q.pending_buf_size){if(V0(J),Q.pending!==0)return Q.last_flush=-1,Q0}h(Q,J.adler&255),h(Q,J.adler>>8&255),J.adler=0}if(Q.status=a0,V0(J),Q.pending!==0)return Q.last_flush=-1,Q0}if(J.avail_in!==0||Q.lookahead!==0||G!==h0&&Q.status!==g8){let X=Q.level===0?k9(Q,G):Q.strategy===z1?kq(Q,G):Q.strategy===Yq?Aq(Q,G):E8[Q.level].func(Q,G);if(X===e0||X===L8)Q.status=g8;if(X===X0||X===e0){if(J.avail_out===0)Q.last_flush=-1;return Q0}if(X===B8){if(G===Qq)Jq(Q);else if(G!==TQ){if(MJ(Q,0,0,!1),G===Gq){if(y0(Q.head),Q.lookahead===0)Q.strstart=0,Q.block_start=0,Q.insert=0}}if(V0(J),J.avail_out===0)return Q.last_flush=-1,Q0}}if(G!==$0)return Q0;if(Q.wrap<=0)return SQ;if(Q.wrap===2)h(Q,J.adler&255),h(Q,J.adler>>8&255),h(Q,J.adler>>16&255),h(Q,J.adler>>24&255),h(Q,J.total_in&255),h(Q,J.total_in>>8&255),h(Q,J.total_in>>16&255),h(Q,J.total_in>>24&255);else v8(Q,J.adler>>>16),v8(Q,J.adler&65535);if(V0(J),Q.wrap>0)Q.wrap=-Q.wrap;return Q.pending!==0?Q0:SQ},Sq=(J)=>{if(r8(J))return O0;const G=J.state.status;return J.state=null,G===a0?s0(J,qq):Q0},Fq=(J,G)=>{let Q=G.length;if(r8(J))return O0;const q=J.state,X=q.wrap;if(X===2||X===1&&q.status!==D8||q.lookahead)return O0;if(X===1)J.adler=c8(J.adler,G,Q,0);if(q.wrap=0,Q>=q.w_size){if(X===0)y0(q.head),q.strstart=0,q.block_start=0,q.insert=0;let K=new Uint8Array(q.w_size);K.set(G.subarray(Q-q.w_size,Q),0),G=K,Q=q.w_size}const{avail_in:W,next_in:Y,input:U}=J;J.avail_in=Q,J.next_in=0,J.input=G,N8(q);while(q.lookahead>=b){let K=q.strstart,V=q.lookahead-(b-1);do q.ins_h=m0(q,q.ins_h,q.window[K+b-1]),q.prev[K&q.w_mask]=q.head[q.ins_h],q.head[q.ins_h]=K,K++;while(--V);q.strstart=K,q.lookahead=b-1,N8(q)}return q.strstart+=q.lookahead,q.block_start=q.strstart,q.insert=q.lookahead,q.lookahead=0,q.match_length=q.prev_length=b-1,q.match_available=0,J.next_in=Y,J.input=U,J.avail_in=W,q.wrap=X,Q0},vq=xq,gq=w9,Eq=I9,yq=R9,fq=wq,bq=Tq,hq=Sq,mq=Fq,_q="pako deflate (from Nodeca project)",f8={deflateInit:vq,deflateInit2:gq,deflateReset:Eq,deflateResetKeep:yq,deflateSetHeader:fq,deflate:bq,deflateEnd:hq,deflateSetDictionary:mq,deflateInfo:_q},uq=(J,G)=>{return Object.prototype.hasOwnProperty.call(J,G)},cq=function(J){const G=Array.prototype.slice.call(arguments,1);while(G.length){const Q=G.shift();if(!Q)continue;if(typeof Q!=="object")throw new TypeError(Q+"must be non-object");for(let q in Q)if(uq(Q,q))J[q]=Q[q]}return J},pq=(J)=>{let G=0;for(let q=0,X=J.length;q<X;q++)G+=J[q].length;const Q=new Uint8Array(G);for(let q=0,X=0,W=J.length;q<W;q++){let Y=J[q];Q.set(Y,X),X+=Y.length}return Q},L1={assign:cq,flattenChunks:pq},x9=!0;try{String.fromCharCode.apply(null,new Uint8Array(1))}catch(J){x9=!1}var p8=new Uint8Array(256);for(let J=0;J<256;J++)p8[J]=J>=252?6:J>=248?5:J>=240?4:J>=224?3:J>=192?2:1;p8[254]=p8[254]=1;var lq=(J)=>{if(typeof TextEncoder==="function"&&TextEncoder.prototype.encode)return(new TextEncoder()).encode(J);let G,Q,q,X,W,Y=J.length,U=0;for(X=0;X<Y;X++){if(Q=J.charCodeAt(X),(Q&64512)===55296&&X+1<Y){if(q=J.charCodeAt(X+1),(q&64512)===56320)Q=65536+(Q-55296<<10)+(q-56320),X++}U+=Q<128?1:Q<2048?2:Q<65536?3:4}G=new Uint8Array(U);for(W=0,X=0;W<U;X++){if(Q=J.charCodeAt(X),(Q&64512)===55296&&X+1<Y){if(q=J.charCodeAt(X+1),(q&64512)===56320)Q=65536+(Q-55296<<10)+(q-56320),X++}if(Q<128)G[W++]=Q;else if(Q<2048)G[W++]=192|Q>>>6,G[W++]=128|Q&63;else if(Q<65536)G[W++]=224|Q>>>12,G[W++]=128|Q>>>6&63,G[W++]=128|Q&63;else G[W++]=240|Q>>>18,G[W++]=128|Q>>>12&63,G[W++]=128|Q>>>6&63,G[W++]=128|Q&63}return G},dq=(J,G)=>{if(G<65534){if(J.subarray&&x9)return String.fromCharCode.apply(null,J.length===G?J:J.subarray(0,G))}let Q="";for(let q=0;q<G;q++)Q+=String.fromCharCode(J[q]);return Q},iq=(J,G)=>{const Q=G||J.length;if(typeof TextDecoder==="function"&&TextDecoder.prototype.decode)return(new TextDecoder()).decode(J.subarray(0,G));let q,X;const W=new Array(Q*2);for(X=0,q=0;q<Q;){let Y=J[q++];if(Y<128){W[X++]=Y;continue}let U=p8[Y];if(U>4){W[X++]=65533,q+=U-1;continue}Y&=U===2?31:U===3?15:7;while(U>1&&q<Q)Y=Y<<6|J[q++]&63,U--;if(U>1){W[X++]=65533;continue}if(Y<65536)W[X++]=Y;else Y-=65536,W[X++]=55296|Y>>10&1023,W[X++]=56320|Y&1023}return dq(W,X)},rq=(J,G)=>{if(G=G||J.length,G>J.length)G=J.length;let Q=G-1;while(Q>=0&&(J[Q]&192)===128)Q--;if(Q<0)return G;if(Q===0)return G;return Q+p8[J[Q]]>G?Q:G},l8={string2buf:lq,buf2string:iq,utf8border:rq},T9=oq,S9=Object.prototype.toString,{Z_NO_FLUSH:nq,Z_SYNC_FLUSH:aq,Z_FULL_FLUSH:sq,Z_FINISH:tq,Z_OK:N1,Z_STREAM_END:eq,Z_DEFAULT_COMPRESSION:J6,Z_DEFAULT_STRATEGY:Q6,Z_DEFLATED:G6}=Q8;o8.prototype.push=function(J,G){const Q=this.strm,q=this.options.chunkSize;let X,W;if(this.ended)return!1;if(G===~~G)W=G;else W=G===!0?tq:nq;if(typeof J==="string")Q.input=l8.string2buf(J);else if(S9.call(J)==="[object ArrayBuffer]")Q.input=new Uint8Array(J);else Q.input=J;Q.next_in=0,Q.avail_in=Q.input.length;for(;;){if(Q.avail_out===0)Q.output=new Uint8Array(q),Q.next_out=0,Q.avail_out=q;if((W===aq||W===sq)&&Q.avail_out<=6){this.onData(Q.output.subarray(0,Q.next_out)),Q.avail_out=0;continue}if(X=f8.deflate(Q,W),X===eq){if(Q.next_out>0)this.onData(Q.output.subarray(0,Q.next_out));return X=f8.deflateEnd(this.strm),this.onEnd(X),this.ended=!0,X===N1}if(Q.avail_out===0){this.onData(Q.output);continue}if(W>0&&Q.next_out>0){this.onData(Q.output.subarray(0,Q.next_out)),Q.avail_out=0;continue}if(Q.avail_in===0)break}return!0};o8.prototype.onData=function(J){this.chunks.push(J)};o8.prototype.onEnd=function(J){if(J===N1)this.result=L1.flattenChunks(this.chunks);this.chunks=[],this.err=J,this.msg=this.strm.msg};var W6=o8,Y6=IJ,U6=q6,V6=X6,K6=Q8,Z6={Deflate:W6,deflate:Y6,deflateRaw:U6,gzip:V6,constants:K6},j1=16209,$6=16191,z6=function J(G,Q){let q,X,W,Y,U,K,V,Z,j,z,$,N,M,H,A,k,R,C,T,x,L,I,E,w;const F=G.state;q=G.next_in,E=G.input,X=q+(G.avail_in-5),W=G.next_out,w=G.output,Y=W-(Q-G.avail_out),U=W+(G.avail_out-257),K=F.dmax,V=F.wsize,Z=F.whave,j=F.wnext,z=F.window,$=F.hold,N=F.bits,M=F.lencode,H=F.distcode,A=(1<<F.lenbits)-1,k=(1<<F.distbits)-1;J:do{if(N<15)$+=E[q++]<<N,N+=8,$+=E[q++]<<N,N+=8;R=M[$&A];Q:for(;;){if(C=R>>>24,$>>>=C,N-=C,C=R>>>16&255,C===0)w[W++]=R&65535;else if(C&16){if(T=R&65535,C&=15,C){if(N<C)$+=E[q++]<<N,N+=8;T+=$&(1<<C)-1,$>>>=C,N-=C}if(N<15)$+=E[q++]<<N,N+=8,$+=E[q++]<<N,N+=8;R=H[$&k];G:for(;;){if(C=R>>>24,$>>>=C,N-=C,C=R>>>16&255,C&16){if(x=R&65535,C&=15,N<C){if($+=E[q++]<<N,N+=8,N<C)$+=E[q++]<<N,N+=8}if(x+=$&(1<<C)-1,x>K){G.msg="invalid distance too far back",F.mode=j1;break J}if($>>>=C,N-=C,C=W-Y,x>C){if(C=x-C,C>Z){if(F.sane){G.msg="invalid distance too far back",F.mode=j1;break J}}if(L=0,I=z,j===0){if(L+=V-C,C<T){T-=C;do w[W++]=z[L++];while(--C);L=W-x,I=w}}else if(j<C){if(L+=V+j-C,C-=j,C<T){T-=C;do w[W++]=z[L++];while(--C);if(L=0,j<T){C=j,T-=C;do w[W++]=z[L++];while(--C);L=W-x,I=w}}}else if(L+=j-C,C<T){T-=C;do w[W++]=z[L++];while(--C);L=W-x,I=w}while(T>2)w[W++]=I[L++],w[W++]=I[L++],w[W++]=I[L++],T-=3;if(T){if(w[W++]=I[L++],T>1)w[W++]=I[L++]}}else{L=W-x;do w[W++]=w[L++],w[W++]=w[L++],w[W++]=w[L++],T-=3;while(T>2);if(T){if(w[W++]=w[L++],T>1)w[W++]=w[L++]}}}else if((C&64)===0){R=H[(R&65535)+($&(1<<C)-1)];continue G}else{G.msg="invalid distance code",F.mode=j1;break J}break}}else if((C&64)===0){R=M[(R&65535)+($&(1<<C)-1)];continue Q}else if(C&32){F.mode=$6;break J}else{G.msg="invalid literal/length code",F.mode=j1;break J}break}}while(q<X&&W<U);T=N>>3,q-=T,N-=T<<3,$&=(1<<N)-1,G.next_in=q,G.next_out=W,G.avail_in=q<X?5+(X-q):5-(q-X),G.avail_out=W<U?257+(U-W):257-(W-U),F.hold=$,F.bits=N;return},P8=15,vQ=852,gQ=592,EQ=0,XJ=1,yQ=2,j6=new Uint16Array([3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,0,0]),M6=new Uint8Array([16,16,16,16,16,16,16,16,17,17,17,17,18,18,18,18,19,19,19,19,20,20,20,20,21,21,21,21,16,72,78]),H6=new Uint16Array([1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,0,0]),P6=new Uint8Array([16,16,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,64,64]),C6=(J,G,Q,q,X,W,Y,U)=>{const K=U.bits;let V=0,Z=0,j=0,z=0,$=0,N=0,M=0,H=0,A=0,k=0,R,C,T,x,L,I=null,E;const w=new Uint16Array(P8+1),F=new Uint16Array(P8+1);let O=null,S,P,B;for(V=0;V<=P8;V++)w[V]=0;for(Z=0;Z<q;Z++)w[G[Q+Z]]++;$=K;for(z=P8;z>=1;z--)if(w[z]!==0)break;if($>z)$=z;if(z===0)return X[W++]=1<<24|64<<16|0,X[W++]=1<<24|64<<16|0,U.bits=1,0;for(j=1;j<z;j++)if(w[j]!==0)break;if($<j)$=j;H=1;for(V=1;V<=P8;V++)if(H<<=1,H-=w[V],H<0)return-1;if(H>0&&(J===EQ||z!==1))return-1;F[1]=0;for(V=1;V<P8;V++)F[V+1]=F[V]+w[V];for(Z=0;Z<q;Z++)if(G[Q+Z]!==0)Y[F[G[Q+Z]]++]=Z;if(J===EQ)I=O=Y,E=20;else if(J===XJ)I=j6,O=M6,E=257;else I=H6,O=P6,E=0;if(k=0,Z=0,V=j,L=W,N=$,M=0,T=-1,A=1<<$,x=A-1,J===XJ&&A>vQ||J===yQ&&A>gQ)return 1;for(;;){if(S=V-M,Y[Z]+1<E)P=0,B=Y[Z];else if(Y[Z]>=E)P=O[Y[Z]-E],B=I[Y[Z]-E];else P=96,B=0;R=1<<V-M,C=1<<N,j=C;do C-=R,X[L+(k>>M)+C]=S<<24|P<<16|B|0;while(C!==0);R=1<<V-1;while(k&R)R>>=1;if(R!==0)k&=R-1,k+=R;else k=0;if(Z++,--w[V]===0){if(V===z)break;V=G[Q+Y[Z]]}if(V>$&&(k&x)!==T){if(M===0)M=$;L+=j,N=V-M,H=1<<N;while(N+M<z){if(H-=w[N+M],H<=0)break;N++,H<<=1}if(A+=1<<N,J===XJ&&A>vQ||J===yQ&&A>gQ)return 1;T=k&x,X[T]=$<<24|N<<16|L-W|0}}if(k!==0)X[L+k]=V-M<<24|64<<16|0;return U.bits=$,0},b8=C6,D6=0,F9=1,v9=2,{Z_FINISH:fQ,Z_BLOCK:N6,Z_TREES:M1,Z_OK:J8,Z_STREAM_END:O6,Z_NEED_DICT:B6,Z_STREAM_ERROR:z0,Z_DATA_ERROR:g9,Z_MEM_ERROR:E9,Z_BUF_ERROR:L6,Z_DEFLATED:bQ}=Q8,A1=16180,hQ=16181,mQ=16182,_Q=16183,uQ=16184,cQ=16185,pQ=16186,lQ=16187,dQ=16188,iQ=16189,O1=16190,I0=16191,WJ=16192,rQ=16193,YJ=16194,oQ=16195,nQ=16196,aQ=16197,sQ=16198,H1=16199,P1=16200,tQ=16201,eQ=16202,J9=16203,Q9=16204,G9=16205,UJ=16206,q9=16207,X9=16208,p=16209,y9=16210,f9=16211,A6=852,k6=592,R6=15,I6=R6,W9=(J)=>{return(J>>>24&255)+(J>>>8&65280)+((J&65280)<<8)+((J&255)<<24)},G8=(J)=>{if(!J)return 1;const G=J.state;if(!G||G.strm!==J||G.mode<A1||G.mode>f9)return 1;return 0},b9=(J)=>{if(G8(J))return z0;const G=J.state;if(J.total_in=J.total_out=G.total=0,J.msg="",G.wrap)J.adler=G.wrap&1;return G.mode=A1,G.last=0,G.havedict=0,G.flags=-1,G.dmax=32768,G.head=null,G.hold=0,G.bits=0,G.lencode=G.lendyn=new Int32Array(A6),G.distcode=G.distdyn=new Int32Array(k6),G.sane=1,G.back=-1,J8},h9=(J)=>{if(G8(J))return z0;const G=J.state;return G.wsize=0,G.whave=0,G.wnext=0,b9(J)},m9=(J,G)=>{let Q;if(G8(J))return z0;const q=J.state;if(G<0)Q=0,G=-G;else if(Q=(G>>4)+5,G<48)G&=15;if(G&&(G<8||G>15))return z0;if(q.window!==null&&q.wbits!==G)q.window=null;return q.wrap=Q,q.wbits=G,h9(J)},_9=(J,G)=>{if(!J)return z0;const Q=new w6;J.state=Q,Q.strm=J,Q.window=null,Q.mode=A1;const q=m9(J,G);if(q!==J8)J.state=null;return q},x6=(J)=>{return _9(J,I6)},Y9=!0,VJ,KJ,T6=(J)=>{if(Y9){VJ=new Int32Array(512),KJ=new Int32Array(32);let G=0;while(G<144)J.lens[G++]=8;while(G<256)J.lens[G++]=9;while(G<280)J.lens[G++]=7;while(G<288)J.lens[G++]=8;b8(F9,J.lens,0,288,VJ,0,J.work,{bits:9}),G=0;while(G<32)J.lens[G++]=5;b8(v9,J.lens,0,32,KJ,0,J.work,{bits:5}),Y9=!1}J.lencode=VJ,J.lenbits=9,J.distcode=KJ,J.distbits=5},u9=(J,G,Q,q)=>{let X;const W=J.state;if(W.window===null)W.wsize=1<<W.wbits,W.wnext=0,W.whave=0,W.window=new Uint8Array(W.wsize);if(q>=W.wsize)W.window.set(G.subarray(Q-W.wsize,Q),0),W.wnext=0,W.whave=W.wsize;else{if(X=W.wsize-W.wnext,X>q)X=q;if(W.window.set(G.subarray(Q-q,Q-q+X),W.wnext),q-=X,q)W.window.set(G.subarray(Q-q,Q),0),W.wnext=q,W.whave=W.wsize;else{if(W.wnext+=X,W.wnext===W.wsize)W.wnext=0;if(W.whave<W.wsize)W.whave+=X}}return 0},S6=(J,G)=>{let Q,q,X,W,Y,U,K,V,Z,j,z,$,N,M,H=0,A,k,R,C,T,x,L,I;const E=new Uint8Array(4);let w,F;const O=new Uint8Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]);if(G8(J)||!J.output||!J.input&&J.avail_in!==0)return z0;if(Q=J.state,Q.mode===I0)Q.mode=WJ;Y=J.next_out,X=J.output,K=J.avail_out,W=J.next_in,q=J.input,U=J.avail_in,V=Q.hold,Z=Q.bits,j=U,z=K,I=J8;J:for(;;)switch(Q.mode){case A1:if(Q.wrap===0){Q.mode=WJ;break}while(Z<16){if(U===0)break J;U--,V+=q[W++]<<Z,Z+=8}if(Q.wrap&2&&V===35615){if(Q.wbits===0)Q.wbits=15;Q.check=0,E[0]=V&255,E[1]=V>>>8&255,Q.check=t(Q.check,E,2,0),V=0,Z=0,Q.mode=hQ;break}if(Q.head)Q.head.done=!1;if(!(Q.wrap&1)||(((V&255)<<8)+(V>>8))%31){J.msg="incorrect header check",Q.mode=p;break}if((V&15)!==bQ){J.msg="unknown compression method",Q.mode=p;break}if(V>>>=4,Z-=4,L=(V&15)+8,Q.wbits===0)Q.wbits=L;if(L>15||L>Q.wbits){J.msg="invalid window size",Q.mode=p;break}Q.dmax=1<<Q.wbits,Q.flags=0,J.adler=Q.check=1,Q.mode=V&512?iQ:I0,V=0,Z=0;break;case hQ:while(Z<16){if(U===0)break J;U--,V+=q[W++]<<Z,Z+=8}if(Q.flags=V,(Q.flags&255)!==bQ){J.msg="unknown compression method",Q.mode=p;break}if(Q.flags&57344){J.msg="unknown header flags set",Q.mode=p;break}if(Q.head)Q.head.text=V>>8&1;if(Q.flags&512&&Q.wrap&4)E[0]=V&255,E[1]=V>>>8&255,Q.check=t(Q.check,E,2,0);V=0,Z=0,Q.mode=mQ;case mQ:while(Z<32){if(U===0)break J;U--,V+=q[W++]<<Z,Z+=8}if(Q.head)Q.head.time=V;if(Q.flags&512&&Q.wrap&4)E[0]=V&255,E[1]=V>>>8&255,E[2]=V>>>16&255,E[3]=V>>>24&255,Q.check=t(Q.check,E,4,0);V=0,Z=0,Q.mode=_Q;case _Q:while(Z<16){if(U===0)break J;U--,V+=q[W++]<<Z,Z+=8}if(Q.head)Q.head.xflags=V&255,Q.head.os=V>>8;if(Q.flags&512&&Q.wrap&4)E[0]=V&255,E[1]=V>>>8&255,Q.check=t(Q.check,E,2,0);V=0,Z=0,Q.mode=uQ;case uQ:if(Q.flags&1024){while(Z<16){if(U===0)break J;U--,V+=q[W++]<<Z,Z+=8}if(Q.length=V,Q.head)Q.head.extra_len=V;if(Q.flags&512&&Q.wrap&4)E[0]=V&255,E[1]=V>>>8&255,Q.check=t(Q.check,E,2,0);V=0,Z=0}else if(Q.head)Q.head.extra=null;Q.mode=cQ;case cQ:if(Q.flags&1024){if($=Q.length,$>U)$=U;if($){if(Q.head){if(L=Q.head.extra_len-Q.length,!Q.head.extra)Q.head.extra=new Uint8Array(Q.head.extra_len);Q.head.extra.set(q.subarray(W,W+$),L)}if(Q.flags&512&&Q.wrap&4)Q.check=t(Q.check,q,$,W);U-=$,W+=$,Q.length-=$}if(Q.length)break J}Q.length=0,Q.mode=pQ;case pQ:if(Q.flags&2048){if(U===0)break J;$=0;do if(L=q[W+$++],Q.head&&L&&Q.length<65536)Q.head.name+=String.fromCharCode(L);while(L&&$<U);if(Q.flags&512&&Q.wrap&4)Q.check=t(Q.check,q,$,W);if(U-=$,W+=$,L)break J}else if(Q.head)Q.head.name=null;Q.length=0,Q.mode=lQ;case lQ:if(Q.flags&4096){if(U===0)break J;$=0;do if(L=q[W+$++],Q.head&&L&&Q.length<65536)Q.head.comment+=String.fromCharCode(L);while(L&&$<U);if(Q.flags&512&&Q.wrap&4)Q.check=t(Q.check,q,$,W);if(U-=$,W+=$,L)break J}else if(Q.head)Q.head.comment=null;Q.mode=dQ;case dQ:if(Q.flags&512){while(Z<16){if(U===0)break J;U--,V+=q[W++]<<Z,Z+=8}if(Q.wrap&4&&V!==(Q.check&65535)){J.msg="header crc mismatch",Q.mode=p;break}V=0,Z=0}if(Q.head)Q.head.hcrc=Q.flags>>9&1,Q.head.done=!0;J.adler=Q.check=0,Q.mode=I0;break;case iQ:while(Z<32){if(U===0)break J;U--,V+=q[W++]<<Z,Z+=8}J.adler=Q.check=W9(V),V=0,Z=0,Q.mode=O1;case O1:if(Q.havedict===0)return J.next_out=Y,J.avail_out=K,J.next_in=W,J.avail_in=U,Q.hold=V,Q.bits=Z,B6;J.adler=Q.check=1,Q.mode=I0;case I0:if(G===N6||G===M1)break J;case WJ:if(Q.last){V>>>=Z&7,Z-=Z&7,Q.mode=UJ;break}while(Z<3){if(U===0)break J;U--,V+=q[W++]<<Z,Z+=8}switch(Q.last=V&1,V>>>=1,Z-=1,V&3){case 0:Q.mode=rQ;break;case 1:if(T6(Q),Q.mode=H1,G===M1){V>>>=2,Z-=2;break J}break;case 2:Q.mode=nQ;break;case 3:J.msg="invalid block type",Q.mode=p}V>>>=2,Z-=2;break;case rQ:V>>>=Z&7,Z-=Z&7;while(Z<32){if(U===0)break J;U--,V+=q[W++]<<Z,Z+=8}if((V&65535)!==(V>>>16^65535)){J.msg="invalid stored block lengths",Q.mode=p;break}if(Q.length=V&65535,V=0,Z=0,Q.mode=YJ,G===M1)break J;case YJ:Q.mode=oQ;case oQ:if($=Q.length,$){if($>U)$=U;if($>K)$=K;if($===0)break J;X.set(q.subarray(W,W+$),Y),U-=$,W+=$,K-=$,Y+=$,Q.length-=$;break}Q.mode=I0;break;case nQ:while(Z<14){if(U===0)break J;U--,V+=q[W++]<<Z,Z+=8}if(Q.nlen=(V&31)+257,V>>>=5,Z-=5,Q.ndist=(V&31)+1,V>>>=5,Z-=5,Q.ncode=(V&15)+4,V>>>=4,Z-=4,Q.nlen>286||Q.ndist>30){J.msg="too many length or distance symbols",Q.mode=p;break}Q.have=0,Q.mode=aQ;case aQ:while(Q.have<Q.ncode){while(Z<3){if(U===0)break J;U--,V+=q[W++]<<Z,Z+=8}Q.lens[O[Q.have++]]=V&7,V>>>=3,Z-=3}while(Q.have<19)Q.lens[O[Q.have++]]=0;if(Q.lencode=Q.lendyn,Q.lenbits=7,w={bits:Q.lenbits},I=b8(D6,Q.lens,0,19,Q.lencode,0,Q.work,w),Q.lenbits=w.bits,I){J.msg="invalid code lengths set",Q.mode=p;break}Q.have=0,Q.mode=sQ;case sQ:while(Q.have<Q.nlen+Q.ndist){for(;;){if(H=Q.lencode[V&(1<<Q.lenbits)-1],A=H>>>24,k=H>>>16&255,R=H&65535,A<=Z)break;if(U===0)break J;U--,V+=q[W++]<<Z,Z+=8}if(R<16)V>>>=A,Z-=A,Q.lens[Q.have++]=R;else{if(R===16){F=A+2;while(Z<F){if(U===0)break J;U--,V+=q[W++]<<Z,Z+=8}if(V>>>=A,Z-=A,Q.have===0){J.msg="invalid bit length repeat",Q.mode=p;break}L=Q.lens[Q.have-1],$=3+(V&3),V>>>=2,Z-=2}else if(R===17){F=A+3;while(Z<F){if(U===0)break J;U--,V+=q[W++]<<Z,Z+=8}V>>>=A,Z-=A,L=0,$=3+(V&7),V>>>=3,Z-=3}else{F=A+7;while(Z<F){if(U===0)break J;U--,V+=q[W++]<<Z,Z+=8}V>>>=A,Z-=A,L=0,$=11+(V&127),V>>>=7,Z-=7}if(Q.have+$>Q.nlen+Q.ndist){J.msg="invalid bit length repeat",Q.mode=p;break}while($--)Q.lens[Q.have++]=L}}if(Q.mode===p)break;if(Q.lens[256]===0){J.msg="invalid code -- missing end-of-block",Q.mode=p;break}if(Q.lenbits=9,w={bits:Q.lenbits},I=b8(F9,Q.lens,0,Q.nlen,Q.lencode,0,Q.work,w),Q.lenbits=w.bits,I){J.msg="invalid literal/lengths set",Q.mode=p;break}if(Q.distbits=6,Q.distcode=Q.distdyn,w={bits:Q.distbits},I=b8(v9,Q.lens,Q.nlen,Q.ndist,Q.distcode,0,Q.work,w),Q.distbits=w.bits,I){J.msg="invalid distances set",Q.mode=p;break}if(Q.mode=H1,G===M1)break J;case H1:Q.mode=P1;case P1:if(U>=6&&K>=258){if(J.next_out=Y,J.avail_out=K,J.next_in=W,J.avail_in=U,Q.hold=V,Q.bits=Z,z6(J,z),Y=J.next_out,X=J.output,K=J.avail_out,W=J.next_in,q=J.input,U=J.avail_in,V=Q.hold,Z=Q.bits,Q.mode===I0)Q.back=-1;break}Q.back=0;for(;;){if(H=Q.lencode[V&(1<<Q.lenbits)-1],A=H>>>24,k=H>>>16&255,R=H&65535,A<=Z)break;if(U===0)break J;U--,V+=q[W++]<<Z,Z+=8}if(k&&(k&240)===0){C=A,T=k,x=R;for(;;){if(H=Q.lencode[x+((V&(1<<C+T)-1)>>C)],A=H>>>24,k=H>>>16&255,R=H&65535,C+A<=Z)break;if(U===0)break J;U--,V+=q[W++]<<Z,Z+=8}V>>>=C,Z-=C,Q.back+=C}if(V>>>=A,Z-=A,Q.back+=A,Q.length=R,k===0){Q.mode=G9;break}if(k&32){Q.back=-1,Q.mode=I0;break}if(k&64){J.msg="invalid literal/length code",Q.mode=p;break}Q.extra=k&15,Q.mode=tQ;case tQ:if(Q.extra){F=Q.extra;while(Z<F){if(U===0)break J;U--,V+=q[W++]<<Z,Z+=8}Q.length+=V&(1<<Q.extra)-1,V>>>=Q.extra,Z-=Q.extra,Q.back+=Q.extra}Q.was=Q.length,Q.mode=eQ;case eQ:for(;;){if(H=Q.distcode[V&(1<<Q.distbits)-1],A=H>>>24,k=H>>>16&255,R=H&65535,A<=Z)break;if(U===0)break J;U--,V+=q[W++]<<Z,Z+=8}if((k&240)===0){C=A,T=k,x=R;for(;;){if(H=Q.distcode[x+((V&(1<<C+T)-1)>>C)],A=H>>>24,k=H>>>16&255,R=H&65535,C+A<=Z)break;if(U===0)break J;U--,V+=q[W++]<<Z,Z+=8}V>>>=C,Z-=C,Q.back+=C}if(V>>>=A,Z-=A,Q.back+=A,k&64){J.msg="invalid distance code",Q.mode=p;break}Q.offset=R,Q.extra=k&15,Q.mode=J9;case J9:if(Q.extra){F=Q.extra;while(Z<F){if(U===0)break J;U--,V+=q[W++]<<Z,Z+=8}Q.offset+=V&(1<<Q.extra)-1,V>>>=Q.extra,Z-=Q.extra,Q.back+=Q.extra}if(Q.offset>Q.dmax){J.msg="invalid distance too far back",Q.mode=p;break}Q.mode=Q9;case Q9:if(K===0)break J;if($=z-K,Q.offset>$){if($=Q.offset-$,$>Q.whave){if(Q.sane){J.msg="invalid distance too far back",Q.mode=p;break}}if($>Q.wnext)$-=Q.wnext,N=Q.wsize-$;else N=Q.wnext-$;if($>Q.length)$=Q.length;M=Q.window}else M=X,N=Y-Q.offset,$=Q.length;if($>K)$=K;K-=$,Q.length-=$;do X[Y++]=M[N++];while(--$);if(Q.length===0)Q.mode=P1;break;case G9:if(K===0)break J;X[Y++]=Q.length,K--,Q.mode=P1;break;case UJ:if(Q.wrap){while(Z<32){if(U===0)break J;U--,V|=q[W++]<<Z,Z+=8}if(z-=K,J.total_out+=z,Q.total+=z,Q.wrap&4&&z)J.adler=Q.check=Q.flags?t(Q.check,X,z,Y-z):c8(Q.check,X,z,Y-z);if(z=K,Q.wrap&4&&(Q.flags?V:W9(V))!==Q.check){J.msg="incorrect data check",Q.mode=p;break}V=0,Z=0}Q.mode=q9;case q9:if(Q.wrap&&Q.flags){while(Z<32){if(U===0)break J;U--,V+=q[W++]<<Z,Z+=8}if(Q.wrap&4&&V!==(Q.total&4294967295)){J.msg="incorrect length check",Q.mode=p;break}V=0,Z=0}Q.mode=X9;case X9:I=O6;break J;case p:I=g9;break J;case y9:return E9;case f9:default:return z0}if(J.next_out=Y,J.avail_out=K,J.next_in=W,J.avail_in=U,Q.hold=V,Q.bits=Z,Q.wsize||z!==J.avail_out&&Q.mode<p&&(Q.mode<UJ||G!==fQ)){if(u9(J,J.output,J.next_out,z-J.avail_out));}if(j-=J.avail_in,z-=J.avail_out,J.total_in+=j,J.total_out+=z,Q.total+=z,Q.wrap&4&&z)J.adler=Q.check=Q.flags?t(Q.check,X,z,J.next_out-z):c8(Q.check,X,z,J.next_out-z);if(J.data_type=Q.bits+(Q.last?64:0)+(Q.mode===I0?128:0)+(Q.mode===H1||Q.mode===YJ?256:0),(j===0&&z===0||G===fQ)&&I===J8)I=L6;return I},F6=(J)=>{if(G8(J))return z0;let G=J.state;if(G.window)G.window=null;return J.state=null,J8},v6=(J,G)=>{if(G8(J))return z0;const Q=J.state;if((Q.wrap&2)===0)return z0;return Q.head=G,G.done=!1,J8},g6=(J,G)=>{const Q=G.length;let q,X,W;if(G8(J))return z0;if(q=J.state,q.wrap!==0&&q.mode!==O1)return z0;if(q.mode===O1){if(X=1,X=c8(X,G,Q,0),X!==q.check)return g9}if(W=u9(J,G,Q,Q),W)return q.mode=y9,E9;return q.havedict=1,J8},E6=h9,y6=m9,f6=b9,b6=x6,h6=_9,m6=S6,_6=F6,u6=v6,c6=g6,p6="pako inflate (from Nodeca project)",x0={inflateReset:E6,inflateReset2:y6,inflateResetKeep:f6,inflateInit:b6,inflateInit2:h6,inflate:m6,inflateEnd:_6,inflateGetHeader:u6,inflateSetDictionary:c6,inflateInfo:p6},d6=l6,c9=Object.prototype.toString,{Z_NO_FLUSH:i6,Z_FINISH:r6,Z_OK:d8,Z_STREAM_END:ZJ,Z_NEED_DICT:$J,Z_STREAM_ERROR:o6,Z_DATA_ERROR:U9,Z_MEM_ERROR:n6}=Q8;n8.prototype.push=function(J,G){const Q=this.strm,q=this.options.chunkSize,X=this.options.dictionary;let W,Y,U;if(this.ended)return!1;if(G===~~G)Y=G;else Y=G===!0?r6:i6;if(c9.call(J)==="[object ArrayBuffer]")Q.input=new Uint8Array(J);else Q.input=J;Q.next_in=0,Q.avail_in=Q.input.length;for(;;){if(Q.avail_out===0)Q.output=new Uint8Array(q),Q.next_out=0,Q.avail_out=q;if(W=x0.inflate(Q,Y),W===$J&&X){if(W=x0.inflateSetDictionary(Q,X),W===d8)W=x0.inflate(Q,Y);else if(W===U9)W=$J}while(Q.avail_in>0&&W===ZJ&&Q.state.wrap>0&&J[Q.next_in]!==0)x0.inflateReset(Q),W=x0.inflate(Q,Y);switch(W){case o6:case U9:case $J:case n6:return this.onEnd(W),this.ended=!0,!1}if(U=Q.avail_out,Q.next_out){if(Q.avail_out===0||W===ZJ)if(this.options.to==="string"){let K=l8.utf8border(Q.output,Q.next_out),V=Q.next_out-K,Z=l8.buf2string(Q.output,K);if(Q.next_out=V,Q.avail_out=q-V,V)Q.output.set(Q.output.subarray(K,K+V),0);this.onData(Z)}else this.onData(Q.output.length===Q.next_out?Q.output:Q.output.subarray(0,Q.next_out))}if(W===d8&&U===0)continue;if(W===ZJ)return W=x0.inflateEnd(this.strm),this.onEnd(W),this.ended=!0,!0;if(Q.avail_in===0)break}return!0};n8.prototype.onData=function(J){this.chunks.push(J)};n8.prototype.onEnd=function(J){if(J===d8)if(this.options.to==="string")this.result=this.chunks.join("");else this.result=L1.flattenChunks(this.chunks);this.chunks=[],this.err=J,this.msg=this.strm.msg};var s6=n8,t6=wJ,e6=a6,J7=wJ,Q7=Q8,G7={Inflate:s6,inflate:t6,inflateRaw:e6,ungzip:J7,constants:Q7},{Deflate:q7,deflate:X7,deflateRaw:W7,gzip:Y7}=Z6,{Inflate:U7,inflate:V7,inflateRaw:K7,ungzip:Z7}=G7,$7=q7,z7=X7,j7=W7,M7=Y7,H7=U7,P7=V7,C7=K7,D7=Z7,N7=Q8,xJ={Deflate:$7,deflate:z7,deflateRaw:j7,gzip:M7,Inflate:H7,inflate:P7,inflateRaw:C7,ungzip:D7,constants:N7};var p9=function(J){if(!Number.isSafeInteger(J)||J<0)throw new Error("positive integer expected, got "+J)},O7=function(J){return J instanceof Uint8Array||ArrayBuffer.isView(J)&&J.constructor.name==="Uint8Array"},A8=function(J,...G){if(!O7(J))throw new Error("Uint8Array expected");if(G.length>0&&!G.includes(J.length))throw new Error("Uint8Array expected of length "+G+", got length="+J.length)},l9=function(J){if(typeof J!=="function"||typeof J.create!=="function")throw new Error("Hash should be wrapped by utils.wrapConstructor");p9(J.outputLen),p9(J.blockLen)},k8=function(J,G=!0){if(J.destroyed)throw new Error("Hash instance has been destroyed");if(G&&J.finished)throw new Error("Hash#digest() has already been called")},d9=function(J,G){A8(J);const Q=G.outputLen;if(J.length<Q)throw new Error("digestInto() expects output buffer of length at least "+Q)};var q8=typeof globalThis==="object"&&("crypto"in globalThis)?globalThis.crypto:void 0;function k1(J){return new DataView(J.buffer,J.byteOffset,J.byteLength)}function H0(J,G){return J<<32-G|J>>>G}function B7(J){if(typeof J!=="string")throw new Error("utf8ToBytes expected string, got "+typeof J);return new Uint8Array((new TextEncoder()).encode(J))}function a8(J){if(typeof J==="string")J=B7(J);return A8(J),J}function i9(...J){let G=0;for(let q=0;q<J.length;q++){const X=J[q];A8(X),G+=X.length}const Q=new Uint8Array(G);for(let q=0,X=0;q<J.length;q++){const W=J[q];Q.set(W,X),X+=W.length}return Q}function r9(J){const G=(q)=>J().update(a8(q)).digest(),Q=J();return G.outputLen=Q.outputLen,G.blockLen=Q.blockLen,G.create=()=>J(),G}function R1(J=32){if(q8&&typeof q8.getRandomValues==="function")return q8.getRandomValues(new Uint8Array(J));if(q8&&typeof q8.randomBytes==="function")return q8.randomBytes(J);throw new Error("crypto.getRandomValues must be defined")}/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */class s8{clone(){return this._cloneInto()}}function L7(J,G,Q,q){if(typeof J.setBigUint64==="function")return J.setBigUint64(G,Q,q);const X=BigInt(32),W=BigInt(4294967295),Y=Number(Q>>X&W),U=Number(Q&W),K=q?4:0,V=q?0:4;J.setUint32(G+K,Y,q),J.setUint32(G+V,U,q)}function o9(J,G,Q){return J&G^~J&Q}function n9(J,G,Q){return J&G^J&Q^G&Q}class TJ extends s8{constructor(J,G,Q,q){super();this.blockLen=J,this.outputLen=G,this.padOffset=Q,this.isLE=q,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(J),this.view=k1(this.buffer)}update(J){k8(this);const{view:G,buffer:Q,blockLen:q}=this;J=a8(J);const X=J.length;for(let W=0;W<X;){const Y=Math.min(q-this.pos,X-W);if(Y===q){const U=k1(J);for(;q<=X-W;W+=q)this.process(U,W);continue}if(Q.set(J.subarray(W,W+Y),this.pos),this.pos+=Y,W+=Y,this.pos===q)this.process(G,0),this.pos=0}return this.length+=J.length,this.roundClean(),this}digestInto(J){k8(this),d9(J,this),this.finished=!0;const{buffer:G,view:Q,blockLen:q,isLE:X}=this;let{pos:W}=this;if(G[W++]=128,this.buffer.subarray(W).fill(0),this.padOffset>q-W)this.process(Q,0),W=0;for(let Z=W;Z<q;Z++)G[Z]=0;L7(Q,q-8,BigInt(this.length*8),X),this.process(Q,0);const Y=k1(J),U=this.outputLen;if(U%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const K=U/4,V=this.get();if(K>V.length)throw new Error("_sha2: outputLen bigger than state");for(let Z=0;Z<K;Z++)Y.setUint32(4*Z,V[Z],X)}digest(){const{buffer:J,outputLen:G}=this;this.digestInto(J);const Q=J.slice(0,G);return this.destroy(),Q}_cloneInto(J){J||(J=new this.constructor),J.set(...this.get());const{blockLen:G,buffer:Q,length:q,finished:X,destroyed:W,pos:Y}=this;if(J.length=q,J.pos=Y,J.finished=X,J.destroyed=W,q%G)J.buffer.set(Q);return J}}var A7=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),_0=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),u0=new Uint32Array(64);class a9 extends TJ{constructor(){super(64,32,8,!1);this.A=_0[0]|0,this.B=_0[1]|0,this.C=_0[2]|0,this.D=_0[3]|0,this.E=_0[4]|0,this.F=_0[5]|0,this.G=_0[6]|0,this.H=_0[7]|0}get(){const{A:J,B:G,C:Q,D:q,E:X,F:W,G:Y,H:U}=this;return[J,G,Q,q,X,W,Y,U]}set(J,G,Q,q,X,W,Y,U){this.A=J|0,this.B=G|0,this.C=Q|0,this.D=q|0,this.E=X|0,this.F=W|0,this.G=Y|0,this.H=U|0}process(J,G){for(let Z=0;Z<16;Z++,G+=4)u0[Z]=J.getUint32(G,!1);for(let Z=16;Z<64;Z++){const j=u0[Z-15],z=u0[Z-2],$=H0(j,7)^H0(j,18)^j>>>3,N=H0(z,17)^H0(z,19)^z>>>10;u0[Z]=N+u0[Z-7]+$+u0[Z-16]|0}let{A:Q,B:q,C:X,D:W,E:Y,F:U,G:K,H:V}=this;for(let Z=0;Z<64;Z++){const j=H0(Y,6)^H0(Y,11)^H0(Y,25),z=V+j+o9(Y,U,K)+A7[Z]+u0[Z]|0,N=(H0(Q,2)^H0(Q,13)^H0(Q,22))+n9(Q,q,X)|0;V=K,K=U,U=Y,Y=W+z|0,W=X,X=q,q=Q,Q=z+N|0}Q=Q+this.A|0,q=q+this.B|0,X=X+this.C|0,W=W+this.D|0,Y=Y+this.E|0,U=U+this.F|0,K=K+this.G|0,V=V+this.H|0,this.set(Q,q,X,W,Y,U,K,V)}roundClean(){u0.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}}var I1=r9(()=>new a9);class SJ extends s8{constructor(J,G){super();this.finished=!1,this.destroyed=!1,l9(J);const Q=a8(G);if(this.iHash=J.create(),typeof this.iHash.update!=="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const q=this.blockLen,X=new Uint8Array(q);X.set(Q.length>q?J.create().update(Q).digest():Q);for(let W=0;W<X.length;W++)X[W]^=54;this.iHash.update(X),this.oHash=J.create();for(let W=0;W<X.length;W++)X[W]^=54^92;this.oHash.update(X),X.fill(0)}update(J){return k8(this),this.iHash.update(J),this}digestInto(J){k8(this),A8(J,this.outputLen),this.finished=!0,this.iHash.digestInto(J),this.oHash.update(J),this.oHash.digestInto(J),this.destroy()}digest(){const J=new Uint8Array(this.oHash.outputLen);return this.digestInto(J),J}_cloneInto(J){J||(J=Object.create(Object.getPrototypeOf(this),{}));const{oHash:G,iHash:Q,finished:q,destroyed:X,blockLen:W,outputLen:Y}=this;return J=J,J.finished=q,J.destroyed=X,J.blockLen=W,J.outputLen=Y,J.oHash=G._cloneInto(J.oHash),J.iHash=Q._cloneInto(J.iHash),J}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}var FJ=(J,G,Q)=>new SJ(J,G).update(Q).digest();FJ.create=(J,G)=>new SJ(J,G);var bJ={};JG(bJ,{validateObject:()=>{{return l0}},utf8ToBytes:()=>{{return x7}},numberToVarBytesBE:()=>{{return I7}},numberToHexUnpadded:()=>{{return Y8}},numberToBytesLE:()=>{{return S1}},numberToBytesBE:()=>{{return P0}},notImplemented:()=>{{return v7}},memoized:()=>{{return F1}},isBytes:()=>{{return c0}},inRange:()=>{{return p0}},hexToNumber:()=>{{return EJ}},hexToBytes:()=>{{return U8}},equalBytes:()=>{{return w7}},ensureBytes:()=>{{return n}},createHmacDrbg:()=>{{return fJ}},concatBytes:()=>{{return S0}},bytesToNumberLE:()=>{{return T1}},bytesToNumberBE:()=>{{return j0}},bytesToHex:()=>{{return W8}},bitSet:()=>{{return S7}},bitMask:()=>{{return t8}},bitLen:()=>{{return yJ}},bitGet:()=>{{return T7}},abytes:()=>{{return R8}},abool:()=>{{return X8}},aInRange:()=>{{return L0}}});function c0(J){return J instanceof Uint8Array||ArrayBuffer.isView(J)&&J.constructor.name==="Uint8Array"}function R8(J){if(!c0(J))throw new Error("Uint8Array expected")}function X8(J,G){if(typeof G!=="boolean")throw new Error(J+" boolean expected, got "+G)}function W8(J){R8(J);let G="";for(let Q=0;Q<J.length;Q++)G+=R7[J[Q]];return G}function Y8(J){const G=J.toString(16);return G.length&1?"0"+G:G}function EJ(J){if(typeof J!=="string")throw new Error("hex string expected, got "+typeof J);return J===""?w1:BigInt("0x"+J)}var s9=function(J){if(J>=T0._0&&J<=T0._9)return J-T0._0;if(J>=T0.A&&J<=T0.F)return J-(T0.A-10);if(J>=T0.a&&J<=T0.f)return J-(T0.a-10);return};function U8(J){if(typeof J!=="string")throw new Error("hex string expected, got "+typeof J);const G=J.length,Q=G/2;if(G%2)throw new Error("hex string expected, got unpadded hex of length "+G);const q=new Uint8Array(Q);for(let X=0,W=0;X<Q;X++,W+=2){const Y=s9(J.charCodeAt(W)),U=s9(J.charCodeAt(W+1));if(Y===void 0||U===void 0){const K=J[W]+J[W+1];throw new Error('hex string expected, got non-hex character "'+K+'" at index '+W)}q[X]=Y*16+U}return q}function j0(J){return EJ(W8(J))}function T1(J){return R8(J),EJ(W8(Uint8Array.from(J).reverse()))}function P0(J,G){return U8(J.toString(16).padStart(G*2,"0"))}function S1(J,G){return P0(J,G).reverse()}function I7(J){return U8(Y8(J))}function n(J,G,Q){let q;if(typeof G==="string")try{q=U8(G)}catch(W){throw new Error(J+" must be hex string or Uint8Array, cause: "+W)}else if(c0(G))q=Uint8Array.from(G);else throw new Error(J+" must be hex string or Uint8Array");const X=q.length;if(typeof Q==="number"&&X!==Q)throw new Error(J+" of length "+Q+" expected, got "+X);return q}function S0(...J){let G=0;for(let q=0;q<J.length;q++){const X=J[q];R8(X),G+=X.length}const Q=new Uint8Array(G);for(let q=0,X=0;q<J.length;q++){const W=J[q];Q.set(W,X),X+=W.length}return Q}function w7(J,G){if(J.length!==G.length)return!1;let Q=0;for(let q=0;q<J.length;q++)Q|=J[q]^G[q];return Q===0}function x7(J){if(typeof J!=="string")throw new Error("string expected");return new Uint8Array((new TextEncoder()).encode(J))}function p0(J,G,Q){return vJ(J)&&vJ(G)&&vJ(Q)&&G<=J&&J<Q}function L0(J,G,Q,q){if(!p0(G,Q,q))throw new Error("expected valid "+J+": "+Q+" <= n < "+q+", got "+G)}function yJ(J){let G;for(G=0;J>w1;J>>=x1,G+=1);return G}function T7(J,G){return J>>BigInt(G)&x1}function S7(J,G,Q){return J|(Q?x1:w1)<<BigInt(G)}function fJ(J,G,Q){if(typeof J!=="number"||J<2)throw new Error("hashLen must be a number");if(typeof G!=="number"||G<2)throw new Error("qByteLen must be a number");if(typeof Q!=="function")throw new Error("hmacFn must be a function");let q=gJ(J),X=gJ(J),W=0;const Y=()=>{q.fill(1),X.fill(0),W=0},U=(...j)=>Q(X,q,...j),K=(j=gJ())=>{if(X=U(t9([0]),j),q=U(),j.length===0)return;X=U(t9([1]),j),q=U()},V=()=>{if(W++>=1000)throw new Error("drbg: tried 1000 values");let j=0;const z=[];while(j<G){q=U();const $=q.slice();z.push($),j+=q.length}return S0(...z)};return(j,z)=>{Y(),K(j);let $=void 0;while(!($=z(V())))K();return Y(),$}}function l0(J,G,Q={}){const q=(X,W,Y)=>{const U=F7[W];if(typeof U!=="function")throw new Error("invalid validator function");const K=J[X];if(Y&&K===void 0)return;if(!U(K,J))throw new Error("param "+String(X)+" is invalid. Expected "+W+", got "+K)};for(let[X,W]of Object.entries(G))q(X,W,!1);for(let[X,W]of Object.entries(Q))q(X,W,!0);return J}function F1(J){const G=new WeakMap;return(Q,...q)=>{const X=G.get(Q);if(X!==void 0)return X;const W=J(Q,...q);return G.set(Q,W),W}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */var w1=BigInt(0),x1=BigInt(1),k7=BigInt(2),R7=Array.from({length:256},(J,G)=>G.toString(16).padStart(2,"0")),T0={_0:48,_9:57,A:65,F:70,a:97,f:102},vJ=(J)=>typeof J==="bigint"&&w1<=J,t8=(J)=>(k7<<BigInt(J-1))-x1,gJ=(J)=>new Uint8Array(J),t9=(J)=>Uint8Array.from(J),F7={bigint:(J)=>typeof J==="bigint",function:(J)=>typeof J==="function",boolean:(J)=>typeof J==="boolean",string:(J)=>typeof J==="string",stringOrUint8Array:(J)=>typeof J==="string"||c0(J),isSafeInteger:(J)=>Number.isSafeInteger(J),array:(J)=>Array.isArray(J),field:(J,G)=>G.Fp.isValid(J),hash:(J)=>typeof J==="function"&&Number.isSafeInteger(J.outputLen)},v7=()=>{throw new Error("not implemented")};function a(J,G){const Q=J%G;return Q>=s?Q:G+Q}function f7(J,G,Q){if(G<s)throw new Error("invalid exponent, negatives unsupported");if(Q<=s)throw new Error("invalid modulus");if(Q===d)return s;let q=d;while(G>s){if(G&d)q=q*J%Q;J=J*J%Q,G>>=d}return q}function Z0(J,G,Q){let q=J;while(G-- >s)q*=q,q%=Q;return q}function v1(J,G){if(J===s)throw new Error("invert: expected non-zero number");if(G<=s)throw new Error("invert: expected positive modulus, got "+G);let Q=a(J,G),q=G,X=s,W=d,Y=d,U=s;while(Q!==s){const V=q/Q,Z=q%Q,j=X-Y*V,z=W-U*V;q=Q,Q=Z,X=Y,W=U,Y=j,U=z}if(q!==d)throw new Error("invert: does not exist");return a(X,G)}function b7(J){const G=(J-d)/V8;let Q,q,X;for(Q=J-d,q=0;Q%V8===s;Q/=V8,q++);for(X=V8;X<J&&f7(X,G,J)!==J-d;X++)if(X>1000)throw new Error("Cannot find square root: likely non-prime P");if(q===1){const Y=(J+d)/hJ;return function U(K,V){const Z=K.pow(V,Y);if(!K.eql(K.sqr(Z),V))throw new Error("Cannot find square root");return Z}}const W=(Q+d)/V8;return function Y(U,K){if(U.pow(K,G)===U.neg(U.ONE))throw new Error("Cannot find square root");let V=q,Z=U.pow(U.mul(U.ONE,X),Q),j=U.pow(K,W),z=U.pow(K,Q);while(!U.eql(z,U.ONE)){if(U.eql(z,U.ZERO))return U.ZERO;let $=1;for(let M=U.sqr(z);$<V;$++){if(U.eql(M,U.ONE))break;M=U.sqr(M)}const N=U.pow(Z,d<<BigInt(V-$-1));Z=U.sqr(N),j=U.mul(j,N),z=U.mul(z,Z),V=$}return j}}function h7(J){if(J%hJ===g7){const G=(J+d)/hJ;return function Q(q,X){const W=q.pow(X,G);if(!q.eql(q.sqr(W),X))throw new Error("Cannot find square root");return W}}if(J%J5===e9){const G=(J-e9)/J5;return function Q(q,X){const W=q.mul(X,V8),Y=q.pow(W,G),U=q.mul(X,Y),K=q.mul(q.mul(U,V8),Y),V=q.mul(U,q.sub(K,q.ONE));if(!q.eql(q.sqr(V),X))throw new Error("Cannot find square root");return V}}if(J%y7===E7);return b7(J)}function mJ(J){const G={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},Q=m7.reduce((q,X)=>{return q[X]="function",q},G);return l0(J,Q)}function _7(J,G,Q){if(Q<s)throw new Error("invalid exponent, negatives unsupported");if(Q===s)return J.ONE;if(Q===d)return G;let q=J.ONE,X=G;while(Q>s){if(Q&d)q=J.mul(q,X);X=J.sqr(X),Q>>=d}return q}function u7(J,G){const Q=new Array(G.length),q=G.reduce((W,Y,U)=>{if(J.is0(Y))return W;return Q[U]=W,J.mul(W,Y)},J.ONE),X=J.inv(q);return G.reduceRight((W,Y,U)=>{if(J.is0(Y))return W;return Q[U]=J.mul(W,Q[U]),J.mul(W,Y)},X),Q}function _J(J,G){const Q=G!==void 0?G:J.toString(2).length,q=Math.ceil(Q/8);return{nBitLength:Q,nByteLength:q}}function g1(J,G,Q=!1,q={}){if(J<=s)throw new Error("invalid field: expected ORDER > 0, got "+J);const{nBitLength:X,nByteLength:W}=_J(J,G);if(W>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let Y;const U=Object.freeze({ORDER:J,isLE:Q,BITS:X,BYTES:W,MASK:t8(X),ZERO:s,ONE:d,create:(K)=>a(K,J),isValid:(K)=>{if(typeof K!=="bigint")throw new Error("invalid field element: expected bigint, got "+typeof K);return s<=K&&K<J},is0:(K)=>K===s,isOdd:(K)=>(K&d)===d,neg:(K)=>a(-K,J),eql:(K,V)=>K===V,sqr:(K)=>a(K*K,J),add:(K,V)=>a(K+V,J),sub:(K,V)=>a(K-V,J),mul:(K,V)=>a(K*V,J),pow:(K,V)=>_7(U,K,V),div:(K,V)=>a(K*v1(V,J),J),sqrN:(K)=>K*K,addN:(K,V)=>K+V,subN:(K,V)=>K-V,mulN:(K,V)=>K*V,inv:(K)=>v1(K,J),sqrt:q.sqrt||((K)=>{if(!Y)Y=h7(J);return Y(U,K)}),invertBatch:(K)=>u7(U,K),cmov:(K,V,Z)=>Z?V:K,toBytes:(K)=>Q?S1(K,W):P0(K,W),fromBytes:(K)=>{if(K.length!==W)throw new Error("Field.fromBytes: expected "+W+" bytes, got "+K.length);return Q?T1(K):j0(K)}});return Object.freeze(U)}function Q5(J){if(typeof J!=="bigint")throw new Error("field order must be bigint");const G=J.toString(2).length;return Math.ceil(G/8)}function uJ(J){const G=Q5(J);return G+Math.ceil(G/2)}function G5(J,G,Q=!1){const q=J.length,X=Q5(G),W=uJ(G);if(q<16||q<W||q>1024)throw new Error("expected "+W+"-1024 bytes of input, got "+q);const Y=Q?T1(J):j0(J),U=a(Y,G-d)+d;return Q?S1(U,X):P0(U,X)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */var s=BigInt(0),d=BigInt(1),V8=BigInt(2),g7=BigInt(3),hJ=BigInt(4),e9=BigInt(5),J5=BigInt(8),E7=BigInt(9),y7=BigInt(16);var m7=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];var cJ=function(J,G){const Q=G.negate();return J?Q:G},X5=function(J,G){if(!Number.isSafeInteger(J)||J<=0||J>G)throw new Error("invalid window size, expected [1.."+G+"], got W="+J)},pJ=function(J,G){X5(J,G);const Q=Math.ceil(G/J)+1,q=2**(J-1);return{windows:Q,windowSize:q}},c7=function(J,G){if(!Array.isArray(J))throw new Error("array expected");J.forEach((Q,q)=>{if(!(Q instanceof G))throw new Error("invalid point at index "+q)})},p7=function(J,G){if(!Array.isArray(J))throw new Error("array of scalars expected");J.forEach((Q,q)=>{if(!G.isValid(Q))throw new Error("invalid scalar at index "+q)})},dJ=function(J){return W5.get(J)||1};function Y5(J,G){return{constTimeNegate:cJ,hasPrecomputes(Q){return dJ(Q)!==1},unsafeLadder(Q,q,X=J.ZERO){let W=Q;while(q>q5){if(q&E1)X=X.add(W);W=W.double(),q>>=E1}return X},precomputeWindow(Q,q){const{windows:X,windowSize:W}=pJ(q,G),Y=[];let U=Q,K=U;for(let V=0;V<X;V++){K=U,Y.push(K);for(let Z=1;Z<W;Z++)K=K.add(U),Y.push(K);U=K.double()}return Y},wNAF(Q,q,X){const{windows:W,windowSize:Y}=pJ(Q,G);let{ZERO:U,BASE:K}=J;const V=BigInt(2**Q-1),Z=2**Q,j=BigInt(Q);for(let z=0;z<W;z++){const $=z*Y;let N=Number(X&V);if(X>>=j,N>Y)N-=Z,X+=E1;const M=$,H=$+Math.abs(N)-1,A=z%2!==0,k=N<0;if(N===0)K=K.add(cJ(A,q[M]));else U=U.add(cJ(k,q[H]))}return{p:U,f:K}},wNAFUnsafe(Q,q,X,W=J.ZERO){const{windows:Y,windowSize:U}=pJ(Q,G),K=BigInt(2**Q-1),V=2**Q,Z=BigInt(Q);for(let j=0;j<Y;j++){const z=j*U;if(X===q5)break;let $=Number(X&K);if(X>>=Z,$>U)$-=V,X+=E1;if($===0)continue;let N=q[z+Math.abs($)-1];if($<0)N=N.negate();W=W.add(N)}return W},getPrecomputes(Q,q,X){let W=lJ.get(q);if(!W){if(W=this.precomputeWindow(q,Q),Q!==1)lJ.set(q,X(W))}return W},wNAFCached(Q,q,X){const W=dJ(Q);return this.wNAF(W,this.getPrecomputes(W,Q,X),q)},wNAFCachedUnsafe(Q,q,X,W){const Y=dJ(Q);if(Y===1)return this.unsafeLadder(Q,q,W);return this.wNAFUnsafe(Y,this.getPrecomputes(Y,Q,X),q,W)},setWindowSize(Q,q){X5(q,G),W5.set(Q,q),lJ.delete(Q)}}}function U5(J,G,Q,q){if(c7(Q,J),p7(q,G),Q.length!==q.length)throw new Error("arrays of points and scalars must have equal length");const X=J.ZERO,W=yJ(BigInt(Q.length)),Y=W>12?W-3:W>4?W-2:W?2:1,U=(1<<Y)-1,K=new Array(U+1).fill(X),V=Math.floor((G.BITS-1)/Y)*Y;let Z=X;for(let j=V;j>=0;j-=Y){K.fill(X);for(let $=0;$<q.length;$++){const N=q[$],M=Number(N>>BigInt(j)&BigInt(U));K[M]=K[M].add(Q[$])}let z=X;for(let $=K.length-1,N=X;$>0;$--)N=N.add(K[$]),z=z.add(N);if(Z=Z.add(z),j!==0)for(let $=0;$<Y;$++)Z=Z.double()}return Z}function iJ(J){return mJ(J.Fp),l0(J,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({..._J(J.n,J.nBitLength),...J,...{p:J.Fp.ORDER}})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */var q5=BigInt(0),E1=BigInt(1),lJ=new WeakMap,W5=new WeakMap;var V5=function(J){if(J.lowS!==void 0)X8("lowS",J.lowS);if(J.prehash!==void 0)X8("prehash",J.prehash)},l7=function(J){const G=iJ(J);l0(G,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});const{endo:Q,Fp:q,a:X}=G;if(Q){if(!q.eql(X,q.ZERO))throw new Error("invalid endomorphism, can only be defined for Koblitz curves that have a=0");if(typeof Q!=="object"||typeof Q.beta!=="bigint"||typeof Q.splitScalar!=="function")throw new Error("invalid endomorphism, expected beta: bigint and splitScalar: function")}return Object.freeze({...G})};function r7(J){const G=l7(J),{Fp:Q}=G,q=g1(G.n,G.nBitLength),X=G.toBytes||((M,H,A)=>{const k=H.toAffine();return S0(Uint8Array.from([4]),Q.toBytes(k.x),Q.toBytes(k.y))}),W=G.fromBytes||((M)=>{const H=M.subarray(1),A=Q.fromBytes(H.subarray(0,Q.BYTES)),k=Q.fromBytes(H.subarray(Q.BYTES,2*Q.BYTES));return{x:A,y:k}});function Y(M){const{a:H,b:A}=G,k=Q.sqr(M),R=Q.mul(k,M);return Q.add(Q.add(R,Q.mul(M,H)),A)}if(!Q.eql(Q.sqr(G.Gy),Y(G.Gx)))throw new Error("bad generator point: equation left != right");function U(M){return p0(M,e,G.n)}function K(M){const{allowedPrivateKeyLengths:H,nByteLength:A,wrapPrivateKey:k,n:R}=G;if(H&&typeof M!=="bigint"){if(c0(M))M=W8(M);if(typeof M!=="string"||!H.includes(M.length))throw new Error("invalid private key");M=M.padStart(A*2,"0")}let C;try{C=typeof M==="bigint"?M:j0(n("private key",M,A))}catch(T){throw new Error("invalid private key, expected hex or "+A+" bytes, got "+typeof M)}if(k)C=a(C,R);return L0("private key",C,e,R),C}function V(M){if(!(M instanceof z))throw new Error("ProjectivePoint expected")}const Z=F1((M,H)=>{const{px:A,py:k,pz:R}=M;if(Q.eql(R,Q.ONE))return{x:A,y:k};const C=M.is0();if(H==null)H=C?Q.ONE:Q.inv(R);const T=Q.mul(A,H),x=Q.mul(k,H),L=Q.mul(R,H);if(C)return{x:Q.ZERO,y:Q.ZERO};if(!Q.eql(L,Q.ONE))throw new Error("invZ was invalid");return{x:T,y:x}}),j=F1((M)=>{if(M.is0()){if(G.allowInfinityPoint&&!Q.is0(M.py))return;throw new Error("bad point: ZERO")}const{x:H,y:A}=M.toAffine();if(!Q.isValid(H)||!Q.isValid(A))throw new Error("bad point: x or y not FE");const k=Q.sqr(A),R=Y(H);if(!Q.eql(k,R))throw new Error("bad point: equation left != right");if(!M.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});class z{constructor(M,H,A){if(this.px=M,this.py=H,this.pz=A,M==null||!Q.isValid(M))throw new Error("x required");if(H==null||!Q.isValid(H))throw new Error("y required");if(A==null||!Q.isValid(A))throw new Error("z required");Object.freeze(this)}static fromAffine(M){const{x:H,y:A}=M||{};if(!M||!Q.isValid(H)||!Q.isValid(A))throw new Error("invalid affine point");if(M instanceof z)throw new Error("projective point not allowed");const k=(R)=>Q.eql(R,Q.ZERO);if(k(H)&&k(A))return z.ZERO;return new z(H,A,Q.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(M){const H=Q.invertBatch(M.map((A)=>A.pz));return M.map((A,k)=>A.toAffine(H[k])).map(z.fromAffine)}static fromHex(M){const H=z.fromAffine(W(n("pointHex",M)));return H.assertValidity(),H}static fromPrivateKey(M){return z.BASE.multiply(K(M))}static msm(M,H){return U5(z,q,M,H)}_setWindowSize(M){N.setWindowSize(this,M)}assertValidity(){j(this)}hasEvenY(){const{y:M}=this.toAffine();if(Q.isOdd)return!Q.isOdd(M);throw new Error("Field doesn't support isOdd")}equals(M){V(M);const{px:H,py:A,pz:k}=this,{px:R,py:C,pz:T}=M,x=Q.eql(Q.mul(H,T),Q.mul(R,k)),L=Q.eql(Q.mul(A,T),Q.mul(C,k));return x&&L}negate(){return new z(this.px,Q.neg(this.py),this.pz)}double(){const{a:M,b:H}=G,A=Q.mul(H,K5),{px:k,py:R,pz:C}=this;let{ZERO:T,ZERO:x,ZERO:L}=Q,I=Q.mul(k,k),E=Q.mul(R,R),w=Q.mul(C,C),F=Q.mul(k,R);return F=Q.add(F,F),L=Q.mul(k,C),L=Q.add(L,L),T=Q.mul(M,L),x=Q.mul(A,w),x=Q.add(T,x),T=Q.sub(E,x),x=Q.add(E,x),x=Q.mul(T,x),T=Q.mul(F,T),L=Q.mul(A,L),w=Q.mul(M,w),F=Q.sub(I,w),F=Q.mul(M,F),F=Q.add(F,L),L=Q.add(I,I),I=Q.add(L,I),I=Q.add(I,w),I=Q.mul(I,F),x=Q.add(x,I),w=Q.mul(R,C),w=Q.add(w,w),I=Q.mul(w,F),T=Q.sub(T,I),L=Q.mul(w,E),L=Q.add(L,L),L=Q.add(L,L),new z(T,x,L)}add(M){V(M);const{px:H,py:A,pz:k}=this,{px:R,py:C,pz:T}=M;let{ZERO:x,ZERO:L,ZERO:I}=Q;const E=G.a,w=Q.mul(G.b,K5);let F=Q.mul(H,R),O=Q.mul(A,C),S=Q.mul(k,T),P=Q.add(H,A),B=Q.add(R,C);P=Q.mul(P,B),B=Q.add(F,O),P=Q.sub(P,B),B=Q.add(H,k);let D=Q.add(R,T);return B=Q.mul(B,D),D=Q.add(F,S),B=Q.sub(B,D),D=Q.add(A,k),x=Q.add(C,T),D=Q.mul(D,x),x=Q.add(O,S),D=Q.sub(D,x),I=Q.mul(E,B),x=Q.mul(w,S),I=Q.add(x,I),x=Q.sub(O,I),I=Q.add(O,I),L=Q.mul(x,I),O=Q.add(F,F),O=Q.add(O,F),S=Q.mul(E,S),B=Q.mul(w,B),O=Q.add(O,S),S=Q.sub(F,S),S=Q.mul(E,S),B=Q.add(B,S),F=Q.mul(O,B),L=Q.add(L,F),F=Q.mul(D,B),x=Q.mul(P,x),x=Q.sub(x,F),F=Q.mul(P,O),I=Q.mul(D,I),I=Q.add(I,F),new z(x,L,I)}subtract(M){return this.add(M.negate())}is0(){return this.equals(z.ZERO)}wNAF(M){return N.wNAFCached(this,M,z.normalizeZ)}multiplyUnsafe(M){const{endo:H,n:A}=G;L0("scalar",M,v0,A);const k=z.ZERO;if(M===v0)return k;if(this.is0()||M===e)return this;if(!H||N.hasPrecomputes(this))return N.wNAFCachedUnsafe(this,M,z.normalizeZ);let{k1neg:R,k1:C,k2neg:T,k2:x}=H.splitScalar(M),L=k,I=k,E=this;while(C>v0||x>v0){if(C&e)L=L.add(E);if(x&e)I=I.add(E);E=E.double(),C>>=e,x>>=e}if(R)L=L.negate();if(T)I=I.negate();return I=new z(Q.mul(I.px,H.beta),I.py,I.pz),L.add(I)}multiply(M){const{endo:H,n:A}=G;L0("scalar",M,e,A);let k,R;if(H){const{k1neg:C,k1:T,k2neg:x,k2:L}=H.splitScalar(M);let{p:I,f:E}=this.wNAF(T),{p:w,f:F}=this.wNAF(L);I=N.constTimeNegate(C,I),w=N.constTimeNegate(x,w),w=new z(Q.mul(w.px,H.beta),w.py,w.pz),k=I.add(w),R=E.add(F)}else{const{p:C,f:T}=this.wNAF(M);k=C,R=T}return z.normalizeZ([k,R])[0]}multiplyAndAddUnsafe(M,H,A){const k=z.BASE,R=(T,x)=>x===v0||x===e||!T.equals(k)?T.multiplyUnsafe(x):T.multiply(x),C=R(this,H).add(R(M,A));return C.is0()?void 0:C}toAffine(M){return Z(this,M)}isTorsionFree(){const{h:M,isTorsionFree:H}=G;if(M===e)return!0;if(H)return H(z,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:M,clearCofactor:H}=G;if(M===e)return this;if(H)return H(z,this);return this.multiplyUnsafe(G.h)}toRawBytes(M=!0){return X8("isCompressed",M),this.assertValidity(),X(z,this,M)}toHex(M=!0){return X8("isCompressed",M),W8(this.toRawBytes(M))}}z.BASE=new z(G.Gx,G.Gy,Q.ONE),z.ZERO=new z(Q.ZERO,Q.ONE,Q.ZERO);const $=G.nBitLength,N=Y5(z,G.endo?Math.ceil($/2):$);return{CURVE:G,ProjectivePoint:z,normPrivateKeyToScalar:K,weierstrassEquation:Y,isWithinCurveOrder:U}}var o7=function(J){const G=iJ(J);return l0(G,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...G})};function $5(J){const G=o7(J),{Fp:Q,n:q}=G,X=Q.BYTES+1,W=2*Q.BYTES+1;function Y(P){return a(P,q)}function U(P){return v1(P,q)}const{ProjectivePoint:K,normPrivateKeyToScalar:V,weierstrassEquation:Z,isWithinCurveOrder:j}=r7({...G,toBytes(P,B,D){const v=B.toAffine(),g=Q.toBytes(v.x),y=S0;if(X8("isCompressed",D),D)return y(Uint8Array.from([B.hasEvenY()?2:3]),g);else return y(Uint8Array.from([4]),g,Q.toBytes(v.y))},fromBytes(P){const B=P.length,D=P[0],v=P.subarray(1);if(B===X&&(D===2||D===3)){const g=j0(v);if(!p0(g,e,Q.ORDER))throw new Error("Point is not on curve");const y=Z(g);let _;try{_=Q.sqrt(y)}catch(r){const m=r instanceof Error?": "+r.message:"";throw new Error("Point is not on curve"+m)}const c=(_&e)===e;if((D&1)===1!==c)_=Q.neg(_);return{x:g,y:_}}else if(B===W&&D===4){const g=Q.fromBytes(v.subarray(0,Q.BYTES)),y=Q.fromBytes(v.subarray(Q.BYTES,2*Q.BYTES));return{x:g,y}}else{const g=X,y=W;throw new Error("invalid Point, expected length of "+g+", or uncompressed "+y+", got "+B)}}}),z=(P)=>W8(P0(P,G.nByteLength));function $(P){const B=q>>e;return P>B}function N(P){return $(P)?Y(-P):P}const M=(P,B,D)=>j0(P.slice(B,D));class H{constructor(P,B,D){this.r=P,this.s=B,this.recovery=D,this.assertValidity()}static fromCompact(P){const B=G.nByteLength;return P=n("compactSignature",P,B*2),new H(M(P,0,B),M(P,B,2*B))}static fromDER(P){const{r:B,s:D}=F0.toSig(n("DER",P));return new H(B,D)}assertValidity(){L0("r",this.r,e,q),L0("s",this.s,e,q)}addRecoveryBit(P){return new H(this.r,this.s,P)}recoverPublicKey(P){const{r:B,s:D,recovery:v}=this,g=x(n("msgHash",P));if(v==null||![0,1,2,3].includes(v))throw new Error("recovery id invalid");const y=v===2||v===3?B+G.n:B;if(y>=Q.ORDER)throw new Error("recovery id 2 or 3 invalid");const _=(v&1)===0?"02":"03",c=K.fromHex(_+z(y)),f=U(y),r=Y(-g*f),m=Y(D*f),i=K.BASE.multiplyAndAddUnsafe(c,r,m);if(!i)throw new Error("point at infinify");return i.assertValidity(),i}hasHighS(){return $(this.s)}normalizeS(){return this.hasHighS()?new H(this.r,Y(-this.s),this.recovery):this}toDERRawBytes(){return U8(this.toDERHex())}toDERHex(){return F0.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return U8(this.toCompactHex())}toCompactHex(){return z(this.r)+z(this.s)}}const A={isValidPrivateKey(P){try{return V(P),!0}catch(B){return!1}},normPrivateKeyToScalar:V,randomPrivateKey:()=>{const P=uJ(G.n);return G5(G.randomBytes(P),G.n)},precompute(P=8,B=K.BASE){return B._setWindowSize(P),B.multiply(BigInt(3)),B}};function k(P,B=!0){return K.fromPrivateKey(P).toRawBytes(B)}function R(P){const B=c0(P),D=typeof P==="string",v=(B||D)&&P.length;if(B)return v===X||v===W;if(D)return v===2*X||v===2*W;if(P instanceof K)return!0;return!1}function C(P,B,D=!0){if(R(P))throw new Error("first arg must be private key");if(!R(B))throw new Error("second arg must be public key");return K.fromHex(B).multiply(V(P)).toRawBytes(D)}const T=G.bits2int||function(P){if(P.length>8192)throw new Error("input is too large");const B=j0(P),D=P.length*8-G.nBitLength;return D>0?B>>BigInt(D):B},x=G.bits2int_modN||function(P){return Y(T(P))},L=t8(G.nBitLength);function I(P){return L0("num < 2^"+G.nBitLength,P,v0,L),P0(P,G.nByteLength)}function E(P,B,D=w){if(["recovered","canonical"].some((G0)=>(G0 in D)))throw new Error("sign() legacy options not supported");const{hash:v,randomBytes:g}=G;let{lowS:y,prehash:_,extraEntropy:c}=D;if(y==null)y=!0;if(P=n("msgHash",P),V5(D),_)P=n("prehashed msgHash",v(P));const f=x(P),r=V(B),m=[I(r),I(f)];if(c!=null&&c!==!1){const G0=c===!0?g(Q.BYTES):c;m.push(n("extraEntropy",G0))}const i=S0(...m),u=f;function l(G0){const o=T(G0);if(!j(o))return;const Y0=U(o),U0=K.BASE.multiply(o).toAffine(),J0=Y(U0.x);if(J0===v0)return;const r0=Y(Y0*Y(u+J0*r));if(r0===v0)return;let R0=(U0.x===J0?0:2)|Number(U0.y&e),MQ=r0;if(y&&$(r0))MQ=N(r0),R0^=1;return new H(J0,MQ,R0)}return{seed:i,k2sig:l}}const w={lowS:G.lowS,prehash:!1},F={lowS:G.lowS,prehash:!1};function O(P,B,D=w){const{seed:v,k2sig:g}=E(P,B,D),y=G;return fJ(y.hash.outputLen,y.nByteLength,y.hmac)(v,g)}K.BASE._setWindowSize(8);function S(P,B,D,v=F){const g=P;B=n("msgHash",B),D=n("publicKey",D);const{lowS:y,prehash:_,format:c}=v;if(V5(v),("strict"in v))throw new Error("options.strict was renamed to lowS");if(c!==void 0&&c!=="compact"&&c!=="der")throw new Error("format must be compact or der");const f=typeof g==="string"||c0(g),r=!f&&!c&&typeof g==="object"&&g!==null&&typeof g.r==="bigint"&&typeof g.s==="bigint";if(!f&&!r)throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");let m=void 0,i;try{if(r)m=new H(g.r,g.s);if(f){try{if(c!=="compact")m=H.fromDER(g)}catch(R0){if(!(R0 instanceof F0.Err))throw R0}if(!m&&c!=="der")m=H.fromCompact(g)}i=K.fromHex(D)}catch(R0){return!1}if(!m)return!1;if(y&&m.hasHighS())return!1;if(_)B=G.hash(B);const{r:u,s:l}=m,G0=x(B),o=U(l),Y0=Y(G0*o),U0=Y(u*o),J0=K.BASE.multiplyAndAddUnsafe(i,Y0,U0)?.toAffine();if(!J0)return!1;return Y(J0.x)===u}return{CURVE:G,getPublicKey:k,getSharedSecret:C,sign:O,verify:S,ProjectivePoint:K,Signature:H,utils:A}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */var{bytesToNumberBE:d7,hexToBytes:i7}=bJ;class Z5 extends Error{constructor(J=""){super(J)}}var F0={Err:Z5,_tlv:{encode:(J,G)=>{const{Err:Q}=F0;if(J<0||J>256)throw new Q("tlv.encode: wrong tag");if(G.length&1)throw new Q("tlv.encode: unpadded data");const q=G.length/2,X=Y8(q);if(X.length/2&128)throw new Q("tlv.encode: long form length too big");const W=q>127?Y8(X.length/2|128):"";return Y8(J)+W+X+G},decode(J,G){const{Err:Q}=F0;let q=0;if(J<0||J>256)throw new Q("tlv.encode: wrong tag");if(G.length<2||G[q++]!==J)throw new Q("tlv.decode: wrong tlv");const X=G[q++],W=!!(X&128);let Y=0;if(!W)Y=X;else{const K=X&127;if(!K)throw new Q("tlv.decode(long): indefinite length not supported");if(K>4)throw new Q("tlv.decode(long): byte length is too big");const V=G.subarray(q,q+K);if(V.length!==K)throw new Q("tlv.decode: length bytes not complete");if(V[0]===0)throw new Q("tlv.decode(long): zero leftmost byte");for(let Z of V)Y=Y<<8|Z;if(q+=K,Y<128)throw new Q("tlv.decode(long): not minimal encoding")}const U=G.subarray(q,q+Y);if(U.length!==Y)throw new Q("tlv.decode: wrong value length");return{v:U,l:G.subarray(q+Y)}}},_int:{encode(J){const{Err:G}=F0;if(J<v0)throw new G("integer: negative integers are not allowed");let Q=Y8(J);if(Number.parseInt(Q[0],16)&8)Q="00"+Q;if(Q.length&1)throw new G("unexpected DER parsing assertion: unpadded hex");return Q},decode(J){const{Err:G}=F0;if(J[0]&128)throw new G("invalid signature integer: negative");if(J[0]===0&&!(J[1]&128))throw new G("invalid signature integer: unnecessary leading zero");return d7(J)}},toSig(J){const{Err:G,_int:Q,_tlv:q}=F0,X=typeof J==="string"?i7(J):J;R8(X);const{v:W,l:Y}=q.decode(48,X);if(Y.length)throw new G("invalid signature: left bytes after parsing");const{v:U,l:K}=q.decode(2,W),{v:V,l:Z}=q.decode(2,K);if(Z.length)throw new G("invalid signature: left bytes after parsing");return{r:Q.decode(U),s:Q.decode(V)}},hexFromSig(J){const{_tlv:G,_int:Q}=F0,q=G.encode(2,Q.encode(J.r)),X=G.encode(2,Q.encode(J.s)),W=q+X;return G.encode(48,W)}},v0=BigInt(0),e=BigInt(1),FW=BigInt(2),K5=BigInt(3),vW=BigInt(4);function n7(J){return{hash:J,hmac:(G,...Q)=>FJ(J,G,i9(...Q)),randomBytes:R1}}function z5(J,G){const Q=(q)=>$5({...J,...n7(q)});return{...Q(G),create:Q}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */var H5=function(J){const G=Q1,Q=BigInt(3),q=BigInt(6),X=BigInt(11),W=BigInt(22),Y=BigInt(23),U=BigInt(44),K=BigInt(88),V=J*J*J%G,Z=V*V*J%G,j=Z0(Z,Q,G)*Z%G,z=Z0(j,Q,G)*Z%G,$=Z0(z,f1,G)*V%G,N=Z0($,X,G)*$%G,M=Z0(N,W,G)*N%G,H=Z0(M,U,G)*M%G,A=Z0(H,K,G)*H%G,k=Z0(A,U,G)*M%G,R=Z0(k,Q,G)*Z%G,C=Z0(R,Y,G)*N%G,T=Z0(C,q,G)*V%G,x=Z0(T,f1,G);if(!oJ.eql(oJ.sqr(x),J))throw new Error("Cannot find square root");return x},b1=function(J,...G){let Q=M5[J];if(Q===void 0){const q=I1(Uint8Array.from(J,(X)=>X.charCodeAt(0)));Q=S0(q,q),M5[J]=Q}return I1(S0(Q,...G))},aJ=function(J){let G=sJ.utils.normPrivateKeyToScalar(J),Q=eJ.fromPrivateKey(G);return{scalar:Q.hasEvenY()?G:J1(-G),bytes:tJ(Q)}},C5=function(J){L0("x",J,e8,Q1);const G=rJ(J*J),Q=rJ(G*J+BigInt(7));let q=H5(Q);if(q%f1!==P5)q=rJ(-q);const X=new eJ(J,q,e8);return X.assertValidity(),X},D5=function(...J){return J1(I8(b1("BIP0340/challenge",...J)))},s7=function(J){return aJ(J).bytes},t7=function(J,G,Q=R1(32)){const q=n("message",J),{bytes:X,scalar:W}=aJ(G),Y=n("auxRand",Q,32),U=nJ(W^I8(b1("BIP0340/aux",Y))),K=b1("BIP0340/nonce",U,X,q),V=J1(I8(K));if(V===P5)throw new Error("sign failed: k is zero");const{bytes:Z,scalar:j}=aJ(V),z=D5(Z,X,q),$=new Uint8Array(64);if($.set(Z,0),$.set(nJ(J1(j+z*W)),32),!N5($,q,X))throw new Error("sign: Invalid signature produced");return $},N5=function(J,G,Q){const q=n("signature",J,64),X=n("message",G),W=n("publicKey",Q,32);try{const Y=C5(I8(W)),U=I8(q.subarray(0,32));if(!p0(U,e8,Q1))return!1;const K=I8(q.subarray(32,64));if(!p0(K,e8,y1))return!1;const V=D5(nJ(U),tJ(Y),X),Z=a7(Y,K,J1(-V));if(!Z||!Z.hasEvenY()||Z.toAffine().x!==U)return!1;return!0}catch(Y){return!1}};/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */var Q1=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),y1=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),e8=BigInt(1),f1=BigInt(2),j5=(J,G)=>(J+G/f1)/G,oJ=g1(Q1,void 0,void 0,{sqrt:H5}),sJ=z5({a:BigInt(0),b:BigInt(7),Fp:oJ,n:y1,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:(J)=>{const G=y1,Q=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),q=-e8*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),X=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),W=Q,Y=BigInt("0x100000000000000000000000000000000"),U=j5(W*J,G),K=j5(-q*J,G);let V=a(J-U*Q-K*X,G),Z=a(-U*q-K*W,G);const j=V>Y,z=Z>Y;if(j)V=G-V;if(z)Z=G-Z;if(V>Y||Z>Y)throw new Error("splitScalar: Endomorphism failed, k="+J);return{k1neg:j,k1:V,k2neg:z,k2:Z}}}},I1),P5=BigInt(0),M5={},tJ=(J)=>J.toRawBytes(!0).slice(1),nJ=(J)=>P0(J,32),rJ=(J)=>a(J,Q1),J1=(J)=>a(J,y1),eJ=sJ.ProjectivePoint,a7=(J,G,Q)=>eJ.BASE.multiplyAndAddUnsafe(J,G,Q),I8=j0,h1=(()=>({getPublicKey:s7,sign:t7,verify:N5,utils:{randomPrivateKey:sJ.utils.randomPrivateKey,lift_x:C5,pointToBytes:tJ,numberToBytesBE:P0,bytesToNumberBE:j0,taggedHash:b1,mod:a}}))();var{floor:JQ,random:e7,sin:JX}=Math,K8="Trystero",d0=(J,G)=>Array(J).fill().map(G);var _1=(J)=>d0(J,()=>"0123456789AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz"[JQ(e7()*"0123456789AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz".length)]).join(""),A0=_1(20),i0=Promise.all.bind(Promise),O5=typeof window!=="undefined",{entries:u1,fromEntries:QQ,keys:B5}=Object,g0=()=>{},C0=(J)=>new Error(`Trystero: ${J}`),QX=new TextEncoder,GX=new TextDecoder,k0=(J)=>QX.encode(J),w8=(J)=>GX.decode(J),c1=(J)=>J.reduce((G,Q)=>G+Q.toString(16).padStart(2,"0"),""),G1=(...J)=>J.join("@"),qX=(J,G)=>{const Q=[...J],q=()=>{const W=JX(G++)*1e4;return W-JQ(W)};let X=Q.length;while(X){const W=JQ(q()*X--);[Q[X],Q[W]]=[Q[W],Q[X]]}return Q},L5=(J,G,Q,q)=>{return(J.relayUrls||(q?qX(G,GQ(J.appId)):G)).slice(0,J.relayUrls?J.relayUrls.length:J.relayRedundancy||Q)},M0=JSON.stringify,Z8=JSON.parse,GQ=(J,G=Number.MAX_SAFE_INTEGER)=>J.split("").reduce((Q,q)=>Q+q.charCodeAt(0),0)%G;var m1={},A5=(J,G)=>{const Q={},q=()=>{const X=new WebSocket(J);X.onclose=()=>{m1[J]??=3333,setTimeout(q,m1[J]),m1[J]*=2},X.onmessage=(W)=>G(W.data),Q.socket=X,Q.url=X.url,Q.ready=new Promise((W)=>X.onopen=()=>{W(Q),m1[J]=3333}),Q.send=(W)=>{if(X.readyState===1)X.send(W)}};return q(),Q},k5=(J)=>()=>QQ(u1(J).map(([G,Q])=>[G,Q.socket]));var qQ="AES-GCM",R5={},XX=(J)=>btoa(String.fromCharCode.apply(null,new Uint8Array(J))),WX=(J)=>{const G=atob(J);return new Uint8Array(G.length).map((Q,q)=>G.charCodeAt(q)).buffer},q1=async(J)=>R5[J]||(R5[J]=Array.from(new Uint8Array(await crypto.subtle.digest("SHA-1",k0(J)))).map((G)=>G.toString(36)).join("")),I5=async(J,G,Q)=>crypto.subtle.importKey("raw",await crypto.subtle.digest({name:"SHA-256"},k0(`${J}:${G}:${Q}`)),{name:qQ},!1,["encrypt","decrypt"]),w5="$",x5=",",T5=async(J,G)=>{const Q=crypto.getRandomValues(new Uint8Array(16));return Q.join(x5)+w5+XX(await crypto.subtle.encrypt({name:qQ,iv:Q},await J,k0(G)))},S5=async(J,G)=>{const[Q,q]=G.split(w5);return w8(await crypto.subtle.decrypt({name:qQ,iv:new Uint8Array(Q.split(x5))},await J,WX(q)))};var YX=5000,F5="icegatheringstatechange",XQ=(J)=>J.replace(/a=ice-options:trickle\s\n/g,""),WQ=(J,{rtcConfig:G,rtcPolyfill:Q,turnConfig:q})=>{const X=new(Q||RTCPeerConnection)({iceServers:UX.concat(q||[]),...G}),W={},Y=(j)=>{j.binaryType="arraybuffer",j.bufferedAmountLowThreshold=65535,j.onmessage=(z)=>W.data?.(z.data),j.onopen=()=>W.connect?.(),j.onclose=()=>W.close?.(),j.onerror=(z)=>W.error?.(z)},U=async(j)=>{if(!j.localDescription)throw new Error("No local description available");return await Promise.race([new Promise((z)=>{const $=()=>{if(j.iceGatheringState==="complete")j.removeEventListener(F5,$),z()};j.addEventListener(F5,$),$()}),new Promise((z)=>setTimeout(z,YX))]),{type:j.localDescription.type,sdp:XQ(j.localDescription.sdp)}};let K=!1,V=null,Z=!1;if(J)V=X.createDataChannel("data"),Y(V);else X.ondatachannel=({channel:j})=>{V=j,Y(j)};return X.onnegotiationneeded=async()=>{try{K=!0,await X.setLocalDescription();const j=await U(X);W.signal?.({type:j.type,sdp:XQ(j.sdp)})}catch(j){W.error?.(j)}finally{K=!1}},X.onconnectionstatechange=()=>{if(["disconnected","failed","closed"].includes(X.connectionState))W.close?.()},X.ontrack=(j)=>{W.track?.(j.track,j.streams[0]),W.stream?.(j.streams[0])},X.onremovestream=(j)=>{W.stream?.(j.stream,{removed:!0})},{created:Date.now(),connection:X,get channel(){return V},get isDead(){return X.connectionState==="closed"},async signal(j){if(V?.readyState==="open"){if(j.type==="offer"||X.signalingState!=="stable"){if(await X.setRemoteDescription(j),j.type==="offer"){await X.setLocalDescription();const z=await U(X);return W.signal?.({type:z.type,sdp:z.sdp}),{type:z.type,sdp:z.sdp}}}return}try{if(j.type==="offer"){if(K||X.signalingState!=="stable"){if(Z=!J,Z)return}await X.setRemoteDescription(j),await X.setLocalDescription();const z=await U(X),$=XQ(z.sdp);return W.signal?.({type:z.type,sdp:$}),{type:z.type,sdp:$}}else if(j.type==="answer"&&(X.signalingState==="have-local-offer"||X.signalingState==="have-remote-offer"))await X.setRemoteDescription(j)}catch(z){W.error?.(z)}},sendData:(j)=>V.send(j),destroy:()=>{if(V)V.close();X.close()},setHandlers:(j)=>Object.assign(W,j),offerPromise:J?new Promise((j)=>{const z=($)=>{if($.type==="offer")j($)};W.signal=z}):Promise.resolve(),addStream:(j)=>{j.getTracks().forEach((z)=>X.addTrack(z,j))},removeStream:(j)=>{X.getSenders().filter((z)=>j.getTracks().includes(z.track)).forEach((z)=>X.removeTrack(z))},addTrack:(j,z)=>X.addTrack(j,z),removeTrack:(j)=>{const z=X.getSenders().find(($)=>$.track===j);if(z)X.removeTrack(z)},replaceTrack:async(j,z)=>{const $=X.getSenders().find((N)=>N.track===j);if($)await $.replaceTrack(z)}}},UX=[...d0(3,(J,G)=>`stun:stun${G||""}.l.google.com:19302`),"stun:global.stun.twilio.com:3478"].map((J)=>({urls:J}));var VX=Object.getPrototypeOf(Uint8Array),l1=12,g5=0,d1=g5+l1,i1=d1+1,X1=i1+1,W1=X1+1,$8=16384-W1,p1=255,v5="bufferedamountlow",x8=(J)=>"@_"+J,E5=(J,G,Q)=>{const q={},X={},W={},Y={},U={},K={},V={},Z={onPeerJoin:g0,onPeerLeave:g0,onPeerStream:g0,onPeerTrack:g0},j=(O,S)=>(O?Array.isArray(O)?O:[O]:B5(q)).flatMap((P)=>{const B=q[P];if(!B)return console.warn(`${K8}: no peer with id ${P} found`),[];return S(P,B)}),z=(O)=>{if(!q[O])return;delete q[O],delete Y[O],delete U[O],Z.onPeerLeave(O),G(O)},$=(O)=>{if(X[O])return W[O];if(!O)throw C0("action type argument is required");const S=k0(O);if(S.byteLength>l1)throw C0(`action type string "${O}" (${S.byteLength}b) exceeds `+`byte limit (${l1}). Hint: choose a shorter name.`);const P=new Uint8Array(l1);P.set(S);let B=0;return X[O]={onComplete:g0,onProgress:g0,setOnComplete:(D)=>X[O]={...X[O],onComplete:D},setOnProgress:(D)=>X[O]={...X[O],onProgress:D},send:async(D,v,g,y)=>{if(g&&typeof g!=="object")throw C0("action meta argument must be an object");const _=typeof D;if(_==="undefined")throw C0("action data cannot be undefined");const c=_!=="string",f=D instanceof Blob,r=f||D instanceof ArrayBuffer||D instanceof VX;if(g&&!r)throw C0("action meta argument can only be used with binary data");const m=r?new Uint8Array(f?await D.arrayBuffer():D):k0(c?M0(D):D),i=g?k0(M0(g)):null,u=Math.ceil(m.byteLength/$8)+(g?1:0)||1,l=d0(u,(G0,o)=>{const Y0=o===u-1,U0=g&&o===0,J0=new Uint8Array(W1+(U0?i.byteLength:Y0?m.byteLength-$8*(u-(g?2:1)):$8));return J0.set(P),J0.set([B],d1),J0.set([Y0|U0<<1|r<<2|c<<3],i1),J0.set([Math.round((o+1)/u*p1)],X1),J0.set(g?U0?i:m.subarray((o-1)*$8,o*$8):m.subarray(o*$8,(o+1)*$8),W1),J0});return B=B+1&p1,i0(j(v,async(G0,o)=>{const{channel:Y0}=o;let U0=0;while(U0<u){const J0=l[U0];if(Y0.bufferedAmount>Y0.bufferedAmountLowThreshold)await new Promise((r0)=>{const R0=()=>{Y0.removeEventListener(v5,R0),r0()};Y0.addEventListener(v5,R0)});if(!q[G0])break;o.sendData(J0),U0++,y?.(J0[X1]/p1,G0,g)}}))}},W[O]||=[X[O].send,X[O].setOnComplete,X[O].setOnProgress]},N=(O,S)=>{const P=new Uint8Array(S),B=w8(P.subarray(g5,d1)).replaceAll("\0",""),[D]=P.subarray(d1,i1),[v]=P.subarray(i1,X1),[g]=P.subarray(X1,W1),y=P.subarray(W1),_=!!(v&1),c=!!(v&1<<1),f=!!(v&1<<2),r=!!(v&1<<3);if(!X[B]){console.warn(`${K8}: received message with unregistered type (${B})`);return}Y[O]||={},Y[O][B]||={};const m=Y[O][B][D]||={chunks:[]};if(c)m.meta=Z8(w8(y));else m.chunks.push(y);if(X[B].onProgress(g/p1,O,m.meta),!_)return;const i=new Uint8Array(m.chunks.reduce((u,l)=>u+l.byteLength,0));if(m.chunks.reduce((u,l)=>{return i.set(l,u),u+l.byteLength},0),delete Y[O][B][D],f)X[B].onComplete(i,O,m.meta);else{const u=w8(i);X[B].onComplete(r?Z8(u):u,O)}},M=async()=>{await w(""),await new Promise((O)=>setTimeout(O,99)),u1(q).forEach(([O,S])=>{S.destroy(),delete q[O]}),Q()},[H,A]=$(x8("ping")),[k,R]=$(x8("pong")),[C,T]=$(x8("signal")),[x,L]=$(x8("stream")),[I,E]=$(x8("track")),[w,F]=$(x8("leave"));if(J((O,S)=>{if(q[S])return;q[S]=O,O.setHandlers({data:(P)=>N(S,P),stream:(P)=>{Z.onPeerStream(P,S,K[S]),delete K[S]},track:(P,B)=>{Z.onPeerTrack(P,B,S,V[S]),delete V[S]},signal:(P)=>C(P,S),close:()=>z(S),error:()=>z(S)}),Z.onPeerJoin(S),O.drainEarlyData?.((P)=>N(S,P))}),A((O,S)=>k("",S)),R((O,S)=>{U[S]?.(),delete U[S]}),T((O,S)=>q[S]?.signal(O)),L((O,S)=>K[S]=O),E((O,S)=>V[S]=O),F((O,S)=>z(S)),O5)addEventListener("beforeunload",M);return{makeAction:$,leave:M,ping:async(O)=>{if(!O)throw C0("ping() must be called with target peer ID");const S=Date.now();return H("",O),await new Promise((P)=>U[O]=P),Date.now()-S},getPeers:()=>QQ(u1(q).map(([O,S])=>[O,S.connection])),addStream:(O,S,P)=>j(S,async(B,D)=>{if(P)await x(P,B);D.addStream(O)}),removeStream:(O,S)=>j(S,(P,B)=>B.removeStream(O)),addTrack:(O,S,P,B)=>j(P,async(D,v)=>{if(B)await I(B,D);v.addTrack(O,S)}),removeTrack:(O,S,P)=>j(P,(B,D)=>D.removeTrack(O,S)),replaceTrack:(O,S,P,B,D)=>j(B,async(v,g)=>{if(D)await I(D,v);g.replaceTrack(O,S,P)}),onPeerJoin:(O)=>Z.onPeerJoin=O,onPeerLeave:(O)=>Z.onPeerLeave=O,onPeerStream:(O)=>Z.onPeerStream=O,onPeerTrack:(O)=>Z.onPeerTrack=O}};var KX=20,ZX=5333,y5=57333,f5=({init:J,subscribe:G,announce:Q})=>{const q={};let X=!1,W,Y,U;return(K,V,Z)=>{const{appId:j}=K;if(q[j]?.[V])return q[j][V];const z={},$={},N=G1(K8,j,V),M=q1(N),H=q1(G1(N,A0)),A=I5(K.password||"",j,V),k=(D)=>async(v)=>({type:v.type,sdp:await D(A,v.sdp)}),R=k(S5),C=k(T5),T=()=>WQ(!0,K),x=(D,v,g)=>{if($[v]){if($[v]!==D)D.destroy();return}$[v]=D,B(D,v),z[v]?.forEach((y,_)=>{if(_!==g)y.destroy()}),delete z[v]},L=(D,v)=>{if($[v]===D)delete $[v]},I=(D,v)=>{if($[D])return;const g=z[D]?.[v];if(g)delete z[D][v],g.destroy()},E=(D)=>{return Y.push(...d0(D,T)),i0(Y.splice(0,D).map((v)=>v.offerPromise.then(C).then((g)=>({peer:v,offer:g}))))},w=(D,v)=>Z?.({error:`incorrect password (${K.password}) when decrypting ${v}`,appId:j,peerId:D,roomId:V}),F=(D)=>async(v,g,y)=>{const[_,c]=await i0([M,H]);if(v!==_&&v!==c)return;const{peerId:f,offer:r,answer:m,peer:i}=typeof g==="string"?Z8(g):g;if(f===A0||$[f])return;if(f&&!r&&!m){if(z[f]?.[D])return;const[[{peer:u,offer:l}],G0]=await i0([E(1),q1(G1(N,f))]);z[f]||=[],z[f][D]=u,setTimeout(()=>I(f,D),O[D]*0.9),u.setHandlers({connect:()=>x(u,f,D),close:()=>L(u,f)}),y(G0,M0({peerId:A0,offer:l}))}else if(r){if(z[f]?.[D]&&A0>f)return;const l=WQ(!1,K);l.setHandlers({connect:()=>x(l,f,D),close:()=>L(l,f)});let G0;try{G0=await R(r)}catch{w(f,"offer");return}if(l.isDead)return;const[o,Y0]=await i0([q1(G1(N,f)),l.signal(G0)]);y(o,M0({peerId:A0,answer:await C(Y0)}))}else if(m){let u;try{u=await R(m)}catch(l){w(f,"answer");return}if(i)i.setHandlers({connect:()=>x(i,f,D),close:()=>L(i,f)}),i.signal(u);else{const l=z[f]?.[D];if(l&&!l.isDead)l.signal(u)}}};if(!K)throw C0("requires a config map as the first argument");if(!j&&!K.firebaseApp)throw C0("config map is missing appId field");if(!V)throw C0("roomId argument required");if(!X){const D=J(K);Y=d0(KX,T),W=Array.isArray(D)?D:[D],X=!0,U=setInterval(()=>Y=Y.filter((v)=>{const g=Date.now()-v.created<y5;if(!g)v.destroy();return g}),y5*1.03)}const O=W.map(()=>ZX),S=[],P=W.map(async(D,v)=>G(await D,await M,await H,F(v),E));i0([M,H]).then(([D,v])=>{const g=async(y,_)=>{const c=await Q(y,D,v);if(typeof c==="number")O[_]=c;S[_]=setTimeout(()=>g(y,_),O[_])};P.forEach(async(y,_)=>{await y,g(await W[_],_)})});let B=g0;return q[j]||={},q[j][V]=E5((D)=>B=D,(D)=>delete $[D],()=>{delete q[j][V],S.forEach(clearTimeout),P.forEach(async(D)=>(await D)()),clearInterval(U)})}};var _5={},$X=5,u5="x",c5="EVENT",p5=h1.utils.randomPrivateKey(),zX=c1(h1.getPublicKey(p5)),YQ={},Y1={},jX={},l5=()=>Math.floor(Date.now()/1000),d5=(J)=>jX[J]??=GQ(J,1e4)+20000,b5=async(J,G)=>{const Q={kind:d5(J),content:G,pubkey:zX,created_at:l5(),tags:[[u5,J]]},q=c1(new Uint8Array(await crypto.subtle.digest("SHA-256",k0(M0([0,Q.pubkey,Q.created_at,Q.kind,Q.tags,Q.content])))));return M0([c5,{...Q,id:q,sig:c1(await h1.sign(q,p5))}])},h5=(J,G)=>{return YQ[J]=G,M0(["REQ",J,{kinds:[d5(G)],since:l5(),["#"+u5]:[G]}])},m5=(J)=>{return delete YQ[J],M0(["CLOSE",J])},UQ=f5({init:(J)=>L5(J,HX,$X,!0).map((G)=>{const Q=A5(G,(q)=>{const[X,W,Y,U]=Z8(q);if(X!==c5){const K=`${K8}: relay failure from ${Q.url} - `;if(X==="NOTICE")console.warn(K+W);else if(X==="OK"&&!Y)console.warn(K+U);return}Y1[W]?.(YQ[W],Y.content)});return _5[G]=Q,Q.ready}),subscribe:(J,G,Q,q)=>{const X=_1(64),W=_1(64);return Y1[X]=Y1[W]=(Y,U)=>q(Y,U,async(K,V)=>J.send(await b5(K,V))),J.send(h5(X,G)),J.send(h5(W,Q)),()=>{J.send(m5(X)),J.send(m5(W)),delete Y1[X],delete Y1[W]}},announce:async(J,G)=>J.send(await b5(G,M0({peerId:A0})))}),MX=k5(_5),HX=["eu.purplerelay.com","ftp.halifax.rwth-aachen.de/nostr","longhorn.bgp.rodeo","multiplexer.huszonegy.world","nfdb.noswhere.com","nostr-verified.wellorder.net","nostr.cool110.xyz","nostr.data.haus","nostr.grooveix.com","nostr.huszonegy.world","nostr.mom","nostr.openhoofd.nl","nostr.petrkr.net/strfry","nostr.sathoarder.com","nostr.stakey.net","nostr.vulpem.com","nostr2.sanhauf.com","nostrelay.circum.space","relay.fountain.fm","relay.nostraddress.com","relay.nostromo.social","relay.snort.social","relay.verified-nostr.com","strfry.openhoofd.nl","yabu.me/v2"].map((J)=>"wss://"+J);var i5=(J,G,Q)=>{if(!J||!J.timestamp)return{resolved:!0,value:G.value,timestamp:G.timestamp};const q=G.timestamp,X=J.timestamp;if(Q.compare(X,q)<0)return{resolved:!0,value:G.value,timestamp:G.timestamp};return{resolved:!1}};var PX=()=>{let J=Promise.resolve();const G=(X)=>{return J=J.then(X).catch(()=>{}),J},Q=async(X)=>{return G(async()=>{try{const U=await(await(await navigator.storage.getDirectory()).getFileHandle(X,{create:!1})).createSyncAccessHandle(),K=new Uint8Array(U.getSize());return U.read(K,{at:0}),U.close(),{type:"loaded",name:X,data:K}}catch(W){return{type:"error",name:X,message:W.message||"Archivo no encontrado o error de lectura"}}})},q=async(X,W)=>{return G(async()=>{try{const K=await(await(await navigator.storage.getDirectory()).getFileHandle(X,{create:!0})).createWritable();return await K.write(W),await K.close(),{type:"saved",name:X}}catch(Y){return console.error(`Error guardando ${X}:`,Y),{type:"error",message:Y.message||"Error al guardar"}}})};self.onmessage=async({data:{type:X,name:W,content:Y}})=>{const U={load:()=>Q(W),save:()=>q(W,Y)};try{const K=U[X],V=K?await K():{type:"error",message:"Unrecognized action"};self.postMessage(V)}catch(K){self.postMessage({type:"error",message:K.message||"Unexpected error"})}}},r5=PX;var z8={$eq:(J,G)=>J===G,$ne:(J,G)=>J!==G,$gt:(J,G)=>J>G,$gte:(J,G)=>J>=G,$lt:(J,G)=>J<G,$lte:(J,G)=>J<=G,$in:(J,G)=>Array.isArray(G)&&G.includes(J),$between:(J,[G,Q])=>J>=G&&J<=Q,$exists:(J,G)=>G?J!==void 0:J===void 0,$text:{global:(J,G)=>{const Q=(X)=>String(X).normalize("NFD").replace(/[\u0300-\u036f]/g,"").toLowerCase().replace(/[^\w\s]/g,""),q=Q(G);return Object.values(J).some((X)=>{if(typeof X==="object")return null.fieldSearch(X,q);return Q(X).includes(q)})},field:(J,G)=>{const Q=(q)=>String(q).normalize("NFD").replace(/[\u0300-\u036f]/g,"").toLowerCase().replace(/[^\w\s]/g,"");return Array.isArray(J)?J.some((q)=>Q(q).includes(Q(G))):Q(J).includes(Q(G))}},$like:(J,G)=>{if(typeof J!=="string"||typeof G!=="string")return!1;return new RegExp(`^${G.replace(/%/g,".*").replace(/_/g,".")}\$`,"i").test(J)},$regex:(J,G)=>typeof J==="string"&&new RegExp(G.$regex||G,"i").test(J),$and:(J,G,Q)=>G.every((q)=>{return Q.createFilter(q)(J)}),$or:(J,G,Q)=>G.some((q)=>{return Q.createFilter(q)(J)}),$not:(J,G,Q)=>{return!Q.createFilter(G)(J)}},VQ=(J,G)=>{const Q=G.split(".");let q=J;for(let X of Q)if(q&&typeof q==="object"&&(X in q))q=q[X];else return;return q},KQ=(J)=>{const G=(Q)=>{return Object.entries(J).every(([q,X])=>{if(q.startsWith("$"))return z8[q](Q,X,{filterNode:G,createFilter:KQ});const W=VQ(Q.value,q);if(typeof X!=="object"||X===null)return z8.$eq(W,X);return Object.entries(X).every(([Y,U])=>{if(Y==="$text")return z8.$text.field(W,U);if(Y==="$between"&&U.every((K)=>K instanceof Date)){const K=new Date(W);return z8.$between(K,U)}return z8[Y]?.(W,U,{filterNode:G,createFilter:KQ})??!1})})};return G},ZQ=(J,G)=>{const Q=KQ(G.query);let q=Object.values(J).filter(Q);if(G.field)q.sort((X,W)=>{const Y=VQ(X.value,G.field),U=VQ(W.value,G.field),K=G.order==="asc"?1:-1;if(typeof Y==="string"&&typeof U==="string")return Y.localeCompare(U)*K;return((Y??0)-(U??0))*K});if(G.$after){const X=q.findIndex((W)=>W.id===G.$after);q=X>=0?q.slice(X+1):[]}if(G.$before){const X=q.findIndex((W)=>W.id===G.$before);q=X>=0?q.slice(0,X):[]}return G.$limit?q.slice(0,G.$limit):q};class $Q{constructor(){this.physical=Date.now(),this.logical=0}now(){const J=Date.now();return this.physical=Math.max(this.physical,J),this.logical++,{physical:this.physical,logical:this.logical}}update(J){this.physical=Math.max(this.physical,J.physical),this.logical=Math.max(this.logical,J.logical)+1}compare(J,G){if(J.logical>G.logical)return 1;else if(J.logical<G.logical)return-1;else return J.physical-G.physical}}var o5=function(J,G){return J.length===G.length&&J.every((Q,q)=>Q===G[q])};async function CX(){console.log("\u26A1 GDB-P2P: Empowering distributed graph databases with real-time synchronization and scalability. Learn more: https://github.com/estebanrfp/gdb \u26A1"),console.log(navigator?.storage?.getDirectory?"OPFS is enabled.":"OPFS is not available."),navigator?.storage?.getDirectory&&await navigator.storage.getDirectory()}if(Symbol.dispose===void 0)Object.defineProperty(Symbol,"dispose",{value:Symbol.for("Symbol.dispose")});class n5{constructor(){this.nodes={}}insert(J,G,Q){this.nodes[J]={id:J,value:G,edges:[],timestamp:Q}}get(J){return this.nodes[J]||null}link(J,G){const Q=this.nodes[J],q=this.nodes[G];if(Q&&q&&!Q.edges.includes(G))Q.edges.push(G)}getAllNodes(){return Object.values(this.nodes)}serialize(){return xJ.deflate(E0(this.nodes))}deserialize(J){this.nodes=s1(xJ.inflate(new Uint8Array(J)))}}class zQ{constructor(J,{password:G}={}){this.hybridClock=new $Q;const Q=localStorage.getItem(`${this.name}_time`);this.globalTimestamp=Q?JSON.parse(Q):null,this.changeList=[],this.name=J,this.password=G,this.graph=new n5,this.eventListeners=[],this.operators=z8,this.initWorker(),this.ready=this.loadGraphFromOPFS();const q=`graph-sync-room-${this.name}`,X={appId:"1234",...this.password&&{password:this.password}},W=UQ(X,q);this.room=W;const[Y,U]=W.makeAction("syncGraph");this.sendData=Y,window.addEventListener("online",async()=>{console.log("\u2705 Reconnected to the network.");const K=localStorage.getItem(`${this.name}_time`);this.globalTimestamp=K?JSON.parse(K):null,this.sendData([{type:"sync",timestamp:this.globalTimestamp}])}),window.addEventListener("offline",async()=>{console.log("\u274C Disconnected from the network.")}),document.addEventListener("visibilitychange",()=>{if(document.visibilityState==="visible"){console.log("The tab is visible again.");const K=localStorage.getItem(`${this.name}_time`);this.globalTimestamp=K?JSON.parse(K):null,this.sendData([{type:"sync",timestamp:this.globalTimestamp}])}else if(document.visibilityState==="hidden")console.log("The tab is no longer visible.")}),CX(),W.onPeerJoin(async(K)=>{console.log("\u26A1 New pair connected:",K);const V=localStorage.getItem(`${this.name}_time`);this.globalTimestamp=V?JSON.parse(V):null,this.sendData([{type:"sync",timestamp:this.globalTimestamp}])}),W.onPeerLeave((K)=>{console.log("\u26A1 Pair disconnected:",K)}),U((K)=>this.receiveChanges(K)),this.channel=new BroadcastChannel(`graphdb_sync_${this.name}`),this.channel.onmessage=async(K)=>{if(K.data==="update")console.log("\uD83D\uDD04 Update received from another tab..."),await this.loadGraphFromOPFS(),this.emit()}}initWorker(){try{const J=URL.createObjectURL(new Blob([`(${r5.toString()})()`],{type:"application/javascript"}));this.worker=new Worker(J),URL.revokeObjectURL(J),this.worker.addEventListener("message",({data:G})=>console.log("Worker message:",`${G.name} ${G.type}`)),console.log("Worker initialized successfully.")}catch({message:J}){console.error("Failed to initialize worker:",J)}}getWorker(){return this.worker}emit(){const J=this.graph.getAllNodes();this.eventListeners.forEach((G)=>G(J))}on(J){this.eventListeners.push(J)}off(J){if(J)this.eventListeners=this.eventListeners.filter((G)=>G!==J);else this.eventListeners=[]}addChange(J,G,Q){const q={id:J,timestamp:G,operation:Q};this.changeList.push(q)}async getAllNodes(){return await this.ready,this.graph.getAllNodes()}async generateHash(){return crypto.randomUUID()}async hashValue(J){const G=(new TextEncoder()).encode(J),Q=await crypto.subtle.digest("SHA-256",G);return Array.from(new Uint8Array(Q)).map((q)=>q.toString(16).padStart(2,"0")).join("")}async loadGraphFromOPFS(){try{const G=await((Q)=>new Promise((q,X)=>{const W=async({data:Y})=>{if(Y.type==="loaded"&&Y.name===Q)this.worker.removeEventListener("message",W),q(new Uint8Array(Y.data));else if(Y.type==="error")this.worker.removeEventListener("message",W),X(new Error(Y.message||"Unknown error"))};this.worker.addEventListener("message",W),this.worker.postMessage({type:"load",name:Q})}))(`${this.name}_graph.msgpack`).catch(()=>new Uint8Array);G.byteLength>0?this.graph.deserialize(G):console.warn("The file '_graph.msgpack' is empty or could not be loaded."),console.log(`Graph loaded from OPFS: [ ${this.graph.getAllNodes().length} nodes ]`)}catch({message:J}){console.error("General error loading the graph from OPFS:",J)}}async saveGraphToOPFS(){try{const J=this.graph.serialize();return await((Q,q)=>new Promise((X,W)=>{const Y=({data:U})=>{if(U.type==="saved"&&U.name===Q)this.worker.removeEventListener("message",Y),X();else if(U.type==="error")this.worker.removeEventListener("message",Y),W(new Error(U.message||"Save error"))};this.worker.addEventListener("message",Y),this.worker.postMessage({type:"save",name:Q,content:q})}))(`${this.name}_graph.msgpack`,J),this.channel.postMessage("update"),!0}catch({message:J}){throw console.error("Save error:",J),new Error("Save failed")}}async put(J,G){await this.ready;const Q=this.hybridClock.now();return localStorage.setItem(`${this.name}_time`,JSON.stringify(Q)),G??=await this.generateHash(E0(J)),this.graph.insert(G,J,Q),this.addChange(G,Q,"insert"),await this.saveGraphToOPFS(),this.sendData([{type:"insert",id:G,value:J,timestamp:Q}]),this.emit(),G}async get(J,G=null){if(await this.ready,typeof J!=="string")return console.error("Parameter must be a valid ID (string)."),{result:null};const Q=this.graph.get(J);if(!Q)return console.error(`Node with ID '${J}' not found.`),{result:null};if(!G)return{result:Q};G(Q);const q=(X)=>{const W=X.find((Y)=>Y.id===J);if(W&&Q&&W.timestamp){if(this.hybridClock.compare(W.timestamp,Q.timestamp)>0)Q.value=W.value,Q.timestamp=W.timestamp,G(W)}};return this.eventListeners.push(q),{result:Q,...G&&{unsubscribe:()=>this.eventListeners.splice(this.eventListeners.indexOf(q),1)}}}async map(...J){await this.ready;let Q={...{realtime:!1,query:{},field:null,order:"asc",$limit:null,$after:null,$before:null}},q=null,X=!1;J.forEach((K)=>typeof K==="function"?q=K:K&&typeof K==="object"&&(X||=("realtime"in K),Object.assign(Q,K))),q&&!X&&(Q.realtime=!0);let W=ZQ(this.graph.nodes,Q),Y=null;const U=(K)=>{const V=K.filter(($)=>!W.some((N)=>N.id===$.id)),Z=W.filter(($)=>!K.some((N)=>N.id===$.id)),j=K.filter(($)=>{const N=W.find((M)=>M.id===$.id);return N&&!o5(E0($.value),E0(N.value))}),z=($,N)=>{const M=N==="removed"?null:$.value,H={id:$.id,value:M,edges:$.edges||[],timestamp:$.timestamp||null,action:N};q(H)};V.forEach(($)=>z($,"added")),Z.forEach(($)=>z($,"removed")),j.forEach(($)=>z($,"updated"))};if(q){if(W.forEach((K)=>{if(K.value)q({id:K.id,value:K.value,edges:K.edges,timestamp:K.timestamp,action:"initial"})}),Q.realtime)Y=(K)=>{const V=ZQ(K,Q);if(!o5(E0(V),E0(W)))U(V),W=V},this.on(Y)}return{results:W,...Q.realtime&&{unsubscribe:()=>Y&&this.off(Y)}}}async remove(J){await this.ready;const G=this.hybridClock.now(),Q=this.graph.get(J);if(!Q)return console.error(`Node with ID '${J}' not found.`);delete this.graph.nodes[J],Object.values(this.graph.nodes).forEach((q)=>q.edges=q.edges.filter((X)=>X!==J)),this.addChange(J,G,"remove"),await this.saveGraphToOPFS(),localStorage.setItem(`${this.name}_time`,JSON.stringify(G)),this.sendData([{type:"remove",id:J,value:Q.value,timestamp:G}]),this.emit()}async clear(){await this.ready,this.graph.nodes={};try{await(await navigator.storage.getDirectory()).removeEntry(`${this.name}_graph.msgpack`)}catch({message:J}){console.warn(`Error deleting _graph.msgpack: ${J}`)}console.log("All data has been deleted.")}async link(J,G){await this.ready;const Q=this.hybridClock.now();if(!this.graph.nodes[J]||!this.graph.nodes[G]){console.error(`One or both nodes (${J}, ${G}) do not exist.`);return}this.graph.link(J,G),this.addChange(J,Q,"update"),await this.saveGraphToOPFS(),localStorage.setItem(`${this.name}_time`,JSON.stringify(Q)),this.sendData([{type:"link",sourceId:J,targetId:G,timestamp:Q}]),this.emit()}async applyFullGraph(J){try{this.graph.nodes={...J.nodes},await this.saveGraphToOPFS(),this.emit()}catch({message:G}){console.error(`Error applying the full graph: ${G}`)}}async receiveChanges(J){const G={insert:(Q)=>this.graph.insert(Q.id,Q.value,Q.timestamp),update:(Q)=>{const q=this.graph.get(Q.id),X=i5(q,Q,this.hybridClock);X.resolved&&Object.assign(q,{value:X.value,timestamp:X.timestamp})},remove:(Q)=>delete this.graph.nodes[Q.id],link:(Q)=>this.graph.link(Q.sourceId,Q.targetId),sync:(Q)=>{if(this.hybridClock.compare(this.globalTimestamp,Q.timestamp)>0)console.log("Sending recent data to the remote node."),this.sendData([{type:"syncReceive",graph:this.graph}])},syncReceive:(Q)=>this.applyFullGraph(Q.graph)};for(let Q of J)G[Q.type]?.(Q);await this.saveGraphToOPFS(),this.emit()}}function DX(J){if(typeof J!=="object"||J===null)throw new Error("Los roles personalizados deben ser un objeto v\xE1lido.");jQ=J}function a5(J,G,Q=new Set){const q=jQ;if(!q[J])return!1;if(Q.has(J))return!1;if(Q.add(J),q[J].can.includes(G))return!0;if(q[J].inherits)return q[J].inherits.some((X)=>a5(X,G,Q));return!1}async function NX(J,G,Q,q=null){if(await J.ready,!jQ[Q])throw new Error(`El rol '${Q}' no existe.`);let X=`user:${G}`;const W=J.graph.get(X),Y={role:Q,expiresAt:q?new Date(q).toISOString():null};if(W)Object.assign(W.value,Y);else J.graph.insert(X,Y);await J.saveGraphToOPFS(),console.log(`Rol '${Q}' asignado al usuario '${G}'${q?` con caducidad en ${q}`:""}.`)}var s5=function(){const J=new Uint8Array(32);return window.crypto.getRandomValues(J),J},OX=function(){const J=new Uint8Array(16);return window.crypto.getRandomValues(J),J};async function BX(J,G){let Q=`user:${G}`;const q=J.graph.get(Q);if(!q)throw new Error("No tienes un rol asignado.");if(q.value.expiresAt&&new Date(q.value.expiresAt)<new Date)throw new Error("Tu rol ha caducado.");return q.value.role}async function LX(J,G,Q){const q=await BX(J,G);if(!a5(q,Q))throw new Error(`No tienes permiso para realizar la operaci\xF3n '${Q}'.`)}async function AX(J,G,Q,q){return await kX(J,G),await LX(J,G,Q),G}async function kX(J,G){let Q=`user:${G}`,q=J.graph.get(Q);if(!q){const X={storedCredential:null,isAuthenticated:!1};J.graph.insert(Q,X),await J.saveGraphToOPFS(),q=J.graph.get(Q)}if(!q.value.storedCredential)await RX(J,G);else if(!q.value.isAuthenticated)await t5(J,G);else console.log("Ya est\xE1s autenticado. Bot\xF3n desactivado.")}async function RX(J,G){if(!window.PublicKeyCredential){alert("WebAuthn no es soportado en este navegador.");return}let Q=`user:${G}`;const q=OX(),W={challenge:s5(),rp:{name:"RBAC System"},user:{id:q,name:G,displayName:G},pubKeyCredParams:[{type:"public-key",alg:-7}],authenticatorSelection:{authenticatorAttachment:"platform",userVerification:"required"},timeout:60000,attestation:"direct"};try{const Y=await navigator.credentials.create({publicKey:W}),U=J.graph.get(Q);if(!U){console.error("\xA1Error! El nodo de usuario desapareci\xF3 durante el registro.");return}U.value.storedCredential={id:Y.id,type:Y.type,rawId:Array.from(new Uint8Array(Y.rawId)),response:{attestationObject:Array.from(new Uint8Array(Y.response.attestationObject)),clientDataJSON:Array.from(new Uint8Array(Y.response.clientDataJSON))}},U.value.isAuthenticated=!0,await J.saveGraphToOPFS(),console.log("Credencial registrada:",Y),await t5(J,G)}catch(Y){console.error("Error en registro",Y)}}async function t5(J,G){let Q=`user:${G}`;const q=J.graph.get(Q);if(!q){alert("No hay usuario registrado. Registra uno primero.");return}const X=q.value.storedCredential;if(!X){alert("No hay credenciales registradas. Registra una primero.");return}const Y={challenge:s5(),allowCredentials:[{id:X.id,type:"public-key"}],userVerification:"required",timeout:60000};try{const U=await navigator.credentials.get({publicKey:Y});q.value.isAuthenticated=!0,await J.saveGraphToOPFS(),console.log("Autenticaci\xF3n exitosa:",U)}catch(U){console.error("Error en autenticaci\xF3n",U)}}var jQ={superadmin:{can:["assignRole"],inherits:["admin"]},admin:{can:["delete"],inherits:["manager"]},manager:{can:["publish"],inherits:["user"]},user:{can:["write"],inherits:["guest"]},guest:{can:["read"]}};export{DX as setCustomRoles,AX as executeWithPermission,NX as assignRole,zQ as GraphDB};
