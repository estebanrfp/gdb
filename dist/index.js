function Z8(W){const Q=W.length;let J=0,V=0;while(V<Q){let G=W.charCodeAt(V++);if((G&4294967168)===0){J++;continue}else if((G&4294965248)===0)J+=2;else{if(G>=55296&&G<=56319){if(V<Q){const X=W.charCodeAt(V);if((X&64512)===56320)++V,G=((G&1023)<<10)+(X&1023)+65536}}if((G&4294901760)===0)J+=3;else J+=4}}return J}function e6(W,Q,J){const V=W.length;let G=J,X=0;while(X<V){let Y=W.charCodeAt(X++);if((Y&4294967168)===0){Q[G++]=Y;continue}else if((Y&4294965248)===0)Q[G++]=Y>>6&31|192;else{if(Y>=55296&&Y<=56319){if(X<V){const U=W.charCodeAt(X);if((U&64512)===56320)++X,Y=((Y&1023)<<10)+(U&1023)+65536}}if((Y&4294901760)===0)Q[G++]=Y>>12&15|224,Q[G++]=Y>>6&63|128;else Q[G++]=Y>>18&7|240,Q[G++]=Y>>12&63|128,Q[G++]=Y>>6&63|128}Q[G++]=Y&63|128}}function J5(W,Q,J){s6.encodeInto(W,Q.subarray(J))}function H8(W,Q,J){if(W.length>W5)J5(W,Q,J);else e6(W,Q,J)}function S1(W,Q,J){let V=Q;const G=V+J,X=[];let Y="";while(V<G){const U=W[V++];if((U&128)===0)X.push(U);else if((U&224)===192){const z=W[V++]&63;X.push((U&31)<<6|z)}else if((U&240)===224){const z=W[V++]&63,q=W[V++]&63;X.push((U&31)<<12|z<<6|q)}else if((U&248)===240){const z=W[V++]&63,q=W[V++]&63,P=W[V++]&63;let $=(U&7)<<18|z<<12|q<<6|P;if($>65535)$-=65536,X.push($>>>10&1023|55296),$=56320|$&1023;X.push($)}else X.push(U);if(X.length>=Q5)Y+=String.fromCharCode(...X),X.length=0}if(X.length>0)Y+=String.fromCharCode(...X);return Y}function X5(W,Q,J){const V=W.subarray(Q,Q+J);return V5.decode(V)}function k8(W,Q,J){if(J>G5)return X5(W,Q,J);else return S1(W,Q,J)}var s6=new TextEncoder,W5=50,Q5=4096,V5=new TextDecoder,G5=200;class D0{constructor(W,Q){this.type=W,this.data=Q}}class d extends Error{constructor(W){super(W);const Q=Object.create(d.prototype);Object.setPrototypeOf(this,Q),Object.defineProperty(this,"name",{configurable:!0,enumerable:!1,value:d.name})}}function $8(W,Q,J){const V=J/4294967296,G=J;W.setUint32(Q,V),W.setUint32(Q+4,G)}function P1(W,Q,J){const V=Math.floor(J/4294967296),G=J;W.setUint32(Q,V),W.setUint32(Q+4,G)}function K1(W,Q){const J=W.getInt32(Q),V=W.getUint32(Q+4);return J*4294967296+V}function B8(W,Q){const J=W.getUint32(Q),V=W.getUint32(Q+4);return J*4294967296+V}var A0=4294967295;function P5({sec:W,nsec:Q}){if(W>=0&&Q>=0&&W<=Y5)if(Q===0&&W<=U5){const J=new Uint8Array(4);return new DataView(J.buffer).setUint32(0,W),J}else{const J=W/4294967296,V=W&4294967295,G=new Uint8Array(8),X=new DataView(G.buffer);return X.setUint32(0,Q<<2|J&3),X.setUint32(4,V),G}else{const J=new Uint8Array(12),V=new DataView(J.buffer);return V.setUint32(0,Q),P1(V,4,W),J}}function K5(W){const Q=W.getTime(),J=Math.floor(Q/1000),V=(Q-J*1000)*1e6,G=Math.floor(V/1e9);return{sec:J+G,nsec:V-G*1e9}}function F5(W){if(W instanceof Date){const Q=K5(W);return P5(Q)}else return null}function z5(W){const Q=new DataView(W.buffer,W.byteOffset,W.byteLength);switch(W.byteLength){case 4:return{sec:Q.getUint32(0),nsec:0};case 8:{const J=Q.getUint32(0),V=Q.getUint32(4),G=(J&3)*4294967296+V,X=J>>>2;return{sec:G,nsec:X}}case 12:{const J=K1(Q,4),V=Q.getUint32(0);return{sec:J,nsec:V}}default:throw new d(`Unrecognized data size for timestamp (expected 4, 8, or 12): ${W.length}`)}}function Z5(W){const Q=z5(W);return new Date(Q.sec*1000+Q.nsec/1e6)}var q5=-1,U5=4294967295,Y5=17179869183,C8={type:q5,encode:F5,decode:Z5};class B0{constructor(){this.builtInEncoders=[],this.builtInDecoders=[],this.encoders=[],this.decoders=[],this.register(C8)}register({type:W,encode:Q,decode:J}){if(W>=0)this.encoders[W]=Q,this.decoders[W]=J;else{const V=-1-W;this.builtInEncoders[V]=Q,this.builtInDecoders[V]=J}}tryToEncode(W,Q){for(let J=0;J<this.builtInEncoders.length;J++){const V=this.builtInEncoders[J];if(V!=null){const G=V(W,Q);if(G!=null){const X=-1-J;return new D0(X,G)}}}for(let J=0;J<this.encoders.length;J++){const V=this.encoders[J];if(V!=null){const G=V(W,Q);if(G!=null)return new D0(J,G)}}if(W instanceof D0)return W;return null}decode(W,Q,J){const V=Q<0?this.builtInDecoders[-1-Q]:this.decoders[Q];if(V)return V(W,Q,J);else return new D0(Q,W)}}B0.defaultCodec=new B0;var H5=function(W){return W instanceof ArrayBuffer||typeof SharedArrayBuffer!=="undefined"&&W instanceof SharedArrayBuffer};function b0(W){if(W instanceof Uint8Array)return W;else if(ArrayBuffer.isView(W))return new Uint8Array(W.buffer,W.byteOffset,W.byteLength);else if(H5(W))return new Uint8Array(W);else return Uint8Array.from(W)}var k5=100,$5=2048;class F1{constructor(W){this.entered=!1,this.extensionCodec=W?.extensionCodec??B0.defaultCodec,this.context=W?.context,this.useBigInt64=W?.useBigInt64??!1,this.maxDepth=W?.maxDepth??k5,this.initialBufferSize=W?.initialBufferSize??$5,this.sortKeys=W?.sortKeys??!1,this.forceFloat32=W?.forceFloat32??!1,this.ignoreUndefined=W?.ignoreUndefined??!1,this.forceIntegerToFloat=W?.forceIntegerToFloat??!1,this.pos=0,this.view=new DataView(new ArrayBuffer(this.initialBufferSize)),this.bytes=new Uint8Array(this.view.buffer)}clone(){return new F1({extensionCodec:this.extensionCodec,context:this.context,useBigInt64:this.useBigInt64,maxDepth:this.maxDepth,initialBufferSize:this.initialBufferSize,sortKeys:this.sortKeys,forceFloat32:this.forceFloat32,ignoreUndefined:this.ignoreUndefined,forceIntegerToFloat:this.forceIntegerToFloat})}reinitializeState(){this.pos=0}encodeSharedRef(W){if(this.entered)return this.clone().encodeSharedRef(W);try{return this.entered=!0,this.reinitializeState(),this.doEncode(W,1),this.bytes.subarray(0,this.pos)}finally{this.entered=!1}}encode(W){if(this.entered)return this.clone().encode(W);try{return this.entered=!0,this.reinitializeState(),this.doEncode(W,1),this.bytes.slice(0,this.pos)}finally{this.entered=!1}}doEncode(W,Q){if(Q>this.maxDepth)throw new Error(`Too deep objects in depth ${Q}`);if(W==null)this.encodeNil();else if(typeof W==="boolean")this.encodeBoolean(W);else if(typeof W==="number")if(!this.forceIntegerToFloat)this.encodeNumber(W);else this.encodeNumberAsFloat(W);else if(typeof W==="string")this.encodeString(W);else if(this.useBigInt64&&typeof W==="bigint")this.encodeBigInt64(W);else this.encodeObject(W,Q)}ensureBufferSizeToWrite(W){const Q=this.pos+W;if(this.view.byteLength<Q)this.resizeBuffer(Q*2)}resizeBuffer(W){const Q=new ArrayBuffer(W),J=new Uint8Array(Q),V=new DataView(Q);J.set(this.bytes),this.view=V,this.bytes=J}encodeNil(){this.writeU8(192)}encodeBoolean(W){if(W===!1)this.writeU8(194);else this.writeU8(195)}encodeNumber(W){if(!this.forceIntegerToFloat&&Number.isSafeInteger(W))if(W>=0)if(W<128)this.writeU8(W);else if(W<256)this.writeU8(204),this.writeU8(W);else if(W<65536)this.writeU8(205),this.writeU16(W);else if(W<4294967296)this.writeU8(206),this.writeU32(W);else if(!this.useBigInt64)this.writeU8(207),this.writeU64(W);else this.encodeNumberAsFloat(W);else if(W>=-32)this.writeU8(224|W+32);else if(W>=-128)this.writeU8(208),this.writeI8(W);else if(W>=-32768)this.writeU8(209),this.writeI16(W);else if(W>=-2147483648)this.writeU8(210),this.writeI32(W);else if(!this.useBigInt64)this.writeU8(211),this.writeI64(W);else this.encodeNumberAsFloat(W);else this.encodeNumberAsFloat(W)}encodeNumberAsFloat(W){if(this.forceFloat32)this.writeU8(202),this.writeF32(W);else this.writeU8(203),this.writeF64(W)}encodeBigInt64(W){if(W>=BigInt(0))this.writeU8(207),this.writeBigUint64(W);else this.writeU8(211),this.writeBigInt64(W)}writeStringHeader(W){if(W<32)this.writeU8(160+W);else if(W<256)this.writeU8(217),this.writeU8(W);else if(W<65536)this.writeU8(218),this.writeU16(W);else if(W<4294967296)this.writeU8(219),this.writeU32(W);else throw new Error(`Too long string: ${W} bytes in UTF-8`)}encodeString(W){const J=Z8(W);this.ensureBufferSizeToWrite(5+J),this.writeStringHeader(J),H8(W,this.bytes,this.pos),this.pos+=J}encodeObject(W,Q){const J=this.extensionCodec.tryToEncode(W,this.context);if(J!=null)this.encodeExtension(J);else if(Array.isArray(W))this.encodeArray(W,Q);else if(ArrayBuffer.isView(W))this.encodeBinary(W);else if(typeof W==="object")this.encodeMap(W,Q);else throw new Error(`Unrecognized object: ${Object.prototype.toString.apply(W)}`)}encodeBinary(W){const Q=W.byteLength;if(Q<256)this.writeU8(196),this.writeU8(Q);else if(Q<65536)this.writeU8(197),this.writeU16(Q);else if(Q<4294967296)this.writeU8(198),this.writeU32(Q);else throw new Error(`Too large binary: ${Q}`);const J=b0(W);this.writeU8a(J)}encodeArray(W,Q){const J=W.length;if(J<16)this.writeU8(144+J);else if(J<65536)this.writeU8(220),this.writeU16(J);else if(J<4294967296)this.writeU8(221),this.writeU32(J);else throw new Error(`Too large array: ${J}`);for(let V of W)this.doEncode(V,Q+1)}countWithoutUndefined(W,Q){let J=0;for(let V of Q)if(W[V]!==void 0)J++;return J}encodeMap(W,Q){const J=Object.keys(W);if(this.sortKeys)J.sort();const V=this.ignoreUndefined?this.countWithoutUndefined(W,J):J.length;if(V<16)this.writeU8(128+V);else if(V<65536)this.writeU8(222),this.writeU16(V);else if(V<4294967296)this.writeU8(223),this.writeU32(V);else throw new Error(`Too large map object: ${V}`);for(let G of J){const X=W[G];if(!(this.ignoreUndefined&&X===void 0))this.encodeString(G),this.doEncode(X,Q+1)}}encodeExtension(W){if(typeof W.data==="function"){const J=W.data(this.pos+6),V=J.length;if(V>=4294967296)throw new Error(`Too large extension object: ${V}`);this.writeU8(201),this.writeU32(V),this.writeI8(W.type),this.writeU8a(J);return}const Q=W.data.length;if(Q===1)this.writeU8(212);else if(Q===2)this.writeU8(213);else if(Q===4)this.writeU8(214);else if(Q===8)this.writeU8(215);else if(Q===16)this.writeU8(216);else if(Q<256)this.writeU8(199),this.writeU8(Q);else if(Q<65536)this.writeU8(200),this.writeU16(Q);else if(Q<4294967296)this.writeU8(201),this.writeU32(Q);else throw new Error(`Too large extension object: ${Q}`);this.writeI8(W.type),this.writeU8a(W.data)}writeU8(W){this.ensureBufferSizeToWrite(1),this.view.setUint8(this.pos,W),this.pos++}writeU8a(W){const Q=W.length;this.ensureBufferSizeToWrite(Q),this.bytes.set(W,this.pos),this.pos+=Q}writeI8(W){this.ensureBufferSizeToWrite(1),this.view.setInt8(this.pos,W),this.pos++}writeU16(W){this.ensureBufferSizeToWrite(2),this.view.setUint16(this.pos,W),this.pos+=2}writeI16(W){this.ensureBufferSizeToWrite(2),this.view.setInt16(this.pos,W),this.pos+=2}writeU32(W){this.ensureBufferSizeToWrite(4),this.view.setUint32(this.pos,W),this.pos+=4}writeI32(W){this.ensureBufferSizeToWrite(4),this.view.setInt32(this.pos,W),this.pos+=4}writeF32(W){this.ensureBufferSizeToWrite(4),this.view.setFloat32(this.pos,W),this.pos+=4}writeF64(W){this.ensureBufferSizeToWrite(8),this.view.setFloat64(this.pos,W),this.pos+=8}writeU64(W){this.ensureBufferSizeToWrite(8),$8(this.view,this.pos,W),this.pos+=8}writeI64(W){this.ensureBufferSizeToWrite(8),P1(this.view,this.pos,W),this.pos+=8}writeBigUint64(W){this.ensureBufferSizeToWrite(8),this.view.setBigUint64(this.pos,W),this.pos+=8}writeBigInt64(W){this.ensureBufferSizeToWrite(8),this.view.setBigInt64(this.pos,W),this.pos+=8}}function N0(W,Q){return new F1(Q).encodeSharedRef(W)}function z1(W){return`${W<0?"-":""}0x${Math.abs(W).toString(16).padStart(2,"0")}`}var B5=16,C5=16;class v1{constructor(W=B5,Q=C5){this.hit=0,this.miss=0,this.maxKeyLength=W,this.maxLengthPerKey=Q,this.caches=[];for(let J=0;J<this.maxKeyLength;J++)this.caches.push([])}canBeCached(W){return W>0&&W<=this.maxKeyLength}find(W,Q,J){const V=this.caches[J-1];W:for(let G of V){const X=G.bytes;for(let Y=0;Y<J;Y++)if(X[Y]!==W[Q+Y])continue W;return G.str}return null}store(W,Q){const J=this.caches[W.length-1],V={bytes:W,str:Q};if(J.length>=this.maxLengthPerKey)J[Math.random()*J.length|0]=V;else J.push(V)}decode(W,Q,J){const V=this.find(W,Q,J);if(V!=null)return this.hit++,V;this.miss++;const G=S1(W,Q,J),X=Uint8Array.prototype.slice.call(W,Q,Q+J);return this.store(X,G),G}}var T1="array",m0="map_key",R8="map_value",j5=(W)=>{if(typeof W==="string"||typeof W==="number")return W;throw new d("The type of key must be string or number but "+typeof W)};class M8{constructor(){this.stack=[],this.stackHeadPosition=-1}get length(){return this.stackHeadPosition+1}top(){return this.stack[this.stackHeadPosition]}pushArrayState(W){const Q=this.getUninitializedStateFromPool();Q.type=T1,Q.position=0,Q.size=W,Q.array=new Array(W)}pushMapState(W){const Q=this.getUninitializedStateFromPool();Q.type=m0,Q.readCount=0,Q.size=W,Q.map={}}getUninitializedStateFromPool(){if(this.stackHeadPosition++,this.stackHeadPosition===this.stack.length){const W={type:void 0,size:0,array:void 0,position:0,readCount:0,map:void 0,key:null};this.stack.push(W)}return this.stack[this.stackHeadPosition]}release(W){if(this.stack[this.stackHeadPosition]!==W)throw new Error("Invalid stack state. Released state is not on top of the stack.");if(W.type===T1){const J=W;J.size=0,J.array=void 0,J.position=0,J.type=void 0}if(W.type===m0||W.type===R8){const J=W;J.size=0,J.map=void 0,J.readCount=0,J.type=void 0}this.stackHeadPosition--}reset(){this.stack.length=0,this.stackHeadPosition=-1}}var u0=-1,g1=new DataView(new ArrayBuffer(0)),R5=new Uint8Array(g1.buffer);try{g1.getInt8(0)}catch(W){if(!(W instanceof RangeError))throw new Error("This module is not supported in the current JavaScript engine because DataView does not throw RangeError on out-of-bounds access")}var j8=new RangeError("Insufficient data"),M5=new v1;class Z1{constructor(W){this.totalPos=0,this.pos=0,this.view=g1,this.bytes=R5,this.headByte=u0,this.stack=new M8,this.entered=!1,this.extensionCodec=W?.extensionCodec??B0.defaultCodec,this.context=W?.context,this.useBigInt64=W?.useBigInt64??!1,this.rawStrings=W?.rawStrings??!1,this.maxStrLength=W?.maxStrLength??A0,this.maxBinLength=W?.maxBinLength??A0,this.maxArrayLength=W?.maxArrayLength??A0,this.maxMapLength=W?.maxMapLength??A0,this.maxExtLength=W?.maxExtLength??A0,this.keyDecoder=W?.keyDecoder!==void 0?W.keyDecoder:M5,this.mapKeyConverter=W?.mapKeyConverter??j5}clone(){return new Z1({extensionCodec:this.extensionCodec,context:this.context,useBigInt64:this.useBigInt64,rawStrings:this.rawStrings,maxStrLength:this.maxStrLength,maxBinLength:this.maxBinLength,maxArrayLength:this.maxArrayLength,maxMapLength:this.maxMapLength,maxExtLength:this.maxExtLength,keyDecoder:this.keyDecoder})}reinitializeState(){this.totalPos=0,this.headByte=u0,this.stack.reset()}setBuffer(W){const Q=b0(W);this.bytes=Q,this.view=new DataView(Q.buffer,Q.byteOffset,Q.byteLength),this.pos=0}appendBuffer(W){if(this.headByte===u0&&!this.hasRemaining(1))this.setBuffer(W);else{const Q=this.bytes.subarray(this.pos),J=b0(W),V=new Uint8Array(Q.length+J.length);V.set(Q),V.set(J,Q.length),this.setBuffer(V)}}hasRemaining(W){return this.view.byteLength-this.pos>=W}createExtraByteError(W){const{view:Q,pos:J}=this;return new RangeError(`Extra ${Q.byteLength-J} of ${Q.byteLength} byte(s) found at buffer[${W}]`)}decode(W){if(this.entered)return this.clone().decode(W);try{this.entered=!0,this.reinitializeState(),this.setBuffer(W);const Q=this.doDecodeSync();if(this.hasRemaining(1))throw this.createExtraByteError(this.pos);return Q}finally{this.entered=!1}}*decodeMulti(W){if(this.entered){yield*this.clone().decodeMulti(W);return}try{this.entered=!0,this.reinitializeState(),this.setBuffer(W);while(this.hasRemaining(1))yield this.doDecodeSync()}finally{this.entered=!1}}async decodeAsync(W){if(this.entered)return this.clone().decodeAsync(W);try{this.entered=!0;let Q=!1,J;for await(let Y of W){if(Q)throw this.entered=!1,this.createExtraByteError(this.totalPos);this.appendBuffer(Y);try{J=this.doDecodeSync(),Q=!0}catch(U){if(!(U instanceof RangeError))throw U}this.totalPos+=this.pos}if(Q){if(this.hasRemaining(1))throw this.createExtraByteError(this.totalPos);return J}const{headByte:V,pos:G,totalPos:X}=this;throw new RangeError(`Insufficient data in parsing ${z1(V)} at ${X} (${G} in the current buffer)`)}finally{this.entered=!1}}decodeArrayStream(W){return this.decodeMultiAsync(W,!0)}decodeStream(W){return this.decodeMultiAsync(W,!1)}async*decodeMultiAsync(W,Q){if(this.entered){yield*this.clone().decodeMultiAsync(W,Q);return}try{this.entered=!0;let J=Q,V=-1;for await(let G of W){if(Q&&V===0)throw this.createExtraByteError(this.totalPos);if(this.appendBuffer(G),J)V=this.readArraySize(),J=!1,this.complete();try{while(!0)if(yield this.doDecodeSync(),--V===0)break}catch(X){if(!(X instanceof RangeError))throw X}this.totalPos+=this.pos}}finally{this.entered=!1}}doDecodeSync(){W:while(!0){const W=this.readHeadByte();let Q;if(W>=224)Q=W-256;else if(W<192)if(W<128)Q=W;else if(W<144){const V=W-128;if(V!==0){this.pushMapState(V),this.complete();continue W}else Q={}}else if(W<160){const V=W-144;if(V!==0){this.pushArrayState(V),this.complete();continue W}else Q=[]}else{const V=W-160;Q=this.decodeString(V,0)}else if(W===192)Q=null;else if(W===194)Q=!1;else if(W===195)Q=!0;else if(W===202)Q=this.readF32();else if(W===203)Q=this.readF64();else if(W===204)Q=this.readU8();else if(W===205)Q=this.readU16();else if(W===206)Q=this.readU32();else if(W===207)if(this.useBigInt64)Q=this.readU64AsBigInt();else Q=this.readU64();else if(W===208)Q=this.readI8();else if(W===209)Q=this.readI16();else if(W===210)Q=this.readI32();else if(W===211)if(this.useBigInt64)Q=this.readI64AsBigInt();else Q=this.readI64();else if(W===217){const V=this.lookU8();Q=this.decodeString(V,1)}else if(W===218){const V=this.lookU16();Q=this.decodeString(V,2)}else if(W===219){const V=this.lookU32();Q=this.decodeString(V,4)}else if(W===220){const V=this.readU16();if(V!==0){this.pushArrayState(V),this.complete();continue W}else Q=[]}else if(W===221){const V=this.readU32();if(V!==0){this.pushArrayState(V),this.complete();continue W}else Q=[]}else if(W===222){const V=this.readU16();if(V!==0){this.pushMapState(V),this.complete();continue W}else Q={}}else if(W===223){const V=this.readU32();if(V!==0){this.pushMapState(V),this.complete();continue W}else Q={}}else if(W===196){const V=this.lookU8();Q=this.decodeBinary(V,1)}else if(W===197){const V=this.lookU16();Q=this.decodeBinary(V,2)}else if(W===198){const V=this.lookU32();Q=this.decodeBinary(V,4)}else if(W===212)Q=this.decodeExtension(1,0);else if(W===213)Q=this.decodeExtension(2,0);else if(W===214)Q=this.decodeExtension(4,0);else if(W===215)Q=this.decodeExtension(8,0);else if(W===216)Q=this.decodeExtension(16,0);else if(W===199){const V=this.lookU8();Q=this.decodeExtension(V,1)}else if(W===200){const V=this.lookU16();Q=this.decodeExtension(V,2)}else if(W===201){const V=this.lookU32();Q=this.decodeExtension(V,4)}else throw new d(`Unrecognized type byte: ${z1(W)}`);this.complete();const J=this.stack;while(J.length>0){const V=J.top();if(V.type===T1)if(V.array[V.position]=Q,V.position++,V.position===V.size)Q=V.array,J.release(V);else continue W;else if(V.type===m0){if(Q==="__proto__")throw new d("The key __proto__ is not allowed");V.key=this.mapKeyConverter(Q),V.type=R8;continue W}else if(V.map[V.key]=Q,V.readCount++,V.readCount===V.size)Q=V.map,J.release(V);else{V.key=null,V.type=m0;continue W}}return Q}}readHeadByte(){if(this.headByte===u0)this.headByte=this.readU8();return this.headByte}complete(){this.headByte=u0}readArraySize(){const W=this.readHeadByte();switch(W){case 220:return this.readU16();case 221:return this.readU32();default:if(W<160)return W-144;else throw new d(`Unrecognized array type byte: ${z1(W)}`)}}pushMapState(W){if(W>this.maxMapLength)throw new d(`Max length exceeded: map length (${W}) > maxMapLengthLength (${this.maxMapLength})`);this.stack.pushMapState(W)}pushArrayState(W){if(W>this.maxArrayLength)throw new d(`Max length exceeded: array length (${W}) > maxArrayLength (${this.maxArrayLength})`);this.stack.pushArrayState(W)}decodeString(W,Q){if(!this.rawStrings||this.stateIsMapKey())return this.decodeUtf8String(W,Q);return this.decodeBinary(W,Q)}decodeUtf8String(W,Q){if(W>this.maxStrLength)throw new d(`Max length exceeded: UTF-8 byte length (${W}) > maxStrLength (${this.maxStrLength})`);if(this.bytes.byteLength<this.pos+Q+W)throw j8;const J=this.pos+Q;let V;if(this.stateIsMapKey()&&this.keyDecoder?.canBeCached(W))V=this.keyDecoder.decode(this.bytes,J,W);else V=k8(this.bytes,J,W);return this.pos+=Q+W,V}stateIsMapKey(){if(this.stack.length>0)return this.stack.top().type===m0;return!1}decodeBinary(W,Q){if(W>this.maxBinLength)throw new d(`Max length exceeded: bin length (${W}) > maxBinLength (${this.maxBinLength})`);if(!this.hasRemaining(W+Q))throw j8;const J=this.pos+Q,V=this.bytes.subarray(J,J+W);return this.pos+=Q+W,V}decodeExtension(W,Q){if(W>this.maxExtLength)throw new d(`Max length exceeded: ext length (${W}) > maxExtLength (${this.maxExtLength})`);const J=this.view.getInt8(this.pos+Q),V=this.decodeBinary(W,Q+1);return this.extensionCodec.decode(V,J,this.context)}lookU8(){return this.view.getUint8(this.pos)}lookU16(){return this.view.getUint16(this.pos)}lookU32(){return this.view.getUint32(this.pos)}readU8(){const W=this.view.getUint8(this.pos);return this.pos++,W}readI8(){const W=this.view.getInt8(this.pos);return this.pos++,W}readU16(){const W=this.view.getUint16(this.pos);return this.pos+=2,W}readI16(){const W=this.view.getInt16(this.pos);return this.pos+=2,W}readU32(){const W=this.view.getUint32(this.pos);return this.pos+=4,W}readI32(){const W=this.view.getInt32(this.pos);return this.pos+=4,W}readU64(){const W=B8(this.view,this.pos);return this.pos+=8,W}readI64(){const W=K1(this.view,this.pos);return this.pos+=8,W}readU64AsBigInt(){const W=this.view.getBigUint64(this.pos);return this.pos+=8,W}readI64AsBigInt(){const W=this.view.getBigInt64(this.pos);return this.pos+=8,W}readF32(){const W=this.view.getFloat32(this.pos);return this.pos+=4,W}readF64(){const W=this.view.getFloat64(this.pos);return this.pos+=8,W}}function c0(W,Q){return new Z1(Q).decode(W)}var E0=function(W){let Q=W.length;while(--Q>=0)W[Q]=0},E1=function(W,Q,J,V,G){this.static_tree=W,this.extra_bits=Q,this.extra_base=J,this.elems=V,this.max_length=G,this.has_stree=W&&W.length},f1=function(W,Q){this.dyn_tree=W,this.max_code=0,this.stat_desc=Q},s=function(W,Q,J,V,G){this.good_length=W,this.max_lazy=Q,this.nice_length=J,this.max_chain=V,this.func=G},xW=function(){this.strm=null,this.status=0,this.pending_buf=null,this.pending_buf_size=0,this.pending_out=0,this.pending=0,this.wrap=0,this.gzhead=null,this.gzindex=0,this.method=x1,this.last_flush=-1,this.w_size=0,this.w_bits=0,this.w_mask=0,this.window=null,this.window_size=0,this.prev=null,this.head=null,this.ins_h=0,this.hash_size=0,this.hash_bits=0,this.hash_mask=0,this.hash_shift=0,this.block_start=0,this.match_length=0,this.prev_match=0,this.match_available=0,this.strstart=0,this.match_start=0,this.lookahead=0,this.prev_length=0,this.max_chain_length=0,this.max_lazy_match=0,this.level=0,this.strategy=0,this.good_match=0,this.nice_match=0,this.dyn_ltree=new Uint16Array(HW*2),this.dyn_dtree=new Uint16Array((2*zW+1)*2),this.bl_tree=new Uint16Array((2*ZW+1)*2),P0(this.dyn_ltree),P0(this.dyn_dtree),P0(this.bl_tree),this.l_desc=null,this.d_desc=null,this.bl_desc=null,this.bl_count=new Uint16Array(kW+1),this.heap=new Uint16Array(2*t1+1),P0(this.heap),this.heap_len=0,this.heap_max=0,this.depth=new Uint16Array(2*t1+1),P0(this.depth),this.sym_buf=0,this.lit_bufsize=0,this.sym_next=0,this.sym_end=0,this.opt_len=0,this.static_len=0,this.matches=0,this.insert=0,this.bi_buf=0,this.bi_valid=0},iW=function(){this.input=null,this.next_in=0,this.avail_in=0,this.total_in=0,this.output=null,this.next_out=0,this.avail_out=0,this.total_out=0,this.msg="",this.state=null,this.data_type=2,this.adler=0},X1=function(W){this.options=I1.assign({level:tW,method:sW,chunkSize:16384,windowBits:15,memLevel:8,strategy:eW},W||{});let Q=this.options;if(Q.raw&&Q.windowBits>0)Q.windowBits=-Q.windowBits;else if(Q.gzip&&Q.windowBits>0&&Q.windowBits<16)Q.windowBits+=16;this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new D6,this.strm.avail_out=0;let J=r0.deflateInit2(this.strm,Q.level,Q.method,Q.windowBits,Q.memLevel,Q.strategy);if(J!==M1)throw new Error(M0[J]);if(Q.header)r0.deflateSetHeader(this.strm,Q.header);if(Q.dictionary){let V;if(typeof Q.dictionary==="string")V=J1.string2buf(Q.dictionary);else if(A6.call(Q.dictionary)==="[object ArrayBuffer]")V=new Uint8Array(Q.dictionary);else V=Q.dictionary;if(J=r0.deflateSetDictionary(this.strm,V),J!==M1)throw new Error(M0[J]);this._dict_set=!0}},Y8=function(W,Q){const J=new X1(Q);if(J.push(W,!0),J.err)throw J.msg||M0[J.err];return J.result},WJ=function(W,Q){return Q=Q||{},Q.raw=!0,Y8(W,Q)},JJ=function(W,Q){return Q=Q||{},Q.gzip=!0,Y8(W,Q)},IJ=function(){this.strm=null,this.mode=0,this.last=!1,this.wrap=0,this.havedict=!1,this.flags=0,this.dmax=0,this.check=0,this.total=0,this.head=null,this.wbits=0,this.wsize=0,this.whave=0,this.wnext=0,this.window=null,this.hold=0,this.bits=0,this.length=0,this.offset=0,this.extra=0,this.lencode=null,this.distcode=null,this.lenbits=0,this.distbits=0,this.ncode=0,this.nlen=0,this.ndist=0,this.have=0,this.next=null,this.lens=new Uint16Array(320),this.work=new Uint16Array(288),this.lendyn=null,this.distdyn=null,this.sane=0,this.back=0,this.was=0},mJ=function(){this.text=0,this.time=0,this.xflags=0,this.os=0,this.extra=null,this.extra_len=0,this.name="",this.comment="",this.hcrc=0,this.done=!1},q1=function(W){this.options=I1.assign({chunkSize:65536,windowBits:15,to:""},W||{});const Q=this.options;if(Q.raw&&Q.windowBits>=0&&Q.windowBits<16){if(Q.windowBits=-Q.windowBits,Q.windowBits===0)Q.windowBits=-15}if(Q.windowBits>=0&&Q.windowBits<16&&!(W&&W.windowBits))Q.windowBits+=32;if(Q.windowBits>15&&Q.windowBits<48){if((Q.windowBits&15)===0)Q.windowBits|=15}this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new D6,this.strm.avail_out=0;let J=q0.inflateInit2(this.strm,Q.windowBits);if(J!==Q1)throw new Error(M0[J]);if(this.header=new cJ,q0.inflateGetHeader(this.strm,this.header),Q.dictionary){if(typeof Q.dictionary==="string")Q.dictionary=J1.string2buf(Q.dictionary);else if(u6.call(Q.dictionary)==="[object ArrayBuffer]")Q.dictionary=new Uint8Array(Q.dictionary);if(Q.raw){if(J=q0.inflateSetDictionary(this.strm,Q.dictionary),J!==Q1)throw new Error(M0[J])}}},P8=function(W,Q){const J=new q1(Q);if(J.push(W),J.err)throw J.msg||M0[J.err];return J.result},rJ=function(W,Q){return Q=Q||{},Q.raw=!0,P8(W,Q)};/*! pako 2.1.0 https://github.com/nodeca/pako @license (MIT AND Zlib) */var L5=0,q6=1,x5=2,I5=3,O5=258,V8=29,V1=256,o0=V1+1+V8,T0=30,G8=19,U6=2*o0+1,C0=15,y1=16,w5=7,X8=256,Y6=16,P6=17,K6=18,n1=new Uint8Array([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0]),j1=new Uint8Array([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13]),D5=new Uint8Array([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7]),F6=new Uint8Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),A5=512,X0=new Array((o0+2)*2);E0(X0);var l0=new Array(T0*2);E0(l0);var a0=new Array(A5);E0(a0);var t0=new Array(O5-I5+1);E0(t0);var q8=new Array(V8);E0(q8);var R1=new Array(T0);E0(R1);var z6,Z6,H6,k6=(W)=>{return W<256?a0[W]:a0[256+(W>>>7)]},e0=(W,Q)=>{W.pending_buf[W.pending++]=Q&255,W.pending_buf[W.pending++]=Q>>>8&255},l=(W,Q,J)=>{if(W.bi_valid>y1-J)W.bi_buf|=Q<<W.bi_valid&65535,e0(W,W.bi_buf),W.bi_buf=Q>>y1-W.bi_valid,W.bi_valid+=J-y1;else W.bi_buf|=Q<<W.bi_valid&65535,W.bi_valid+=J},W0=(W,Q,J)=>{l(W,J[Q*2],J[Q*2+1])},$6=(W,Q)=>{let J=0;do J|=W&1,W>>>=1,J<<=1;while(--Q>0);return J>>>1},N5=(W)=>{if(W.bi_valid===16)e0(W,W.bi_buf),W.bi_buf=0,W.bi_valid=0;else if(W.bi_valid>=8)W.pending_buf[W.pending++]=W.bi_buf&255,W.bi_buf>>=8,W.bi_valid-=8},S5=(W,Q)=>{const{dyn_tree:J,max_code:V}=Q,G=Q.stat_desc.static_tree,X=Q.stat_desc.has_stree,Y=Q.stat_desc.extra_bits,U=Q.stat_desc.extra_base,z=Q.stat_desc.max_length;let q,P,$,F,K,H,S=0;for(F=0;F<=C0;F++)W.bl_count[F]=0;J[W.heap[W.heap_max]*2+1]=0;for(q=W.heap_max+1;q<U6;q++){if(P=W.heap[q],F=J[J[P*2+1]*2+1]+1,F>z)F=z,S++;if(J[P*2+1]=F,P>V)continue;if(W.bl_count[F]++,K=0,P>=U)K=Y[P-U];if(H=J[P*2],W.opt_len+=H*(F+K),X)W.static_len+=H*(G[P*2+1]+K)}if(S===0)return;do{F=z-1;while(W.bl_count[F]===0)F--;W.bl_count[F]--,W.bl_count[F+1]+=2,W.bl_count[z]--,S-=2}while(S>0);for(F=z;F!==0;F--){P=W.bl_count[F];while(P!==0){if($=W.heap[--q],$>V)continue;if(J[$*2+1]!==F)W.opt_len+=(F-J[$*2+1])*J[$*2],J[$*2+1]=F;P--}}},B6=(W,Q,J)=>{const V=new Array(C0+1);let G=0,X,Y;for(X=1;X<=C0;X++)G=G+J[X-1]<<1,V[X]=G;for(Y=0;Y<=Q;Y++){let U=W[Y*2+1];if(U===0)continue;W[Y*2]=$6(V[U]++,U)}},v5=()=>{let W,Q,J,V,G;const X=new Array(C0+1);J=0;for(V=0;V<V8-1;V++){q8[V]=J;for(W=0;W<1<<n1[V];W++)t0[J++]=V}t0[J-1]=V,G=0;for(V=0;V<16;V++){R1[V]=G;for(W=0;W<1<<j1[V];W++)a0[G++]=V}G>>=7;for(;V<T0;V++){R1[V]=G<<7;for(W=0;W<1<<j1[V]-7;W++)a0[256+G++]=V}for(Q=0;Q<=C0;Q++)X[Q]=0;W=0;while(W<=143)X0[W*2+1]=8,W++,X[8]++;while(W<=255)X0[W*2+1]=9,W++,X[9]++;while(W<=279)X0[W*2+1]=7,W++,X[7]++;while(W<=287)X0[W*2+1]=8,W++,X[8]++;B6(X0,o0+1,X);for(W=0;W<T0;W++)l0[W*2+1]=5,l0[W*2]=$6(W,5);z6=new E1(X0,n1,V1+1,o0,C0),Z6=new E1(l0,j1,0,T0,C0),H6=new E1(new Array(0),D5,0,G8,w5)},C6=(W)=>{let Q;for(Q=0;Q<o0;Q++)W.dyn_ltree[Q*2]=0;for(Q=0;Q<T0;Q++)W.dyn_dtree[Q*2]=0;for(Q=0;Q<G8;Q++)W.bl_tree[Q*2]=0;W.dyn_ltree[X8*2]=1,W.opt_len=W.static_len=0,W.sym_next=W.matches=0},j6=(W)=>{if(W.bi_valid>8)e0(W,W.bi_buf);else if(W.bi_valid>0)W.pending_buf[W.pending++]=W.bi_buf;W.bi_buf=0,W.bi_valid=0},L8=(W,Q,J,V)=>{const G=Q*2,X=J*2;return W[G]<W[X]||W[G]===W[X]&&V[Q]<=V[J]},p1=(W,Q,J)=>{const V=W.heap[J];let G=J<<1;while(G<=W.heap_len){if(G<W.heap_len&&L8(Q,W.heap[G+1],W.heap[G],W.depth))G++;if(L8(Q,V,W.heap[G],W.depth))break;W.heap[J]=W.heap[G],J=G,G<<=1}W.heap[J]=V},x8=(W,Q,J)=>{let V,G,X=0,Y,U;if(W.sym_next!==0)do if(V=W.pending_buf[W.sym_buf+X++]&255,V+=(W.pending_buf[W.sym_buf+X++]&255)<<8,G=W.pending_buf[W.sym_buf+X++],V===0)W0(W,G,Q);else{if(Y=t0[G],W0(W,Y+V1+1,Q),U=n1[Y],U!==0)G-=q8[Y],l(W,G,U);if(V--,Y=k6(V),W0(W,Y,J),U=j1[Y],U!==0)V-=R1[Y],l(W,V,U)}while(X<W.sym_next);W0(W,X8,Q)},o1=(W,Q)=>{const J=Q.dyn_tree,V=Q.stat_desc.static_tree,G=Q.stat_desc.has_stree,X=Q.stat_desc.elems;let Y,U,z=-1,q;W.heap_len=0,W.heap_max=U6;for(Y=0;Y<X;Y++)if(J[Y*2]!==0)W.heap[++W.heap_len]=z=Y,W.depth[Y]=0;else J[Y*2+1]=0;while(W.heap_len<2)if(q=W.heap[++W.heap_len]=z<2?++z:0,J[q*2]=1,W.depth[q]=0,W.opt_len--,G)W.static_len-=V[q*2+1];Q.max_code=z;for(Y=W.heap_len>>1;Y>=1;Y--)p1(W,J,Y);q=X;do Y=W.heap[1],W.heap[1]=W.heap[W.heap_len--],p1(W,J,1),U=W.heap[1],W.heap[--W.heap_max]=Y,W.heap[--W.heap_max]=U,J[q*2]=J[Y*2]+J[U*2],W.depth[q]=(W.depth[Y]>=W.depth[U]?W.depth[Y]:W.depth[U])+1,J[Y*2+1]=J[U*2+1]=q,W.heap[1]=q++,p1(W,J,1);while(W.heap_len>=2);W.heap[--W.heap_max]=W.heap[1],S5(W,Q),B6(J,z,W.bl_count)},I8=(W,Q,J)=>{let V,G=-1,X,Y=Q[1],U=0,z=7,q=4;if(Y===0)z=138,q=3;Q[(J+1)*2+1]=65535;for(V=0;V<=J;V++){if(X=Y,Y=Q[(V+1)*2+1],++U<z&&X===Y)continue;else if(U<q)W.bl_tree[X*2]+=U;else if(X!==0){if(X!==G)W.bl_tree[X*2]++;W.bl_tree[Y6*2]++}else if(U<=10)W.bl_tree[P6*2]++;else W.bl_tree[K6*2]++;if(U=0,G=X,Y===0)z=138,q=3;else if(X===Y)z=6,q=3;else z=7,q=4}},O8=(W,Q,J)=>{let V,G=-1,X,Y=Q[1],U=0,z=7,q=4;if(Y===0)z=138,q=3;for(V=0;V<=J;V++){if(X=Y,Y=Q[(V+1)*2+1],++U<z&&X===Y)continue;else if(U<q)do W0(W,X,W.bl_tree);while(--U!==0);else if(X!==0){if(X!==G)W0(W,X,W.bl_tree),U--;W0(W,Y6,W.bl_tree),l(W,U-3,2)}else if(U<=10)W0(W,P6,W.bl_tree),l(W,U-3,3);else W0(W,K6,W.bl_tree),l(W,U-11,7);if(U=0,G=X,Y===0)z=138,q=3;else if(X===Y)z=6,q=3;else z=7,q=4}},T5=(W)=>{let Q;I8(W,W.dyn_ltree,W.l_desc.max_code),I8(W,W.dyn_dtree,W.d_desc.max_code),o1(W,W.bl_desc);for(Q=G8-1;Q>=3;Q--)if(W.bl_tree[F6[Q]*2+1]!==0)break;return W.opt_len+=3*(Q+1)+5+5+4,Q},g5=(W,Q,J,V)=>{let G;l(W,Q-257,5),l(W,J-1,5),l(W,V-4,4);for(G=0;G<V;G++)l(W,W.bl_tree[F6[G]*2+1],3);O8(W,W.dyn_ltree,Q-1),O8(W,W.dyn_dtree,J-1)},y5=(W)=>{let Q=4093624447,J;for(J=0;J<=31;J++,Q>>>=1)if(Q&1&&W.dyn_ltree[J*2]!==0)return 0;if(W.dyn_ltree[18]!==0||W.dyn_ltree[20]!==0||W.dyn_ltree[26]!==0)return 1;for(J=32;J<V1;J++)if(W.dyn_ltree[J*2]!==0)return 1;return 0},w8=!1,E5=(W)=>{if(!w8)v5(),w8=!0;W.l_desc=new f1(W.dyn_ltree,z6),W.d_desc=new f1(W.dyn_dtree,Z6),W.bl_desc=new f1(W.bl_tree,H6),W.bi_buf=0,W.bi_valid=0,C6(W)},R6=(W,Q,J,V)=>{if(l(W,(L5<<1)+(V?1:0),3),j6(W),e0(W,J),e0(W,~J),J)W.pending_buf.set(W.window.subarray(Q,Q+J),W.pending);W.pending+=J},f5=(W)=>{l(W,q6<<1,3),W0(W,X8,X0),N5(W)},p5=(W,Q,J,V)=>{let G,X,Y=0;if(W.level>0){if(W.strm.data_type===2)W.strm.data_type=y5(W);if(o1(W,W.l_desc),o1(W,W.d_desc),Y=T5(W),G=W.opt_len+3+7>>>3,X=W.static_len+3+7>>>3,X<=G)G=X}else G=X=J+5;if(J+4<=G&&Q!==-1)R6(W,Q,J,V);else if(W.strategy===4||X===G)l(W,(q6<<1)+(V?1:0),3),x8(W,X0,l0);else l(W,(x5<<1)+(V?1:0),3),g5(W,W.l_desc.max_code+1,W.d_desc.max_code+1,Y+1),x8(W,W.dyn_ltree,W.dyn_dtree);if(C6(W),V)j6(W)},h5=(W,Q,J)=>{if(W.pending_buf[W.sym_buf+W.sym_next++]=Q,W.pending_buf[W.sym_buf+W.sym_next++]=Q>>8,W.pending_buf[W.sym_buf+W.sym_next++]=J,Q===0)W.dyn_ltree[J*2]++;else W.matches++,Q--,W.dyn_ltree[(t0[J]+V1+1)*2]++,W.dyn_dtree[k6(Q)*2]++;return W.sym_next===W.sym_end},b5=E5,u5=R6,m5=p5,c5=h5,_5=f5,d5={_tr_init:b5,_tr_stored_block:u5,_tr_flush_block:m5,_tr_tally:c5,_tr_align:_5},i5=(W,Q,J,V)=>{let G=W&65535|0,X=W>>>16&65535|0,Y=0;while(J!==0){Y=J>2000?2000:J,J-=Y;do G=G+Q[V++]|0,X=X+G|0;while(--Y);G%=65521,X%=65521}return G|X<<16|0},s0=i5,l5=()=>{let W,Q=[];for(var J=0;J<256;J++){W=J;for(var V=0;V<8;V++)W=W&1?3988292384^W>>>1:W>>>1;Q[J]=W}return Q},r5=new Uint32Array(l5()),n5=(W,Q,J,V)=>{const G=r5,X=V+J;W^=-1;for(let Y=V;Y<X;Y++)W=W>>>8^G[(W^Q[Y])&255];return W^-1},m=n5,M0={2:"need dictionary",1:"stream end",0:"","-1":"file error","-2":"stream error","-3":"data error","-4":"insufficient memory","-5":"buffer error","-6":"incompatible version"},I0={Z_NO_FLUSH:0,Z_PARTIAL_FLUSH:1,Z_SYNC_FLUSH:2,Z_FULL_FLUSH:3,Z_FINISH:4,Z_BLOCK:5,Z_TREES:6,Z_OK:0,Z_STREAM_END:1,Z_NEED_DICT:2,Z_ERRNO:-1,Z_STREAM_ERROR:-2,Z_DATA_ERROR:-3,Z_MEM_ERROR:-4,Z_BUF_ERROR:-5,Z_NO_COMPRESSION:0,Z_BEST_SPEED:1,Z_BEST_COMPRESSION:9,Z_DEFAULT_COMPRESSION:-1,Z_FILTERED:1,Z_HUFFMAN_ONLY:2,Z_RLE:3,Z_FIXED:4,Z_DEFAULT_STRATEGY:0,Z_BINARY:0,Z_TEXT:1,Z_UNKNOWN:2,Z_DEFLATED:8},{_tr_init:o5,_tr_stored_block:a1,_tr_flush_block:a5,_tr_tally:F0,_tr_align:t5}=d5,{Z_NO_FLUSH:z0,Z_PARTIAL_FLUSH:e5,Z_FULL_FLUSH:s5,Z_FINISH:a,Z_BLOCK:D8,Z_OK:c,Z_STREAM_END:A8,Z_STREAM_ERROR:J0,Z_DATA_ERROR:WW,Z_BUF_ERROR:h1,Z_DEFAULT_COMPRESSION:JW,Z_FILTERED:QW,Z_HUFFMAN_ONLY:H1,Z_RLE:VW,Z_FIXED:GW,Z_DEFAULT_STRATEGY:XW,Z_UNKNOWN:qW,Z_DEFLATED:x1}=I0,UW=9,YW=15,PW=8,KW=29,FW=256,t1=FW+1+KW,zW=30,ZW=19,HW=2*t1+1,kW=15,T=3,K0=258,Q0=K0+T+1,$W=32,g0=42,U8=57,e1=69,s1=73,W8=91,J8=103,j0=113,d0=666,i=1,f0=2,L0=3,p0=4,BW=3,R0=(W,Q)=>{return W.msg=M0[Q],Q},N8=(W)=>{return W*2-(W>4?9:0)},P0=(W)=>{let Q=W.length;while(--Q>=0)W[Q]=0},CW=(W)=>{let Q,J,V,G=W.w_size;Q=W.hash_size,V=Q;do J=W.head[--V],W.head[V]=J>=G?J-G:0;while(--Q);Q=G,V=Q;do J=W.prev[--V],W.prev[V]=J>=G?J-G:0;while(--Q)},jW=(W,Q,J)=>(Q<<W.hash_shift^J)&W.hash_mask,Z0=jW,r=(W)=>{const Q=W.state;let J=Q.pending;if(J>W.avail_out)J=W.avail_out;if(J===0)return;if(W.output.set(Q.pending_buf.subarray(Q.pending_out,Q.pending_out+J),W.next_out),W.next_out+=J,Q.pending_out+=J,W.total_out+=J,W.avail_out-=J,Q.pending-=J,Q.pending===0)Q.pending_out=0},n=(W,Q)=>{a5(W,W.block_start>=0?W.block_start:-1,W.strstart-W.block_start,Q),W.block_start=W.strstart,r(W.strm)},y=(W,Q)=>{W.pending_buf[W.pending++]=Q},_0=(W,Q)=>{W.pending_buf[W.pending++]=Q>>>8&255,W.pending_buf[W.pending++]=Q&255},Q8=(W,Q,J,V)=>{let G=W.avail_in;if(G>V)G=V;if(G===0)return 0;if(W.avail_in-=G,Q.set(W.input.subarray(W.next_in,W.next_in+G),J),W.state.wrap===1)W.adler=s0(W.adler,Q,G,J);else if(W.state.wrap===2)W.adler=m(W.adler,Q,G,J);return W.next_in+=G,W.total_in+=G,G},M6=(W,Q)=>{let{max_chain_length:J,strstart:V}=W,G,X,Y=W.prev_length,U=W.nice_match;const z=W.strstart>W.w_size-Q0?W.strstart-(W.w_size-Q0):0,q=W.window,P=W.w_mask,$=W.prev,F=W.strstart+K0;let K=q[V+Y-1],H=q[V+Y];if(W.prev_length>=W.good_match)J>>=2;if(U>W.lookahead)U=W.lookahead;do{if(G=Q,q[G+Y]!==H||q[G+Y-1]!==K||q[G]!==q[V]||q[++G]!==q[V+1])continue;V+=2,G++;do;while(q[++V]===q[++G]&&q[++V]===q[++G]&&q[++V]===q[++G]&&q[++V]===q[++G]&&q[++V]===q[++G]&&q[++V]===q[++G]&&q[++V]===q[++G]&&q[++V]===q[++G]&&V<F);if(X=K0-(F-V),V=F-K0,X>Y){if(W.match_start=Q,Y=X,X>=U)break;K=q[V+Y-1],H=q[V+Y]}}while((Q=$[Q&P])>z&&--J!==0);if(Y<=W.lookahead)return Y;return W.lookahead},y0=(W)=>{const Q=W.w_size;let J,V,G;do{if(V=W.window_size-W.lookahead-W.strstart,W.strstart>=Q+(Q-Q0)){if(W.window.set(W.window.subarray(Q,Q+Q-V),0),W.match_start-=Q,W.strstart-=Q,W.block_start-=Q,W.insert>W.strstart)W.insert=W.strstart;CW(W),V+=Q}if(W.strm.avail_in===0)break;if(J=Q8(W.strm,W.window,W.strstart+W.lookahead,V),W.lookahead+=J,W.lookahead+W.insert>=T){G=W.strstart-W.insert,W.ins_h=W.window[G],W.ins_h=Z0(W,W.ins_h,W.window[G+1]);while(W.insert)if(W.ins_h=Z0(W,W.ins_h,W.window[G+T-1]),W.prev[G&W.w_mask]=W.head[W.ins_h],W.head[W.ins_h]=G,G++,W.insert--,W.lookahead+W.insert<T)break}}while(W.lookahead<Q0&&W.strm.avail_in!==0)},L6=(W,Q)=>{let J=W.pending_buf_size-5>W.w_size?W.w_size:W.pending_buf_size-5,V,G,X,Y=0,U=W.strm.avail_in;do{if(V=65535,X=W.bi_valid+42>>3,W.strm.avail_out<X)break;if(X=W.strm.avail_out-X,G=W.strstart-W.block_start,V>G+W.strm.avail_in)V=G+W.strm.avail_in;if(V>X)V=X;if(V<J&&(V===0&&Q!==a||Q===z0||V!==G+W.strm.avail_in))break;if(Y=Q===a&&V===G+W.strm.avail_in?1:0,a1(W,0,0,Y),W.pending_buf[W.pending-4]=V,W.pending_buf[W.pending-3]=V>>8,W.pending_buf[W.pending-2]=~V,W.pending_buf[W.pending-1]=~V>>8,r(W.strm),G){if(G>V)G=V;W.strm.output.set(W.window.subarray(W.block_start,W.block_start+G),W.strm.next_out),W.strm.next_out+=G,W.strm.avail_out-=G,W.strm.total_out+=G,W.block_start+=G,V-=G}if(V)Q8(W.strm,W.strm.output,W.strm.next_out,V),W.strm.next_out+=V,W.strm.avail_out-=V,W.strm.total_out+=V}while(Y===0);if(U-=W.strm.avail_in,U){if(U>=W.w_size)W.matches=2,W.window.set(W.strm.input.subarray(W.strm.next_in-W.w_size,W.strm.next_in),0),W.strstart=W.w_size,W.insert=W.strstart;else{if(W.window_size-W.strstart<=U){if(W.strstart-=W.w_size,W.window.set(W.window.subarray(W.w_size,W.w_size+W.strstart),0),W.matches<2)W.matches++;if(W.insert>W.strstart)W.insert=W.strstart}W.window.set(W.strm.input.subarray(W.strm.next_in-U,W.strm.next_in),W.strstart),W.strstart+=U,W.insert+=U>W.w_size-W.insert?W.w_size-W.insert:U}W.block_start=W.strstart}if(W.high_water<W.strstart)W.high_water=W.strstart;if(Y)return p0;if(Q!==z0&&Q!==a&&W.strm.avail_in===0&&W.strstart===W.block_start)return f0;if(X=W.window_size-W.strstart,W.strm.avail_in>X&&W.block_start>=W.w_size){if(W.block_start-=W.w_size,W.strstart-=W.w_size,W.window.set(W.window.subarray(W.w_size,W.w_size+W.strstart),0),W.matches<2)W.matches++;if(X+=W.w_size,W.insert>W.strstart)W.insert=W.strstart}if(X>W.strm.avail_in)X=W.strm.avail_in;if(X)Q8(W.strm,W.window,W.strstart,X),W.strstart+=X,W.insert+=X>W.w_size-W.insert?W.w_size-W.insert:X;if(W.high_water<W.strstart)W.high_water=W.strstart;if(X=W.bi_valid+42>>3,X=W.pending_buf_size-X>65535?65535:W.pending_buf_size-X,J=X>W.w_size?W.w_size:X,G=W.strstart-W.block_start,G>=J||(G||Q===a)&&Q!==z0&&W.strm.avail_in===0&&G<=X)V=G>X?X:G,Y=Q===a&&W.strm.avail_in===0&&V===G?1:0,a1(W,W.block_start,V,Y),W.block_start+=V,r(W.strm);return Y?L0:i},b1=(W,Q)=>{let J,V;for(;;){if(W.lookahead<Q0){if(y0(W),W.lookahead<Q0&&Q===z0)return i;if(W.lookahead===0)break}if(J=0,W.lookahead>=T)W.ins_h=Z0(W,W.ins_h,W.window[W.strstart+T-1]),J=W.prev[W.strstart&W.w_mask]=W.head[W.ins_h],W.head[W.ins_h]=W.strstart;if(J!==0&&W.strstart-J<=W.w_size-Q0)W.match_length=M6(W,J);if(W.match_length>=T)if(V=F0(W,W.strstart-W.match_start,W.match_length-T),W.lookahead-=W.match_length,W.match_length<=W.max_lazy_match&&W.lookahead>=T){W.match_length--;do W.strstart++,W.ins_h=Z0(W,W.ins_h,W.window[W.strstart+T-1]),J=W.prev[W.strstart&W.w_mask]=W.head[W.ins_h],W.head[W.ins_h]=W.strstart;while(--W.match_length!==0);W.strstart++}else W.strstart+=W.match_length,W.match_length=0,W.ins_h=W.window[W.strstart],W.ins_h=Z0(W,W.ins_h,W.window[W.strstart+1]);else V=F0(W,0,W.window[W.strstart]),W.lookahead--,W.strstart++;if(V){if(n(W,!1),W.strm.avail_out===0)return i}}if(W.insert=W.strstart<T-1?W.strstart:T-1,Q===a){if(n(W,!0),W.strm.avail_out===0)return L0;return p0}if(W.sym_next){if(n(W,!1),W.strm.avail_out===0)return i}return f0},S0=(W,Q)=>{let J,V,G;for(;;){if(W.lookahead<Q0){if(y0(W),W.lookahead<Q0&&Q===z0)return i;if(W.lookahead===0)break}if(J=0,W.lookahead>=T)W.ins_h=Z0(W,W.ins_h,W.window[W.strstart+T-1]),J=W.prev[W.strstart&W.w_mask]=W.head[W.ins_h],W.head[W.ins_h]=W.strstart;if(W.prev_length=W.match_length,W.prev_match=W.match_start,W.match_length=T-1,J!==0&&W.prev_length<W.max_lazy_match&&W.strstart-J<=W.w_size-Q0){if(W.match_length=M6(W,J),W.match_length<=5&&(W.strategy===QW||W.match_length===T&&W.strstart-W.match_start>4096))W.match_length=T-1}if(W.prev_length>=T&&W.match_length<=W.prev_length){G=W.strstart+W.lookahead-T,V=F0(W,W.strstart-1-W.prev_match,W.prev_length-T),W.lookahead-=W.prev_length-1,W.prev_length-=2;do if(++W.strstart<=G)W.ins_h=Z0(W,W.ins_h,W.window[W.strstart+T-1]),J=W.prev[W.strstart&W.w_mask]=W.head[W.ins_h],W.head[W.ins_h]=W.strstart;while(--W.prev_length!==0);if(W.match_available=0,W.match_length=T-1,W.strstart++,V){if(n(W,!1),W.strm.avail_out===0)return i}}else if(W.match_available){if(V=F0(W,0,W.window[W.strstart-1]),V)n(W,!1);if(W.strstart++,W.lookahead--,W.strm.avail_out===0)return i}else W.match_available=1,W.strstart++,W.lookahead--}if(W.match_available)V=F0(W,0,W.window[W.strstart-1]),W.match_available=0;if(W.insert=W.strstart<T-1?W.strstart:T-1,Q===a){if(n(W,!0),W.strm.avail_out===0)return L0;return p0}if(W.sym_next){if(n(W,!1),W.strm.avail_out===0)return i}return f0},RW=(W,Q)=>{let J,V,G,X;const Y=W.window;for(;;){if(W.lookahead<=K0){if(y0(W),W.lookahead<=K0&&Q===z0)return i;if(W.lookahead===0)break}if(W.match_length=0,W.lookahead>=T&&W.strstart>0){if(G=W.strstart-1,V=Y[G],V===Y[++G]&&V===Y[++G]&&V===Y[++G]){X=W.strstart+K0;do;while(V===Y[++G]&&V===Y[++G]&&V===Y[++G]&&V===Y[++G]&&V===Y[++G]&&V===Y[++G]&&V===Y[++G]&&V===Y[++G]&&G<X);if(W.match_length=K0-(X-G),W.match_length>W.lookahead)W.match_length=W.lookahead}}if(W.match_length>=T)J=F0(W,1,W.match_length-T),W.lookahead-=W.match_length,W.strstart+=W.match_length,W.match_length=0;else J=F0(W,0,W.window[W.strstart]),W.lookahead--,W.strstart++;if(J){if(n(W,!1),W.strm.avail_out===0)return i}}if(W.insert=0,Q===a){if(n(W,!0),W.strm.avail_out===0)return L0;return p0}if(W.sym_next){if(n(W,!1),W.strm.avail_out===0)return i}return f0},MW=(W,Q)=>{let J;for(;;){if(W.lookahead===0){if(y0(W),W.lookahead===0){if(Q===z0)return i;break}}if(W.match_length=0,J=F0(W,0,W.window[W.strstart]),W.lookahead--,W.strstart++,J){if(n(W,!1),W.strm.avail_out===0)return i}}if(W.insert=0,Q===a){if(n(W,!0),W.strm.avail_out===0)return L0;return p0}if(W.sym_next){if(n(W,!1),W.strm.avail_out===0)return i}return f0},i0=[new s(0,0,0,0,L6),new s(4,4,8,4,b1),new s(4,5,16,8,b1),new s(4,6,32,32,b1),new s(4,4,16,16,S0),new s(8,16,32,32,S0),new s(8,16,128,128,S0),new s(8,32,128,256,S0),new s(32,128,258,1024,S0),new s(32,258,258,4096,S0)],LW=(W)=>{W.window_size=2*W.w_size,P0(W.head),W.max_lazy_match=i0[W.level].max_lazy,W.good_match=i0[W.level].good_length,W.nice_match=i0[W.level].nice_length,W.max_chain_length=i0[W.level].max_chain,W.strstart=0,W.block_start=0,W.lookahead=0,W.insert=0,W.match_length=W.prev_length=T-1,W.match_available=0,W.ins_h=0},G1=(W)=>{if(!W)return 1;const Q=W.state;if(!Q||Q.strm!==W||Q.status!==g0&&Q.status!==U8&&Q.status!==e1&&Q.status!==s1&&Q.status!==W8&&Q.status!==J8&&Q.status!==j0&&Q.status!==d0)return 1;return 0},x6=(W)=>{if(G1(W))return R0(W,J0);W.total_in=W.total_out=0,W.data_type=qW;const Q=W.state;if(Q.pending=0,Q.pending_out=0,Q.wrap<0)Q.wrap=-Q.wrap;return Q.status=Q.wrap===2?U8:Q.wrap?g0:j0,W.adler=Q.wrap===2?0:1,Q.last_flush=-2,o5(Q),c},I6=(W)=>{const Q=x6(W);if(Q===c)LW(W.state);return Q},IW=(W,Q)=>{if(G1(W)||W.state.wrap!==2)return J0;return W.state.gzhead=Q,c},O6=(W,Q,J,V,G,X)=>{if(!W)return J0;let Y=1;if(Q===JW)Q=6;if(V<0)Y=0,V=-V;else if(V>15)Y=2,V-=16;if(G<1||G>UW||J!==x1||V<8||V>15||Q<0||Q>9||X<0||X>GW||V===8&&Y!==1)return R0(W,J0);if(V===8)V=9;const U=new xW;return W.state=U,U.strm=W,U.status=g0,U.wrap=Y,U.gzhead=null,U.w_bits=V,U.w_size=1<<U.w_bits,U.w_mask=U.w_size-1,U.hash_bits=G+7,U.hash_size=1<<U.hash_bits,U.hash_mask=U.hash_size-1,U.hash_shift=~~((U.hash_bits+T-1)/T),U.window=new Uint8Array(U.w_size*2),U.head=new Uint16Array(U.hash_size),U.prev=new Uint16Array(U.w_size),U.lit_bufsize=1<<G+6,U.pending_buf_size=U.lit_bufsize*4,U.pending_buf=new Uint8Array(U.pending_buf_size),U.sym_buf=U.lit_bufsize,U.sym_end=(U.lit_bufsize-1)*3,U.level=Q,U.strategy=X,U.method=J,I6(W)},OW=(W,Q)=>{return O6(W,Q,x1,YW,PW,XW)},wW=(W,Q)=>{if(G1(W)||Q>D8||Q<0)return W?R0(W,J0):J0;const J=W.state;if(!W.output||W.avail_in!==0&&!W.input||J.status===d0&&Q!==a)return R0(W,W.avail_out===0?h1:J0);const V=J.last_flush;if(J.last_flush=Q,J.pending!==0){if(r(W),W.avail_out===0)return J.last_flush=-1,c}else if(W.avail_in===0&&N8(Q)<=N8(V)&&Q!==a)return R0(W,h1);if(J.status===d0&&W.avail_in!==0)return R0(W,h1);if(J.status===g0&&J.wrap===0)J.status=j0;if(J.status===g0){let G=x1+(J.w_bits-8<<4)<<8,X=-1;if(J.strategy>=H1||J.level<2)X=0;else if(J.level<6)X=1;else if(J.level===6)X=2;else X=3;if(G|=X<<6,J.strstart!==0)G|=$W;if(G+=31-G%31,_0(J,G),J.strstart!==0)_0(J,W.adler>>>16),_0(J,W.adler&65535);if(W.adler=1,J.status=j0,r(W),J.pending!==0)return J.last_flush=-1,c}if(J.status===U8)if(W.adler=0,y(J,31),y(J,139),y(J,8),!J.gzhead){if(y(J,0),y(J,0),y(J,0),y(J,0),y(J,0),y(J,J.level===9?2:J.strategy>=H1||J.level<2?4:0),y(J,BW),J.status=j0,r(W),J.pending!==0)return J.last_flush=-1,c}else{if(y(J,(J.gzhead.text?1:0)+(J.gzhead.hcrc?2:0)+(!J.gzhead.extra?0:4)+(!J.gzhead.name?0:8)+(!J.gzhead.comment?0:16)),y(J,J.gzhead.time&255),y(J,J.gzhead.time>>8&255),y(J,J.gzhead.time>>16&255),y(J,J.gzhead.time>>24&255),y(J,J.level===9?2:J.strategy>=H1||J.level<2?4:0),y(J,J.gzhead.os&255),J.gzhead.extra&&J.gzhead.extra.length)y(J,J.gzhead.extra.length&255),y(J,J.gzhead.extra.length>>8&255);if(J.gzhead.hcrc)W.adler=m(W.adler,J.pending_buf,J.pending,0);J.gzindex=0,J.status=e1}if(J.status===e1){if(J.gzhead.extra){let G=J.pending,X=(J.gzhead.extra.length&65535)-J.gzindex;while(J.pending+X>J.pending_buf_size){let U=J.pending_buf_size-J.pending;if(J.pending_buf.set(J.gzhead.extra.subarray(J.gzindex,J.gzindex+U),J.pending),J.pending=J.pending_buf_size,J.gzhead.hcrc&&J.pending>G)W.adler=m(W.adler,J.pending_buf,J.pending-G,G);if(J.gzindex+=U,r(W),J.pending!==0)return J.last_flush=-1,c;G=0,X-=U}let Y=new Uint8Array(J.gzhead.extra);if(J.pending_buf.set(Y.subarray(J.gzindex,J.gzindex+X),J.pending),J.pending+=X,J.gzhead.hcrc&&J.pending>G)W.adler=m(W.adler,J.pending_buf,J.pending-G,G);J.gzindex=0}J.status=s1}if(J.status===s1){if(J.gzhead.name){let G=J.pending,X;do{if(J.pending===J.pending_buf_size){if(J.gzhead.hcrc&&J.pending>G)W.adler=m(W.adler,J.pending_buf,J.pending-G,G);if(r(W),J.pending!==0)return J.last_flush=-1,c;G=0}if(J.gzindex<J.gzhead.name.length)X=J.gzhead.name.charCodeAt(J.gzindex++)&255;else X=0;y(J,X)}while(X!==0);if(J.gzhead.hcrc&&J.pending>G)W.adler=m(W.adler,J.pending_buf,J.pending-G,G);J.gzindex=0}J.status=W8}if(J.status===W8){if(J.gzhead.comment){let G=J.pending,X;do{if(J.pending===J.pending_buf_size){if(J.gzhead.hcrc&&J.pending>G)W.adler=m(W.adler,J.pending_buf,J.pending-G,G);if(r(W),J.pending!==0)return J.last_flush=-1,c;G=0}if(J.gzindex<J.gzhead.comment.length)X=J.gzhead.comment.charCodeAt(J.gzindex++)&255;else X=0;y(J,X)}while(X!==0);if(J.gzhead.hcrc&&J.pending>G)W.adler=m(W.adler,J.pending_buf,J.pending-G,G)}J.status=J8}if(J.status===J8){if(J.gzhead.hcrc){if(J.pending+2>J.pending_buf_size){if(r(W),J.pending!==0)return J.last_flush=-1,c}y(J,W.adler&255),y(J,W.adler>>8&255),W.adler=0}if(J.status=j0,r(W),J.pending!==0)return J.last_flush=-1,c}if(W.avail_in!==0||J.lookahead!==0||Q!==z0&&J.status!==d0){let G=J.level===0?L6(J,Q):J.strategy===H1?MW(J,Q):J.strategy===VW?RW(J,Q):i0[J.level].func(J,Q);if(G===L0||G===p0)J.status=d0;if(G===i||G===L0){if(W.avail_out===0)J.last_flush=-1;return c}if(G===f0){if(Q===e5)t5(J);else if(Q!==D8){if(a1(J,0,0,!1),Q===s5){if(P0(J.head),J.lookahead===0)J.strstart=0,J.block_start=0,J.insert=0}}if(r(W),W.avail_out===0)return J.last_flush=-1,c}}if(Q!==a)return c;if(J.wrap<=0)return A8;if(J.wrap===2)y(J,W.adler&255),y(J,W.adler>>8&255),y(J,W.adler>>16&255),y(J,W.adler>>24&255),y(J,W.total_in&255),y(J,W.total_in>>8&255),y(J,W.total_in>>16&255),y(J,W.total_in>>24&255);else _0(J,W.adler>>>16),_0(J,W.adler&65535);if(r(W),J.wrap>0)J.wrap=-J.wrap;return J.pending!==0?c:A8},DW=(W)=>{if(G1(W))return J0;const Q=W.state.status;return W.state=null,Q===j0?R0(W,WW):c},AW=(W,Q)=>{let J=Q.length;if(G1(W))return J0;const V=W.state,G=V.wrap;if(G===2||G===1&&V.status!==g0||V.lookahead)return J0;if(G===1)W.adler=s0(W.adler,Q,J,0);if(V.wrap=0,J>=V.w_size){if(G===0)P0(V.head),V.strstart=0,V.block_start=0,V.insert=0;let z=new Uint8Array(V.w_size);z.set(Q.subarray(J-V.w_size,J),0),Q=z,J=V.w_size}const{avail_in:X,next_in:Y,input:U}=W;W.avail_in=J,W.next_in=0,W.input=Q,y0(V);while(V.lookahead>=T){let z=V.strstart,q=V.lookahead-(T-1);do V.ins_h=Z0(V,V.ins_h,V.window[z+T-1]),V.prev[z&V.w_mask]=V.head[V.ins_h],V.head[V.ins_h]=z,z++;while(--q);V.strstart=z,V.lookahead=T-1,y0(V)}return V.strstart+=V.lookahead,V.block_start=V.strstart,V.insert=V.lookahead,V.lookahead=0,V.match_length=V.prev_length=T-1,V.match_available=0,W.next_in=Y,W.input=U,W.avail_in=X,V.wrap=G,c},NW=OW,SW=O6,vW=I6,TW=x6,gW=IW,yW=wW,EW=DW,fW=AW,pW="pako deflate (from Nodeca project)",r0={deflateInit:NW,deflateInit2:SW,deflateReset:vW,deflateResetKeep:TW,deflateSetHeader:gW,deflate:yW,deflateEnd:EW,deflateSetDictionary:fW,deflateInfo:pW},hW=(W,Q)=>{return Object.prototype.hasOwnProperty.call(W,Q)},bW=function(W){const Q=Array.prototype.slice.call(arguments,1);while(Q.length){const J=Q.shift();if(!J)continue;if(typeof J!=="object")throw new TypeError(J+"must be non-object");for(let V in J)if(hW(J,V))W[V]=J[V]}return W},uW=(W)=>{let Q=0;for(let V=0,G=W.length;V<G;V++)Q+=W[V].length;const J=new Uint8Array(Q);for(let V=0,G=0,X=W.length;V<X;V++){let Y=W[V];J.set(Y,G),G+=Y.length}return J},I1={assign:bW,flattenChunks:uW},w6=!0;try{String.fromCharCode.apply(null,new Uint8Array(1))}catch(W){w6=!1}var W1=new Uint8Array(256);for(let W=0;W<256;W++)W1[W]=W>=252?6:W>=248?5:W>=240?4:W>=224?3:W>=192?2:1;W1[254]=W1[254]=1;var mW=(W)=>{if(typeof TextEncoder==="function"&&TextEncoder.prototype.encode)return(new TextEncoder()).encode(W);let Q,J,V,G,X,Y=W.length,U=0;for(G=0;G<Y;G++){if(J=W.charCodeAt(G),(J&64512)===55296&&G+1<Y){if(V=W.charCodeAt(G+1),(V&64512)===56320)J=65536+(J-55296<<10)+(V-56320),G++}U+=J<128?1:J<2048?2:J<65536?3:4}Q=new Uint8Array(U);for(X=0,G=0;X<U;G++){if(J=W.charCodeAt(G),(J&64512)===55296&&G+1<Y){if(V=W.charCodeAt(G+1),(V&64512)===56320)J=65536+(J-55296<<10)+(V-56320),G++}if(J<128)Q[X++]=J;else if(J<2048)Q[X++]=192|J>>>6,Q[X++]=128|J&63;else if(J<65536)Q[X++]=224|J>>>12,Q[X++]=128|J>>>6&63,Q[X++]=128|J&63;else Q[X++]=240|J>>>18,Q[X++]=128|J>>>12&63,Q[X++]=128|J>>>6&63,Q[X++]=128|J&63}return Q},cW=(W,Q)=>{if(Q<65534){if(W.subarray&&w6)return String.fromCharCode.apply(null,W.length===Q?W:W.subarray(0,Q))}let J="";for(let V=0;V<Q;V++)J+=String.fromCharCode(W[V]);return J},_W=(W,Q)=>{const J=Q||W.length;if(typeof TextDecoder==="function"&&TextDecoder.prototype.decode)return(new TextDecoder()).decode(W.subarray(0,Q));let V,G;const X=new Array(J*2);for(G=0,V=0;V<J;){let Y=W[V++];if(Y<128){X[G++]=Y;continue}let U=W1[Y];if(U>4){X[G++]=65533,V+=U-1;continue}Y&=U===2?31:U===3?15:7;while(U>1&&V<J)Y=Y<<6|W[V++]&63,U--;if(U>1){X[G++]=65533;continue}if(Y<65536)X[G++]=Y;else Y-=65536,X[G++]=55296|Y>>10&1023,X[G++]=56320|Y&1023}return cW(X,G)},dW=(W,Q)=>{if(Q=Q||W.length,Q>W.length)Q=W.length;let J=Q-1;while(J>=0&&(W[J]&192)===128)J--;if(J<0)return Q;if(J===0)return Q;return J+W1[W[J]]>Q?J:Q},J1={string2buf:mW,buf2string:_W,utf8border:dW},D6=iW,A6=Object.prototype.toString,{Z_NO_FLUSH:lW,Z_SYNC_FLUSH:rW,Z_FULL_FLUSH:nW,Z_FINISH:oW,Z_OK:M1,Z_STREAM_END:aW,Z_DEFAULT_COMPRESSION:tW,Z_DEFAULT_STRATEGY:eW,Z_DEFLATED:sW}=I0;X1.prototype.push=function(W,Q){const J=this.strm,V=this.options.chunkSize;let G,X;if(this.ended)return!1;if(Q===~~Q)X=Q;else X=Q===!0?oW:lW;if(typeof W==="string")J.input=J1.string2buf(W);else if(A6.call(W)==="[object ArrayBuffer]")J.input=new Uint8Array(W);else J.input=W;J.next_in=0,J.avail_in=J.input.length;for(;;){if(J.avail_out===0)J.output=new Uint8Array(V),J.next_out=0,J.avail_out=V;if((X===rW||X===nW)&&J.avail_out<=6){this.onData(J.output.subarray(0,J.next_out)),J.avail_out=0;continue}if(G=r0.deflate(J,X),G===aW){if(J.next_out>0)this.onData(J.output.subarray(0,J.next_out));return G=r0.deflateEnd(this.strm),this.onEnd(G),this.ended=!0,G===M1}if(J.avail_out===0){this.onData(J.output);continue}if(X>0&&J.next_out>0){this.onData(J.output.subarray(0,J.next_out)),J.avail_out=0;continue}if(J.avail_in===0)break}return!0};X1.prototype.onData=function(W){this.chunks.push(W)};X1.prototype.onEnd=function(W){if(W===M1)this.result=I1.flattenChunks(this.chunks);this.chunks=[],this.err=W,this.msg=this.strm.msg};var QJ=X1,VJ=Y8,GJ=WJ,XJ=JJ,qJ=I0,UJ={Deflate:QJ,deflate:VJ,deflateRaw:GJ,gzip:XJ,constants:qJ},k1=16209,YJ=16191,PJ=function W(Q,J){let V,G,X,Y,U,z,q,P,$,F,K,H,S,x,M,D,O,Z,g,h,C,v,A,L;const N=Q.state;V=Q.next_in,A=Q.input,G=V+(Q.avail_in-5),X=Q.next_out,L=Q.output,Y=X-(J-Q.avail_out),U=X+(Q.avail_out-257),z=N.dmax,q=N.wsize,P=N.whave,$=N.wnext,F=N.window,K=N.hold,H=N.bits,S=N.lencode,x=N.distcode,M=(1<<N.lenbits)-1,D=(1<<N.distbits)-1;W:do{if(H<15)K+=A[V++]<<H,H+=8,K+=A[V++]<<H,H+=8;O=S[K&M];J:for(;;){if(Z=O>>>24,K>>>=Z,H-=Z,Z=O>>>16&255,Z===0)L[X++]=O&65535;else if(Z&16){if(g=O&65535,Z&=15,Z){if(H<Z)K+=A[V++]<<H,H+=8;g+=K&(1<<Z)-1,K>>>=Z,H-=Z}if(H<15)K+=A[V++]<<H,H+=8,K+=A[V++]<<H,H+=8;O=x[K&D];Q:for(;;){if(Z=O>>>24,K>>>=Z,H-=Z,Z=O>>>16&255,Z&16){if(h=O&65535,Z&=15,H<Z){if(K+=A[V++]<<H,H+=8,H<Z)K+=A[V++]<<H,H+=8}if(h+=K&(1<<Z)-1,h>z){Q.msg="invalid distance too far back",N.mode=k1;break W}if(K>>>=Z,H-=Z,Z=X-Y,h>Z){if(Z=h-Z,Z>P){if(N.sane){Q.msg="invalid distance too far back",N.mode=k1;break W}}if(C=0,v=F,$===0){if(C+=q-Z,Z<g){g-=Z;do L[X++]=F[C++];while(--Z);C=X-h,v=L}}else if($<Z){if(C+=q+$-Z,Z-=$,Z<g){g-=Z;do L[X++]=F[C++];while(--Z);if(C=0,$<g){Z=$,g-=Z;do L[X++]=F[C++];while(--Z);C=X-h,v=L}}}else if(C+=$-Z,Z<g){g-=Z;do L[X++]=F[C++];while(--Z);C=X-h,v=L}while(g>2)L[X++]=v[C++],L[X++]=v[C++],L[X++]=v[C++],g-=3;if(g){if(L[X++]=v[C++],g>1)L[X++]=v[C++]}}else{C=X-h;do L[X++]=L[C++],L[X++]=L[C++],L[X++]=L[C++],g-=3;while(g>2);if(g){if(L[X++]=L[C++],g>1)L[X++]=L[C++]}}}else if((Z&64)===0){O=x[(O&65535)+(K&(1<<Z)-1)];continue Q}else{Q.msg="invalid distance code",N.mode=k1;break W}break}}else if((Z&64)===0){O=S[(O&65535)+(K&(1<<Z)-1)];continue J}else if(Z&32){N.mode=YJ;break W}else{Q.msg="invalid literal/length code",N.mode=k1;break W}break}}while(V<G&&X<U);g=H>>3,V-=g,H-=g<<3,K&=(1<<H)-1,Q.next_in=V,Q.next_out=X,Q.avail_in=V<G?5+(G-V):5-(V-G),Q.avail_out=X<U?257+(U-X):257-(X-U),N.hold=K,N.bits=H;return},v0=15,S8=852,v8=592,T8=0,u1=1,g8=2,KJ=new Uint16Array([3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,0,0]),FJ=new Uint8Array([16,16,16,16,16,16,16,16,17,17,17,17,18,18,18,18,19,19,19,19,20,20,20,20,21,21,21,21,16,72,78]),zJ=new Uint16Array([1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,0,0]),ZJ=new Uint8Array([16,16,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,64,64]),HJ=(W,Q,J,V,G,X,Y,U)=>{const z=U.bits;let q=0,P=0,$=0,F=0,K=0,H=0,S=0,x=0,M=0,D=0,O,Z,g,h,C,v=null,A;const L=new Uint16Array(v0+1),N=new Uint16Array(v0+1);let e=null,H0,U0,k0;for(q=0;q<=v0;q++)L[q]=0;for(P=0;P<V;P++)L[Q[J+P]]++;K=z;for(F=v0;F>=1;F--)if(L[F]!==0)break;if(K>F)K=F;if(F===0)return G[X++]=1<<24|64<<16|0,G[X++]=1<<24|64<<16|0,U.bits=1,0;for($=1;$<F;$++)if(L[$]!==0)break;if(K<$)K=$;x=1;for(q=1;q<=v0;q++)if(x<<=1,x-=L[q],x<0)return-1;if(x>0&&(W===T8||F!==1))return-1;N[1]=0;for(q=1;q<v0;q++)N[q+1]=N[q]+L[q];for(P=0;P<V;P++)if(Q[J+P]!==0)Y[N[Q[J+P]]++]=P;if(W===T8)v=e=Y,A=20;else if(W===u1)v=KJ,e=FJ,A=257;else v=zJ,e=ZJ,A=0;if(D=0,P=0,q=$,C=X,H=K,S=0,g=-1,M=1<<K,h=M-1,W===u1&&M>S8||W===g8&&M>v8)return 1;for(;;){if(H0=q-S,Y[P]+1<A)U0=0,k0=Y[P];else if(Y[P]>=A)U0=e[Y[P]-A],k0=v[Y[P]-A];else U0=96,k0=0;O=1<<q-S,Z=1<<H,$=Z;do Z-=O,G[C+(D>>S)+Z]=H0<<24|U0<<16|k0|0;while(Z!==0);O=1<<q-1;while(D&O)O>>=1;if(O!==0)D&=O-1,D+=O;else D=0;if(P++,--L[q]===0){if(q===F)break;q=Q[J+Y[P]]}if(q>K&&(D&h)!==g){if(S===0)S=K;C+=$,H=q-S,x=1<<H;while(H+S<F){if(x-=L[H+S],x<=0)break;H++,x<<=1}if(M+=1<<H,W===u1&&M>S8||W===g8&&M>v8)return 1;g=D&h,G[g]=K<<24|H<<16|C-X|0}}if(D!==0)G[C+D]=q-S<<24|64<<16|0;return U.bits=K,0},n0=HJ,kJ=0,N6=1,S6=2,{Z_FINISH:y8,Z_BLOCK:$J,Z_TREES:$1,Z_OK:x0,Z_STREAM_END:BJ,Z_NEED_DICT:CJ,Z_STREAM_ERROR:t,Z_DATA_ERROR:v6,Z_MEM_ERROR:T6,Z_BUF_ERROR:jJ,Z_DEFLATED:E8}=I0,O1=16180,f8=16181,p8=16182,h8=16183,b8=16184,u8=16185,m8=16186,c8=16187,_8=16188,d8=16189,L1=16190,G0=16191,m1=16192,i8=16193,c1=16194,l8=16195,r8=16196,n8=16197,o8=16198,B1=16199,C1=16200,a8=16201,t8=16202,e8=16203,s8=16204,W6=16205,_1=16206,J6=16207,Q6=16208,b=16209,g6=16210,y6=16211,RJ=852,MJ=592,LJ=15,xJ=LJ,V6=(W)=>{return(W>>>24&255)+(W>>>8&65280)+((W&65280)<<8)+((W&255)<<24)},O0=(W)=>{if(!W)return 1;const Q=W.state;if(!Q||Q.strm!==W||Q.mode<O1||Q.mode>y6)return 1;return 0},E6=(W)=>{if(O0(W))return t;const Q=W.state;if(W.total_in=W.total_out=Q.total=0,W.msg="",Q.wrap)W.adler=Q.wrap&1;return Q.mode=O1,Q.last=0,Q.havedict=0,Q.flags=-1,Q.dmax=32768,Q.head=null,Q.hold=0,Q.bits=0,Q.lencode=Q.lendyn=new Int32Array(RJ),Q.distcode=Q.distdyn=new Int32Array(MJ),Q.sane=1,Q.back=-1,x0},f6=(W)=>{if(O0(W))return t;const Q=W.state;return Q.wsize=0,Q.whave=0,Q.wnext=0,E6(W)},p6=(W,Q)=>{let J;if(O0(W))return t;const V=W.state;if(Q<0)J=0,Q=-Q;else if(J=(Q>>4)+5,Q<48)Q&=15;if(Q&&(Q<8||Q>15))return t;if(V.window!==null&&V.wbits!==Q)V.window=null;return V.wrap=J,V.wbits=Q,f6(W)},h6=(W,Q)=>{if(!W)return t;const J=new IJ;W.state=J,J.strm=W,J.window=null,J.mode=O1;const V=p6(W,Q);if(V!==x0)W.state=null;return V},OJ=(W)=>{return h6(W,xJ)},G6=!0,d1,i1,wJ=(W)=>{if(G6){d1=new Int32Array(512),i1=new Int32Array(32);let Q=0;while(Q<144)W.lens[Q++]=8;while(Q<256)W.lens[Q++]=9;while(Q<280)W.lens[Q++]=7;while(Q<288)W.lens[Q++]=8;n0(N6,W.lens,0,288,d1,0,W.work,{bits:9}),Q=0;while(Q<32)W.lens[Q++]=5;n0(S6,W.lens,0,32,i1,0,W.work,{bits:5}),G6=!1}W.lencode=d1,W.lenbits=9,W.distcode=i1,W.distbits=5},b6=(W,Q,J,V)=>{let G;const X=W.state;if(X.window===null)X.wsize=1<<X.wbits,X.wnext=0,X.whave=0,X.window=new Uint8Array(X.wsize);if(V>=X.wsize)X.window.set(Q.subarray(J-X.wsize,J),0),X.wnext=0,X.whave=X.wsize;else{if(G=X.wsize-X.wnext,G>V)G=V;if(X.window.set(Q.subarray(J-V,J-V+G),X.wnext),V-=G,V)X.window.set(Q.subarray(J-V,J),0),X.wnext=V,X.whave=X.wsize;else{if(X.wnext+=G,X.wnext===X.wsize)X.wnext=0;if(X.whave<X.wsize)X.whave+=G}}return 0},DJ=(W,Q)=>{let J,V,G,X,Y,U,z,q,P,$,F,K,H,S,x=0,M,D,O,Z,g,h,C,v;const A=new Uint8Array(4);let L,N;const e=new Uint8Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]);if(O0(W)||!W.output||!W.input&&W.avail_in!==0)return t;if(J=W.state,J.mode===G0)J.mode=m1;Y=W.next_out,G=W.output,z=W.avail_out,X=W.next_in,V=W.input,U=W.avail_in,q=J.hold,P=J.bits,$=U,F=z,v=x0;W:for(;;)switch(J.mode){case O1:if(J.wrap===0){J.mode=m1;break}while(P<16){if(U===0)break W;U--,q+=V[X++]<<P,P+=8}if(J.wrap&2&&q===35615){if(J.wbits===0)J.wbits=15;J.check=0,A[0]=q&255,A[1]=q>>>8&255,J.check=m(J.check,A,2,0),q=0,P=0,J.mode=f8;break}if(J.head)J.head.done=!1;if(!(J.wrap&1)||(((q&255)<<8)+(q>>8))%31){W.msg="incorrect header check",J.mode=b;break}if((q&15)!==E8){W.msg="unknown compression method",J.mode=b;break}if(q>>>=4,P-=4,C=(q&15)+8,J.wbits===0)J.wbits=C;if(C>15||C>J.wbits){W.msg="invalid window size",J.mode=b;break}J.dmax=1<<J.wbits,J.flags=0,W.adler=J.check=1,J.mode=q&512?d8:G0,q=0,P=0;break;case f8:while(P<16){if(U===0)break W;U--,q+=V[X++]<<P,P+=8}if(J.flags=q,(J.flags&255)!==E8){W.msg="unknown compression method",J.mode=b;break}if(J.flags&57344){W.msg="unknown header flags set",J.mode=b;break}if(J.head)J.head.text=q>>8&1;if(J.flags&512&&J.wrap&4)A[0]=q&255,A[1]=q>>>8&255,J.check=m(J.check,A,2,0);q=0,P=0,J.mode=p8;case p8:while(P<32){if(U===0)break W;U--,q+=V[X++]<<P,P+=8}if(J.head)J.head.time=q;if(J.flags&512&&J.wrap&4)A[0]=q&255,A[1]=q>>>8&255,A[2]=q>>>16&255,A[3]=q>>>24&255,J.check=m(J.check,A,4,0);q=0,P=0,J.mode=h8;case h8:while(P<16){if(U===0)break W;U--,q+=V[X++]<<P,P+=8}if(J.head)J.head.xflags=q&255,J.head.os=q>>8;if(J.flags&512&&J.wrap&4)A[0]=q&255,A[1]=q>>>8&255,J.check=m(J.check,A,2,0);q=0,P=0,J.mode=b8;case b8:if(J.flags&1024){while(P<16){if(U===0)break W;U--,q+=V[X++]<<P,P+=8}if(J.length=q,J.head)J.head.extra_len=q;if(J.flags&512&&J.wrap&4)A[0]=q&255,A[1]=q>>>8&255,J.check=m(J.check,A,2,0);q=0,P=0}else if(J.head)J.head.extra=null;J.mode=u8;case u8:if(J.flags&1024){if(K=J.length,K>U)K=U;if(K){if(J.head){if(C=J.head.extra_len-J.length,!J.head.extra)J.head.extra=new Uint8Array(J.head.extra_len);J.head.extra.set(V.subarray(X,X+K),C)}if(J.flags&512&&J.wrap&4)J.check=m(J.check,V,K,X);U-=K,X+=K,J.length-=K}if(J.length)break W}J.length=0,J.mode=m8;case m8:if(J.flags&2048){if(U===0)break W;K=0;do if(C=V[X+K++],J.head&&C&&J.length<65536)J.head.name+=String.fromCharCode(C);while(C&&K<U);if(J.flags&512&&J.wrap&4)J.check=m(J.check,V,K,X);if(U-=K,X+=K,C)break W}else if(J.head)J.head.name=null;J.length=0,J.mode=c8;case c8:if(J.flags&4096){if(U===0)break W;K=0;do if(C=V[X+K++],J.head&&C&&J.length<65536)J.head.comment+=String.fromCharCode(C);while(C&&K<U);if(J.flags&512&&J.wrap&4)J.check=m(J.check,V,K,X);if(U-=K,X+=K,C)break W}else if(J.head)J.head.comment=null;J.mode=_8;case _8:if(J.flags&512){while(P<16){if(U===0)break W;U--,q+=V[X++]<<P,P+=8}if(J.wrap&4&&q!==(J.check&65535)){W.msg="header crc mismatch",J.mode=b;break}q=0,P=0}if(J.head)J.head.hcrc=J.flags>>9&1,J.head.done=!0;W.adler=J.check=0,J.mode=G0;break;case d8:while(P<32){if(U===0)break W;U--,q+=V[X++]<<P,P+=8}W.adler=J.check=V6(q),q=0,P=0,J.mode=L1;case L1:if(J.havedict===0)return W.next_out=Y,W.avail_out=z,W.next_in=X,W.avail_in=U,J.hold=q,J.bits=P,CJ;W.adler=J.check=1,J.mode=G0;case G0:if(Q===$J||Q===$1)break W;case m1:if(J.last){q>>>=P&7,P-=P&7,J.mode=_1;break}while(P<3){if(U===0)break W;U--,q+=V[X++]<<P,P+=8}switch(J.last=q&1,q>>>=1,P-=1,q&3){case 0:J.mode=i8;break;case 1:if(wJ(J),J.mode=B1,Q===$1){q>>>=2,P-=2;break W}break;case 2:J.mode=r8;break;case 3:W.msg="invalid block type",J.mode=b}q>>>=2,P-=2;break;case i8:q>>>=P&7,P-=P&7;while(P<32){if(U===0)break W;U--,q+=V[X++]<<P,P+=8}if((q&65535)!==(q>>>16^65535)){W.msg="invalid stored block lengths",J.mode=b;break}if(J.length=q&65535,q=0,P=0,J.mode=c1,Q===$1)break W;case c1:J.mode=l8;case l8:if(K=J.length,K){if(K>U)K=U;if(K>z)K=z;if(K===0)break W;G.set(V.subarray(X,X+K),Y),U-=K,X+=K,z-=K,Y+=K,J.length-=K;break}J.mode=G0;break;case r8:while(P<14){if(U===0)break W;U--,q+=V[X++]<<P,P+=8}if(J.nlen=(q&31)+257,q>>>=5,P-=5,J.ndist=(q&31)+1,q>>>=5,P-=5,J.ncode=(q&15)+4,q>>>=4,P-=4,J.nlen>286||J.ndist>30){W.msg="too many length or distance symbols",J.mode=b;break}J.have=0,J.mode=n8;case n8:while(J.have<J.ncode){while(P<3){if(U===0)break W;U--,q+=V[X++]<<P,P+=8}J.lens[e[J.have++]]=q&7,q>>>=3,P-=3}while(J.have<19)J.lens[e[J.have++]]=0;if(J.lencode=J.lendyn,J.lenbits=7,L={bits:J.lenbits},v=n0(kJ,J.lens,0,19,J.lencode,0,J.work,L),J.lenbits=L.bits,v){W.msg="invalid code lengths set",J.mode=b;break}J.have=0,J.mode=o8;case o8:while(J.have<J.nlen+J.ndist){for(;;){if(x=J.lencode[q&(1<<J.lenbits)-1],M=x>>>24,D=x>>>16&255,O=x&65535,M<=P)break;if(U===0)break W;U--,q+=V[X++]<<P,P+=8}if(O<16)q>>>=M,P-=M,J.lens[J.have++]=O;else{if(O===16){N=M+2;while(P<N){if(U===0)break W;U--,q+=V[X++]<<P,P+=8}if(q>>>=M,P-=M,J.have===0){W.msg="invalid bit length repeat",J.mode=b;break}C=J.lens[J.have-1],K=3+(q&3),q>>>=2,P-=2}else if(O===17){N=M+3;while(P<N){if(U===0)break W;U--,q+=V[X++]<<P,P+=8}q>>>=M,P-=M,C=0,K=3+(q&7),q>>>=3,P-=3}else{N=M+7;while(P<N){if(U===0)break W;U--,q+=V[X++]<<P,P+=8}q>>>=M,P-=M,C=0,K=11+(q&127),q>>>=7,P-=7}if(J.have+K>J.nlen+J.ndist){W.msg="invalid bit length repeat",J.mode=b;break}while(K--)J.lens[J.have++]=C}}if(J.mode===b)break;if(J.lens[256]===0){W.msg="invalid code -- missing end-of-block",J.mode=b;break}if(J.lenbits=9,L={bits:J.lenbits},v=n0(N6,J.lens,0,J.nlen,J.lencode,0,J.work,L),J.lenbits=L.bits,v){W.msg="invalid literal/lengths set",J.mode=b;break}if(J.distbits=6,J.distcode=J.distdyn,L={bits:J.distbits},v=n0(S6,J.lens,J.nlen,J.ndist,J.distcode,0,J.work,L),J.distbits=L.bits,v){W.msg="invalid distances set",J.mode=b;break}if(J.mode=B1,Q===$1)break W;case B1:J.mode=C1;case C1:if(U>=6&&z>=258){if(W.next_out=Y,W.avail_out=z,W.next_in=X,W.avail_in=U,J.hold=q,J.bits=P,PJ(W,F),Y=W.next_out,G=W.output,z=W.avail_out,X=W.next_in,V=W.input,U=W.avail_in,q=J.hold,P=J.bits,J.mode===G0)J.back=-1;break}J.back=0;for(;;){if(x=J.lencode[q&(1<<J.lenbits)-1],M=x>>>24,D=x>>>16&255,O=x&65535,M<=P)break;if(U===0)break W;U--,q+=V[X++]<<P,P+=8}if(D&&(D&240)===0){Z=M,g=D,h=O;for(;;){if(x=J.lencode[h+((q&(1<<Z+g)-1)>>Z)],M=x>>>24,D=x>>>16&255,O=x&65535,Z+M<=P)break;if(U===0)break W;U--,q+=V[X++]<<P,P+=8}q>>>=Z,P-=Z,J.back+=Z}if(q>>>=M,P-=M,J.back+=M,J.length=O,D===0){J.mode=W6;break}if(D&32){J.back=-1,J.mode=G0;break}if(D&64){W.msg="invalid literal/length code",J.mode=b;break}J.extra=D&15,J.mode=a8;case a8:if(J.extra){N=J.extra;while(P<N){if(U===0)break W;U--,q+=V[X++]<<P,P+=8}J.length+=q&(1<<J.extra)-1,q>>>=J.extra,P-=J.extra,J.back+=J.extra}J.was=J.length,J.mode=t8;case t8:for(;;){if(x=J.distcode[q&(1<<J.distbits)-1],M=x>>>24,D=x>>>16&255,O=x&65535,M<=P)break;if(U===0)break W;U--,q+=V[X++]<<P,P+=8}if((D&240)===0){Z=M,g=D,h=O;for(;;){if(x=J.distcode[h+((q&(1<<Z+g)-1)>>Z)],M=x>>>24,D=x>>>16&255,O=x&65535,Z+M<=P)break;if(U===0)break W;U--,q+=V[X++]<<P,P+=8}q>>>=Z,P-=Z,J.back+=Z}if(q>>>=M,P-=M,J.back+=M,D&64){W.msg="invalid distance code",J.mode=b;break}J.offset=O,J.extra=D&15,J.mode=e8;case e8:if(J.extra){N=J.extra;while(P<N){if(U===0)break W;U--,q+=V[X++]<<P,P+=8}J.offset+=q&(1<<J.extra)-1,q>>>=J.extra,P-=J.extra,J.back+=J.extra}if(J.offset>J.dmax){W.msg="invalid distance too far back",J.mode=b;break}J.mode=s8;case s8:if(z===0)break W;if(K=F-z,J.offset>K){if(K=J.offset-K,K>J.whave){if(J.sane){W.msg="invalid distance too far back",J.mode=b;break}}if(K>J.wnext)K-=J.wnext,H=J.wsize-K;else H=J.wnext-K;if(K>J.length)K=J.length;S=J.window}else S=G,H=Y-J.offset,K=J.length;if(K>z)K=z;z-=K,J.length-=K;do G[Y++]=S[H++];while(--K);if(J.length===0)J.mode=C1;break;case W6:if(z===0)break W;G[Y++]=J.length,z--,J.mode=C1;break;case _1:if(J.wrap){while(P<32){if(U===0)break W;U--,q|=V[X++]<<P,P+=8}if(F-=z,W.total_out+=F,J.total+=F,J.wrap&4&&F)W.adler=J.check=J.flags?m(J.check,G,F,Y-F):s0(J.check,G,F,Y-F);if(F=z,J.wrap&4&&(J.flags?q:V6(q))!==J.check){W.msg="incorrect data check",J.mode=b;break}q=0,P=0}J.mode=J6;case J6:if(J.wrap&&J.flags){while(P<32){if(U===0)break W;U--,q+=V[X++]<<P,P+=8}if(J.wrap&4&&q!==(J.total&4294967295)){W.msg="incorrect length check",J.mode=b;break}q=0,P=0}J.mode=Q6;case Q6:v=BJ;break W;case b:v=v6;break W;case g6:return T6;case y6:default:return t}if(W.next_out=Y,W.avail_out=z,W.next_in=X,W.avail_in=U,J.hold=q,J.bits=P,J.wsize||F!==W.avail_out&&J.mode<b&&(J.mode<_1||Q!==y8)){if(b6(W,W.output,W.next_out,F-W.avail_out));}if($-=W.avail_in,F-=W.avail_out,W.total_in+=$,W.total_out+=F,J.total+=F,J.wrap&4&&F)W.adler=J.check=J.flags?m(J.check,G,F,W.next_out-F):s0(J.check,G,F,W.next_out-F);if(W.data_type=J.bits+(J.last?64:0)+(J.mode===G0?128:0)+(J.mode===B1||J.mode===c1?256:0),($===0&&F===0||Q===y8)&&v===x0)v=jJ;return v},AJ=(W)=>{if(O0(W))return t;let Q=W.state;if(Q.window)Q.window=null;return W.state=null,x0},NJ=(W,Q)=>{if(O0(W))return t;const J=W.state;if((J.wrap&2)===0)return t;return J.head=Q,Q.done=!1,x0},SJ=(W,Q)=>{const J=Q.length;let V,G,X;if(O0(W))return t;if(V=W.state,V.wrap!==0&&V.mode!==L1)return t;if(V.mode===L1){if(G=1,G=s0(G,Q,J,0),G!==V.check)return v6}if(X=b6(W,Q,J,J),X)return V.mode=g6,T6;return V.havedict=1,x0},vJ=f6,TJ=p6,gJ=E6,yJ=OJ,EJ=h6,fJ=DJ,pJ=AJ,hJ=NJ,bJ=SJ,uJ="pako inflate (from Nodeca project)",q0={inflateReset:vJ,inflateReset2:TJ,inflateResetKeep:gJ,inflateInit:yJ,inflateInit2:EJ,inflate:fJ,inflateEnd:pJ,inflateGetHeader:hJ,inflateSetDictionary:bJ,inflateInfo:uJ},cJ=mJ,u6=Object.prototype.toString,{Z_NO_FLUSH:_J,Z_FINISH:dJ,Z_OK:Q1,Z_STREAM_END:l1,Z_NEED_DICT:r1,Z_STREAM_ERROR:iJ,Z_DATA_ERROR:X6,Z_MEM_ERROR:lJ}=I0;q1.prototype.push=function(W,Q){const J=this.strm,V=this.options.chunkSize,G=this.options.dictionary;let X,Y,U;if(this.ended)return!1;if(Q===~~Q)Y=Q;else Y=Q===!0?dJ:_J;if(u6.call(W)==="[object ArrayBuffer]")J.input=new Uint8Array(W);else J.input=W;J.next_in=0,J.avail_in=J.input.length;for(;;){if(J.avail_out===0)J.output=new Uint8Array(V),J.next_out=0,J.avail_out=V;if(X=q0.inflate(J,Y),X===r1&&G){if(X=q0.inflateSetDictionary(J,G),X===Q1)X=q0.inflate(J,Y);else if(X===X6)X=r1}while(J.avail_in>0&&X===l1&&J.state.wrap>0&&W[J.next_in]!==0)q0.inflateReset(J),X=q0.inflate(J,Y);switch(X){case iJ:case X6:case r1:case lJ:return this.onEnd(X),this.ended=!0,!1}if(U=J.avail_out,J.next_out){if(J.avail_out===0||X===l1)if(this.options.to==="string"){let z=J1.utf8border(J.output,J.next_out),q=J.next_out-z,P=J1.buf2string(J.output,z);if(J.next_out=q,J.avail_out=V-q,q)J.output.set(J.output.subarray(z,z+q),0);this.onData(P)}else this.onData(J.output.length===J.next_out?J.output:J.output.subarray(0,J.next_out))}if(X===Q1&&U===0)continue;if(X===l1)return X=q0.inflateEnd(this.strm),this.onEnd(X),this.ended=!0,!0;if(J.avail_in===0)break}return!0};q1.prototype.onData=function(W){this.chunks.push(W)};q1.prototype.onEnd=function(W){if(W===Q1)if(this.options.to==="string")this.result=this.chunks.join("");else this.result=I1.flattenChunks(this.chunks);this.chunks=[],this.err=W,this.msg=this.strm.msg};var nJ=q1,oJ=P8,aJ=rJ,tJ=P8,eJ=I0,sJ={Inflate:nJ,inflate:oJ,inflateRaw:aJ,ungzip:tJ,constants:eJ},{Deflate:W7,deflate:J7,deflateRaw:Q7,gzip:V7}=UJ,{Inflate:G7,inflate:X7,inflateRaw:q7,ungzip:U7}=sJ,Y7=W7,P7=J7,K7=Q7,F7=V7,z7=G7,Z7=X7,H7=q7,k7=U7,$7=I0,h0={Deflate:Y7,deflate:P7,deflateRaw:K7,gzip:F7,Inflate:z7,inflate:Z7,inflateRaw:H7,ungzip:k7,constants:$7};function m6(W,Q,J){let V=Q.timestamp;if(V?.physical>Date.now()+7200000)V={physical:Date.now()+7200000,logical:V.logical};if(!W?.timestamp)return{resolved:!0,value:Q.value,timestamp:V};if(J.compare(V,W.timestamp)<=0)return{resolved:!1};return{resolved:!0,value:Q.value,timestamp:V}}function c6(W,Q=50){const J=`gdb_oplog_${W}`;let V=[];function G(){try{const Y=localStorage.getItem(J);V=Y?JSON.parse(Y):[]}catch(Y){console.error("\u274C GDB: Failed to load oplog from localStorage:",Y),V=[]}}function X(){try{localStorage.setItem(J,JSON.stringify(V))}catch(Y){console.error("\u274C GDB: Failed to save oplog to localStorage:",Y)}}return G(),{remove(Y){V=V.filter((U)=>U.id!==Y),X()},add(Y){if(V.push(Y),V.length>Q)V.shift();X()},getDelta(Y,U){if(!Y)return[...V];return V.filter((z)=>U(z.timestamp,Y)>0)},getOldest(){return V[0]},clear(){V=[],localStorage.removeItem(J)}}}var B7=()=>{const W=new Map,Q=async()=>{try{const z=await navigator.storage.getDirectory(),P=await(await z.getFileHandle("~opfs-sync-test",{create:!0})).createSyncAccessHandle?.();return await P?.close(),await z.removeEntry("~opfs-sync-test"),!!P}catch{return!1}};let J="idb";const V=(async()=>{if(await Q())J="sync";else try{const z=await navigator.storage.getDirectory(),P=await(await z.getFileHandle("~opfs-async-test",{create:!0})).createWritable?.();if(await P?.close(),await z.removeEntry("~opfs-async-test"),P)J="async";else J="idb"}catch{J="idb"}})(),G=async(z,q)=>{if(!W.has(z))W.set(z,[]);const P=W.get(z),$=P[P.length-1]||Promise.resolve();let F;const K=new Promise((H)=>F=H);P.push(K);try{return await $,await q()}finally{if(P.shift(),F(),P.length===0)W.delete(z)}},X=(()=>{let z;const q=async()=>{if(!z)z=new Promise((P,$)=>{const F=indexedDB.open("opfs-fallback-db",1);F.onupgradeneeded=()=>F.result.createObjectStore("files"),F.onsuccess=()=>P(F.result),F.onerror=()=>$(F.error)});return z};return{getDB:q,get:async(P)=>{const $=await q();return new Promise((F,K)=>{const S=$.transaction("files","readonly").objectStore("files").get(P);S.onsuccess=()=>F(S.result||new Uint8Array),S.onerror=()=>K(S.error)})},set:async(P,$)=>{const F=await q();return new Promise((K,H)=>{const x=F.transaction("files","readwrite").objectStore("files").put($,P);x.onsuccess=()=>K(),x.onerror=()=>H(x.error)})}}})(),Y=async(z)=>{await V;try{if(J==="idb"){const K=await X.get(z);return{type:"loaded",name:z,data:K}}const P=await(await navigator.storage.getDirectory()).getFileHandle(z);if(J==="sync"){let K;try{K=await P.createSyncAccessHandle();const H=K.getSize(),S=new Uint8Array(H),x=K.read(S,{at:0});return{type:"loaded",name:z,data:S.slice(0,x)}}finally{K?.close()}}const $=await P.getFile(),F=new Uint8Array(await $.arrayBuffer());return{type:"loaded",name:z,data:F}}catch(q){const P=q.name==="NotFoundError"?"File not found":q.message||"Error reading file";return{type:"error",name:z,message:P}}},U=async(z,q)=>{if(await V,!(q instanceof Uint8Array))return{type:"error",name:z,message:"Content must be a Uint8Array"};return G(z,async()=>{try{if(J==="idb")return await X.set(z,q),{type:"saved",name:z};const $=await(await navigator.storage.getDirectory()).getFileHandle(z,{create:!0});if(J==="sync"){let F;try{F=await $.createSyncAccessHandle(),F.truncate(0),F.write(q,{at:0}),F.flush()}finally{F?.close()}}else{let F;try{F=await $.createWritable(),await F.write(q)}finally{await F?.close()}}return{type:"saved",name:z}}catch(P){return{type:"error",name:z,message:P.message||"Error saving file"}}})};self.onmessage=async({data:z})=>{const{type:q,name:P,content:$}=z;await V;const F={load:()=>Y(P),save:()=>U(P,$)};try{const K=F[q],H=K?await K():{type:"error",message:`Unrecognized action type: ${q}`};self.postMessage(H)}catch(K){console.error("\u274C Worker unexpected error:",K),self.postMessage({type:"error",name:P,message:K.message||"Unexpected worker error"})}}},_6=B7;var U1={$eq:(W,Q)=>W===Q,$ne:(W,Q)=>W!==Q,$gt:(W,Q)=>W>Q,$gte:(W,Q)=>W>=Q,$lt:(W,Q)=>W<Q,$lte:(W,Q)=>W<=Q,$in:(W,Q)=>Array.isArray(Q)&&(Array.isArray(W)?W.some((J)=>Q.includes(J)):Q.includes(W)),$between:(W,[Q,J])=>W>=Q&&W<=J,$exists:(W,Q)=>Q?W!==void 0:W===void 0,$text:{global:(W,Q)=>{const J=(G)=>String(G).normalize("NFD").replace(/[\u0300-\u036f]/g,"").toLowerCase().replace(/[^\w\s]/g,""),V=J(Q);return Object.values(W).some((G)=>typeof G==="object"?null.fieldSearch(G,V):J(G).includes(V))},field:(W,Q)=>{const J=(G)=>String(G).normalize("NFD").replace(/[\u0300-\u036f]/g,"").toLowerCase().replace(/[^\w\s]/g,""),V=J(Q);return Array.isArray(W)?W.some((G)=>J(G).includes(V)):J(W).includes(V)}},$like:(W,Q)=>typeof W==="string"&&typeof Q==="string"&&new RegExp(`^${Q.replace(/%/g,".*").replace(/_/g,".")}\$`,"i").test(W),$regex:(W,Q)=>typeof W==="string"&&new RegExp(Q.$regex||Q,"i").test(W),$and:(W,Q,J)=>Q.every((V)=>J.createFilter(V,J.allNodes)(W)),$or:(W,Q,J)=>Q.some((V)=>J.createFilter(V,J.allNodes)(W)),$not:(W,Q,J)=>!J.createFilter(Q,J.allNodes)(W),$edge:(W,Q,J)=>{if(!W.edges?.length||typeof Q!=="object"||Q===null)return!1;const V=J.createFilter(Q,J.allNodes),G=[...W.edges],X=new Set(G).add(W.id),Y=[];while(G.length){const U=G.shift(),z=J.allNodes[U];if(!z)continue;if(V(z))Y.push(z);z.edges?.forEach((q)=>!X.has(q)&&X.add(q)&&G.push(q))}if(Y.length)W._edgeResult=Y;return Y.length>0}},K8=(W,Q)=>Q.split(".").reduce((J,V)=>J&&typeof J==="object"&&(V in J)?J[V]:void 0,W),w1=(W,Q)=>{if(Object.keys(W).length===0)return()=>!0;return(J)=>Object.entries(W).every(([V,G])=>{if(V.startsWith("$"))return U1[V](J,G,{createFilter:w1,allNodes:Q});const X=K8(J.value,V);if(typeof G!=="object"||G===null)return U1.$eq(X,G);return Object.entries(G).every(([Y,U])=>{if(Y==="$text")return U1.$text.field(X,U);if(Y==="$between"&&U.every((z)=>z instanceof Date))return U1.$between(new Date(X),U);return U1[Y]?.(X,U,{createFilter:w1,allNodes:Q})??!1})})},F8=(W,Q)=>{const{$edge:J,...V}=Q.query||{},G=w1(V,W),X=Object.values(W).filter(G);let U=[...J?(()=>{const z=w1({$edge:J},W);X.forEach((P)=>z(P));const q=new Map;return X.forEach((P)=>{if(P._edgeResult)P._edgeResult.forEach(($)=>q.set($.id,$)),delete P._edgeResult}),Array.from(q.values())})():X];if(Q.field){const z=Q.order==="asc"?1:-1;U.sort((q,P)=>{const $=K8(q.value,Q.field),F=K8(P.value,Q.field);if(typeof $==="string"&&typeof F==="string")return $.localeCompare(F)*z;return(($??0)-(F??0))*z})}if(Q.$after){const z=U.findIndex((q)=>q.id===Q.$after);U=z>=0?U.slice(z+1):[]}if(Q.$before){const z=U.findIndex((q)=>q.id===Q.$before);U=z>=0?U.slice(0,z):[]}if(Q.$limit)U=U.slice(0,Q.$limit);return U};function d6(){let W=Date.now(),Q=0;return{now(){const J=Date.now();return W=Math.max(W,J),Q++,{physical:W,logical:Q}},update(J){if(!J||typeof J.physical!=="number"||typeof J.logical!=="number"){console.warn("\u26A0\uFE0F HybridClock.update received an invalid remote timestamp.",J);return}W=Math.max(W,J.physical),Q=Math.max(Q,J.logical)+1},compare(J,V){if(!J&&!V)return 0;if(!J)return-1;if(!V)return 1;if(J.physical>V.physical)return 1;if(J.physical<V.physical)return-1;if(J.logical>V.logical)return 1;if(J.logical<V.logical)return-1;return 0}}}var i6=function(W,Q){return W.length===Q.length&&W.every((J,V)=>J===Q[V])};async function j7(){if(console.info(navigator?.storage?.getDirectory?"\u2705 OPFS is enabled.":"\uD83D\uDEAB OPFS is not available."),navigator?.storage?.getDirectory)await navigator.storage.getDirectory()}var R7=function(){const W={nodes:{}};return{get nodes(){return W.nodes},set nodes(J){W.nodes=J||{}},upsert(J,V,G){const X=W.nodes[J];W.nodes[J]={id:J,value:V&&typeof V==="object"?r6(V):V,edges:X?.edges?[...X.edges]:[],timestamp:G}},get(J){return W.nodes[J]||null},link(J,V,G){const X=W.nodes[J],Y=W.nodes[V];if(X&&Y&&!X.edges.includes(V))W.nodes[J]={...X,edges:[...X.edges,V],timestamp:G}},getAllNodes(){return Object.values(W.nodes)},serialize(){return h0.deflate(N0(W.nodes))},deserialize(J){W.nodes=c0(h0.inflate(new Uint8Array(J)))}}};async function n6(W,Q={}){console.info("\x1B[36m\u26A1 GenosDB: Empowering distributed graph databases with real-time synchronization and scalability. Learn more: https://github.com/estebanrfp/gdb \u26A1\x1B[0m");const{rtc:J=!1,password:V,sm:G=!1,audit:X=!1,ii:Y=!1,rx:U=!1,ai:z=!1,geo:q=!1,saveDelay:P=200,oplogSize:$=20}=Q,F=R7(),K=d6(),H=c6(W,$),S=[];let x=null,M=[],D=null,O=null,Z=null,g=null;const h=[],C={};Object.defineProperties(C,{syncChannel:{get:()=>O},broadcastChannel:{get:()=>Z},hybridClock:{get:()=>K},graph:{get:()=>({getAllNodes:()=>F.getAllNodes(),get:(k)=>F.get(k)})},worker:{get:()=>D},oplog:{get:()=>H},options:{get:()=>Q},pako:{get:()=>h0},encode:{get:()=>N0},decode:{get:()=>c0},deepClone:{get:()=>r6}});async function v(k,I){try{const j=await import(new URL(`./${k}.min.js`,import.meta.url).href),E=I&&typeof I==="object"?I:{},B=j.init?.(C,j,E);if(B)Object.assign(C,B);return j}catch(j){throw console.error(`\u274C Initialization of ${k} failed:`,j),j}}function A(){const k=localStorage.getItem(`${W}_time`);x=k?JSON.parse(k):null}function L(k){x=k,localStorage.setItem(`${W}_time`,JSON.stringify(k))}function N(){try{const k=URL.createObjectURL(new Blob([`(${_6.toString()})()`],{type:"application/javascript"}));D=new Worker(k),URL.revokeObjectURL(k),D.addEventListener("message",({data:I})=>{console.info(`\uD83D\uDCBE ${I.name} ${I.type}`)}),console.info("\u2699\uFE0F Worker initialized successfully.")}catch({message:k}){console.error("\u274C Failed to initialize worker:",k)}}function e(){const k={...F.nodes};M.forEach((I)=>I(k))}const H0=C7(()=>e()),U0=l6(async()=>{const k=h.splice(0,h.length);if(!k.length)return!1;return await O.send(k),!0},16);async function k0(){try{const I=await((j)=>new Promise((E,B)=>{const w=async({data:R})=>{if(R.type==="loaded"&&R.name===j)D.removeEventListener("message",w),E(new Uint8Array(R.data));else if(R.type==="error")D.removeEventListener("message",w),B(new Error(R.message||"Unknown error"))};D.addEventListener("message",w),D.postMessage({type:"load",name:j})}))(`${W}_graph.msgpack`).catch(()=>new Uint8Array);I.byteLength>0?F.deserialize(I):console.warn("\u26A0\uFE0F The file '_graph.msgpack' is empty or could not be loaded."),console.info(`\u2705 Graph loaded: [ ${F.getAllNodes().length} nodes ]`)}catch({message:k}){console.error("\u274C Error loading the graph:",k)}}async function D1(){try{const k=F.serialize();return await((j,E)=>new Promise((B,w)=>{const R=({data:f})=>{if(f.type==="saved"&&f.name===j)D.removeEventListener("message",R),B();else if(f.type==="error")D.removeEventListener("message",R),w(new Error(f.message||"Save error"))};D.addEventListener("message",R),D.postMessage({type:"save",name:j,content:E})}))(`${W}_graph.msgpack`,k),Z.postMessage("update"),!0}catch({message:k}){throw console.error("\u274C Save error:",k),new Error("Save failed")}}const A1=l6(()=>D1(),P);async function o6(k){try{console.info("\uD83D\uDD04 Applying full graph from remote..."),F.nodes={...k.nodes},await D1()}catch({message:I}){console.error(`\u274C Error applying the full graph: ${I}`)}}async function a6(k){let I=!1,j=null;const E={upsert:(B)=>{const w=F.get(B.id),R=m6(w,B,K);if(R.resolved){if(F.upsert(B.id,R.value,R.timestamp),K.update(R.timestamp),H.add({type:"upsert",id:B.id,timestamp:R.timestamp}),I=!0,!j||K.compare(R.timestamp,j)>0)j=R.timestamp}},remove:(B)=>{const w=F.get(B.id);if(w&&K.compare(w.timestamp,B.timestamp)<0){if(delete F.nodes[B.id],K.update(B.timestamp),H.add({type:"remove",id:B.id,timestamp:B.timestamp}),I=!0,!j||K.compare(B.timestamp,j)>0)j=B.timestamp}},link:(B)=>{const w=F.get(B.sourceId),R=F.get(B.targetId);if(w&&R&&K.compare(w.timestamp,B.timestamp)<0){if(F.link(B.sourceId,B.targetId,B.timestamp),K.update(B.timestamp),H.add({type:"link",sourceId:B.sourceId,targetId:B.targetId,timestamp:B.timestamp}),I=!0,!j||K.compare(B.timestamp,j)>0)j=B.timestamp}},sync:async(B)=>{const w=B.timestamp;if(w===null){console.info("\uD83D\uDCEC [SYNC REQUEST] from new peer (no timestamp). Sending full graph."),await O.send([{type:"syncReceive",graph:F}]);return}console.info("\uD83D\uDCEC [SYNC REQUEST] since:",new Date(w.physical).toLocaleString());const R=H.getOldest();if(R&&K.compare(w,R.timestamp)<0){console.info("\uD83D\uDCA5 [FALLBACK TRIGGERED] Peer is too far behind. Sending FULL graph state."),await O.send([{type:"syncReceive",graph:F}]);return}const f=H.getDelta(w,K.compare);if(f.length>0){const p=f.map((_)=>{if(_.type==="upsert"){const V0=F.get(_.id);return{..._,value:V0?V0.value:null}}return _}),o=h0.deflate(N0(p));console.info(`\uD83D\uDE80 [DELTA SYNC SENDING] Found ${f.length} new operations to send.`),await O.send([{type:"deltaSync",operations:o}])}else console.info("\u2705 [ALREADY SYNCED] Peer is up-to-date. Nothing to send.")},deltaSync:(B)=>{const w=B.operations.byteLength,R=c0(h0.inflate(B.operations)),f=N0(R).byteLength;console.info(`\uD83D\uDEF0\uFE0F [DELTA SYNC RECEIVED] Applying ${R.length} operations from a peer.`),console.info(`   Compressed: ${w} bytes, Decompressed: ${f} bytes.`);for(let p of R)E[p.type]?.(p)},syncReceive:async(B)=>{if(console.info("\uD83D\uDCE6 [FULL SYNC RECEIVED] Overwriting local state with full graph from a peer."),B.graph&&B.graph.nodes){await o6(B.graph),H.clear(),console.info("\uD83D\uDD12 Oplog has been cleared due to full sync."),I=!0;let w=null;for(let R in B.graph.nodes){const f=B.graph.nodes[R];if(f.timestamp&&(!w||K.compare(f.timestamp,w)>0))w=f.timestamp}if(w)console.info("\uD83D\uDCC8 [GLOBAL TIMESTAMP] Updated from full sync."),j=w,K.update(w)}else console.error("\u274C Full sync failed: received graph data is invalid.",B.graph)}};for(let B of k)if(E[B.type])await E[B.type](B);else console.warn(`\uD83E\uDD37\u200D\u2640\uFE0F [UNKNOWN MESSAGE TYPE] Received unhandled message type: "${B.type}"`);if(j){if(!x||K.compare(j,x)>0)console.info(`\uD83D\uDCC8 [GLOBAL TIMESTAMP] Advanced from ${x?.logical} to ${j.logical}.`),L(j)}if(I)console.info("\uD83D\uDCBE [STATE CHANGED] Saving state and emitting update."),await D1(),e()}Object.assign(C,{use(k){if(typeof k==="function")S.push(k)},async put(k,I){const j=K.now();L(j),I??=crypto.randomUUID(),F.upsert(I,k,j),H.add({type:"upsert",id:I,timestamp:j}),A1();try{h.push({type:"upsert",id:I,value:k,timestamp:j}),U0().catch(()=>{})}finally{H0()}return I},async link(k,I){const j=K.now();if(!F.nodes[k]||!F.nodes[I]){console.warn(`\u26A0\uFE0F One or both nodes (${k}, ${I}) do not exist.`);return}F.link(k,I,j),H.add({type:"link",sourceId:k,targetId:I,timestamp:j}),A1(),L(j);try{h.push({type:"link",sourceId:k,targetId:I,timestamp:j}),U0().catch(()=>{})}finally{H0()}},async remove(k){const I=K.now(),j=F.get(k);if(!j)return console.warn(`\u26A0\uFE0F Node with ID '${k}' not found.`);delete F.nodes[k],H.add({type:"remove",id:k,timestamp:I}),Object.values(F.nodes).forEach((E)=>E.edges=E.edges.filter((B)=>B!==k)),A1(),L(I);try{h.push({type:"remove",id:k,value:j.value,timestamp:I}),U0().catch(()=>{})}finally{H0()}},async get(k,I=null){if(typeof k!=="string")return{result:null};const j=F.get(k);if(!j){if(I)I(null);return{result:null}}const E=(R)=>{if(!R)return null;const f=R.value!==null&&typeof R.value==="object"?{...R.value}:R.value;return{...R,value:f}};if(!I)return{result:E(j)};let B=j.timestamp;I(E(j));const w=(R)=>{const f=R[k];if(f){if(K.compare(f.timestamp,B)>0)B=f.timestamp,I(E(f))}else I(null),M.splice(M.indexOf(w),1)};return M.push(w),{result:E(j),unsubscribe:()=>{const R=M.indexOf(w);if(R>-1)M.splice(R,1)}}},async map(...k){let j={...{realtime:!1,query:{},field:null,order:"asc",$limit:null,$after:null,$before:null}},E=null,B=!1;k.forEach((p)=>typeof p==="function"?E=p:p&&typeof p==="object"&&(B||=("realtime"in p),Object.assign(j,p))),E&&!B&&(j.realtime=!0);let w=F8(F.nodes,j),R=null;const f=(p)=>{const o=new Map(w.map((u)=>[u.id,u])),_=new Map(p.map((u)=>[u.id,u])),V0=[],w0=[],z8=[];for(let[u,Y0]of _){const Y1=o.get(u);if(!Y1)V0.push(Y0);else if((Y0.timestamp?.physical||0)!==(Y1.timestamp?.physical||0)||(Y0.timestamp?.logical||0)!==(Y1.timestamp?.logical||0)||!i6(Y0.edges||[],Y1.edges||[]))w0.push(Y0)}for(let[u]of o)if(!_.has(u))z8.push(o.get(u));const N1=(u,Y0)=>E({id:u.id,value:Y0==="removed"?null:u.value,edges:u.edges||[],timestamp:u.timestamp||null,action:Y0});V0.forEach((u)=>N1(u,"added")),z8.forEach((u)=>N1(u,"removed")),w0.forEach((u)=>N1(u,"updated"))};if(E){if(w.forEach((p)=>{E({id:p.id,value:p.value,edges:p.edges,timestamp:p.timestamp,action:"initial"})}),j.realtime){const p=(o)=>{const _=o.timestamp?.physical||0,V0=o.timestamp?.logical||0,w0=(o.edges||[]).join(",");return`${o.id}:${_}:${V0}:${w0}`};R=(o)=>{const _=F8(o,j);if(_.length!==w.length)f(_),w=_;else{const V0=_.map(p),w0=w.map(p);if(!i6(V0,w0))f(_),w=_}},M.push(R)}}return{results:w,...j.realtime&&E&&R&&{unsubscribe:()=>{const p=M.indexOf(R);p>-1&&M.splice(p,1)}}}},async clear(){F.nodes={};try{await(await navigator.storage.getDirectory()).removeEntry(`${W}_graph.msgpack`)}catch({message:k}){console.warn(`\u26A0\uFE0F Error deleting _graph.msgpack: ${k}`)}e(),console.info("\u2705 All data has been deleted.")}}),N(),A(),await j7(),await k0();const $0=[];if(G)$0.push(v("sm",G));if(z)$0.push(v("AIQuery",z));if(U)$0.push(v("radixindex",U));if(Y)$0.push(v("invertedindex",Y));if(X)$0.push(v("audit",X));if(q)$0.push(v("geo",q));await Promise.all($0);const t6=`graph-sync-room-${W}`;if(J){const{join:k}=await v("genosrtc"),{relayUrls:I,turnConfig:j}=J?.constructor===Object?J:{},E={appId:"1234",...V&&{password:V}};if(I)E.relayUrls=I;if(j)E.turnConfig=j;const B=k(E,t6);O=B.channel("syncGraph"),g=k(E,`app-sync-${W}`),C.room=g,B.on("peer:join",async(w)=>{console.info("\u26A1 New peer connected:",w),O.send([{type:"sync",timestamp:x}])}),B.on("peer:leave",(w)=>{console.info("\u26A1 Peer disconnected:",w)}),O.on("message",async(w)=>{let R=w;for(let f of S)try{if(R=await f(R),!R||R.length===0)return}catch(p){console.error("\u274C GDB: Middleware error, discarding message.",p);return}await a6(R)})}return Z=new BroadcastChannel(`graphdb_sync_${W}`),Z.onmessage=async(k)=>{if(k.data==="update")console.info("\uD83D\uDD04 Update received from another tab..."),await k0(),A(),H0()},console.info(`\u2705 GenosDB [ ${W} ] instance is ready.`),C}var r6=(W)=>{if(W===null||typeof W!=="object")return W;if(typeof structuredClone==="function")return structuredClone(W);return JSON.parse(JSON.stringify(W))},l6=(W,Q=16)=>{let J=null,V=null;return(...G)=>{if(!V)V={},V.promise=new Promise((Y,U)=>(V.resolve=Y,V.reject=U));if(J)("cancelIdleCallback"in window?cancelIdleCallback:clearTimeout)(J);const X=async()=>{J=null;try{V.resolve(await W(...G))}catch(Y){V.reject(Y)}finally{V=null}};return J=("requestIdleCallback"in window)?requestIdleCallback(X,{timeout:Q}):setTimeout(X,Q),V.promise}},C7=(W)=>{let Q=null;return()=>{if(Q!==null)return;Q=requestAnimationFrame(()=>{Q=null,W()})}};var CQ=n6;class M7{constructor(){throw new Error("\u26A0\uFE0F WARNING: `new GDB()` is deprecated and will be removed. "+"Migrate to async factory function `const db = await gdb(...)`.\nMigration Guide: https://github.com/estebanrfp/gdb/wiki/Migration-Guide\nWiki: https://github.com/estebanrfp/gdb/wiki")}}export{CQ as gdb,M7 as GDB};
