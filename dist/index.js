var e5=Object.defineProperty;var JG=(J,G)=>{for(var Q in G)e5(J,Q,{get:G[Q],enumerable:!0,configurable:!0,set:(q)=>G[Q]=()=>q})};function HQ(J){const G=J.length;let Q=0,q=0;while(q<G){let W=J.charCodeAt(q++);if((W&4294967168)===0){Q++;continue}else if((W&4294965248)===0)Q+=2;else{if(W>=55296&&W<=56319){if(q<G){const X=J.charCodeAt(q);if((X&64512)===56320)++q,W=((W&1023)<<10)+(X&1023)+65536}}if((W&4294901760)===0)Q+=3;else Q+=4}}return Q}function QG(J,G,Q){const q=J.length;let W=Q,X=0;while(X<q){let Y=J.charCodeAt(X++);if((Y&4294967168)===0){G[W++]=Y;continue}else if((Y&4294965248)===0)G[W++]=Y>>6&31|192;else{if(Y>=55296&&Y<=56319){if(X<q){const U=J.charCodeAt(X);if((U&64512)===56320)++X,Y=((Y&1023)<<10)+(U&1023)+65536}}if((Y&4294901760)===0)G[W++]=Y>>12&15|224,G[W++]=Y>>6&63|128;else G[W++]=Y>>18&7|240,G[W++]=Y>>12&63|128,G[W++]=Y>>6&63|128}G[W++]=Y&63|128}}function WG(J,G,Q){GG.encodeInto(J,G.subarray(Q))}function PQ(J,G,Q){if(J.length>qG)WG(J,G,Q);else QG(J,G,Q)}function r1(J,G,Q){let q=G;const W=q+Q,X=[];let Y="";while(q<W){const U=J[q++];if((U&128)===0)X.push(U);else if((U&224)===192){const K=J[q++]&63;X.push((U&31)<<6|K)}else if((U&240)===224){const K=J[q++]&63,V=J[q++]&63;X.push((U&31)<<12|K<<6|V)}else if((U&248)===240){const K=J[q++]&63,V=J[q++]&63,Z=J[q++]&63;let j=(U&7)<<18|K<<12|V<<6|Z;if(j>65535)j-=65536,X.push(j>>>10&1023|55296),j=56320|j&1023;X.push(j)}else X.push(U);if(X.length>=XG)Y+=String.fromCharCode(...X),X.length=0}if(X.length>0)Y+=String.fromCharCode(...X);return Y}function VG(J,G,Q){const q=J.subarray(G,G+Q);return YG.decode(q)}function CQ(J,G,Q){if(Q>UG)return VG(J,G,Q);else return r1(J,G,Q)}var GG=new TextEncoder,qG=50,XG=4096,YG=new TextDecoder,UG=200;class j8{constructor(J,G){this.type=J,this.data=G}}class q0 extends Error{constructor(J){super(J);const G=Object.create(q0.prototype);Object.setPrototypeOf(this,G),Object.defineProperty(this,"name",{configurable:!0,enumerable:!1,value:q0.name})}}function DQ(J,G,Q){const q=Q/4294967296,W=Q;J.setUint32(G,q),J.setUint32(G+4,W)}function U1(J,G,Q){const q=Math.floor(Q/4294967296),W=Q;J.setUint32(G,q),J.setUint32(G+4,W)}function V1(J,G){const Q=J.getInt32(G),q=J.getUint32(G+4);return Q*4294967296+q}function OQ(J,G){const Q=J.getUint32(G),q=J.getUint32(G+4);return Q*4294967296+q}var M8=4294967295;function zG({sec:J,nsec:G}){if(J>=0&&G>=0&&J<=$G)if(G===0&&J<=ZG){const Q=new Uint8Array(4);return new DataView(Q.buffer).setUint32(0,J),Q}else{const Q=J/4294967296,q=J&4294967295,W=new Uint8Array(8),X=new DataView(W.buffer);return X.setUint32(0,G<<2|Q&3),X.setUint32(4,q),W}else{const Q=new Uint8Array(12),q=new DataView(Q.buffer);return q.setUint32(0,G),U1(q,4,J),Q}}function jG(J){const G=J.getTime(),Q=Math.floor(G/1000),q=(G-Q*1000)*1e6,W=Math.floor(q/1e9);return{sec:Q+W,nsec:q-W*1e9}}function MG(J){if(J instanceof Date){const G=jG(J);return zG(G)}else return null}function HG(J){const G=new DataView(J.buffer,J.byteOffset,J.byteLength);switch(J.byteLength){case 4:return{sec:G.getUint32(0),nsec:0};case 8:{const Q=G.getUint32(0),q=G.getUint32(4),W=(Q&3)*4294967296+q,X=Q>>>2;return{sec:W,nsec:X}}case 12:{const Q=V1(G,4),q=G.getUint32(0);return{sec:Q,nsec:q}}default:throw new q0(`Unrecognized data size for timestamp (expected 4, 8, or 12): ${J.length}`)}}function PG(J){const G=HG(J);return new Date(G.sec*1000+G.nsec/1e6)}var KG=-1,ZG=4294967295,$G=17179869183,BQ={type:KG,encode:MG,decode:PG};class o0{constructor(){this.builtInEncoders=[],this.builtInDecoders=[],this.encoders=[],this.decoders=[],this.register(BQ)}register({type:J,encode:G,decode:Q}){if(J>=0)this.encoders[J]=G,this.decoders[J]=Q;else{const q=-1-J;this.builtInEncoders[q]=G,this.builtInDecoders[q]=Q}}tryToEncode(J,G){for(let Q=0;Q<this.builtInEncoders.length;Q++){const q=this.builtInEncoders[Q];if(q!=null){const W=q(J,G);if(W!=null){const X=-1-Q;return new j8(X,W)}}}for(let Q=0;Q<this.encoders.length;Q++){const q=this.encoders[Q];if(q!=null){const W=q(J,G);if(W!=null)return new j8(Q,W)}}if(J instanceof j8)return J;return null}decode(J,G,Q){const q=G<0?this.builtInDecoders[-1-G]:this.decoders[G];if(q)return q(J,G,Q);else return new j8(G,J)}}o0.defaultCodec=new o0;var CG=function(J){return J instanceof ArrayBuffer||typeof SharedArrayBuffer!=="undefined"&&J instanceof SharedArrayBuffer};function T8(J){if(J instanceof Uint8Array)return J;else if(ArrayBuffer.isView(J))return new Uint8Array(J.buffer,J.byteOffset,J.byteLength);else if(CG(J))return new Uint8Array(J);else return Uint8Array.from(J)}var DG=100,OG=2048;class K1{constructor(J){this.entered=!1,this.extensionCodec=J?.extensionCodec??o0.defaultCodec,this.context=J?.context,this.useBigInt64=J?.useBigInt64??!1,this.maxDepth=J?.maxDepth??DG,this.initialBufferSize=J?.initialBufferSize??OG,this.sortKeys=J?.sortKeys??!1,this.forceFloat32=J?.forceFloat32??!1,this.ignoreUndefined=J?.ignoreUndefined??!1,this.forceIntegerToFloat=J?.forceIntegerToFloat??!1,this.pos=0,this.view=new DataView(new ArrayBuffer(this.initialBufferSize)),this.bytes=new Uint8Array(this.view.buffer)}clone(){return new K1({extensionCodec:this.extensionCodec,context:this.context,useBigInt64:this.useBigInt64,maxDepth:this.maxDepth,initialBufferSize:this.initialBufferSize,sortKeys:this.sortKeys,forceFloat32:this.forceFloat32,ignoreUndefined:this.ignoreUndefined,forceIntegerToFloat:this.forceIntegerToFloat})}reinitializeState(){this.pos=0}encodeSharedRef(J){if(this.entered)return this.clone().encodeSharedRef(J);try{return this.entered=!0,this.reinitializeState(),this.doEncode(J,1),this.bytes.subarray(0,this.pos)}finally{this.entered=!1}}encode(J){if(this.entered)return this.clone().encode(J);try{return this.entered=!0,this.reinitializeState(),this.doEncode(J,1),this.bytes.slice(0,this.pos)}finally{this.entered=!1}}doEncode(J,G){if(G>this.maxDepth)throw new Error(`Too deep objects in depth ${G}`);if(J==null)this.encodeNil();else if(typeof J==="boolean")this.encodeBoolean(J);else if(typeof J==="number")if(!this.forceIntegerToFloat)this.encodeNumber(J);else this.encodeNumberAsFloat(J);else if(typeof J==="string")this.encodeString(J);else if(this.useBigInt64&&typeof J==="bigint")this.encodeBigInt64(J);else this.encodeObject(J,G)}ensureBufferSizeToWrite(J){const G=this.pos+J;if(this.view.byteLength<G)this.resizeBuffer(G*2)}resizeBuffer(J){const G=new ArrayBuffer(J),Q=new Uint8Array(G),q=new DataView(G);Q.set(this.bytes),this.view=q,this.bytes=Q}encodeNil(){this.writeU8(192)}encodeBoolean(J){if(J===!1)this.writeU8(194);else this.writeU8(195)}encodeNumber(J){if(!this.forceIntegerToFloat&&Number.isSafeInteger(J))if(J>=0)if(J<128)this.writeU8(J);else if(J<256)this.writeU8(204),this.writeU8(J);else if(J<65536)this.writeU8(205),this.writeU16(J);else if(J<4294967296)this.writeU8(206),this.writeU32(J);else if(!this.useBigInt64)this.writeU8(207),this.writeU64(J);else this.encodeNumberAsFloat(J);else if(J>=-32)this.writeU8(224|J+32);else if(J>=-128)this.writeU8(208),this.writeI8(J);else if(J>=-32768)this.writeU8(209),this.writeI16(J);else if(J>=-2147483648)this.writeU8(210),this.writeI32(J);else if(!this.useBigInt64)this.writeU8(211),this.writeI64(J);else this.encodeNumberAsFloat(J);else this.encodeNumberAsFloat(J)}encodeNumberAsFloat(J){if(this.forceFloat32)this.writeU8(202),this.writeF32(J);else this.writeU8(203),this.writeF64(J)}encodeBigInt64(J){if(J>=BigInt(0))this.writeU8(207),this.writeBigUint64(J);else this.writeU8(211),this.writeBigInt64(J)}writeStringHeader(J){if(J<32)this.writeU8(160+J);else if(J<256)this.writeU8(217),this.writeU8(J);else if(J<65536)this.writeU8(218),this.writeU16(J);else if(J<4294967296)this.writeU8(219),this.writeU32(J);else throw new Error(`Too long string: ${J} bytes in UTF-8`)}encodeString(J){const Q=HQ(J);this.ensureBufferSizeToWrite(5+Q),this.writeStringHeader(Q),PQ(J,this.bytes,this.pos),this.pos+=Q}encodeObject(J,G){const Q=this.extensionCodec.tryToEncode(J,this.context);if(Q!=null)this.encodeExtension(Q);else if(Array.isArray(J))this.encodeArray(J,G);else if(ArrayBuffer.isView(J))this.encodeBinary(J);else if(typeof J==="object")this.encodeMap(J,G);else throw new Error(`Unrecognized object: ${Object.prototype.toString.apply(J)}`)}encodeBinary(J){const G=J.byteLength;if(G<256)this.writeU8(196),this.writeU8(G);else if(G<65536)this.writeU8(197),this.writeU16(G);else if(G<4294967296)this.writeU8(198),this.writeU32(G);else throw new Error(`Too large binary: ${G}`);const Q=T8(J);this.writeU8a(Q)}encodeArray(J,G){const Q=J.length;if(Q<16)this.writeU8(144+Q);else if(Q<65536)this.writeU8(220),this.writeU16(Q);else if(Q<4294967296)this.writeU8(221),this.writeU32(Q);else throw new Error(`Too large array: ${Q}`);for(let q of J)this.doEncode(q,G+1)}countWithoutUndefined(J,G){let Q=0;for(let q of G)if(J[q]!==void 0)Q++;return Q}encodeMap(J,G){const Q=Object.keys(J);if(this.sortKeys)Q.sort();const q=this.ignoreUndefined?this.countWithoutUndefined(J,Q):Q.length;if(q<16)this.writeU8(128+q);else if(q<65536)this.writeU8(222),this.writeU16(q);else if(q<4294967296)this.writeU8(223),this.writeU32(q);else throw new Error(`Too large map object: ${q}`);for(let W of Q){const X=J[W];if(!(this.ignoreUndefined&&X===void 0))this.encodeString(W),this.doEncode(X,G+1)}}encodeExtension(J){if(typeof J.data==="function"){const Q=J.data(this.pos+6),q=Q.length;if(q>=4294967296)throw new Error(`Too large extension object: ${q}`);this.writeU8(201),this.writeU32(q),this.writeI8(J.type),this.writeU8a(Q);return}const G=J.data.length;if(G===1)this.writeU8(212);else if(G===2)this.writeU8(213);else if(G===4)this.writeU8(214);else if(G===8)this.writeU8(215);else if(G===16)this.writeU8(216);else if(G<256)this.writeU8(199),this.writeU8(G);else if(G<65536)this.writeU8(200),this.writeU16(G);else if(G<4294967296)this.writeU8(201),this.writeU32(G);else throw new Error(`Too large extension object: ${G}`);this.writeI8(J.type),this.writeU8a(J.data)}writeU8(J){this.ensureBufferSizeToWrite(1),this.view.setUint8(this.pos,J),this.pos++}writeU8a(J){const G=J.length;this.ensureBufferSizeToWrite(G),this.bytes.set(J,this.pos),this.pos+=G}writeI8(J){this.ensureBufferSizeToWrite(1),this.view.setInt8(this.pos,J),this.pos++}writeU16(J){this.ensureBufferSizeToWrite(2),this.view.setUint16(this.pos,J),this.pos+=2}writeI16(J){this.ensureBufferSizeToWrite(2),this.view.setInt16(this.pos,J),this.pos+=2}writeU32(J){this.ensureBufferSizeToWrite(4),this.view.setUint32(this.pos,J),this.pos+=4}writeI32(J){this.ensureBufferSizeToWrite(4),this.view.setInt32(this.pos,J),this.pos+=4}writeF32(J){this.ensureBufferSizeToWrite(4),this.view.setFloat32(this.pos,J),this.pos+=4}writeF64(J){this.ensureBufferSizeToWrite(8),this.view.setFloat64(this.pos,J),this.pos+=8}writeU64(J){this.ensureBufferSizeToWrite(8),DQ(this.view,this.pos,J),this.pos+=8}writeI64(J){this.ensureBufferSizeToWrite(8),U1(this.view,this.pos,J),this.pos+=8}writeBigUint64(J){this.ensureBufferSizeToWrite(8),this.view.setBigUint64(this.pos,J),this.pos+=8}writeBigInt64(J){this.ensureBufferSizeToWrite(8),this.view.setBigInt64(this.pos,J),this.pos+=8}}function E0(J,G){return new K1(G).encodeSharedRef(J)}function Z1(J){return`${J<0?"-":""}0x${Math.abs(J).toString(16).padStart(2,"0")}`}var BG=16,LG=16;class o1{constructor(J=BG,G=LG){this.hit=0,this.miss=0,this.maxKeyLength=J,this.maxLengthPerKey=G,this.caches=[];for(let Q=0;Q<this.maxKeyLength;Q++)this.caches.push([])}canBeCached(J){return J>0&&J<=this.maxKeyLength}find(J,G,Q){const q=this.caches[Q-1];J:for(let W of q){const X=W.bytes;for(let Y=0;Y<Q;Y++)if(X[Y]!==J[G+Y])continue J;return W.str}return null}store(J,G){const Q=this.caches[J.length-1],q={bytes:J,str:G};if(Q.length>=this.maxLengthPerKey)Q[Math.random()*Q.length|0]=q;else Q.push(q)}decode(J,G,Q){const q=this.find(J,G,Q);if(q!=null)return this.hit++,q;this.miss++;const W=r1(J,G,Q),X=Uint8Array.prototype.slice.call(J,G,G+Q);return this.store(X,W),W}}var n1="array",S8="map_key",NQ="map_value",NG=(J)=>{if(typeof J==="string"||typeof J==="number")return J;throw new q0("The type of key must be string or number but "+typeof J)};class AQ{constructor(){this.stack=[],this.stackHeadPosition=-1}get length(){return this.stackHeadPosition+1}top(){return this.stack[this.stackHeadPosition]}pushArrayState(J){const G=this.getUninitializedStateFromPool();G.type=n1,G.position=0,G.size=J,G.array=new Array(J)}pushMapState(J){const G=this.getUninitializedStateFromPool();G.type=S8,G.readCount=0,G.size=J,G.map={}}getUninitializedStateFromPool(){if(this.stackHeadPosition++,this.stackHeadPosition===this.stack.length){const J={type:void 0,size:0,array:void 0,position:0,readCount:0,map:void 0,key:null};this.stack.push(J)}return this.stack[this.stackHeadPosition]}release(J){if(this.stack[this.stackHeadPosition]!==J)throw new Error("Invalid stack state. Released state is not on top of the stack.");if(J.type===n1){const Q=J;Q.size=0,Q.array=void 0,Q.position=0,Q.type=void 0}if(J.type===S8||J.type===NQ){const Q=J;Q.size=0,Q.map=void 0,Q.readCount=0,Q.type=void 0}this.stackHeadPosition--}reset(){this.stack.length=0,this.stackHeadPosition=-1}}var F8=-1,a1=new DataView(new ArrayBuffer(0)),AG=new Uint8Array(a1.buffer);try{a1.getInt8(0)}catch(J){if(!(J instanceof RangeError))throw new Error("This module is not supported in the current JavaScript engine because DataView does not throw RangeError on out-of-bounds access")}var LQ=new RangeError("Insufficient data"),RG=new o1;class $1{constructor(J){this.totalPos=0,this.pos=0,this.view=a1,this.bytes=AG,this.headByte=F8,this.stack=new AQ,this.entered=!1,this.extensionCodec=J?.extensionCodec??o0.defaultCodec,this.context=J?.context,this.useBigInt64=J?.useBigInt64??!1,this.rawStrings=J?.rawStrings??!1,this.maxStrLength=J?.maxStrLength??M8,this.maxBinLength=J?.maxBinLength??M8,this.maxArrayLength=J?.maxArrayLength??M8,this.maxMapLength=J?.maxMapLength??M8,this.maxExtLength=J?.maxExtLength??M8,this.keyDecoder=J?.keyDecoder!==void 0?J.keyDecoder:RG,this.mapKeyConverter=J?.mapKeyConverter??NG}clone(){return new $1({extensionCodec:this.extensionCodec,context:this.context,useBigInt64:this.useBigInt64,rawStrings:this.rawStrings,maxStrLength:this.maxStrLength,maxBinLength:this.maxBinLength,maxArrayLength:this.maxArrayLength,maxMapLength:this.maxMapLength,maxExtLength:this.maxExtLength,keyDecoder:this.keyDecoder})}reinitializeState(){this.totalPos=0,this.headByte=F8,this.stack.reset()}setBuffer(J){const G=T8(J);this.bytes=G,this.view=new DataView(G.buffer,G.byteOffset,G.byteLength),this.pos=0}appendBuffer(J){if(this.headByte===F8&&!this.hasRemaining(1))this.setBuffer(J);else{const G=this.bytes.subarray(this.pos),Q=T8(J),q=new Uint8Array(G.length+Q.length);q.set(G),q.set(Q,G.length),this.setBuffer(q)}}hasRemaining(J){return this.view.byteLength-this.pos>=J}createExtraByteError(J){const{view:G,pos:Q}=this;return new RangeError(`Extra ${G.byteLength-Q} of ${G.byteLength} byte(s) found at buffer[${J}]`)}decode(J){if(this.entered)return this.clone().decode(J);try{this.entered=!0,this.reinitializeState(),this.setBuffer(J);const G=this.doDecodeSync();if(this.hasRemaining(1))throw this.createExtraByteError(this.pos);return G}finally{this.entered=!1}}*decodeMulti(J){if(this.entered){yield*this.clone().decodeMulti(J);return}try{this.entered=!0,this.reinitializeState(),this.setBuffer(J);while(this.hasRemaining(1))yield this.doDecodeSync()}finally{this.entered=!1}}async decodeAsync(J){if(this.entered)return this.clone().decodeAsync(J);try{this.entered=!0;let G=!1,Q;for await(let Y of J){if(G)throw this.entered=!1,this.createExtraByteError(this.totalPos);this.appendBuffer(Y);try{Q=this.doDecodeSync(),G=!0}catch(U){if(!(U instanceof RangeError))throw U}this.totalPos+=this.pos}if(G){if(this.hasRemaining(1))throw this.createExtraByteError(this.totalPos);return Q}const{headByte:q,pos:W,totalPos:X}=this;throw new RangeError(`Insufficient data in parsing ${Z1(q)} at ${X} (${W} in the current buffer)`)}finally{this.entered=!1}}decodeArrayStream(J){return this.decodeMultiAsync(J,!0)}decodeStream(J){return this.decodeMultiAsync(J,!1)}async*decodeMultiAsync(J,G){if(this.entered){yield*this.clone().decodeMultiAsync(J,G);return}try{this.entered=!0;let Q=G,q=-1;for await(let W of J){if(G&&q===0)throw this.createExtraByteError(this.totalPos);if(this.appendBuffer(W),Q)q=this.readArraySize(),Q=!1,this.complete();try{while(!0)if(yield this.doDecodeSync(),--q===0)break}catch(X){if(!(X instanceof RangeError))throw X}this.totalPos+=this.pos}}finally{this.entered=!1}}doDecodeSync(){J:while(!0){const J=this.readHeadByte();let G;if(J>=224)G=J-256;else if(J<192)if(J<128)G=J;else if(J<144){const q=J-128;if(q!==0){this.pushMapState(q),this.complete();continue J}else G={}}else if(J<160){const q=J-144;if(q!==0){this.pushArrayState(q),this.complete();continue J}else G=[]}else{const q=J-160;G=this.decodeString(q,0)}else if(J===192)G=null;else if(J===194)G=!1;else if(J===195)G=!0;else if(J===202)G=this.readF32();else if(J===203)G=this.readF64();else if(J===204)G=this.readU8();else if(J===205)G=this.readU16();else if(J===206)G=this.readU32();else if(J===207)if(this.useBigInt64)G=this.readU64AsBigInt();else G=this.readU64();else if(J===208)G=this.readI8();else if(J===209)G=this.readI16();else if(J===210)G=this.readI32();else if(J===211)if(this.useBigInt64)G=this.readI64AsBigInt();else G=this.readI64();else if(J===217){const q=this.lookU8();G=this.decodeString(q,1)}else if(J===218){const q=this.lookU16();G=this.decodeString(q,2)}else if(J===219){const q=this.lookU32();G=this.decodeString(q,4)}else if(J===220){const q=this.readU16();if(q!==0){this.pushArrayState(q),this.complete();continue J}else G=[]}else if(J===221){const q=this.readU32();if(q!==0){this.pushArrayState(q),this.complete();continue J}else G=[]}else if(J===222){const q=this.readU16();if(q!==0){this.pushMapState(q),this.complete();continue J}else G={}}else if(J===223){const q=this.readU32();if(q!==0){this.pushMapState(q),this.complete();continue J}else G={}}else if(J===196){const q=this.lookU8();G=this.decodeBinary(q,1)}else if(J===197){const q=this.lookU16();G=this.decodeBinary(q,2)}else if(J===198){const q=this.lookU32();G=this.decodeBinary(q,4)}else if(J===212)G=this.decodeExtension(1,0);else if(J===213)G=this.decodeExtension(2,0);else if(J===214)G=this.decodeExtension(4,0);else if(J===215)G=this.decodeExtension(8,0);else if(J===216)G=this.decodeExtension(16,0);else if(J===199){const q=this.lookU8();G=this.decodeExtension(q,1)}else if(J===200){const q=this.lookU16();G=this.decodeExtension(q,2)}else if(J===201){const q=this.lookU32();G=this.decodeExtension(q,4)}else throw new q0(`Unrecognized type byte: ${Z1(J)}`);this.complete();const Q=this.stack;while(Q.length>0){const q=Q.top();if(q.type===n1)if(q.array[q.position]=G,q.position++,q.position===q.size)G=q.array,Q.release(q);else continue J;else if(q.type===S8){if(G==="__proto__")throw new q0("The key __proto__ is not allowed");q.key=this.mapKeyConverter(G),q.type=NQ;continue J}else if(q.map[q.key]=G,q.readCount++,q.readCount===q.size)G=q.map,Q.release(q);else{q.key=null,q.type=S8;continue J}}return G}}readHeadByte(){if(this.headByte===F8)this.headByte=this.readU8();return this.headByte}complete(){this.headByte=F8}readArraySize(){const J=this.readHeadByte();switch(J){case 220:return this.readU16();case 221:return this.readU32();default:if(J<160)return J-144;else throw new q0(`Unrecognized array type byte: ${Z1(J)}`)}}pushMapState(J){if(J>this.maxMapLength)throw new q0(`Max length exceeded: map length (${J}) > maxMapLengthLength (${this.maxMapLength})`);this.stack.pushMapState(J)}pushArrayState(J){if(J>this.maxArrayLength)throw new q0(`Max length exceeded: array length (${J}) > maxArrayLength (${this.maxArrayLength})`);this.stack.pushArrayState(J)}decodeString(J,G){if(!this.rawStrings||this.stateIsMapKey())return this.decodeUtf8String(J,G);return this.decodeBinary(J,G)}decodeUtf8String(J,G){if(J>this.maxStrLength)throw new q0(`Max length exceeded: UTF-8 byte length (${J}) > maxStrLength (${this.maxStrLength})`);if(this.bytes.byteLength<this.pos+G+J)throw LQ;const Q=this.pos+G;let q;if(this.stateIsMapKey()&&this.keyDecoder?.canBeCached(J))q=this.keyDecoder.decode(this.bytes,Q,J);else q=CQ(this.bytes,Q,J);return this.pos+=G+J,q}stateIsMapKey(){if(this.stack.length>0)return this.stack.top().type===S8;return!1}decodeBinary(J,G){if(J>this.maxBinLength)throw new q0(`Max length exceeded: bin length (${J}) > maxBinLength (${this.maxBinLength})`);if(!this.hasRemaining(J+G))throw LQ;const Q=this.pos+G,q=this.bytes.subarray(Q,Q+J);return this.pos+=G+J,q}decodeExtension(J,G){if(J>this.maxExtLength)throw new q0(`Max length exceeded: ext length (${J}) > maxExtLength (${this.maxExtLength})`);const Q=this.view.getInt8(this.pos+G),q=this.decodeBinary(J,G+1);return this.extensionCodec.decode(q,Q,this.context)}lookU8(){return this.view.getUint8(this.pos)}lookU16(){return this.view.getUint16(this.pos)}lookU32(){return this.view.getUint32(this.pos)}readU8(){const J=this.view.getUint8(this.pos);return this.pos++,J}readI8(){const J=this.view.getInt8(this.pos);return this.pos++,J}readU16(){const J=this.view.getUint16(this.pos);return this.pos+=2,J}readI16(){const J=this.view.getInt16(this.pos);return this.pos+=2,J}readU32(){const J=this.view.getUint32(this.pos);return this.pos+=4,J}readI32(){const J=this.view.getInt32(this.pos);return this.pos+=4,J}readU64(){const J=OQ(this.view,this.pos);return this.pos+=8,J}readI64(){const J=V1(this.view,this.pos);return this.pos+=8,J}readU64AsBigInt(){const J=this.view.getBigUint64(this.pos);return this.pos+=8,J}readI64AsBigInt(){const J=this.view.getBigInt64(this.pos);return this.pos+=8,J}readF32(){const J=this.view.getFloat32(this.pos);return this.pos+=4,J}readF64(){const J=this.view.getFloat64(this.pos);return this.pos+=8,J}}function s1(J,G){return new $1(G).decode(J)}var B8=function(J){let G=J.length;while(--G>=0)J[G]=0},e1=function(J,G,Q,q,W){this.static_tree=J,this.extra_bits=G,this.extra_base=Q,this.elems=q,this.max_length=W,this.has_stree=J&&J.length},JJ=function(J,G){this.dyn_tree=J,this.max_code=0,this.stat_desc=G},D0=function(J,G,Q,q,W){this.good_length=J,this.max_lazy=G,this.nice_length=Q,this.max_chain=q,this.func=W},I6=function(){this.strm=null,this.status=0,this.pending_buf=null,this.pending_buf_size=0,this.pending_out=0,this.pending=0,this.wrap=0,this.gzhead=null,this.gzindex=0,this.method=L1,this.last_flush=-1,this.w_size=0,this.w_bits=0,this.w_mask=0,this.window=null,this.window_size=0,this.prev=null,this.head=null,this.ins_h=0,this.hash_size=0,this.hash_bits=0,this.hash_mask=0,this.hash_shift=0,this.block_start=0,this.match_length=0,this.prev_match=0,this.match_available=0,this.strstart=0,this.match_start=0,this.lookahead=0,this.prev_length=0,this.max_chain_length=0,this.max_lazy_match=0,this.level=0,this.strategy=0,this.good_match=0,this.nice_match=0,this.dyn_ltree=new Uint16Array(C6*2),this.dyn_dtree=new Uint16Array((2*H6+1)*2),this.bl_tree=new Uint16Array((2*P6+1)*2),y0(this.dyn_ltree),y0(this.dyn_dtree),y0(this.bl_tree),this.l_desc=null,this.d_desc=null,this.bl_desc=null,this.bl_count=new Uint16Array(D6+1),this.heap=new Uint16Array(2*HJ+1),y0(this.heap),this.heap_len=0,this.heap_max=0,this.depth=new Uint16Array(2*HJ+1),y0(this.depth),this.sym_buf=0,this.lit_bufsize=0,this.sym_next=0,this.sym_end=0,this.opt_len=0,this.static_len=0,this.matches=0,this.insert=0,this.bi_buf=0,this.bi_valid=0},o6=function(){this.input=null,this.next_in=0,this.avail_in=0,this.total_in=0,this.output=null,this.next_out=0,this.avail_out=0,this.total_out=0,this.msg="",this.state=null,this.data_type=2,this.adler=0},o8=function(J){this.options=N1.assign({level:J7,method:G7,chunkSize:16384,windowBits:15,memLevel:8,strategy:Q7},J||{});let G=this.options;if(G.raw&&G.windowBits>0)G.windowBits=-G.windowBits;else if(G.gzip&&G.windowBits>0&&G.windowBits<16)G.windowBits+=16;this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new T9,this.strm.avail_out=0;let Q=f8.deflateInit2(this.strm,G.level,G.method,G.windowBits,G.memLevel,G.strategy);if(Q!==O1)throw new Error(t0[Q]);if(G.header)f8.deflateSetHeader(this.strm,G.header);if(G.dictionary){let q;if(typeof G.dictionary==="string")q=l8.string2buf(G.dictionary);else if(F9.call(G.dictionary)==="[object ArrayBuffer]")q=new Uint8Array(G.dictionary);else q=G.dictionary;if(Q=f8.deflateSetDictionary(this.strm,q),Q!==O1)throw new Error(t0[Q]);this._dict_set=!0}},IJ=function(J,G){const Q=new o8(G);if(Q.push(J,!0),Q.err)throw Q.msg||t0[Q.err];return Q.result},q7=function(J,G){return G=G||{},G.raw=!0,IJ(J,G)},W7=function(J,G){return G=G||{},G.gzip=!0,IJ(J,G)},w7=function(){this.strm=null,this.mode=0,this.last=!1,this.wrap=0,this.havedict=!1,this.flags=0,this.dmax=0,this.check=0,this.total=0,this.head=null,this.wbits=0,this.wsize=0,this.whave=0,this.wnext=0,this.window=null,this.hold=0,this.bits=0,this.length=0,this.offset=0,this.extra=0,this.lencode=null,this.distcode=null,this.lenbits=0,this.distbits=0,this.ncode=0,this.nlen=0,this.ndist=0,this.have=0,this.next=null,this.lens=new Uint16Array(320),this.work=new Uint16Array(288),this.lendyn=null,this.distdyn=null,this.sane=0,this.back=0,this.was=0},l7=function(){this.text=0,this.time=0,this.xflags=0,this.os=0,this.extra=null,this.extra_len=0,this.name="",this.comment="",this.hcrc=0,this.done=!1},n8=function(J){this.options=N1.assign({chunkSize:65536,windowBits:15,to:""},J||{});const G=this.options;if(G.raw&&G.windowBits>=0&&G.windowBits<16){if(G.windowBits=-G.windowBits,G.windowBits===0)G.windowBits=-15}if(G.windowBits>=0&&G.windowBits<16&&!(J&&J.windowBits))G.windowBits+=32;if(G.windowBits>15&&G.windowBits<48){if((G.windowBits&15)===0)G.windowBits|=15}this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new T9,this.strm.avail_out=0;let Q=x0.inflateInit2(this.strm,G.windowBits);if(Q!==d8)throw new Error(t0[Q]);if(this.header=new d7,x0.inflateGetHeader(this.strm,this.header),G.dictionary){if(typeof G.dictionary==="string")G.dictionary=l8.string2buf(G.dictionary);else if(c9.call(G.dictionary)==="[object ArrayBuffer]")G.dictionary=new Uint8Array(G.dictionary);if(G.raw){if(Q=x0.inflateSetDictionary(this.strm,G.dictionary),Q!==d8)throw new Error(t0[Q])}}},wJ=function(J,G){const Q=new n8(G);if(Q.push(J),Q.err)throw Q.msg||t0[Q.err];return Q.result},a7=function(J,G){return G=G||{},G.raw=!0,wJ(J,G)};/*! pako 2.1.0 https://github.com/nodeca/pako @license (MIT AND Zlib) */var kG=0,V9=1,IG=2,wG=3,xG=258,LJ=29,i8=256,h8=i8+1+LJ,C8=30,NJ=19,K9=2*h8+1,n0=15,t1=16,TG=7,AJ=256,Z9=16,$9=17,z9=18,zJ=new Uint8Array([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0]),C1=new Uint8Array([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13]),FG=new Uint8Array([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7]),j9=new Uint8Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),SG=512,w0=new Array((h8+2)*2);B8(w0);var y8=new Array(C8*2);B8(y8);var m8=new Array(SG);B8(m8);var _8=new Array(xG-wG+1);B8(_8);var RJ=new Array(LJ);B8(RJ);var D1=new Array(C8);B8(D1);var M9,H9,P9,C9=(J)=>{return J<256?m8[J]:m8[256+(J>>>7)]},u8=(J,G)=>{J.pending_buf[J.pending++]=G&255,J.pending_buf[J.pending++]=G>>>8&255},X0=(J,G,Q)=>{if(J.bi_valid>t1-Q)J.bi_buf|=G<<J.bi_valid&65535,u8(J,J.bi_buf),J.bi_buf=G>>t1-J.bi_valid,J.bi_valid+=Q-t1;else J.bi_buf|=G<<J.bi_valid&65535,J.bi_valid+=Q},O0=(J,G,Q)=>{X0(J,Q[G*2],Q[G*2+1])},D9=(J,G)=>{let Q=0;do Q|=J&1,J>>>=1,Q<<=1;while(--G>0);return Q>>>1},vG=(J)=>{if(J.bi_valid===16)u8(J,J.bi_buf),J.bi_buf=0,J.bi_valid=0;else if(J.bi_valid>=8)J.pending_buf[J.pending++]=J.bi_buf&255,J.bi_buf>>=8,J.bi_valid-=8},gG=(J,G)=>{const{dyn_tree:Q,max_code:q}=G,W=G.stat_desc.static_tree,X=G.stat_desc.has_stree,Y=G.stat_desc.extra_bits,U=G.stat_desc.extra_base,K=G.stat_desc.max_length;let V,Z,j,$,z,P,M=0;for($=0;$<=n0;$++)J.bl_count[$]=0;Q[J.heap[J.heap_max]*2+1]=0;for(V=J.heap_max+1;V<K9;V++){if(Z=J.heap[V],$=Q[Q[Z*2+1]*2+1]+1,$>K)$=K,M++;if(Q[Z*2+1]=$,Z>q)continue;if(J.bl_count[$]++,z=0,Z>=U)z=Y[Z-U];if(P=Q[Z*2],J.opt_len+=P*($+z),X)J.static_len+=P*(W[Z*2+1]+z)}if(M===0)return;do{$=K-1;while(J.bl_count[$]===0)$--;J.bl_count[$]--,J.bl_count[$+1]+=2,J.bl_count[K]--,M-=2}while(M>0);for($=K;$!==0;$--){Z=J.bl_count[$];while(Z!==0){if(j=J.heap[--V],j>q)continue;if(Q[j*2+1]!==$)J.opt_len+=($-Q[j*2+1])*Q[j*2],Q[j*2+1]=$;Z--}}},O9=(J,G,Q)=>{const q=new Array(n0+1);let W=0,X,Y;for(X=1;X<=n0;X++)W=W+Q[X-1]<<1,q[X]=W;for(Y=0;Y<=G;Y++){let U=J[Y*2+1];if(U===0)continue;J[Y*2]=D9(q[U]++,U)}},EG=()=>{let J,G,Q,q,W;const X=new Array(n0+1);Q=0;for(q=0;q<LJ-1;q++){RJ[q]=Q;for(J=0;J<1<<zJ[q];J++)_8[Q++]=q}_8[Q-1]=q,W=0;for(q=0;q<16;q++){D1[q]=W;for(J=0;J<1<<C1[q];J++)m8[W++]=q}W>>=7;for(;q<C8;q++){D1[q]=W<<7;for(J=0;J<1<<C1[q]-7;J++)m8[256+W++]=q}for(G=0;G<=n0;G++)X[G]=0;J=0;while(J<=143)w0[J*2+1]=8,J++,X[8]++;while(J<=255)w0[J*2+1]=9,J++,X[9]++;while(J<=279)w0[J*2+1]=7,J++,X[7]++;while(J<=287)w0[J*2+1]=8,J++,X[8]++;O9(w0,h8+1,X);for(J=0;J<C8;J++)y8[J*2+1]=5,y8[J*2]=D9(J,5);M9=new e1(w0,zJ,i8+1,h8,n0),H9=new e1(y8,C1,0,C8,n0),P9=new e1(new Array(0),FG,0,NJ,TG)},B9=(J)=>{let G;for(G=0;G<h8;G++)J.dyn_ltree[G*2]=0;for(G=0;G<C8;G++)J.dyn_dtree[G*2]=0;for(G=0;G<NJ;G++)J.bl_tree[G*2]=0;J.dyn_ltree[AJ*2]=1,J.opt_len=J.static_len=0,J.sym_next=J.matches=0},L9=(J)=>{if(J.bi_valid>8)u8(J,J.bi_buf);else if(J.bi_valid>0)J.pending_buf[J.pending++]=J.bi_buf;J.bi_buf=0,J.bi_valid=0},RQ=(J,G,Q,q)=>{const W=G*2,X=Q*2;return J[W]<J[X]||J[W]===J[X]&&q[G]<=q[Q]},QJ=(J,G,Q)=>{const q=J.heap[Q];let W=Q<<1;while(W<=J.heap_len){if(W<J.heap_len&&RQ(G,J.heap[W+1],J.heap[W],J.depth))W++;if(RQ(G,q,J.heap[W],J.depth))break;J.heap[Q]=J.heap[W],Q=W,W<<=1}J.heap[Q]=q},kQ=(J,G,Q)=>{let q,W,X=0,Y,U;if(J.sym_next!==0)do if(q=J.pending_buf[J.sym_buf+X++]&255,q+=(J.pending_buf[J.sym_buf+X++]&255)<<8,W=J.pending_buf[J.sym_buf+X++],q===0)O0(J,W,G);else{if(Y=_8[W],O0(J,Y+i8+1,G),U=zJ[Y],U!==0)W-=RJ[Y],X0(J,W,U);if(q--,Y=C9(q),O0(J,Y,Q),U=C1[Y],U!==0)q-=D1[Y],X0(J,q,U)}while(X<J.sym_next);O0(J,AJ,G)},jJ=(J,G)=>{const Q=G.dyn_tree,q=G.stat_desc.static_tree,W=G.stat_desc.has_stree,X=G.stat_desc.elems;let Y,U,K=-1,V;J.heap_len=0,J.heap_max=K9;for(Y=0;Y<X;Y++)if(Q[Y*2]!==0)J.heap[++J.heap_len]=K=Y,J.depth[Y]=0;else Q[Y*2+1]=0;while(J.heap_len<2)if(V=J.heap[++J.heap_len]=K<2?++K:0,Q[V*2]=1,J.depth[V]=0,J.opt_len--,W)J.static_len-=q[V*2+1];G.max_code=K;for(Y=J.heap_len>>1;Y>=1;Y--)QJ(J,Q,Y);V=X;do Y=J.heap[1],J.heap[1]=J.heap[J.heap_len--],QJ(J,Q,1),U=J.heap[1],J.heap[--J.heap_max]=Y,J.heap[--J.heap_max]=U,Q[V*2]=Q[Y*2]+Q[U*2],J.depth[V]=(J.depth[Y]>=J.depth[U]?J.depth[Y]:J.depth[U])+1,Q[Y*2+1]=Q[U*2+1]=V,J.heap[1]=V++,QJ(J,Q,1);while(J.heap_len>=2);J.heap[--J.heap_max]=J.heap[1],gG(J,G),O9(Q,K,J.bl_count)},IQ=(J,G,Q)=>{let q,W=-1,X,Y=G[1],U=0,K=7,V=4;if(Y===0)K=138,V=3;G[(Q+1)*2+1]=65535;for(q=0;q<=Q;q++){if(X=Y,Y=G[(q+1)*2+1],++U<K&&X===Y)continue;else if(U<V)J.bl_tree[X*2]+=U;else if(X!==0){if(X!==W)J.bl_tree[X*2]++;J.bl_tree[Z9*2]++}else if(U<=10)J.bl_tree[$9*2]++;else J.bl_tree[z9*2]++;if(U=0,W=X,Y===0)K=138,V=3;else if(X===Y)K=6,V=3;else K=7,V=4}},wQ=(J,G,Q)=>{let q,W=-1,X,Y=G[1],U=0,K=7,V=4;if(Y===0)K=138,V=3;for(q=0;q<=Q;q++){if(X=Y,Y=G[(q+1)*2+1],++U<K&&X===Y)continue;else if(U<V)do O0(J,X,J.bl_tree);while(--U!==0);else if(X!==0){if(X!==W)O0(J,X,J.bl_tree),U--;O0(J,Z9,J.bl_tree),X0(J,U-3,2)}else if(U<=10)O0(J,$9,J.bl_tree),X0(J,U-3,3);else O0(J,z9,J.bl_tree),X0(J,U-11,7);if(U=0,W=X,Y===0)K=138,V=3;else if(X===Y)K=6,V=3;else K=7,V=4}},yG=(J)=>{let G;IQ(J,J.dyn_ltree,J.l_desc.max_code),IQ(J,J.dyn_dtree,J.d_desc.max_code),jJ(J,J.bl_desc);for(G=NJ-1;G>=3;G--)if(J.bl_tree[j9[G]*2+1]!==0)break;return J.opt_len+=3*(G+1)+5+5+4,G},fG=(J,G,Q,q)=>{let W;X0(J,G-257,5),X0(J,Q-1,5),X0(J,q-4,4);for(W=0;W<q;W++)X0(J,J.bl_tree[j9[W]*2+1],3);wQ(J,J.dyn_ltree,G-1),wQ(J,J.dyn_dtree,Q-1)},bG=(J)=>{let G=4093624447,Q;for(Q=0;Q<=31;Q++,G>>>=1)if(G&1&&J.dyn_ltree[Q*2]!==0)return 0;if(J.dyn_ltree[18]!==0||J.dyn_ltree[20]!==0||J.dyn_ltree[26]!==0)return 1;for(Q=32;Q<i8;Q++)if(J.dyn_ltree[Q*2]!==0)return 1;return 0},xQ=!1,hG=(J)=>{if(!xQ)EG(),xQ=!0;J.l_desc=new JJ(J.dyn_ltree,M9),J.d_desc=new JJ(J.dyn_dtree,H9),J.bl_desc=new JJ(J.bl_tree,P9),J.bi_buf=0,J.bi_valid=0,B9(J)},N9=(J,G,Q,q)=>{if(X0(J,(kG<<1)+(q?1:0),3),L9(J),u8(J,Q),u8(J,~Q),Q)J.pending_buf.set(J.window.subarray(G,G+Q),J.pending);J.pending+=Q},mG=(J)=>{X0(J,V9<<1,3),O0(J,AJ,w0),vG(J)},_G=(J,G,Q,q)=>{let W,X,Y=0;if(J.level>0){if(J.strm.data_type===2)J.strm.data_type=bG(J);if(jJ(J,J.l_desc),jJ(J,J.d_desc),Y=yG(J),W=J.opt_len+3+7>>>3,X=J.static_len+3+7>>>3,X<=W)W=X}else W=X=Q+5;if(Q+4<=W&&G!==-1)N9(J,G,Q,q);else if(J.strategy===4||X===W)X0(J,(V9<<1)+(q?1:0),3),kQ(J,w0,y8);else X0(J,(IG<<1)+(q?1:0),3),fG(J,J.l_desc.max_code+1,J.d_desc.max_code+1,Y+1),kQ(J,J.dyn_ltree,J.dyn_dtree);if(B9(J),q)L9(J)},uG=(J,G,Q)=>{if(J.pending_buf[J.sym_buf+J.sym_next++]=G,J.pending_buf[J.sym_buf+J.sym_next++]=G>>8,J.pending_buf[J.sym_buf+J.sym_next++]=Q,G===0)J.dyn_ltree[Q*2]++;else J.matches++,G--,J.dyn_ltree[(_8[Q]+i8+1)*2]++,J.dyn_dtree[C9(G)*2]++;return J.sym_next===J.sym_end},cG=hG,pG=N9,lG=_G,dG=uG,iG=mG,rG={_tr_init:cG,_tr_stored_block:pG,_tr_flush_block:lG,_tr_tally:dG,_tr_align:iG},oG=(J,G,Q,q)=>{let W=J&65535|0,X=J>>>16&65535|0,Y=0;while(Q!==0){Y=Q>2000?2000:Q,Q-=Y;do W=W+G[q++]|0,X=X+W|0;while(--Y);W%=65521,X%=65521}return W|X<<16|0},c8=oG,nG=()=>{let J,G=[];for(var Q=0;Q<256;Q++){J=Q;for(var q=0;q<8;q++)J=J&1?3988292384^J>>>1:J>>>1;G[Q]=J}return G},aG=new Uint32Array(nG()),sG=(J,G,Q,q)=>{const W=aG,X=q+Q;J^=-1;for(let Y=q;Y<X;Y++)J=J>>>8^W[(J^G[Y])&255];return J^-1},t=sG,t0={2:"need dictionary",1:"stream end",0:"","-1":"file error","-2":"stream error","-3":"data error","-4":"insufficient memory","-5":"buffer error","-6":"incompatible version"},Q8={Z_NO_FLUSH:0,Z_PARTIAL_FLUSH:1,Z_SYNC_FLUSH:2,Z_FULL_FLUSH:3,Z_FINISH:4,Z_BLOCK:5,Z_TREES:6,Z_OK:0,Z_STREAM_END:1,Z_NEED_DICT:2,Z_ERRNO:-1,Z_STREAM_ERROR:-2,Z_DATA_ERROR:-3,Z_MEM_ERROR:-4,Z_BUF_ERROR:-5,Z_NO_COMPRESSION:0,Z_BEST_SPEED:1,Z_BEST_COMPRESSION:9,Z_DEFAULT_COMPRESSION:-1,Z_FILTERED:1,Z_HUFFMAN_ONLY:2,Z_RLE:3,Z_FIXED:4,Z_DEFAULT_STRATEGY:0,Z_BINARY:0,Z_TEXT:1,Z_UNKNOWN:2,Z_DEFLATED:8},{_tr_init:tG,_tr_stored_block:MJ,_tr_flush_block:eG,_tr_tally:b0,_tr_align:J6}=rG,{Z_NO_FLUSH:h0,Z_PARTIAL_FLUSH:Q6,Z_FULL_FLUSH:G6,Z_FINISH:$0,Z_BLOCK:TQ,Z_OK:Q0,Z_STREAM_END:FQ,Z_STREAM_ERROR:B0,Z_DATA_ERROR:q6,Z_BUF_ERROR:GJ,Z_DEFAULT_COMPRESSION:W6,Z_FILTERED:X6,Z_HUFFMAN_ONLY:z1,Z_RLE:Y6,Z_FIXED:U6,Z_DEFAULT_STRATEGY:V6,Z_UNKNOWN:K6,Z_DEFLATED:L1}=Q8,Z6=9,$6=15,z6=8,j6=29,M6=256,HJ=M6+1+j6,H6=30,P6=19,C6=2*HJ+1,D6=15,b=3,f0=258,L0=f0+b+1,O6=32,D8=42,kJ=57,PJ=69,CJ=73,DJ=91,OJ=103,a0=113,g8=666,W0=1,L8=2,e0=3,N8=4,B6=3,s0=(J,G)=>{return J.msg=t0[G],G},SQ=(J)=>{return J*2-(J>4?9:0)},y0=(J)=>{let G=J.length;while(--G>=0)J[G]=0},L6=(J)=>{let G,Q,q,W=J.w_size;G=J.hash_size,q=G;do Q=J.head[--q],J.head[q]=Q>=W?Q-W:0;while(--G);G=W,q=G;do Q=J.prev[--q],J.prev[q]=Q>=W?Q-W:0;while(--G)},N6=(J,G,Q)=>(G<<J.hash_shift^Q)&J.hash_mask,m0=N6,V0=(J)=>{const G=J.state;let Q=G.pending;if(Q>J.avail_out)Q=J.avail_out;if(Q===0)return;if(J.output.set(G.pending_buf.subarray(G.pending_out,G.pending_out+Q),J.next_out),J.next_out+=Q,G.pending_out+=Q,J.total_out+=Q,J.avail_out-=Q,G.pending-=Q,G.pending===0)G.pending_out=0},K0=(J,G)=>{eG(J,J.block_start>=0?J.block_start:-1,J.strstart-J.block_start,G),J.block_start=J.strstart,V0(J.strm)},h=(J,G)=>{J.pending_buf[J.pending++]=G},v8=(J,G)=>{J.pending_buf[J.pending++]=G>>>8&255,J.pending_buf[J.pending++]=G&255},BJ=(J,G,Q,q)=>{let W=J.avail_in;if(W>q)W=q;if(W===0)return 0;if(J.avail_in-=W,G.set(J.input.subarray(J.next_in,J.next_in+W),Q),J.state.wrap===1)J.adler=c8(J.adler,G,W,Q);else if(J.state.wrap===2)J.adler=t(J.adler,G,W,Q);return J.next_in+=W,J.total_in+=W,W},A9=(J,G)=>{let{max_chain_length:Q,strstart:q}=J,W,X,Y=J.prev_length,U=J.nice_match;const K=J.strstart>J.w_size-L0?J.strstart-(J.w_size-L0):0,V=J.window,Z=J.w_mask,j=J.prev,$=J.strstart+f0;let z=V[q+Y-1],P=V[q+Y];if(J.prev_length>=J.good_match)Q>>=2;if(U>J.lookahead)U=J.lookahead;do{if(W=G,V[W+Y]!==P||V[W+Y-1]!==z||V[W]!==V[q]||V[++W]!==V[q+1])continue;q+=2,W++;do;while(V[++q]===V[++W]&&V[++q]===V[++W]&&V[++q]===V[++W]&&V[++q]===V[++W]&&V[++q]===V[++W]&&V[++q]===V[++W]&&V[++q]===V[++W]&&V[++q]===V[++W]&&q<$);if(X=f0-($-q),q=$-f0,X>Y){if(J.match_start=G,Y=X,X>=U)break;z=V[q+Y-1],P=V[q+Y]}}while((G=j[G&Z])>K&&--Q!==0);if(Y<=J.lookahead)return Y;return J.lookahead},O8=(J)=>{const G=J.w_size;let Q,q,W;do{if(q=J.window_size-J.lookahead-J.strstart,J.strstart>=G+(G-L0)){if(J.window.set(J.window.subarray(G,G+G-q),0),J.match_start-=G,J.strstart-=G,J.block_start-=G,J.insert>J.strstart)J.insert=J.strstart;L6(J),q+=G}if(J.strm.avail_in===0)break;if(Q=BJ(J.strm,J.window,J.strstart+J.lookahead,q),J.lookahead+=Q,J.lookahead+J.insert>=b){W=J.strstart-J.insert,J.ins_h=J.window[W],J.ins_h=m0(J,J.ins_h,J.window[W+1]);while(J.insert)if(J.ins_h=m0(J,J.ins_h,J.window[W+b-1]),J.prev[W&J.w_mask]=J.head[J.ins_h],J.head[J.ins_h]=W,W++,J.insert--,J.lookahead+J.insert<b)break}}while(J.lookahead<L0&&J.strm.avail_in!==0)},R9=(J,G)=>{let Q=J.pending_buf_size-5>J.w_size?J.w_size:J.pending_buf_size-5,q,W,X,Y=0,U=J.strm.avail_in;do{if(q=65535,X=J.bi_valid+42>>3,J.strm.avail_out<X)break;if(X=J.strm.avail_out-X,W=J.strstart-J.block_start,q>W+J.strm.avail_in)q=W+J.strm.avail_in;if(q>X)q=X;if(q<Q&&(q===0&&G!==$0||G===h0||q!==W+J.strm.avail_in))break;if(Y=G===$0&&q===W+J.strm.avail_in?1:0,MJ(J,0,0,Y),J.pending_buf[J.pending-4]=q,J.pending_buf[J.pending-3]=q>>8,J.pending_buf[J.pending-2]=~q,J.pending_buf[J.pending-1]=~q>>8,V0(J.strm),W){if(W>q)W=q;J.strm.output.set(J.window.subarray(J.block_start,J.block_start+W),J.strm.next_out),J.strm.next_out+=W,J.strm.avail_out-=W,J.strm.total_out+=W,J.block_start+=W,q-=W}if(q)BJ(J.strm,J.strm.output,J.strm.next_out,q),J.strm.next_out+=q,J.strm.avail_out-=q,J.strm.total_out+=q}while(Y===0);if(U-=J.strm.avail_in,U){if(U>=J.w_size)J.matches=2,J.window.set(J.strm.input.subarray(J.strm.next_in-J.w_size,J.strm.next_in),0),J.strstart=J.w_size,J.insert=J.strstart;else{if(J.window_size-J.strstart<=U){if(J.strstart-=J.w_size,J.window.set(J.window.subarray(J.w_size,J.w_size+J.strstart),0),J.matches<2)J.matches++;if(J.insert>J.strstart)J.insert=J.strstart}J.window.set(J.strm.input.subarray(J.strm.next_in-U,J.strm.next_in),J.strstart),J.strstart+=U,J.insert+=U>J.w_size-J.insert?J.w_size-J.insert:U}J.block_start=J.strstart}if(J.high_water<J.strstart)J.high_water=J.strstart;if(Y)return N8;if(G!==h0&&G!==$0&&J.strm.avail_in===0&&J.strstart===J.block_start)return L8;if(X=J.window_size-J.strstart,J.strm.avail_in>X&&J.block_start>=J.w_size){if(J.block_start-=J.w_size,J.strstart-=J.w_size,J.window.set(J.window.subarray(J.w_size,J.w_size+J.strstart),0),J.matches<2)J.matches++;if(X+=J.w_size,J.insert>J.strstart)J.insert=J.strstart}if(X>J.strm.avail_in)X=J.strm.avail_in;if(X)BJ(J.strm,J.window,J.strstart,X),J.strstart+=X,J.insert+=X>J.w_size-J.insert?J.w_size-J.insert:X;if(J.high_water<J.strstart)J.high_water=J.strstart;if(X=J.bi_valid+42>>3,X=J.pending_buf_size-X>65535?65535:J.pending_buf_size-X,Q=X>J.w_size?J.w_size:X,W=J.strstart-J.block_start,W>=Q||(W||G===$0)&&G!==h0&&J.strm.avail_in===0&&W<=X)q=W>X?X:W,Y=G===$0&&J.strm.avail_in===0&&q===W?1:0,MJ(J,J.block_start,q,Y),J.block_start+=q,V0(J.strm);return Y?e0:W0},qJ=(J,G)=>{let Q,q;for(;;){if(J.lookahead<L0){if(O8(J),J.lookahead<L0&&G===h0)return W0;if(J.lookahead===0)break}if(Q=0,J.lookahead>=b)J.ins_h=m0(J,J.ins_h,J.window[J.strstart+b-1]),Q=J.prev[J.strstart&J.w_mask]=J.head[J.ins_h],J.head[J.ins_h]=J.strstart;if(Q!==0&&J.strstart-Q<=J.w_size-L0)J.match_length=A9(J,Q);if(J.match_length>=b)if(q=b0(J,J.strstart-J.match_start,J.match_length-b),J.lookahead-=J.match_length,J.match_length<=J.max_lazy_match&&J.lookahead>=b){J.match_length--;do J.strstart++,J.ins_h=m0(J,J.ins_h,J.window[J.strstart+b-1]),Q=J.prev[J.strstart&J.w_mask]=J.head[J.ins_h],J.head[J.ins_h]=J.strstart;while(--J.match_length!==0);J.strstart++}else J.strstart+=J.match_length,J.match_length=0,J.ins_h=J.window[J.strstart],J.ins_h=m0(J,J.ins_h,J.window[J.strstart+1]);else q=b0(J,0,J.window[J.strstart]),J.lookahead--,J.strstart++;if(q){if(K0(J,!1),J.strm.avail_out===0)return W0}}if(J.insert=J.strstart<b-1?J.strstart:b-1,G===$0){if(K0(J,!0),J.strm.avail_out===0)return e0;return N8}if(J.sym_next){if(K0(J,!1),J.strm.avail_out===0)return W0}return L8},H8=(J,G)=>{let Q,q,W;for(;;){if(J.lookahead<L0){if(O8(J),J.lookahead<L0&&G===h0)return W0;if(J.lookahead===0)break}if(Q=0,J.lookahead>=b)J.ins_h=m0(J,J.ins_h,J.window[J.strstart+b-1]),Q=J.prev[J.strstart&J.w_mask]=J.head[J.ins_h],J.head[J.ins_h]=J.strstart;if(J.prev_length=J.match_length,J.prev_match=J.match_start,J.match_length=b-1,Q!==0&&J.prev_length<J.max_lazy_match&&J.strstart-Q<=J.w_size-L0){if(J.match_length=A9(J,Q),J.match_length<=5&&(J.strategy===X6||J.match_length===b&&J.strstart-J.match_start>4096))J.match_length=b-1}if(J.prev_length>=b&&J.match_length<=J.prev_length){W=J.strstart+J.lookahead-b,q=b0(J,J.strstart-1-J.prev_match,J.prev_length-b),J.lookahead-=J.prev_length-1,J.prev_length-=2;do if(++J.strstart<=W)J.ins_h=m0(J,J.ins_h,J.window[J.strstart+b-1]),Q=J.prev[J.strstart&J.w_mask]=J.head[J.ins_h],J.head[J.ins_h]=J.strstart;while(--J.prev_length!==0);if(J.match_available=0,J.match_length=b-1,J.strstart++,q){if(K0(J,!1),J.strm.avail_out===0)return W0}}else if(J.match_available){if(q=b0(J,0,J.window[J.strstart-1]),q)K0(J,!1);if(J.strstart++,J.lookahead--,J.strm.avail_out===0)return W0}else J.match_available=1,J.strstart++,J.lookahead--}if(J.match_available)q=b0(J,0,J.window[J.strstart-1]),J.match_available=0;if(J.insert=J.strstart<b-1?J.strstart:b-1,G===$0){if(K0(J,!0),J.strm.avail_out===0)return e0;return N8}if(J.sym_next){if(K0(J,!1),J.strm.avail_out===0)return W0}return L8},A6=(J,G)=>{let Q,q,W,X;const Y=J.window;for(;;){if(J.lookahead<=f0){if(O8(J),J.lookahead<=f0&&G===h0)return W0;if(J.lookahead===0)break}if(J.match_length=0,J.lookahead>=b&&J.strstart>0){if(W=J.strstart-1,q=Y[W],q===Y[++W]&&q===Y[++W]&&q===Y[++W]){X=J.strstart+f0;do;while(q===Y[++W]&&q===Y[++W]&&q===Y[++W]&&q===Y[++W]&&q===Y[++W]&&q===Y[++W]&&q===Y[++W]&&q===Y[++W]&&W<X);if(J.match_length=f0-(X-W),J.match_length>J.lookahead)J.match_length=J.lookahead}}if(J.match_length>=b)Q=b0(J,1,J.match_length-b),J.lookahead-=J.match_length,J.strstart+=J.match_length,J.match_length=0;else Q=b0(J,0,J.window[J.strstart]),J.lookahead--,J.strstart++;if(Q){if(K0(J,!1),J.strm.avail_out===0)return W0}}if(J.insert=0,G===$0){if(K0(J,!0),J.strm.avail_out===0)return e0;return N8}if(J.sym_next){if(K0(J,!1),J.strm.avail_out===0)return W0}return L8},R6=(J,G)=>{let Q;for(;;){if(J.lookahead===0){if(O8(J),J.lookahead===0){if(G===h0)return W0;break}}if(J.match_length=0,Q=b0(J,0,J.window[J.strstart]),J.lookahead--,J.strstart++,Q){if(K0(J,!1),J.strm.avail_out===0)return W0}}if(J.insert=0,G===$0){if(K0(J,!0),J.strm.avail_out===0)return e0;return N8}if(J.sym_next){if(K0(J,!1),J.strm.avail_out===0)return W0}return L8},E8=[new D0(0,0,0,0,R9),new D0(4,4,8,4,qJ),new D0(4,5,16,8,qJ),new D0(4,6,32,32,qJ),new D0(4,4,16,16,H8),new D0(8,16,32,32,H8),new D0(8,16,128,128,H8),new D0(8,32,128,256,H8),new D0(32,128,258,1024,H8),new D0(32,258,258,4096,H8)],k6=(J)=>{J.window_size=2*J.w_size,y0(J.head),J.max_lazy_match=E8[J.level].max_lazy,J.good_match=E8[J.level].good_length,J.nice_match=E8[J.level].nice_length,J.max_chain_length=E8[J.level].max_chain,J.strstart=0,J.block_start=0,J.lookahead=0,J.insert=0,J.match_length=J.prev_length=b-1,J.match_available=0,J.ins_h=0},r8=(J)=>{if(!J)return 1;const G=J.state;if(!G||G.strm!==J||G.status!==D8&&G.status!==kJ&&G.status!==PJ&&G.status!==CJ&&G.status!==DJ&&G.status!==OJ&&G.status!==a0&&G.status!==g8)return 1;return 0},k9=(J)=>{if(r8(J))return s0(J,B0);J.total_in=J.total_out=0,J.data_type=K6;const G=J.state;if(G.pending=0,G.pending_out=0,G.wrap<0)G.wrap=-G.wrap;return G.status=G.wrap===2?kJ:G.wrap?D8:a0,J.adler=G.wrap===2?0:1,G.last_flush=-2,tG(G),Q0},I9=(J)=>{const G=k9(J);if(G===Q0)k6(J.state);return G},w6=(J,G)=>{if(r8(J)||J.state.wrap!==2)return B0;return J.state.gzhead=G,Q0},w9=(J,G,Q,q,W,X)=>{if(!J)return B0;let Y=1;if(G===W6)G=6;if(q<0)Y=0,q=-q;else if(q>15)Y=2,q-=16;if(W<1||W>Z6||Q!==L1||q<8||q>15||G<0||G>9||X<0||X>U6||q===8&&Y!==1)return s0(J,B0);if(q===8)q=9;const U=new I6;return J.state=U,U.strm=J,U.status=D8,U.wrap=Y,U.gzhead=null,U.w_bits=q,U.w_size=1<<U.w_bits,U.w_mask=U.w_size-1,U.hash_bits=W+7,U.hash_size=1<<U.hash_bits,U.hash_mask=U.hash_size-1,U.hash_shift=~~((U.hash_bits+b-1)/b),U.window=new Uint8Array(U.w_size*2),U.head=new Uint16Array(U.hash_size),U.prev=new Uint16Array(U.w_size),U.lit_bufsize=1<<W+6,U.pending_buf_size=U.lit_bufsize*4,U.pending_buf=new Uint8Array(U.pending_buf_size),U.sym_buf=U.lit_bufsize,U.sym_end=(U.lit_bufsize-1)*3,U.level=G,U.strategy=X,U.method=Q,I9(J)},x6=(J,G)=>{return w9(J,G,L1,$6,z6,V6)},T6=(J,G)=>{if(r8(J)||G>TQ||G<0)return J?s0(J,B0):B0;const Q=J.state;if(!J.output||J.avail_in!==0&&!J.input||Q.status===g8&&G!==$0)return s0(J,J.avail_out===0?GJ:B0);const q=Q.last_flush;if(Q.last_flush=G,Q.pending!==0){if(V0(J),J.avail_out===0)return Q.last_flush=-1,Q0}else if(J.avail_in===0&&SQ(G)<=SQ(q)&&G!==$0)return s0(J,GJ);if(Q.status===g8&&J.avail_in!==0)return s0(J,GJ);if(Q.status===D8&&Q.wrap===0)Q.status=a0;if(Q.status===D8){let W=L1+(Q.w_bits-8<<4)<<8,X=-1;if(Q.strategy>=z1||Q.level<2)X=0;else if(Q.level<6)X=1;else if(Q.level===6)X=2;else X=3;if(W|=X<<6,Q.strstart!==0)W|=O6;if(W+=31-W%31,v8(Q,W),Q.strstart!==0)v8(Q,J.adler>>>16),v8(Q,J.adler&65535);if(J.adler=1,Q.status=a0,V0(J),Q.pending!==0)return Q.last_flush=-1,Q0}if(Q.status===kJ)if(J.adler=0,h(Q,31),h(Q,139),h(Q,8),!Q.gzhead){if(h(Q,0),h(Q,0),h(Q,0),h(Q,0),h(Q,0),h(Q,Q.level===9?2:Q.strategy>=z1||Q.level<2?4:0),h(Q,B6),Q.status=a0,V0(J),Q.pending!==0)return Q.last_flush=-1,Q0}else{if(h(Q,(Q.gzhead.text?1:0)+(Q.gzhead.hcrc?2:0)+(!Q.gzhead.extra?0:4)+(!Q.gzhead.name?0:8)+(!Q.gzhead.comment?0:16)),h(Q,Q.gzhead.time&255),h(Q,Q.gzhead.time>>8&255),h(Q,Q.gzhead.time>>16&255),h(Q,Q.gzhead.time>>24&255),h(Q,Q.level===9?2:Q.strategy>=z1||Q.level<2?4:0),h(Q,Q.gzhead.os&255),Q.gzhead.extra&&Q.gzhead.extra.length)h(Q,Q.gzhead.extra.length&255),h(Q,Q.gzhead.extra.length>>8&255);if(Q.gzhead.hcrc)J.adler=t(J.adler,Q.pending_buf,Q.pending,0);Q.gzindex=0,Q.status=PJ}if(Q.status===PJ){if(Q.gzhead.extra){let W=Q.pending,X=(Q.gzhead.extra.length&65535)-Q.gzindex;while(Q.pending+X>Q.pending_buf_size){let U=Q.pending_buf_size-Q.pending;if(Q.pending_buf.set(Q.gzhead.extra.subarray(Q.gzindex,Q.gzindex+U),Q.pending),Q.pending=Q.pending_buf_size,Q.gzhead.hcrc&&Q.pending>W)J.adler=t(J.adler,Q.pending_buf,Q.pending-W,W);if(Q.gzindex+=U,V0(J),Q.pending!==0)return Q.last_flush=-1,Q0;W=0,X-=U}let Y=new Uint8Array(Q.gzhead.extra);if(Q.pending_buf.set(Y.subarray(Q.gzindex,Q.gzindex+X),Q.pending),Q.pending+=X,Q.gzhead.hcrc&&Q.pending>W)J.adler=t(J.adler,Q.pending_buf,Q.pending-W,W);Q.gzindex=0}Q.status=CJ}if(Q.status===CJ){if(Q.gzhead.name){let W=Q.pending,X;do{if(Q.pending===Q.pending_buf_size){if(Q.gzhead.hcrc&&Q.pending>W)J.adler=t(J.adler,Q.pending_buf,Q.pending-W,W);if(V0(J),Q.pending!==0)return Q.last_flush=-1,Q0;W=0}if(Q.gzindex<Q.gzhead.name.length)X=Q.gzhead.name.charCodeAt(Q.gzindex++)&255;else X=0;h(Q,X)}while(X!==0);if(Q.gzhead.hcrc&&Q.pending>W)J.adler=t(J.adler,Q.pending_buf,Q.pending-W,W);Q.gzindex=0}Q.status=DJ}if(Q.status===DJ){if(Q.gzhead.comment){let W=Q.pending,X;do{if(Q.pending===Q.pending_buf_size){if(Q.gzhead.hcrc&&Q.pending>W)J.adler=t(J.adler,Q.pending_buf,Q.pending-W,W);if(V0(J),Q.pending!==0)return Q.last_flush=-1,Q0;W=0}if(Q.gzindex<Q.gzhead.comment.length)X=Q.gzhead.comment.charCodeAt(Q.gzindex++)&255;else X=0;h(Q,X)}while(X!==0);if(Q.gzhead.hcrc&&Q.pending>W)J.adler=t(J.adler,Q.pending_buf,Q.pending-W,W)}Q.status=OJ}if(Q.status===OJ){if(Q.gzhead.hcrc){if(Q.pending+2>Q.pending_buf_size){if(V0(J),Q.pending!==0)return Q.last_flush=-1,Q0}h(Q,J.adler&255),h(Q,J.adler>>8&255),J.adler=0}if(Q.status=a0,V0(J),Q.pending!==0)return Q.last_flush=-1,Q0}if(J.avail_in!==0||Q.lookahead!==0||G!==h0&&Q.status!==g8){let W=Q.level===0?R9(Q,G):Q.strategy===z1?R6(Q,G):Q.strategy===Y6?A6(Q,G):E8[Q.level].func(Q,G);if(W===e0||W===N8)Q.status=g8;if(W===W0||W===e0){if(J.avail_out===0)Q.last_flush=-1;return Q0}if(W===L8){if(G===Q6)J6(Q);else if(G!==TQ){if(MJ(Q,0,0,!1),G===G6){if(y0(Q.head),Q.lookahead===0)Q.strstart=0,Q.block_start=0,Q.insert=0}}if(V0(J),J.avail_out===0)return Q.last_flush=-1,Q0}}if(G!==$0)return Q0;if(Q.wrap<=0)return FQ;if(Q.wrap===2)h(Q,J.adler&255),h(Q,J.adler>>8&255),h(Q,J.adler>>16&255),h(Q,J.adler>>24&255),h(Q,J.total_in&255),h(Q,J.total_in>>8&255),h(Q,J.total_in>>16&255),h(Q,J.total_in>>24&255);else v8(Q,J.adler>>>16),v8(Q,J.adler&65535);if(V0(J),Q.wrap>0)Q.wrap=-Q.wrap;return Q.pending!==0?Q0:FQ},F6=(J)=>{if(r8(J))return B0;const G=J.state.status;return J.state=null,G===a0?s0(J,q6):Q0},S6=(J,G)=>{let Q=G.length;if(r8(J))return B0;const q=J.state,W=q.wrap;if(W===2||W===1&&q.status!==D8||q.lookahead)return B0;if(W===1)J.adler=c8(J.adler,G,Q,0);if(q.wrap=0,Q>=q.w_size){if(W===0)y0(q.head),q.strstart=0,q.block_start=0,q.insert=0;let K=new Uint8Array(q.w_size);K.set(G.subarray(Q-q.w_size,Q),0),G=K,Q=q.w_size}const{avail_in:X,next_in:Y,input:U}=J;J.avail_in=Q,J.next_in=0,J.input=G,O8(q);while(q.lookahead>=b){let K=q.strstart,V=q.lookahead-(b-1);do q.ins_h=m0(q,q.ins_h,q.window[K+b-1]),q.prev[K&q.w_mask]=q.head[q.ins_h],q.head[q.ins_h]=K,K++;while(--V);q.strstart=K,q.lookahead=b-1,O8(q)}return q.strstart+=q.lookahead,q.block_start=q.strstart,q.insert=q.lookahead,q.lookahead=0,q.match_length=q.prev_length=b-1,q.match_available=0,J.next_in=Y,J.input=U,J.avail_in=X,q.wrap=W,Q0},v6=x6,g6=w9,E6=I9,y6=k9,f6=w6,b6=T6,h6=F6,m6=S6,_6="pako deflate (from Nodeca project)",f8={deflateInit:v6,deflateInit2:g6,deflateReset:E6,deflateResetKeep:y6,deflateSetHeader:f6,deflate:b6,deflateEnd:h6,deflateSetDictionary:m6,deflateInfo:_6},u6=(J,G)=>{return Object.prototype.hasOwnProperty.call(J,G)},c6=function(J){const G=Array.prototype.slice.call(arguments,1);while(G.length){const Q=G.shift();if(!Q)continue;if(typeof Q!=="object")throw new TypeError(Q+"must be non-object");for(let q in Q)if(u6(Q,q))J[q]=Q[q]}return J},p6=(J)=>{let G=0;for(let q=0,W=J.length;q<W;q++)G+=J[q].length;const Q=new Uint8Array(G);for(let q=0,W=0,X=J.length;q<X;q++){let Y=J[q];Q.set(Y,W),W+=Y.length}return Q},N1={assign:c6,flattenChunks:p6},x9=!0;try{String.fromCharCode.apply(null,new Uint8Array(1))}catch(J){x9=!1}var p8=new Uint8Array(256);for(let J=0;J<256;J++)p8[J]=J>=252?6:J>=248?5:J>=240?4:J>=224?3:J>=192?2:1;p8[254]=p8[254]=1;var l6=(J)=>{if(typeof TextEncoder==="function"&&TextEncoder.prototype.encode)return(new TextEncoder()).encode(J);let G,Q,q,W,X,Y=J.length,U=0;for(W=0;W<Y;W++){if(Q=J.charCodeAt(W),(Q&64512)===55296&&W+1<Y){if(q=J.charCodeAt(W+1),(q&64512)===56320)Q=65536+(Q-55296<<10)+(q-56320),W++}U+=Q<128?1:Q<2048?2:Q<65536?3:4}G=new Uint8Array(U);for(X=0,W=0;X<U;W++){if(Q=J.charCodeAt(W),(Q&64512)===55296&&W+1<Y){if(q=J.charCodeAt(W+1),(q&64512)===56320)Q=65536+(Q-55296<<10)+(q-56320),W++}if(Q<128)G[X++]=Q;else if(Q<2048)G[X++]=192|Q>>>6,G[X++]=128|Q&63;else if(Q<65536)G[X++]=224|Q>>>12,G[X++]=128|Q>>>6&63,G[X++]=128|Q&63;else G[X++]=240|Q>>>18,G[X++]=128|Q>>>12&63,G[X++]=128|Q>>>6&63,G[X++]=128|Q&63}return G},d6=(J,G)=>{if(G<65534){if(J.subarray&&x9)return String.fromCharCode.apply(null,J.length===G?J:J.subarray(0,G))}let Q="";for(let q=0;q<G;q++)Q+=String.fromCharCode(J[q]);return Q},i6=(J,G)=>{const Q=G||J.length;if(typeof TextDecoder==="function"&&TextDecoder.prototype.decode)return(new TextDecoder()).decode(J.subarray(0,G));let q,W;const X=new Array(Q*2);for(W=0,q=0;q<Q;){let Y=J[q++];if(Y<128){X[W++]=Y;continue}let U=p8[Y];if(U>4){X[W++]=65533,q+=U-1;continue}Y&=U===2?31:U===3?15:7;while(U>1&&q<Q)Y=Y<<6|J[q++]&63,U--;if(U>1){X[W++]=65533;continue}if(Y<65536)X[W++]=Y;else Y-=65536,X[W++]=55296|Y>>10&1023,X[W++]=56320|Y&1023}return d6(X,W)},r6=(J,G)=>{if(G=G||J.length,G>J.length)G=J.length;let Q=G-1;while(Q>=0&&(J[Q]&192)===128)Q--;if(Q<0)return G;if(Q===0)return G;return Q+p8[J[Q]]>G?Q:G},l8={string2buf:l6,buf2string:i6,utf8border:r6},T9=o6,F9=Object.prototype.toString,{Z_NO_FLUSH:n6,Z_SYNC_FLUSH:a6,Z_FULL_FLUSH:s6,Z_FINISH:t6,Z_OK:O1,Z_STREAM_END:e6,Z_DEFAULT_COMPRESSION:J7,Z_DEFAULT_STRATEGY:Q7,Z_DEFLATED:G7}=Q8;o8.prototype.push=function(J,G){const Q=this.strm,q=this.options.chunkSize;let W,X;if(this.ended)return!1;if(G===~~G)X=G;else X=G===!0?t6:n6;if(typeof J==="string")Q.input=l8.string2buf(J);else if(F9.call(J)==="[object ArrayBuffer]")Q.input=new Uint8Array(J);else Q.input=J;Q.next_in=0,Q.avail_in=Q.input.length;for(;;){if(Q.avail_out===0)Q.output=new Uint8Array(q),Q.next_out=0,Q.avail_out=q;if((X===a6||X===s6)&&Q.avail_out<=6){this.onData(Q.output.subarray(0,Q.next_out)),Q.avail_out=0;continue}if(W=f8.deflate(Q,X),W===e6){if(Q.next_out>0)this.onData(Q.output.subarray(0,Q.next_out));return W=f8.deflateEnd(this.strm),this.onEnd(W),this.ended=!0,W===O1}if(Q.avail_out===0){this.onData(Q.output);continue}if(X>0&&Q.next_out>0){this.onData(Q.output.subarray(0,Q.next_out)),Q.avail_out=0;continue}if(Q.avail_in===0)break}return!0};o8.prototype.onData=function(J){this.chunks.push(J)};o8.prototype.onEnd=function(J){if(J===O1)this.result=N1.flattenChunks(this.chunks);this.chunks=[],this.err=J,this.msg=this.strm.msg};var X7=o8,Y7=IJ,U7=q7,V7=W7,K7=Q8,Z7={Deflate:X7,deflate:Y7,deflateRaw:U7,gzip:V7,constants:K7},j1=16209,$7=16191,z7=function J(G,Q){let q,W,X,Y,U,K,V,Z,j,$,z,P,M,H,A,R,k,D,T,x,N,I,E,w;const S=G.state;q=G.next_in,E=G.input,W=q+(G.avail_in-5),X=G.next_out,w=G.output,Y=X-(Q-G.avail_out),U=X+(G.avail_out-257),K=S.dmax,V=S.wsize,Z=S.whave,j=S.wnext,$=S.window,z=S.hold,P=S.bits,M=S.lencode,H=S.distcode,A=(1<<S.lenbits)-1,R=(1<<S.distbits)-1;J:do{if(P<15)z+=E[q++]<<P,P+=8,z+=E[q++]<<P,P+=8;k=M[z&A];Q:for(;;){if(D=k>>>24,z>>>=D,P-=D,D=k>>>16&255,D===0)w[X++]=k&65535;else if(D&16){if(T=k&65535,D&=15,D){if(P<D)z+=E[q++]<<P,P+=8;T+=z&(1<<D)-1,z>>>=D,P-=D}if(P<15)z+=E[q++]<<P,P+=8,z+=E[q++]<<P,P+=8;k=H[z&R];G:for(;;){if(D=k>>>24,z>>>=D,P-=D,D=k>>>16&255,D&16){if(x=k&65535,D&=15,P<D){if(z+=E[q++]<<P,P+=8,P<D)z+=E[q++]<<P,P+=8}if(x+=z&(1<<D)-1,x>K){G.msg="invalid distance too far back",S.mode=j1;break J}if(z>>>=D,P-=D,D=X-Y,x>D){if(D=x-D,D>Z){if(S.sane){G.msg="invalid distance too far back",S.mode=j1;break J}}if(N=0,I=$,j===0){if(N+=V-D,D<T){T-=D;do w[X++]=$[N++];while(--D);N=X-x,I=w}}else if(j<D){if(N+=V+j-D,D-=j,D<T){T-=D;do w[X++]=$[N++];while(--D);if(N=0,j<T){D=j,T-=D;do w[X++]=$[N++];while(--D);N=X-x,I=w}}}else if(N+=j-D,D<T){T-=D;do w[X++]=$[N++];while(--D);N=X-x,I=w}while(T>2)w[X++]=I[N++],w[X++]=I[N++],w[X++]=I[N++],T-=3;if(T){if(w[X++]=I[N++],T>1)w[X++]=I[N++]}}else{N=X-x;do w[X++]=w[N++],w[X++]=w[N++],w[X++]=w[N++],T-=3;while(T>2);if(T){if(w[X++]=w[N++],T>1)w[X++]=w[N++]}}}else if((D&64)===0){k=H[(k&65535)+(z&(1<<D)-1)];continue G}else{G.msg="invalid distance code",S.mode=j1;break J}break}}else if((D&64)===0){k=M[(k&65535)+(z&(1<<D)-1)];continue Q}else if(D&32){S.mode=$7;break J}else{G.msg="invalid literal/length code",S.mode=j1;break J}break}}while(q<W&&X<U);T=P>>3,q-=T,P-=T<<3,z&=(1<<P)-1,G.next_in=q,G.next_out=X,G.avail_in=q<W?5+(W-q):5-(q-W),G.avail_out=X<U?257+(U-X):257-(X-U),S.hold=z,S.bits=P;return},P8=15,vQ=852,gQ=592,EQ=0,WJ=1,yQ=2,j7=new Uint16Array([3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,0,0]),M7=new Uint8Array([16,16,16,16,16,16,16,16,17,17,17,17,18,18,18,18,19,19,19,19,20,20,20,20,21,21,21,21,16,72,78]),H7=new Uint16Array([1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,0,0]),P7=new Uint8Array([16,16,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,64,64]),C7=(J,G,Q,q,W,X,Y,U)=>{const K=U.bits;let V=0,Z=0,j=0,$=0,z=0,P=0,M=0,H=0,A=0,R=0,k,D,T,x,N,I=null,E;const w=new Uint16Array(P8+1),S=new Uint16Array(P8+1);let B=null,F,C,L;for(V=0;V<=P8;V++)w[V]=0;for(Z=0;Z<q;Z++)w[G[Q+Z]]++;z=K;for($=P8;$>=1;$--)if(w[$]!==0)break;if(z>$)z=$;if($===0)return W[X++]=1<<24|64<<16|0,W[X++]=1<<24|64<<16|0,U.bits=1,0;for(j=1;j<$;j++)if(w[j]!==0)break;if(z<j)z=j;H=1;for(V=1;V<=P8;V++)if(H<<=1,H-=w[V],H<0)return-1;if(H>0&&(J===EQ||$!==1))return-1;S[1]=0;for(V=1;V<P8;V++)S[V+1]=S[V]+w[V];for(Z=0;Z<q;Z++)if(G[Q+Z]!==0)Y[S[G[Q+Z]]++]=Z;if(J===EQ)I=B=Y,E=20;else if(J===WJ)I=j7,B=M7,E=257;else I=H7,B=P7,E=0;if(R=0,Z=0,V=j,N=X,P=z,M=0,T=-1,A=1<<z,x=A-1,J===WJ&&A>vQ||J===yQ&&A>gQ)return 1;for(;;){if(F=V-M,Y[Z]+1<E)C=0,L=Y[Z];else if(Y[Z]>=E)C=B[Y[Z]-E],L=I[Y[Z]-E];else C=96,L=0;k=1<<V-M,D=1<<P,j=D;do D-=k,W[N+(R>>M)+D]=F<<24|C<<16|L|0;while(D!==0);k=1<<V-1;while(R&k)k>>=1;if(k!==0)R&=k-1,R+=k;else R=0;if(Z++,--w[V]===0){if(V===$)break;V=G[Q+Y[Z]]}if(V>z&&(R&x)!==T){if(M===0)M=z;N+=j,P=V-M,H=1<<P;while(P+M<$){if(H-=w[P+M],H<=0)break;P++,H<<=1}if(A+=1<<P,J===WJ&&A>vQ||J===yQ&&A>gQ)return 1;T=R&x,W[T]=z<<24|P<<16|N-X|0}}if(R!==0)W[N+R]=V-M<<24|64<<16|0;return U.bits=z,0},b8=C7,D7=0,S9=1,v9=2,{Z_FINISH:fQ,Z_BLOCK:O7,Z_TREES:M1,Z_OK:J8,Z_STREAM_END:B7,Z_NEED_DICT:L7,Z_STREAM_ERROR:z0,Z_DATA_ERROR:g9,Z_MEM_ERROR:E9,Z_BUF_ERROR:N7,Z_DEFLATED:bQ}=Q8,A1=16180,hQ=16181,mQ=16182,_Q=16183,uQ=16184,cQ=16185,pQ=16186,lQ=16187,dQ=16188,iQ=16189,B1=16190,I0=16191,XJ=16192,rQ=16193,YJ=16194,oQ=16195,nQ=16196,aQ=16197,sQ=16198,H1=16199,P1=16200,tQ=16201,eQ=16202,J9=16203,Q9=16204,G9=16205,UJ=16206,q9=16207,W9=16208,p=16209,y9=16210,f9=16211,A7=852,R7=592,k7=15,I7=k7,X9=(J)=>{return(J>>>24&255)+(J>>>8&65280)+((J&65280)<<8)+((J&255)<<24)},G8=(J)=>{if(!J)return 1;const G=J.state;if(!G||G.strm!==J||G.mode<A1||G.mode>f9)return 1;return 0},b9=(J)=>{if(G8(J))return z0;const G=J.state;if(J.total_in=J.total_out=G.total=0,J.msg="",G.wrap)J.adler=G.wrap&1;return G.mode=A1,G.last=0,G.havedict=0,G.flags=-1,G.dmax=32768,G.head=null,G.hold=0,G.bits=0,G.lencode=G.lendyn=new Int32Array(A7),G.distcode=G.distdyn=new Int32Array(R7),G.sane=1,G.back=-1,J8},h9=(J)=>{if(G8(J))return z0;const G=J.state;return G.wsize=0,G.whave=0,G.wnext=0,b9(J)},m9=(J,G)=>{let Q;if(G8(J))return z0;const q=J.state;if(G<0)Q=0,G=-G;else if(Q=(G>>4)+5,G<48)G&=15;if(G&&(G<8||G>15))return z0;if(q.window!==null&&q.wbits!==G)q.window=null;return q.wrap=Q,q.wbits=G,h9(J)},_9=(J,G)=>{if(!J)return z0;const Q=new w7;J.state=Q,Q.strm=J,Q.window=null,Q.mode=A1;const q=m9(J,G);if(q!==J8)J.state=null;return q},x7=(J)=>{return _9(J,I7)},Y9=!0,VJ,KJ,T7=(J)=>{if(Y9){VJ=new Int32Array(512),KJ=new Int32Array(32);let G=0;while(G<144)J.lens[G++]=8;while(G<256)J.lens[G++]=9;while(G<280)J.lens[G++]=7;while(G<288)J.lens[G++]=8;b8(S9,J.lens,0,288,VJ,0,J.work,{bits:9}),G=0;while(G<32)J.lens[G++]=5;b8(v9,J.lens,0,32,KJ,0,J.work,{bits:5}),Y9=!1}J.lencode=VJ,J.lenbits=9,J.distcode=KJ,J.distbits=5},u9=(J,G,Q,q)=>{let W;const X=J.state;if(X.window===null)X.wsize=1<<X.wbits,X.wnext=0,X.whave=0,X.window=new Uint8Array(X.wsize);if(q>=X.wsize)X.window.set(G.subarray(Q-X.wsize,Q),0),X.wnext=0,X.whave=X.wsize;else{if(W=X.wsize-X.wnext,W>q)W=q;if(X.window.set(G.subarray(Q-q,Q-q+W),X.wnext),q-=W,q)X.window.set(G.subarray(Q-q,Q),0),X.wnext=q,X.whave=X.wsize;else{if(X.wnext+=W,X.wnext===X.wsize)X.wnext=0;if(X.whave<X.wsize)X.whave+=W}}return 0},F7=(J,G)=>{let Q,q,W,X,Y,U,K,V,Z,j,$,z,P,M,H=0,A,R,k,D,T,x,N,I;const E=new Uint8Array(4);let w,S;const B=new Uint8Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]);if(G8(J)||!J.output||!J.input&&J.avail_in!==0)return z0;if(Q=J.state,Q.mode===I0)Q.mode=XJ;Y=J.next_out,W=J.output,K=J.avail_out,X=J.next_in,q=J.input,U=J.avail_in,V=Q.hold,Z=Q.bits,j=U,$=K,I=J8;J:for(;;)switch(Q.mode){case A1:if(Q.wrap===0){Q.mode=XJ;break}while(Z<16){if(U===0)break J;U--,V+=q[X++]<<Z,Z+=8}if(Q.wrap&2&&V===35615){if(Q.wbits===0)Q.wbits=15;Q.check=0,E[0]=V&255,E[1]=V>>>8&255,Q.check=t(Q.check,E,2,0),V=0,Z=0,Q.mode=hQ;break}if(Q.head)Q.head.done=!1;if(!(Q.wrap&1)||(((V&255)<<8)+(V>>8))%31){J.msg="incorrect header check",Q.mode=p;break}if((V&15)!==bQ){J.msg="unknown compression method",Q.mode=p;break}if(V>>>=4,Z-=4,N=(V&15)+8,Q.wbits===0)Q.wbits=N;if(N>15||N>Q.wbits){J.msg="invalid window size",Q.mode=p;break}Q.dmax=1<<Q.wbits,Q.flags=0,J.adler=Q.check=1,Q.mode=V&512?iQ:I0,V=0,Z=0;break;case hQ:while(Z<16){if(U===0)break J;U--,V+=q[X++]<<Z,Z+=8}if(Q.flags=V,(Q.flags&255)!==bQ){J.msg="unknown compression method",Q.mode=p;break}if(Q.flags&57344){J.msg="unknown header flags set",Q.mode=p;break}if(Q.head)Q.head.text=V>>8&1;if(Q.flags&512&&Q.wrap&4)E[0]=V&255,E[1]=V>>>8&255,Q.check=t(Q.check,E,2,0);V=0,Z=0,Q.mode=mQ;case mQ:while(Z<32){if(U===0)break J;U--,V+=q[X++]<<Z,Z+=8}if(Q.head)Q.head.time=V;if(Q.flags&512&&Q.wrap&4)E[0]=V&255,E[1]=V>>>8&255,E[2]=V>>>16&255,E[3]=V>>>24&255,Q.check=t(Q.check,E,4,0);V=0,Z=0,Q.mode=_Q;case _Q:while(Z<16){if(U===0)break J;U--,V+=q[X++]<<Z,Z+=8}if(Q.head)Q.head.xflags=V&255,Q.head.os=V>>8;if(Q.flags&512&&Q.wrap&4)E[0]=V&255,E[1]=V>>>8&255,Q.check=t(Q.check,E,2,0);V=0,Z=0,Q.mode=uQ;case uQ:if(Q.flags&1024){while(Z<16){if(U===0)break J;U--,V+=q[X++]<<Z,Z+=8}if(Q.length=V,Q.head)Q.head.extra_len=V;if(Q.flags&512&&Q.wrap&4)E[0]=V&255,E[1]=V>>>8&255,Q.check=t(Q.check,E,2,0);V=0,Z=0}else if(Q.head)Q.head.extra=null;Q.mode=cQ;case cQ:if(Q.flags&1024){if(z=Q.length,z>U)z=U;if(z){if(Q.head){if(N=Q.head.extra_len-Q.length,!Q.head.extra)Q.head.extra=new Uint8Array(Q.head.extra_len);Q.head.extra.set(q.subarray(X,X+z),N)}if(Q.flags&512&&Q.wrap&4)Q.check=t(Q.check,q,z,X);U-=z,X+=z,Q.length-=z}if(Q.length)break J}Q.length=0,Q.mode=pQ;case pQ:if(Q.flags&2048){if(U===0)break J;z=0;do if(N=q[X+z++],Q.head&&N&&Q.length<65536)Q.head.name+=String.fromCharCode(N);while(N&&z<U);if(Q.flags&512&&Q.wrap&4)Q.check=t(Q.check,q,z,X);if(U-=z,X+=z,N)break J}else if(Q.head)Q.head.name=null;Q.length=0,Q.mode=lQ;case lQ:if(Q.flags&4096){if(U===0)break J;z=0;do if(N=q[X+z++],Q.head&&N&&Q.length<65536)Q.head.comment+=String.fromCharCode(N);while(N&&z<U);if(Q.flags&512&&Q.wrap&4)Q.check=t(Q.check,q,z,X);if(U-=z,X+=z,N)break J}else if(Q.head)Q.head.comment=null;Q.mode=dQ;case dQ:if(Q.flags&512){while(Z<16){if(U===0)break J;U--,V+=q[X++]<<Z,Z+=8}if(Q.wrap&4&&V!==(Q.check&65535)){J.msg="header crc mismatch",Q.mode=p;break}V=0,Z=0}if(Q.head)Q.head.hcrc=Q.flags>>9&1,Q.head.done=!0;J.adler=Q.check=0,Q.mode=I0;break;case iQ:while(Z<32){if(U===0)break J;U--,V+=q[X++]<<Z,Z+=8}J.adler=Q.check=X9(V),V=0,Z=0,Q.mode=B1;case B1:if(Q.havedict===0)return J.next_out=Y,J.avail_out=K,J.next_in=X,J.avail_in=U,Q.hold=V,Q.bits=Z,L7;J.adler=Q.check=1,Q.mode=I0;case I0:if(G===O7||G===M1)break J;case XJ:if(Q.last){V>>>=Z&7,Z-=Z&7,Q.mode=UJ;break}while(Z<3){if(U===0)break J;U--,V+=q[X++]<<Z,Z+=8}switch(Q.last=V&1,V>>>=1,Z-=1,V&3){case 0:Q.mode=rQ;break;case 1:if(T7(Q),Q.mode=H1,G===M1){V>>>=2,Z-=2;break J}break;case 2:Q.mode=nQ;break;case 3:J.msg="invalid block type",Q.mode=p}V>>>=2,Z-=2;break;case rQ:V>>>=Z&7,Z-=Z&7;while(Z<32){if(U===0)break J;U--,V+=q[X++]<<Z,Z+=8}if((V&65535)!==(V>>>16^65535)){J.msg="invalid stored block lengths",Q.mode=p;break}if(Q.length=V&65535,V=0,Z=0,Q.mode=YJ,G===M1)break J;case YJ:Q.mode=oQ;case oQ:if(z=Q.length,z){if(z>U)z=U;if(z>K)z=K;if(z===0)break J;W.set(q.subarray(X,X+z),Y),U-=z,X+=z,K-=z,Y+=z,Q.length-=z;break}Q.mode=I0;break;case nQ:while(Z<14){if(U===0)break J;U--,V+=q[X++]<<Z,Z+=8}if(Q.nlen=(V&31)+257,V>>>=5,Z-=5,Q.ndist=(V&31)+1,V>>>=5,Z-=5,Q.ncode=(V&15)+4,V>>>=4,Z-=4,Q.nlen>286||Q.ndist>30){J.msg="too many length or distance symbols",Q.mode=p;break}Q.have=0,Q.mode=aQ;case aQ:while(Q.have<Q.ncode){while(Z<3){if(U===0)break J;U--,V+=q[X++]<<Z,Z+=8}Q.lens[B[Q.have++]]=V&7,V>>>=3,Z-=3}while(Q.have<19)Q.lens[B[Q.have++]]=0;if(Q.lencode=Q.lendyn,Q.lenbits=7,w={bits:Q.lenbits},I=b8(D7,Q.lens,0,19,Q.lencode,0,Q.work,w),Q.lenbits=w.bits,I){J.msg="invalid code lengths set",Q.mode=p;break}Q.have=0,Q.mode=sQ;case sQ:while(Q.have<Q.nlen+Q.ndist){for(;;){if(H=Q.lencode[V&(1<<Q.lenbits)-1],A=H>>>24,R=H>>>16&255,k=H&65535,A<=Z)break;if(U===0)break J;U--,V+=q[X++]<<Z,Z+=8}if(k<16)V>>>=A,Z-=A,Q.lens[Q.have++]=k;else{if(k===16){S=A+2;while(Z<S){if(U===0)break J;U--,V+=q[X++]<<Z,Z+=8}if(V>>>=A,Z-=A,Q.have===0){J.msg="invalid bit length repeat",Q.mode=p;break}N=Q.lens[Q.have-1],z=3+(V&3),V>>>=2,Z-=2}else if(k===17){S=A+3;while(Z<S){if(U===0)break J;U--,V+=q[X++]<<Z,Z+=8}V>>>=A,Z-=A,N=0,z=3+(V&7),V>>>=3,Z-=3}else{S=A+7;while(Z<S){if(U===0)break J;U--,V+=q[X++]<<Z,Z+=8}V>>>=A,Z-=A,N=0,z=11+(V&127),V>>>=7,Z-=7}if(Q.have+z>Q.nlen+Q.ndist){J.msg="invalid bit length repeat",Q.mode=p;break}while(z--)Q.lens[Q.have++]=N}}if(Q.mode===p)break;if(Q.lens[256]===0){J.msg="invalid code -- missing end-of-block",Q.mode=p;break}if(Q.lenbits=9,w={bits:Q.lenbits},I=b8(S9,Q.lens,0,Q.nlen,Q.lencode,0,Q.work,w),Q.lenbits=w.bits,I){J.msg="invalid literal/lengths set",Q.mode=p;break}if(Q.distbits=6,Q.distcode=Q.distdyn,w={bits:Q.distbits},I=b8(v9,Q.lens,Q.nlen,Q.ndist,Q.distcode,0,Q.work,w),Q.distbits=w.bits,I){J.msg="invalid distances set",Q.mode=p;break}if(Q.mode=H1,G===M1)break J;case H1:Q.mode=P1;case P1:if(U>=6&&K>=258){if(J.next_out=Y,J.avail_out=K,J.next_in=X,J.avail_in=U,Q.hold=V,Q.bits=Z,z7(J,$),Y=J.next_out,W=J.output,K=J.avail_out,X=J.next_in,q=J.input,U=J.avail_in,V=Q.hold,Z=Q.bits,Q.mode===I0)Q.back=-1;break}Q.back=0;for(;;){if(H=Q.lencode[V&(1<<Q.lenbits)-1],A=H>>>24,R=H>>>16&255,k=H&65535,A<=Z)break;if(U===0)break J;U--,V+=q[X++]<<Z,Z+=8}if(R&&(R&240)===0){D=A,T=R,x=k;for(;;){if(H=Q.lencode[x+((V&(1<<D+T)-1)>>D)],A=H>>>24,R=H>>>16&255,k=H&65535,D+A<=Z)break;if(U===0)break J;U--,V+=q[X++]<<Z,Z+=8}V>>>=D,Z-=D,Q.back+=D}if(V>>>=A,Z-=A,Q.back+=A,Q.length=k,R===0){Q.mode=G9;break}if(R&32){Q.back=-1,Q.mode=I0;break}if(R&64){J.msg="invalid literal/length code",Q.mode=p;break}Q.extra=R&15,Q.mode=tQ;case tQ:if(Q.extra){S=Q.extra;while(Z<S){if(U===0)break J;U--,V+=q[X++]<<Z,Z+=8}Q.length+=V&(1<<Q.extra)-1,V>>>=Q.extra,Z-=Q.extra,Q.back+=Q.extra}Q.was=Q.length,Q.mode=eQ;case eQ:for(;;){if(H=Q.distcode[V&(1<<Q.distbits)-1],A=H>>>24,R=H>>>16&255,k=H&65535,A<=Z)break;if(U===0)break J;U--,V+=q[X++]<<Z,Z+=8}if((R&240)===0){D=A,T=R,x=k;for(;;){if(H=Q.distcode[x+((V&(1<<D+T)-1)>>D)],A=H>>>24,R=H>>>16&255,k=H&65535,D+A<=Z)break;if(U===0)break J;U--,V+=q[X++]<<Z,Z+=8}V>>>=D,Z-=D,Q.back+=D}if(V>>>=A,Z-=A,Q.back+=A,R&64){J.msg="invalid distance code",Q.mode=p;break}Q.offset=k,Q.extra=R&15,Q.mode=J9;case J9:if(Q.extra){S=Q.extra;while(Z<S){if(U===0)break J;U--,V+=q[X++]<<Z,Z+=8}Q.offset+=V&(1<<Q.extra)-1,V>>>=Q.extra,Z-=Q.extra,Q.back+=Q.extra}if(Q.offset>Q.dmax){J.msg="invalid distance too far back",Q.mode=p;break}Q.mode=Q9;case Q9:if(K===0)break J;if(z=$-K,Q.offset>z){if(z=Q.offset-z,z>Q.whave){if(Q.sane){J.msg="invalid distance too far back",Q.mode=p;break}}if(z>Q.wnext)z-=Q.wnext,P=Q.wsize-z;else P=Q.wnext-z;if(z>Q.length)z=Q.length;M=Q.window}else M=W,P=Y-Q.offset,z=Q.length;if(z>K)z=K;K-=z,Q.length-=z;do W[Y++]=M[P++];while(--z);if(Q.length===0)Q.mode=P1;break;case G9:if(K===0)break J;W[Y++]=Q.length,K--,Q.mode=P1;break;case UJ:if(Q.wrap){while(Z<32){if(U===0)break J;U--,V|=q[X++]<<Z,Z+=8}if($-=K,J.total_out+=$,Q.total+=$,Q.wrap&4&&$)J.adler=Q.check=Q.flags?t(Q.check,W,$,Y-$):c8(Q.check,W,$,Y-$);if($=K,Q.wrap&4&&(Q.flags?V:X9(V))!==Q.check){J.msg="incorrect data check",Q.mode=p;break}V=0,Z=0}Q.mode=q9;case q9:if(Q.wrap&&Q.flags){while(Z<32){if(U===0)break J;U--,V+=q[X++]<<Z,Z+=8}if(Q.wrap&4&&V!==(Q.total&4294967295)){J.msg="incorrect length check",Q.mode=p;break}V=0,Z=0}Q.mode=W9;case W9:I=B7;break J;case p:I=g9;break J;case y9:return E9;case f9:default:return z0}if(J.next_out=Y,J.avail_out=K,J.next_in=X,J.avail_in=U,Q.hold=V,Q.bits=Z,Q.wsize||$!==J.avail_out&&Q.mode<p&&(Q.mode<UJ||G!==fQ)){if(u9(J,J.output,J.next_out,$-J.avail_out));}if(j-=J.avail_in,$-=J.avail_out,J.total_in+=j,J.total_out+=$,Q.total+=$,Q.wrap&4&&$)J.adler=Q.check=Q.flags?t(Q.check,W,$,J.next_out-$):c8(Q.check,W,$,J.next_out-$);if(J.data_type=Q.bits+(Q.last?64:0)+(Q.mode===I0?128:0)+(Q.mode===H1||Q.mode===YJ?256:0),(j===0&&$===0||G===fQ)&&I===J8)I=N7;return I},S7=(J)=>{if(G8(J))return z0;let G=J.state;if(G.window)G.window=null;return J.state=null,J8},v7=(J,G)=>{if(G8(J))return z0;const Q=J.state;if((Q.wrap&2)===0)return z0;return Q.head=G,G.done=!1,J8},g7=(J,G)=>{const Q=G.length;let q,W,X;if(G8(J))return z0;if(q=J.state,q.wrap!==0&&q.mode!==B1)return z0;if(q.mode===B1){if(W=1,W=c8(W,G,Q,0),W!==q.check)return g9}if(X=u9(J,G,Q,Q),X)return q.mode=y9,E9;return q.havedict=1,J8},E7=h9,y7=m9,f7=b9,b7=x7,h7=_9,m7=F7,_7=S7,u7=v7,c7=g7,p7="pako inflate (from Nodeca project)",x0={inflateReset:E7,inflateReset2:y7,inflateResetKeep:f7,inflateInit:b7,inflateInit2:h7,inflate:m7,inflateEnd:_7,inflateGetHeader:u7,inflateSetDictionary:c7,inflateInfo:p7},d7=l7,c9=Object.prototype.toString,{Z_NO_FLUSH:i7,Z_FINISH:r7,Z_OK:d8,Z_STREAM_END:ZJ,Z_NEED_DICT:$J,Z_STREAM_ERROR:o7,Z_DATA_ERROR:U9,Z_MEM_ERROR:n7}=Q8;n8.prototype.push=function(J,G){const Q=this.strm,q=this.options.chunkSize,W=this.options.dictionary;let X,Y,U;if(this.ended)return!1;if(G===~~G)Y=G;else Y=G===!0?r7:i7;if(c9.call(J)==="[object ArrayBuffer]")Q.input=new Uint8Array(J);else Q.input=J;Q.next_in=0,Q.avail_in=Q.input.length;for(;;){if(Q.avail_out===0)Q.output=new Uint8Array(q),Q.next_out=0,Q.avail_out=q;if(X=x0.inflate(Q,Y),X===$J&&W){if(X=x0.inflateSetDictionary(Q,W),X===d8)X=x0.inflate(Q,Y);else if(X===U9)X=$J}while(Q.avail_in>0&&X===ZJ&&Q.state.wrap>0&&J[Q.next_in]!==0)x0.inflateReset(Q),X=x0.inflate(Q,Y);switch(X){case o7:case U9:case $J:case n7:return this.onEnd(X),this.ended=!0,!1}if(U=Q.avail_out,Q.next_out){if(Q.avail_out===0||X===ZJ)if(this.options.to==="string"){let K=l8.utf8border(Q.output,Q.next_out),V=Q.next_out-K,Z=l8.buf2string(Q.output,K);if(Q.next_out=V,Q.avail_out=q-V,V)Q.output.set(Q.output.subarray(K,K+V),0);this.onData(Z)}else this.onData(Q.output.length===Q.next_out?Q.output:Q.output.subarray(0,Q.next_out))}if(X===d8&&U===0)continue;if(X===ZJ)return X=x0.inflateEnd(this.strm),this.onEnd(X),this.ended=!0,!0;if(Q.avail_in===0)break}return!0};n8.prototype.onData=function(J){this.chunks.push(J)};n8.prototype.onEnd=function(J){if(J===d8)if(this.options.to==="string")this.result=this.chunks.join("");else this.result=N1.flattenChunks(this.chunks);this.chunks=[],this.err=J,this.msg=this.strm.msg};var s7=n8,t7=wJ,e7=a7,Jq=wJ,Qq=Q8,Gq={Inflate:s7,inflate:t7,inflateRaw:e7,ungzip:Jq,constants:Qq},{Deflate:qq,deflate:Wq,deflateRaw:Xq,gzip:Yq}=Z7,{Inflate:Uq,inflate:Vq,inflateRaw:Kq,ungzip:Zq}=Gq,$q=qq,zq=Wq,jq=Xq,Mq=Yq,Hq=Uq,Pq=Vq,Cq=Kq,Dq=Zq,Oq=Q8,xJ={Deflate:$q,deflate:zq,deflateRaw:jq,gzip:Mq,Inflate:Hq,inflate:Pq,inflateRaw:Cq,ungzip:Dq,constants:Oq};var p9=function(J){if(!Number.isSafeInteger(J)||J<0)throw new Error("positive integer expected, got "+J)},Bq=function(J){return J instanceof Uint8Array||ArrayBuffer.isView(J)&&J.constructor.name==="Uint8Array"},A8=function(J,...G){if(!Bq(J))throw new Error("Uint8Array expected");if(G.length>0&&!G.includes(J.length))throw new Error("Uint8Array expected of length "+G+", got length="+J.length)},l9=function(J){if(typeof J!=="function"||typeof J.create!=="function")throw new Error("Hash should be wrapped by utils.wrapConstructor");p9(J.outputLen),p9(J.blockLen)},R8=function(J,G=!0){if(J.destroyed)throw new Error("Hash instance has been destroyed");if(G&&J.finished)throw new Error("Hash#digest() has already been called")},d9=function(J,G){A8(J);const Q=G.outputLen;if(J.length<Q)throw new Error("digestInto() expects output buffer of length at least "+Q)};var q8=typeof globalThis==="object"&&("crypto"in globalThis)?globalThis.crypto:void 0;function R1(J){return new DataView(J.buffer,J.byteOffset,J.byteLength)}function H0(J,G){return J<<32-G|J>>>G}function Lq(J){if(typeof J!=="string")throw new Error("utf8ToBytes expected string, got "+typeof J);return new Uint8Array((new TextEncoder()).encode(J))}function a8(J){if(typeof J==="string")J=Lq(J);return A8(J),J}function i9(...J){let G=0;for(let q=0;q<J.length;q++){const W=J[q];A8(W),G+=W.length}const Q=new Uint8Array(G);for(let q=0,W=0;q<J.length;q++){const X=J[q];Q.set(X,W),W+=X.length}return Q}function r9(J){const G=(q)=>J().update(a8(q)).digest(),Q=J();return G.outputLen=Q.outputLen,G.blockLen=Q.blockLen,G.create=()=>J(),G}function k1(J=32){if(q8&&typeof q8.getRandomValues==="function")return q8.getRandomValues(new Uint8Array(J));if(q8&&typeof q8.randomBytes==="function")return q8.randomBytes(J);throw new Error("crypto.getRandomValues must be defined")}/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */class s8{clone(){return this._cloneInto()}}function Nq(J,G,Q,q){if(typeof J.setBigUint64==="function")return J.setBigUint64(G,Q,q);const W=BigInt(32),X=BigInt(4294967295),Y=Number(Q>>W&X),U=Number(Q&X),K=q?4:0,V=q?0:4;J.setUint32(G+K,Y,q),J.setUint32(G+V,U,q)}function o9(J,G,Q){return J&G^~J&Q}function n9(J,G,Q){return J&G^J&Q^G&Q}class TJ extends s8{constructor(J,G,Q,q){super();this.blockLen=J,this.outputLen=G,this.padOffset=Q,this.isLE=q,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(J),this.view=R1(this.buffer)}update(J){R8(this);const{view:G,buffer:Q,blockLen:q}=this;J=a8(J);const W=J.length;for(let X=0;X<W;){const Y=Math.min(q-this.pos,W-X);if(Y===q){const U=R1(J);for(;q<=W-X;X+=q)this.process(U,X);continue}if(Q.set(J.subarray(X,X+Y),this.pos),this.pos+=Y,X+=Y,this.pos===q)this.process(G,0),this.pos=0}return this.length+=J.length,this.roundClean(),this}digestInto(J){R8(this),d9(J,this),this.finished=!0;const{buffer:G,view:Q,blockLen:q,isLE:W}=this;let{pos:X}=this;if(G[X++]=128,this.buffer.subarray(X).fill(0),this.padOffset>q-X)this.process(Q,0),X=0;for(let Z=X;Z<q;Z++)G[Z]=0;Nq(Q,q-8,BigInt(this.length*8),W),this.process(Q,0);const Y=R1(J),U=this.outputLen;if(U%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const K=U/4,V=this.get();if(K>V.length)throw new Error("_sha2: outputLen bigger than state");for(let Z=0;Z<K;Z++)Y.setUint32(4*Z,V[Z],W)}digest(){const{buffer:J,outputLen:G}=this;this.digestInto(J);const Q=J.slice(0,G);return this.destroy(),Q}_cloneInto(J){J||(J=new this.constructor),J.set(...this.get());const{blockLen:G,buffer:Q,length:q,finished:W,destroyed:X,pos:Y}=this;if(J.length=q,J.pos=Y,J.finished=W,J.destroyed=X,q%G)J.buffer.set(Q);return J}}var Aq=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),_0=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),u0=new Uint32Array(64);class a9 extends TJ{constructor(){super(64,32,8,!1);this.A=_0[0]|0,this.B=_0[1]|0,this.C=_0[2]|0,this.D=_0[3]|0,this.E=_0[4]|0,this.F=_0[5]|0,this.G=_0[6]|0,this.H=_0[7]|0}get(){const{A:J,B:G,C:Q,D:q,E:W,F:X,G:Y,H:U}=this;return[J,G,Q,q,W,X,Y,U]}set(J,G,Q,q,W,X,Y,U){this.A=J|0,this.B=G|0,this.C=Q|0,this.D=q|0,this.E=W|0,this.F=X|0,this.G=Y|0,this.H=U|0}process(J,G){for(let Z=0;Z<16;Z++,G+=4)u0[Z]=J.getUint32(G,!1);for(let Z=16;Z<64;Z++){const j=u0[Z-15],$=u0[Z-2],z=H0(j,7)^H0(j,18)^j>>>3,P=H0($,17)^H0($,19)^$>>>10;u0[Z]=P+u0[Z-7]+z+u0[Z-16]|0}let{A:Q,B:q,C:W,D:X,E:Y,F:U,G:K,H:V}=this;for(let Z=0;Z<64;Z++){const j=H0(Y,6)^H0(Y,11)^H0(Y,25),$=V+j+o9(Y,U,K)+Aq[Z]+u0[Z]|0,P=(H0(Q,2)^H0(Q,13)^H0(Q,22))+n9(Q,q,W)|0;V=K,K=U,U=Y,Y=X+$|0,X=W,W=q,q=Q,Q=$+P|0}Q=Q+this.A|0,q=q+this.B|0,W=W+this.C|0,X=X+this.D|0,Y=Y+this.E|0,U=U+this.F|0,K=K+this.G|0,V=V+this.H|0,this.set(Q,q,W,X,Y,U,K,V)}roundClean(){u0.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}}var I1=r9(()=>new a9);class FJ extends s8{constructor(J,G){super();this.finished=!1,this.destroyed=!1,l9(J);const Q=a8(G);if(this.iHash=J.create(),typeof this.iHash.update!=="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const q=this.blockLen,W=new Uint8Array(q);W.set(Q.length>q?J.create().update(Q).digest():Q);for(let X=0;X<W.length;X++)W[X]^=54;this.iHash.update(W),this.oHash=J.create();for(let X=0;X<W.length;X++)W[X]^=54^92;this.oHash.update(W),W.fill(0)}update(J){return R8(this),this.iHash.update(J),this}digestInto(J){R8(this),A8(J,this.outputLen),this.finished=!0,this.iHash.digestInto(J),this.oHash.update(J),this.oHash.digestInto(J),this.destroy()}digest(){const J=new Uint8Array(this.oHash.outputLen);return this.digestInto(J),J}_cloneInto(J){J||(J=Object.create(Object.getPrototypeOf(this),{}));const{oHash:G,iHash:Q,finished:q,destroyed:W,blockLen:X,outputLen:Y}=this;return J=J,J.finished=q,J.destroyed=W,J.blockLen=X,J.outputLen=Y,J.oHash=G._cloneInto(J.oHash),J.iHash=Q._cloneInto(J.iHash),J}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}var SJ=(J,G,Q)=>new FJ(J,G).update(Q).digest();SJ.create=(J,G)=>new FJ(J,G);var bJ={};JG(bJ,{validateObject:()=>{{return l0}},utf8ToBytes:()=>{{return xq}},numberToVarBytesBE:()=>{{return Iq}},numberToHexUnpadded:()=>{{return Y8}},numberToBytesLE:()=>{{return F1}},numberToBytesBE:()=>{{return P0}},notImplemented:()=>{{return vq}},memoized:()=>{{return S1}},isBytes:()=>{{return c0}},inRange:()=>{{return p0}},hexToNumber:()=>{{return EJ}},hexToBytes:()=>{{return U8}},equalBytes:()=>{{return wq}},ensureBytes:()=>{{return n}},createHmacDrbg:()=>{{return fJ}},concatBytes:()=>{{return F0}},bytesToNumberLE:()=>{{return T1}},bytesToNumberBE:()=>{{return j0}},bytesToHex:()=>{{return X8}},bitSet:()=>{{return Fq}},bitMask:()=>{{return t8}},bitLen:()=>{{return yJ}},bitGet:()=>{{return Tq}},abytes:()=>{{return k8}},abool:()=>{{return W8}},aInRange:()=>{{return N0}}});function c0(J){return J instanceof Uint8Array||ArrayBuffer.isView(J)&&J.constructor.name==="Uint8Array"}function k8(J){if(!c0(J))throw new Error("Uint8Array expected")}function W8(J,G){if(typeof G!=="boolean")throw new Error(J+" boolean expected, got "+G)}function X8(J){k8(J);let G="";for(let Q=0;Q<J.length;Q++)G+=kq[J[Q]];return G}function Y8(J){const G=J.toString(16);return G.length&1?"0"+G:G}function EJ(J){if(typeof J!=="string")throw new Error("hex string expected, got "+typeof J);return J===""?w1:BigInt("0x"+J)}var s9=function(J){if(J>=T0._0&&J<=T0._9)return J-T0._0;if(J>=T0.A&&J<=T0.F)return J-(T0.A-10);if(J>=T0.a&&J<=T0.f)return J-(T0.a-10);return};function U8(J){if(typeof J!=="string")throw new Error("hex string expected, got "+typeof J);const G=J.length,Q=G/2;if(G%2)throw new Error("hex string expected, got unpadded hex of length "+G);const q=new Uint8Array(Q);for(let W=0,X=0;W<Q;W++,X+=2){const Y=s9(J.charCodeAt(X)),U=s9(J.charCodeAt(X+1));if(Y===void 0||U===void 0){const K=J[X]+J[X+1];throw new Error('hex string expected, got non-hex character "'+K+'" at index '+X)}q[W]=Y*16+U}return q}function j0(J){return EJ(X8(J))}function T1(J){return k8(J),EJ(X8(Uint8Array.from(J).reverse()))}function P0(J,G){return U8(J.toString(16).padStart(G*2,"0"))}function F1(J,G){return P0(J,G).reverse()}function Iq(J){return U8(Y8(J))}function n(J,G,Q){let q;if(typeof G==="string")try{q=U8(G)}catch(X){throw new Error(J+" must be hex string or Uint8Array, cause: "+X)}else if(c0(G))q=Uint8Array.from(G);else throw new Error(J+" must be hex string or Uint8Array");const W=q.length;if(typeof Q==="number"&&W!==Q)throw new Error(J+" of length "+Q+" expected, got "+W);return q}function F0(...J){let G=0;for(let q=0;q<J.length;q++){const W=J[q];k8(W),G+=W.length}const Q=new Uint8Array(G);for(let q=0,W=0;q<J.length;q++){const X=J[q];Q.set(X,W),W+=X.length}return Q}function wq(J,G){if(J.length!==G.length)return!1;let Q=0;for(let q=0;q<J.length;q++)Q|=J[q]^G[q];return Q===0}function xq(J){if(typeof J!=="string")throw new Error("string expected");return new Uint8Array((new TextEncoder()).encode(J))}function p0(J,G,Q){return vJ(J)&&vJ(G)&&vJ(Q)&&G<=J&&J<Q}function N0(J,G,Q,q){if(!p0(G,Q,q))throw new Error("expected valid "+J+": "+Q+" <= n < "+q+", got "+G)}function yJ(J){let G;for(G=0;J>w1;J>>=x1,G+=1);return G}function Tq(J,G){return J>>BigInt(G)&x1}function Fq(J,G,Q){return J|(Q?x1:w1)<<BigInt(G)}function fJ(J,G,Q){if(typeof J!=="number"||J<2)throw new Error("hashLen must be a number");if(typeof G!=="number"||G<2)throw new Error("qByteLen must be a number");if(typeof Q!=="function")throw new Error("hmacFn must be a function");let q=gJ(J),W=gJ(J),X=0;const Y=()=>{q.fill(1),W.fill(0),X=0},U=(...j)=>Q(W,q,...j),K=(j=gJ())=>{if(W=U(t9([0]),j),q=U(),j.length===0)return;W=U(t9([1]),j),q=U()},V=()=>{if(X++>=1000)throw new Error("drbg: tried 1000 values");let j=0;const $=[];while(j<G){q=U();const z=q.slice();$.push(z),j+=q.length}return F0(...$)};return(j,$)=>{Y(),K(j);let z=void 0;while(!(z=$(V())))K();return Y(),z}}function l0(J,G,Q={}){const q=(W,X,Y)=>{const U=Sq[X];if(typeof U!=="function")throw new Error("invalid validator function");const K=J[W];if(Y&&K===void 0)return;if(!U(K,J))throw new Error("param "+String(W)+" is invalid. Expected "+X+", got "+K)};for(let[W,X]of Object.entries(G))q(W,X,!1);for(let[W,X]of Object.entries(Q))q(W,X,!0);return J}function S1(J){const G=new WeakMap;return(Q,...q)=>{const W=G.get(Q);if(W!==void 0)return W;const X=J(Q,...q);return G.set(Q,X),X}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */var w1=BigInt(0),x1=BigInt(1),Rq=BigInt(2),kq=Array.from({length:256},(J,G)=>G.toString(16).padStart(2,"0")),T0={_0:48,_9:57,A:65,F:70,a:97,f:102},vJ=(J)=>typeof J==="bigint"&&w1<=J,t8=(J)=>(Rq<<BigInt(J-1))-x1,gJ=(J)=>new Uint8Array(J),t9=(J)=>Uint8Array.from(J),Sq={bigint:(J)=>typeof J==="bigint",function:(J)=>typeof J==="function",boolean:(J)=>typeof J==="boolean",string:(J)=>typeof J==="string",stringOrUint8Array:(J)=>typeof J==="string"||c0(J),isSafeInteger:(J)=>Number.isSafeInteger(J),array:(J)=>Array.isArray(J),field:(J,G)=>G.Fp.isValid(J),hash:(J)=>typeof J==="function"&&Number.isSafeInteger(J.outputLen)},vq=()=>{throw new Error("not implemented")};function a(J,G){const Q=J%G;return Q>=s?Q:G+Q}function fq(J,G,Q){if(G<s)throw new Error("invalid exponent, negatives unsupported");if(Q<=s)throw new Error("invalid modulus");if(Q===d)return s;let q=d;while(G>s){if(G&d)q=q*J%Q;J=J*J%Q,G>>=d}return q}function Z0(J,G,Q){let q=J;while(G-- >s)q*=q,q%=Q;return q}function v1(J,G){if(J===s)throw new Error("invert: expected non-zero number");if(G<=s)throw new Error("invert: expected positive modulus, got "+G);let Q=a(J,G),q=G,W=s,X=d,Y=d,U=s;while(Q!==s){const V=q/Q,Z=q%Q,j=W-Y*V,$=X-U*V;q=Q,Q=Z,W=Y,X=U,Y=j,U=$}if(q!==d)throw new Error("invert: does not exist");return a(W,G)}function bq(J){const G=(J-d)/V8;let Q,q,W;for(Q=J-d,q=0;Q%V8===s;Q/=V8,q++);for(W=V8;W<J&&fq(W,G,J)!==J-d;W++)if(W>1000)throw new Error("Cannot find square root: likely non-prime P");if(q===1){const Y=(J+d)/hJ;return function U(K,V){const Z=K.pow(V,Y);if(!K.eql(K.sqr(Z),V))throw new Error("Cannot find square root");return Z}}const X=(Q+d)/V8;return function Y(U,K){if(U.pow(K,G)===U.neg(U.ONE))throw new Error("Cannot find square root");let V=q,Z=U.pow(U.mul(U.ONE,W),Q),j=U.pow(K,X),$=U.pow(K,Q);while(!U.eql($,U.ONE)){if(U.eql($,U.ZERO))return U.ZERO;let z=1;for(let M=U.sqr($);z<V;z++){if(U.eql(M,U.ONE))break;M=U.sqr(M)}const P=U.pow(Z,d<<BigInt(V-z-1));Z=U.sqr(P),j=U.mul(j,P),$=U.mul($,Z),V=z}return j}}function hq(J){if(J%hJ===gq){const G=(J+d)/hJ;return function Q(q,W){const X=q.pow(W,G);if(!q.eql(q.sqr(X),W))throw new Error("Cannot find square root");return X}}if(J%J5===e9){const G=(J-e9)/J5;return function Q(q,W){const X=q.mul(W,V8),Y=q.pow(X,G),U=q.mul(W,Y),K=q.mul(q.mul(U,V8),Y),V=q.mul(U,q.sub(K,q.ONE));if(!q.eql(q.sqr(V),W))throw new Error("Cannot find square root");return V}}if(J%yq===Eq);return bq(J)}function mJ(J){const G={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},Q=mq.reduce((q,W)=>{return q[W]="function",q},G);return l0(J,Q)}function _q(J,G,Q){if(Q<s)throw new Error("invalid exponent, negatives unsupported");if(Q===s)return J.ONE;if(Q===d)return G;let q=J.ONE,W=G;while(Q>s){if(Q&d)q=J.mul(q,W);W=J.sqr(W),Q>>=d}return q}function uq(J,G){const Q=new Array(G.length),q=G.reduce((X,Y,U)=>{if(J.is0(Y))return X;return Q[U]=X,J.mul(X,Y)},J.ONE),W=J.inv(q);return G.reduceRight((X,Y,U)=>{if(J.is0(Y))return X;return Q[U]=J.mul(X,Q[U]),J.mul(X,Y)},W),Q}function _J(J,G){const Q=G!==void 0?G:J.toString(2).length,q=Math.ceil(Q/8);return{nBitLength:Q,nByteLength:q}}function g1(J,G,Q=!1,q={}){if(J<=s)throw new Error("invalid field: expected ORDER > 0, got "+J);const{nBitLength:W,nByteLength:X}=_J(J,G);if(X>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let Y;const U=Object.freeze({ORDER:J,isLE:Q,BITS:W,BYTES:X,MASK:t8(W),ZERO:s,ONE:d,create:(K)=>a(K,J),isValid:(K)=>{if(typeof K!=="bigint")throw new Error("invalid field element: expected bigint, got "+typeof K);return s<=K&&K<J},is0:(K)=>K===s,isOdd:(K)=>(K&d)===d,neg:(K)=>a(-K,J),eql:(K,V)=>K===V,sqr:(K)=>a(K*K,J),add:(K,V)=>a(K+V,J),sub:(K,V)=>a(K-V,J),mul:(K,V)=>a(K*V,J),pow:(K,V)=>_q(U,K,V),div:(K,V)=>a(K*v1(V,J),J),sqrN:(K)=>K*K,addN:(K,V)=>K+V,subN:(K,V)=>K-V,mulN:(K,V)=>K*V,inv:(K)=>v1(K,J),sqrt:q.sqrt||((K)=>{if(!Y)Y=hq(J);return Y(U,K)}),invertBatch:(K)=>uq(U,K),cmov:(K,V,Z)=>Z?V:K,toBytes:(K)=>Q?F1(K,X):P0(K,X),fromBytes:(K)=>{if(K.length!==X)throw new Error("Field.fromBytes: expected "+X+" bytes, got "+K.length);return Q?T1(K):j0(K)}});return Object.freeze(U)}function Q5(J){if(typeof J!=="bigint")throw new Error("field order must be bigint");const G=J.toString(2).length;return Math.ceil(G/8)}function uJ(J){const G=Q5(J);return G+Math.ceil(G/2)}function G5(J,G,Q=!1){const q=J.length,W=Q5(G),X=uJ(G);if(q<16||q<X||q>1024)throw new Error("expected "+X+"-1024 bytes of input, got "+q);const Y=Q?T1(J):j0(J),U=a(Y,G-d)+d;return Q?F1(U,W):P0(U,W)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */var s=BigInt(0),d=BigInt(1),V8=BigInt(2),gq=BigInt(3),hJ=BigInt(4),e9=BigInt(5),J5=BigInt(8),Eq=BigInt(9),yq=BigInt(16);var mq=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];var cJ=function(J,G){const Q=G.negate();return J?Q:G},W5=function(J,G){if(!Number.isSafeInteger(J)||J<=0||J>G)throw new Error("invalid window size, expected [1.."+G+"], got W="+J)},pJ=function(J,G){W5(J,G);const Q=Math.ceil(G/J)+1,q=2**(J-1);return{windows:Q,windowSize:q}},cq=function(J,G){if(!Array.isArray(J))throw new Error("array expected");J.forEach((Q,q)=>{if(!(Q instanceof G))throw new Error("invalid point at index "+q)})},pq=function(J,G){if(!Array.isArray(J))throw new Error("array of scalars expected");J.forEach((Q,q)=>{if(!G.isValid(Q))throw new Error("invalid scalar at index "+q)})},dJ=function(J){return X5.get(J)||1};function Y5(J,G){return{constTimeNegate:cJ,hasPrecomputes(Q){return dJ(Q)!==1},unsafeLadder(Q,q,W=J.ZERO){let X=Q;while(q>q5){if(q&E1)W=W.add(X);X=X.double(),q>>=E1}return W},precomputeWindow(Q,q){const{windows:W,windowSize:X}=pJ(q,G),Y=[];let U=Q,K=U;for(let V=0;V<W;V++){K=U,Y.push(K);for(let Z=1;Z<X;Z++)K=K.add(U),Y.push(K);U=K.double()}return Y},wNAF(Q,q,W){const{windows:X,windowSize:Y}=pJ(Q,G);let{ZERO:U,BASE:K}=J;const V=BigInt(2**Q-1),Z=2**Q,j=BigInt(Q);for(let $=0;$<X;$++){const z=$*Y;let P=Number(W&V);if(W>>=j,P>Y)P-=Z,W+=E1;const M=z,H=z+Math.abs(P)-1,A=$%2!==0,R=P<0;if(P===0)K=K.add(cJ(A,q[M]));else U=U.add(cJ(R,q[H]))}return{p:U,f:K}},wNAFUnsafe(Q,q,W,X=J.ZERO){const{windows:Y,windowSize:U}=pJ(Q,G),K=BigInt(2**Q-1),V=2**Q,Z=BigInt(Q);for(let j=0;j<Y;j++){const $=j*U;if(W===q5)break;let z=Number(W&K);if(W>>=Z,z>U)z-=V,W+=E1;if(z===0)continue;let P=q[$+Math.abs(z)-1];if(z<0)P=P.negate();X=X.add(P)}return X},getPrecomputes(Q,q,W){let X=lJ.get(q);if(!X){if(X=this.precomputeWindow(q,Q),Q!==1)lJ.set(q,W(X))}return X},wNAFCached(Q,q,W){const X=dJ(Q);return this.wNAF(X,this.getPrecomputes(X,Q,W),q)},wNAFCachedUnsafe(Q,q,W,X){const Y=dJ(Q);if(Y===1)return this.unsafeLadder(Q,q,X);return this.wNAFUnsafe(Y,this.getPrecomputes(Y,Q,W),q,X)},setWindowSize(Q,q){W5(q,G),X5.set(Q,q),lJ.delete(Q)}}}function U5(J,G,Q,q){if(cq(Q,J),pq(q,G),Q.length!==q.length)throw new Error("arrays of points and scalars must have equal length");const W=J.ZERO,X=yJ(BigInt(Q.length)),Y=X>12?X-3:X>4?X-2:X?2:1,U=(1<<Y)-1,K=new Array(U+1).fill(W),V=Math.floor((G.BITS-1)/Y)*Y;let Z=W;for(let j=V;j>=0;j-=Y){K.fill(W);for(let z=0;z<q.length;z++){const P=q[z],M=Number(P>>BigInt(j)&BigInt(U));K[M]=K[M].add(Q[z])}let $=W;for(let z=K.length-1,P=W;z>0;z--)P=P.add(K[z]),$=$.add(P);if(Z=Z.add($),j!==0)for(let z=0;z<Y;z++)Z=Z.double()}return Z}function iJ(J){return mJ(J.Fp),l0(J,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({..._J(J.n,J.nBitLength),...J,...{p:J.Fp.ORDER}})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */var q5=BigInt(0),E1=BigInt(1),lJ=new WeakMap,X5=new WeakMap;var V5=function(J){if(J.lowS!==void 0)W8("lowS",J.lowS);if(J.prehash!==void 0)W8("prehash",J.prehash)},lq=function(J){const G=iJ(J);l0(G,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});const{endo:Q,Fp:q,a:W}=G;if(Q){if(!q.eql(W,q.ZERO))throw new Error("invalid endomorphism, can only be defined for Koblitz curves that have a=0");if(typeof Q!=="object"||typeof Q.beta!=="bigint"||typeof Q.splitScalar!=="function")throw new Error("invalid endomorphism, expected beta: bigint and splitScalar: function")}return Object.freeze({...G})};function rq(J){const G=lq(J),{Fp:Q}=G,q=g1(G.n,G.nBitLength),W=G.toBytes||((M,H,A)=>{const R=H.toAffine();return F0(Uint8Array.from([4]),Q.toBytes(R.x),Q.toBytes(R.y))}),X=G.fromBytes||((M)=>{const H=M.subarray(1),A=Q.fromBytes(H.subarray(0,Q.BYTES)),R=Q.fromBytes(H.subarray(Q.BYTES,2*Q.BYTES));return{x:A,y:R}});function Y(M){const{a:H,b:A}=G,R=Q.sqr(M),k=Q.mul(R,M);return Q.add(Q.add(k,Q.mul(M,H)),A)}if(!Q.eql(Q.sqr(G.Gy),Y(G.Gx)))throw new Error("bad generator point: equation left != right");function U(M){return p0(M,e,G.n)}function K(M){const{allowedPrivateKeyLengths:H,nByteLength:A,wrapPrivateKey:R,n:k}=G;if(H&&typeof M!=="bigint"){if(c0(M))M=X8(M);if(typeof M!=="string"||!H.includes(M.length))throw new Error("invalid private key");M=M.padStart(A*2,"0")}let D;try{D=typeof M==="bigint"?M:j0(n("private key",M,A))}catch(T){throw new Error("invalid private key, expected hex or "+A+" bytes, got "+typeof M)}if(R)D=a(D,k);return N0("private key",D,e,k),D}function V(M){if(!(M instanceof $))throw new Error("ProjectivePoint expected")}const Z=S1((M,H)=>{const{px:A,py:R,pz:k}=M;if(Q.eql(k,Q.ONE))return{x:A,y:R};const D=M.is0();if(H==null)H=D?Q.ONE:Q.inv(k);const T=Q.mul(A,H),x=Q.mul(R,H),N=Q.mul(k,H);if(D)return{x:Q.ZERO,y:Q.ZERO};if(!Q.eql(N,Q.ONE))throw new Error("invZ was invalid");return{x:T,y:x}}),j=S1((M)=>{if(M.is0()){if(G.allowInfinityPoint&&!Q.is0(M.py))return;throw new Error("bad point: ZERO")}const{x:H,y:A}=M.toAffine();if(!Q.isValid(H)||!Q.isValid(A))throw new Error("bad point: x or y not FE");const R=Q.sqr(A),k=Y(H);if(!Q.eql(R,k))throw new Error("bad point: equation left != right");if(!M.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});class ${constructor(M,H,A){if(this.px=M,this.py=H,this.pz=A,M==null||!Q.isValid(M))throw new Error("x required");if(H==null||!Q.isValid(H))throw new Error("y required");if(A==null||!Q.isValid(A))throw new Error("z required");Object.freeze(this)}static fromAffine(M){const{x:H,y:A}=M||{};if(!M||!Q.isValid(H)||!Q.isValid(A))throw new Error("invalid affine point");if(M instanceof $)throw new Error("projective point not allowed");const R=(k)=>Q.eql(k,Q.ZERO);if(R(H)&&R(A))return $.ZERO;return new $(H,A,Q.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(M){const H=Q.invertBatch(M.map((A)=>A.pz));return M.map((A,R)=>A.toAffine(H[R])).map($.fromAffine)}static fromHex(M){const H=$.fromAffine(X(n("pointHex",M)));return H.assertValidity(),H}static fromPrivateKey(M){return $.BASE.multiply(K(M))}static msm(M,H){return U5($,q,M,H)}_setWindowSize(M){P.setWindowSize(this,M)}assertValidity(){j(this)}hasEvenY(){const{y:M}=this.toAffine();if(Q.isOdd)return!Q.isOdd(M);throw new Error("Field doesn't support isOdd")}equals(M){V(M);const{px:H,py:A,pz:R}=this,{px:k,py:D,pz:T}=M,x=Q.eql(Q.mul(H,T),Q.mul(k,R)),N=Q.eql(Q.mul(A,T),Q.mul(D,R));return x&&N}negate(){return new $(this.px,Q.neg(this.py),this.pz)}double(){const{a:M,b:H}=G,A=Q.mul(H,K5),{px:R,py:k,pz:D}=this;let{ZERO:T,ZERO:x,ZERO:N}=Q,I=Q.mul(R,R),E=Q.mul(k,k),w=Q.mul(D,D),S=Q.mul(R,k);return S=Q.add(S,S),N=Q.mul(R,D),N=Q.add(N,N),T=Q.mul(M,N),x=Q.mul(A,w),x=Q.add(T,x),T=Q.sub(E,x),x=Q.add(E,x),x=Q.mul(T,x),T=Q.mul(S,T),N=Q.mul(A,N),w=Q.mul(M,w),S=Q.sub(I,w),S=Q.mul(M,S),S=Q.add(S,N),N=Q.add(I,I),I=Q.add(N,I),I=Q.add(I,w),I=Q.mul(I,S),x=Q.add(x,I),w=Q.mul(k,D),w=Q.add(w,w),I=Q.mul(w,S),T=Q.sub(T,I),N=Q.mul(w,E),N=Q.add(N,N),N=Q.add(N,N),new $(T,x,N)}add(M){V(M);const{px:H,py:A,pz:R}=this,{px:k,py:D,pz:T}=M;let{ZERO:x,ZERO:N,ZERO:I}=Q;const E=G.a,w=Q.mul(G.b,K5);let S=Q.mul(H,k),B=Q.mul(A,D),F=Q.mul(R,T),C=Q.add(H,A),L=Q.add(k,D);C=Q.mul(C,L),L=Q.add(S,B),C=Q.sub(C,L),L=Q.add(H,R);let O=Q.add(k,T);return L=Q.mul(L,O),O=Q.add(S,F),L=Q.sub(L,O),O=Q.add(A,R),x=Q.add(D,T),O=Q.mul(O,x),x=Q.add(B,F),O=Q.sub(O,x),I=Q.mul(E,L),x=Q.mul(w,F),I=Q.add(x,I),x=Q.sub(B,I),I=Q.add(B,I),N=Q.mul(x,I),B=Q.add(S,S),B=Q.add(B,S),F=Q.mul(E,F),L=Q.mul(w,L),B=Q.add(B,F),F=Q.sub(S,F),F=Q.mul(E,F),L=Q.add(L,F),S=Q.mul(B,L),N=Q.add(N,S),S=Q.mul(O,L),x=Q.mul(C,x),x=Q.sub(x,S),S=Q.mul(C,B),I=Q.mul(O,I),I=Q.add(I,S),new $(x,N,I)}subtract(M){return this.add(M.negate())}is0(){return this.equals($.ZERO)}wNAF(M){return P.wNAFCached(this,M,$.normalizeZ)}multiplyUnsafe(M){const{endo:H,n:A}=G;N0("scalar",M,v0,A);const R=$.ZERO;if(M===v0)return R;if(this.is0()||M===e)return this;if(!H||P.hasPrecomputes(this))return P.wNAFCachedUnsafe(this,M,$.normalizeZ);let{k1neg:k,k1:D,k2neg:T,k2:x}=H.splitScalar(M),N=R,I=R,E=this;while(D>v0||x>v0){if(D&e)N=N.add(E);if(x&e)I=I.add(E);E=E.double(),D>>=e,x>>=e}if(k)N=N.negate();if(T)I=I.negate();return I=new $(Q.mul(I.px,H.beta),I.py,I.pz),N.add(I)}multiply(M){const{endo:H,n:A}=G;N0("scalar",M,e,A);let R,k;if(H){const{k1neg:D,k1:T,k2neg:x,k2:N}=H.splitScalar(M);let{p:I,f:E}=this.wNAF(T),{p:w,f:S}=this.wNAF(N);I=P.constTimeNegate(D,I),w=P.constTimeNegate(x,w),w=new $(Q.mul(w.px,H.beta),w.py,w.pz),R=I.add(w),k=E.add(S)}else{const{p:D,f:T}=this.wNAF(M);R=D,k=T}return $.normalizeZ([R,k])[0]}multiplyAndAddUnsafe(M,H,A){const R=$.BASE,k=(T,x)=>x===v0||x===e||!T.equals(R)?T.multiplyUnsafe(x):T.multiply(x),D=k(this,H).add(k(M,A));return D.is0()?void 0:D}toAffine(M){return Z(this,M)}isTorsionFree(){const{h:M,isTorsionFree:H}=G;if(M===e)return!0;if(H)return H($,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:M,clearCofactor:H}=G;if(M===e)return this;if(H)return H($,this);return this.multiplyUnsafe(G.h)}toRawBytes(M=!0){return W8("isCompressed",M),this.assertValidity(),W($,this,M)}toHex(M=!0){return W8("isCompressed",M),X8(this.toRawBytes(M))}}$.BASE=new $(G.Gx,G.Gy,Q.ONE),$.ZERO=new $(Q.ZERO,Q.ONE,Q.ZERO);const z=G.nBitLength,P=Y5($,G.endo?Math.ceil(z/2):z);return{CURVE:G,ProjectivePoint:$,normPrivateKeyToScalar:K,weierstrassEquation:Y,isWithinCurveOrder:U}}var oq=function(J){const G=iJ(J);return l0(G,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...G})};function $5(J){const G=oq(J),{Fp:Q,n:q}=G,W=Q.BYTES+1,X=2*Q.BYTES+1;function Y(C){return a(C,q)}function U(C){return v1(C,q)}const{ProjectivePoint:K,normPrivateKeyToScalar:V,weierstrassEquation:Z,isWithinCurveOrder:j}=rq({...G,toBytes(C,L,O){const v=L.toAffine(),g=Q.toBytes(v.x),y=F0;if(W8("isCompressed",O),O)return y(Uint8Array.from([L.hasEvenY()?2:3]),g);else return y(Uint8Array.from([4]),g,Q.toBytes(v.y))},fromBytes(C){const L=C.length,O=C[0],v=C.subarray(1);if(L===W&&(O===2||O===3)){const g=j0(v);if(!p0(g,e,Q.ORDER))throw new Error("Point is not on curve");const y=Z(g);let _;try{_=Q.sqrt(y)}catch(r){const m=r instanceof Error?": "+r.message:"";throw new Error("Point is not on curve"+m)}const c=(_&e)===e;if((O&1)===1!==c)_=Q.neg(_);return{x:g,y:_}}else if(L===X&&O===4){const g=Q.fromBytes(v.subarray(0,Q.BYTES)),y=Q.fromBytes(v.subarray(Q.BYTES,2*Q.BYTES));return{x:g,y}}else{const g=W,y=X;throw new Error("invalid Point, expected length of "+g+", or uncompressed "+y+", got "+L)}}}),$=(C)=>X8(P0(C,G.nByteLength));function z(C){const L=q>>e;return C>L}function P(C){return z(C)?Y(-C):C}const M=(C,L,O)=>j0(C.slice(L,O));class H{constructor(C,L,O){this.r=C,this.s=L,this.recovery=O,this.assertValidity()}static fromCompact(C){const L=G.nByteLength;return C=n("compactSignature",C,L*2),new H(M(C,0,L),M(C,L,2*L))}static fromDER(C){const{r:L,s:O}=S0.toSig(n("DER",C));return new H(L,O)}assertValidity(){N0("r",this.r,e,q),N0("s",this.s,e,q)}addRecoveryBit(C){return new H(this.r,this.s,C)}recoverPublicKey(C){const{r:L,s:O,recovery:v}=this,g=x(n("msgHash",C));if(v==null||![0,1,2,3].includes(v))throw new Error("recovery id invalid");const y=v===2||v===3?L+G.n:L;if(y>=Q.ORDER)throw new Error("recovery id 2 or 3 invalid");const _=(v&1)===0?"02":"03",c=K.fromHex(_+$(y)),f=U(y),r=Y(-g*f),m=Y(O*f),i=K.BASE.multiplyAndAddUnsafe(c,r,m);if(!i)throw new Error("point at infinify");return i.assertValidity(),i}hasHighS(){return z(this.s)}normalizeS(){return this.hasHighS()?new H(this.r,Y(-this.s),this.recovery):this}toDERRawBytes(){return U8(this.toDERHex())}toDERHex(){return S0.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return U8(this.toCompactHex())}toCompactHex(){return $(this.r)+$(this.s)}}const A={isValidPrivateKey(C){try{return V(C),!0}catch(L){return!1}},normPrivateKeyToScalar:V,randomPrivateKey:()=>{const C=uJ(G.n);return G5(G.randomBytes(C),G.n)},precompute(C=8,L=K.BASE){return L._setWindowSize(C),L.multiply(BigInt(3)),L}};function R(C,L=!0){return K.fromPrivateKey(C).toRawBytes(L)}function k(C){const L=c0(C),O=typeof C==="string",v=(L||O)&&C.length;if(L)return v===W||v===X;if(O)return v===2*W||v===2*X;if(C instanceof K)return!0;return!1}function D(C,L,O=!0){if(k(C))throw new Error("first arg must be private key");if(!k(L))throw new Error("second arg must be public key");return K.fromHex(L).multiply(V(C)).toRawBytes(O)}const T=G.bits2int||function(C){if(C.length>8192)throw new Error("input is too large");const L=j0(C),O=C.length*8-G.nBitLength;return O>0?L>>BigInt(O):L},x=G.bits2int_modN||function(C){return Y(T(C))},N=t8(G.nBitLength);function I(C){return N0("num < 2^"+G.nBitLength,C,v0,N),P0(C,G.nByteLength)}function E(C,L,O=w){if(["recovered","canonical"].some((G0)=>(G0 in O)))throw new Error("sign() legacy options not supported");const{hash:v,randomBytes:g}=G;let{lowS:y,prehash:_,extraEntropy:c}=O;if(y==null)y=!0;if(C=n("msgHash",C),V5(O),_)C=n("prehashed msgHash",v(C));const f=x(C),r=V(L),m=[I(r),I(f)];if(c!=null&&c!==!1){const G0=c===!0?g(Q.BYTES):c;m.push(n("extraEntropy",G0))}const i=F0(...m),u=f;function l(G0){const o=T(G0);if(!j(o))return;const Y0=U(o),U0=K.BASE.multiply(o).toAffine(),J0=Y(U0.x);if(J0===v0)return;const r0=Y(Y0*Y(u+J0*r));if(r0===v0)return;let k0=(U0.x===J0?0:2)|Number(U0.y&e),MQ=r0;if(y&&z(r0))MQ=P(r0),k0^=1;return new H(J0,MQ,k0)}return{seed:i,k2sig:l}}const w={lowS:G.lowS,prehash:!1},S={lowS:G.lowS,prehash:!1};function B(C,L,O=w){const{seed:v,k2sig:g}=E(C,L,O),y=G;return fJ(y.hash.outputLen,y.nByteLength,y.hmac)(v,g)}K.BASE._setWindowSize(8);function F(C,L,O,v=S){const g=C;L=n("msgHash",L),O=n("publicKey",O);const{lowS:y,prehash:_,format:c}=v;if(V5(v),("strict"in v))throw new Error("options.strict was renamed to lowS");if(c!==void 0&&c!=="compact"&&c!=="der")throw new Error("format must be compact or der");const f=typeof g==="string"||c0(g),r=!f&&!c&&typeof g==="object"&&g!==null&&typeof g.r==="bigint"&&typeof g.s==="bigint";if(!f&&!r)throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");let m=void 0,i;try{if(r)m=new H(g.r,g.s);if(f){try{if(c!=="compact")m=H.fromDER(g)}catch(k0){if(!(k0 instanceof S0.Err))throw k0}if(!m&&c!=="der")m=H.fromCompact(g)}i=K.fromHex(O)}catch(k0){return!1}if(!m)return!1;if(y&&m.hasHighS())return!1;if(_)L=G.hash(L);const{r:u,s:l}=m,G0=x(L),o=U(l),Y0=Y(G0*o),U0=Y(u*o),J0=K.BASE.multiplyAndAddUnsafe(i,Y0,U0)?.toAffine();if(!J0)return!1;return Y(J0.x)===u}return{CURVE:G,getPublicKey:R,getSharedSecret:D,sign:B,verify:F,ProjectivePoint:K,Signature:H,utils:A}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */var{bytesToNumberBE:dq,hexToBytes:iq}=bJ;class Z5 extends Error{constructor(J=""){super(J)}}var S0={Err:Z5,_tlv:{encode:(J,G)=>{const{Err:Q}=S0;if(J<0||J>256)throw new Q("tlv.encode: wrong tag");if(G.length&1)throw new Q("tlv.encode: unpadded data");const q=G.length/2,W=Y8(q);if(W.length/2&128)throw new Q("tlv.encode: long form length too big");const X=q>127?Y8(W.length/2|128):"";return Y8(J)+X+W+G},decode(J,G){const{Err:Q}=S0;let q=0;if(J<0||J>256)throw new Q("tlv.encode: wrong tag");if(G.length<2||G[q++]!==J)throw new Q("tlv.decode: wrong tlv");const W=G[q++],X=!!(W&128);let Y=0;if(!X)Y=W;else{const K=W&127;if(!K)throw new Q("tlv.decode(long): indefinite length not supported");if(K>4)throw new Q("tlv.decode(long): byte length is too big");const V=G.subarray(q,q+K);if(V.length!==K)throw new Q("tlv.decode: length bytes not complete");if(V[0]===0)throw new Q("tlv.decode(long): zero leftmost byte");for(let Z of V)Y=Y<<8|Z;if(q+=K,Y<128)throw new Q("tlv.decode(long): not minimal encoding")}const U=G.subarray(q,q+Y);if(U.length!==Y)throw new Q("tlv.decode: wrong value length");return{v:U,l:G.subarray(q+Y)}}},_int:{encode(J){const{Err:G}=S0;if(J<v0)throw new G("integer: negative integers are not allowed");let Q=Y8(J);if(Number.parseInt(Q[0],16)&8)Q="00"+Q;if(Q.length&1)throw new G("unexpected DER parsing assertion: unpadded hex");return Q},decode(J){const{Err:G}=S0;if(J[0]&128)throw new G("invalid signature integer: negative");if(J[0]===0&&!(J[1]&128))throw new G("invalid signature integer: unnecessary leading zero");return dq(J)}},toSig(J){const{Err:G,_int:Q,_tlv:q}=S0,W=typeof J==="string"?iq(J):J;k8(W);const{v:X,l:Y}=q.decode(48,W);if(Y.length)throw new G("invalid signature: left bytes after parsing");const{v:U,l:K}=q.decode(2,X),{v:V,l:Z}=q.decode(2,K);if(Z.length)throw new G("invalid signature: left bytes after parsing");return{r:Q.decode(U),s:Q.decode(V)}},hexFromSig(J){const{_tlv:G,_int:Q}=S0,q=G.encode(2,Q.encode(J.r)),W=G.encode(2,Q.encode(J.s)),X=q+W;return G.encode(48,X)}},v0=BigInt(0),e=BigInt(1),SX=BigInt(2),K5=BigInt(3),vX=BigInt(4);function nq(J){return{hash:J,hmac:(G,...Q)=>SJ(J,G,i9(...Q)),randomBytes:k1}}function z5(J,G){const Q=(q)=>$5({...J,...nq(q)});return{...Q(G),create:Q}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */var H5=function(J){const G=Q1,Q=BigInt(3),q=BigInt(6),W=BigInt(11),X=BigInt(22),Y=BigInt(23),U=BigInt(44),K=BigInt(88),V=J*J*J%G,Z=V*V*J%G,j=Z0(Z,Q,G)*Z%G,$=Z0(j,Q,G)*Z%G,z=Z0($,f1,G)*V%G,P=Z0(z,W,G)*z%G,M=Z0(P,X,G)*P%G,H=Z0(M,U,G)*M%G,A=Z0(H,K,G)*H%G,R=Z0(A,U,G)*M%G,k=Z0(R,Q,G)*Z%G,D=Z0(k,Y,G)*P%G,T=Z0(D,q,G)*V%G,x=Z0(T,f1,G);if(!oJ.eql(oJ.sqr(x),J))throw new Error("Cannot find square root");return x},b1=function(J,...G){let Q=M5[J];if(Q===void 0){const q=I1(Uint8Array.from(J,(W)=>W.charCodeAt(0)));Q=F0(q,q),M5[J]=Q}return I1(F0(Q,...G))},aJ=function(J){let G=sJ.utils.normPrivateKeyToScalar(J),Q=eJ.fromPrivateKey(G);return{scalar:Q.hasEvenY()?G:J1(-G),bytes:tJ(Q)}},C5=function(J){N0("x",J,e8,Q1);const G=rJ(J*J),Q=rJ(G*J+BigInt(7));let q=H5(Q);if(q%f1!==P5)q=rJ(-q);const W=new eJ(J,q,e8);return W.assertValidity(),W},D5=function(...J){return J1(I8(b1("BIP0340/challenge",...J)))},sq=function(J){return aJ(J).bytes},tq=function(J,G,Q=k1(32)){const q=n("message",J),{bytes:W,scalar:X}=aJ(G),Y=n("auxRand",Q,32),U=nJ(X^I8(b1("BIP0340/aux",Y))),K=b1("BIP0340/nonce",U,W,q),V=J1(I8(K));if(V===P5)throw new Error("sign failed: k is zero");const{bytes:Z,scalar:j}=aJ(V),$=D5(Z,W,q),z=new Uint8Array(64);if(z.set(Z,0),z.set(nJ(J1(j+$*X)),32),!O5(z,q,W))throw new Error("sign: Invalid signature produced");return z},O5=function(J,G,Q){const q=n("signature",J,64),W=n("message",G),X=n("publicKey",Q,32);try{const Y=C5(I8(X)),U=I8(q.subarray(0,32));if(!p0(U,e8,Q1))return!1;const K=I8(q.subarray(32,64));if(!p0(K,e8,y1))return!1;const V=D5(nJ(U),tJ(Y),W),Z=aq(Y,K,J1(-V));if(!Z||!Z.hasEvenY()||Z.toAffine().x!==U)return!1;return!0}catch(Y){return!1}};/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */var Q1=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),y1=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),e8=BigInt(1),f1=BigInt(2),j5=(J,G)=>(J+G/f1)/G,oJ=g1(Q1,void 0,void 0,{sqrt:H5}),sJ=z5({a:BigInt(0),b:BigInt(7),Fp:oJ,n:y1,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:(J)=>{const G=y1,Q=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),q=-e8*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),W=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),X=Q,Y=BigInt("0x100000000000000000000000000000000"),U=j5(X*J,G),K=j5(-q*J,G);let V=a(J-U*Q-K*W,G),Z=a(-U*q-K*X,G);const j=V>Y,$=Z>Y;if(j)V=G-V;if($)Z=G-Z;if(V>Y||Z>Y)throw new Error("splitScalar: Endomorphism failed, k="+J);return{k1neg:j,k1:V,k2neg:$,k2:Z}}}},I1),P5=BigInt(0),M5={},tJ=(J)=>J.toRawBytes(!0).slice(1),nJ=(J)=>P0(J,32),rJ=(J)=>a(J,Q1),J1=(J)=>a(J,y1),eJ=sJ.ProjectivePoint,aq=(J,G,Q)=>eJ.BASE.multiplyAndAddUnsafe(J,G,Q),I8=j0,h1=(()=>({getPublicKey:sq,sign:tq,verify:O5,utils:{randomPrivateKey:sJ.utils.randomPrivateKey,lift_x:C5,pointToBytes:tJ,numberToBytesBE:P0,bytesToNumberBE:j0,taggedHash:b1,mod:a}}))();var{floor:JQ,random:eq,sin:JW}=Math,K8="Trystero",d0=(J,G)=>Array(J).fill().map(G);var _1=(J)=>d0(J,()=>"0123456789AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz"[JQ(eq()*"0123456789AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz".length)]).join(""),A0=_1(20),i0=Promise.all.bind(Promise),B5=typeof window!=="undefined",{entries:u1,fromEntries:QQ,keys:L5}=Object,g0=()=>{},C0=(J)=>new Error(`Trystero: ${J}`),QW=new TextEncoder,GW=new TextDecoder,R0=(J)=>QW.encode(J),w8=(J)=>GW.decode(J),c1=(J)=>J.reduce((G,Q)=>G+Q.toString(16).padStart(2,"0"),""),G1=(...J)=>J.join("@"),qW=(J,G)=>{const Q=[...J],q=()=>{const X=JW(G++)*1e4;return X-JQ(X)};let W=Q.length;while(W){const X=JQ(q()*W--);[Q[W],Q[X]]=[Q[X],Q[W]]}return Q},N5=(J,G,Q,q)=>{return(J.relayUrls||(q?qW(G,GQ(J.appId)):G)).slice(0,J.relayUrls?J.relayUrls.length:J.relayRedundancy||Q)},M0=JSON.stringify,Z8=JSON.parse,GQ=(J,G=Number.MAX_SAFE_INTEGER)=>J.split("").reduce((Q,q)=>Q+q.charCodeAt(0),0)%G;var m1={},A5=(J,G)=>{const Q={},q=()=>{const W=new WebSocket(J);W.onclose=()=>{m1[J]??=3333,setTimeout(q,m1[J]),m1[J]*=2},W.onmessage=(X)=>G(X.data),Q.socket=W,Q.url=W.url,Q.ready=new Promise((X)=>W.onopen=()=>{X(Q),m1[J]=3333}),Q.send=(X)=>{if(W.readyState===1)W.send(X)}};return q(),Q},R5=(J)=>()=>QQ(u1(J).map(([G,Q])=>[G,Q.socket]));var qQ="AES-GCM",k5={},WW=(J)=>btoa(String.fromCharCode.apply(null,new Uint8Array(J))),XW=(J)=>{const G=atob(J);return new Uint8Array(G.length).map((Q,q)=>G.charCodeAt(q)).buffer},q1=async(J)=>k5[J]||(k5[J]=Array.from(new Uint8Array(await crypto.subtle.digest("SHA-1",R0(J)))).map((G)=>G.toString(36)).join("")),I5=async(J,G,Q)=>crypto.subtle.importKey("raw",await crypto.subtle.digest({name:"SHA-256"},R0(`${J}:${G}:${Q}`)),{name:qQ},!1,["encrypt","decrypt"]),w5="$",x5=",",T5=async(J,G)=>{const Q=crypto.getRandomValues(new Uint8Array(16));return Q.join(x5)+w5+WW(await crypto.subtle.encrypt({name:qQ,iv:Q},await J,R0(G)))},F5=async(J,G)=>{const[Q,q]=G.split(w5);return w8(await crypto.subtle.decrypt({name:qQ,iv:new Uint8Array(Q.split(x5))},await J,XW(q)))};var YW=5000,S5="icegatheringstatechange",WQ=(J)=>J.replace(/a=ice-options:trickle\s\n/g,""),XQ=(J,{rtcConfig:G,rtcPolyfill:Q,turnConfig:q})=>{const W=new(Q||RTCPeerConnection)({iceServers:UW.concat(q||[]),...G}),X={},Y=(j)=>{j.binaryType="arraybuffer",j.bufferedAmountLowThreshold=65535,j.onmessage=($)=>X.data?.($.data),j.onopen=()=>X.connect?.(),j.onclose=()=>X.close?.(),j.onerror=($)=>X.error?.($)},U=async(j)=>{if(!j.localDescription)throw new Error("No local description available");return await Promise.race([new Promise(($)=>{const z=()=>{if(j.iceGatheringState==="complete")j.removeEventListener(S5,z),$()};j.addEventListener(S5,z),z()}),new Promise(($)=>setTimeout($,YW))]),{type:j.localDescription.type,sdp:WQ(j.localDescription.sdp)}};let K=!1,V=null,Z=!1;if(J)V=W.createDataChannel("data"),Y(V);else W.ondatachannel=({channel:j})=>{V=j,Y(j)};return W.onnegotiationneeded=async()=>{try{K=!0,await W.setLocalDescription();const j=await U(W);X.signal?.({type:j.type,sdp:WQ(j.sdp)})}catch(j){X.error?.(j)}finally{K=!1}},W.onconnectionstatechange=()=>{if(["disconnected","failed","closed"].includes(W.connectionState))X.close?.()},W.ontrack=(j)=>{X.track?.(j.track,j.streams[0]),X.stream?.(j.streams[0])},W.onremovestream=(j)=>{X.stream?.(j.stream,{removed:!0})},{created:Date.now(),connection:W,get channel(){return V},get isDead(){return W.connectionState==="closed"},async signal(j){if(V?.readyState==="open"){if(j.type==="offer"||W.signalingState!=="stable"){if(await W.setRemoteDescription(j),j.type==="offer"){await W.setLocalDescription();const $=await U(W);return X.signal?.({type:$.type,sdp:$.sdp}),{type:$.type,sdp:$.sdp}}}return}try{if(j.type==="offer"){if(K||W.signalingState!=="stable"){if(Z=!J,Z)return}await W.setRemoteDescription(j),await W.setLocalDescription();const $=await U(W),z=WQ($.sdp);return X.signal?.({type:$.type,sdp:z}),{type:$.type,sdp:z}}else if(j.type==="answer"&&(W.signalingState==="have-local-offer"||W.signalingState==="have-remote-offer"))await W.setRemoteDescription(j)}catch($){X.error?.($)}},sendData:(j)=>V.send(j),destroy:()=>{if(V)V.close();W.close()},setHandlers:(j)=>Object.assign(X,j),offerPromise:J?new Promise((j)=>{const $=(z)=>{if(z.type==="offer")j(z)};X.signal=$}):Promise.resolve(),addStream:(j)=>{j.getTracks().forEach(($)=>W.addTrack($,j))},removeStream:(j)=>{W.getSenders().filter(($)=>j.getTracks().includes($.track)).forEach(($)=>W.removeTrack($))},addTrack:(j,$)=>W.addTrack(j,$),removeTrack:(j)=>{const $=W.getSenders().find((z)=>z.track===j);if($)W.removeTrack($)},replaceTrack:async(j,$)=>{const z=W.getSenders().find((P)=>P.track===j);if(z)await z.replaceTrack($)}}},UW=[...d0(3,(J,G)=>`stun:stun${G||""}.l.google.com:19302`),"stun:global.stun.twilio.com:3478"].map((J)=>({urls:J}));var VW=Object.getPrototypeOf(Uint8Array),l1=12,g5=0,d1=g5+l1,i1=d1+1,W1=i1+1,X1=W1+1,$8=16384-X1,p1=255,v5="bufferedamountlow",x8=(J)=>"@_"+J,E5=(J,G,Q)=>{const q={},W={},X={},Y={},U={},K={},V={},Z={onPeerJoin:g0,onPeerLeave:g0,onPeerStream:g0,onPeerTrack:g0},j=(B,F)=>(B?Array.isArray(B)?B:[B]:L5(q)).flatMap((C)=>{const L=q[C];if(!L)return console.warn(`${K8}: no peer with id ${C} found`),[];return F(C,L)}),$=(B)=>{if(!q[B])return;delete q[B],delete Y[B],delete U[B],Z.onPeerLeave(B),G(B)},z=(B)=>{if(W[B])return X[B];if(!B)throw C0("action type argument is required");const F=R0(B);if(F.byteLength>l1)throw C0(`action type string "${B}" (${F.byteLength}b) exceeds `+`byte limit (${l1}). Hint: choose a shorter name.`);const C=new Uint8Array(l1);C.set(F);let L=0;return W[B]={onComplete:g0,onProgress:g0,setOnComplete:(O)=>W[B]={...W[B],onComplete:O},setOnProgress:(O)=>W[B]={...W[B],onProgress:O},send:async(O,v,g,y)=>{if(g&&typeof g!=="object")throw C0("action meta argument must be an object");const _=typeof O;if(_==="undefined")throw C0("action data cannot be undefined");const c=_!=="string",f=O instanceof Blob,r=f||O instanceof ArrayBuffer||O instanceof VW;if(g&&!r)throw C0("action meta argument can only be used with binary data");const m=r?new Uint8Array(f?await O.arrayBuffer():O):R0(c?M0(O):O),i=g?R0(M0(g)):null,u=Math.ceil(m.byteLength/$8)+(g?1:0)||1,l=d0(u,(G0,o)=>{const Y0=o===u-1,U0=g&&o===0,J0=new Uint8Array(X1+(U0?i.byteLength:Y0?m.byteLength-$8*(u-(g?2:1)):$8));return J0.set(C),J0.set([L],d1),J0.set([Y0|U0<<1|r<<2|c<<3],i1),J0.set([Math.round((o+1)/u*p1)],W1),J0.set(g?U0?i:m.subarray((o-1)*$8,o*$8):m.subarray(o*$8,(o+1)*$8),X1),J0});return L=L+1&p1,i0(j(v,async(G0,o)=>{const{channel:Y0}=o;let U0=0;while(U0<u){const J0=l[U0];if(Y0.bufferedAmount>Y0.bufferedAmountLowThreshold)await new Promise((r0)=>{const k0=()=>{Y0.removeEventListener(v5,k0),r0()};Y0.addEventListener(v5,k0)});if(!q[G0])break;o.sendData(J0),U0++,y?.(J0[W1]/p1,G0,g)}}))}},X[B]||=[W[B].send,W[B].setOnComplete,W[B].setOnProgress]},P=(B,F)=>{const C=new Uint8Array(F),L=w8(C.subarray(g5,d1)).replaceAll("\0",""),[O]=C.subarray(d1,i1),[v]=C.subarray(i1,W1),[g]=C.subarray(W1,X1),y=C.subarray(X1),_=!!(v&1),c=!!(v&1<<1),f=!!(v&1<<2),r=!!(v&1<<3);if(!W[L]){console.warn(`${K8}: received message with unregistered type (${L})`);return}Y[B]||={},Y[B][L]||={};const m=Y[B][L][O]||={chunks:[]};if(c)m.meta=Z8(w8(y));else m.chunks.push(y);if(W[L].onProgress(g/p1,B,m.meta),!_)return;const i=new Uint8Array(m.chunks.reduce((u,l)=>u+l.byteLength,0));if(m.chunks.reduce((u,l)=>{return i.set(l,u),u+l.byteLength},0),delete Y[B][L][O],f)W[L].onComplete(i,B,m.meta);else{const u=w8(i);W[L].onComplete(r?Z8(u):u,B)}},M=async()=>{await w(""),await new Promise((B)=>setTimeout(B,99)),u1(q).forEach(([B,F])=>{F.destroy(),delete q[B]}),Q()},[H,A]=z(x8("ping")),[R,k]=z(x8("pong")),[D,T]=z(x8("signal")),[x,N]=z(x8("stream")),[I,E]=z(x8("track")),[w,S]=z(x8("leave"));if(J((B,F)=>{if(q[F])return;q[F]=B,B.setHandlers({data:(C)=>P(F,C),stream:(C)=>{Z.onPeerStream(C,F,K[F]),delete K[F]},track:(C,L)=>{Z.onPeerTrack(C,L,F,V[F]),delete V[F]},signal:(C)=>D(C,F),close:()=>$(F),error:()=>$(F)}),Z.onPeerJoin(F),B.drainEarlyData?.((C)=>P(F,C))}),A((B,F)=>R("",F)),k((B,F)=>{U[F]?.(),delete U[F]}),T((B,F)=>q[F]?.signal(B)),N((B,F)=>K[F]=B),E((B,F)=>V[F]=B),S((B,F)=>$(F)),B5)addEventListener("beforeunload",M);return{makeAction:z,leave:M,ping:async(B)=>{if(!B)throw C0("ping() must be called with target peer ID");const F=Date.now();return H("",B),await new Promise((C)=>U[B]=C),Date.now()-F},getPeers:()=>QQ(u1(q).map(([B,F])=>[B,F.connection])),addStream:(B,F,C)=>j(F,async(L,O)=>{if(C)await x(C,L);O.addStream(B)}),removeStream:(B,F)=>j(F,(C,L)=>L.removeStream(B)),addTrack:(B,F,C,L)=>j(C,async(O,v)=>{if(L)await I(L,O);v.addTrack(B,F)}),removeTrack:(B,F,C)=>j(C,(L,O)=>O.removeTrack(B,F)),replaceTrack:(B,F,C,L,O)=>j(L,async(v,g)=>{if(O)await I(O,v);g.replaceTrack(B,F,C)}),onPeerJoin:(B)=>Z.onPeerJoin=B,onPeerLeave:(B)=>Z.onPeerLeave=B,onPeerStream:(B)=>Z.onPeerStream=B,onPeerTrack:(B)=>Z.onPeerTrack=B}};var KW=20,ZW=5333,y5=57333,f5=({init:J,subscribe:G,announce:Q})=>{const q={};let W=!1,X,Y,U;return(K,V,Z)=>{const{appId:j}=K;if(q[j]?.[V])return q[j][V];const $={},z={},P=G1(K8,j,V),M=q1(P),H=q1(G1(P,A0)),A=I5(K.password||"",j,V),R=(O)=>async(v)=>({type:v.type,sdp:await O(A,v.sdp)}),k=R(F5),D=R(T5),T=()=>XQ(!0,K),x=(O,v,g)=>{if(z[v]){if(z[v]!==O)O.destroy();return}z[v]=O,L(O,v),$[v]?.forEach((y,_)=>{if(_!==g)y.destroy()}),delete $[v]},N=(O,v)=>{if(z[v]===O)delete z[v]},I=(O,v)=>{if(z[O])return;const g=$[O]?.[v];if(g)delete $[O][v],g.destroy()},E=(O)=>{return Y.push(...d0(O,T)),i0(Y.splice(0,O).map((v)=>v.offerPromise.then(D).then((g)=>({peer:v,offer:g}))))},w=(O,v)=>Z?.({error:`incorrect password (${K.password}) when decrypting ${v}`,appId:j,peerId:O,roomId:V}),S=(O)=>async(v,g,y)=>{const[_,c]=await i0([M,H]);if(v!==_&&v!==c)return;const{peerId:f,offer:r,answer:m,peer:i}=typeof g==="string"?Z8(g):g;if(f===A0||z[f])return;if(f&&!r&&!m){if($[f]?.[O])return;const[[{peer:u,offer:l}],G0]=await i0([E(1),q1(G1(P,f))]);$[f]||=[],$[f][O]=u,setTimeout(()=>I(f,O),B[O]*0.9),u.setHandlers({connect:()=>x(u,f,O),close:()=>N(u,f)}),y(G0,M0({peerId:A0,offer:l}))}else if(r){if($[f]?.[O]&&A0>f)return;const l=XQ(!1,K);l.setHandlers({connect:()=>x(l,f,O),close:()=>N(l,f)});let G0;try{G0=await k(r)}catch{w(f,"offer");return}if(l.isDead)return;const[o,Y0]=await i0([q1(G1(P,f)),l.signal(G0)]);y(o,M0({peerId:A0,answer:await D(Y0)}))}else if(m){let u;try{u=await k(m)}catch(l){w(f,"answer");return}if(i)i.setHandlers({connect:()=>x(i,f,O),close:()=>N(i,f)}),i.signal(u);else{const l=$[f]?.[O];if(l&&!l.isDead)l.signal(u)}}};if(!K)throw C0("requires a config map as the first argument");if(!j&&!K.firebaseApp)throw C0("config map is missing appId field");if(!V)throw C0("roomId argument required");if(!W){const O=J(K);Y=d0(KW,T),X=Array.isArray(O)?O:[O],W=!0,U=setInterval(()=>Y=Y.filter((v)=>{const g=Date.now()-v.created<y5;if(!g)v.destroy();return g}),y5*1.03)}const B=X.map(()=>ZW),F=[],C=X.map(async(O,v)=>G(await O,await M,await H,S(v),E));i0([M,H]).then(([O,v])=>{const g=async(y,_)=>{const c=await Q(y,O,v);if(typeof c==="number")B[_]=c;F[_]=setTimeout(()=>g(y,_),B[_])};C.forEach(async(y,_)=>{await y,g(await X[_],_)})});let L=g0;return q[j]||={},q[j][V]=E5((O)=>L=O,(O)=>delete z[O],()=>{delete q[j][V],F.forEach(clearTimeout),C.forEach(async(O)=>(await O)()),clearInterval(U)})}};var _5={},$W=5,u5="x",c5="EVENT",p5=h1.utils.randomPrivateKey(),zW=c1(h1.getPublicKey(p5)),YQ={},Y1={},jW={},l5=()=>Math.floor(Date.now()/1000),d5=(J)=>jW[J]??=GQ(J,1e4)+20000,b5=async(J,G)=>{const Q={kind:d5(J),content:G,pubkey:zW,created_at:l5(),tags:[[u5,J]]},q=c1(new Uint8Array(await crypto.subtle.digest("SHA-256",R0(M0([0,Q.pubkey,Q.created_at,Q.kind,Q.tags,Q.content])))));return M0([c5,{...Q,id:q,sig:c1(await h1.sign(q,p5))}])},h5=(J,G)=>{return YQ[J]=G,M0(["REQ",J,{kinds:[d5(G)],since:l5(),["#"+u5]:[G]}])},m5=(J)=>{return delete YQ[J],M0(["CLOSE",J])},UQ=f5({init:(J)=>N5(J,HW,$W,!0).map((G)=>{const Q=A5(G,(q)=>{const[W,X,Y,U]=Z8(q);if(W!==c5){const K=`${K8}: relay failure from ${Q.url} - `;if(W==="NOTICE")console.warn(K+X);else if(W==="OK"&&!Y)console.warn(K+U);return}Y1[X]?.(YQ[X],Y.content)});return _5[G]=Q,Q.ready}),subscribe:(J,G,Q,q)=>{const W=_1(64),X=_1(64);return Y1[W]=Y1[X]=(Y,U)=>q(Y,U,async(K,V)=>J.send(await b5(K,V))),J.send(h5(W,G)),J.send(h5(X,Q)),()=>{J.send(m5(W)),J.send(m5(X)),delete Y1[W],delete Y1[X]}},announce:async(J,G)=>J.send(await b5(G,M0({peerId:A0})))}),MW=R5(_5),HW=["eu.purplerelay.com","ftp.halifax.rwth-aachen.de/nostr","longhorn.bgp.rodeo","multiplexer.huszonegy.world","nfdb.noswhere.com","nostr-verified.wellorder.net","nostr.cool110.xyz","nostr.data.haus","nostr.grooveix.com","nostr.huszonegy.world","nostr.mom","nostr.openhoofd.nl","nostr.petrkr.net/strfry","nostr.sathoarder.com","nostr.stakey.net","nostr.vulpem.com","nostr2.sanhauf.com","nostrelay.circum.space","relay.fountain.fm","relay.nostraddress.com","relay.nostromo.social","relay.snort.social","relay.verified-nostr.com","strfry.openhoofd.nl","yabu.me/v2"].map((J)=>"wss://"+J);var i5=(J,G,Q)=>{if(!J||!J.timestamp)return{resolved:!0,value:G.value,timestamp:G.timestamp};const q=G.timestamp,W=J.timestamp;if(Q.compare(W,q)<0)return{resolved:!0,value:G.value,timestamp:G.timestamp};return{resolved:!1}};var PW=()=>{const J=new Map,G=async()=>{try{const K=await navigator.storage.getDirectory(),Z=await(await K.getFileHandle("~",{create:!0})).createSyncAccessHandle?.();return await Z?.close(),await K.removeEntry("~"),!!Z}catch{return!1}};let Q="idb";const q=(async()=>{if(await G())Q="sync";else try{const K=await navigator.storage.getDirectory();await(await(await K.getFileHandle("~",{create:!0})).createWritable?.())?.close(),await K.removeEntry("~"),Q="async"}catch{Q="idb"}})(),W=async(K,V)=>{if(!J.has(K))J.set(K,[]);const Z=J.get(K),j=Z[Z.length-1]||Promise.resolve();let $;const z=new Promise((P)=>$=P);Z.push(z);try{return await j,await V()}finally{if(Z.shift(),$(),Z.length===0)J.delete(K)}},X=(()=>{let K;return{getDB:async()=>{if(!K)K=new Promise((V,Z)=>{const j=indexedDB.open("opfs-fallback",1);j.onupgradeneeded=()=>j.result.createObjectStore("files"),j.onsuccess=()=>V(j.result),j.onerror=()=>Z(j.error)});return K},get:async(V)=>{const Z=await X.getDB();return new Promise((j,$)=>{const P=Z.transaction("files","readonly").objectStore("files").get(V);P.onsuccess=()=>j(P.result||new Uint8Array),P.onerror=()=>$(P.error)})},set:async(V,Z)=>{const j=await X.getDB();return new Promise(($,z)=>{const M=j.transaction("files","readwrite").objectStore("files").put(Z,V);M.onsuccess=()=>$(),M.onerror=()=>z(M.error)})}}})(),Y=async(K)=>{await q;try{if(Q==="idb"){const z=await X.get(K);return{type:"loaded",name:K,data:z}}const Z=await(await navigator.storage.getDirectory()).getFileHandle(K);if(Q==="sync"){const z=await Z.createSyncAccessHandle(),P=z.getSize(),M=new Uint8Array(P),H=z.read(M,{at:0});return z.close(),{type:"loaded",name:K,data:M.slice(0,H)}}const j=await Z.getFile(),$=new Uint8Array(await j.arrayBuffer());return{type:"loaded",name:K,data:$}}catch(V){return{type:"error",name:K,message:V.message||"Error al leer"}}},U=async(K,V)=>{if(await q,!(V instanceof Uint8Array))return{type:"error",name:K,message:"El contenido debe ser Uint8Array"};return W(K,async()=>{try{if(Q==="idb")return await X.set(K,V),{type:"saved",name:K};const j=await(await navigator.storage.getDirectory()).getFileHandle(K,{create:!0});if(Q==="sync"){const $=await j.createSyncAccessHandle();$.truncate(0),$.write(V,{at:0}),$.flush(),$.close()}else{const $=await j.createWritable();await $.write(V),await $.close()}return{type:"saved",name:K}}catch(Z){return{type:"error",name:K,message:Z.message||"Error al guardar"}}})};self.onmessage=async({data:{type:K,name:V,content:Z}})=>{await q;const j={load:()=>Y(V),save:()=>U(V,Z)};try{const $=j[K]?await j[K]():{type:"error",message:"Acci\xF3n no reconocida"};self.postMessage($)}catch($){self.postMessage({type:"error",message:$.message||"Error inesperado"})}}},r5=PW;var z8={$eq:(J,G)=>J===G,$ne:(J,G)=>J!==G,$gt:(J,G)=>J>G,$gte:(J,G)=>J>=G,$lt:(J,G)=>J<G,$lte:(J,G)=>J<=G,$in:(J,G)=>Array.isArray(G)&&G.includes(J),$between:(J,[G,Q])=>J>=G&&J<=Q,$exists:(J,G)=>G?J!==void 0:J===void 0,$text:{global:(J,G)=>{const Q=(W)=>String(W).normalize("NFD").replace(/[\u0300-\u036f]/g,"").toLowerCase().replace(/[^\w\s]/g,""),q=Q(G);return Object.values(J).some((W)=>{if(typeof W==="object")return null.fieldSearch(W,q);return Q(W).includes(q)})},field:(J,G)=>{const Q=(q)=>String(q).normalize("NFD").replace(/[\u0300-\u036f]/g,"").toLowerCase().replace(/[^\w\s]/g,"");return Array.isArray(J)?J.some((q)=>Q(q).includes(Q(G))):Q(J).includes(Q(G))}},$like:(J,G)=>{if(typeof J!=="string"||typeof G!=="string")return!1;return new RegExp(`^${G.replace(/%/g,".*").replace(/_/g,".")}\$`,"i").test(J)},$regex:(J,G)=>typeof J==="string"&&new RegExp(G.$regex||G,"i").test(J),$and:(J,G,Q)=>G.every((q)=>{return Q.createFilter(q)(J)}),$or:(J,G,Q)=>G.some((q)=>{return Q.createFilter(q)(J)}),$not:(J,G,Q)=>{return!Q.createFilter(G)(J)}},VQ=(J,G)=>{const Q=G.split(".");let q=J;for(let W of Q)if(q&&typeof q==="object"&&(W in q))q=q[W];else return;return q},KQ=(J)=>{const G=(Q)=>{return Object.entries(J).every(([q,W])=>{if(q.startsWith("$"))return z8[q](Q,W,{filterNode:G,createFilter:KQ});const X=VQ(Q.value,q);if(typeof W!=="object"||W===null)return z8.$eq(X,W);return Object.entries(W).every(([Y,U])=>{if(Y==="$text")return z8.$text.field(X,U);if(Y==="$between"&&U.every((K)=>K instanceof Date)){const K=new Date(X);return z8.$between(K,U)}return z8[Y]?.(X,U,{filterNode:G,createFilter:KQ})??!1})})};return G},ZQ=(J,G)=>{const Q=KQ(G.query);let q=Object.values(J).filter(Q);if(G.field)q.sort((W,X)=>{const Y=VQ(W.value,G.field),U=VQ(X.value,G.field),K=G.order==="asc"?1:-1;if(typeof Y==="string"&&typeof U==="string")return Y.localeCompare(U)*K;return((Y??0)-(U??0))*K});if(G.$after){const W=q.findIndex((X)=>X.id===G.$after);q=W>=0?q.slice(W+1):[]}if(G.$before){const W=q.findIndex((X)=>X.id===G.$before);q=W>=0?q.slice(0,W):[]}return G.$limit?q.slice(0,G.$limit):q};class $Q{constructor(){this.physical=Date.now(),this.logical=0}now(){const J=Date.now();return this.physical=Math.max(this.physical,J),this.logical++,{physical:this.physical,logical:this.logical}}update(J){this.physical=Math.max(this.physical,J.physical),this.logical=Math.max(this.logical,J.logical)+1}compare(J,G){if(J.logical>G.logical)return 1;else if(J.logical<G.logical)return-1;else return J.physical-G.physical}}var o5=function(J,G){return J.length===G.length&&J.every((Q,q)=>Q===G[q])};async function CW(){console.log("\u26A1 GDB-P2P: Empowering distributed graph databases with real-time synchronization and scalability. Learn more: https://github.com/estebanrfp/gdb \u26A1"),console.log(navigator?.storage?.getDirectory?"OPFS is enabled.":"OPFS is not available."),navigator?.storage?.getDirectory&&await navigator.storage.getDirectory()}if(Symbol.dispose===void 0)Object.defineProperty(Symbol,"dispose",{value:Symbol.for("Symbol.dispose")});class n5{constructor(){this.nodes={}}insert(J,G,Q){this.nodes[J]={id:J,value:G,edges:[],timestamp:Q}}get(J){return this.nodes[J]||null}link(J,G){const Q=this.nodes[J],q=this.nodes[G];if(Q&&q&&!Q.edges.includes(G))Q.edges.push(G)}getAllNodes(){return Object.values(this.nodes)}serialize(){return xJ.deflate(E0(this.nodes))}deserialize(J){this.nodes=s1(xJ.inflate(new Uint8Array(J)))}}class zQ{constructor(J,{password:G}={}){this.hybridClock=new $Q;const Q=localStorage.getItem(`${this.name}_time`);this.globalTimestamp=Q?JSON.parse(Q):null,this.changeList=[],this.name=J,this.password=G,this.graph=new n5,this.eventListeners=[],this.operators=z8,this.initWorker(),this.ready=this.loadGraphFromOPFS();const q=`graph-sync-room-${this.name}`,W={appId:"1234",...this.password&&{password:this.password}},X=UQ(W,q);this.room=X;const[Y,U]=X.makeAction("syncGraph");this.sendData=Y,window.addEventListener("online",async()=>{console.log("\u2705 Reconnected to the network.");const K=localStorage.getItem(`${this.name}_time`);this.globalTimestamp=K?JSON.parse(K):null,this.sendData([{type:"sync",timestamp:this.globalTimestamp}])}),window.addEventListener("offline",async()=>{console.log("\u274C Disconnected from the network.")}),document.addEventListener("visibilitychange",()=>{if(document.visibilityState==="visible"){console.log("The tab is visible again.");const K=localStorage.getItem(`${this.name}_time`);this.globalTimestamp=K?JSON.parse(K):null,this.sendData([{type:"sync",timestamp:this.globalTimestamp}])}else if(document.visibilityState==="hidden")console.log("The tab is no longer visible.")}),CW(),X.onPeerJoin(async(K)=>{console.log("\u26A1 New pair connected:",K);const V=localStorage.getItem(`${this.name}_time`);this.globalTimestamp=V?JSON.parse(V):null,this.sendData([{type:"sync",timestamp:this.globalTimestamp}])}),X.onPeerLeave((K)=>{console.log("\u26A1 Pair disconnected:",K)}),U((K)=>this.receiveChanges(K)),this.channel=new BroadcastChannel(`graphdb_sync_${this.name}`),this.channel.onmessage=async(K)=>{if(K.data==="update")console.log("\uD83D\uDD04 Update received from another tab..."),await this.loadGraphFromOPFS(),this.emit()}}initWorker(){try{const J=URL.createObjectURL(new Blob([`(${r5.toString()})()`],{type:"application/javascript"}));this.worker=new Worker(J),URL.revokeObjectURL(J),this.worker.addEventListener("message",({data:G})=>console.log("Worker message:",`${G.name} ${G.type}`)),console.log("Worker initialized successfully.")}catch({message:J}){console.error("Failed to initialize worker:",J)}}getWorker(){return this.worker}emit(){const J=this.graph.getAllNodes();this.eventListeners.forEach((G)=>G(J))}on(J){this.eventListeners.push(J)}off(J){if(J)this.eventListeners=this.eventListeners.filter((G)=>G!==J);else this.eventListeners=[]}addChange(J,G,Q){const q={id:J,timestamp:G,operation:Q};this.changeList.push(q)}async getAllNodes(){return await this.ready,this.graph.getAllNodes()}async generateHash(){return crypto.randomUUID()}async hashValue(J){const G=(new TextEncoder()).encode(J),Q=await crypto.subtle.digest("SHA-256",G);return Array.from(new Uint8Array(Q)).map((q)=>q.toString(16).padStart(2,"0")).join("")}async loadGraphFromOPFS(){try{const G=await((Q)=>new Promise((q,W)=>{const X=async({data:Y})=>{if(Y.type==="loaded"&&Y.name===Q)this.worker.removeEventListener("message",X),q(new Uint8Array(Y.data));else if(Y.type==="error")this.worker.removeEventListener("message",X),W(new Error(Y.message||"Unknown error"))};this.worker.addEventListener("message",X),this.worker.postMessage({type:"load",name:Q})}))(`${this.name}_graph.msgpack`).catch(()=>new Uint8Array);G.byteLength>0?this.graph.deserialize(G):console.warn("The file '_graph.msgpack' is empty or could not be loaded."),console.log(`Graph loaded from OPFS: [ ${this.graph.getAllNodes().length} nodes ]`)}catch({message:J}){console.error("General error loading the graph from OPFS:",J)}}async saveGraphToOPFS(){try{const J=this.graph.serialize();return await((Q,q)=>new Promise((W,X)=>{const Y=({data:U})=>{if(U.type==="saved"&&U.name===Q)this.worker.removeEventListener("message",Y),W();else if(U.type==="error")this.worker.removeEventListener("message",Y),X(new Error(U.message||"Save error"))};this.worker.addEventListener("message",Y),this.worker.postMessage({type:"save",name:Q,content:q})}))(`${this.name}_graph.msgpack`,J),this.channel.postMessage("update"),!0}catch({message:J}){throw console.error("Save error:",J),new Error("Save failed")}}async put(J,G){await this.ready;const Q=this.hybridClock.now();return localStorage.setItem(`${this.name}_time`,JSON.stringify(Q)),G??=await this.generateHash(E0(J)),this.graph.insert(G,J,Q),this.addChange(G,Q,"insert"),await this.saveGraphToOPFS(),this.sendData([{type:"insert",id:G,value:J,timestamp:Q}]),this.emit(),G}async get(J,G=null){if(await this.ready,typeof J!=="string")return console.error("Parameter must be a valid ID (string)."),{result:null};const Q=this.graph.get(J);if(!Q)return console.error(`Node with ID '${J}' not found.`),{result:null};if(!G)return{result:Q};G(Q);const q=(W)=>{const X=W.find((Y)=>Y.id===J);if(X&&Q&&X.timestamp){if(this.hybridClock.compare(X.timestamp,Q.timestamp)>0)Q.value=X.value,Q.timestamp=X.timestamp,G(X)}};return this.eventListeners.push(q),{result:Q,...G&&{unsubscribe:()=>this.eventListeners.splice(this.eventListeners.indexOf(q),1)}}}async map(...J){await this.ready;let Q={...{realtime:!1,query:{},field:null,order:"asc",$limit:null,$after:null,$before:null}},q=null,W=!1;J.forEach((K)=>typeof K==="function"?q=K:K&&typeof K==="object"&&(W||=("realtime"in K),Object.assign(Q,K))),q&&!W&&(Q.realtime=!0);let X=ZQ(this.graph.nodes,Q),Y=null;const U=(K)=>{const V=K.filter((z)=>!X.some((P)=>P.id===z.id)),Z=X.filter((z)=>!K.some((P)=>P.id===z.id)),j=K.filter((z)=>{const P=X.find((M)=>M.id===z.id);return P&&!o5(E0(z.value),E0(P.value))}),$=(z,P)=>{const M=P==="removed"?null:z.value,H={id:z.id,value:M,edges:z.edges||[],timestamp:z.timestamp||null,action:P};q(H)};V.forEach((z)=>$(z,"added")),Z.forEach((z)=>$(z,"removed")),j.forEach((z)=>$(z,"updated"))};if(q){if(X.forEach((K)=>{if(K.value)q({id:K.id,value:K.value,edges:K.edges,timestamp:K.timestamp,action:"initial"})}),Q.realtime)Y=(K)=>{const V=ZQ(K,Q);if(!o5(E0(V),E0(X)))U(V),X=V},this.on(Y)}return{results:X,...Q.realtime&&{unsubscribe:()=>Y&&this.off(Y)}}}async remove(J){await this.ready;const G=this.hybridClock.now(),Q=this.graph.get(J);if(!Q)return console.error(`Node with ID '${J}' not found.`);delete this.graph.nodes[J],Object.values(this.graph.nodes).forEach((q)=>q.edges=q.edges.filter((W)=>W!==J)),this.addChange(J,G,"remove"),await this.saveGraphToOPFS(),localStorage.setItem(`${this.name}_time`,JSON.stringify(G)),this.sendData([{type:"remove",id:J,value:Q.value,timestamp:G}]),this.emit()}async clear(){await this.ready,this.graph.nodes={};try{await(await navigator.storage.getDirectory()).removeEntry(`${this.name}_graph.msgpack`)}catch({message:J}){console.warn(`Error deleting _graph.msgpack: ${J}`)}console.log("All data has been deleted.")}async link(J,G){await this.ready;const Q=this.hybridClock.now();if(!this.graph.nodes[J]||!this.graph.nodes[G]){console.error(`One or both nodes (${J}, ${G}) do not exist.`);return}this.graph.link(J,G),this.addChange(J,Q,"update"),await this.saveGraphToOPFS(),localStorage.setItem(`${this.name}_time`,JSON.stringify(Q)),this.sendData([{type:"link",sourceId:J,targetId:G,timestamp:Q}]),this.emit()}async applyFullGraph(J){try{this.graph.nodes={...J.nodes},await this.saveGraphToOPFS(),this.emit()}catch({message:G}){console.error(`Error applying the full graph: ${G}`)}}async receiveChanges(J){const G={insert:(Q)=>this.graph.insert(Q.id,Q.value,Q.timestamp),update:(Q)=>{const q=this.graph.get(Q.id),W=i5(q,Q,this.hybridClock);W.resolved&&Object.assign(q,{value:W.value,timestamp:W.timestamp})},remove:(Q)=>delete this.graph.nodes[Q.id],link:(Q)=>this.graph.link(Q.sourceId,Q.targetId),sync:(Q)=>{if(this.hybridClock.compare(this.globalTimestamp,Q.timestamp)>0)console.log("Sending recent data to the remote node."),this.sendData([{type:"syncReceive",graph:this.graph}])},syncReceive:(Q)=>this.applyFullGraph(Q.graph)};for(let Q of J)G[Q.type]?.(Q);await this.saveGraphToOPFS(),this.emit()}}function DW(J){if(typeof J!=="object"||J===null)throw new Error("Los roles personalizados deben ser un objeto v\xE1lido.");jQ=J}function a5(J,G,Q=new Set){const q=jQ;if(!q[J])return!1;if(Q.has(J))return!1;if(Q.add(J),q[J].can.includes(G))return!0;if(q[J].inherits)return q[J].inherits.some((W)=>a5(W,G,Q));return!1}async function OW(J,G,Q,q=null){if(await J.ready,!jQ[Q])throw new Error(`El rol '${Q}' no existe.`);let W=`user:${G}`;const X=J.graph.get(W),Y={role:Q,expiresAt:q?new Date(q).toISOString():null};if(X)Object.assign(X.value,Y);else J.graph.insert(W,Y);await J.saveGraphToOPFS(),console.log(`Rol '${Q}' asignado al usuario '${G}'${q?` con caducidad en ${q}`:""}.`)}var s5=function(){const J=new Uint8Array(32);return window.crypto.getRandomValues(J),J},BW=function(){const J=new Uint8Array(16);return window.crypto.getRandomValues(J),J};async function LW(J,G){let Q=`user:${G}`;const q=J.graph.get(Q);if(!q)throw new Error("No tienes un rol asignado.");if(q.value.expiresAt&&new Date(q.value.expiresAt)<new Date)throw new Error("Tu rol ha caducado.");return q.value.role}async function NW(J,G,Q){const q=await LW(J,G);if(!a5(q,Q))throw new Error(`No tienes permiso para realizar la operaci\xF3n '${Q}'.`)}async function AW(J,G,Q,q){return await RW(J,G),await NW(J,G,Q),G}async function RW(J,G){let Q=`user:${G}`,q=J.graph.get(Q);if(!q){const W={storedCredential:null,isAuthenticated:!1};J.graph.insert(Q,W),await J.saveGraphToOPFS(),q=J.graph.get(Q)}if(!q.value.storedCredential)await kW(J,G);else if(!q.value.isAuthenticated)await t5(J,G);else console.log("Ya est\xE1s autenticado. Bot\xF3n desactivado.")}async function kW(J,G){if(!window.PublicKeyCredential){alert("WebAuthn no es soportado en este navegador.");return}let Q=`user:${G}`;const q=BW(),X={challenge:s5(),rp:{name:"RBAC System"},user:{id:q,name:G,displayName:G},pubKeyCredParams:[{type:"public-key",alg:-7}],authenticatorSelection:{authenticatorAttachment:"platform",userVerification:"required"},timeout:60000,attestation:"direct"};try{const Y=await navigator.credentials.create({publicKey:X}),U=J.graph.get(Q);if(!U){console.error("\xA1Error! El nodo de usuario desapareci\xF3 durante el registro.");return}U.value.storedCredential={id:Y.id,type:Y.type,rawId:Array.from(new Uint8Array(Y.rawId)),response:{attestationObject:Array.from(new Uint8Array(Y.response.attestationObject)),clientDataJSON:Array.from(new Uint8Array(Y.response.clientDataJSON))}},U.value.isAuthenticated=!0,await J.saveGraphToOPFS(),console.log("Credencial registrada:",Y),await t5(J,G)}catch(Y){console.error("Error en registro",Y)}}async function t5(J,G){let Q=`user:${G}`;const q=J.graph.get(Q);if(!q){alert("No hay usuario registrado. Registra uno primero.");return}const W=q.value.storedCredential;if(!W){alert("No hay credenciales registradas. Registra una primero.");return}const Y={challenge:s5(),allowCredentials:[{id:W.id,type:"public-key"}],userVerification:"required",timeout:60000};try{const U=await navigator.credentials.get({publicKey:Y});q.value.isAuthenticated=!0,await J.saveGraphToOPFS(),console.log("Autenticaci\xF3n exitosa:",U)}catch(U){console.error("Error en autenticaci\xF3n",U)}}var jQ={superadmin:{can:["assignRole"],inherits:["admin"]},admin:{can:["delete"],inherits:["manager"]},manager:{can:["publish"],inherits:["user"]},user:{can:["write"],inherits:["guest"]},guest:{can:["read"]}};export{DW as setCustomRoles,AW as executeWithPermission,OW as assignRole,zQ as GraphDB};
