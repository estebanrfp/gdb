function H8(J){const Q=J.length;let W=0,G=0;while(G<Q){let V=J.charCodeAt(G++);if((V&4294967168)===0){W++;continue}else if((V&4294965248)===0)W+=2;else{if(V>=55296&&V<=56319){if(G<Q){const X=J.charCodeAt(G);if((X&64512)===56320)++G,V=((V&1023)<<10)+(X&1023)+65536}}if((V&4294901760)===0)W+=3;else W+=4}}return W}function t6(J,Q,W){const G=J.length;let V=W,X=0;while(X<G){let Y=J.charCodeAt(X++);if((Y&4294967168)===0){Q[V++]=Y;continue}else if((Y&4294965248)===0)Q[V++]=Y>>6&31|192;else{if(Y>=55296&&Y<=56319){if(X<G){const U=J.charCodeAt(X);if((U&64512)===56320)++X,Y=((Y&1023)<<10)+(U&1023)+65536}}if((Y&4294901760)===0)Q[V++]=Y>>12&15|224,Q[V++]=Y>>6&63|128;else Q[V++]=Y>>18&7|240,Q[V++]=Y>>12&63|128,Q[V++]=Y>>6&63|128}Q[V++]=Y&63|128}}function W5(J,Q,W){s6.encodeInto(J,Q.subarray(W))}function k8(J,Q,W){if(J.length>J5)W5(J,Q,W);else t6(J,Q,W)}function S1(J,Q,W){let G=Q;const V=G+W,X=[];let Y="";while(G<V){const U=J[G++];if((U&128)===0)X.push(U);else if((U&224)===192){const F=J[G++]&63;X.push((U&31)<<6|F)}else if((U&240)===224){const F=J[G++]&63,q=J[G++]&63;X.push((U&31)<<12|F<<6|q)}else if((U&248)===240){const F=J[G++]&63,q=J[G++]&63,P=J[G++]&63;let $=(U&7)<<18|F<<12|q<<6|P;if($>65535)$-=65536,X.push($>>>10&1023|55296),$=56320|$&1023;X.push($)}else X.push(U);if(X.length>=Q5)Y+=String.fromCharCode(...X),X.length=0}if(X.length>0)Y+=String.fromCharCode(...X);return Y}function X5(J,Q,W){const G=J.subarray(Q,Q+W);return G5.decode(G)}function $8(J,Q,W){if(W>V5)return X5(J,Q,W);else return S1(J,Q,W)}var s6=new TextEncoder,J5=50,Q5=4096,G5=new TextDecoder,V5=200;class A0{constructor(J,Q){this.type=J,this.data=Q}}class i extends Error{constructor(J){super(J);const Q=Object.create(i.prototype);Object.setPrototypeOf(this,Q),Object.defineProperty(this,"name",{configurable:!0,enumerable:!1,value:i.name})}}function B8(J,Q,W){const G=W/4294967296,V=W;J.setUint32(Q,G),J.setUint32(Q+4,V)}function K1(J,Q,W){const G=Math.floor(W/4294967296),V=W;J.setUint32(Q,G),J.setUint32(Q+4,V)}function F1(J,Q){const W=J.getInt32(Q),G=J.getUint32(Q+4);return W*4294967296+G}function j8(J,Q){const W=J.getUint32(Q),G=J.getUint32(Q+4);return W*4294967296+G}var N0=4294967295;function P5({sec:J,nsec:Q}){if(J>=0&&Q>=0&&J<=Y5)if(Q===0&&J<=U5){const W=new Uint8Array(4);return new DataView(W.buffer).setUint32(0,J),W}else{const W=J/4294967296,G=J&4294967295,V=new Uint8Array(8),X=new DataView(V.buffer);return X.setUint32(0,Q<<2|W&3),X.setUint32(4,G),V}else{const W=new Uint8Array(12),G=new DataView(W.buffer);return G.setUint32(0,Q),K1(G,4,J),W}}function K5(J){const Q=J.getTime(),W=Math.floor(Q/1000),G=(Q-W*1000)*1e6,V=Math.floor(G/1e9);return{sec:W+V,nsec:G-V*1e9}}function F5(J){if(J instanceof Date){const Q=K5(J);return P5(Q)}else return null}function z5(J){const Q=new DataView(J.buffer,J.byteOffset,J.byteLength);switch(J.byteLength){case 4:return{sec:Q.getUint32(0),nsec:0};case 8:{const W=Q.getUint32(0),G=Q.getUint32(4),V=(W&3)*4294967296+G,X=W>>>2;return{sec:V,nsec:X}}case 12:{const W=F1(Q,4),G=Q.getUint32(0);return{sec:W,nsec:G}}default:throw new i(`Unrecognized data size for timestamp (expected 4, 8, or 12): ${J.length}`)}}function Z5(J){const Q=z5(J);return new Date(Q.sec*1000+Q.nsec/1e6)}var q5=-1,U5=4294967295,Y5=17179869183,R8={type:q5,encode:F5,decode:Z5};class $0{constructor(){this.builtInEncoders=[],this.builtInDecoders=[],this.encoders=[],this.decoders=[],this.register(R8)}register({type:J,encode:Q,decode:W}){if(J>=0)this.encoders[J]=Q,this.decoders[J]=W;else{const G=-1-J;this.builtInEncoders[G]=Q,this.builtInDecoders[G]=W}}tryToEncode(J,Q){for(let W=0;W<this.builtInEncoders.length;W++){const G=this.builtInEncoders[W];if(G!=null){const V=G(J,Q);if(V!=null){const X=-1-W;return new A0(X,V)}}}for(let W=0;W<this.encoders.length;W++){const G=this.encoders[W];if(G!=null){const V=G(J,Q);if(V!=null)return new A0(W,V)}}if(J instanceof A0)return J;return null}decode(J,Q,W){const G=Q<0?this.builtInDecoders[-1-Q]:this.decoders[Q];if(G)return G(J,Q,W);else return new A0(Q,J)}}$0.defaultCodec=new $0;var H5=function(J){return J instanceof ArrayBuffer||typeof SharedArrayBuffer!=="undefined"&&J instanceof SharedArrayBuffer};function b0(J){if(J instanceof Uint8Array)return J;else if(ArrayBuffer.isView(J))return new Uint8Array(J.buffer,J.byteOffset,J.byteLength);else if(H5(J))return new Uint8Array(J);else return Uint8Array.from(J)}var k5=100,$5=2048;class z1{constructor(J){this.entered=!1,this.extensionCodec=J?.extensionCodec??$0.defaultCodec,this.context=J?.context,this.useBigInt64=J?.useBigInt64??!1,this.maxDepth=J?.maxDepth??k5,this.initialBufferSize=J?.initialBufferSize??$5,this.sortKeys=J?.sortKeys??!1,this.forceFloat32=J?.forceFloat32??!1,this.ignoreUndefined=J?.ignoreUndefined??!1,this.forceIntegerToFloat=J?.forceIntegerToFloat??!1,this.pos=0,this.view=new DataView(new ArrayBuffer(this.initialBufferSize)),this.bytes=new Uint8Array(this.view.buffer)}clone(){return new z1({extensionCodec:this.extensionCodec,context:this.context,useBigInt64:this.useBigInt64,maxDepth:this.maxDepth,initialBufferSize:this.initialBufferSize,sortKeys:this.sortKeys,forceFloat32:this.forceFloat32,ignoreUndefined:this.ignoreUndefined,forceIntegerToFloat:this.forceIntegerToFloat})}reinitializeState(){this.pos=0}encodeSharedRef(J){if(this.entered)return this.clone().encodeSharedRef(J);try{return this.entered=!0,this.reinitializeState(),this.doEncode(J,1),this.bytes.subarray(0,this.pos)}finally{this.entered=!1}}encode(J){if(this.entered)return this.clone().encode(J);try{return this.entered=!0,this.reinitializeState(),this.doEncode(J,1),this.bytes.slice(0,this.pos)}finally{this.entered=!1}}doEncode(J,Q){if(Q>this.maxDepth)throw new Error(`Too deep objects in depth ${Q}`);if(J==null)this.encodeNil();else if(typeof J==="boolean")this.encodeBoolean(J);else if(typeof J==="number")if(!this.forceIntegerToFloat)this.encodeNumber(J);else this.encodeNumberAsFloat(J);else if(typeof J==="string")this.encodeString(J);else if(this.useBigInt64&&typeof J==="bigint")this.encodeBigInt64(J);else this.encodeObject(J,Q)}ensureBufferSizeToWrite(J){const Q=this.pos+J;if(this.view.byteLength<Q)this.resizeBuffer(Q*2)}resizeBuffer(J){const Q=new ArrayBuffer(J),W=new Uint8Array(Q),G=new DataView(Q);W.set(this.bytes),this.view=G,this.bytes=W}encodeNil(){this.writeU8(192)}encodeBoolean(J){if(J===!1)this.writeU8(194);else this.writeU8(195)}encodeNumber(J){if(!this.forceIntegerToFloat&&Number.isSafeInteger(J))if(J>=0)if(J<128)this.writeU8(J);else if(J<256)this.writeU8(204),this.writeU8(J);else if(J<65536)this.writeU8(205),this.writeU16(J);else if(J<4294967296)this.writeU8(206),this.writeU32(J);else if(!this.useBigInt64)this.writeU8(207),this.writeU64(J);else this.encodeNumberAsFloat(J);else if(J>=-32)this.writeU8(224|J+32);else if(J>=-128)this.writeU8(208),this.writeI8(J);else if(J>=-32768)this.writeU8(209),this.writeI16(J);else if(J>=-2147483648)this.writeU8(210),this.writeI32(J);else if(!this.useBigInt64)this.writeU8(211),this.writeI64(J);else this.encodeNumberAsFloat(J);else this.encodeNumberAsFloat(J)}encodeNumberAsFloat(J){if(this.forceFloat32)this.writeU8(202),this.writeF32(J);else this.writeU8(203),this.writeF64(J)}encodeBigInt64(J){if(J>=BigInt(0))this.writeU8(207),this.writeBigUint64(J);else this.writeU8(211),this.writeBigInt64(J)}writeStringHeader(J){if(J<32)this.writeU8(160+J);else if(J<256)this.writeU8(217),this.writeU8(J);else if(J<65536)this.writeU8(218),this.writeU16(J);else if(J<4294967296)this.writeU8(219),this.writeU32(J);else throw new Error(`Too long string: ${J} bytes in UTF-8`)}encodeString(J){const W=H8(J);this.ensureBufferSizeToWrite(5+W),this.writeStringHeader(W),k8(J,this.bytes,this.pos),this.pos+=W}encodeObject(J,Q){const W=this.extensionCodec.tryToEncode(J,this.context);if(W!=null)this.encodeExtension(W);else if(Array.isArray(J))this.encodeArray(J,Q);else if(ArrayBuffer.isView(J))this.encodeBinary(J);else if(typeof J==="object")this.encodeMap(J,Q);else throw new Error(`Unrecognized object: ${Object.prototype.toString.apply(J)}`)}encodeBinary(J){const Q=J.byteLength;if(Q<256)this.writeU8(196),this.writeU8(Q);else if(Q<65536)this.writeU8(197),this.writeU16(Q);else if(Q<4294967296)this.writeU8(198),this.writeU32(Q);else throw new Error(`Too large binary: ${Q}`);const W=b0(J);this.writeU8a(W)}encodeArray(J,Q){const W=J.length;if(W<16)this.writeU8(144+W);else if(W<65536)this.writeU8(220),this.writeU16(W);else if(W<4294967296)this.writeU8(221),this.writeU32(W);else throw new Error(`Too large array: ${W}`);for(let G of J)this.doEncode(G,Q+1)}countWithoutUndefined(J,Q){let W=0;for(let G of Q)if(J[G]!==void 0)W++;return W}encodeMap(J,Q){const W=Object.keys(J);if(this.sortKeys)W.sort();const G=this.ignoreUndefined?this.countWithoutUndefined(J,W):W.length;if(G<16)this.writeU8(128+G);else if(G<65536)this.writeU8(222),this.writeU16(G);else if(G<4294967296)this.writeU8(223),this.writeU32(G);else throw new Error(`Too large map object: ${G}`);for(let V of W){const X=J[V];if(!(this.ignoreUndefined&&X===void 0))this.encodeString(V),this.doEncode(X,Q+1)}}encodeExtension(J){if(typeof J.data==="function"){const W=J.data(this.pos+6),G=W.length;if(G>=4294967296)throw new Error(`Too large extension object: ${G}`);this.writeU8(201),this.writeU32(G),this.writeI8(J.type),this.writeU8a(W);return}const Q=J.data.length;if(Q===1)this.writeU8(212);else if(Q===2)this.writeU8(213);else if(Q===4)this.writeU8(214);else if(Q===8)this.writeU8(215);else if(Q===16)this.writeU8(216);else if(Q<256)this.writeU8(199),this.writeU8(Q);else if(Q<65536)this.writeU8(200),this.writeU16(Q);else if(Q<4294967296)this.writeU8(201),this.writeU32(Q);else throw new Error(`Too large extension object: ${Q}`);this.writeI8(J.type),this.writeU8a(J.data)}writeU8(J){this.ensureBufferSizeToWrite(1),this.view.setUint8(this.pos,J),this.pos++}writeU8a(J){const Q=J.length;this.ensureBufferSizeToWrite(Q),this.bytes.set(J,this.pos),this.pos+=Q}writeI8(J){this.ensureBufferSizeToWrite(1),this.view.setInt8(this.pos,J),this.pos++}writeU16(J){this.ensureBufferSizeToWrite(2),this.view.setUint16(this.pos,J),this.pos+=2}writeI16(J){this.ensureBufferSizeToWrite(2),this.view.setInt16(this.pos,J),this.pos+=2}writeU32(J){this.ensureBufferSizeToWrite(4),this.view.setUint32(this.pos,J),this.pos+=4}writeI32(J){this.ensureBufferSizeToWrite(4),this.view.setInt32(this.pos,J),this.pos+=4}writeF32(J){this.ensureBufferSizeToWrite(4),this.view.setFloat32(this.pos,J),this.pos+=4}writeF64(J){this.ensureBufferSizeToWrite(8),this.view.setFloat64(this.pos,J),this.pos+=8}writeU64(J){this.ensureBufferSizeToWrite(8),B8(this.view,this.pos,J),this.pos+=8}writeI64(J){this.ensureBufferSizeToWrite(8),K1(this.view,this.pos,J),this.pos+=8}writeBigUint64(J){this.ensureBufferSizeToWrite(8),this.view.setBigUint64(this.pos,J),this.pos+=8}writeBigInt64(J){this.ensureBufferSizeToWrite(8),this.view.setBigInt64(this.pos,J),this.pos+=8}}function u0(J,Q){return new z1(Q).encodeSharedRef(J)}function Z1(J){return`${J<0?"-":""}0x${Math.abs(J).toString(16).padStart(2,"0")}`}var B5=16,j5=16;class T1{constructor(J=B5,Q=j5){this.hit=0,this.miss=0,this.maxKeyLength=J,this.maxLengthPerKey=Q,this.caches=[];for(let W=0;W<this.maxKeyLength;W++)this.caches.push([])}canBeCached(J){return J>0&&J<=this.maxKeyLength}find(J,Q,W){const G=this.caches[W-1];J:for(let V of G){const X=V.bytes;for(let Y=0;Y<W;Y++)if(X[Y]!==J[Q+Y])continue J;return V.str}return null}store(J,Q){const W=this.caches[J.length-1],G={bytes:J,str:Q};if(W.length>=this.maxLengthPerKey)W[Math.random()*W.length|0]=G;else W.push(G)}decode(J,Q,W){const G=this.find(J,Q,W);if(G!=null)return this.hit++,G;this.miss++;const V=S1(J,Q,W),X=Uint8Array.prototype.slice.call(J,Q,Q+W);return this.store(X,V),V}}var g1="array",c0="map_key",L8="map_value",R5=(J)=>{if(typeof J==="string"||typeof J==="number")return J;throw new i("The type of key must be string or number but "+typeof J)};class C8{constructor(){this.stack=[],this.stackHeadPosition=-1}get length(){return this.stackHeadPosition+1}top(){return this.stack[this.stackHeadPosition]}pushArrayState(J){const Q=this.getUninitializedStateFromPool();Q.type=g1,Q.position=0,Q.size=J,Q.array=new Array(J)}pushMapState(J){const Q=this.getUninitializedStateFromPool();Q.type=c0,Q.readCount=0,Q.size=J,Q.map={}}getUninitializedStateFromPool(){if(this.stackHeadPosition++,this.stackHeadPosition===this.stack.length){const J={type:void 0,size:0,array:void 0,position:0,readCount:0,map:void 0,key:null};this.stack.push(J)}return this.stack[this.stackHeadPosition]}release(J){if(this.stack[this.stackHeadPosition]!==J)throw new Error("Invalid stack state. Released state is not on top of the stack.");if(J.type===g1){const W=J;W.size=0,W.array=void 0,W.position=0,W.type=void 0}if(J.type===c0||J.type===L8){const W=J;W.size=0,W.map=void 0,W.readCount=0,W.type=void 0}this.stackHeadPosition--}reset(){this.stack.length=0,this.stackHeadPosition=-1}}var m0=-1,v1=new DataView(new ArrayBuffer(0)),M5=new Uint8Array(v1.buffer);try{v1.getInt8(0)}catch(J){if(!(J instanceof RangeError))throw new Error("This module is not supported in the current JavaScript engine because DataView does not throw RangeError on out-of-bounds access")}var M8=new RangeError("Insufficient data"),L5=new T1;class H1{constructor(J){this.totalPos=0,this.pos=0,this.view=v1,this.bytes=M5,this.headByte=m0,this.stack=new C8,this.entered=!1,this.extensionCodec=J?.extensionCodec??$0.defaultCodec,this.context=J?.context,this.useBigInt64=J?.useBigInt64??!1,this.rawStrings=J?.rawStrings??!1,this.maxStrLength=J?.maxStrLength??N0,this.maxBinLength=J?.maxBinLength??N0,this.maxArrayLength=J?.maxArrayLength??N0,this.maxMapLength=J?.maxMapLength??N0,this.maxExtLength=J?.maxExtLength??N0,this.keyDecoder=J?.keyDecoder!==void 0?J.keyDecoder:L5,this.mapKeyConverter=J?.mapKeyConverter??R5}clone(){return new H1({extensionCodec:this.extensionCodec,context:this.context,useBigInt64:this.useBigInt64,rawStrings:this.rawStrings,maxStrLength:this.maxStrLength,maxBinLength:this.maxBinLength,maxArrayLength:this.maxArrayLength,maxMapLength:this.maxMapLength,maxExtLength:this.maxExtLength,keyDecoder:this.keyDecoder})}reinitializeState(){this.totalPos=0,this.headByte=m0,this.stack.reset()}setBuffer(J){const Q=b0(J);this.bytes=Q,this.view=new DataView(Q.buffer,Q.byteOffset,Q.byteLength),this.pos=0}appendBuffer(J){if(this.headByte===m0&&!this.hasRemaining(1))this.setBuffer(J);else{const Q=this.bytes.subarray(this.pos),W=b0(J),G=new Uint8Array(Q.length+W.length);G.set(Q),G.set(W,Q.length),this.setBuffer(G)}}hasRemaining(J){return this.view.byteLength-this.pos>=J}createExtraByteError(J){const{view:Q,pos:W}=this;return new RangeError(`Extra ${Q.byteLength-W} of ${Q.byteLength} byte(s) found at buffer[${J}]`)}decode(J){if(this.entered)return this.clone().decode(J);try{this.entered=!0,this.reinitializeState(),this.setBuffer(J);const Q=this.doDecodeSync();if(this.hasRemaining(1))throw this.createExtraByteError(this.pos);return Q}finally{this.entered=!1}}*decodeMulti(J){if(this.entered){yield*this.clone().decodeMulti(J);return}try{this.entered=!0,this.reinitializeState(),this.setBuffer(J);while(this.hasRemaining(1))yield this.doDecodeSync()}finally{this.entered=!1}}async decodeAsync(J){if(this.entered)return this.clone().decodeAsync(J);try{this.entered=!0;let Q=!1,W;for await(let Y of J){if(Q)throw this.entered=!1,this.createExtraByteError(this.totalPos);this.appendBuffer(Y);try{W=this.doDecodeSync(),Q=!0}catch(U){if(!(U instanceof RangeError))throw U}this.totalPos+=this.pos}if(Q){if(this.hasRemaining(1))throw this.createExtraByteError(this.totalPos);return W}const{headByte:G,pos:V,totalPos:X}=this;throw new RangeError(`Insufficient data in parsing ${Z1(G)} at ${X} (${V} in the current buffer)`)}finally{this.entered=!1}}decodeArrayStream(J){return this.decodeMultiAsync(J,!0)}decodeStream(J){return this.decodeMultiAsync(J,!1)}async*decodeMultiAsync(J,Q){if(this.entered){yield*this.clone().decodeMultiAsync(J,Q);return}try{this.entered=!0;let W=Q,G=-1;for await(let V of J){if(Q&&G===0)throw this.createExtraByteError(this.totalPos);if(this.appendBuffer(V),W)G=this.readArraySize(),W=!1,this.complete();try{while(!0)if(yield this.doDecodeSync(),--G===0)break}catch(X){if(!(X instanceof RangeError))throw X}this.totalPos+=this.pos}}finally{this.entered=!1}}doDecodeSync(){J:while(!0){const J=this.readHeadByte();let Q;if(J>=224)Q=J-256;else if(J<192)if(J<128)Q=J;else if(J<144){const G=J-128;if(G!==0){this.pushMapState(G),this.complete();continue J}else Q={}}else if(J<160){const G=J-144;if(G!==0){this.pushArrayState(G),this.complete();continue J}else Q=[]}else{const G=J-160;Q=this.decodeString(G,0)}else if(J===192)Q=null;else if(J===194)Q=!1;else if(J===195)Q=!0;else if(J===202)Q=this.readF32();else if(J===203)Q=this.readF64();else if(J===204)Q=this.readU8();else if(J===205)Q=this.readU16();else if(J===206)Q=this.readU32();else if(J===207)if(this.useBigInt64)Q=this.readU64AsBigInt();else Q=this.readU64();else if(J===208)Q=this.readI8();else if(J===209)Q=this.readI16();else if(J===210)Q=this.readI32();else if(J===211)if(this.useBigInt64)Q=this.readI64AsBigInt();else Q=this.readI64();else if(J===217){const G=this.lookU8();Q=this.decodeString(G,1)}else if(J===218){const G=this.lookU16();Q=this.decodeString(G,2)}else if(J===219){const G=this.lookU32();Q=this.decodeString(G,4)}else if(J===220){const G=this.readU16();if(G!==0){this.pushArrayState(G),this.complete();continue J}else Q=[]}else if(J===221){const G=this.readU32();if(G!==0){this.pushArrayState(G),this.complete();continue J}else Q=[]}else if(J===222){const G=this.readU16();if(G!==0){this.pushMapState(G),this.complete();continue J}else Q={}}else if(J===223){const G=this.readU32();if(G!==0){this.pushMapState(G),this.complete();continue J}else Q={}}else if(J===196){const G=this.lookU8();Q=this.decodeBinary(G,1)}else if(J===197){const G=this.lookU16();Q=this.decodeBinary(G,2)}else if(J===198){const G=this.lookU32();Q=this.decodeBinary(G,4)}else if(J===212)Q=this.decodeExtension(1,0);else if(J===213)Q=this.decodeExtension(2,0);else if(J===214)Q=this.decodeExtension(4,0);else if(J===215)Q=this.decodeExtension(8,0);else if(J===216)Q=this.decodeExtension(16,0);else if(J===199){const G=this.lookU8();Q=this.decodeExtension(G,1)}else if(J===200){const G=this.lookU16();Q=this.decodeExtension(G,2)}else if(J===201){const G=this.lookU32();Q=this.decodeExtension(G,4)}else throw new i(`Unrecognized type byte: ${Z1(J)}`);this.complete();const W=this.stack;while(W.length>0){const G=W.top();if(G.type===g1)if(G.array[G.position]=Q,G.position++,G.position===G.size)Q=G.array,W.release(G);else continue J;else if(G.type===c0){if(Q==="__proto__")throw new i("The key __proto__ is not allowed");G.key=this.mapKeyConverter(Q),G.type=L8;continue J}else if(G.map[G.key]=Q,G.readCount++,G.readCount===G.size)Q=G.map,W.release(G);else{G.key=null,G.type=c0;continue J}}return Q}}readHeadByte(){if(this.headByte===m0)this.headByte=this.readU8();return this.headByte}complete(){this.headByte=m0}readArraySize(){const J=this.readHeadByte();switch(J){case 220:return this.readU16();case 221:return this.readU32();default:if(J<160)return J-144;else throw new i(`Unrecognized array type byte: ${Z1(J)}`)}}pushMapState(J){if(J>this.maxMapLength)throw new i(`Max length exceeded: map length (${J}) > maxMapLengthLength (${this.maxMapLength})`);this.stack.pushMapState(J)}pushArrayState(J){if(J>this.maxArrayLength)throw new i(`Max length exceeded: array length (${J}) > maxArrayLength (${this.maxArrayLength})`);this.stack.pushArrayState(J)}decodeString(J,Q){if(!this.rawStrings||this.stateIsMapKey())return this.decodeUtf8String(J,Q);return this.decodeBinary(J,Q)}decodeUtf8String(J,Q){if(J>this.maxStrLength)throw new i(`Max length exceeded: UTF-8 byte length (${J}) > maxStrLength (${this.maxStrLength})`);if(this.bytes.byteLength<this.pos+Q+J)throw M8;const W=this.pos+Q;let G;if(this.stateIsMapKey()&&this.keyDecoder?.canBeCached(J))G=this.keyDecoder.decode(this.bytes,W,J);else G=$8(this.bytes,W,J);return this.pos+=Q+J,G}stateIsMapKey(){if(this.stack.length>0)return this.stack.top().type===c0;return!1}decodeBinary(J,Q){if(J>this.maxBinLength)throw new i(`Max length exceeded: bin length (${J}) > maxBinLength (${this.maxBinLength})`);if(!this.hasRemaining(J+Q))throw M8;const W=this.pos+Q,G=this.bytes.subarray(W,W+J);return this.pos+=Q+J,G}decodeExtension(J,Q){if(J>this.maxExtLength)throw new i(`Max length exceeded: ext length (${J}) > maxExtLength (${this.maxExtLength})`);const W=this.view.getInt8(this.pos+Q),G=this.decodeBinary(J,Q+1);return this.extensionCodec.decode(G,W,this.context)}lookU8(){return this.view.getUint8(this.pos)}lookU16(){return this.view.getUint16(this.pos)}lookU32(){return this.view.getUint32(this.pos)}readU8(){const J=this.view.getUint8(this.pos);return this.pos++,J}readI8(){const J=this.view.getInt8(this.pos);return this.pos++,J}readU16(){const J=this.view.getUint16(this.pos);return this.pos+=2,J}readI16(){const J=this.view.getInt16(this.pos);return this.pos+=2,J}readU32(){const J=this.view.getUint32(this.pos);return this.pos+=4,J}readI32(){const J=this.view.getInt32(this.pos);return this.pos+=4,J}readU64(){const J=j8(this.view,this.pos);return this.pos+=8,J}readI64(){const J=F1(this.view,this.pos);return this.pos+=8,J}readU64AsBigInt(){const J=this.view.getBigUint64(this.pos);return this.pos+=8,J}readI64AsBigInt(){const J=this.view.getBigInt64(this.pos);return this.pos+=8,J}readF32(){const J=this.view.getFloat32(this.pos);return this.pos+=4,J}readF64(){const J=this.view.getFloat64(this.pos);return this.pos+=8,J}}function B0(J,Q){return new H1(Q).decode(J)}var E0=function(J){let Q=J.length;while(--Q>=0)J[Q]=0},E1=function(J,Q,W,G,V){this.static_tree=J,this.extra_bits=Q,this.extra_base=W,this.elems=G,this.max_length=V,this.has_stree=J&&J.length},f1=function(J,Q){this.dyn_tree=J,this.max_code=0,this.stat_desc=Q},J0=function(J,Q,W,G,V){this.good_length=J,this.max_lazy=Q,this.nice_length=W,this.max_chain=G,this.func=V},IJ=function(){this.strm=null,this.status=0,this.pending_buf=null,this.pending_buf_size=0,this.pending_out=0,this.pending=0,this.wrap=0,this.gzhead=null,this.gzindex=0,this.method=x1,this.last_flush=-1,this.w_size=0,this.w_bits=0,this.w_mask=0,this.window=null,this.window_size=0,this.prev=null,this.head=null,this.ins_h=0,this.hash_size=0,this.hash_bits=0,this.hash_mask=0,this.hash_shift=0,this.block_start=0,this.match_length=0,this.prev_match=0,this.match_available=0,this.strstart=0,this.match_start=0,this.lookahead=0,this.prev_length=0,this.max_chain_length=0,this.max_lazy_match=0,this.level=0,this.strategy=0,this.good_match=0,this.nice_match=0,this.dyn_ltree=new Uint16Array(HJ*2),this.dyn_dtree=new Uint16Array((2*zJ+1)*2),this.bl_tree=new Uint16Array((2*ZJ+1)*2),F0(this.dyn_ltree),F0(this.dyn_dtree),F0(this.bl_tree),this.l_desc=null,this.d_desc=null,this.bl_desc=null,this.bl_count=new Uint16Array(kJ+1),this.heap=new Uint16Array(2*e1+1),F0(this.heap),this.heap_len=0,this.heap_max=0,this.depth=new Uint16Array(2*e1+1),F0(this.depth),this.sym_buf=0,this.lit_bufsize=0,this.sym_next=0,this.sym_end=0,this.opt_len=0,this.static_len=0,this.matches=0,this.insert=0,this.bi_buf=0,this.bi_valid=0},iJ=function(){this.input=null,this.next_in=0,this.avail_in=0,this.total_in=0,this.output=null,this.next_out=0,this.avail_out=0,this.total_out=0,this.msg="",this.state=null,this.data_type=2,this.adler=0},X1=function(J){this.options=O1.assign({level:eJ,method:sJ,chunkSize:16384,windowBits:15,memLevel:8,strategy:tJ},J||{});let Q=this.options;if(Q.raw&&Q.windowBits>0)Q.windowBits=-Q.windowBits;else if(Q.gzip&&Q.windowBits>0&&Q.windowBits<16)Q.windowBits+=16;this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new A6,this.strm.avail_out=0;let W=n0.deflateInit2(this.strm,Q.level,Q.method,Q.windowBits,Q.memLevel,Q.strategy);if(W!==C1)throw new Error(L0[W]);if(Q.header)n0.deflateSetHeader(this.strm,Q.header);if(Q.dictionary){let G;if(typeof Q.dictionary==="string")G=W1.string2buf(Q.dictionary);else if(N6.call(Q.dictionary)==="[object ArrayBuffer]")G=new Uint8Array(Q.dictionary);else G=Q.dictionary;if(W=n0.deflateSetDictionary(this.strm,G),W!==C1)throw new Error(L0[W]);this._dict_set=!0}},Y8=function(J,Q){const W=new X1(Q);if(W.push(J,!0),W.err)throw W.msg||L0[W.err];return W.result},JW=function(J,Q){return Q=Q||{},Q.raw=!0,Y8(J,Q)},WW=function(J,Q){return Q=Q||{},Q.gzip=!0,Y8(J,Q)},xW=function(){this.strm=null,this.mode=0,this.last=!1,this.wrap=0,this.havedict=!1,this.flags=0,this.dmax=0,this.check=0,this.total=0,this.head=null,this.wbits=0,this.wsize=0,this.whave=0,this.wnext=0,this.window=null,this.hold=0,this.bits=0,this.length=0,this.offset=0,this.extra=0,this.lencode=null,this.distcode=null,this.lenbits=0,this.distbits=0,this.ncode=0,this.nlen=0,this.ndist=0,this.have=0,this.next=null,this.lens=new Uint16Array(320),this.work=new Uint16Array(288),this.lendyn=null,this.distdyn=null,this.sane=0,this.back=0,this.was=0},mW=function(){this.text=0,this.time=0,this.xflags=0,this.os=0,this.extra=null,this.extra_len=0,this.name="",this.comment="",this.hcrc=0,this.done=!1},q1=function(J){this.options=O1.assign({chunkSize:65536,windowBits:15,to:""},J||{});const Q=this.options;if(Q.raw&&Q.windowBits>=0&&Q.windowBits<16){if(Q.windowBits=-Q.windowBits,Q.windowBits===0)Q.windowBits=-15}if(Q.windowBits>=0&&Q.windowBits<16&&!(J&&J.windowBits))Q.windowBits+=32;if(Q.windowBits>15&&Q.windowBits<48){if((Q.windowBits&15)===0)Q.windowBits|=15}this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new A6,this.strm.avail_out=0;let W=U0.inflateInit2(this.strm,Q.windowBits);if(W!==Q1)throw new Error(L0[W]);if(this.header=new cW,U0.inflateGetHeader(this.strm,this.header),Q.dictionary){if(typeof Q.dictionary==="string")Q.dictionary=W1.string2buf(Q.dictionary);else if(m6.call(Q.dictionary)==="[object ArrayBuffer]")Q.dictionary=new Uint8Array(Q.dictionary);if(Q.raw){if(W=U0.inflateSetDictionary(this.strm,Q.dictionary),W!==Q1)throw new Error(L0[W])}}},P8=function(J,Q){const W=new q1(Q);if(W.push(J),W.err)throw W.msg||L0[W.err];return W.result},nW=function(J,Q){return Q=Q||{},Q.raw=!0,P8(J,Q)};/*! pako 2.1.0 https://github.com/nodeca/pako @license (MIT AND Zlib) */var C5=0,U6=1,I5=2,x5=3,O5=258,G8=29,G1=256,o0=G1+1+G8,g0=30,V8=19,Y6=2*o0+1,j0=15,y1=16,w5=7,X8=256,P6=16,K6=17,F6=18,r1=new Uint8Array([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0]),M1=new Uint8Array([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13]),D5=new Uint8Array([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7]),z6=new Uint8Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),A5=512,q0=new Array((o0+2)*2);E0(q0);var l0=new Array(g0*2);E0(l0);var a0=new Array(A5);E0(a0);var e0=new Array(O5-x5+1);E0(e0);var q8=new Array(G8);E0(q8);var L1=new Array(g0);E0(L1);var Z6,H6,k6,$6=(J)=>{return J<256?a0[J]:a0[256+(J>>>7)]},t0=(J,Q)=>{J.pending_buf[J.pending++]=Q&255,J.pending_buf[J.pending++]=Q>>>8&255},n=(J,Q,W)=>{if(J.bi_valid>y1-W)J.bi_buf|=Q<<J.bi_valid&65535,t0(J,J.bi_buf),J.bi_buf=Q>>y1-J.bi_valid,J.bi_valid+=W-y1;else J.bi_buf|=Q<<J.bi_valid&65535,J.bi_valid+=W},W0=(J,Q,W)=>{n(J,W[Q*2],W[Q*2+1])},B6=(J,Q)=>{let W=0;do W|=J&1,J>>>=1,W<<=1;while(--Q>0);return W>>>1},N5=(J)=>{if(J.bi_valid===16)t0(J,J.bi_buf),J.bi_buf=0,J.bi_valid=0;else if(J.bi_valid>=8)J.pending_buf[J.pending++]=J.bi_buf&255,J.bi_buf>>=8,J.bi_valid-=8},S5=(J,Q)=>{const{dyn_tree:W,max_code:G}=Q,V=Q.stat_desc.static_tree,X=Q.stat_desc.has_stree,Y=Q.stat_desc.extra_bits,U=Q.stat_desc.extra_base,F=Q.stat_desc.max_length;let q,P,$,z,K,k,O=0;for(z=0;z<=j0;z++)J.bl_count[z]=0;W[J.heap[J.heap_max]*2+1]=0;for(q=J.heap_max+1;q<Y6;q++){if(P=J.heap[q],z=W[W[P*2+1]*2+1]+1,z>F)z=F,O++;if(W[P*2+1]=z,P>G)continue;if(J.bl_count[z]++,K=0,P>=U)K=Y[P-U];if(k=W[P*2],J.opt_len+=k*(z+K),X)J.static_len+=k*(V[P*2+1]+K)}if(O===0)return;do{z=F-1;while(J.bl_count[z]===0)z--;J.bl_count[z]--,J.bl_count[z+1]+=2,J.bl_count[F]--,O-=2}while(O>0);for(z=F;z!==0;z--){P=J.bl_count[z];while(P!==0){if($=J.heap[--q],$>G)continue;if(W[$*2+1]!==z)J.opt_len+=(z-W[$*2+1])*W[$*2],W[$*2+1]=z;P--}}},j6=(J,Q,W)=>{const G=new Array(j0+1);let V=0,X,Y;for(X=1;X<=j0;X++)V=V+W[X-1]<<1,G[X]=V;for(Y=0;Y<=Q;Y++){let U=J[Y*2+1];if(U===0)continue;J[Y*2]=B6(G[U]++,U)}},T5=()=>{let J,Q,W,G,V;const X=new Array(j0+1);W=0;for(G=0;G<G8-1;G++){q8[G]=W;for(J=0;J<1<<r1[G];J++)e0[W++]=G}e0[W-1]=G,V=0;for(G=0;G<16;G++){L1[G]=V;for(J=0;J<1<<M1[G];J++)a0[V++]=G}V>>=7;for(;G<g0;G++){L1[G]=V<<7;for(J=0;J<1<<M1[G]-7;J++)a0[256+V++]=G}for(Q=0;Q<=j0;Q++)X[Q]=0;J=0;while(J<=143)q0[J*2+1]=8,J++,X[8]++;while(J<=255)q0[J*2+1]=9,J++,X[9]++;while(J<=279)q0[J*2+1]=7,J++,X[7]++;while(J<=287)q0[J*2+1]=8,J++,X[8]++;j6(q0,o0+1,X);for(J=0;J<g0;J++)l0[J*2+1]=5,l0[J*2]=B6(J,5);Z6=new E1(q0,r1,G1+1,o0,j0),H6=new E1(l0,M1,0,g0,j0),k6=new E1(new Array(0),D5,0,V8,w5)},R6=(J)=>{let Q;for(Q=0;Q<o0;Q++)J.dyn_ltree[Q*2]=0;for(Q=0;Q<g0;Q++)J.dyn_dtree[Q*2]=0;for(Q=0;Q<V8;Q++)J.bl_tree[Q*2]=0;J.dyn_ltree[X8*2]=1,J.opt_len=J.static_len=0,J.sym_next=J.matches=0},M6=(J)=>{if(J.bi_valid>8)t0(J,J.bi_buf);else if(J.bi_valid>0)J.pending_buf[J.pending++]=J.bi_buf;J.bi_buf=0,J.bi_valid=0},I8=(J,Q,W,G)=>{const V=Q*2,X=W*2;return J[V]<J[X]||J[V]===J[X]&&G[Q]<=G[W]},h1=(J,Q,W)=>{const G=J.heap[W];let V=W<<1;while(V<=J.heap_len){if(V<J.heap_len&&I8(Q,J.heap[V+1],J.heap[V],J.depth))V++;if(I8(Q,G,J.heap[V],J.depth))break;J.heap[W]=J.heap[V],W=V,V<<=1}J.heap[W]=G},x8=(J,Q,W)=>{let G,V,X=0,Y,U;if(J.sym_next!==0)do if(G=J.pending_buf[J.sym_buf+X++]&255,G+=(J.pending_buf[J.sym_buf+X++]&255)<<8,V=J.pending_buf[J.sym_buf+X++],G===0)W0(J,V,Q);else{if(Y=e0[V],W0(J,Y+G1+1,Q),U=r1[Y],U!==0)V-=q8[Y],n(J,V,U);if(G--,Y=$6(G),W0(J,Y,W),U=M1[Y],U!==0)G-=L1[Y],n(J,G,U)}while(X<J.sym_next);W0(J,X8,Q)},o1=(J,Q)=>{const W=Q.dyn_tree,G=Q.stat_desc.static_tree,V=Q.stat_desc.has_stree,X=Q.stat_desc.elems;let Y,U,F=-1,q;J.heap_len=0,J.heap_max=Y6;for(Y=0;Y<X;Y++)if(W[Y*2]!==0)J.heap[++J.heap_len]=F=Y,J.depth[Y]=0;else W[Y*2+1]=0;while(J.heap_len<2)if(q=J.heap[++J.heap_len]=F<2?++F:0,W[q*2]=1,J.depth[q]=0,J.opt_len--,V)J.static_len-=G[q*2+1];Q.max_code=F;for(Y=J.heap_len>>1;Y>=1;Y--)h1(J,W,Y);q=X;do Y=J.heap[1],J.heap[1]=J.heap[J.heap_len--],h1(J,W,1),U=J.heap[1],J.heap[--J.heap_max]=Y,J.heap[--J.heap_max]=U,W[q*2]=W[Y*2]+W[U*2],J.depth[q]=(J.depth[Y]>=J.depth[U]?J.depth[Y]:J.depth[U])+1,W[Y*2+1]=W[U*2+1]=q,J.heap[1]=q++,h1(J,W,1);while(J.heap_len>=2);J.heap[--J.heap_max]=J.heap[1],S5(J,Q),j6(W,F,J.bl_count)},O8=(J,Q,W)=>{let G,V=-1,X,Y=Q[1],U=0,F=7,q=4;if(Y===0)F=138,q=3;Q[(W+1)*2+1]=65535;for(G=0;G<=W;G++){if(X=Y,Y=Q[(G+1)*2+1],++U<F&&X===Y)continue;else if(U<q)J.bl_tree[X*2]+=U;else if(X!==0){if(X!==V)J.bl_tree[X*2]++;J.bl_tree[P6*2]++}else if(U<=10)J.bl_tree[K6*2]++;else J.bl_tree[F6*2]++;if(U=0,V=X,Y===0)F=138,q=3;else if(X===Y)F=6,q=3;else F=7,q=4}},w8=(J,Q,W)=>{let G,V=-1,X,Y=Q[1],U=0,F=7,q=4;if(Y===0)F=138,q=3;for(G=0;G<=W;G++){if(X=Y,Y=Q[(G+1)*2+1],++U<F&&X===Y)continue;else if(U<q)do W0(J,X,J.bl_tree);while(--U!==0);else if(X!==0){if(X!==V)W0(J,X,J.bl_tree),U--;W0(J,P6,J.bl_tree),n(J,U-3,2)}else if(U<=10)W0(J,K6,J.bl_tree),n(J,U-3,3);else W0(J,F6,J.bl_tree),n(J,U-11,7);if(U=0,V=X,Y===0)F=138,q=3;else if(X===Y)F=6,q=3;else F=7,q=4}},g5=(J)=>{let Q;O8(J,J.dyn_ltree,J.l_desc.max_code),O8(J,J.dyn_dtree,J.d_desc.max_code),o1(J,J.bl_desc);for(Q=V8-1;Q>=3;Q--)if(J.bl_tree[z6[Q]*2+1]!==0)break;return J.opt_len+=3*(Q+1)+5+5+4,Q},v5=(J,Q,W,G)=>{let V;n(J,Q-257,5),n(J,W-1,5),n(J,G-4,4);for(V=0;V<G;V++)n(J,J.bl_tree[z6[V]*2+1],3);w8(J,J.dyn_ltree,Q-1),w8(J,J.dyn_dtree,W-1)},y5=(J)=>{let Q=4093624447,W;for(W=0;W<=31;W++,Q>>>=1)if(Q&1&&J.dyn_ltree[W*2]!==0)return 0;if(J.dyn_ltree[18]!==0||J.dyn_ltree[20]!==0||J.dyn_ltree[26]!==0)return 1;for(W=32;W<G1;W++)if(J.dyn_ltree[W*2]!==0)return 1;return 0},D8=!1,E5=(J)=>{if(!D8)T5(),D8=!0;J.l_desc=new f1(J.dyn_ltree,Z6),J.d_desc=new f1(J.dyn_dtree,H6),J.bl_desc=new f1(J.bl_tree,k6),J.bi_buf=0,J.bi_valid=0,R6(J)},L6=(J,Q,W,G)=>{if(n(J,(C5<<1)+(G?1:0),3),M6(J),t0(J,W),t0(J,~W),W)J.pending_buf.set(J.window.subarray(Q,Q+W),J.pending);J.pending+=W},f5=(J)=>{n(J,U6<<1,3),W0(J,X8,q0),N5(J)},h5=(J,Q,W,G)=>{let V,X,Y=0;if(J.level>0){if(J.strm.data_type===2)J.strm.data_type=y5(J);if(o1(J,J.l_desc),o1(J,J.d_desc),Y=g5(J),V=J.opt_len+3+7>>>3,X=J.static_len+3+7>>>3,X<=V)V=X}else V=X=W+5;if(W+4<=V&&Q!==-1)L6(J,Q,W,G);else if(J.strategy===4||X===V)n(J,(U6<<1)+(G?1:0),3),x8(J,q0,l0);else n(J,(I5<<1)+(G?1:0),3),v5(J,J.l_desc.max_code+1,J.d_desc.max_code+1,Y+1),x8(J,J.dyn_ltree,J.dyn_dtree);if(R6(J),G)M6(J)},p5=(J,Q,W)=>{if(J.pending_buf[J.sym_buf+J.sym_next++]=Q,J.pending_buf[J.sym_buf+J.sym_next++]=Q>>8,J.pending_buf[J.sym_buf+J.sym_next++]=W,Q===0)J.dyn_ltree[W*2]++;else J.matches++,Q--,J.dyn_ltree[(e0[W]+G1+1)*2]++,J.dyn_dtree[$6(Q)*2]++;return J.sym_next===J.sym_end},b5=E5,u5=L6,m5=h5,c5=p5,_5=f5,d5={_tr_init:b5,_tr_stored_block:u5,_tr_flush_block:m5,_tr_tally:c5,_tr_align:_5},i5=(J,Q,W,G)=>{let V=J&65535|0,X=J>>>16&65535|0,Y=0;while(W!==0){Y=W>2000?2000:W,W-=Y;do V=V+Q[G++]|0,X=X+V|0;while(--Y);V%=65521,X%=65521}return V|X<<16|0},s0=i5,l5=()=>{let J,Q=[];for(var W=0;W<256;W++){J=W;for(var G=0;G<8;G++)J=J&1?3988292384^J>>>1:J>>>1;Q[W]=J}return Q},n5=new Uint32Array(l5()),r5=(J,Q,W,G)=>{const V=n5,X=G+W;J^=-1;for(let Y=G;Y<X;Y++)J=J>>>8^V[(J^Q[Y])&255];return J^-1},_=r5,L0={2:"need dictionary",1:"stream end",0:"","-1":"file error","-2":"stream error","-3":"data error","-4":"insufficient memory","-5":"buffer error","-6":"incompatible version"},x0={Z_NO_FLUSH:0,Z_PARTIAL_FLUSH:1,Z_SYNC_FLUSH:2,Z_FULL_FLUSH:3,Z_FINISH:4,Z_BLOCK:5,Z_TREES:6,Z_OK:0,Z_STREAM_END:1,Z_NEED_DICT:2,Z_ERRNO:-1,Z_STREAM_ERROR:-2,Z_DATA_ERROR:-3,Z_MEM_ERROR:-4,Z_BUF_ERROR:-5,Z_NO_COMPRESSION:0,Z_BEST_SPEED:1,Z_BEST_COMPRESSION:9,Z_DEFAULT_COMPRESSION:-1,Z_FILTERED:1,Z_HUFFMAN_ONLY:2,Z_RLE:3,Z_FIXED:4,Z_DEFAULT_STRATEGY:0,Z_BINARY:0,Z_TEXT:1,Z_UNKNOWN:2,Z_DEFLATED:8},{_tr_init:o5,_tr_stored_block:a1,_tr_flush_block:a5,_tr_tally:Z0,_tr_align:e5}=d5,{Z_NO_FLUSH:H0,Z_PARTIAL_FLUSH:t5,Z_FULL_FLUSH:s5,Z_FINISH:a,Z_BLOCK:A8,Z_OK:d,Z_STREAM_END:N8,Z_STREAM_ERROR:Q0,Z_DATA_ERROR:JJ,Z_BUF_ERROR:p1,Z_DEFAULT_COMPRESSION:WJ,Z_FILTERED:QJ,Z_HUFFMAN_ONLY:k1,Z_RLE:GJ,Z_FIXED:VJ,Z_DEFAULT_STRATEGY:XJ,Z_UNKNOWN:qJ,Z_DEFLATED:x1}=x0,UJ=9,YJ=15,PJ=8,KJ=29,FJ=256,e1=FJ+1+KJ,zJ=30,ZJ=19,HJ=2*e1+1,kJ=15,g=3,z0=258,G0=z0+g+1,$J=32,v0=42,U8=57,t1=69,s1=73,J8=91,W8=103,R0=113,d0=666,l=1,f0=2,C0=3,h0=4,BJ=3,M0=(J,Q)=>{return J.msg=L0[Q],Q},S8=(J)=>{return J*2-(J>4?9:0)},F0=(J)=>{let Q=J.length;while(--Q>=0)J[Q]=0},jJ=(J)=>{let Q,W,G,V=J.w_size;Q=J.hash_size,G=Q;do W=J.head[--G],J.head[G]=W>=V?W-V:0;while(--Q);Q=V,G=Q;do W=J.prev[--G],J.prev[G]=W>=V?W-V:0;while(--Q)},RJ=(J,Q,W)=>(Q<<J.hash_shift^W)&J.hash_mask,k0=RJ,r=(J)=>{const Q=J.state;let W=Q.pending;if(W>J.avail_out)W=J.avail_out;if(W===0)return;if(J.output.set(Q.pending_buf.subarray(Q.pending_out,Q.pending_out+W),J.next_out),J.next_out+=W,Q.pending_out+=W,J.total_out+=W,J.avail_out-=W,Q.pending-=W,Q.pending===0)Q.pending_out=0},o=(J,Q)=>{a5(J,J.block_start>=0?J.block_start:-1,J.strstart-J.block_start,Q),J.block_start=J.strstart,r(J.strm)},E=(J,Q)=>{J.pending_buf[J.pending++]=Q},_0=(J,Q)=>{J.pending_buf[J.pending++]=Q>>>8&255,J.pending_buf[J.pending++]=Q&255},Q8=(J,Q,W,G)=>{let V=J.avail_in;if(V>G)V=G;if(V===0)return 0;if(J.avail_in-=V,Q.set(J.input.subarray(J.next_in,J.next_in+V),W),J.state.wrap===1)J.adler=s0(J.adler,Q,V,W);else if(J.state.wrap===2)J.adler=_(J.adler,Q,V,W);return J.next_in+=V,J.total_in+=V,V},C6=(J,Q)=>{let{max_chain_length:W,strstart:G}=J,V,X,Y=J.prev_length,U=J.nice_match;const F=J.strstart>J.w_size-G0?J.strstart-(J.w_size-G0):0,q=J.window,P=J.w_mask,$=J.prev,z=J.strstart+z0;let K=q[G+Y-1],k=q[G+Y];if(J.prev_length>=J.good_match)W>>=2;if(U>J.lookahead)U=J.lookahead;do{if(V=Q,q[V+Y]!==k||q[V+Y-1]!==K||q[V]!==q[G]||q[++V]!==q[G+1])continue;G+=2,V++;do;while(q[++G]===q[++V]&&q[++G]===q[++V]&&q[++G]===q[++V]&&q[++G]===q[++V]&&q[++G]===q[++V]&&q[++G]===q[++V]&&q[++G]===q[++V]&&q[++G]===q[++V]&&G<z);if(X=z0-(z-G),G=z-z0,X>Y){if(J.match_start=Q,Y=X,X>=U)break;K=q[G+Y-1],k=q[G+Y]}}while((Q=$[Q&P])>F&&--W!==0);if(Y<=J.lookahead)return Y;return J.lookahead},y0=(J)=>{const Q=J.w_size;let W,G,V;do{if(G=J.window_size-J.lookahead-J.strstart,J.strstart>=Q+(Q-G0)){if(J.window.set(J.window.subarray(Q,Q+Q-G),0),J.match_start-=Q,J.strstart-=Q,J.block_start-=Q,J.insert>J.strstart)J.insert=J.strstart;jJ(J),G+=Q}if(J.strm.avail_in===0)break;if(W=Q8(J.strm,J.window,J.strstart+J.lookahead,G),J.lookahead+=W,J.lookahead+J.insert>=g){V=J.strstart-J.insert,J.ins_h=J.window[V],J.ins_h=k0(J,J.ins_h,J.window[V+1]);while(J.insert)if(J.ins_h=k0(J,J.ins_h,J.window[V+g-1]),J.prev[V&J.w_mask]=J.head[J.ins_h],J.head[J.ins_h]=V,V++,J.insert--,J.lookahead+J.insert<g)break}}while(J.lookahead<G0&&J.strm.avail_in!==0)},I6=(J,Q)=>{let W=J.pending_buf_size-5>J.w_size?J.w_size:J.pending_buf_size-5,G,V,X,Y=0,U=J.strm.avail_in;do{if(G=65535,X=J.bi_valid+42>>3,J.strm.avail_out<X)break;if(X=J.strm.avail_out-X,V=J.strstart-J.block_start,G>V+J.strm.avail_in)G=V+J.strm.avail_in;if(G>X)G=X;if(G<W&&(G===0&&Q!==a||Q===H0||G!==V+J.strm.avail_in))break;if(Y=Q===a&&G===V+J.strm.avail_in?1:0,a1(J,0,0,Y),J.pending_buf[J.pending-4]=G,J.pending_buf[J.pending-3]=G>>8,J.pending_buf[J.pending-2]=~G,J.pending_buf[J.pending-1]=~G>>8,r(J.strm),V){if(V>G)V=G;J.strm.output.set(J.window.subarray(J.block_start,J.block_start+V),J.strm.next_out),J.strm.next_out+=V,J.strm.avail_out-=V,J.strm.total_out+=V,J.block_start+=V,G-=V}if(G)Q8(J.strm,J.strm.output,J.strm.next_out,G),J.strm.next_out+=G,J.strm.avail_out-=G,J.strm.total_out+=G}while(Y===0);if(U-=J.strm.avail_in,U){if(U>=J.w_size)J.matches=2,J.window.set(J.strm.input.subarray(J.strm.next_in-J.w_size,J.strm.next_in),0),J.strstart=J.w_size,J.insert=J.strstart;else{if(J.window_size-J.strstart<=U){if(J.strstart-=J.w_size,J.window.set(J.window.subarray(J.w_size,J.w_size+J.strstart),0),J.matches<2)J.matches++;if(J.insert>J.strstart)J.insert=J.strstart}J.window.set(J.strm.input.subarray(J.strm.next_in-U,J.strm.next_in),J.strstart),J.strstart+=U,J.insert+=U>J.w_size-J.insert?J.w_size-J.insert:U}J.block_start=J.strstart}if(J.high_water<J.strstart)J.high_water=J.strstart;if(Y)return h0;if(Q!==H0&&Q!==a&&J.strm.avail_in===0&&J.strstart===J.block_start)return f0;if(X=J.window_size-J.strstart,J.strm.avail_in>X&&J.block_start>=J.w_size){if(J.block_start-=J.w_size,J.strstart-=J.w_size,J.window.set(J.window.subarray(J.w_size,J.w_size+J.strstart),0),J.matches<2)J.matches++;if(X+=J.w_size,J.insert>J.strstart)J.insert=J.strstart}if(X>J.strm.avail_in)X=J.strm.avail_in;if(X)Q8(J.strm,J.window,J.strstart,X),J.strstart+=X,J.insert+=X>J.w_size-J.insert?J.w_size-J.insert:X;if(J.high_water<J.strstart)J.high_water=J.strstart;if(X=J.bi_valid+42>>3,X=J.pending_buf_size-X>65535?65535:J.pending_buf_size-X,W=X>J.w_size?J.w_size:X,V=J.strstart-J.block_start,V>=W||(V||Q===a)&&Q!==H0&&J.strm.avail_in===0&&V<=X)G=V>X?X:V,Y=Q===a&&J.strm.avail_in===0&&G===V?1:0,a1(J,J.block_start,G,Y),J.block_start+=G,r(J.strm);return Y?C0:l},b1=(J,Q)=>{let W,G;for(;;){if(J.lookahead<G0){if(y0(J),J.lookahead<G0&&Q===H0)return l;if(J.lookahead===0)break}if(W=0,J.lookahead>=g)J.ins_h=k0(J,J.ins_h,J.window[J.strstart+g-1]),W=J.prev[J.strstart&J.w_mask]=J.head[J.ins_h],J.head[J.ins_h]=J.strstart;if(W!==0&&J.strstart-W<=J.w_size-G0)J.match_length=C6(J,W);if(J.match_length>=g)if(G=Z0(J,J.strstart-J.match_start,J.match_length-g),J.lookahead-=J.match_length,J.match_length<=J.max_lazy_match&&J.lookahead>=g){J.match_length--;do J.strstart++,J.ins_h=k0(J,J.ins_h,J.window[J.strstart+g-1]),W=J.prev[J.strstart&J.w_mask]=J.head[J.ins_h],J.head[J.ins_h]=J.strstart;while(--J.match_length!==0);J.strstart++}else J.strstart+=J.match_length,J.match_length=0,J.ins_h=J.window[J.strstart],J.ins_h=k0(J,J.ins_h,J.window[J.strstart+1]);else G=Z0(J,0,J.window[J.strstart]),J.lookahead--,J.strstart++;if(G){if(o(J,!1),J.strm.avail_out===0)return l}}if(J.insert=J.strstart<g-1?J.strstart:g-1,Q===a){if(o(J,!0),J.strm.avail_out===0)return C0;return h0}if(J.sym_next){if(o(J,!1),J.strm.avail_out===0)return l}return f0},S0=(J,Q)=>{let W,G,V;for(;;){if(J.lookahead<G0){if(y0(J),J.lookahead<G0&&Q===H0)return l;if(J.lookahead===0)break}if(W=0,J.lookahead>=g)J.ins_h=k0(J,J.ins_h,J.window[J.strstart+g-1]),W=J.prev[J.strstart&J.w_mask]=J.head[J.ins_h],J.head[J.ins_h]=J.strstart;if(J.prev_length=J.match_length,J.prev_match=J.match_start,J.match_length=g-1,W!==0&&J.prev_length<J.max_lazy_match&&J.strstart-W<=J.w_size-G0){if(J.match_length=C6(J,W),J.match_length<=5&&(J.strategy===QJ||J.match_length===g&&J.strstart-J.match_start>4096))J.match_length=g-1}if(J.prev_length>=g&&J.match_length<=J.prev_length){V=J.strstart+J.lookahead-g,G=Z0(J,J.strstart-1-J.prev_match,J.prev_length-g),J.lookahead-=J.prev_length-1,J.prev_length-=2;do if(++J.strstart<=V)J.ins_h=k0(J,J.ins_h,J.window[J.strstart+g-1]),W=J.prev[J.strstart&J.w_mask]=J.head[J.ins_h],J.head[J.ins_h]=J.strstart;while(--J.prev_length!==0);if(J.match_available=0,J.match_length=g-1,J.strstart++,G){if(o(J,!1),J.strm.avail_out===0)return l}}else if(J.match_available){if(G=Z0(J,0,J.window[J.strstart-1]),G)o(J,!1);if(J.strstart++,J.lookahead--,J.strm.avail_out===0)return l}else J.match_available=1,J.strstart++,J.lookahead--}if(J.match_available)G=Z0(J,0,J.window[J.strstart-1]),J.match_available=0;if(J.insert=J.strstart<g-1?J.strstart:g-1,Q===a){if(o(J,!0),J.strm.avail_out===0)return C0;return h0}if(J.sym_next){if(o(J,!1),J.strm.avail_out===0)return l}return f0},MJ=(J,Q)=>{let W,G,V,X;const Y=J.window;for(;;){if(J.lookahead<=z0){if(y0(J),J.lookahead<=z0&&Q===H0)return l;if(J.lookahead===0)break}if(J.match_length=0,J.lookahead>=g&&J.strstart>0){if(V=J.strstart-1,G=Y[V],G===Y[++V]&&G===Y[++V]&&G===Y[++V]){X=J.strstart+z0;do;while(G===Y[++V]&&G===Y[++V]&&G===Y[++V]&&G===Y[++V]&&G===Y[++V]&&G===Y[++V]&&G===Y[++V]&&G===Y[++V]&&V<X);if(J.match_length=z0-(X-V),J.match_length>J.lookahead)J.match_length=J.lookahead}}if(J.match_length>=g)W=Z0(J,1,J.match_length-g),J.lookahead-=J.match_length,J.strstart+=J.match_length,J.match_length=0;else W=Z0(J,0,J.window[J.strstart]),J.lookahead--,J.strstart++;if(W){if(o(J,!1),J.strm.avail_out===0)return l}}if(J.insert=0,Q===a){if(o(J,!0),J.strm.avail_out===0)return C0;return h0}if(J.sym_next){if(o(J,!1),J.strm.avail_out===0)return l}return f0},LJ=(J,Q)=>{let W;for(;;){if(J.lookahead===0){if(y0(J),J.lookahead===0){if(Q===H0)return l;break}}if(J.match_length=0,W=Z0(J,0,J.window[J.strstart]),J.lookahead--,J.strstart++,W){if(o(J,!1),J.strm.avail_out===0)return l}}if(J.insert=0,Q===a){if(o(J,!0),J.strm.avail_out===0)return C0;return h0}if(J.sym_next){if(o(J,!1),J.strm.avail_out===0)return l}return f0},i0=[new J0(0,0,0,0,I6),new J0(4,4,8,4,b1),new J0(4,5,16,8,b1),new J0(4,6,32,32,b1),new J0(4,4,16,16,S0),new J0(8,16,32,32,S0),new J0(8,16,128,128,S0),new J0(8,32,128,256,S0),new J0(32,128,258,1024,S0),new J0(32,258,258,4096,S0)],CJ=(J)=>{J.window_size=2*J.w_size,F0(J.head),J.max_lazy_match=i0[J.level].max_lazy,J.good_match=i0[J.level].good_length,J.nice_match=i0[J.level].nice_length,J.max_chain_length=i0[J.level].max_chain,J.strstart=0,J.block_start=0,J.lookahead=0,J.insert=0,J.match_length=J.prev_length=g-1,J.match_available=0,J.ins_h=0},V1=(J)=>{if(!J)return 1;const Q=J.state;if(!Q||Q.strm!==J||Q.status!==v0&&Q.status!==U8&&Q.status!==t1&&Q.status!==s1&&Q.status!==J8&&Q.status!==W8&&Q.status!==R0&&Q.status!==d0)return 1;return 0},x6=(J)=>{if(V1(J))return M0(J,Q0);J.total_in=J.total_out=0,J.data_type=qJ;const Q=J.state;if(Q.pending=0,Q.pending_out=0,Q.wrap<0)Q.wrap=-Q.wrap;return Q.status=Q.wrap===2?U8:Q.wrap?v0:R0,J.adler=Q.wrap===2?0:1,Q.last_flush=-2,o5(Q),d},O6=(J)=>{const Q=x6(J);if(Q===d)CJ(J.state);return Q},xJ=(J,Q)=>{if(V1(J)||J.state.wrap!==2)return Q0;return J.state.gzhead=Q,d},w6=(J,Q,W,G,V,X)=>{if(!J)return Q0;let Y=1;if(Q===WJ)Q=6;if(G<0)Y=0,G=-G;else if(G>15)Y=2,G-=16;if(V<1||V>UJ||W!==x1||G<8||G>15||Q<0||Q>9||X<0||X>VJ||G===8&&Y!==1)return M0(J,Q0);if(G===8)G=9;const U=new IJ;return J.state=U,U.strm=J,U.status=v0,U.wrap=Y,U.gzhead=null,U.w_bits=G,U.w_size=1<<U.w_bits,U.w_mask=U.w_size-1,U.hash_bits=V+7,U.hash_size=1<<U.hash_bits,U.hash_mask=U.hash_size-1,U.hash_shift=~~((U.hash_bits+g-1)/g),U.window=new Uint8Array(U.w_size*2),U.head=new Uint16Array(U.hash_size),U.prev=new Uint16Array(U.w_size),U.lit_bufsize=1<<V+6,U.pending_buf_size=U.lit_bufsize*4,U.pending_buf=new Uint8Array(U.pending_buf_size),U.sym_buf=U.lit_bufsize,U.sym_end=(U.lit_bufsize-1)*3,U.level=Q,U.strategy=X,U.method=W,O6(J)},OJ=(J,Q)=>{return w6(J,Q,x1,YJ,PJ,XJ)},wJ=(J,Q)=>{if(V1(J)||Q>A8||Q<0)return J?M0(J,Q0):Q0;const W=J.state;if(!J.output||J.avail_in!==0&&!J.input||W.status===d0&&Q!==a)return M0(J,J.avail_out===0?p1:Q0);const G=W.last_flush;if(W.last_flush=Q,W.pending!==0){if(r(J),J.avail_out===0)return W.last_flush=-1,d}else if(J.avail_in===0&&S8(Q)<=S8(G)&&Q!==a)return M0(J,p1);if(W.status===d0&&J.avail_in!==0)return M0(J,p1);if(W.status===v0&&W.wrap===0)W.status=R0;if(W.status===v0){let V=x1+(W.w_bits-8<<4)<<8,X=-1;if(W.strategy>=k1||W.level<2)X=0;else if(W.level<6)X=1;else if(W.level===6)X=2;else X=3;if(V|=X<<6,W.strstart!==0)V|=$J;if(V+=31-V%31,_0(W,V),W.strstart!==0)_0(W,J.adler>>>16),_0(W,J.adler&65535);if(J.adler=1,W.status=R0,r(J),W.pending!==0)return W.last_flush=-1,d}if(W.status===U8)if(J.adler=0,E(W,31),E(W,139),E(W,8),!W.gzhead){if(E(W,0),E(W,0),E(W,0),E(W,0),E(W,0),E(W,W.level===9?2:W.strategy>=k1||W.level<2?4:0),E(W,BJ),W.status=R0,r(J),W.pending!==0)return W.last_flush=-1,d}else{if(E(W,(W.gzhead.text?1:0)+(W.gzhead.hcrc?2:0)+(!W.gzhead.extra?0:4)+(!W.gzhead.name?0:8)+(!W.gzhead.comment?0:16)),E(W,W.gzhead.time&255),E(W,W.gzhead.time>>8&255),E(W,W.gzhead.time>>16&255),E(W,W.gzhead.time>>24&255),E(W,W.level===9?2:W.strategy>=k1||W.level<2?4:0),E(W,W.gzhead.os&255),W.gzhead.extra&&W.gzhead.extra.length)E(W,W.gzhead.extra.length&255),E(W,W.gzhead.extra.length>>8&255);if(W.gzhead.hcrc)J.adler=_(J.adler,W.pending_buf,W.pending,0);W.gzindex=0,W.status=t1}if(W.status===t1){if(W.gzhead.extra){let V=W.pending,X=(W.gzhead.extra.length&65535)-W.gzindex;while(W.pending+X>W.pending_buf_size){let U=W.pending_buf_size-W.pending;if(W.pending_buf.set(W.gzhead.extra.subarray(W.gzindex,W.gzindex+U),W.pending),W.pending=W.pending_buf_size,W.gzhead.hcrc&&W.pending>V)J.adler=_(J.adler,W.pending_buf,W.pending-V,V);if(W.gzindex+=U,r(J),W.pending!==0)return W.last_flush=-1,d;V=0,X-=U}let Y=new Uint8Array(W.gzhead.extra);if(W.pending_buf.set(Y.subarray(W.gzindex,W.gzindex+X),W.pending),W.pending+=X,W.gzhead.hcrc&&W.pending>V)J.adler=_(J.adler,W.pending_buf,W.pending-V,V);W.gzindex=0}W.status=s1}if(W.status===s1){if(W.gzhead.name){let V=W.pending,X;do{if(W.pending===W.pending_buf_size){if(W.gzhead.hcrc&&W.pending>V)J.adler=_(J.adler,W.pending_buf,W.pending-V,V);if(r(J),W.pending!==0)return W.last_flush=-1,d;V=0}if(W.gzindex<W.gzhead.name.length)X=W.gzhead.name.charCodeAt(W.gzindex++)&255;else X=0;E(W,X)}while(X!==0);if(W.gzhead.hcrc&&W.pending>V)J.adler=_(J.adler,W.pending_buf,W.pending-V,V);W.gzindex=0}W.status=J8}if(W.status===J8){if(W.gzhead.comment){let V=W.pending,X;do{if(W.pending===W.pending_buf_size){if(W.gzhead.hcrc&&W.pending>V)J.adler=_(J.adler,W.pending_buf,W.pending-V,V);if(r(J),W.pending!==0)return W.last_flush=-1,d;V=0}if(W.gzindex<W.gzhead.comment.length)X=W.gzhead.comment.charCodeAt(W.gzindex++)&255;else X=0;E(W,X)}while(X!==0);if(W.gzhead.hcrc&&W.pending>V)J.adler=_(J.adler,W.pending_buf,W.pending-V,V)}W.status=W8}if(W.status===W8){if(W.gzhead.hcrc){if(W.pending+2>W.pending_buf_size){if(r(J),W.pending!==0)return W.last_flush=-1,d}E(W,J.adler&255),E(W,J.adler>>8&255),J.adler=0}if(W.status=R0,r(J),W.pending!==0)return W.last_flush=-1,d}if(J.avail_in!==0||W.lookahead!==0||Q!==H0&&W.status!==d0){let V=W.level===0?I6(W,Q):W.strategy===k1?LJ(W,Q):W.strategy===GJ?MJ(W,Q):i0[W.level].func(W,Q);if(V===C0||V===h0)W.status=d0;if(V===l||V===C0){if(J.avail_out===0)W.last_flush=-1;return d}if(V===f0){if(Q===t5)e5(W);else if(Q!==A8){if(a1(W,0,0,!1),Q===s5){if(F0(W.head),W.lookahead===0)W.strstart=0,W.block_start=0,W.insert=0}}if(r(J),J.avail_out===0)return W.last_flush=-1,d}}if(Q!==a)return d;if(W.wrap<=0)return N8;if(W.wrap===2)E(W,J.adler&255),E(W,J.adler>>8&255),E(W,J.adler>>16&255),E(W,J.adler>>24&255),E(W,J.total_in&255),E(W,J.total_in>>8&255),E(W,J.total_in>>16&255),E(W,J.total_in>>24&255);else _0(W,J.adler>>>16),_0(W,J.adler&65535);if(r(J),W.wrap>0)W.wrap=-W.wrap;return W.pending!==0?d:N8},DJ=(J)=>{if(V1(J))return Q0;const Q=J.state.status;return J.state=null,Q===R0?M0(J,JJ):d},AJ=(J,Q)=>{let W=Q.length;if(V1(J))return Q0;const G=J.state,V=G.wrap;if(V===2||V===1&&G.status!==v0||G.lookahead)return Q0;if(V===1)J.adler=s0(J.adler,Q,W,0);if(G.wrap=0,W>=G.w_size){if(V===0)F0(G.head),G.strstart=0,G.block_start=0,G.insert=0;let F=new Uint8Array(G.w_size);F.set(Q.subarray(W-G.w_size,W),0),Q=F,W=G.w_size}const{avail_in:X,next_in:Y,input:U}=J;J.avail_in=W,J.next_in=0,J.input=Q,y0(G);while(G.lookahead>=g){let F=G.strstart,q=G.lookahead-(g-1);do G.ins_h=k0(G,G.ins_h,G.window[F+g-1]),G.prev[F&G.w_mask]=G.head[G.ins_h],G.head[G.ins_h]=F,F++;while(--q);G.strstart=F,G.lookahead=g-1,y0(G)}return G.strstart+=G.lookahead,G.block_start=G.strstart,G.insert=G.lookahead,G.lookahead=0,G.match_length=G.prev_length=g-1,G.match_available=0,J.next_in=Y,J.input=U,J.avail_in=X,G.wrap=V,d},NJ=OJ,SJ=w6,TJ=O6,gJ=x6,vJ=xJ,yJ=wJ,EJ=DJ,fJ=AJ,hJ="pako deflate (from Nodeca project)",n0={deflateInit:NJ,deflateInit2:SJ,deflateReset:TJ,deflateResetKeep:gJ,deflateSetHeader:vJ,deflate:yJ,deflateEnd:EJ,deflateSetDictionary:fJ,deflateInfo:hJ},pJ=(J,Q)=>{return Object.prototype.hasOwnProperty.call(J,Q)},bJ=function(J){const Q=Array.prototype.slice.call(arguments,1);while(Q.length){const W=Q.shift();if(!W)continue;if(typeof W!=="object")throw new TypeError(W+"must be non-object");for(let G in W)if(pJ(W,G))J[G]=W[G]}return J},uJ=(J)=>{let Q=0;for(let G=0,V=J.length;G<V;G++)Q+=J[G].length;const W=new Uint8Array(Q);for(let G=0,V=0,X=J.length;G<X;G++){let Y=J[G];W.set(Y,V),V+=Y.length}return W},O1={assign:bJ,flattenChunks:uJ},D6=!0;try{String.fromCharCode.apply(null,new Uint8Array(1))}catch(J){D6=!1}var J1=new Uint8Array(256);for(let J=0;J<256;J++)J1[J]=J>=252?6:J>=248?5:J>=240?4:J>=224?3:J>=192?2:1;J1[254]=J1[254]=1;var mJ=(J)=>{if(typeof TextEncoder==="function"&&TextEncoder.prototype.encode)return(new TextEncoder()).encode(J);let Q,W,G,V,X,Y=J.length,U=0;for(V=0;V<Y;V++){if(W=J.charCodeAt(V),(W&64512)===55296&&V+1<Y){if(G=J.charCodeAt(V+1),(G&64512)===56320)W=65536+(W-55296<<10)+(G-56320),V++}U+=W<128?1:W<2048?2:W<65536?3:4}Q=new Uint8Array(U);for(X=0,V=0;X<U;V++){if(W=J.charCodeAt(V),(W&64512)===55296&&V+1<Y){if(G=J.charCodeAt(V+1),(G&64512)===56320)W=65536+(W-55296<<10)+(G-56320),V++}if(W<128)Q[X++]=W;else if(W<2048)Q[X++]=192|W>>>6,Q[X++]=128|W&63;else if(W<65536)Q[X++]=224|W>>>12,Q[X++]=128|W>>>6&63,Q[X++]=128|W&63;else Q[X++]=240|W>>>18,Q[X++]=128|W>>>12&63,Q[X++]=128|W>>>6&63,Q[X++]=128|W&63}return Q},cJ=(J,Q)=>{if(Q<65534){if(J.subarray&&D6)return String.fromCharCode.apply(null,J.length===Q?J:J.subarray(0,Q))}let W="";for(let G=0;G<Q;G++)W+=String.fromCharCode(J[G]);return W},_J=(J,Q)=>{const W=Q||J.length;if(typeof TextDecoder==="function"&&TextDecoder.prototype.decode)return(new TextDecoder()).decode(J.subarray(0,Q));let G,V;const X=new Array(W*2);for(V=0,G=0;G<W;){let Y=J[G++];if(Y<128){X[V++]=Y;continue}let U=J1[Y];if(U>4){X[V++]=65533,G+=U-1;continue}Y&=U===2?31:U===3?15:7;while(U>1&&G<W)Y=Y<<6|J[G++]&63,U--;if(U>1){X[V++]=65533;continue}if(Y<65536)X[V++]=Y;else Y-=65536,X[V++]=55296|Y>>10&1023,X[V++]=56320|Y&1023}return cJ(X,V)},dJ=(J,Q)=>{if(Q=Q||J.length,Q>J.length)Q=J.length;let W=Q-1;while(W>=0&&(J[W]&192)===128)W--;if(W<0)return Q;if(W===0)return Q;return W+J1[J[W]]>Q?W:Q},W1={string2buf:mJ,buf2string:_J,utf8border:dJ},A6=iJ,N6=Object.prototype.toString,{Z_NO_FLUSH:lJ,Z_SYNC_FLUSH:nJ,Z_FULL_FLUSH:rJ,Z_FINISH:oJ,Z_OK:C1,Z_STREAM_END:aJ,Z_DEFAULT_COMPRESSION:eJ,Z_DEFAULT_STRATEGY:tJ,Z_DEFLATED:sJ}=x0;X1.prototype.push=function(J,Q){const W=this.strm,G=this.options.chunkSize;let V,X;if(this.ended)return!1;if(Q===~~Q)X=Q;else X=Q===!0?oJ:lJ;if(typeof J==="string")W.input=W1.string2buf(J);else if(N6.call(J)==="[object ArrayBuffer]")W.input=new Uint8Array(J);else W.input=J;W.next_in=0,W.avail_in=W.input.length;for(;;){if(W.avail_out===0)W.output=new Uint8Array(G),W.next_out=0,W.avail_out=G;if((X===nJ||X===rJ)&&W.avail_out<=6){this.onData(W.output.subarray(0,W.next_out)),W.avail_out=0;continue}if(V=n0.deflate(W,X),V===aJ){if(W.next_out>0)this.onData(W.output.subarray(0,W.next_out));return V=n0.deflateEnd(this.strm),this.onEnd(V),this.ended=!0,V===C1}if(W.avail_out===0){this.onData(W.output);continue}if(X>0&&W.next_out>0){this.onData(W.output.subarray(0,W.next_out)),W.avail_out=0;continue}if(W.avail_in===0)break}return!0};X1.prototype.onData=function(J){this.chunks.push(J)};X1.prototype.onEnd=function(J){if(J===C1)this.result=O1.flattenChunks(this.chunks);this.chunks=[],this.err=J,this.msg=this.strm.msg};var QW=X1,GW=Y8,VW=JW,XW=WW,qW=x0,UW={Deflate:QW,deflate:GW,deflateRaw:VW,gzip:XW,constants:qW},$1=16209,YW=16191,PW=function J(Q,W){let G,V,X,Y,U,F,q,P,$,z,K,k,O,w,R,A,L,H,T,p,j,v,D,I;const N=Q.state;G=Q.next_in,D=Q.input,V=G+(Q.avail_in-5),X=Q.next_out,I=Q.output,Y=X-(W-Q.avail_out),U=X+(Q.avail_out-257),F=N.dmax,q=N.wsize,P=N.whave,$=N.wnext,z=N.window,K=N.hold,k=N.bits,O=N.lencode,w=N.distcode,R=(1<<N.lenbits)-1,A=(1<<N.distbits)-1;J:do{if(k<15)K+=D[G++]<<k,k+=8,K+=D[G++]<<k,k+=8;L=O[K&R];W:for(;;){if(H=L>>>24,K>>>=H,k-=H,H=L>>>16&255,H===0)I[X++]=L&65535;else if(H&16){if(T=L&65535,H&=15,H){if(k<H)K+=D[G++]<<k,k+=8;T+=K&(1<<H)-1,K>>>=H,k-=H}if(k<15)K+=D[G++]<<k,k+=8,K+=D[G++]<<k,k+=8;L=w[K&A];Q:for(;;){if(H=L>>>24,K>>>=H,k-=H,H=L>>>16&255,H&16){if(p=L&65535,H&=15,k<H){if(K+=D[G++]<<k,k+=8,k<H)K+=D[G++]<<k,k+=8}if(p+=K&(1<<H)-1,p>F){Q.msg="invalid distance too far back",N.mode=$1;break J}if(K>>>=H,k-=H,H=X-Y,p>H){if(H=p-H,H>P){if(N.sane){Q.msg="invalid distance too far back",N.mode=$1;break J}}if(j=0,v=z,$===0){if(j+=q-H,H<T){T-=H;do I[X++]=z[j++];while(--H);j=X-p,v=I}}else if($<H){if(j+=q+$-H,H-=$,H<T){T-=H;do I[X++]=z[j++];while(--H);if(j=0,$<T){H=$,T-=H;do I[X++]=z[j++];while(--H);j=X-p,v=I}}}else if(j+=$-H,H<T){T-=H;do I[X++]=z[j++];while(--H);j=X-p,v=I}while(T>2)I[X++]=v[j++],I[X++]=v[j++],I[X++]=v[j++],T-=3;if(T){if(I[X++]=v[j++],T>1)I[X++]=v[j++]}}else{j=X-p;do I[X++]=I[j++],I[X++]=I[j++],I[X++]=I[j++],T-=3;while(T>2);if(T){if(I[X++]=I[j++],T>1)I[X++]=I[j++]}}}else if((H&64)===0){L=w[(L&65535)+(K&(1<<H)-1)];continue Q}else{Q.msg="invalid distance code",N.mode=$1;break J}break}}else if((H&64)===0){L=O[(L&65535)+(K&(1<<H)-1)];continue W}else if(H&32){N.mode=YW;break J}else{Q.msg="invalid literal/length code",N.mode=$1;break J}break}}while(G<V&&X<U);T=k>>3,G-=T,k-=T<<3,K&=(1<<k)-1,Q.next_in=G,Q.next_out=X,Q.avail_in=G<V?5+(V-G):5-(G-V),Q.avail_out=X<U?257+(U-X):257-(X-U),N.hold=K,N.bits=k;return},T0=15,T8=852,g8=592,v8=0,u1=1,y8=2,KW=new Uint16Array([3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,0,0]),FW=new Uint8Array([16,16,16,16,16,16,16,16,17,17,17,17,18,18,18,18,19,19,19,19,20,20,20,20,21,21,21,21,16,72,78]),zW=new Uint16Array([1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,0,0]),ZW=new Uint8Array([16,16,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,64,64]),HW=(J,Q,W,G,V,X,Y,U)=>{const F=U.bits;let q=0,P=0,$=0,z=0,K=0,k=0,O=0,w=0,R=0,A=0,L,H,T,p,j,v=null,D;const I=new Uint16Array(T0+1),N=new Uint16Array(T0+1);let V0=null,p0,s,Y0;for(q=0;q<=T0;q++)I[q]=0;for(P=0;P<G;P++)I[Q[W+P]]++;K=F;for(z=T0;z>=1;z--)if(I[z]!==0)break;if(K>z)K=z;if(z===0)return V[X++]=1<<24|64<<16|0,V[X++]=1<<24|64<<16|0,U.bits=1,0;for($=1;$<z;$++)if(I[$]!==0)break;if(K<$)K=$;w=1;for(q=1;q<=T0;q++)if(w<<=1,w-=I[q],w<0)return-1;if(w>0&&(J===v8||z!==1))return-1;N[1]=0;for(q=1;q<T0;q++)N[q+1]=N[q]+I[q];for(P=0;P<G;P++)if(Q[W+P]!==0)Y[N[Q[W+P]]++]=P;if(J===v8)v=V0=Y,D=20;else if(J===u1)v=KW,V0=FW,D=257;else v=zW,V0=ZW,D=0;if(A=0,P=0,q=$,j=X,k=K,O=0,T=-1,R=1<<K,p=R-1,J===u1&&R>T8||J===y8&&R>g8)return 1;for(;;){if(p0=q-O,Y[P]+1<D)s=0,Y0=Y[P];else if(Y[P]>=D)s=V0[Y[P]-D],Y0=v[Y[P]-D];else s=96,Y0=0;L=1<<q-O,H=1<<k,$=H;do H-=L,V[j+(A>>O)+H]=p0<<24|s<<16|Y0|0;while(H!==0);L=1<<q-1;while(A&L)L>>=1;if(L!==0)A&=L-1,A+=L;else A=0;if(P++,--I[q]===0){if(q===z)break;q=Q[W+Y[P]]}if(q>K&&(A&p)!==T){if(O===0)O=K;j+=$,k=q-O,w=1<<k;while(k+O<z){if(w-=I[k+O],w<=0)break;k++,w<<=1}if(R+=1<<k,J===u1&&R>T8||J===y8&&R>g8)return 1;T=A&p,V[T]=K<<24|k<<16|j-X|0}}if(A!==0)V[j+A]=q-O<<24|64<<16|0;return U.bits=K,0},r0=HW,kW=0,S6=1,T6=2,{Z_FINISH:E8,Z_BLOCK:$W,Z_TREES:B1,Z_OK:I0,Z_STREAM_END:BW,Z_NEED_DICT:jW,Z_STREAM_ERROR:e,Z_DATA_ERROR:g6,Z_MEM_ERROR:v6,Z_BUF_ERROR:RW,Z_DEFLATED:f8}=x0,w1=16180,h8=16181,p8=16182,b8=16183,u8=16184,m8=16185,c8=16186,_8=16187,d8=16188,i8=16189,I1=16190,X0=16191,m1=16192,l8=16193,c1=16194,n8=16195,r8=16196,o8=16197,a8=16198,j1=16199,R1=16200,e8=16201,t8=16202,s8=16203,J6=16204,W6=16205,_1=16206,Q6=16207,G6=16208,h=16209,y6=16210,E6=16211,MW=852,LW=592,CW=15,IW=CW,V6=(J)=>{return(J>>>24&255)+(J>>>8&65280)+((J&65280)<<8)+((J&255)<<24)},O0=(J)=>{if(!J)return 1;const Q=J.state;if(!Q||Q.strm!==J||Q.mode<w1||Q.mode>E6)return 1;return 0},f6=(J)=>{if(O0(J))return e;const Q=J.state;if(J.total_in=J.total_out=Q.total=0,J.msg="",Q.wrap)J.adler=Q.wrap&1;return Q.mode=w1,Q.last=0,Q.havedict=0,Q.flags=-1,Q.dmax=32768,Q.head=null,Q.hold=0,Q.bits=0,Q.lencode=Q.lendyn=new Int32Array(MW),Q.distcode=Q.distdyn=new Int32Array(LW),Q.sane=1,Q.back=-1,I0},h6=(J)=>{if(O0(J))return e;const Q=J.state;return Q.wsize=0,Q.whave=0,Q.wnext=0,f6(J)},p6=(J,Q)=>{let W;if(O0(J))return e;const G=J.state;if(Q<0)W=0,Q=-Q;else if(W=(Q>>4)+5,Q<48)Q&=15;if(Q&&(Q<8||Q>15))return e;if(G.window!==null&&G.wbits!==Q)G.window=null;return G.wrap=W,G.wbits=Q,h6(J)},b6=(J,Q)=>{if(!J)return e;const W=new xW;J.state=W,W.strm=J,W.window=null,W.mode=w1;const G=p6(J,Q);if(G!==I0)J.state=null;return G},OW=(J)=>{return b6(J,IW)},X6=!0,d1,i1,wW=(J)=>{if(X6){d1=new Int32Array(512),i1=new Int32Array(32);let Q=0;while(Q<144)J.lens[Q++]=8;while(Q<256)J.lens[Q++]=9;while(Q<280)J.lens[Q++]=7;while(Q<288)J.lens[Q++]=8;r0(S6,J.lens,0,288,d1,0,J.work,{bits:9}),Q=0;while(Q<32)J.lens[Q++]=5;r0(T6,J.lens,0,32,i1,0,J.work,{bits:5}),X6=!1}J.lencode=d1,J.lenbits=9,J.distcode=i1,J.distbits=5},u6=(J,Q,W,G)=>{let V;const X=J.state;if(X.window===null)X.wsize=1<<X.wbits,X.wnext=0,X.whave=0,X.window=new Uint8Array(X.wsize);if(G>=X.wsize)X.window.set(Q.subarray(W-X.wsize,W),0),X.wnext=0,X.whave=X.wsize;else{if(V=X.wsize-X.wnext,V>G)V=G;if(X.window.set(Q.subarray(W-G,W-G+V),X.wnext),G-=V,G)X.window.set(Q.subarray(W-G,W),0),X.wnext=G,X.whave=X.wsize;else{if(X.wnext+=V,X.wnext===X.wsize)X.wnext=0;if(X.whave<X.wsize)X.whave+=V}}return 0},DW=(J,Q)=>{let W,G,V,X,Y,U,F,q,P,$,z,K,k,O,w=0,R,A,L,H,T,p,j,v;const D=new Uint8Array(4);let I,N;const V0=new Uint8Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]);if(O0(J)||!J.output||!J.input&&J.avail_in!==0)return e;if(W=J.state,W.mode===X0)W.mode=m1;Y=J.next_out,V=J.output,F=J.avail_out,X=J.next_in,G=J.input,U=J.avail_in,q=W.hold,P=W.bits,$=U,z=F,v=I0;J:for(;;)switch(W.mode){case w1:if(W.wrap===0){W.mode=m1;break}while(P<16){if(U===0)break J;U--,q+=G[X++]<<P,P+=8}if(W.wrap&2&&q===35615){if(W.wbits===0)W.wbits=15;W.check=0,D[0]=q&255,D[1]=q>>>8&255,W.check=_(W.check,D,2,0),q=0,P=0,W.mode=h8;break}if(W.head)W.head.done=!1;if(!(W.wrap&1)||(((q&255)<<8)+(q>>8))%31){J.msg="incorrect header check",W.mode=h;break}if((q&15)!==f8){J.msg="unknown compression method",W.mode=h;break}if(q>>>=4,P-=4,j=(q&15)+8,W.wbits===0)W.wbits=j;if(j>15||j>W.wbits){J.msg="invalid window size",W.mode=h;break}W.dmax=1<<W.wbits,W.flags=0,J.adler=W.check=1,W.mode=q&512?i8:X0,q=0,P=0;break;case h8:while(P<16){if(U===0)break J;U--,q+=G[X++]<<P,P+=8}if(W.flags=q,(W.flags&255)!==f8){J.msg="unknown compression method",W.mode=h;break}if(W.flags&57344){J.msg="unknown header flags set",W.mode=h;break}if(W.head)W.head.text=q>>8&1;if(W.flags&512&&W.wrap&4)D[0]=q&255,D[1]=q>>>8&255,W.check=_(W.check,D,2,0);q=0,P=0,W.mode=p8;case p8:while(P<32){if(U===0)break J;U--,q+=G[X++]<<P,P+=8}if(W.head)W.head.time=q;if(W.flags&512&&W.wrap&4)D[0]=q&255,D[1]=q>>>8&255,D[2]=q>>>16&255,D[3]=q>>>24&255,W.check=_(W.check,D,4,0);q=0,P=0,W.mode=b8;case b8:while(P<16){if(U===0)break J;U--,q+=G[X++]<<P,P+=8}if(W.head)W.head.xflags=q&255,W.head.os=q>>8;if(W.flags&512&&W.wrap&4)D[0]=q&255,D[1]=q>>>8&255,W.check=_(W.check,D,2,0);q=0,P=0,W.mode=u8;case u8:if(W.flags&1024){while(P<16){if(U===0)break J;U--,q+=G[X++]<<P,P+=8}if(W.length=q,W.head)W.head.extra_len=q;if(W.flags&512&&W.wrap&4)D[0]=q&255,D[1]=q>>>8&255,W.check=_(W.check,D,2,0);q=0,P=0}else if(W.head)W.head.extra=null;W.mode=m8;case m8:if(W.flags&1024){if(K=W.length,K>U)K=U;if(K){if(W.head){if(j=W.head.extra_len-W.length,!W.head.extra)W.head.extra=new Uint8Array(W.head.extra_len);W.head.extra.set(G.subarray(X,X+K),j)}if(W.flags&512&&W.wrap&4)W.check=_(W.check,G,K,X);U-=K,X+=K,W.length-=K}if(W.length)break J}W.length=0,W.mode=c8;case c8:if(W.flags&2048){if(U===0)break J;K=0;do if(j=G[X+K++],W.head&&j&&W.length<65536)W.head.name+=String.fromCharCode(j);while(j&&K<U);if(W.flags&512&&W.wrap&4)W.check=_(W.check,G,K,X);if(U-=K,X+=K,j)break J}else if(W.head)W.head.name=null;W.length=0,W.mode=_8;case _8:if(W.flags&4096){if(U===0)break J;K=0;do if(j=G[X+K++],W.head&&j&&W.length<65536)W.head.comment+=String.fromCharCode(j);while(j&&K<U);if(W.flags&512&&W.wrap&4)W.check=_(W.check,G,K,X);if(U-=K,X+=K,j)break J}else if(W.head)W.head.comment=null;W.mode=d8;case d8:if(W.flags&512){while(P<16){if(U===0)break J;U--,q+=G[X++]<<P,P+=8}if(W.wrap&4&&q!==(W.check&65535)){J.msg="header crc mismatch",W.mode=h;break}q=0,P=0}if(W.head)W.head.hcrc=W.flags>>9&1,W.head.done=!0;J.adler=W.check=0,W.mode=X0;break;case i8:while(P<32){if(U===0)break J;U--,q+=G[X++]<<P,P+=8}J.adler=W.check=V6(q),q=0,P=0,W.mode=I1;case I1:if(W.havedict===0)return J.next_out=Y,J.avail_out=F,J.next_in=X,J.avail_in=U,W.hold=q,W.bits=P,jW;J.adler=W.check=1,W.mode=X0;case X0:if(Q===$W||Q===B1)break J;case m1:if(W.last){q>>>=P&7,P-=P&7,W.mode=_1;break}while(P<3){if(U===0)break J;U--,q+=G[X++]<<P,P+=8}switch(W.last=q&1,q>>>=1,P-=1,q&3){case 0:W.mode=l8;break;case 1:if(wW(W),W.mode=j1,Q===B1){q>>>=2,P-=2;break J}break;case 2:W.mode=r8;break;case 3:J.msg="invalid block type",W.mode=h}q>>>=2,P-=2;break;case l8:q>>>=P&7,P-=P&7;while(P<32){if(U===0)break J;U--,q+=G[X++]<<P,P+=8}if((q&65535)!==(q>>>16^65535)){J.msg="invalid stored block lengths",W.mode=h;break}if(W.length=q&65535,q=0,P=0,W.mode=c1,Q===B1)break J;case c1:W.mode=n8;case n8:if(K=W.length,K){if(K>U)K=U;if(K>F)K=F;if(K===0)break J;V.set(G.subarray(X,X+K),Y),U-=K,X+=K,F-=K,Y+=K,W.length-=K;break}W.mode=X0;break;case r8:while(P<14){if(U===0)break J;U--,q+=G[X++]<<P,P+=8}if(W.nlen=(q&31)+257,q>>>=5,P-=5,W.ndist=(q&31)+1,q>>>=5,P-=5,W.ncode=(q&15)+4,q>>>=4,P-=4,W.nlen>286||W.ndist>30){J.msg="too many length or distance symbols",W.mode=h;break}W.have=0,W.mode=o8;case o8:while(W.have<W.ncode){while(P<3){if(U===0)break J;U--,q+=G[X++]<<P,P+=8}W.lens[V0[W.have++]]=q&7,q>>>=3,P-=3}while(W.have<19)W.lens[V0[W.have++]]=0;if(W.lencode=W.lendyn,W.lenbits=7,I={bits:W.lenbits},v=r0(kW,W.lens,0,19,W.lencode,0,W.work,I),W.lenbits=I.bits,v){J.msg="invalid code lengths set",W.mode=h;break}W.have=0,W.mode=a8;case a8:while(W.have<W.nlen+W.ndist){for(;;){if(w=W.lencode[q&(1<<W.lenbits)-1],R=w>>>24,A=w>>>16&255,L=w&65535,R<=P)break;if(U===0)break J;U--,q+=G[X++]<<P,P+=8}if(L<16)q>>>=R,P-=R,W.lens[W.have++]=L;else{if(L===16){N=R+2;while(P<N){if(U===0)break J;U--,q+=G[X++]<<P,P+=8}if(q>>>=R,P-=R,W.have===0){J.msg="invalid bit length repeat",W.mode=h;break}j=W.lens[W.have-1],K=3+(q&3),q>>>=2,P-=2}else if(L===17){N=R+3;while(P<N){if(U===0)break J;U--,q+=G[X++]<<P,P+=8}q>>>=R,P-=R,j=0,K=3+(q&7),q>>>=3,P-=3}else{N=R+7;while(P<N){if(U===0)break J;U--,q+=G[X++]<<P,P+=8}q>>>=R,P-=R,j=0,K=11+(q&127),q>>>=7,P-=7}if(W.have+K>W.nlen+W.ndist){J.msg="invalid bit length repeat",W.mode=h;break}while(K--)W.lens[W.have++]=j}}if(W.mode===h)break;if(W.lens[256]===0){J.msg="invalid code -- missing end-of-block",W.mode=h;break}if(W.lenbits=9,I={bits:W.lenbits},v=r0(S6,W.lens,0,W.nlen,W.lencode,0,W.work,I),W.lenbits=I.bits,v){J.msg="invalid literal/lengths set",W.mode=h;break}if(W.distbits=6,W.distcode=W.distdyn,I={bits:W.distbits},v=r0(T6,W.lens,W.nlen,W.ndist,W.distcode,0,W.work,I),W.distbits=I.bits,v){J.msg="invalid distances set",W.mode=h;break}if(W.mode=j1,Q===B1)break J;case j1:W.mode=R1;case R1:if(U>=6&&F>=258){if(J.next_out=Y,J.avail_out=F,J.next_in=X,J.avail_in=U,W.hold=q,W.bits=P,PW(J,z),Y=J.next_out,V=J.output,F=J.avail_out,X=J.next_in,G=J.input,U=J.avail_in,q=W.hold,P=W.bits,W.mode===X0)W.back=-1;break}W.back=0;for(;;){if(w=W.lencode[q&(1<<W.lenbits)-1],R=w>>>24,A=w>>>16&255,L=w&65535,R<=P)break;if(U===0)break J;U--,q+=G[X++]<<P,P+=8}if(A&&(A&240)===0){H=R,T=A,p=L;for(;;){if(w=W.lencode[p+((q&(1<<H+T)-1)>>H)],R=w>>>24,A=w>>>16&255,L=w&65535,H+R<=P)break;if(U===0)break J;U--,q+=G[X++]<<P,P+=8}q>>>=H,P-=H,W.back+=H}if(q>>>=R,P-=R,W.back+=R,W.length=L,A===0){W.mode=W6;break}if(A&32){W.back=-1,W.mode=X0;break}if(A&64){J.msg="invalid literal/length code",W.mode=h;break}W.extra=A&15,W.mode=e8;case e8:if(W.extra){N=W.extra;while(P<N){if(U===0)break J;U--,q+=G[X++]<<P,P+=8}W.length+=q&(1<<W.extra)-1,q>>>=W.extra,P-=W.extra,W.back+=W.extra}W.was=W.length,W.mode=t8;case t8:for(;;){if(w=W.distcode[q&(1<<W.distbits)-1],R=w>>>24,A=w>>>16&255,L=w&65535,R<=P)break;if(U===0)break J;U--,q+=G[X++]<<P,P+=8}if((A&240)===0){H=R,T=A,p=L;for(;;){if(w=W.distcode[p+((q&(1<<H+T)-1)>>H)],R=w>>>24,A=w>>>16&255,L=w&65535,H+R<=P)break;if(U===0)break J;U--,q+=G[X++]<<P,P+=8}q>>>=H,P-=H,W.back+=H}if(q>>>=R,P-=R,W.back+=R,A&64){J.msg="invalid distance code",W.mode=h;break}W.offset=L,W.extra=A&15,W.mode=s8;case s8:if(W.extra){N=W.extra;while(P<N){if(U===0)break J;U--,q+=G[X++]<<P,P+=8}W.offset+=q&(1<<W.extra)-1,q>>>=W.extra,P-=W.extra,W.back+=W.extra}if(W.offset>W.dmax){J.msg="invalid distance too far back",W.mode=h;break}W.mode=J6;case J6:if(F===0)break J;if(K=z-F,W.offset>K){if(K=W.offset-K,K>W.whave){if(W.sane){J.msg="invalid distance too far back",W.mode=h;break}}if(K>W.wnext)K-=W.wnext,k=W.wsize-K;else k=W.wnext-K;if(K>W.length)K=W.length;O=W.window}else O=V,k=Y-W.offset,K=W.length;if(K>F)K=F;F-=K,W.length-=K;do V[Y++]=O[k++];while(--K);if(W.length===0)W.mode=R1;break;case W6:if(F===0)break J;V[Y++]=W.length,F--,W.mode=R1;break;case _1:if(W.wrap){while(P<32){if(U===0)break J;U--,q|=G[X++]<<P,P+=8}if(z-=F,J.total_out+=z,W.total+=z,W.wrap&4&&z)J.adler=W.check=W.flags?_(W.check,V,z,Y-z):s0(W.check,V,z,Y-z);if(z=F,W.wrap&4&&(W.flags?q:V6(q))!==W.check){J.msg="incorrect data check",W.mode=h;break}q=0,P=0}W.mode=Q6;case Q6:if(W.wrap&&W.flags){while(P<32){if(U===0)break J;U--,q+=G[X++]<<P,P+=8}if(W.wrap&4&&q!==(W.total&4294967295)){J.msg="incorrect length check",W.mode=h;break}q=0,P=0}W.mode=G6;case G6:v=BW;break J;case h:v=g6;break J;case y6:return v6;case E6:default:return e}if(J.next_out=Y,J.avail_out=F,J.next_in=X,J.avail_in=U,W.hold=q,W.bits=P,W.wsize||z!==J.avail_out&&W.mode<h&&(W.mode<_1||Q!==E8)){if(u6(J,J.output,J.next_out,z-J.avail_out));}if($-=J.avail_in,z-=J.avail_out,J.total_in+=$,J.total_out+=z,W.total+=z,W.wrap&4&&z)J.adler=W.check=W.flags?_(W.check,V,z,J.next_out-z):s0(W.check,V,z,J.next_out-z);if(J.data_type=W.bits+(W.last?64:0)+(W.mode===X0?128:0)+(W.mode===j1||W.mode===c1?256:0),($===0&&z===0||Q===E8)&&v===I0)v=RW;return v},AW=(J)=>{if(O0(J))return e;let Q=J.state;if(Q.window)Q.window=null;return J.state=null,I0},NW=(J,Q)=>{if(O0(J))return e;const W=J.state;if((W.wrap&2)===0)return e;return W.head=Q,Q.done=!1,I0},SW=(J,Q)=>{const W=Q.length;let G,V,X;if(O0(J))return e;if(G=J.state,G.wrap!==0&&G.mode!==I1)return e;if(G.mode===I1){if(V=1,V=s0(V,Q,W,0),V!==G.check)return g6}if(X=u6(J,Q,W,W),X)return G.mode=y6,v6;return G.havedict=1,I0},TW=h6,gW=p6,vW=f6,yW=OW,EW=b6,fW=DW,hW=AW,pW=NW,bW=SW,uW="pako inflate (from Nodeca project)",U0={inflateReset:TW,inflateReset2:gW,inflateResetKeep:vW,inflateInit:yW,inflateInit2:EW,inflate:fW,inflateEnd:hW,inflateGetHeader:pW,inflateSetDictionary:bW,inflateInfo:uW},cW=mW,m6=Object.prototype.toString,{Z_NO_FLUSH:_W,Z_FINISH:dW,Z_OK:Q1,Z_STREAM_END:l1,Z_NEED_DICT:n1,Z_STREAM_ERROR:iW,Z_DATA_ERROR:q6,Z_MEM_ERROR:lW}=x0;q1.prototype.push=function(J,Q){const W=this.strm,G=this.options.chunkSize,V=this.options.dictionary;let X,Y,U;if(this.ended)return!1;if(Q===~~Q)Y=Q;else Y=Q===!0?dW:_W;if(m6.call(J)==="[object ArrayBuffer]")W.input=new Uint8Array(J);else W.input=J;W.next_in=0,W.avail_in=W.input.length;for(;;){if(W.avail_out===0)W.output=new Uint8Array(G),W.next_out=0,W.avail_out=G;if(X=U0.inflate(W,Y),X===n1&&V){if(X=U0.inflateSetDictionary(W,V),X===Q1)X=U0.inflate(W,Y);else if(X===q6)X=n1}while(W.avail_in>0&&X===l1&&W.state.wrap>0&&J[W.next_in]!==0)U0.inflateReset(W),X=U0.inflate(W,Y);switch(X){case iW:case q6:case n1:case lW:return this.onEnd(X),this.ended=!0,!1}if(U=W.avail_out,W.next_out){if(W.avail_out===0||X===l1)if(this.options.to==="string"){let F=W1.utf8border(W.output,W.next_out),q=W.next_out-F,P=W1.buf2string(W.output,F);if(W.next_out=q,W.avail_out=G-q,q)W.output.set(W.output.subarray(F,F+q),0);this.onData(P)}else this.onData(W.output.length===W.next_out?W.output:W.output.subarray(0,W.next_out))}if(X===Q1&&U===0)continue;if(X===l1)return X=U0.inflateEnd(this.strm),this.onEnd(X),this.ended=!0,!0;if(W.avail_in===0)break}return!0};q1.prototype.onData=function(J){this.chunks.push(J)};q1.prototype.onEnd=function(J){if(J===Q1)if(this.options.to==="string")this.result=this.chunks.join("");else this.result=O1.flattenChunks(this.chunks);this.chunks=[],this.err=J,this.msg=this.strm.msg};var rW=q1,oW=P8,aW=nW,eW=P8,tW=x0,sW={Inflate:rW,inflate:oW,inflateRaw:aW,ungzip:eW,constants:tW},{Deflate:J7,deflate:W7,deflateRaw:Q7,gzip:G7}=UW,{Inflate:V7,inflate:X7,inflateRaw:q7,ungzip:U7}=sW,Y7=J7,P7=W7,K7=Q7,F7=G7,z7=V7,Z7=X7,H7=q7,k7=U7,$7=x0,w0={Deflate:Y7,deflate:P7,deflateRaw:K7,gzip:F7,Inflate:z7,inflate:Z7,inflateRaw:H7,ungzip:k7,constants:$7};function c6(J,Q,W){let G=Q.timestamp;if(G?.physical>Date.now()+7200000)G={physical:Date.now()+7200000,logical:G.logical};if(Q?.value?.priority===!0&&typeof Q.id==="string"&&Q.id.startsWith("user:")&&("role"in Q.value)){const{priority:V,...X}=Q.value;return{resolved:!0,value:X,timestamp:G}}if(Q?.value?.priority!==void 0){const{priority:V,...X}=Q.value;Q={...Q,value:X}}if(!J?.timestamp)return{resolved:!0,value:Q.value,timestamp:G};if(W.compare(G,J.timestamp)<=0)return{resolved:!1};return{resolved:!0,value:Q.value,timestamp:G}}function _6(J,Q=50){const W=`gdb_oplog_${J}`;let G=[];function V(){try{const Y=localStorage.getItem(W);G=Y?JSON.parse(Y):[]}catch(Y){console.error("\u274C GDB: Failed to load oplog from localStorage:",Y),G=[]}}function X(){try{localStorage.setItem(W,JSON.stringify(G))}catch(Y){console.error("\u274C GDB: Failed to save oplog to localStorage:",Y)}}return V(),{remove(Y){G=G.filter((U)=>U.id!==Y),X()},add(Y){if(G.push(Y),G.length>Q)G.shift();X()},getDelta(Y,U){if(!Y)return[...G];return G.filter((F)=>U(F.timestamp,Y)>0)},getOldest(){return G[0]},clear(){G=[],localStorage.removeItem(W)}}}var B7=()=>{const J=new Map,Q=async()=>{try{const F=await navigator.storage.getDirectory(),P=await(await F.getFileHandle("~opfs-sync-test",{create:!0})).createSyncAccessHandle?.();return await P?.close(),await F.removeEntry("~opfs-sync-test"),!!P}catch{return!1}};let W="idb";const G=(async()=>{if(await Q())W="sync";else try{const F=await navigator.storage.getDirectory(),P=await(await F.getFileHandle("~opfs-async-test",{create:!0})).createWritable?.();if(await P?.close(),await F.removeEntry("~opfs-async-test"),P)W="async";else W="idb"}catch{W="idb"}})(),V=async(F,q)=>{if(!J.has(F))J.set(F,[]);const P=J.get(F),$=P[P.length-1]||Promise.resolve();let z;const K=new Promise((k)=>z=k);P.push(K);try{return await $,await q()}finally{if(P.shift(),z(),P.length===0)J.delete(F)}},X=(()=>{let F;const q=async()=>{if(!F)F=new Promise((P,$)=>{const z=indexedDB.open("opfs-fallback-db",1);z.onupgradeneeded=()=>z.result.createObjectStore("files"),z.onsuccess=()=>P(z.result),z.onerror=()=>$(z.error)});return F};return{getDB:q,get:async(P)=>{const $=await q();return new Promise((z,K)=>{const O=$.transaction("files","readonly").objectStore("files").get(P);O.onsuccess=()=>z(O.result||new Uint8Array),O.onerror=()=>K(O.error)})},set:async(P,$)=>{const z=await q();return new Promise((K,k)=>{const w=z.transaction("files","readwrite").objectStore("files").put($,P);w.onsuccess=()=>K(),w.onerror=()=>k(w.error)})}}})(),Y=async(F)=>{await G;try{if(W==="idb"){const K=await X.get(F);return{type:"loaded",name:F,data:K}}const P=await(await navigator.storage.getDirectory()).getFileHandle(F);if(W==="sync"){let K;try{K=await P.createSyncAccessHandle();const k=K.getSize(),O=new Uint8Array(k),w=K.read(O,{at:0});return{type:"loaded",name:F,data:O.slice(0,w)}}finally{K?.close()}}const $=await P.getFile(),z=new Uint8Array(await $.arrayBuffer());return{type:"loaded",name:F,data:z}}catch(q){if(q.name==="NotFoundError")return{type:"loaded",name:F,data:new Uint8Array};return console.error(`\u274C Worker file load error for '${F}':`,q),{type:"error",name:F,message:q.message||"Error reading file"}}},U=async(F,q)=>{if(await G,!(q instanceof Uint8Array))return{type:"error",name:F,message:"Content must be a Uint8Array"};return V(F,async()=>{try{if(W==="idb")return await X.set(F,q),{type:"saved",name:F};const $=await(await navigator.storage.getDirectory()).getFileHandle(F,{create:!0});if(W==="sync"){let z;try{z=await $.createSyncAccessHandle(),z.truncate(0),z.write(q,{at:0}),z.flush()}finally{z?.close()}}else{let z;try{z=await $.createWritable(),await z.write(q)}finally{await z?.close()}}return{type:"saved",name:F}}catch(P){return{type:"error",name:F,message:P.message||"Error saving file"}}})};self.onmessage=async({data:F})=>{const{type:q,name:P,content:$}=F;await G;const z={load:()=>Y(P),save:()=>U(P,$)};try{const K=z[q],k=K?await K():{type:"error",message:`Unrecognized action type: ${q}`};self.postMessage(k)}catch(K){console.error("\u274C Worker unexpected error:",K),self.postMessage({type:"error",name:P,message:K.message||"Unexpected worker error"})}}},d6=B7;var U1={$eq:(J,Q)=>J===Q,$ne:(J,Q)=>J!==Q,$gt:(J,Q)=>J>Q,$gte:(J,Q)=>J>=Q,$lt:(J,Q)=>J<Q,$lte:(J,Q)=>J<=Q,$in:(J,Q)=>Array.isArray(Q)&&(Array.isArray(J)?J.some((W)=>Q.includes(W)):Q.includes(J)),$between:(J,[Q,W])=>J>=Q&&J<=W,$exists:(J,Q)=>Q?J!==void 0:J===void 0,$startsWith:(J,Q)=>typeof J==="string"&&J.startsWith(Q),$endsWith:(J,Q)=>typeof J==="string"&&J.endsWith(Q),$contains:(J,Q)=>typeof J==="string"&&J.includes(Q),$text:{global:(J,Q)=>{const W=(V)=>String(V).normalize("NFD").replace(/[\u0300-\u036f]/g,"").toLowerCase().replace(/[^\w\s]/g,""),G=W(Q);return Object.values(J).some((V)=>typeof V==="object"?null.fieldSearch(V,G):W(V).includes(G))},field:(J,Q)=>{const W=(V)=>String(V).normalize("NFD").replace(/[\u0300-\u036f]/g,"").toLowerCase().replace(/[^\w\s]/g,""),G=W(Q);return Array.isArray(J)?J.some((V)=>W(V).includes(G)):W(J).includes(G)}},$like:(J,Q)=>typeof J==="string"&&typeof Q==="string"&&new RegExp(`^${Q.replace(/%/g,".*").replace(/_/g,".")}\$`,"i").test(J),$regex:(J,Q)=>typeof J==="string"&&new RegExp(Q.$regex||Q,"i").test(J),$and:(J,Q,W)=>Q.every((G)=>W.createFilter(G,W.allNodes)(J)),$or:(J,Q,W)=>Q.some((G)=>W.createFilter(G,W.allNodes)(J)),$not:(J,Q,W)=>!W.createFilter(Q,W.allNodes)(J),$edge:(J,Q,W)=>{if(!J.edges?.length||typeof Q!=="object"||Q===null)return!1;const G=W.createFilter(Q,W.allNodes),V=[...J.edges],X=new Set(V).add(J.id),Y=[];while(V.length){const U=V.shift(),F=W.allNodes[U];if(!F)continue;if(G(F))Y.push(F);F.edges?.forEach((q)=>!X.has(q)&&X.add(q)&&V.push(q))}if(Y.length)J._edgeResult=Y;return Y.length>0}},D1=(J,Q)=>Q.split(".").reduce((W,G)=>W&&typeof W==="object"&&(G in W)?W[G]:void 0,J),A1=(J,Q)=>{if(Object.keys(J).length===0)return()=>!0;return(W)=>Object.entries(J).every(([G,V])=>{if(G.startsWith("$"))return U1[G](W,V,{createFilter:A1,allNodes:Q});let X=D1(W.value,G);if(X===void 0)X=D1(W,G);if(typeof V!=="object"||V===null)return U1.$eq(X,V);return Object.entries(V).every(([Y,U])=>{if(Y==="$text")return U1.$text.field(X,U);if(Y==="$between"&&U.every((F)=>F instanceof Date))return U1.$between(new Date(X),U);return U1[Y]?.(X,U,{createFilter:A1,allNodes:Q})??!1})})},K8=(J,Q)=>{const{$edge:W,...G}=Q.query||{},V=A1(G,J),X=Object.values(J).filter(V);let U=[...W?(()=>{const F=A1({$edge:W},J);X.forEach((P)=>F(P));const q=new Map;return X.forEach((P)=>{if(P._edgeResult)P._edgeResult.forEach(($)=>q.set($.id,$)),delete P._edgeResult}),Array.from(q.values())})():X];if(Q.field){const F=Q.order==="asc"?1:-1;U.sort((q,P)=>{const $=D1(q.value,Q.field),z=D1(P.value,Q.field);if(typeof $==="string"&&typeof z==="string")return $.localeCompare(z)*F;return(($??0)-(z??0))*F})}if(Q.$after){const F=U.findIndex((q)=>q.id===Q.$after);U=F>=0?U.slice(F+1):[]}if(Q.$before){const F=U.findIndex((q)=>q.id===Q.$before);U=F>=0?U.slice(0,F):[]}if(Q.$limit)U=U.slice(0,Q.$limit);return U};function i6(){let J=Date.now(),Q=0;return{now(){const W=Date.now();return J=Math.max(J,W),Q++,{physical:J,logical:Q}},update(W){if(!W||typeof W.physical!=="number"||typeof W.logical!=="number"){console.warn("\u26A0\uFE0F HybridClock.update received an invalid remote timestamp.",W);return}J=Math.max(J,W.physical),Q=Math.max(Q,W.logical)+1},compare(W,G){if(!W&&!G)return 0;if(!W)return-1;if(!G)return 1;if(W.physical>G.physical)return 1;if(W.physical<G.physical)return-1;if(W.logical>G.logical)return 1;if(W.logical<G.logical)return-1;return 0}}}async function R7(){if(console.info(navigator?.storage?.getDirectory?"\u2705 OPFS is enabled.":"\uD83D\uDEAB OPFS is not available."),navigator?.storage?.getDirectory)await navigator.storage.getDirectory()}var M7=function(){const J={nodes:{}};return{get nodes(){return J.nodes},set nodes(Q){J.nodes=Q||{}},upsert(Q,W,G){const V=J.nodes[Q];J.nodes[Q]={id:Q,value:W&&typeof W==="object"?F8(W):W,edges:V?.edges?[...V.edges]:[],timestamp:G}},get(Q){return J.nodes[Q]||null},link(Q,W,G){const V=J.nodes[Q],X=J.nodes[W];if(V&&X&&!V.edges.includes(W))J.nodes[Q]={...V,edges:[...V.edges,W],timestamp:G}},getAllNodes(){return Object.values(J.nodes)},serialize(){return w0.deflate(u0(J.nodes))},deserialize(Q){J.nodes=B0(w0.inflate(new Uint8Array(Q)))}}};async function r6(J,Q={}){console.info("\x1B[36m\u26A1 GenosDB: Empowering distributed graph databases with real-time synchronization and scalability. Learn more: https://github.com/estebanrfp/gdb \u26A1\x1B[0m");const{rtc:W=!1,password:G,sm:V=!1,audit:X=!1,ii:Y=!1,rx:U=!1,ai:F=!1,geo:q=!1,nlq:P=!1,saveDelay:$=200,oplogSize:z=20}=Q,K=M7(),k=i6(),O=_6(J,z),w=[];let R=null,A=[],L=null,H=null,T=null,p=null;const j=[],v={};Object.defineProperties(v,{syncChannel:{get:()=>H},broadcastChannel:{get:()=>T},hybridClock:{get:()=>k},graph:{get:()=>({getAllNodes:()=>K.getAllNodes(),get:(B)=>K.get(B)})},worker:{get:()=>L},oplog:{get:()=>O},options:{get:()=>Q},pako:{get:()=>w0},encode:{get:()=>u0},decode:{get:()=>B0},deepClone:{get:()=>F8}});async function D(B,x){try{const M=await import(new URL(`./${B}.min.js`,import.meta.url).href),f=x&&typeof x==="object"?x:{},b=await M.init?.(v,M,f);if(b)Object.assign(v,b);return M}catch(M){throw console.error(`\u274C Initialization of ${B} failed:`,M),M}}function I(){const B=localStorage.getItem(`${J}_time`);R=B?JSON.parse(B):null}function N(B){R=B,localStorage.setItem(`${J}_time`,JSON.stringify(B))}function V0(){try{const B=URL.createObjectURL(new Blob([`(${d6.toString()})()`],{type:"application/javascript"}));L=new Worker(B),URL.revokeObjectURL(B),L.addEventListener("message",({data:x})=>console.info(`\uD83D\uDCBE ${x.name} ${x.type}`)),console.info("\u2699\uFE0F Worker initialized successfully.")}catch({message:B}){console.error("\u274C Failed to initialize worker:",B)}}function p0(){const B={...K.nodes};A.forEach((x)=>x(B))}const s=j7(()=>p0()),Y0=n6(async()=>{const B=j.splice(0,j.length);if(!B.length)return!1;return await H.send(B),!0},16);async function z8(){try{const x=await((M)=>new Promise((f,b)=>{const y=async({data:Z})=>{if(Z.type==="loaded"&&Z.name===M)L.removeEventListener("message",y),f(new Uint8Array(Z.data));else if(Z.type==="error")L.removeEventListener("message",y),b(new Error(Z.message||"Unknown error"))};L.addEventListener("message",y),L.postMessage({type:"load",name:M})}))(`${J}_graph.msgpack`).catch(()=>new Uint8Array);x.byteLength>0?K.deserialize(x):console.info("\uD83D\uDCBE New database. File will be created on first save.")}catch({message:B}){console.error("\u274C Error loading the graph:",B)}}async function o6(){try{const B=K.serialize();return await((M,f)=>new Promise((b,y)=>{const Z=({data:S})=>{if(S.type==="saved"&&S.name===M)L.removeEventListener("message",Z),b();else if(S.type==="error")L.removeEventListener("message",Z),y(new Error(S.message||"Save error"))};L.addEventListener("message",Z),L.postMessage({type:"save",name:M,content:f})}))(`${J}_graph.msgpack`,B),T.postMessage("update"),!0}catch({message:B}){throw console.error("\u274C Save error:",B),new Error("Save failed")}}const Y1=n6(()=>o6(),$);async function a6(B){let x=!1,M=null;const f=(Z)=>{if(!M||k.compare(Z,M)>0)M=Z},b=(Z)=>{try{if(Z instanceof Uint8Array)return B0(w0.inflate(Z));if(Array.isArray(Z))return Z;if(Z&&typeof Z==="object")return B0(w0.inflate(new Uint8Array(Object.values(Z))))}catch(S){console.error("\u274C deltaSync decode failed",S)}return null},y={upsert:(Z)=>{const S=K.get(Z.id),{resolved:C,value:m,timestamp:c}=c6(S,Z,k);if(!C)return;K.upsert(Z.id,m,c),k.update(c),O.add({type:"upsert",id:Z.id,timestamp:c}),x=!0,f(c)},remove:(Z)=>{const S=K.get(Z.id);if(!S||k.compare(S.timestamp,Z.timestamp)>=0)return;delete K.nodes[Z.id],k.update(Z.timestamp),O.add({type:"remove",id:Z.id,timestamp:Z.timestamp}),x=!0,f(Z.timestamp)},link:(Z)=>{const S=K.get(Z.sourceId),C=K.get(Z.targetId);if(!S||!C||k.compare(S.timestamp,Z.timestamp)>=0)return;K.link(Z.sourceId,Z.targetId,Z.timestamp),k.update(Z.timestamp),O.add({type:"link",...Z}),x=!0,f(Z.timestamp)},sync:async({timestamp:Z})=>{const S=O.getOldest();if(Z==null||S&&k.compare(Z,S.timestamp)<0)return console.info("\uD83D\uDCA5 [FALLBACK] Peer too far behind \u2192 sending FULL state."),H.send([{type:"fullStateSync",graphData:K.serialize(),timestamp:R}]);const m=O.getDelta(Z,k.compare);if(!m.length)return;const c=m.map((t)=>t.type==="upsert"?{...t,value:K.get(t.id)?.value}:t);console.info(`\uD83D\uDE80 [DELTA SYNC SENDING] ${c.length} ops.`),await H.send([{type:"deltaSync",operations:w0.deflate(u0(c)),timestamp:R}])},deltaSync:({operations:Z})=>{const S=b(Z);if(!Array.isArray(S)){console.warn("\u26A0\uFE0F deltaSync payload not array. Ignored.");return}console.log(`\uD83D\uDEF0\uFE0F [DELTA SYNC RECEIVED] ${S.length} ops.`);for(let C of S)if(C&&y[C.type])y[C.type](C);else if(C)console.warn(`\uD83E\uDD37 Unknown op: ${C.type}`)},fullStateSync:async({graphData:Z,timestamp:S})=>{if(R&&S&&k.compare(R,S)>0){console.log("\uD83D\uDD04 Local newer, ignoring full sync.");return}if(!(Z instanceof Uint8Array))if(Z&&typeof Z==="object")Z=new Uint8Array(Object.values(Z));else{console.error("\u274C Invalid full graph data received");return}try{if(console.log("\uD83D\uDCE6 [FULL SYNC RECEIVED] Applying full graph."),K.deserialize(Z),O.clear(),x=!0,S)f(S),k.update(S)}catch(C){console.error("\u274C Full sync failed:",C)}}};for(let Z of B)if(y[Z.type])await y[Z.type](Z);else console.warn(`\uD83E\uDD37 Unknown type: ${Z.type}`);if(M&&(!R||k.compare(M,R)>0))console.info(`\uD83D\uDCC8 [GLOBAL TS] Advanced to ${M.logical}`),N(M);if(x)console.info("\uD83D\uDCBE [STATE CHANGED] Saving + emitting."),await Y1(),s()}Object.assign(v,{use(B){if(typeof B==="function")w.push(B)},async put(B,x){const M=k.now();N(M),x=x??crypto.randomUUID(),K.upsert(x,B,M),O.add({type:"upsert",id:x,timestamp:M}),Y1();try{j.push({type:"upsert",id:x,value:B,timestamp:M}),Y0().catch(()=>{})}finally{s()}return x},async link(B,x){const M=k.now();if(!K.nodes[B]||!K.nodes[x]){console.warn(`\u26A0\uFE0F One or both nodes (${B}, ${x}) do not exist.`);return}K.link(B,x,M),O.add({type:"link",sourceId:B,targetId:x,timestamp:M}),Y1(),N(M);try{j.push({type:"link",sourceId:B,targetId:x,timestamp:M}),Y0().catch(()=>{})}finally{s()}},async remove(B){const x=k.now(),M=K.get(B);if(!M)return console.warn(`\u26A0\uFE0F Node with ID '${B}' not found.`);delete K.nodes[B],O.add({type:"remove",id:B,timestamp:x}),Object.values(K.nodes).forEach((f)=>f.edges=f.edges.filter((b)=>b!==B)),Y1(),N(x);try{j.push({type:"remove",id:B,value:M.value,timestamp:x}),Y0().catch(()=>{})}finally{s()}},async get(B,x=null){if(typeof B!=="string")return{result:null};const M=K.get(B);if(!M){if(x)x(null);return{result:null}}const f=(Z)=>{if(!Z)return null;const S=Z.value!==null&&typeof Z.value==="object"?{...Z.value}:Z.value;return{...Z,value:S}};if(!x)return{result:f(M)};let b=M.timestamp;x(f(M));const y=(Z)=>{const S=Z[B];if(S){if(k.compare(S.timestamp,b)>0)b=S.timestamp,x(f(S))}else x(null),A.splice(A.indexOf(y),1)};return A.push(y),{result:f(M),unsubscribe:()=>{const Z=A.indexOf(y);if(Z>-1)A.splice(Z,1)}}},async map(...B){let M={...{realtime:!1,query:{},field:null,order:"asc",$limit:null,$after:null,$before:null}},f=null,b=!1;B.forEach((C)=>typeof C==="function"?f=C:C&&typeof C==="object"&&(b=b||("realtime"in C),Object.assign(M,C))),f&&!b&&(M.realtime=!0);let y=K8(K.nodes,M),Z=null;const S=(C)=>{const m=new Map(y.map((u)=>[u.id,u])),c=new Map(C.map((u)=>[u.id,u])),t=[],D0=[],Z8=[];for(let[u,K0]of c){const P1=m.get(u);if(!P1)t.push(K0);else if((K0.timestamp?.physical||0)!==(P1.timestamp?.physical||0)||(K0.timestamp?.logical||0)!==(P1.timestamp?.logical||0)||!l6(K0.edges||[],P1.edges||[]))D0.push(K0)}for(let[u]of m)if(!c.has(u))Z8.push(m.get(u));const N1=(u,K0)=>f({id:u.id,value:K0==="removed"?null:u.value,edges:u.edges||[],timestamp:u.timestamp||null,action:K0});t.forEach((u)=>N1(u,"added")),Z8.forEach((u)=>N1(u,"removed")),D0.forEach((u)=>N1(u,"updated"))};if(f){if(y.forEach((C)=>{f({id:C.id,value:C.value,edges:C.edges,timestamp:C.timestamp,action:"initial"})}),M.realtime){const C=(m)=>{const c=m.timestamp?.physical||0,t=m.timestamp?.logical||0,D0=(m.edges||[]).join(",");return`${m.id}:${c}:${t}:${D0}`};Z=(m)=>{const c=K8(m,M);if(c.length!==y.length)S(c),y=c;else{const t=c.map(C),D0=y.map(C);if(!l6(t,D0))S(c),y=c}},A.push(Z)}}return{results:y,...M.realtime&&f&&Z&&{unsubscribe:()=>{const C=A.indexOf(Z);C>-1&&A.splice(C,1)}}}},async clear(){K.nodes={};try{await(await navigator.storage.getDirectory()).removeEntry(`${J}_graph.msgpack`)}catch({message:B}){console.warn(`\u26A0\uFE0F Error deleting _graph.msgpack: ${B}`)}p0(),console.info("\u2705 All data has been deleted.")}}),V0(),I(),await R7(),await z8();const P0=[];if(V)P0.push(D("sm",V));if(F)P0.push(D("ai",F));if(U)P0.push(D("rx",U));if(Y)P0.push(D("ii",Y));if(X)P0.push(D("audit",X));if(q)P0.push(D("geo",q));if(P)P0.push(D("nlq",P));await Promise.all(P0);const e6=`graph-sync-room-${J}`;if(W){const{join:B}=await D("genosrtc"),{relayUrls:x,turnConfig:M}=W?.constructor===Object?W:{},f={appId:"1234",...G&&{password:G}};if(x)f.relayUrls=x;if(M)f.turnConfig=M;const b=B(f,e6);H=b.channel("syncGraph"),p=B(f,`app-sync-${J}`),v.room=p,b.on("peer:join",async(y)=>{console.info("\u26A1 New peer connected:",y),H.send([{type:"sync",timestamp:R}])}),b.on("peer:leave",(y)=>{console.info("\u26A1 Peer disconnected:",y)}),H?.on("message",async(y)=>{let Z;try{if(y instanceof Uint8Array||y instanceof ArrayBuffer){const C=B0(y);Z=Array.isArray(C)?C:[C]}else Z=Array.isArray(y)?y:[y]}catch(C){return console.error("\u274C Failed to decode MessagePack:",C)}const S=new Map([...new Set(Z.flatMap((C)=>["id","sourceId","targetId"].map((m)=>C&&C[m]).filter(Boolean)))].map((C)=>K.get(C)?[C,F8(K.get(C))]:null).filter(Boolean));for(let C of w)try{if(Z=await C(Z,S),!Z||!Z.length)return}catch(m){console.error("\u274C Middleware error, discarding message.",m);return}await a6(Z)})}return T=new BroadcastChannel(`graphdb_sync_${J}`),T.onmessage=async(B)=>{if(B.data==="update")console.info("\uD83D\uDD04 Update received from another tab..."),await z8(),I(),s()},console.info(`\u2705 GenosDB [ \x1B[32m${J}\x1B[0m ] instance is ready.`),v}var l6=(J,Q)=>J.length===Q.length&&J.every((W,G)=>W===Q[G]),F8=(J)=>J&&typeof J==="object"?globalThis.structuredClone?.(J)??JSON.parse(JSON.stringify(J)):J,n6=(J,Q=16)=>{let W=null,G=null;return(...V)=>{if(!G)G={},G.promise=new Promise((Y,U)=>(G.resolve=Y,G.reject=U));if(W)("cancelIdleCallback"in window?cancelIdleCallback:clearTimeout)(W);const X=async()=>{W=null;try{G.resolve(await J(...V))}catch(Y){G.reject(Y)}finally{G=null}};return W=("requestIdleCallback"in window)?requestIdleCallback(X,{timeout:Q}):setTimeout(X,Q),G.promise}},j7=(J)=>{let Q=null;return()=>{if(Q!==null)return;Q=requestAnimationFrame(()=>{Q=null,J()})}};var jQ=r6;class L7{constructor(){throw new Error("\u26A0\uFE0F WARNING: `new GDB()` is deprecated and will be removed. "+"Migrate to async factory function `const db = await gdb(...)`.\nMigration Guide: https://github.com/estebanrfp/gdb/wiki/Migration-Guide\nWiki: https://github.com/estebanrfp/gdb/wiki")}}export{jQ as gdb,L7 as GDB};
