function $8(W){const Q=W.length;let J=0,V=0;while(V<Q){let G=W.charCodeAt(V++);if((G&4294967168)===0){J++;continue}else if((G&4294965248)===0)J+=2;else{if(G>=55296&&G<=56319){if(V<Q){const X=W.charCodeAt(V);if((X&64512)===56320)++V,G=((G&1023)<<10)+(X&1023)+65536}}if((G&4294901760)===0)J+=3;else J+=4}}return J}function J5(W,Q,J){const V=W.length;let G=J,X=0;while(X<V){let Y=W.charCodeAt(X++);if((Y&4294967168)===0){Q[G++]=Y;continue}else if((Y&4294965248)===0)Q[G++]=Y>>6&31|192;else{if(Y>=55296&&Y<=56319){if(X<V){const U=W.charCodeAt(X);if((U&64512)===56320)++X,Y=((Y&1023)<<10)+(U&1023)+65536}}if((Y&4294901760)===0)Q[G++]=Y>>12&15|224,Q[G++]=Y>>6&63|128;else Q[G++]=Y>>18&7|240,Q[G++]=Y>>12&63|128,Q[G++]=Y>>6&63|128}Q[G++]=Y&63|128}}function G5(W,Q,J){Q5.encodeInto(W,Q.subarray(J))}function B8(W,Q,J){if(W.length>V5)G5(W,Q,J);else J5(W,Q,J)}function v1(W,Q,J){let V=Q;const G=V+J,X=[];let Y="";while(V<G){const U=W[V++];if((U&128)===0)X.push(U);else if((U&224)===192){const K=W[V++]&63;X.push((U&31)<<6|K)}else if((U&240)===224){const K=W[V++]&63,q=W[V++]&63;X.push((U&31)<<12|K<<6|q)}else if((U&248)===240){const K=W[V++]&63,q=W[V++]&63,P=W[V++]&63;let k=(U&7)<<18|K<<12|q<<6|P;if(k>65535)k-=65536,X.push(k>>>10&1023|55296),k=56320|k&1023;X.push(k)}else X.push(U);if(X.length>=X5)Y+=String.fromCharCode(...X),X.length=0}if(X.length>0)Y+=String.fromCharCode(...X);return Y}function Y5(W,Q,J){const V=W.subarray(Q,Q+J);return q5.decode(V)}function C8(W,Q,J){if(J>U5)return Y5(W,Q,J);else return v1(W,Q,J)}var Q5=new TextEncoder,V5=50,X5=4096,q5=new TextDecoder,U5=200;class D0{constructor(W,Q){this.type=W,this.data=Q}}class d extends Error{constructor(W){super(W);const Q=Object.create(d.prototype);Object.setPrototypeOf(this,Q),Object.defineProperty(this,"name",{configurable:!0,enumerable:!1,value:d.name})}}function j8(W,Q,J){const V=J/4294967296,G=J;W.setUint32(Q,V),W.setUint32(Q+4,G)}function P1(W,Q,J){const V=Math.floor(J/4294967296),G=J;W.setUint32(Q,V),W.setUint32(Q+4,G)}function K1(W,Q){const J=W.getInt32(Q),V=W.getUint32(Q+4);return J*4294967296+V}function R8(W,Q){const J=W.getUint32(Q),V=W.getUint32(Q+4);return J*4294967296+V}var A0=4294967295;function z5({sec:W,nsec:Q}){if(W>=0&&Q>=0&&W<=F5)if(Q===0&&W<=K5){const J=new Uint8Array(4);return new DataView(J.buffer).setUint32(0,W),J}else{const J=W/4294967296,V=W&4294967295,G=new Uint8Array(8),X=new DataView(G.buffer);return X.setUint32(0,Q<<2|J&3),X.setUint32(4,V),G}else{const J=new Uint8Array(12),V=new DataView(J.buffer);return V.setUint32(0,Q),P1(V,4,W),J}}function Z5(W){const Q=W.getTime(),J=Math.floor(Q/1000),V=(Q-J*1000)*1e6,G=Math.floor(V/1e9);return{sec:J+G,nsec:V-G*1e9}}function H5(W){if(W instanceof Date){const Q=Z5(W);return z5(Q)}else return null}function k5(W){const Q=new DataView(W.buffer,W.byteOffset,W.byteLength);switch(W.byteLength){case 4:return{sec:Q.getUint32(0),nsec:0};case 8:{const J=Q.getUint32(0),V=Q.getUint32(4),G=(J&3)*4294967296+V,X=J>>>2;return{sec:G,nsec:X}}case 12:{const J=K1(Q,4),V=Q.getUint32(0);return{sec:J,nsec:V}}default:throw new d(`Unrecognized data size for timestamp (expected 4, 8, or 12): ${W.length}`)}}function $5(W){const Q=k5(W);return new Date(Q.sec*1000+Q.nsec/1e6)}var P5=-1,K5=4294967295,F5=17179869183,M8={type:P5,encode:H5,decode:$5};class $0{constructor(){this.builtInEncoders=[],this.builtInDecoders=[],this.encoders=[],this.decoders=[],this.register(M8)}register({type:W,encode:Q,decode:J}){if(W>=0)this.encoders[W]=Q,this.decoders[W]=J;else{const V=-1-W;this.builtInEncoders[V]=Q,this.builtInDecoders[V]=J}}tryToEncode(W,Q){for(let J=0;J<this.builtInEncoders.length;J++){const V=this.builtInEncoders[J];if(V!=null){const G=V(W,Q);if(G!=null){const X=-1-J;return new D0(X,G)}}}for(let J=0;J<this.encoders.length;J++){const V=this.encoders[J];if(V!=null){const G=V(W,Q);if(G!=null)return new D0(J,G)}}if(W instanceof D0)return W;return null}decode(W,Q,J){const V=Q<0?this.builtInDecoders[-1-Q]:this.decoders[Q];if(V)return V(W,Q,J);else return new D0(Q,W)}}$0.defaultCodec=new $0;var B5=function(W){return W instanceof ArrayBuffer||typeof SharedArrayBuffer!=="undefined"&&W instanceof SharedArrayBuffer};function b0(W){if(W instanceof Uint8Array)return W;else if(ArrayBuffer.isView(W))return new Uint8Array(W.buffer,W.byteOffset,W.byteLength);else if(B5(W))return new Uint8Array(W);else return Uint8Array.from(W)}var C5=100,j5=2048;class F1{constructor(W){this.entered=!1,this.extensionCodec=W?.extensionCodec??$0.defaultCodec,this.context=W?.context,this.useBigInt64=W?.useBigInt64??!1,this.maxDepth=W?.maxDepth??C5,this.initialBufferSize=W?.initialBufferSize??j5,this.sortKeys=W?.sortKeys??!1,this.forceFloat32=W?.forceFloat32??!1,this.ignoreUndefined=W?.ignoreUndefined??!1,this.forceIntegerToFloat=W?.forceIntegerToFloat??!1,this.pos=0,this.view=new DataView(new ArrayBuffer(this.initialBufferSize)),this.bytes=new Uint8Array(this.view.buffer)}clone(){return new F1({extensionCodec:this.extensionCodec,context:this.context,useBigInt64:this.useBigInt64,maxDepth:this.maxDepth,initialBufferSize:this.initialBufferSize,sortKeys:this.sortKeys,forceFloat32:this.forceFloat32,ignoreUndefined:this.ignoreUndefined,forceIntegerToFloat:this.forceIntegerToFloat})}reinitializeState(){this.pos=0}encodeSharedRef(W){if(this.entered)return this.clone().encodeSharedRef(W);try{return this.entered=!0,this.reinitializeState(),this.doEncode(W,1),this.bytes.subarray(0,this.pos)}finally{this.entered=!1}}encode(W){if(this.entered)return this.clone().encode(W);try{return this.entered=!0,this.reinitializeState(),this.doEncode(W,1),this.bytes.slice(0,this.pos)}finally{this.entered=!1}}doEncode(W,Q){if(Q>this.maxDepth)throw new Error(`Too deep objects in depth ${Q}`);if(W==null)this.encodeNil();else if(typeof W==="boolean")this.encodeBoolean(W);else if(typeof W==="number")if(!this.forceIntegerToFloat)this.encodeNumber(W);else this.encodeNumberAsFloat(W);else if(typeof W==="string")this.encodeString(W);else if(this.useBigInt64&&typeof W==="bigint")this.encodeBigInt64(W);else this.encodeObject(W,Q)}ensureBufferSizeToWrite(W){const Q=this.pos+W;if(this.view.byteLength<Q)this.resizeBuffer(Q*2)}resizeBuffer(W){const Q=new ArrayBuffer(W),J=new Uint8Array(Q),V=new DataView(Q);J.set(this.bytes),this.view=V,this.bytes=J}encodeNil(){this.writeU8(192)}encodeBoolean(W){if(W===!1)this.writeU8(194);else this.writeU8(195)}encodeNumber(W){if(!this.forceIntegerToFloat&&Number.isSafeInteger(W))if(W>=0)if(W<128)this.writeU8(W);else if(W<256)this.writeU8(204),this.writeU8(W);else if(W<65536)this.writeU8(205),this.writeU16(W);else if(W<4294967296)this.writeU8(206),this.writeU32(W);else if(!this.useBigInt64)this.writeU8(207),this.writeU64(W);else this.encodeNumberAsFloat(W);else if(W>=-32)this.writeU8(224|W+32);else if(W>=-128)this.writeU8(208),this.writeI8(W);else if(W>=-32768)this.writeU8(209),this.writeI16(W);else if(W>=-2147483648)this.writeU8(210),this.writeI32(W);else if(!this.useBigInt64)this.writeU8(211),this.writeI64(W);else this.encodeNumberAsFloat(W);else this.encodeNumberAsFloat(W)}encodeNumberAsFloat(W){if(this.forceFloat32)this.writeU8(202),this.writeF32(W);else this.writeU8(203),this.writeF64(W)}encodeBigInt64(W){if(W>=BigInt(0))this.writeU8(207),this.writeBigUint64(W);else this.writeU8(211),this.writeBigInt64(W)}writeStringHeader(W){if(W<32)this.writeU8(160+W);else if(W<256)this.writeU8(217),this.writeU8(W);else if(W<65536)this.writeU8(218),this.writeU16(W);else if(W<4294967296)this.writeU8(219),this.writeU32(W);else throw new Error(`Too long string: ${W} bytes in UTF-8`)}encodeString(W){const J=$8(W);this.ensureBufferSizeToWrite(5+J),this.writeStringHeader(J),B8(W,this.bytes,this.pos),this.pos+=J}encodeObject(W,Q){const J=this.extensionCodec.tryToEncode(W,this.context);if(J!=null)this.encodeExtension(J);else if(Array.isArray(W))this.encodeArray(W,Q);else if(ArrayBuffer.isView(W))this.encodeBinary(W);else if(typeof W==="object")this.encodeMap(W,Q);else throw new Error(`Unrecognized object: ${Object.prototype.toString.apply(W)}`)}encodeBinary(W){const Q=W.byteLength;if(Q<256)this.writeU8(196),this.writeU8(Q);else if(Q<65536)this.writeU8(197),this.writeU16(Q);else if(Q<4294967296)this.writeU8(198),this.writeU32(Q);else throw new Error(`Too large binary: ${Q}`);const J=b0(W);this.writeU8a(J)}encodeArray(W,Q){const J=W.length;if(J<16)this.writeU8(144+J);else if(J<65536)this.writeU8(220),this.writeU16(J);else if(J<4294967296)this.writeU8(221),this.writeU32(J);else throw new Error(`Too large array: ${J}`);for(let V of W)this.doEncode(V,Q+1)}countWithoutUndefined(W,Q){let J=0;for(let V of Q)if(W[V]!==void 0)J++;return J}encodeMap(W,Q){const J=Object.keys(W);if(this.sortKeys)J.sort();const V=this.ignoreUndefined?this.countWithoutUndefined(W,J):J.length;if(V<16)this.writeU8(128+V);else if(V<65536)this.writeU8(222),this.writeU16(V);else if(V<4294967296)this.writeU8(223),this.writeU32(V);else throw new Error(`Too large map object: ${V}`);for(let G of J){const X=W[G];if(!(this.ignoreUndefined&&X===void 0))this.encodeString(G),this.doEncode(X,Q+1)}}encodeExtension(W){if(typeof W.data==="function"){const J=W.data(this.pos+6),V=J.length;if(V>=4294967296)throw new Error(`Too large extension object: ${V}`);this.writeU8(201),this.writeU32(V),this.writeI8(W.type),this.writeU8a(J);return}const Q=W.data.length;if(Q===1)this.writeU8(212);else if(Q===2)this.writeU8(213);else if(Q===4)this.writeU8(214);else if(Q===8)this.writeU8(215);else if(Q===16)this.writeU8(216);else if(Q<256)this.writeU8(199),this.writeU8(Q);else if(Q<65536)this.writeU8(200),this.writeU16(Q);else if(Q<4294967296)this.writeU8(201),this.writeU32(Q);else throw new Error(`Too large extension object: ${Q}`);this.writeI8(W.type),this.writeU8a(W.data)}writeU8(W){this.ensureBufferSizeToWrite(1),this.view.setUint8(this.pos,W),this.pos++}writeU8a(W){const Q=W.length;this.ensureBufferSizeToWrite(Q),this.bytes.set(W,this.pos),this.pos+=Q}writeI8(W){this.ensureBufferSizeToWrite(1),this.view.setInt8(this.pos,W),this.pos++}writeU16(W){this.ensureBufferSizeToWrite(2),this.view.setUint16(this.pos,W),this.pos+=2}writeI16(W){this.ensureBufferSizeToWrite(2),this.view.setInt16(this.pos,W),this.pos+=2}writeU32(W){this.ensureBufferSizeToWrite(4),this.view.setUint32(this.pos,W),this.pos+=4}writeI32(W){this.ensureBufferSizeToWrite(4),this.view.setInt32(this.pos,W),this.pos+=4}writeF32(W){this.ensureBufferSizeToWrite(4),this.view.setFloat32(this.pos,W),this.pos+=4}writeF64(W){this.ensureBufferSizeToWrite(8),this.view.setFloat64(this.pos,W),this.pos+=8}writeU64(W){this.ensureBufferSizeToWrite(8),j8(this.view,this.pos,W),this.pos+=8}writeI64(W){this.ensureBufferSizeToWrite(8),P1(this.view,this.pos,W),this.pos+=8}writeBigUint64(W){this.ensureBufferSizeToWrite(8),this.view.setBigUint64(this.pos,W),this.pos+=8}writeBigInt64(W){this.ensureBufferSizeToWrite(8),this.view.setBigInt64(this.pos,W),this.pos+=8}}function N0(W,Q){return new F1(Q).encodeSharedRef(W)}function z1(W){return`${W<0?"-":""}0x${Math.abs(W).toString(16).padStart(2,"0")}`}var R5=16,M5=16;class T1{constructor(W=R5,Q=M5){this.hit=0,this.miss=0,this.maxKeyLength=W,this.maxLengthPerKey=Q,this.caches=[];for(let J=0;J<this.maxKeyLength;J++)this.caches.push([])}canBeCached(W){return W>0&&W<=this.maxKeyLength}find(W,Q,J){const V=this.caches[J-1];W:for(let G of V){const X=G.bytes;for(let Y=0;Y<J;Y++)if(X[Y]!==W[Q+Y])continue W;return G.str}return null}store(W,Q){const J=this.caches[W.length-1],V={bytes:W,str:Q};if(J.length>=this.maxLengthPerKey)J[Math.random()*J.length|0]=V;else J.push(V)}decode(W,Q,J){const V=this.find(W,Q,J);if(V!=null)return this.hit++,V;this.miss++;const G=v1(W,Q,J),X=Uint8Array.prototype.slice.call(W,Q,Q+J);return this.store(X,G),G}}var g1="array",m0="map_key",x8="map_value",L5=(W)=>{if(typeof W==="string"||typeof W==="number")return W;throw new d("The type of key must be string or number but "+typeof W)};class I8{constructor(){this.stack=[],this.stackHeadPosition=-1}get length(){return this.stackHeadPosition+1}top(){return this.stack[this.stackHeadPosition]}pushArrayState(W){const Q=this.getUninitializedStateFromPool();Q.type=g1,Q.position=0,Q.size=W,Q.array=new Array(W)}pushMapState(W){const Q=this.getUninitializedStateFromPool();Q.type=m0,Q.readCount=0,Q.size=W,Q.map={}}getUninitializedStateFromPool(){if(this.stackHeadPosition++,this.stackHeadPosition===this.stack.length){const W={type:void 0,size:0,array:void 0,position:0,readCount:0,map:void 0,key:null};this.stack.push(W)}return this.stack[this.stackHeadPosition]}release(W){if(this.stack[this.stackHeadPosition]!==W)throw new Error("Invalid stack state. Released state is not on top of the stack.");if(W.type===g1){const J=W;J.size=0,J.array=void 0,J.position=0,J.type=void 0}if(W.type===m0||W.type===x8){const J=W;J.size=0,J.map=void 0,J.readCount=0,J.type=void 0}this.stackHeadPosition--}reset(){this.stack.length=0,this.stackHeadPosition=-1}}var u0=-1,y1=new DataView(new ArrayBuffer(0)),x5=new Uint8Array(y1.buffer);try{y1.getInt8(0)}catch(W){if(!(W instanceof RangeError))throw new Error("This module is not supported in the current JavaScript engine because DataView does not throw RangeError on out-of-bounds access")}var L8=new RangeError("Insufficient data"),I5=new T1;class Z1{constructor(W){this.totalPos=0,this.pos=0,this.view=y1,this.bytes=x5,this.headByte=u0,this.stack=new I8,this.entered=!1,this.extensionCodec=W?.extensionCodec??$0.defaultCodec,this.context=W?.context,this.useBigInt64=W?.useBigInt64??!1,this.rawStrings=W?.rawStrings??!1,this.maxStrLength=W?.maxStrLength??A0,this.maxBinLength=W?.maxBinLength??A0,this.maxArrayLength=W?.maxArrayLength??A0,this.maxMapLength=W?.maxMapLength??A0,this.maxExtLength=W?.maxExtLength??A0,this.keyDecoder=W?.keyDecoder!==void 0?W.keyDecoder:I5,this.mapKeyConverter=W?.mapKeyConverter??L5}clone(){return new Z1({extensionCodec:this.extensionCodec,context:this.context,useBigInt64:this.useBigInt64,rawStrings:this.rawStrings,maxStrLength:this.maxStrLength,maxBinLength:this.maxBinLength,maxArrayLength:this.maxArrayLength,maxMapLength:this.maxMapLength,maxExtLength:this.maxExtLength,keyDecoder:this.keyDecoder})}reinitializeState(){this.totalPos=0,this.headByte=u0,this.stack.reset()}setBuffer(W){const Q=b0(W);this.bytes=Q,this.view=new DataView(Q.buffer,Q.byteOffset,Q.byteLength),this.pos=0}appendBuffer(W){if(this.headByte===u0&&!this.hasRemaining(1))this.setBuffer(W);else{const Q=this.bytes.subarray(this.pos),J=b0(W),V=new Uint8Array(Q.length+J.length);V.set(Q),V.set(J,Q.length),this.setBuffer(V)}}hasRemaining(W){return this.view.byteLength-this.pos>=W}createExtraByteError(W){const{view:Q,pos:J}=this;return new RangeError(`Extra ${Q.byteLength-J} of ${Q.byteLength} byte(s) found at buffer[${W}]`)}decode(W){if(this.entered)return this.clone().decode(W);try{this.entered=!0,this.reinitializeState(),this.setBuffer(W);const Q=this.doDecodeSync();if(this.hasRemaining(1))throw this.createExtraByteError(this.pos);return Q}finally{this.entered=!1}}*decodeMulti(W){if(this.entered){yield*this.clone().decodeMulti(W);return}try{this.entered=!0,this.reinitializeState(),this.setBuffer(W);while(this.hasRemaining(1))yield this.doDecodeSync()}finally{this.entered=!1}}async decodeAsync(W){if(this.entered)return this.clone().decodeAsync(W);try{this.entered=!0;let Q=!1,J;for await(let Y of W){if(Q)throw this.entered=!1,this.createExtraByteError(this.totalPos);this.appendBuffer(Y);try{J=this.doDecodeSync(),Q=!0}catch(U){if(!(U instanceof RangeError))throw U}this.totalPos+=this.pos}if(Q){if(this.hasRemaining(1))throw this.createExtraByteError(this.totalPos);return J}const{headByte:V,pos:G,totalPos:X}=this;throw new RangeError(`Insufficient data in parsing ${z1(V)} at ${X} (${G} in the current buffer)`)}finally{this.entered=!1}}decodeArrayStream(W){return this.decodeMultiAsync(W,!0)}decodeStream(W){return this.decodeMultiAsync(W,!1)}async*decodeMultiAsync(W,Q){if(this.entered){yield*this.clone().decodeMultiAsync(W,Q);return}try{this.entered=!0;let J=Q,V=-1;for await(let G of W){if(Q&&V===0)throw this.createExtraByteError(this.totalPos);if(this.appendBuffer(G),J)V=this.readArraySize(),J=!1,this.complete();try{while(!0)if(yield this.doDecodeSync(),--V===0)break}catch(X){if(!(X instanceof RangeError))throw X}this.totalPos+=this.pos}}finally{this.entered=!1}}doDecodeSync(){W:while(!0){const W=this.readHeadByte();let Q;if(W>=224)Q=W-256;else if(W<192)if(W<128)Q=W;else if(W<144){const V=W-128;if(V!==0){this.pushMapState(V),this.complete();continue W}else Q={}}else if(W<160){const V=W-144;if(V!==0){this.pushArrayState(V),this.complete();continue W}else Q=[]}else{const V=W-160;Q=this.decodeString(V,0)}else if(W===192)Q=null;else if(W===194)Q=!1;else if(W===195)Q=!0;else if(W===202)Q=this.readF32();else if(W===203)Q=this.readF64();else if(W===204)Q=this.readU8();else if(W===205)Q=this.readU16();else if(W===206)Q=this.readU32();else if(W===207)if(this.useBigInt64)Q=this.readU64AsBigInt();else Q=this.readU64();else if(W===208)Q=this.readI8();else if(W===209)Q=this.readI16();else if(W===210)Q=this.readI32();else if(W===211)if(this.useBigInt64)Q=this.readI64AsBigInt();else Q=this.readI64();else if(W===217){const V=this.lookU8();Q=this.decodeString(V,1)}else if(W===218){const V=this.lookU16();Q=this.decodeString(V,2)}else if(W===219){const V=this.lookU32();Q=this.decodeString(V,4)}else if(W===220){const V=this.readU16();if(V!==0){this.pushArrayState(V),this.complete();continue W}else Q=[]}else if(W===221){const V=this.readU32();if(V!==0){this.pushArrayState(V),this.complete();continue W}else Q=[]}else if(W===222){const V=this.readU16();if(V!==0){this.pushMapState(V),this.complete();continue W}else Q={}}else if(W===223){const V=this.readU32();if(V!==0){this.pushMapState(V),this.complete();continue W}else Q={}}else if(W===196){const V=this.lookU8();Q=this.decodeBinary(V,1)}else if(W===197){const V=this.lookU16();Q=this.decodeBinary(V,2)}else if(W===198){const V=this.lookU32();Q=this.decodeBinary(V,4)}else if(W===212)Q=this.decodeExtension(1,0);else if(W===213)Q=this.decodeExtension(2,0);else if(W===214)Q=this.decodeExtension(4,0);else if(W===215)Q=this.decodeExtension(8,0);else if(W===216)Q=this.decodeExtension(16,0);else if(W===199){const V=this.lookU8();Q=this.decodeExtension(V,1)}else if(W===200){const V=this.lookU16();Q=this.decodeExtension(V,2)}else if(W===201){const V=this.lookU32();Q=this.decodeExtension(V,4)}else throw new d(`Unrecognized type byte: ${z1(W)}`);this.complete();const J=this.stack;while(J.length>0){const V=J.top();if(V.type===g1)if(V.array[V.position]=Q,V.position++,V.position===V.size)Q=V.array,J.release(V);else continue W;else if(V.type===m0){if(Q==="__proto__")throw new d("The key __proto__ is not allowed");V.key=this.mapKeyConverter(Q),V.type=x8;continue W}else if(V.map[V.key]=Q,V.readCount++,V.readCount===V.size)Q=V.map,J.release(V);else{V.key=null,V.type=m0;continue W}}return Q}}readHeadByte(){if(this.headByte===u0)this.headByte=this.readU8();return this.headByte}complete(){this.headByte=u0}readArraySize(){const W=this.readHeadByte();switch(W){case 220:return this.readU16();case 221:return this.readU32();default:if(W<160)return W-144;else throw new d(`Unrecognized array type byte: ${z1(W)}`)}}pushMapState(W){if(W>this.maxMapLength)throw new d(`Max length exceeded: map length (${W}) > maxMapLengthLength (${this.maxMapLength})`);this.stack.pushMapState(W)}pushArrayState(W){if(W>this.maxArrayLength)throw new d(`Max length exceeded: array length (${W}) > maxArrayLength (${this.maxArrayLength})`);this.stack.pushArrayState(W)}decodeString(W,Q){if(!this.rawStrings||this.stateIsMapKey())return this.decodeUtf8String(W,Q);return this.decodeBinary(W,Q)}decodeUtf8String(W,Q){if(W>this.maxStrLength)throw new d(`Max length exceeded: UTF-8 byte length (${W}) > maxStrLength (${this.maxStrLength})`);if(this.bytes.byteLength<this.pos+Q+W)throw L8;const J=this.pos+Q;let V;if(this.stateIsMapKey()&&this.keyDecoder?.canBeCached(W))V=this.keyDecoder.decode(this.bytes,J,W);else V=C8(this.bytes,J,W);return this.pos+=Q+W,V}stateIsMapKey(){if(this.stack.length>0)return this.stack.top().type===m0;return!1}decodeBinary(W,Q){if(W>this.maxBinLength)throw new d(`Max length exceeded: bin length (${W}) > maxBinLength (${this.maxBinLength})`);if(!this.hasRemaining(W+Q))throw L8;const J=this.pos+Q,V=this.bytes.subarray(J,J+W);return this.pos+=Q+W,V}decodeExtension(W,Q){if(W>this.maxExtLength)throw new d(`Max length exceeded: ext length (${W}) > maxExtLength (${this.maxExtLength})`);const J=this.view.getInt8(this.pos+Q),V=this.decodeBinary(W,Q+1);return this.extensionCodec.decode(V,J,this.context)}lookU8(){return this.view.getUint8(this.pos)}lookU16(){return this.view.getUint16(this.pos)}lookU32(){return this.view.getUint32(this.pos)}readU8(){const W=this.view.getUint8(this.pos);return this.pos++,W}readI8(){const W=this.view.getInt8(this.pos);return this.pos++,W}readU16(){const W=this.view.getUint16(this.pos);return this.pos+=2,W}readI16(){const W=this.view.getInt16(this.pos);return this.pos+=2,W}readU32(){const W=this.view.getUint32(this.pos);return this.pos+=4,W}readI32(){const W=this.view.getInt32(this.pos);return this.pos+=4,W}readU64(){const W=R8(this.view,this.pos);return this.pos+=8,W}readI64(){const W=K1(this.view,this.pos);return this.pos+=8,W}readU64AsBigInt(){const W=this.view.getBigUint64(this.pos);return this.pos+=8,W}readI64AsBigInt(){const W=this.view.getBigInt64(this.pos);return this.pos+=8,W}readF32(){const W=this.view.getFloat32(this.pos);return this.pos+=4,W}readF64(){const W=this.view.getFloat64(this.pos);return this.pos+=8,W}}function c0(W,Q){return new Z1(Q).decode(W)}var E0=function(W){let Q=W.length;while(--Q>=0)W[Q]=0},f1=function(W,Q,J,V,G){this.static_tree=W,this.extra_bits=Q,this.extra_base=J,this.elems=V,this.max_length=G,this.has_stree=W&&W.length},p1=function(W,Q){this.dyn_tree=W,this.max_code=0,this.stat_desc=Q},s=function(W,Q,J,V,G){this.good_length=W,this.max_lazy=Q,this.nice_length=J,this.max_chain=V,this.func=G},OW=function(){this.strm=null,this.status=0,this.pending_buf=null,this.pending_buf_size=0,this.pending_out=0,this.pending=0,this.wrap=0,this.gzhead=null,this.gzindex=0,this.method=x1,this.last_flush=-1,this.w_size=0,this.w_bits=0,this.w_mask=0,this.window=null,this.window_size=0,this.prev=null,this.head=null,this.ins_h=0,this.hash_size=0,this.hash_bits=0,this.hash_mask=0,this.hash_shift=0,this.block_start=0,this.match_length=0,this.prev_match=0,this.match_available=0,this.strstart=0,this.match_start=0,this.lookahead=0,this.prev_length=0,this.max_chain_length=0,this.max_lazy_match=0,this.level=0,this.strategy=0,this.good_match=0,this.nice_match=0,this.dyn_ltree=new Uint16Array(BW*2),this.dyn_dtree=new Uint16Array((2*kW+1)*2),this.bl_tree=new Uint16Array((2*$W+1)*2),K0(this.dyn_ltree),K0(this.dyn_dtree),K0(this.bl_tree),this.l_desc=null,this.d_desc=null,this.bl_desc=null,this.bl_count=new Uint16Array(CW+1),this.heap=new Uint16Array(2*e1+1),K0(this.heap),this.heap_len=0,this.heap_max=0,this.depth=new Uint16Array(2*e1+1),K0(this.depth),this.sym_buf=0,this.lit_bufsize=0,this.sym_next=0,this.sym_end=0,this.opt_len=0,this.static_len=0,this.matches=0,this.insert=0,this.bi_buf=0,this.bi_valid=0},nW=function(){this.input=null,this.next_in=0,this.avail_in=0,this.total_in=0,this.output=null,this.next_out=0,this.avail_out=0,this.total_out=0,this.msg="",this.state=null,this.data_type=2,this.adler=0},X1=function(W){this.options=I1.assign({level:WJ,method:QJ,chunkSize:16384,windowBits:15,memLevel:8,strategy:JJ},W||{});let Q=this.options;if(Q.raw&&Q.windowBits>0)Q.windowBits=-Q.windowBits;else if(Q.gzip&&Q.windowBits>0&&Q.windowBits<16)Q.windowBits+=16;this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new S6,this.strm.avail_out=0;let J=r0.deflateInit2(this.strm,Q.level,Q.method,Q.windowBits,Q.memLevel,Q.strategy);if(J!==M1)throw new Error(R0[J]);if(Q.header)r0.deflateSetHeader(this.strm,Q.header);if(Q.dictionary){let V;if(typeof Q.dictionary==="string")V=J1.string2buf(Q.dictionary);else if(v6.call(Q.dictionary)==="[object ArrayBuffer]")V=new Uint8Array(Q.dictionary);else V=Q.dictionary;if(J=r0.deflateSetDictionary(this.strm,V),J!==M1)throw new Error(R0[J]);this._dict_set=!0}},P8=function(W,Q){const J=new X1(Q);if(J.push(W,!0),J.err)throw J.msg||R0[J.err];return J.result},VJ=function(W,Q){return Q=Q||{},Q.raw=!0,P8(W,Q)},GJ=function(W,Q){return Q=Q||{},Q.gzip=!0,P8(W,Q)},DJ=function(){this.strm=null,this.mode=0,this.last=!1,this.wrap=0,this.havedict=!1,this.flags=0,this.dmax=0,this.check=0,this.total=0,this.head=null,this.wbits=0,this.wsize=0,this.whave=0,this.wnext=0,this.window=null,this.hold=0,this.bits=0,this.length=0,this.offset=0,this.extra=0,this.lencode=null,this.distcode=null,this.lenbits=0,this.distbits=0,this.ncode=0,this.nlen=0,this.ndist=0,this.have=0,this.next=null,this.lens=new Uint16Array(320),this.work=new Uint16Array(288),this.lendyn=null,this.distdyn=null,this.sane=0,this.back=0,this.was=0},dJ=function(){this.text=0,this.time=0,this.xflags=0,this.os=0,this.extra=null,this.extra_len=0,this.name="",this.comment="",this.hcrc=0,this.done=!1},q1=function(W){this.options=I1.assign({chunkSize:65536,windowBits:15,to:""},W||{});const Q=this.options;if(Q.raw&&Q.windowBits>=0&&Q.windowBits<16){if(Q.windowBits=-Q.windowBits,Q.windowBits===0)Q.windowBits=-15}if(Q.windowBits>=0&&Q.windowBits<16&&!(W&&W.windowBits))Q.windowBits+=32;if(Q.windowBits>15&&Q.windowBits<48){if((Q.windowBits&15)===0)Q.windowBits|=15}this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new S6,this.strm.avail_out=0;let J=U0.inflateInit2(this.strm,Q.windowBits);if(J!==Q1)throw new Error(R0[J]);if(this.header=new iJ,U0.inflateGetHeader(this.strm,this.header),Q.dictionary){if(typeof Q.dictionary==="string")Q.dictionary=J1.string2buf(Q.dictionary);else if(_6.call(Q.dictionary)==="[object ArrayBuffer]")Q.dictionary=new Uint8Array(Q.dictionary);if(Q.raw){if(J=U0.inflateSetDictionary(this.strm,Q.dictionary),J!==Q1)throw new Error(R0[J])}}},K8=function(W,Q){const J=new q1(Q);if(J.push(W),J.err)throw J.msg||R0[J.err];return J.result},aJ=function(W,Q){return Q=Q||{},Q.raw=!0,K8(W,Q)};/*! pako 2.1.0 https://github.com/nodeca/pako @license (MIT AND Zlib) */var w5=0,P6=1,O5=2,D5=3,A5=258,G8=29,V1=256,o0=V1+1+G8,T0=30,X8=19,K6=2*o0+1,B0=15,E1=16,N5=7,q8=256,F6=16,z6=17,Z6=18,o1=new Uint8Array([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0]),j1=new Uint8Array([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13]),S5=new Uint8Array([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7]),H6=new Uint8Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),v5=512,q0=new Array((o0+2)*2);E0(q0);var l0=new Array(T0*2);E0(l0);var a0=new Array(v5);E0(a0);var t0=new Array(A5-D5+1);E0(t0);var U8=new Array(G8);E0(U8);var R1=new Array(T0);E0(R1);var k6,$6,B6,C6=(W)=>{return W<256?a0[W]:a0[256+(W>>>7)]},e0=(W,Q)=>{W.pending_buf[W.pending++]=Q&255,W.pending_buf[W.pending++]=Q>>>8&255},l=(W,Q,J)=>{if(W.bi_valid>E1-J)W.bi_buf|=Q<<W.bi_valid&65535,e0(W,W.bi_buf),W.bi_buf=Q>>E1-W.bi_valid,W.bi_valid+=J-E1;else W.bi_buf|=Q<<W.bi_valid&65535,W.bi_valid+=J},W0=(W,Q,J)=>{l(W,J[Q*2],J[Q*2+1])},j6=(W,Q)=>{let J=0;do J|=W&1,W>>>=1,J<<=1;while(--Q>0);return J>>>1},T5=(W)=>{if(W.bi_valid===16)e0(W,W.bi_buf),W.bi_buf=0,W.bi_valid=0;else if(W.bi_valid>=8)W.pending_buf[W.pending++]=W.bi_buf&255,W.bi_buf>>=8,W.bi_valid-=8},g5=(W,Q)=>{const{dyn_tree:J,max_code:V}=Q,G=Q.stat_desc.static_tree,X=Q.stat_desc.has_stree,Y=Q.stat_desc.extra_bits,U=Q.stat_desc.extra_base,K=Q.stat_desc.max_length;let q,P,k,z,F,Z,R=0;for(z=0;z<=B0;z++)W.bl_count[z]=0;J[W.heap[W.heap_max]*2+1]=0;for(q=W.heap_max+1;q<K6;q++){if(P=W.heap[q],z=J[J[P*2+1]*2+1]+1,z>K)z=K,R++;if(J[P*2+1]=z,P>V)continue;if(W.bl_count[z]++,F=0,P>=U)F=Y[P-U];if(Z=J[P*2],W.opt_len+=Z*(z+F),X)W.static_len+=Z*(G[P*2+1]+F)}if(R===0)return;do{z=K-1;while(W.bl_count[z]===0)z--;W.bl_count[z]--,W.bl_count[z+1]+=2,W.bl_count[K]--,R-=2}while(R>0);for(z=K;z!==0;z--){P=W.bl_count[z];while(P!==0){if(k=W.heap[--q],k>V)continue;if(J[k*2+1]!==z)W.opt_len+=(z-J[k*2+1])*J[k*2],J[k*2+1]=z;P--}}},R6=(W,Q,J)=>{const V=new Array(B0+1);let G=0,X,Y;for(X=1;X<=B0;X++)G=G+J[X-1]<<1,V[X]=G;for(Y=0;Y<=Q;Y++){let U=W[Y*2+1];if(U===0)continue;W[Y*2]=j6(V[U]++,U)}},y5=()=>{let W,Q,J,V,G;const X=new Array(B0+1);J=0;for(V=0;V<G8-1;V++){U8[V]=J;for(W=0;W<1<<o1[V];W++)t0[J++]=V}t0[J-1]=V,G=0;for(V=0;V<16;V++){R1[V]=G;for(W=0;W<1<<j1[V];W++)a0[G++]=V}G>>=7;for(;V<T0;V++){R1[V]=G<<7;for(W=0;W<1<<j1[V]-7;W++)a0[256+G++]=V}for(Q=0;Q<=B0;Q++)X[Q]=0;W=0;while(W<=143)q0[W*2+1]=8,W++,X[8]++;while(W<=255)q0[W*2+1]=9,W++,X[9]++;while(W<=279)q0[W*2+1]=7,W++,X[7]++;while(W<=287)q0[W*2+1]=8,W++,X[8]++;R6(q0,o0+1,X);for(W=0;W<T0;W++)l0[W*2+1]=5,l0[W*2]=j6(W,5);k6=new f1(q0,o1,V1+1,o0,B0),$6=new f1(l0,j1,0,T0,B0),B6=new f1(new Array(0),S5,0,X8,N5)},M6=(W)=>{let Q;for(Q=0;Q<o0;Q++)W.dyn_ltree[Q*2]=0;for(Q=0;Q<T0;Q++)W.dyn_dtree[Q*2]=0;for(Q=0;Q<X8;Q++)W.bl_tree[Q*2]=0;W.dyn_ltree[q8*2]=1,W.opt_len=W.static_len=0,W.sym_next=W.matches=0},L6=(W)=>{if(W.bi_valid>8)e0(W,W.bi_buf);else if(W.bi_valid>0)W.pending_buf[W.pending++]=W.bi_buf;W.bi_buf=0,W.bi_valid=0},w8=(W,Q,J,V)=>{const G=Q*2,X=J*2;return W[G]<W[X]||W[G]===W[X]&&V[Q]<=V[J]},h1=(W,Q,J)=>{const V=W.heap[J];let G=J<<1;while(G<=W.heap_len){if(G<W.heap_len&&w8(Q,W.heap[G+1],W.heap[G],W.depth))G++;if(w8(Q,V,W.heap[G],W.depth))break;W.heap[J]=W.heap[G],J=G,G<<=1}W.heap[J]=V},O8=(W,Q,J)=>{let V,G,X=0,Y,U;if(W.sym_next!==0)do if(V=W.pending_buf[W.sym_buf+X++]&255,V+=(W.pending_buf[W.sym_buf+X++]&255)<<8,G=W.pending_buf[W.sym_buf+X++],V===0)W0(W,G,Q);else{if(Y=t0[G],W0(W,Y+V1+1,Q),U=o1[Y],U!==0)G-=U8[Y],l(W,G,U);if(V--,Y=C6(V),W0(W,Y,J),U=j1[Y],U!==0)V-=R1[Y],l(W,V,U)}while(X<W.sym_next);W0(W,q8,Q)},a1=(W,Q)=>{const J=Q.dyn_tree,V=Q.stat_desc.static_tree,G=Q.stat_desc.has_stree,X=Q.stat_desc.elems;let Y,U,K=-1,q;W.heap_len=0,W.heap_max=K6;for(Y=0;Y<X;Y++)if(J[Y*2]!==0)W.heap[++W.heap_len]=K=Y,W.depth[Y]=0;else J[Y*2+1]=0;while(W.heap_len<2)if(q=W.heap[++W.heap_len]=K<2?++K:0,J[q*2]=1,W.depth[q]=0,W.opt_len--,G)W.static_len-=V[q*2+1];Q.max_code=K;for(Y=W.heap_len>>1;Y>=1;Y--)h1(W,J,Y);q=X;do Y=W.heap[1],W.heap[1]=W.heap[W.heap_len--],h1(W,J,1),U=W.heap[1],W.heap[--W.heap_max]=Y,W.heap[--W.heap_max]=U,J[q*2]=J[Y*2]+J[U*2],W.depth[q]=(W.depth[Y]>=W.depth[U]?W.depth[Y]:W.depth[U])+1,J[Y*2+1]=J[U*2+1]=q,W.heap[1]=q++,h1(W,J,1);while(W.heap_len>=2);W.heap[--W.heap_max]=W.heap[1],g5(W,Q),R6(J,K,W.bl_count)},D8=(W,Q,J)=>{let V,G=-1,X,Y=Q[1],U=0,K=7,q=4;if(Y===0)K=138,q=3;Q[(J+1)*2+1]=65535;for(V=0;V<=J;V++){if(X=Y,Y=Q[(V+1)*2+1],++U<K&&X===Y)continue;else if(U<q)W.bl_tree[X*2]+=U;else if(X!==0){if(X!==G)W.bl_tree[X*2]++;W.bl_tree[F6*2]++}else if(U<=10)W.bl_tree[z6*2]++;else W.bl_tree[Z6*2]++;if(U=0,G=X,Y===0)K=138,q=3;else if(X===Y)K=6,q=3;else K=7,q=4}},A8=(W,Q,J)=>{let V,G=-1,X,Y=Q[1],U=0,K=7,q=4;if(Y===0)K=138,q=3;for(V=0;V<=J;V++){if(X=Y,Y=Q[(V+1)*2+1],++U<K&&X===Y)continue;else if(U<q)do W0(W,X,W.bl_tree);while(--U!==0);else if(X!==0){if(X!==G)W0(W,X,W.bl_tree),U--;W0(W,F6,W.bl_tree),l(W,U-3,2)}else if(U<=10)W0(W,z6,W.bl_tree),l(W,U-3,3);else W0(W,Z6,W.bl_tree),l(W,U-11,7);if(U=0,G=X,Y===0)K=138,q=3;else if(X===Y)K=6,q=3;else K=7,q=4}},E5=(W)=>{let Q;D8(W,W.dyn_ltree,W.l_desc.max_code),D8(W,W.dyn_dtree,W.d_desc.max_code),a1(W,W.bl_desc);for(Q=X8-1;Q>=3;Q--)if(W.bl_tree[H6[Q]*2+1]!==0)break;return W.opt_len+=3*(Q+1)+5+5+4,Q},f5=(W,Q,J,V)=>{let G;l(W,Q-257,5),l(W,J-1,5),l(W,V-4,4);for(G=0;G<V;G++)l(W,W.bl_tree[H6[G]*2+1],3);A8(W,W.dyn_ltree,Q-1),A8(W,W.dyn_dtree,J-1)},p5=(W)=>{let Q=4093624447,J;for(J=0;J<=31;J++,Q>>>=1)if(Q&1&&W.dyn_ltree[J*2]!==0)return 0;if(W.dyn_ltree[18]!==0||W.dyn_ltree[20]!==0||W.dyn_ltree[26]!==0)return 1;for(J=32;J<V1;J++)if(W.dyn_ltree[J*2]!==0)return 1;return 0},N8=!1,h5=(W)=>{if(!N8)y5(),N8=!0;W.l_desc=new p1(W.dyn_ltree,k6),W.d_desc=new p1(W.dyn_dtree,$6),W.bl_desc=new p1(W.bl_tree,B6),W.bi_buf=0,W.bi_valid=0,M6(W)},x6=(W,Q,J,V)=>{if(l(W,(w5<<1)+(V?1:0),3),L6(W),e0(W,J),e0(W,~J),J)W.pending_buf.set(W.window.subarray(Q,Q+J),W.pending);W.pending+=J},b5=(W)=>{l(W,P6<<1,3),W0(W,q8,q0),T5(W)},u5=(W,Q,J,V)=>{let G,X,Y=0;if(W.level>0){if(W.strm.data_type===2)W.strm.data_type=p5(W);if(a1(W,W.l_desc),a1(W,W.d_desc),Y=E5(W),G=W.opt_len+3+7>>>3,X=W.static_len+3+7>>>3,X<=G)G=X}else G=X=J+5;if(J+4<=G&&Q!==-1)x6(W,Q,J,V);else if(W.strategy===4||X===G)l(W,(P6<<1)+(V?1:0),3),O8(W,q0,l0);else l(W,(O5<<1)+(V?1:0),3),f5(W,W.l_desc.max_code+1,W.d_desc.max_code+1,Y+1),O8(W,W.dyn_ltree,W.dyn_dtree);if(M6(W),V)L6(W)},m5=(W,Q,J)=>{if(W.pending_buf[W.sym_buf+W.sym_next++]=Q,W.pending_buf[W.sym_buf+W.sym_next++]=Q>>8,W.pending_buf[W.sym_buf+W.sym_next++]=J,Q===0)W.dyn_ltree[J*2]++;else W.matches++,Q--,W.dyn_ltree[(t0[J]+V1+1)*2]++,W.dyn_dtree[C6(Q)*2]++;return W.sym_next===W.sym_end},c5=h5,_5=x6,d5=u5,i5=m5,l5=b5,r5={_tr_init:c5,_tr_stored_block:_5,_tr_flush_block:d5,_tr_tally:i5,_tr_align:l5},n5=(W,Q,J,V)=>{let G=W&65535|0,X=W>>>16&65535|0,Y=0;while(J!==0){Y=J>2000?2000:J,J-=Y;do G=G+Q[V++]|0,X=X+G|0;while(--Y);G%=65521,X%=65521}return G|X<<16|0},s0=n5,o5=()=>{let W,Q=[];for(var J=0;J<256;J++){W=J;for(var V=0;V<8;V++)W=W&1?3988292384^W>>>1:W>>>1;Q[J]=W}return Q},a5=new Uint32Array(o5()),t5=(W,Q,J,V)=>{const G=a5,X=V+J;W^=-1;for(let Y=V;Y<X;Y++)W=W>>>8^G[(W^Q[Y])&255];return W^-1},m=t5,R0={2:"need dictionary",1:"stream end",0:"","-1":"file error","-2":"stream error","-3":"data error","-4":"insufficient memory","-5":"buffer error","-6":"incompatible version"},x0={Z_NO_FLUSH:0,Z_PARTIAL_FLUSH:1,Z_SYNC_FLUSH:2,Z_FULL_FLUSH:3,Z_FINISH:4,Z_BLOCK:5,Z_TREES:6,Z_OK:0,Z_STREAM_END:1,Z_NEED_DICT:2,Z_ERRNO:-1,Z_STREAM_ERROR:-2,Z_DATA_ERROR:-3,Z_MEM_ERROR:-4,Z_BUF_ERROR:-5,Z_NO_COMPRESSION:0,Z_BEST_SPEED:1,Z_BEST_COMPRESSION:9,Z_DEFAULT_COMPRESSION:-1,Z_FILTERED:1,Z_HUFFMAN_ONLY:2,Z_RLE:3,Z_FIXED:4,Z_DEFAULT_STRATEGY:0,Z_BINARY:0,Z_TEXT:1,Z_UNKNOWN:2,Z_DEFLATED:8},{_tr_init:e5,_tr_stored_block:t1,_tr_flush_block:s5,_tr_tally:z0,_tr_align:WW}=r5,{Z_NO_FLUSH:Z0,Z_PARTIAL_FLUSH:JW,Z_FULL_FLUSH:QW,Z_FINISH:t,Z_BLOCK:S8,Z_OK:c,Z_STREAM_END:v8,Z_STREAM_ERROR:J0,Z_DATA_ERROR:VW,Z_BUF_ERROR:b1,Z_DEFAULT_COMPRESSION:GW,Z_FILTERED:XW,Z_HUFFMAN_ONLY:H1,Z_RLE:qW,Z_FIXED:UW,Z_DEFAULT_STRATEGY:YW,Z_UNKNOWN:PW,Z_DEFLATED:x1}=x0,KW=9,FW=15,zW=8,ZW=29,HW=256,e1=HW+1+ZW,kW=30,$W=19,BW=2*e1+1,CW=15,T=3,F0=258,Q0=F0+T+1,jW=32,g0=42,Y8=57,s1=69,W8=73,J8=91,Q8=103,C0=113,d0=666,i=1,f0=2,M0=3,p0=4,RW=3,j0=(W,Q)=>{return W.msg=R0[Q],Q},T8=(W)=>{return W*2-(W>4?9:0)},K0=(W)=>{let Q=W.length;while(--Q>=0)W[Q]=0},MW=(W)=>{let Q,J,V,G=W.w_size;Q=W.hash_size,V=Q;do J=W.head[--V],W.head[V]=J>=G?J-G:0;while(--Q);Q=G,V=Q;do J=W.prev[--V],W.prev[V]=J>=G?J-G:0;while(--Q)},LW=(W,Q,J)=>(Q<<W.hash_shift^J)&W.hash_mask,H0=LW,r=(W)=>{const Q=W.state;let J=Q.pending;if(J>W.avail_out)J=W.avail_out;if(J===0)return;if(W.output.set(Q.pending_buf.subarray(Q.pending_out,Q.pending_out+J),W.next_out),W.next_out+=J,Q.pending_out+=J,W.total_out+=J,W.avail_out-=J,Q.pending-=J,Q.pending===0)Q.pending_out=0},n=(W,Q)=>{s5(W,W.block_start>=0?W.block_start:-1,W.strstart-W.block_start,Q),W.block_start=W.strstart,r(W.strm)},y=(W,Q)=>{W.pending_buf[W.pending++]=Q},_0=(W,Q)=>{W.pending_buf[W.pending++]=Q>>>8&255,W.pending_buf[W.pending++]=Q&255},V8=(W,Q,J,V)=>{let G=W.avail_in;if(G>V)G=V;if(G===0)return 0;if(W.avail_in-=G,Q.set(W.input.subarray(W.next_in,W.next_in+G),J),W.state.wrap===1)W.adler=s0(W.adler,Q,G,J);else if(W.state.wrap===2)W.adler=m(W.adler,Q,G,J);return W.next_in+=G,W.total_in+=G,G},I6=(W,Q)=>{let{max_chain_length:J,strstart:V}=W,G,X,Y=W.prev_length,U=W.nice_match;const K=W.strstart>W.w_size-Q0?W.strstart-(W.w_size-Q0):0,q=W.window,P=W.w_mask,k=W.prev,z=W.strstart+F0;let F=q[V+Y-1],Z=q[V+Y];if(W.prev_length>=W.good_match)J>>=2;if(U>W.lookahead)U=W.lookahead;do{if(G=Q,q[G+Y]!==Z||q[G+Y-1]!==F||q[G]!==q[V]||q[++G]!==q[V+1])continue;V+=2,G++;do;while(q[++V]===q[++G]&&q[++V]===q[++G]&&q[++V]===q[++G]&&q[++V]===q[++G]&&q[++V]===q[++G]&&q[++V]===q[++G]&&q[++V]===q[++G]&&q[++V]===q[++G]&&V<z);if(X=F0-(z-V),V=z-F0,X>Y){if(W.match_start=Q,Y=X,X>=U)break;F=q[V+Y-1],Z=q[V+Y]}}while((Q=k[Q&P])>K&&--J!==0);if(Y<=W.lookahead)return Y;return W.lookahead},y0=(W)=>{const Q=W.w_size;let J,V,G;do{if(V=W.window_size-W.lookahead-W.strstart,W.strstart>=Q+(Q-Q0)){if(W.window.set(W.window.subarray(Q,Q+Q-V),0),W.match_start-=Q,W.strstart-=Q,W.block_start-=Q,W.insert>W.strstart)W.insert=W.strstart;MW(W),V+=Q}if(W.strm.avail_in===0)break;if(J=V8(W.strm,W.window,W.strstart+W.lookahead,V),W.lookahead+=J,W.lookahead+W.insert>=T){G=W.strstart-W.insert,W.ins_h=W.window[G],W.ins_h=H0(W,W.ins_h,W.window[G+1]);while(W.insert)if(W.ins_h=H0(W,W.ins_h,W.window[G+T-1]),W.prev[G&W.w_mask]=W.head[W.ins_h],W.head[W.ins_h]=G,G++,W.insert--,W.lookahead+W.insert<T)break}}while(W.lookahead<Q0&&W.strm.avail_in!==0)},w6=(W,Q)=>{let J=W.pending_buf_size-5>W.w_size?W.w_size:W.pending_buf_size-5,V,G,X,Y=0,U=W.strm.avail_in;do{if(V=65535,X=W.bi_valid+42>>3,W.strm.avail_out<X)break;if(X=W.strm.avail_out-X,G=W.strstart-W.block_start,V>G+W.strm.avail_in)V=G+W.strm.avail_in;if(V>X)V=X;if(V<J&&(V===0&&Q!==t||Q===Z0||V!==G+W.strm.avail_in))break;if(Y=Q===t&&V===G+W.strm.avail_in?1:0,t1(W,0,0,Y),W.pending_buf[W.pending-4]=V,W.pending_buf[W.pending-3]=V>>8,W.pending_buf[W.pending-2]=~V,W.pending_buf[W.pending-1]=~V>>8,r(W.strm),G){if(G>V)G=V;W.strm.output.set(W.window.subarray(W.block_start,W.block_start+G),W.strm.next_out),W.strm.next_out+=G,W.strm.avail_out-=G,W.strm.total_out+=G,W.block_start+=G,V-=G}if(V)V8(W.strm,W.strm.output,W.strm.next_out,V),W.strm.next_out+=V,W.strm.avail_out-=V,W.strm.total_out+=V}while(Y===0);if(U-=W.strm.avail_in,U){if(U>=W.w_size)W.matches=2,W.window.set(W.strm.input.subarray(W.strm.next_in-W.w_size,W.strm.next_in),0),W.strstart=W.w_size,W.insert=W.strstart;else{if(W.window_size-W.strstart<=U){if(W.strstart-=W.w_size,W.window.set(W.window.subarray(W.w_size,W.w_size+W.strstart),0),W.matches<2)W.matches++;if(W.insert>W.strstart)W.insert=W.strstart}W.window.set(W.strm.input.subarray(W.strm.next_in-U,W.strm.next_in),W.strstart),W.strstart+=U,W.insert+=U>W.w_size-W.insert?W.w_size-W.insert:U}W.block_start=W.strstart}if(W.high_water<W.strstart)W.high_water=W.strstart;if(Y)return p0;if(Q!==Z0&&Q!==t&&W.strm.avail_in===0&&W.strstart===W.block_start)return f0;if(X=W.window_size-W.strstart,W.strm.avail_in>X&&W.block_start>=W.w_size){if(W.block_start-=W.w_size,W.strstart-=W.w_size,W.window.set(W.window.subarray(W.w_size,W.w_size+W.strstart),0),W.matches<2)W.matches++;if(X+=W.w_size,W.insert>W.strstart)W.insert=W.strstart}if(X>W.strm.avail_in)X=W.strm.avail_in;if(X)V8(W.strm,W.window,W.strstart,X),W.strstart+=X,W.insert+=X>W.w_size-W.insert?W.w_size-W.insert:X;if(W.high_water<W.strstart)W.high_water=W.strstart;if(X=W.bi_valid+42>>3,X=W.pending_buf_size-X>65535?65535:W.pending_buf_size-X,J=X>W.w_size?W.w_size:X,G=W.strstart-W.block_start,G>=J||(G||Q===t)&&Q!==Z0&&W.strm.avail_in===0&&G<=X)V=G>X?X:G,Y=Q===t&&W.strm.avail_in===0&&V===G?1:0,t1(W,W.block_start,V,Y),W.block_start+=V,r(W.strm);return Y?M0:i},u1=(W,Q)=>{let J,V;for(;;){if(W.lookahead<Q0){if(y0(W),W.lookahead<Q0&&Q===Z0)return i;if(W.lookahead===0)break}if(J=0,W.lookahead>=T)W.ins_h=H0(W,W.ins_h,W.window[W.strstart+T-1]),J=W.prev[W.strstart&W.w_mask]=W.head[W.ins_h],W.head[W.ins_h]=W.strstart;if(J!==0&&W.strstart-J<=W.w_size-Q0)W.match_length=I6(W,J);if(W.match_length>=T)if(V=z0(W,W.strstart-W.match_start,W.match_length-T),W.lookahead-=W.match_length,W.match_length<=W.max_lazy_match&&W.lookahead>=T){W.match_length--;do W.strstart++,W.ins_h=H0(W,W.ins_h,W.window[W.strstart+T-1]),J=W.prev[W.strstart&W.w_mask]=W.head[W.ins_h],W.head[W.ins_h]=W.strstart;while(--W.match_length!==0);W.strstart++}else W.strstart+=W.match_length,W.match_length=0,W.ins_h=W.window[W.strstart],W.ins_h=H0(W,W.ins_h,W.window[W.strstart+1]);else V=z0(W,0,W.window[W.strstart]),W.lookahead--,W.strstart++;if(V){if(n(W,!1),W.strm.avail_out===0)return i}}if(W.insert=W.strstart<T-1?W.strstart:T-1,Q===t){if(n(W,!0),W.strm.avail_out===0)return M0;return p0}if(W.sym_next){if(n(W,!1),W.strm.avail_out===0)return i}return f0},S0=(W,Q)=>{let J,V,G;for(;;){if(W.lookahead<Q0){if(y0(W),W.lookahead<Q0&&Q===Z0)return i;if(W.lookahead===0)break}if(J=0,W.lookahead>=T)W.ins_h=H0(W,W.ins_h,W.window[W.strstart+T-1]),J=W.prev[W.strstart&W.w_mask]=W.head[W.ins_h],W.head[W.ins_h]=W.strstart;if(W.prev_length=W.match_length,W.prev_match=W.match_start,W.match_length=T-1,J!==0&&W.prev_length<W.max_lazy_match&&W.strstart-J<=W.w_size-Q0){if(W.match_length=I6(W,J),W.match_length<=5&&(W.strategy===XW||W.match_length===T&&W.strstart-W.match_start>4096))W.match_length=T-1}if(W.prev_length>=T&&W.match_length<=W.prev_length){G=W.strstart+W.lookahead-T,V=z0(W,W.strstart-1-W.prev_match,W.prev_length-T),W.lookahead-=W.prev_length-1,W.prev_length-=2;do if(++W.strstart<=G)W.ins_h=H0(W,W.ins_h,W.window[W.strstart+T-1]),J=W.prev[W.strstart&W.w_mask]=W.head[W.ins_h],W.head[W.ins_h]=W.strstart;while(--W.prev_length!==0);if(W.match_available=0,W.match_length=T-1,W.strstart++,V){if(n(W,!1),W.strm.avail_out===0)return i}}else if(W.match_available){if(V=z0(W,0,W.window[W.strstart-1]),V)n(W,!1);if(W.strstart++,W.lookahead--,W.strm.avail_out===0)return i}else W.match_available=1,W.strstart++,W.lookahead--}if(W.match_available)V=z0(W,0,W.window[W.strstart-1]),W.match_available=0;if(W.insert=W.strstart<T-1?W.strstart:T-1,Q===t){if(n(W,!0),W.strm.avail_out===0)return M0;return p0}if(W.sym_next){if(n(W,!1),W.strm.avail_out===0)return i}return f0},xW=(W,Q)=>{let J,V,G,X;const Y=W.window;for(;;){if(W.lookahead<=F0){if(y0(W),W.lookahead<=F0&&Q===Z0)return i;if(W.lookahead===0)break}if(W.match_length=0,W.lookahead>=T&&W.strstart>0){if(G=W.strstart-1,V=Y[G],V===Y[++G]&&V===Y[++G]&&V===Y[++G]){X=W.strstart+F0;do;while(V===Y[++G]&&V===Y[++G]&&V===Y[++G]&&V===Y[++G]&&V===Y[++G]&&V===Y[++G]&&V===Y[++G]&&V===Y[++G]&&G<X);if(W.match_length=F0-(X-G),W.match_length>W.lookahead)W.match_length=W.lookahead}}if(W.match_length>=T)J=z0(W,1,W.match_length-T),W.lookahead-=W.match_length,W.strstart+=W.match_length,W.match_length=0;else J=z0(W,0,W.window[W.strstart]),W.lookahead--,W.strstart++;if(J){if(n(W,!1),W.strm.avail_out===0)return i}}if(W.insert=0,Q===t){if(n(W,!0),W.strm.avail_out===0)return M0;return p0}if(W.sym_next){if(n(W,!1),W.strm.avail_out===0)return i}return f0},IW=(W,Q)=>{let J;for(;;){if(W.lookahead===0){if(y0(W),W.lookahead===0){if(Q===Z0)return i;break}}if(W.match_length=0,J=z0(W,0,W.window[W.strstart]),W.lookahead--,W.strstart++,J){if(n(W,!1),W.strm.avail_out===0)return i}}if(W.insert=0,Q===t){if(n(W,!0),W.strm.avail_out===0)return M0;return p0}if(W.sym_next){if(n(W,!1),W.strm.avail_out===0)return i}return f0},i0=[new s(0,0,0,0,w6),new s(4,4,8,4,u1),new s(4,5,16,8,u1),new s(4,6,32,32,u1),new s(4,4,16,16,S0),new s(8,16,32,32,S0),new s(8,16,128,128,S0),new s(8,32,128,256,S0),new s(32,128,258,1024,S0),new s(32,258,258,4096,S0)],wW=(W)=>{W.window_size=2*W.w_size,K0(W.head),W.max_lazy_match=i0[W.level].max_lazy,W.good_match=i0[W.level].good_length,W.nice_match=i0[W.level].nice_length,W.max_chain_length=i0[W.level].max_chain,W.strstart=0,W.block_start=0,W.lookahead=0,W.insert=0,W.match_length=W.prev_length=T-1,W.match_available=0,W.ins_h=0},G1=(W)=>{if(!W)return 1;const Q=W.state;if(!Q||Q.strm!==W||Q.status!==g0&&Q.status!==Y8&&Q.status!==s1&&Q.status!==W8&&Q.status!==J8&&Q.status!==Q8&&Q.status!==C0&&Q.status!==d0)return 1;return 0},O6=(W)=>{if(G1(W))return j0(W,J0);W.total_in=W.total_out=0,W.data_type=PW;const Q=W.state;if(Q.pending=0,Q.pending_out=0,Q.wrap<0)Q.wrap=-Q.wrap;return Q.status=Q.wrap===2?Y8:Q.wrap?g0:C0,W.adler=Q.wrap===2?0:1,Q.last_flush=-2,e5(Q),c},D6=(W)=>{const Q=O6(W);if(Q===c)wW(W.state);return Q},DW=(W,Q)=>{if(G1(W)||W.state.wrap!==2)return J0;return W.state.gzhead=Q,c},A6=(W,Q,J,V,G,X)=>{if(!W)return J0;let Y=1;if(Q===GW)Q=6;if(V<0)Y=0,V=-V;else if(V>15)Y=2,V-=16;if(G<1||G>KW||J!==x1||V<8||V>15||Q<0||Q>9||X<0||X>UW||V===8&&Y!==1)return j0(W,J0);if(V===8)V=9;const U=new OW;return W.state=U,U.strm=W,U.status=g0,U.wrap=Y,U.gzhead=null,U.w_bits=V,U.w_size=1<<U.w_bits,U.w_mask=U.w_size-1,U.hash_bits=G+7,U.hash_size=1<<U.hash_bits,U.hash_mask=U.hash_size-1,U.hash_shift=~~((U.hash_bits+T-1)/T),U.window=new Uint8Array(U.w_size*2),U.head=new Uint16Array(U.hash_size),U.prev=new Uint16Array(U.w_size),U.lit_bufsize=1<<G+6,U.pending_buf_size=U.lit_bufsize*4,U.pending_buf=new Uint8Array(U.pending_buf_size),U.sym_buf=U.lit_bufsize,U.sym_end=(U.lit_bufsize-1)*3,U.level=Q,U.strategy=X,U.method=J,D6(W)},AW=(W,Q)=>{return A6(W,Q,x1,FW,zW,YW)},NW=(W,Q)=>{if(G1(W)||Q>S8||Q<0)return W?j0(W,J0):J0;const J=W.state;if(!W.output||W.avail_in!==0&&!W.input||J.status===d0&&Q!==t)return j0(W,W.avail_out===0?b1:J0);const V=J.last_flush;if(J.last_flush=Q,J.pending!==0){if(r(W),W.avail_out===0)return J.last_flush=-1,c}else if(W.avail_in===0&&T8(Q)<=T8(V)&&Q!==t)return j0(W,b1);if(J.status===d0&&W.avail_in!==0)return j0(W,b1);if(J.status===g0&&J.wrap===0)J.status=C0;if(J.status===g0){let G=x1+(J.w_bits-8<<4)<<8,X=-1;if(J.strategy>=H1||J.level<2)X=0;else if(J.level<6)X=1;else if(J.level===6)X=2;else X=3;if(G|=X<<6,J.strstart!==0)G|=jW;if(G+=31-G%31,_0(J,G),J.strstart!==0)_0(J,W.adler>>>16),_0(J,W.adler&65535);if(W.adler=1,J.status=C0,r(W),J.pending!==0)return J.last_flush=-1,c}if(J.status===Y8)if(W.adler=0,y(J,31),y(J,139),y(J,8),!J.gzhead){if(y(J,0),y(J,0),y(J,0),y(J,0),y(J,0),y(J,J.level===9?2:J.strategy>=H1||J.level<2?4:0),y(J,RW),J.status=C0,r(W),J.pending!==0)return J.last_flush=-1,c}else{if(y(J,(J.gzhead.text?1:0)+(J.gzhead.hcrc?2:0)+(!J.gzhead.extra?0:4)+(!J.gzhead.name?0:8)+(!J.gzhead.comment?0:16)),y(J,J.gzhead.time&255),y(J,J.gzhead.time>>8&255),y(J,J.gzhead.time>>16&255),y(J,J.gzhead.time>>24&255),y(J,J.level===9?2:J.strategy>=H1||J.level<2?4:0),y(J,J.gzhead.os&255),J.gzhead.extra&&J.gzhead.extra.length)y(J,J.gzhead.extra.length&255),y(J,J.gzhead.extra.length>>8&255);if(J.gzhead.hcrc)W.adler=m(W.adler,J.pending_buf,J.pending,0);J.gzindex=0,J.status=s1}if(J.status===s1){if(J.gzhead.extra){let G=J.pending,X=(J.gzhead.extra.length&65535)-J.gzindex;while(J.pending+X>J.pending_buf_size){let U=J.pending_buf_size-J.pending;if(J.pending_buf.set(J.gzhead.extra.subarray(J.gzindex,J.gzindex+U),J.pending),J.pending=J.pending_buf_size,J.gzhead.hcrc&&J.pending>G)W.adler=m(W.adler,J.pending_buf,J.pending-G,G);if(J.gzindex+=U,r(W),J.pending!==0)return J.last_flush=-1,c;G=0,X-=U}let Y=new Uint8Array(J.gzhead.extra);if(J.pending_buf.set(Y.subarray(J.gzindex,J.gzindex+X),J.pending),J.pending+=X,J.gzhead.hcrc&&J.pending>G)W.adler=m(W.adler,J.pending_buf,J.pending-G,G);J.gzindex=0}J.status=W8}if(J.status===W8){if(J.gzhead.name){let G=J.pending,X;do{if(J.pending===J.pending_buf_size){if(J.gzhead.hcrc&&J.pending>G)W.adler=m(W.adler,J.pending_buf,J.pending-G,G);if(r(W),J.pending!==0)return J.last_flush=-1,c;G=0}if(J.gzindex<J.gzhead.name.length)X=J.gzhead.name.charCodeAt(J.gzindex++)&255;else X=0;y(J,X)}while(X!==0);if(J.gzhead.hcrc&&J.pending>G)W.adler=m(W.adler,J.pending_buf,J.pending-G,G);J.gzindex=0}J.status=J8}if(J.status===J8){if(J.gzhead.comment){let G=J.pending,X;do{if(J.pending===J.pending_buf_size){if(J.gzhead.hcrc&&J.pending>G)W.adler=m(W.adler,J.pending_buf,J.pending-G,G);if(r(W),J.pending!==0)return J.last_flush=-1,c;G=0}if(J.gzindex<J.gzhead.comment.length)X=J.gzhead.comment.charCodeAt(J.gzindex++)&255;else X=0;y(J,X)}while(X!==0);if(J.gzhead.hcrc&&J.pending>G)W.adler=m(W.adler,J.pending_buf,J.pending-G,G)}J.status=Q8}if(J.status===Q8){if(J.gzhead.hcrc){if(J.pending+2>J.pending_buf_size){if(r(W),J.pending!==0)return J.last_flush=-1,c}y(J,W.adler&255),y(J,W.adler>>8&255),W.adler=0}if(J.status=C0,r(W),J.pending!==0)return J.last_flush=-1,c}if(W.avail_in!==0||J.lookahead!==0||Q!==Z0&&J.status!==d0){let G=J.level===0?w6(J,Q):J.strategy===H1?IW(J,Q):J.strategy===qW?xW(J,Q):i0[J.level].func(J,Q);if(G===M0||G===p0)J.status=d0;if(G===i||G===M0){if(W.avail_out===0)J.last_flush=-1;return c}if(G===f0){if(Q===JW)WW(J);else if(Q!==S8){if(t1(J,0,0,!1),Q===QW){if(K0(J.head),J.lookahead===0)J.strstart=0,J.block_start=0,J.insert=0}}if(r(W),W.avail_out===0)return J.last_flush=-1,c}}if(Q!==t)return c;if(J.wrap<=0)return v8;if(J.wrap===2)y(J,W.adler&255),y(J,W.adler>>8&255),y(J,W.adler>>16&255),y(J,W.adler>>24&255),y(J,W.total_in&255),y(J,W.total_in>>8&255),y(J,W.total_in>>16&255),y(J,W.total_in>>24&255);else _0(J,W.adler>>>16),_0(J,W.adler&65535);if(r(W),J.wrap>0)J.wrap=-J.wrap;return J.pending!==0?c:v8},SW=(W)=>{if(G1(W))return J0;const Q=W.state.status;return W.state=null,Q===C0?j0(W,VW):c},vW=(W,Q)=>{let J=Q.length;if(G1(W))return J0;const V=W.state,G=V.wrap;if(G===2||G===1&&V.status!==g0||V.lookahead)return J0;if(G===1)W.adler=s0(W.adler,Q,J,0);if(V.wrap=0,J>=V.w_size){if(G===0)K0(V.head),V.strstart=0,V.block_start=0,V.insert=0;let K=new Uint8Array(V.w_size);K.set(Q.subarray(J-V.w_size,J),0),Q=K,J=V.w_size}const{avail_in:X,next_in:Y,input:U}=W;W.avail_in=J,W.next_in=0,W.input=Q,y0(V);while(V.lookahead>=T){let K=V.strstart,q=V.lookahead-(T-1);do V.ins_h=H0(V,V.ins_h,V.window[K+T-1]),V.prev[K&V.w_mask]=V.head[V.ins_h],V.head[V.ins_h]=K,K++;while(--q);V.strstart=K,V.lookahead=T-1,y0(V)}return V.strstart+=V.lookahead,V.block_start=V.strstart,V.insert=V.lookahead,V.lookahead=0,V.match_length=V.prev_length=T-1,V.match_available=0,W.next_in=Y,W.input=U,W.avail_in=X,V.wrap=G,c},TW=AW,gW=A6,yW=D6,EW=O6,fW=DW,pW=NW,hW=SW,bW=vW,uW="pako deflate (from Nodeca project)",r0={deflateInit:TW,deflateInit2:gW,deflateReset:yW,deflateResetKeep:EW,deflateSetHeader:fW,deflate:pW,deflateEnd:hW,deflateSetDictionary:bW,deflateInfo:uW},mW=(W,Q)=>{return Object.prototype.hasOwnProperty.call(W,Q)},cW=function(W){const Q=Array.prototype.slice.call(arguments,1);while(Q.length){const J=Q.shift();if(!J)continue;if(typeof J!=="object")throw new TypeError(J+"must be non-object");for(let V in J)if(mW(J,V))W[V]=J[V]}return W},_W=(W)=>{let Q=0;for(let V=0,G=W.length;V<G;V++)Q+=W[V].length;const J=new Uint8Array(Q);for(let V=0,G=0,X=W.length;V<X;V++){let Y=W[V];J.set(Y,G),G+=Y.length}return J},I1={assign:cW,flattenChunks:_W},N6=!0;try{String.fromCharCode.apply(null,new Uint8Array(1))}catch(W){N6=!1}var W1=new Uint8Array(256);for(let W=0;W<256;W++)W1[W]=W>=252?6:W>=248?5:W>=240?4:W>=224?3:W>=192?2:1;W1[254]=W1[254]=1;var dW=(W)=>{if(typeof TextEncoder==="function"&&TextEncoder.prototype.encode)return(new TextEncoder()).encode(W);let Q,J,V,G,X,Y=W.length,U=0;for(G=0;G<Y;G++){if(J=W.charCodeAt(G),(J&64512)===55296&&G+1<Y){if(V=W.charCodeAt(G+1),(V&64512)===56320)J=65536+(J-55296<<10)+(V-56320),G++}U+=J<128?1:J<2048?2:J<65536?3:4}Q=new Uint8Array(U);for(X=0,G=0;X<U;G++){if(J=W.charCodeAt(G),(J&64512)===55296&&G+1<Y){if(V=W.charCodeAt(G+1),(V&64512)===56320)J=65536+(J-55296<<10)+(V-56320),G++}if(J<128)Q[X++]=J;else if(J<2048)Q[X++]=192|J>>>6,Q[X++]=128|J&63;else if(J<65536)Q[X++]=224|J>>>12,Q[X++]=128|J>>>6&63,Q[X++]=128|J&63;else Q[X++]=240|J>>>18,Q[X++]=128|J>>>12&63,Q[X++]=128|J>>>6&63,Q[X++]=128|J&63}return Q},iW=(W,Q)=>{if(Q<65534){if(W.subarray&&N6)return String.fromCharCode.apply(null,W.length===Q?W:W.subarray(0,Q))}let J="";for(let V=0;V<Q;V++)J+=String.fromCharCode(W[V]);return J},lW=(W,Q)=>{const J=Q||W.length;if(typeof TextDecoder==="function"&&TextDecoder.prototype.decode)return(new TextDecoder()).decode(W.subarray(0,Q));let V,G;const X=new Array(J*2);for(G=0,V=0;V<J;){let Y=W[V++];if(Y<128){X[G++]=Y;continue}let U=W1[Y];if(U>4){X[G++]=65533,V+=U-1;continue}Y&=U===2?31:U===3?15:7;while(U>1&&V<J)Y=Y<<6|W[V++]&63,U--;if(U>1){X[G++]=65533;continue}if(Y<65536)X[G++]=Y;else Y-=65536,X[G++]=55296|Y>>10&1023,X[G++]=56320|Y&1023}return iW(X,G)},rW=(W,Q)=>{if(Q=Q||W.length,Q>W.length)Q=W.length;let J=Q-1;while(J>=0&&(W[J]&192)===128)J--;if(J<0)return Q;if(J===0)return Q;return J+W1[W[J]]>Q?J:Q},J1={string2buf:dW,buf2string:lW,utf8border:rW},S6=nW,v6=Object.prototype.toString,{Z_NO_FLUSH:oW,Z_SYNC_FLUSH:aW,Z_FULL_FLUSH:tW,Z_FINISH:eW,Z_OK:M1,Z_STREAM_END:sW,Z_DEFAULT_COMPRESSION:WJ,Z_DEFAULT_STRATEGY:JJ,Z_DEFLATED:QJ}=x0;X1.prototype.push=function(W,Q){const J=this.strm,V=this.options.chunkSize;let G,X;if(this.ended)return!1;if(Q===~~Q)X=Q;else X=Q===!0?eW:oW;if(typeof W==="string")J.input=J1.string2buf(W);else if(v6.call(W)==="[object ArrayBuffer]")J.input=new Uint8Array(W);else J.input=W;J.next_in=0,J.avail_in=J.input.length;for(;;){if(J.avail_out===0)J.output=new Uint8Array(V),J.next_out=0,J.avail_out=V;if((X===aW||X===tW)&&J.avail_out<=6){this.onData(J.output.subarray(0,J.next_out)),J.avail_out=0;continue}if(G=r0.deflate(J,X),G===sW){if(J.next_out>0)this.onData(J.output.subarray(0,J.next_out));return G=r0.deflateEnd(this.strm),this.onEnd(G),this.ended=!0,G===M1}if(J.avail_out===0){this.onData(J.output);continue}if(X>0&&J.next_out>0){this.onData(J.output.subarray(0,J.next_out)),J.avail_out=0;continue}if(J.avail_in===0)break}return!0};X1.prototype.onData=function(W){this.chunks.push(W)};X1.prototype.onEnd=function(W){if(W===M1)this.result=I1.flattenChunks(this.chunks);this.chunks=[],this.err=W,this.msg=this.strm.msg};var XJ=X1,qJ=P8,UJ=VJ,YJ=GJ,PJ=x0,KJ={Deflate:XJ,deflate:qJ,deflateRaw:UJ,gzip:YJ,constants:PJ},k1=16209,FJ=16191,zJ=function W(Q,J){let V,G,X,Y,U,K,q,P,k,z,F,Z,R,M,O,v,w,H,N,b,j,g,D,L;const S=Q.state;V=Q.next_in,D=Q.input,G=V+(Q.avail_in-5),X=Q.next_out,L=Q.output,Y=X-(J-Q.avail_out),U=X+(Q.avail_out-257),K=S.dmax,q=S.wsize,P=S.whave,k=S.wnext,z=S.window,F=S.hold,Z=S.bits,R=S.lencode,M=S.distcode,O=(1<<S.lenbits)-1,v=(1<<S.distbits)-1;W:do{if(Z<15)F+=D[V++]<<Z,Z+=8,F+=D[V++]<<Z,Z+=8;w=R[F&O];J:for(;;){if(H=w>>>24,F>>>=H,Z-=H,H=w>>>16&255,H===0)L[X++]=w&65535;else if(H&16){if(N=w&65535,H&=15,H){if(Z<H)F+=D[V++]<<Z,Z+=8;N+=F&(1<<H)-1,F>>>=H,Z-=H}if(Z<15)F+=D[V++]<<Z,Z+=8,F+=D[V++]<<Z,Z+=8;w=M[F&v];Q:for(;;){if(H=w>>>24,F>>>=H,Z-=H,H=w>>>16&255,H&16){if(b=w&65535,H&=15,Z<H){if(F+=D[V++]<<Z,Z+=8,Z<H)F+=D[V++]<<Z,Z+=8}if(b+=F&(1<<H)-1,b>K){Q.msg="invalid distance too far back",S.mode=k1;break W}if(F>>>=H,Z-=H,H=X-Y,b>H){if(H=b-H,H>P){if(S.sane){Q.msg="invalid distance too far back",S.mode=k1;break W}}if(j=0,g=z,k===0){if(j+=q-H,H<N){N-=H;do L[X++]=z[j++];while(--H);j=X-b,g=L}}else if(k<H){if(j+=q+k-H,H-=k,H<N){N-=H;do L[X++]=z[j++];while(--H);if(j=0,k<N){H=k,N-=H;do L[X++]=z[j++];while(--H);j=X-b,g=L}}}else if(j+=k-H,H<N){N-=H;do L[X++]=z[j++];while(--H);j=X-b,g=L}while(N>2)L[X++]=g[j++],L[X++]=g[j++],L[X++]=g[j++],N-=3;if(N){if(L[X++]=g[j++],N>1)L[X++]=g[j++]}}else{j=X-b;do L[X++]=L[j++],L[X++]=L[j++],L[X++]=L[j++],N-=3;while(N>2);if(N){if(L[X++]=L[j++],N>1)L[X++]=L[j++]}}}else if((H&64)===0){w=M[(w&65535)+(F&(1<<H)-1)];continue Q}else{Q.msg="invalid distance code",S.mode=k1;break W}break}}else if((H&64)===0){w=R[(w&65535)+(F&(1<<H)-1)];continue J}else if(H&32){S.mode=FJ;break W}else{Q.msg="invalid literal/length code",S.mode=k1;break W}break}}while(V<G&&X<U);N=Z>>3,V-=N,Z-=N<<3,F&=(1<<Z)-1,Q.next_in=V,Q.next_out=X,Q.avail_in=V<G?5+(G-V):5-(V-G),Q.avail_out=X<U?257+(U-X):257-(X-U),S.hold=F,S.bits=Z;return},v0=15,g8=852,y8=592,E8=0,m1=1,f8=2,ZJ=new Uint16Array([3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,0,0]),HJ=new Uint8Array([16,16,16,16,16,16,16,16,17,17,17,17,18,18,18,18,19,19,19,19,20,20,20,20,21,21,21,21,16,72,78]),kJ=new Uint16Array([1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,0,0]),$J=new Uint8Array([16,16,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,64,64]),BJ=(W,Q,J,V,G,X,Y,U)=>{const K=U.bits;let q=0,P=0,k=0,z=0,F=0,Z=0,R=0,M=0,O=0,v=0,w,H,N,b,j,g=null,D;const L=new Uint16Array(v0+1),S=new Uint16Array(v0+1);let o=null,U1,Y0,V0;for(q=0;q<=v0;q++)L[q]=0;for(P=0;P<V;P++)L[Q[J+P]]++;F=K;for(z=v0;z>=1;z--)if(L[z]!==0)break;if(F>z)F=z;if(z===0)return G[X++]=1<<24|64<<16|0,G[X++]=1<<24|64<<16|0,U.bits=1,0;for(k=1;k<z;k++)if(L[k]!==0)break;if(F<k)F=k;M=1;for(q=1;q<=v0;q++)if(M<<=1,M-=L[q],M<0)return-1;if(M>0&&(W===E8||z!==1))return-1;S[1]=0;for(q=1;q<v0;q++)S[q+1]=S[q]+L[q];for(P=0;P<V;P++)if(Q[J+P]!==0)Y[S[Q[J+P]]++]=P;if(W===E8)g=o=Y,D=20;else if(W===m1)g=ZJ,o=HJ,D=257;else g=kJ,o=$J,D=0;if(v=0,P=0,q=k,j=X,Z=F,R=0,N=-1,O=1<<F,b=O-1,W===m1&&O>g8||W===f8&&O>y8)return 1;for(;;){if(U1=q-R,Y[P]+1<D)Y0=0,V0=Y[P];else if(Y[P]>=D)Y0=o[Y[P]-D],V0=g[Y[P]-D];else Y0=96,V0=0;w=1<<q-R,H=1<<Z,k=H;do H-=w,G[j+(v>>R)+H]=U1<<24|Y0<<16|V0|0;while(H!==0);w=1<<q-1;while(v&w)w>>=1;if(w!==0)v&=w-1,v+=w;else v=0;if(P++,--L[q]===0){if(q===z)break;q=Q[J+Y[P]]}if(q>F&&(v&b)!==N){if(R===0)R=F;j+=k,Z=q-R,M=1<<Z;while(Z+R<z){if(M-=L[Z+R],M<=0)break;Z++,M<<=1}if(O+=1<<Z,W===m1&&O>g8||W===f8&&O>y8)return 1;N=v&b,G[N]=F<<24|Z<<16|j-X|0}}if(v!==0)G[j+v]=q-R<<24|64<<16|0;return U.bits=F,0},n0=BJ,CJ=0,T6=1,g6=2,{Z_FINISH:p8,Z_BLOCK:jJ,Z_TREES:$1,Z_OK:L0,Z_STREAM_END:RJ,Z_NEED_DICT:MJ,Z_STREAM_ERROR:e,Z_DATA_ERROR:y6,Z_MEM_ERROR:E6,Z_BUF_ERROR:LJ,Z_DEFLATED:h8}=x0,w1=16180,b8=16181,u8=16182,m8=16183,c8=16184,_8=16185,d8=16186,i8=16187,l8=16188,r8=16189,L1=16190,X0=16191,c1=16192,n8=16193,_1=16194,o8=16195,a8=16196,t8=16197,e8=16198,B1=16199,C1=16200,s8=16201,W6=16202,J6=16203,Q6=16204,V6=16205,d1=16206,G6=16207,X6=16208,h=16209,f6=16210,p6=16211,xJ=852,IJ=592,wJ=15,OJ=wJ,q6=(W)=>{return(W>>>24&255)+(W>>>8&65280)+((W&65280)<<8)+((W&255)<<24)},I0=(W)=>{if(!W)return 1;const Q=W.state;if(!Q||Q.strm!==W||Q.mode<w1||Q.mode>p6)return 1;return 0},h6=(W)=>{if(I0(W))return e;const Q=W.state;if(W.total_in=W.total_out=Q.total=0,W.msg="",Q.wrap)W.adler=Q.wrap&1;return Q.mode=w1,Q.last=0,Q.havedict=0,Q.flags=-1,Q.dmax=32768,Q.head=null,Q.hold=0,Q.bits=0,Q.lencode=Q.lendyn=new Int32Array(xJ),Q.distcode=Q.distdyn=new Int32Array(IJ),Q.sane=1,Q.back=-1,L0},b6=(W)=>{if(I0(W))return e;const Q=W.state;return Q.wsize=0,Q.whave=0,Q.wnext=0,h6(W)},u6=(W,Q)=>{let J;if(I0(W))return e;const V=W.state;if(Q<0)J=0,Q=-Q;else if(J=(Q>>4)+5,Q<48)Q&=15;if(Q&&(Q<8||Q>15))return e;if(V.window!==null&&V.wbits!==Q)V.window=null;return V.wrap=J,V.wbits=Q,b6(W)},m6=(W,Q)=>{if(!W)return e;const J=new DJ;W.state=J,J.strm=W,J.window=null,J.mode=w1;const V=u6(W,Q);if(V!==L0)W.state=null;return V},AJ=(W)=>{return m6(W,OJ)},U6=!0,i1,l1,NJ=(W)=>{if(U6){i1=new Int32Array(512),l1=new Int32Array(32);let Q=0;while(Q<144)W.lens[Q++]=8;while(Q<256)W.lens[Q++]=9;while(Q<280)W.lens[Q++]=7;while(Q<288)W.lens[Q++]=8;n0(T6,W.lens,0,288,i1,0,W.work,{bits:9}),Q=0;while(Q<32)W.lens[Q++]=5;n0(g6,W.lens,0,32,l1,0,W.work,{bits:5}),U6=!1}W.lencode=i1,W.lenbits=9,W.distcode=l1,W.distbits=5},c6=(W,Q,J,V)=>{let G;const X=W.state;if(X.window===null)X.wsize=1<<X.wbits,X.wnext=0,X.whave=0,X.window=new Uint8Array(X.wsize);if(V>=X.wsize)X.window.set(Q.subarray(J-X.wsize,J),0),X.wnext=0,X.whave=X.wsize;else{if(G=X.wsize-X.wnext,G>V)G=V;if(X.window.set(Q.subarray(J-V,J-V+G),X.wnext),V-=G,V)X.window.set(Q.subarray(J-V,J),0),X.wnext=V,X.whave=X.wsize;else{if(X.wnext+=G,X.wnext===X.wsize)X.wnext=0;if(X.whave<X.wsize)X.whave+=G}}return 0},SJ=(W,Q)=>{let J,V,G,X,Y,U,K,q,P,k,z,F,Z,R,M=0,O,v,w,H,N,b,j,g;const D=new Uint8Array(4);let L,S;const o=new Uint8Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]);if(I0(W)||!W.output||!W.input&&W.avail_in!==0)return e;if(J=W.state,J.mode===X0)J.mode=c1;Y=W.next_out,G=W.output,K=W.avail_out,X=W.next_in,V=W.input,U=W.avail_in,q=J.hold,P=J.bits,k=U,z=K,g=L0;W:for(;;)switch(J.mode){case w1:if(J.wrap===0){J.mode=c1;break}while(P<16){if(U===0)break W;U--,q+=V[X++]<<P,P+=8}if(J.wrap&2&&q===35615){if(J.wbits===0)J.wbits=15;J.check=0,D[0]=q&255,D[1]=q>>>8&255,J.check=m(J.check,D,2,0),q=0,P=0,J.mode=b8;break}if(J.head)J.head.done=!1;if(!(J.wrap&1)||(((q&255)<<8)+(q>>8))%31){W.msg="incorrect header check",J.mode=h;break}if((q&15)!==h8){W.msg="unknown compression method",J.mode=h;break}if(q>>>=4,P-=4,j=(q&15)+8,J.wbits===0)J.wbits=j;if(j>15||j>J.wbits){W.msg="invalid window size",J.mode=h;break}J.dmax=1<<J.wbits,J.flags=0,W.adler=J.check=1,J.mode=q&512?r8:X0,q=0,P=0;break;case b8:while(P<16){if(U===0)break W;U--,q+=V[X++]<<P,P+=8}if(J.flags=q,(J.flags&255)!==h8){W.msg="unknown compression method",J.mode=h;break}if(J.flags&57344){W.msg="unknown header flags set",J.mode=h;break}if(J.head)J.head.text=q>>8&1;if(J.flags&512&&J.wrap&4)D[0]=q&255,D[1]=q>>>8&255,J.check=m(J.check,D,2,0);q=0,P=0,J.mode=u8;case u8:while(P<32){if(U===0)break W;U--,q+=V[X++]<<P,P+=8}if(J.head)J.head.time=q;if(J.flags&512&&J.wrap&4)D[0]=q&255,D[1]=q>>>8&255,D[2]=q>>>16&255,D[3]=q>>>24&255,J.check=m(J.check,D,4,0);q=0,P=0,J.mode=m8;case m8:while(P<16){if(U===0)break W;U--,q+=V[X++]<<P,P+=8}if(J.head)J.head.xflags=q&255,J.head.os=q>>8;if(J.flags&512&&J.wrap&4)D[0]=q&255,D[1]=q>>>8&255,J.check=m(J.check,D,2,0);q=0,P=0,J.mode=c8;case c8:if(J.flags&1024){while(P<16){if(U===0)break W;U--,q+=V[X++]<<P,P+=8}if(J.length=q,J.head)J.head.extra_len=q;if(J.flags&512&&J.wrap&4)D[0]=q&255,D[1]=q>>>8&255,J.check=m(J.check,D,2,0);q=0,P=0}else if(J.head)J.head.extra=null;J.mode=_8;case _8:if(J.flags&1024){if(F=J.length,F>U)F=U;if(F){if(J.head){if(j=J.head.extra_len-J.length,!J.head.extra)J.head.extra=new Uint8Array(J.head.extra_len);J.head.extra.set(V.subarray(X,X+F),j)}if(J.flags&512&&J.wrap&4)J.check=m(J.check,V,F,X);U-=F,X+=F,J.length-=F}if(J.length)break W}J.length=0,J.mode=d8;case d8:if(J.flags&2048){if(U===0)break W;F=0;do if(j=V[X+F++],J.head&&j&&J.length<65536)J.head.name+=String.fromCharCode(j);while(j&&F<U);if(J.flags&512&&J.wrap&4)J.check=m(J.check,V,F,X);if(U-=F,X+=F,j)break W}else if(J.head)J.head.name=null;J.length=0,J.mode=i8;case i8:if(J.flags&4096){if(U===0)break W;F=0;do if(j=V[X+F++],J.head&&j&&J.length<65536)J.head.comment+=String.fromCharCode(j);while(j&&F<U);if(J.flags&512&&J.wrap&4)J.check=m(J.check,V,F,X);if(U-=F,X+=F,j)break W}else if(J.head)J.head.comment=null;J.mode=l8;case l8:if(J.flags&512){while(P<16){if(U===0)break W;U--,q+=V[X++]<<P,P+=8}if(J.wrap&4&&q!==(J.check&65535)){W.msg="header crc mismatch",J.mode=h;break}q=0,P=0}if(J.head)J.head.hcrc=J.flags>>9&1,J.head.done=!0;W.adler=J.check=0,J.mode=X0;break;case r8:while(P<32){if(U===0)break W;U--,q+=V[X++]<<P,P+=8}W.adler=J.check=q6(q),q=0,P=0,J.mode=L1;case L1:if(J.havedict===0)return W.next_out=Y,W.avail_out=K,W.next_in=X,W.avail_in=U,J.hold=q,J.bits=P,MJ;W.adler=J.check=1,J.mode=X0;case X0:if(Q===jJ||Q===$1)break W;case c1:if(J.last){q>>>=P&7,P-=P&7,J.mode=d1;break}while(P<3){if(U===0)break W;U--,q+=V[X++]<<P,P+=8}switch(J.last=q&1,q>>>=1,P-=1,q&3){case 0:J.mode=n8;break;case 1:if(NJ(J),J.mode=B1,Q===$1){q>>>=2,P-=2;break W}break;case 2:J.mode=a8;break;case 3:W.msg="invalid block type",J.mode=h}q>>>=2,P-=2;break;case n8:q>>>=P&7,P-=P&7;while(P<32){if(U===0)break W;U--,q+=V[X++]<<P,P+=8}if((q&65535)!==(q>>>16^65535)){W.msg="invalid stored block lengths",J.mode=h;break}if(J.length=q&65535,q=0,P=0,J.mode=_1,Q===$1)break W;case _1:J.mode=o8;case o8:if(F=J.length,F){if(F>U)F=U;if(F>K)F=K;if(F===0)break W;G.set(V.subarray(X,X+F),Y),U-=F,X+=F,K-=F,Y+=F,J.length-=F;break}J.mode=X0;break;case a8:while(P<14){if(U===0)break W;U--,q+=V[X++]<<P,P+=8}if(J.nlen=(q&31)+257,q>>>=5,P-=5,J.ndist=(q&31)+1,q>>>=5,P-=5,J.ncode=(q&15)+4,q>>>=4,P-=4,J.nlen>286||J.ndist>30){W.msg="too many length or distance symbols",J.mode=h;break}J.have=0,J.mode=t8;case t8:while(J.have<J.ncode){while(P<3){if(U===0)break W;U--,q+=V[X++]<<P,P+=8}J.lens[o[J.have++]]=q&7,q>>>=3,P-=3}while(J.have<19)J.lens[o[J.have++]]=0;if(J.lencode=J.lendyn,J.lenbits=7,L={bits:J.lenbits},g=n0(CJ,J.lens,0,19,J.lencode,0,J.work,L),J.lenbits=L.bits,g){W.msg="invalid code lengths set",J.mode=h;break}J.have=0,J.mode=e8;case e8:while(J.have<J.nlen+J.ndist){for(;;){if(M=J.lencode[q&(1<<J.lenbits)-1],O=M>>>24,v=M>>>16&255,w=M&65535,O<=P)break;if(U===0)break W;U--,q+=V[X++]<<P,P+=8}if(w<16)q>>>=O,P-=O,J.lens[J.have++]=w;else{if(w===16){S=O+2;while(P<S){if(U===0)break W;U--,q+=V[X++]<<P,P+=8}if(q>>>=O,P-=O,J.have===0){W.msg="invalid bit length repeat",J.mode=h;break}j=J.lens[J.have-1],F=3+(q&3),q>>>=2,P-=2}else if(w===17){S=O+3;while(P<S){if(U===0)break W;U--,q+=V[X++]<<P,P+=8}q>>>=O,P-=O,j=0,F=3+(q&7),q>>>=3,P-=3}else{S=O+7;while(P<S){if(U===0)break W;U--,q+=V[X++]<<P,P+=8}q>>>=O,P-=O,j=0,F=11+(q&127),q>>>=7,P-=7}if(J.have+F>J.nlen+J.ndist){W.msg="invalid bit length repeat",J.mode=h;break}while(F--)J.lens[J.have++]=j}}if(J.mode===h)break;if(J.lens[256]===0){W.msg="invalid code -- missing end-of-block",J.mode=h;break}if(J.lenbits=9,L={bits:J.lenbits},g=n0(T6,J.lens,0,J.nlen,J.lencode,0,J.work,L),J.lenbits=L.bits,g){W.msg="invalid literal/lengths set",J.mode=h;break}if(J.distbits=6,J.distcode=J.distdyn,L={bits:J.distbits},g=n0(g6,J.lens,J.nlen,J.ndist,J.distcode,0,J.work,L),J.distbits=L.bits,g){W.msg="invalid distances set",J.mode=h;break}if(J.mode=B1,Q===$1)break W;case B1:J.mode=C1;case C1:if(U>=6&&K>=258){if(W.next_out=Y,W.avail_out=K,W.next_in=X,W.avail_in=U,J.hold=q,J.bits=P,zJ(W,z),Y=W.next_out,G=W.output,K=W.avail_out,X=W.next_in,V=W.input,U=W.avail_in,q=J.hold,P=J.bits,J.mode===X0)J.back=-1;break}J.back=0;for(;;){if(M=J.lencode[q&(1<<J.lenbits)-1],O=M>>>24,v=M>>>16&255,w=M&65535,O<=P)break;if(U===0)break W;U--,q+=V[X++]<<P,P+=8}if(v&&(v&240)===0){H=O,N=v,b=w;for(;;){if(M=J.lencode[b+((q&(1<<H+N)-1)>>H)],O=M>>>24,v=M>>>16&255,w=M&65535,H+O<=P)break;if(U===0)break W;U--,q+=V[X++]<<P,P+=8}q>>>=H,P-=H,J.back+=H}if(q>>>=O,P-=O,J.back+=O,J.length=w,v===0){J.mode=V6;break}if(v&32){J.back=-1,J.mode=X0;break}if(v&64){W.msg="invalid literal/length code",J.mode=h;break}J.extra=v&15,J.mode=s8;case s8:if(J.extra){S=J.extra;while(P<S){if(U===0)break W;U--,q+=V[X++]<<P,P+=8}J.length+=q&(1<<J.extra)-1,q>>>=J.extra,P-=J.extra,J.back+=J.extra}J.was=J.length,J.mode=W6;case W6:for(;;){if(M=J.distcode[q&(1<<J.distbits)-1],O=M>>>24,v=M>>>16&255,w=M&65535,O<=P)break;if(U===0)break W;U--,q+=V[X++]<<P,P+=8}if((v&240)===0){H=O,N=v,b=w;for(;;){if(M=J.distcode[b+((q&(1<<H+N)-1)>>H)],O=M>>>24,v=M>>>16&255,w=M&65535,H+O<=P)break;if(U===0)break W;U--,q+=V[X++]<<P,P+=8}q>>>=H,P-=H,J.back+=H}if(q>>>=O,P-=O,J.back+=O,v&64){W.msg="invalid distance code",J.mode=h;break}J.offset=w,J.extra=v&15,J.mode=J6;case J6:if(J.extra){S=J.extra;while(P<S){if(U===0)break W;U--,q+=V[X++]<<P,P+=8}J.offset+=q&(1<<J.extra)-1,q>>>=J.extra,P-=J.extra,J.back+=J.extra}if(J.offset>J.dmax){W.msg="invalid distance too far back",J.mode=h;break}J.mode=Q6;case Q6:if(K===0)break W;if(F=z-K,J.offset>F){if(F=J.offset-F,F>J.whave){if(J.sane){W.msg="invalid distance too far back",J.mode=h;break}}if(F>J.wnext)F-=J.wnext,Z=J.wsize-F;else Z=J.wnext-F;if(F>J.length)F=J.length;R=J.window}else R=G,Z=Y-J.offset,F=J.length;if(F>K)F=K;K-=F,J.length-=F;do G[Y++]=R[Z++];while(--F);if(J.length===0)J.mode=C1;break;case V6:if(K===0)break W;G[Y++]=J.length,K--,J.mode=C1;break;case d1:if(J.wrap){while(P<32){if(U===0)break W;U--,q|=V[X++]<<P,P+=8}if(z-=K,W.total_out+=z,J.total+=z,J.wrap&4&&z)W.adler=J.check=J.flags?m(J.check,G,z,Y-z):s0(J.check,G,z,Y-z);if(z=K,J.wrap&4&&(J.flags?q:q6(q))!==J.check){W.msg="incorrect data check",J.mode=h;break}q=0,P=0}J.mode=G6;case G6:if(J.wrap&&J.flags){while(P<32){if(U===0)break W;U--,q+=V[X++]<<P,P+=8}if(J.wrap&4&&q!==(J.total&4294967295)){W.msg="incorrect length check",J.mode=h;break}q=0,P=0}J.mode=X6;case X6:g=RJ;break W;case h:g=y6;break W;case f6:return E6;case p6:default:return e}if(W.next_out=Y,W.avail_out=K,W.next_in=X,W.avail_in=U,J.hold=q,J.bits=P,J.wsize||z!==W.avail_out&&J.mode<h&&(J.mode<d1||Q!==p8)){if(c6(W,W.output,W.next_out,z-W.avail_out));}if(k-=W.avail_in,z-=W.avail_out,W.total_in+=k,W.total_out+=z,J.total+=z,J.wrap&4&&z)W.adler=J.check=J.flags?m(J.check,G,z,W.next_out-z):s0(J.check,G,z,W.next_out-z);if(W.data_type=J.bits+(J.last?64:0)+(J.mode===X0?128:0)+(J.mode===B1||J.mode===_1?256:0),(k===0&&z===0||Q===p8)&&g===L0)g=LJ;return g},vJ=(W)=>{if(I0(W))return e;let Q=W.state;if(Q.window)Q.window=null;return W.state=null,L0},TJ=(W,Q)=>{if(I0(W))return e;const J=W.state;if((J.wrap&2)===0)return e;return J.head=Q,Q.done=!1,L0},gJ=(W,Q)=>{const J=Q.length;let V,G,X;if(I0(W))return e;if(V=W.state,V.wrap!==0&&V.mode!==L1)return e;if(V.mode===L1){if(G=1,G=s0(G,Q,J,0),G!==V.check)return y6}if(X=c6(W,Q,J,J),X)return V.mode=f6,E6;return V.havedict=1,L0},yJ=b6,EJ=u6,fJ=h6,pJ=AJ,hJ=m6,bJ=SJ,uJ=vJ,mJ=TJ,cJ=gJ,_J="pako inflate (from Nodeca project)",U0={inflateReset:yJ,inflateReset2:EJ,inflateResetKeep:fJ,inflateInit:pJ,inflateInit2:hJ,inflate:bJ,inflateEnd:uJ,inflateGetHeader:mJ,inflateSetDictionary:cJ,inflateInfo:_J},iJ=dJ,_6=Object.prototype.toString,{Z_NO_FLUSH:lJ,Z_FINISH:rJ,Z_OK:Q1,Z_STREAM_END:r1,Z_NEED_DICT:n1,Z_STREAM_ERROR:nJ,Z_DATA_ERROR:Y6,Z_MEM_ERROR:oJ}=x0;q1.prototype.push=function(W,Q){const J=this.strm,V=this.options.chunkSize,G=this.options.dictionary;let X,Y,U;if(this.ended)return!1;if(Q===~~Q)Y=Q;else Y=Q===!0?rJ:lJ;if(_6.call(W)==="[object ArrayBuffer]")J.input=new Uint8Array(W);else J.input=W;J.next_in=0,J.avail_in=J.input.length;for(;;){if(J.avail_out===0)J.output=new Uint8Array(V),J.next_out=0,J.avail_out=V;if(X=U0.inflate(J,Y),X===n1&&G){if(X=U0.inflateSetDictionary(J,G),X===Q1)X=U0.inflate(J,Y);else if(X===Y6)X=n1}while(J.avail_in>0&&X===r1&&J.state.wrap>0&&W[J.next_in]!==0)U0.inflateReset(J),X=U0.inflate(J,Y);switch(X){case nJ:case Y6:case n1:case oJ:return this.onEnd(X),this.ended=!0,!1}if(U=J.avail_out,J.next_out){if(J.avail_out===0||X===r1)if(this.options.to==="string"){let K=J1.utf8border(J.output,J.next_out),q=J.next_out-K,P=J1.buf2string(J.output,K);if(J.next_out=q,J.avail_out=V-q,q)J.output.set(J.output.subarray(K,K+q),0);this.onData(P)}else this.onData(J.output.length===J.next_out?J.output:J.output.subarray(0,J.next_out))}if(X===Q1&&U===0)continue;if(X===r1)return X=U0.inflateEnd(this.strm),this.onEnd(X),this.ended=!0,!0;if(J.avail_in===0)break}return!0};q1.prototype.onData=function(W){this.chunks.push(W)};q1.prototype.onEnd=function(W){if(W===Q1)if(this.options.to==="string")this.result=this.chunks.join("");else this.result=I1.flattenChunks(this.chunks);this.chunks=[],this.err=W,this.msg=this.strm.msg};var tJ=q1,eJ=K8,sJ=aJ,W7=K8,J7=x0,Q7={Inflate:tJ,inflate:eJ,inflateRaw:sJ,ungzip:W7,constants:J7},{Deflate:V7,deflate:G7,deflateRaw:X7,gzip:q7}=KJ,{Inflate:U7,inflate:Y7,inflateRaw:P7,ungzip:K7}=Q7,F7=V7,z7=G7,Z7=X7,H7=q7,k7=U7,$7=Y7,B7=P7,C7=K7,j7=x0,h0={Deflate:F7,deflate:z7,deflateRaw:Z7,gzip:H7,Inflate:k7,inflate:$7,inflateRaw:B7,ungzip:C7,constants:j7};function d6(W,Q,J){let V=Q.timestamp;if(V?.physical>Date.now()+7200000)V={physical:Date.now()+7200000,logical:V.logical};if(!W?.timestamp)return{resolved:!0,value:Q.value,timestamp:V};if(J.compare(V,W.timestamp)<=0)return{resolved:!1};return{resolved:!0,value:Q.value,timestamp:V}}function i6(W,Q=50){const J=`gdb_oplog_${W}`;let V=[];function G(){try{const Y=localStorage.getItem(J);V=Y?JSON.parse(Y):[]}catch(Y){console.error("\u274C GDB: Failed to load oplog from localStorage:",Y),V=[]}}function X(){try{localStorage.setItem(J,JSON.stringify(V))}catch(Y){console.error("\u274C GDB: Failed to save oplog to localStorage:",Y)}}return G(),{remove(Y){V=V.filter((U)=>U.id!==Y),X()},add(Y){if(V.push(Y),V.length>Q)V.shift();X()},getDelta(Y,U){if(!Y)return[...V];return V.filter((K)=>U(K.timestamp,Y)>0)},getOldest(){return V[0]},clear(){V=[],localStorage.removeItem(J)}}}var R7=()=>{const W=new Map,Q=async()=>{try{const K=await navigator.storage.getDirectory(),P=await(await K.getFileHandle("~opfs-sync-test",{create:!0})).createSyncAccessHandle?.();return await P?.close(),await K.removeEntry("~opfs-sync-test"),!!P}catch{return!1}};let J="idb";const V=(async()=>{if(await Q())J="sync";else try{const K=await navigator.storage.getDirectory(),P=await(await K.getFileHandle("~opfs-async-test",{create:!0})).createWritable?.();if(await P?.close(),await K.removeEntry("~opfs-async-test"),P)J="async";else J="idb"}catch{J="idb"}})(),G=async(K,q)=>{if(!W.has(K))W.set(K,[]);const P=W.get(K),k=P[P.length-1]||Promise.resolve();let z;const F=new Promise((Z)=>z=Z);P.push(F);try{return await k,await q()}finally{if(P.shift(),z(),P.length===0)W.delete(K)}},X=(()=>{let K;const q=async()=>{if(!K)K=new Promise((P,k)=>{const z=indexedDB.open("opfs-fallback-db",1);z.onupgradeneeded=()=>z.result.createObjectStore("files"),z.onsuccess=()=>P(z.result),z.onerror=()=>k(z.error)});return K};return{getDB:q,get:async(P)=>{const k=await q();return new Promise((z,F)=>{const R=k.transaction("files","readonly").objectStore("files").get(P);R.onsuccess=()=>z(R.result||new Uint8Array),R.onerror=()=>F(R.error)})},set:async(P,k)=>{const z=await q();return new Promise((F,Z)=>{const M=z.transaction("files","readwrite").objectStore("files").put(k,P);M.onsuccess=()=>F(),M.onerror=()=>Z(M.error)})}}})(),Y=async(K)=>{await V;try{if(J==="idb"){const F=await X.get(K);return{type:"loaded",name:K,data:F}}const P=await(await navigator.storage.getDirectory()).getFileHandle(K);if(J==="sync"){let F;try{F=await P.createSyncAccessHandle();const Z=F.getSize(),R=new Uint8Array(Z),M=F.read(R,{at:0});return{type:"loaded",name:K,data:R.slice(0,M)}}finally{F?.close()}}const k=await P.getFile(),z=new Uint8Array(await k.arrayBuffer());return{type:"loaded",name:K,data:z}}catch(q){const P=q.name==="NotFoundError"?"File not found":q.message||"Error reading file";return{type:"error",name:K,message:P}}},U=async(K,q)=>{if(await V,!(q instanceof Uint8Array))return{type:"error",name:K,message:"Content must be a Uint8Array"};return G(K,async()=>{try{if(J==="idb")return await X.set(K,q),{type:"saved",name:K};const k=await(await navigator.storage.getDirectory()).getFileHandle(K,{create:!0});if(J==="sync"){let z;try{z=await k.createSyncAccessHandle(),z.truncate(0),z.write(q,{at:0}),z.flush()}finally{z?.close()}}else{let z;try{z=await k.createWritable(),await z.write(q)}finally{await z?.close()}}return{type:"saved",name:K}}catch(P){return{type:"error",name:K,message:P.message||"Error saving file"}}})};self.onmessage=async({data:K})=>{const{type:q,name:P,content:k}=K;await V;const z={load:()=>Y(P),save:()=>U(P,k)};try{const F=z[q],Z=F?await F():{type:"error",message:`Unrecognized action type: ${q}`};self.postMessage(Z)}catch(F){console.error("\u274C Worker unexpected error:",F),self.postMessage({type:"error",name:P,message:F.message||"Unexpected worker error"})}}},l6=R7;var w0={$eq:(W,Q)=>W===Q,$ne:(W,Q)=>W!==Q,$gt:(W,Q)=>W>Q,$gte:(W,Q)=>W>=Q,$lt:(W,Q)=>W<Q,$lte:(W,Q)=>W<=Q,$in:(W,Q)=>Array.isArray(Q)&&(Array.isArray(W)?W.some((J)=>Q.includes(J)):Q.includes(W)),$between:(W,[Q,J])=>W>=Q&&W<=J,$exists:(W,Q)=>Q?W!==void 0:W===void 0,$text:{global:(W,Q)=>{const J=(G)=>String(G).normalize("NFD").replace(/[\u0300-\u036f]/g,"").toLowerCase().replace(/[^\w\s]/g,""),V=J(Q);return Object.values(W).some((G)=>typeof G==="object"?null.fieldSearch(G,V):J(G).includes(V))},field:(W,Q)=>{const J=(G)=>String(G).normalize("NFD").replace(/[\u0300-\u036f]/g,"").toLowerCase().replace(/[^\w\s]/g,""),V=J(Q);return Array.isArray(W)?W.some((G)=>J(G).includes(V)):J(W).includes(V)}},$like:(W,Q)=>typeof W==="string"&&typeof Q==="string"&&new RegExp(`^${Q.replace(/%/g,".*").replace(/_/g,".")}\$`,"i").test(W),$regex:(W,Q)=>typeof W==="string"&&new RegExp(Q.$regex||Q,"i").test(W),$and:(W,Q,J)=>Q.every((V)=>J.createFilter(V,J.allNodes)(W)),$or:(W,Q,J)=>Q.some((V)=>J.createFilter(V,J.allNodes)(W)),$not:(W,Q,J)=>!J.createFilter(Q,J.allNodes)(W),$edge:(W,Q,J)=>{if(!W.edges?.length||typeof Q!=="object"||Q===null)return!1;const V=J.createFilter(Q,J.allNodes),G=[...W.edges],X=new Set(G).add(W.id),Y=[];while(G.length){const U=G.shift(),K=J.allNodes[U];if(!K)continue;if(V(K))Y.push(K);K.edges?.forEach((q)=>!X.has(q)&&X.add(q)&&G.push(q))}if(Y.length)W._edgeResult=Y;return Y.length>0}},F8=(W,Q)=>Q.split(".").reduce((J,V)=>J&&typeof J==="object"&&(V in J)?J[V]:void 0,W),O1=(W,Q)=>{if(Object.keys(W).length===0)return()=>!0;return(J)=>Object.entries(W).every(([V,G])=>{if(V.startsWith("$"))return w0[V](J,G,{createFilter:O1,allNodes:Q});const X=F8(J.value,V);if(typeof G!=="object"||G===null)return w0.$eq(X,G);return Object.entries(G).every(([Y,U])=>{if(Y==="$text")return w0.$text.field(X,U);if(Y==="$between"&&U.every((K)=>K instanceof Date))return w0.$between(new Date(X),U);return w0[Y]?.(X,U,{createFilter:O1,allNodes:Q})??!1})})},z8=(W,Q)=>{const{$edge:J,...V}=Q.query||{},G=O1(V,W),X=Object.values(W).filter(G);let U=[...J?(()=>{const K=O1({$edge:J},W);X.forEach((P)=>K(P));const q=new Map;return X.forEach((P)=>{if(P._edgeResult)P._edgeResult.forEach((k)=>q.set(k.id,k)),delete P._edgeResult}),Array.from(q.values())})():X];if(Q.field){const K=Q.order==="asc"?1:-1;U.sort((q,P)=>{const k=F8(q.value,Q.field),z=F8(P.value,Q.field);if(typeof k==="string"&&typeof z==="string")return k.localeCompare(z)*K;return((k??0)-(z??0))*K})}if(Q.$after){const K=U.findIndex((q)=>q.id===Q.$after);U=K>=0?U.slice(K+1):[]}if(Q.$before){const K=U.findIndex((q)=>q.id===Q.$before);U=K>=0?U.slice(0,K):[]}if(Q.$limit)U=U.slice(0,Q.$limit);return U};function r6(){let W=Date.now(),Q=0;return{now(){const J=Date.now();return W=Math.max(W,J),Q++,{physical:W,logical:Q}},update(J){if(!J||typeof J.physical!=="number"||typeof J.logical!=="number"){console.warn("\u26A0\uFE0F HybridClock.update received an invalid remote timestamp.",J);return}W=Math.max(W,J.physical),Q=Math.max(Q,J.logical)+1},compare(J,V){if(!J&&!V)return 0;if(!J)return-1;if(!V)return 1;if(J.physical>V.physical)return 1;if(J.physical<V.physical)return-1;if(J.logical>V.logical)return 1;if(J.logical<V.logical)return-1;return 0}}}var n6=function(W,Q){return W.length===Q.length&&W.every((J,V)=>J===Q[V])};async function L7(){if(console.info(navigator?.storage?.getDirectory?"\u2705 OPFS is enabled.":"\uD83D\uDEAB OPFS is not available."),navigator?.storage?.getDirectory)await navigator.storage.getDirectory()}var x7=function(){const W={nodes:{}};return{get nodes(){return W.nodes},set nodes(J){W.nodes=J||{}},upsert(J,V,G){const X=W.nodes[J];W.nodes[J]={id:J,value:V&&typeof V==="object"?a6(V):V,edges:X?.edges?[...X.edges]:[],timestamp:G}},get(J){return W.nodes[J]||null},link(J,V,G){const X=W.nodes[J],Y=W.nodes[V];if(X&&Y&&!X.edges.includes(V))W.nodes[J]={...X,edges:[...X.edges,V],timestamp:G}},getAllNodes(){return Object.values(W.nodes)},serialize(){return h0.deflate(N0(W.nodes))},deserialize(J){W.nodes=c0(h0.inflate(new Uint8Array(J)))}}};async function t6(W,Q={}){console.info("\x1B[36m\u26A1 GenosDB: Empowering distributed graph databases with real-time synchronization and scalability. Learn more: https://github.com/estebanrfp/gdb \u26A1\x1B[0m");const{rtc:J=!1,password:V,sm:G=!1,audit:X=!1,ii:Y=!1,rx:U=!1,ai:K=!1,geo:q=!1,relayUrls:P=null,turnConfig:k=null,saveDelay:z=200,oplogSize:F=20}=Q,Z=x7(),R=r6(),M=i6(W,F),O=[];let v=null,w=[],H=null,N=null,b=null,j=null;const g=[],D={};Object.defineProperties(D,{hybridClock:{get:()=>R},graph:{get:()=>Z},syncChannel:{get:()=>N},worker:{get:()=>H},oplog:{get:()=>M},broadcastChannel:{get:()=>b},options:{get:()=>Q},pako:{get:()=>h0},encode:{get:()=>N0},decode:{get:()=>c0},operators:{get:()=>w0},deepClone:{get:()=>a6},generateHash:{get:()=>Z8}});async function L(B,x){try{const C=await import(new URL(`./${B}.min.js`,import.meta.url).href),E=x&&typeof x==="object"?x:{},$=C.init?.(D,C,E);if($)Object.assign(D,$);return C}catch(C){throw console.error(`\u274C Initialization of ${B} failed:`,C),C}}function S(){const B=localStorage.getItem(`${W}_time`);v=B?JSON.parse(B):null}function o(B){v=B,localStorage.setItem(`${W}_time`,JSON.stringify(B))}function U1(){try{const B=URL.createObjectURL(new Blob([`(${l6.toString()})()`],{type:"application/javascript"}));H=new Worker(B),URL.revokeObjectURL(B),H.addEventListener("message",({data:x})=>{console.info(`\uD83D\uDCBE ${x.name} ${x.type}`)}),console.info("\u2699\uFE0F Worker initialized successfully.")}catch({message:B}){console.error("\u274C Failed to initialize worker:",B)}}function Y0(){const B={...Z.nodes};w.forEach((x)=>x(B))}const V0=M7(()=>Y0()),D1=o6(async()=>{const B=g.splice(0,g.length);if(!B.length)return!1;return await N.send(B),!0},16);async function Z8(){return crypto.randomUUID()}async function H8(){try{const x=await((C)=>new Promise((E,$)=>{const A=async({data:I})=>{if(I.type==="loaded"&&I.name===C)H.removeEventListener("message",A),E(new Uint8Array(I.data));else if(I.type==="error")H.removeEventListener("message",A),$(new Error(I.message||"Unknown error"))};H.addEventListener("message",A),H.postMessage({type:"load",name:C})}))(`${W}_graph.msgpack`).catch(()=>new Uint8Array);x.byteLength>0?Z.deserialize(x):console.warn("\u26A0\uFE0F The file '_graph.msgpack' is empty or could not be loaded."),console.info(`\u2705 Graph loaded: [ ${Z.getAllNodes().length} nodes ]`)}catch({message:B}){console.error("\u274C Error loading the graph:",B)}}async function A1(){try{const B=Z.serialize();return await((C,E)=>new Promise(($,A)=>{const I=({data:f})=>{if(f.type==="saved"&&f.name===C)H.removeEventListener("message",I),$();else if(f.type==="error")H.removeEventListener("message",I),A(new Error(f.message||"Save error"))};H.addEventListener("message",I),H.postMessage({type:"save",name:C,content:E})}))(`${W}_graph.msgpack`,B),b.postMessage("update"),!0}catch({message:B}){throw console.error("\u274C Save error:",B),new Error("Save failed")}}const N1=o6(()=>A1(),z);async function e6(B){try{console.info("\uD83D\uDD04 Applying full graph from remote..."),Z.nodes={...B.nodes},await A1()}catch({message:x}){console.error(`\u274C Error applying the full graph: ${x}`)}}async function s6(B){let x=!1,C=null;const E={upsert:($)=>{const A=Z.get($.id),I=d6(A,$,R);if(I.resolved){if(Z.upsert($.id,I.value,I.timestamp),R.update(I.timestamp),M.add({type:"upsert",id:$.id,timestamp:I.timestamp}),x=!0,!C||R.compare(I.timestamp,C)>0)C=I.timestamp}},remove:($)=>{const A=Z.get($.id);if(A&&R.compare(A.timestamp,$.timestamp)<0){if(delete Z.nodes[$.id],R.update($.timestamp),M.add({type:"remove",id:$.id,timestamp:$.timestamp}),x=!0,!C||R.compare($.timestamp,C)>0)C=$.timestamp}},link:($)=>{const A=Z.get($.sourceId),I=Z.get($.targetId);if(A&&I&&R.compare(A.timestamp,$.timestamp)<0){if(Z.link($.sourceId,$.targetId,$.timestamp),R.update($.timestamp),M.add({type:"link",sourceId:$.sourceId,targetId:$.targetId,timestamp:$.timestamp}),x=!0,!C||R.compare($.timestamp,C)>0)C=$.timestamp}},sync:async($)=>{const A=$.timestamp;if(A===null){console.info("\uD83D\uDCEC [SYNC REQUEST] from new peer (no timestamp). Sending full graph."),await N.send([{type:"syncReceive",graph:Z}]);return}console.info("\uD83D\uDCEC [SYNC REQUEST] since:",new Date(A.physical).toLocaleString());const I=M.getOldest();if(I&&R.compare(A,I.timestamp)<0){console.info("\uD83D\uDCA5 [FALLBACK TRIGGERED] Peer is too far behind. Sending FULL graph state."),await N.send([{type:"syncReceive",graph:Z}]);return}const f=M.getDelta(A,R.compare);if(f.length>0){const p=f.map((_)=>{if(_.type==="upsert"){const G0=Z.get(_.id);return{..._,value:G0?G0.value:null}}return _}),a=h0.deflate(N0(p));console.info(`\uD83D\uDE80 [DELTA SYNC SENDING] Found ${f.length} new operations to send.`),await N.send([{type:"deltaSync",operations:a}])}else console.info("\u2705 [ALREADY SYNCED] Peer is up-to-date. Nothing to send.")},deltaSync:($)=>{const A=$.operations.byteLength,I=c0(h0.inflate($.operations)),f=N0(I).byteLength;console.info(`\uD83D\uDEF0\uFE0F [DELTA SYNC RECEIVED] Applying ${I.length} operations from a peer.`),console.info(`   Compressed: ${A} bytes, Decompressed: ${f} bytes.`);for(let p of I)E[p.type]?.(p)},syncReceive:async($)=>{if(console.info("\uD83D\uDCE6 [FULL SYNC RECEIVED] Overwriting local state with full graph from a peer."),$.graph&&$.graph.nodes){await e6($.graph),M.clear(),console.info("\uD83D\uDD12 Oplog has been cleared due to full sync."),x=!0;let A=null;for(let I in $.graph.nodes){const f=$.graph.nodes[I];if(f.timestamp&&(!A||R.compare(f.timestamp,A)>0))A=f.timestamp}if(A)console.info("\uD83D\uDCC8 [GLOBAL TIMESTAMP] Updated from full sync."),C=A,R.update(A)}else console.error("\u274C Full sync failed: received graph data is invalid.",$.graph)}};for(let $ of B)if(E[$.type])await E[$.type]($);else console.warn(`\uD83E\uDD37\u200D\u2640\uFE0F [UNKNOWN MESSAGE TYPE] Received unhandled message type: "${$.type}"`);if(C){if(!v||R.compare(C,v)>0)console.info(`\uD83D\uDCC8 [GLOBAL TIMESTAMP] Advanced from ${v?.logical} to ${C.logical}.`),o(C)}if(x)console.info("\uD83D\uDCBE [STATE CHANGED] Saving state and emitting update."),await A1(),Y0()}Object.assign(D,{use(B){if(typeof B==="function")O.push(B)},async put(B,x){const C=R.now();o(C),x??=await Z8(),Z.upsert(x,B,C),M.add({type:"upsert",id:x,timestamp:C}),N1();try{g.push({type:"upsert",id:x,value:B,timestamp:C}),D1().catch(()=>{})}finally{V0()}return x},async link(B,x){const C=R.now();if(!Z.nodes[B]||!Z.nodes[x]){console.warn(`\u26A0\uFE0F One or both nodes (${B}, ${x}) do not exist.`);return}Z.link(B,x,C),M.add({type:"link",sourceId:B,targetId:x,timestamp:C}),N1(),o(C);try{g.push({type:"link",sourceId:B,targetId:x,timestamp:C}),D1().catch(()=>{})}finally{V0()}},async remove(B){const x=R.now(),C=Z.get(B);if(!C)return console.warn(`\u26A0\uFE0F Node with ID '${B}' not found.`);delete Z.nodes[B],M.add({type:"remove",id:B,timestamp:x}),Object.values(Z.nodes).forEach((E)=>E.edges=E.edges.filter(($)=>$!==B)),N1(),o(x);try{g.push({type:"remove",id:B,value:C.value,timestamp:x}),D1().catch(()=>{})}finally{V0()}},async get(B,x=null){if(typeof B!=="string")return{result:null};const C=Z.get(B);if(!C){if(x)x(null);return{result:null}}const E=(I)=>{if(!I)return null;const f=I.value!==null&&typeof I.value==="object"?{...I.value}:I.value;return{...I,value:f}};if(!x)return{result:E(C)};let $=C.timestamp;x(E(C));const A=(I)=>{const f=I[B];if(f){if(R.compare(f.timestamp,$)>0)$=f.timestamp,x(E(f))}else x(null),w.splice(w.indexOf(A),1)};return w.push(A),{result:E(C),unsubscribe:()=>{const I=w.indexOf(A);if(I>-1)w.splice(I,1)}}},async map(...B){let C={...{realtime:!1,query:{},field:null,order:"asc",$limit:null,$after:null,$before:null}},E=null,$=!1;B.forEach((p)=>typeof p==="function"?E=p:p&&typeof p==="object"&&($||=("realtime"in p),Object.assign(C,p))),E&&!$&&(C.realtime=!0);let A=z8(Z.nodes,C),I=null;const f=(p)=>{const a=new Map(A.map((u)=>[u.id,u])),_=new Map(p.map((u)=>[u.id,u])),G0=[],O0=[],k8=[];for(let[u,P0]of _){const Y1=a.get(u);if(!Y1)G0.push(P0);else if((P0.timestamp?.physical||0)!==(Y1.timestamp?.physical||0)||(P0.timestamp?.logical||0)!==(Y1.timestamp?.logical||0)||!n6(P0.edges||[],Y1.edges||[]))O0.push(P0)}for(let[u]of a)if(!_.has(u))k8.push(a.get(u));const S1=(u,P0)=>E({id:u.id,value:P0==="removed"?null:u.value,edges:u.edges||[],timestamp:u.timestamp||null,action:P0});G0.forEach((u)=>S1(u,"added")),k8.forEach((u)=>S1(u,"removed")),O0.forEach((u)=>S1(u,"updated"))};if(E){if(A.forEach((p)=>{E({id:p.id,value:p.value,edges:p.edges,timestamp:p.timestamp,action:"initial"})}),C.realtime){const p=(a)=>{const _=a.timestamp?.physical||0,G0=a.timestamp?.logical||0,O0=(a.edges||[]).join(",");return`${a.id}:${_}:${G0}:${O0}`};I=(a)=>{const _=z8(a,C);if(_.length!==A.length)f(_),A=_;else{const G0=_.map(p),O0=A.map(p);if(!n6(G0,O0))f(_),A=_}},w.push(I)}}return{results:A,...C.realtime&&E&&I&&{unsubscribe:()=>{const p=w.indexOf(I);p>-1&&w.splice(p,1)}}}},async clear(){Z.nodes={};try{await(await navigator.storage.getDirectory()).removeEntry(`${W}_graph.msgpack`)}catch({message:B}){console.warn(`\u26A0\uFE0F Error deleting _graph.msgpack: ${B}`)}Y0(),console.info("\u2705 All data has been deleted.")}}),U1(),S(),await L7(),await H8();const k0=[];if(G)k0.push(L("sm",G));if(K)k0.push(L("AIQuery",K));if(U)k0.push(L("radixindex",U));if(Y)k0.push(L("invertedindex",Y));if(X)k0.push(L("audit",X));if(q)k0.push(L("geo",q));await Promise.all(k0);const W5=`graph-sync-room-${W}`;if(Q.rtc){const{join:B}=await L("genosrtc"),x={appId:"1234",...V&&{password:V}};if(P)x.relayUrls=P;if(k)x.turnConfig=k;const C=B(x,W5);N=C.channel("syncGraph"),j=B(x,`app-sync-${W}`),D.room=j,C.on("peer:join",async(E)=>{console.info("\u26A1 New peer connected:",E),N.send([{type:"sync",timestamp:v}])}),C.on("peer:leave",(E)=>{console.info("\u26A1 Peer disconnected:",E)}),N.on("message",async(E)=>{let $=E;for(let A of O)try{if($=await A($),!$||$.length===0)return}catch(I){console.error("\u274C GDB: Middleware error, discarding message.",I);return}await s6($)})}return b=new BroadcastChannel(`graphdb_sync_${W}`),b.onmessage=async(B)=>{if(B.data==="update")console.info("\uD83D\uDD04 Update received from another tab..."),await H8(),S(),V0()},console.info(`\u2705 GenosDB [ ${W} ] instance is ready.`),D}var a6=(W)=>{if(W===null||typeof W!=="object")return W;if(typeof structuredClone==="function")return structuredClone(W);return JSON.parse(JSON.stringify(W))},o6=(W,Q=16)=>{let J=null,V=null;return(...G)=>{if(!V)V={},V.promise=new Promise((Y,U)=>(V.resolve=Y,V.reject=U));if(J)("cancelIdleCallback"in window?cancelIdleCallback:clearTimeout)(J);const X=async()=>{J=null;try{V.resolve(await W(...G))}catch(Y){V.reject(Y)}finally{V=null}};return J=("requestIdleCallback"in window)?requestIdleCallback(X,{timeout:Q}):setTimeout(X,Q),V.promise}},M7=(W)=>{let Q=null;return()=>{if(Q!==null)return;Q=requestAnimationFrame(()=>{Q=null,W()})}};var MQ=t6;class I7{constructor(){throw new Error("\u26A0\uFE0F WARNING: `new GDB()` is deprecated and will be removed. "+"Migrate to async factory function `const db = await gdb(...)`.\nMigration Guide: https://github.com/estebanrfp/gdb/wiki/Migration-Guide\nWiki: https://github.com/estebanrfp/gdb/wiki")}}export{MQ as gdb,I7 as GDB};
