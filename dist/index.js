function c6(W){const Q=W.length;let J=0,V=0;while(V<Q){let G=W.charCodeAt(V++);if((G&4294967168)===0){J++;continue}else if((G&4294965248)===0)J+=2;else{if(G>=55296&&G<=56319){if(V<Q){const X=W.charCodeAt(V);if((X&64512)===56320)++V,G=((G&1023)<<10)+(X&1023)+65536}}if((G&4294901760)===0)J+=3;else J+=4}}return J}function vW(W,Q,J){const V=W.length;let G=J,X=0;while(X<V){let q=W.charCodeAt(X++);if((q&4294967168)===0){Q[G++]=q;continue}else if((q&4294965248)===0)Q[G++]=q>>6&31|192;else{if(q>=55296&&q<=56319){if(X<V){const Y=W.charCodeAt(X);if((Y&64512)===56320)++X,q=((q&1023)<<10)+(Y&1023)+65536}}if((q&4294901760)===0)Q[G++]=q>>12&15|224,Q[G++]=q>>6&63|128;else Q[G++]=q>>18&7|240,Q[G++]=q>>12&63|128,Q[G++]=q>>6&63|128}Q[G++]=q&63|128}}function gW(W,Q,J){TW.encodeInto(W,Q.subarray(J))}function i6(W,Q,J){if(W.length>AW)gW(W,Q,J);else vW(W,Q,J)}function v8(W,Q,J){let V=Q;const G=V+J,X=[];let q="";while(V<G){const Y=W[V++];if((Y&128)===0)X.push(Y);else if((Y&224)===192){const F=W[V++]&63;X.push((Y&31)<<6|F)}else if((Y&240)===224){const F=W[V++]&63,U=W[V++]&63;X.push((Y&31)<<12|F<<6|U)}else if((Y&248)===240){const F=W[V++]&63,U=W[V++]&63,P=W[V++]&63;let H=(Y&7)<<18|F<<12|U<<6|P;if(H>65535)H-=65536,X.push(H>>>10&1023|55296),H=56320|H&1023;X.push(H)}else X.push(Y);if(X.length>=EW)q+=String.fromCharCode(...X),X.length=0}if(X.length>0)q+=String.fromCharCode(...X);return q}function fW(W,Q,J){const V=W.subarray(Q,Q+J);return yW.decode(V)}function l6(W,Q,J){if(J>pW)return fW(W,Q,J);else return v8(W,Q,J)}var TW=new TextEncoder,AW=50,EW=4096,yW=new TextDecoder,pW=200;class t0{constructor(W,Q){this.type=W,this.data=Q}}class V0 extends Error{constructor(W){super(W);const Q=Object.create(V0.prototype);Object.setPrototypeOf(this,Q),Object.defineProperty(this,"name",{configurable:!0,enumerable:!1,value:V0.name})}}function r6(W,Q,J){const V=J/4294967296,G=J;W.setUint32(Q,V),W.setUint32(Q+4,G)}function n1(W,Q,J){const V=Math.floor(J/4294967296),G=J;W.setUint32(Q,V),W.setUint32(Q+4,G)}function o1(W,Q){const J=W.getInt32(Q),V=W.getUint32(Q+4);return J*4294967296+V}function n6(W,Q){const J=W.getUint32(Q),V=W.getUint32(Q+4);return J*4294967296+V}var W1=4294967295;function mW({sec:W,nsec:Q}){if(W>=0&&Q>=0&&W<=uW)if(Q===0&&W<=hW){const J=new Uint8Array(4);return new DataView(J.buffer).setUint32(0,W),J}else{const J=W/4294967296,V=W&4294967295,G=new Uint8Array(8),X=new DataView(G.buffer);return X.setUint32(0,Q<<2|J&3),X.setUint32(4,V),G}else{const J=new Uint8Array(12),V=new DataView(J.buffer);return V.setUint32(0,Q),n1(V,4,W),J}}function _W(W){const Q=W.getTime(),J=Math.floor(Q/1000),V=(Q-J*1000)*1e6,G=Math.floor(V/1e9);return{sec:J+G,nsec:V-G*1e9}}function dW(W){if(W instanceof Date){const Q=_W(W);return mW(Q)}else return null}function cW(W){const Q=new DataView(W.buffer,W.byteOffset,W.byteLength);switch(W.byteLength){case 4:return{sec:Q.getUint32(0),nsec:0};case 8:{const J=Q.getUint32(0),V=Q.getUint32(4),G=(J&3)*4294967296+V,X=J>>>2;return{sec:G,nsec:X}}case 12:{const J=o1(Q,4),V=Q.getUint32(0);return{sec:J,nsec:V}}default:throw new V0(`Unrecognized data size for timestamp (expected 4, 8, or 12): ${W.length}`)}}function iW(W){const Q=cW(W);return new Date(Q.sec*1000+Q.nsec/1e6)}var bW=-1,hW=4294967295,uW=17179869183,o6={type:bW,encode:dW,decode:iW};class b0{constructor(){this.builtInEncoders=[],this.builtInDecoders=[],this.encoders=[],this.decoders=[],this.register(o6)}register({type:W,encode:Q,decode:J}){if(W>=0)this.encoders[W]=Q,this.decoders[W]=J;else{const V=-1-W;this.builtInEncoders[V]=Q,this.builtInDecoders[V]=J}}tryToEncode(W,Q){for(let J=0;J<this.builtInEncoders.length;J++){const V=this.builtInEncoders[J];if(V!=null){const G=V(W,Q);if(G!=null){const X=-1-J;return new t0(X,G)}}}for(let J=0;J<this.encoders.length;J++){const V=this.encoders[J];if(V!=null){const G=V(W,Q);if(G!=null)return new t0(J,G)}}if(W instanceof t0)return W;return null}decode(W,Q,J){const V=Q<0?this.builtInDecoders[-1-Q]:this.decoders[Q];if(V)return V(W,Q,J);else return new t0(Q,W)}}b0.defaultCodec=new b0;var lW=function(W){return W instanceof ArrayBuffer||typeof SharedArrayBuffer!=="undefined"&&W instanceof SharedArrayBuffer};function M1(W){if(W instanceof Uint8Array)return W;else if(ArrayBuffer.isView(W))return new Uint8Array(W.buffer,W.byteOffset,W.byteLength);else if(lW(W))return new Uint8Array(W);else return Uint8Array.from(W)}var rW=100,nW=2048;class a1{constructor(W){this.entered=!1,this.extensionCodec=W?.extensionCodec??b0.defaultCodec,this.context=W?.context,this.useBigInt64=W?.useBigInt64??!1,this.maxDepth=W?.maxDepth??rW,this.initialBufferSize=W?.initialBufferSize??nW,this.sortKeys=W?.sortKeys??!1,this.forceFloat32=W?.forceFloat32??!1,this.ignoreUndefined=W?.ignoreUndefined??!1,this.forceIntegerToFloat=W?.forceIntegerToFloat??!1,this.pos=0,this.view=new DataView(new ArrayBuffer(this.initialBufferSize)),this.bytes=new Uint8Array(this.view.buffer)}clone(){return new a1({extensionCodec:this.extensionCodec,context:this.context,useBigInt64:this.useBigInt64,maxDepth:this.maxDepth,initialBufferSize:this.initialBufferSize,sortKeys:this.sortKeys,forceFloat32:this.forceFloat32,ignoreUndefined:this.ignoreUndefined,forceIntegerToFloat:this.forceIntegerToFloat})}reinitializeState(){this.pos=0}encodeSharedRef(W){if(this.entered)return this.clone().encodeSharedRef(W);try{return this.entered=!0,this.reinitializeState(),this.doEncode(W,1),this.bytes.subarray(0,this.pos)}finally{this.entered=!1}}encode(W){if(this.entered)return this.clone().encode(W);try{return this.entered=!0,this.reinitializeState(),this.doEncode(W,1),this.bytes.slice(0,this.pos)}finally{this.entered=!1}}doEncode(W,Q){if(Q>this.maxDepth)throw new Error(`Too deep objects in depth ${Q}`);if(W==null)this.encodeNil();else if(typeof W==="boolean")this.encodeBoolean(W);else if(typeof W==="number")if(!this.forceIntegerToFloat)this.encodeNumber(W);else this.encodeNumberAsFloat(W);else if(typeof W==="string")this.encodeString(W);else if(this.useBigInt64&&typeof W==="bigint")this.encodeBigInt64(W);else this.encodeObject(W,Q)}ensureBufferSizeToWrite(W){const Q=this.pos+W;if(this.view.byteLength<Q)this.resizeBuffer(Q*2)}resizeBuffer(W){const Q=new ArrayBuffer(W),J=new Uint8Array(Q),V=new DataView(Q);J.set(this.bytes),this.view=V,this.bytes=J}encodeNil(){this.writeU8(192)}encodeBoolean(W){if(W===!1)this.writeU8(194);else this.writeU8(195)}encodeNumber(W){if(!this.forceIntegerToFloat&&Number.isSafeInteger(W))if(W>=0)if(W<128)this.writeU8(W);else if(W<256)this.writeU8(204),this.writeU8(W);else if(W<65536)this.writeU8(205),this.writeU16(W);else if(W<4294967296)this.writeU8(206),this.writeU32(W);else if(!this.useBigInt64)this.writeU8(207),this.writeU64(W);else this.encodeNumberAsFloat(W);else if(W>=-32)this.writeU8(224|W+32);else if(W>=-128)this.writeU8(208),this.writeI8(W);else if(W>=-32768)this.writeU8(209),this.writeI16(W);else if(W>=-2147483648)this.writeU8(210),this.writeI32(W);else if(!this.useBigInt64)this.writeU8(211),this.writeI64(W);else this.encodeNumberAsFloat(W);else this.encodeNumberAsFloat(W)}encodeNumberAsFloat(W){if(this.forceFloat32)this.writeU8(202),this.writeF32(W);else this.writeU8(203),this.writeF64(W)}encodeBigInt64(W){if(W>=BigInt(0))this.writeU8(207),this.writeBigUint64(W);else this.writeU8(211),this.writeBigInt64(W)}writeStringHeader(W){if(W<32)this.writeU8(160+W);else if(W<256)this.writeU8(217),this.writeU8(W);else if(W<65536)this.writeU8(218),this.writeU16(W);else if(W<4294967296)this.writeU8(219),this.writeU32(W);else throw new Error(`Too long string: ${W} bytes in UTF-8`)}encodeString(W){const J=c6(W);this.ensureBufferSizeToWrite(5+J),this.writeStringHeader(J),i6(W,this.bytes,this.pos),this.pos+=J}encodeObject(W,Q){const J=this.extensionCodec.tryToEncode(W,this.context);if(J!=null)this.encodeExtension(J);else if(Array.isArray(W))this.encodeArray(W,Q);else if(ArrayBuffer.isView(W))this.encodeBinary(W);else if(typeof W==="object")this.encodeMap(W,Q);else throw new Error(`Unrecognized object: ${Object.prototype.toString.apply(W)}`)}encodeBinary(W){const Q=W.byteLength;if(Q<256)this.writeU8(196),this.writeU8(Q);else if(Q<65536)this.writeU8(197),this.writeU16(Q);else if(Q<4294967296)this.writeU8(198),this.writeU32(Q);else throw new Error(`Too large binary: ${Q}`);const J=M1(W);this.writeU8a(J)}encodeArray(W,Q){const J=W.length;if(J<16)this.writeU8(144+J);else if(J<65536)this.writeU8(220),this.writeU16(J);else if(J<4294967296)this.writeU8(221),this.writeU32(J);else throw new Error(`Too large array: ${J}`);for(let V of W)this.doEncode(V,Q+1)}countWithoutUndefined(W,Q){let J=0;for(let V of Q)if(W[V]!==void 0)J++;return J}encodeMap(W,Q){const J=Object.keys(W);if(this.sortKeys)J.sort();const V=this.ignoreUndefined?this.countWithoutUndefined(W,J):J.length;if(V<16)this.writeU8(128+V);else if(V<65536)this.writeU8(222),this.writeU16(V);else if(V<4294967296)this.writeU8(223),this.writeU32(V);else throw new Error(`Too large map object: ${V}`);for(let G of J){const X=W[G];if(!(this.ignoreUndefined&&X===void 0))this.encodeString(G),this.doEncode(X,Q+1)}}encodeExtension(W){if(typeof W.data==="function"){const J=W.data(this.pos+6),V=J.length;if(V>=4294967296)throw new Error(`Too large extension object: ${V}`);this.writeU8(201),this.writeU32(V),this.writeI8(W.type),this.writeU8a(J);return}const Q=W.data.length;if(Q===1)this.writeU8(212);else if(Q===2)this.writeU8(213);else if(Q===4)this.writeU8(214);else if(Q===8)this.writeU8(215);else if(Q===16)this.writeU8(216);else if(Q<256)this.writeU8(199),this.writeU8(Q);else if(Q<65536)this.writeU8(200),this.writeU16(Q);else if(Q<4294967296)this.writeU8(201),this.writeU32(Q);else throw new Error(`Too large extension object: ${Q}`);this.writeI8(W.type),this.writeU8a(W.data)}writeU8(W){this.ensureBufferSizeToWrite(1),this.view.setUint8(this.pos,W),this.pos++}writeU8a(W){const Q=W.length;this.ensureBufferSizeToWrite(Q),this.bytes.set(W,this.pos),this.pos+=Q}writeI8(W){this.ensureBufferSizeToWrite(1),this.view.setInt8(this.pos,W),this.pos++}writeU16(W){this.ensureBufferSizeToWrite(2),this.view.setUint16(this.pos,W),this.pos+=2}writeI16(W){this.ensureBufferSizeToWrite(2),this.view.setInt16(this.pos,W),this.pos+=2}writeU32(W){this.ensureBufferSizeToWrite(4),this.view.setUint32(this.pos,W),this.pos+=4}writeI32(W){this.ensureBufferSizeToWrite(4),this.view.setInt32(this.pos,W),this.pos+=4}writeF32(W){this.ensureBufferSizeToWrite(4),this.view.setFloat32(this.pos,W),this.pos+=4}writeF64(W){this.ensureBufferSizeToWrite(8),this.view.setFloat64(this.pos,W),this.pos+=8}writeU64(W){this.ensureBufferSizeToWrite(8),r6(this.view,this.pos,W),this.pos+=8}writeI64(W){this.ensureBufferSizeToWrite(8),n1(this.view,this.pos,W),this.pos+=8}writeBigUint64(W){this.ensureBufferSizeToWrite(8),this.view.setBigUint64(this.pos,W),this.pos+=8}writeBigInt64(W){this.ensureBufferSizeToWrite(8),this.view.setBigInt64(this.pos,W),this.pos+=8}}function v0(W,Q){return new a1(Q).encodeSharedRef(W)}function s1(W){return`${W<0?"-":""}0x${Math.abs(W).toString(16).padStart(2,"0")}`}var oW=16,aW=16;class T8{constructor(W=oW,Q=aW){this.hit=0,this.miss=0,this.maxKeyLength=W,this.maxLengthPerKey=Q,this.caches=[];for(let J=0;J<this.maxKeyLength;J++)this.caches.push([])}canBeCached(W){return W>0&&W<=this.maxKeyLength}find(W,Q,J){const V=this.caches[J-1];W:for(let G of V){const X=G.bytes;for(let q=0;q<J;q++)if(X[q]!==W[Q+q])continue W;return G.str}return null}store(W,Q){const J=this.caches[W.length-1],V={bytes:W,str:Q};if(J.length>=this.maxLengthPerKey)J[Math.random()*J.length|0]=V;else J.push(V)}decode(W,Q,J){const V=this.find(W,Q,J);if(V!=null)return this.hit++,V;this.miss++;const G=v8(W,Q,J),X=Uint8Array.prototype.slice.call(W,Q,Q+J);return this.store(X,G),G}}var A8="array",L1="map_key",s6="map_value",sW=(W)=>{if(typeof W==="string"||typeof W==="number")return W;throw new V0("The type of key must be string or number but "+typeof W)};class e6{constructor(){this.stack=[],this.stackHeadPosition=-1}get length(){return this.stackHeadPosition+1}top(){return this.stack[this.stackHeadPosition]}pushArrayState(W){const Q=this.getUninitializedStateFromPool();Q.type=A8,Q.position=0,Q.size=W,Q.array=new Array(W)}pushMapState(W){const Q=this.getUninitializedStateFromPool();Q.type=L1,Q.readCount=0,Q.size=W,Q.map={}}getUninitializedStateFromPool(){if(this.stackHeadPosition++,this.stackHeadPosition===this.stack.length){const W={type:void 0,size:0,array:void 0,position:0,readCount:0,map:void 0,key:null};this.stack.push(W)}return this.stack[this.stackHeadPosition]}release(W){if(this.stack[this.stackHeadPosition]!==W)throw new Error("Invalid stack state. Released state is not on top of the stack.");if(W.type===A8){const J=W;J.size=0,J.array=void 0,J.position=0,J.type=void 0}if(W.type===L1||W.type===s6){const J=W;J.size=0,J.map=void 0,J.readCount=0,J.type=void 0}this.stackHeadPosition--}reset(){this.stack.length=0,this.stackHeadPosition=-1}}var R1=-1,g8=new DataView(new ArrayBuffer(0)),eW=new Uint8Array(g8.buffer);try{g8.getInt8(0)}catch(W){if(!(W instanceof RangeError))throw new Error("This module is not supported in the current JavaScript engine because DataView does not throw RangeError on out-of-bounds access")}var a6=new RangeError("Insufficient data"),tW=new T8;class e1{constructor(W){this.totalPos=0,this.pos=0,this.view=g8,this.bytes=eW,this.headByte=R1,this.stack=new e6,this.entered=!1,this.extensionCodec=W?.extensionCodec??b0.defaultCodec,this.context=W?.context,this.useBigInt64=W?.useBigInt64??!1,this.rawStrings=W?.rawStrings??!1,this.maxStrLength=W?.maxStrLength??W1,this.maxBinLength=W?.maxBinLength??W1,this.maxArrayLength=W?.maxArrayLength??W1,this.maxMapLength=W?.maxMapLength??W1,this.maxExtLength=W?.maxExtLength??W1,this.keyDecoder=W?.keyDecoder!==void 0?W.keyDecoder:tW,this.mapKeyConverter=W?.mapKeyConverter??sW}clone(){return new e1({extensionCodec:this.extensionCodec,context:this.context,useBigInt64:this.useBigInt64,rawStrings:this.rawStrings,maxStrLength:this.maxStrLength,maxBinLength:this.maxBinLength,maxArrayLength:this.maxArrayLength,maxMapLength:this.maxMapLength,maxExtLength:this.maxExtLength,keyDecoder:this.keyDecoder})}reinitializeState(){this.totalPos=0,this.headByte=R1,this.stack.reset()}setBuffer(W){const Q=M1(W);this.bytes=Q,this.view=new DataView(Q.buffer,Q.byteOffset,Q.byteLength),this.pos=0}appendBuffer(W){if(this.headByte===R1&&!this.hasRemaining(1))this.setBuffer(W);else{const Q=this.bytes.subarray(this.pos),J=M1(W),V=new Uint8Array(Q.length+J.length);V.set(Q),V.set(J,Q.length),this.setBuffer(V)}}hasRemaining(W){return this.view.byteLength-this.pos>=W}createExtraByteError(W){const{view:Q,pos:J}=this;return new RangeError(`Extra ${Q.byteLength-J} of ${Q.byteLength} byte(s) found at buffer[${W}]`)}decode(W){if(this.entered)return this.clone().decode(W);try{this.entered=!0,this.reinitializeState(),this.setBuffer(W);const Q=this.doDecodeSync();if(this.hasRemaining(1))throw this.createExtraByteError(this.pos);return Q}finally{this.entered=!1}}*decodeMulti(W){if(this.entered){yield*this.clone().decodeMulti(W);return}try{this.entered=!0,this.reinitializeState(),this.setBuffer(W);while(this.hasRemaining(1))yield this.doDecodeSync()}finally{this.entered=!1}}async decodeAsync(W){if(this.entered)return this.clone().decodeAsync(W);try{this.entered=!0;let Q=!1,J;for await(let q of W){if(Q)throw this.entered=!1,this.createExtraByteError(this.totalPos);this.appendBuffer(q);try{J=this.doDecodeSync(),Q=!0}catch(Y){if(!(Y instanceof RangeError))throw Y}this.totalPos+=this.pos}if(Q){if(this.hasRemaining(1))throw this.createExtraByteError(this.totalPos);return J}const{headByte:V,pos:G,totalPos:X}=this;throw new RangeError(`Insufficient data in parsing ${s1(V)} at ${X} (${G} in the current buffer)`)}finally{this.entered=!1}}decodeArrayStream(W){return this.decodeMultiAsync(W,!0)}decodeStream(W){return this.decodeMultiAsync(W,!1)}async*decodeMultiAsync(W,Q){if(this.entered){yield*this.clone().decodeMultiAsync(W,Q);return}try{this.entered=!0;let J=Q,V=-1;for await(let G of W){if(Q&&V===0)throw this.createExtraByteError(this.totalPos);if(this.appendBuffer(G),J)V=this.readArraySize(),J=!1,this.complete();try{while(!0)if(yield this.doDecodeSync(),--V===0)break}catch(X){if(!(X instanceof RangeError))throw X}this.totalPos+=this.pos}}finally{this.entered=!1}}doDecodeSync(){W:while(!0){const W=this.readHeadByte();let Q;if(W>=224)Q=W-256;else if(W<192)if(W<128)Q=W;else if(W<144){const V=W-128;if(V!==0){this.pushMapState(V),this.complete();continue W}else Q={}}else if(W<160){const V=W-144;if(V!==0){this.pushArrayState(V),this.complete();continue W}else Q=[]}else{const V=W-160;Q=this.decodeString(V,0)}else if(W===192)Q=null;else if(W===194)Q=!1;else if(W===195)Q=!0;else if(W===202)Q=this.readF32();else if(W===203)Q=this.readF64();else if(W===204)Q=this.readU8();else if(W===205)Q=this.readU16();else if(W===206)Q=this.readU32();else if(W===207)if(this.useBigInt64)Q=this.readU64AsBigInt();else Q=this.readU64();else if(W===208)Q=this.readI8();else if(W===209)Q=this.readI16();else if(W===210)Q=this.readI32();else if(W===211)if(this.useBigInt64)Q=this.readI64AsBigInt();else Q=this.readI64();else if(W===217){const V=this.lookU8();Q=this.decodeString(V,1)}else if(W===218){const V=this.lookU16();Q=this.decodeString(V,2)}else if(W===219){const V=this.lookU32();Q=this.decodeString(V,4)}else if(W===220){const V=this.readU16();if(V!==0){this.pushArrayState(V),this.complete();continue W}else Q=[]}else if(W===221){const V=this.readU32();if(V!==0){this.pushArrayState(V),this.complete();continue W}else Q=[]}else if(W===222){const V=this.readU16();if(V!==0){this.pushMapState(V),this.complete();continue W}else Q={}}else if(W===223){const V=this.readU32();if(V!==0){this.pushMapState(V),this.complete();continue W}else Q={}}else if(W===196){const V=this.lookU8();Q=this.decodeBinary(V,1)}else if(W===197){const V=this.lookU16();Q=this.decodeBinary(V,2)}else if(W===198){const V=this.lookU32();Q=this.decodeBinary(V,4)}else if(W===212)Q=this.decodeExtension(1,0);else if(W===213)Q=this.decodeExtension(2,0);else if(W===214)Q=this.decodeExtension(4,0);else if(W===215)Q=this.decodeExtension(8,0);else if(W===216)Q=this.decodeExtension(16,0);else if(W===199){const V=this.lookU8();Q=this.decodeExtension(V,1)}else if(W===200){const V=this.lookU16();Q=this.decodeExtension(V,2)}else if(W===201){const V=this.lookU32();Q=this.decodeExtension(V,4)}else throw new V0(`Unrecognized type byte: ${s1(W)}`);this.complete();const J=this.stack;while(J.length>0){const V=J.top();if(V.type===A8)if(V.array[V.position]=Q,V.position++,V.position===V.size)Q=V.array,J.release(V);else continue W;else if(V.type===L1){if(Q==="__proto__")throw new V0("The key __proto__ is not allowed");V.key=this.mapKeyConverter(Q),V.type=s6;continue W}else if(V.map[V.key]=Q,V.readCount++,V.readCount===V.size)Q=V.map,J.release(V);else{V.key=null,V.type=L1;continue W}}return Q}}readHeadByte(){if(this.headByte===R1)this.headByte=this.readU8();return this.headByte}complete(){this.headByte=R1}readArraySize(){const W=this.readHeadByte();switch(W){case 220:return this.readU16();case 221:return this.readU32();default:if(W<160)return W-144;else throw new V0(`Unrecognized array type byte: ${s1(W)}`)}}pushMapState(W){if(W>this.maxMapLength)throw new V0(`Max length exceeded: map length (${W}) > maxMapLengthLength (${this.maxMapLength})`);this.stack.pushMapState(W)}pushArrayState(W){if(W>this.maxArrayLength)throw new V0(`Max length exceeded: array length (${W}) > maxArrayLength (${this.maxArrayLength})`);this.stack.pushArrayState(W)}decodeString(W,Q){if(!this.rawStrings||this.stateIsMapKey())return this.decodeUtf8String(W,Q);return this.decodeBinary(W,Q)}decodeUtf8String(W,Q){if(W>this.maxStrLength)throw new V0(`Max length exceeded: UTF-8 byte length (${W}) > maxStrLength (${this.maxStrLength})`);if(this.bytes.byteLength<this.pos+Q+W)throw a6;const J=this.pos+Q;let V;if(this.stateIsMapKey()&&this.keyDecoder?.canBeCached(W))V=this.keyDecoder.decode(this.bytes,J,W);else V=l6(this.bytes,J,W);return this.pos+=Q+W,V}stateIsMapKey(){if(this.stack.length>0)return this.stack.top().type===L1;return!1}decodeBinary(W,Q){if(W>this.maxBinLength)throw new V0(`Max length exceeded: bin length (${W}) > maxBinLength (${this.maxBinLength})`);if(!this.hasRemaining(W+Q))throw a6;const J=this.pos+Q,V=this.bytes.subarray(J,J+W);return this.pos+=Q+W,V}decodeExtension(W,Q){if(W>this.maxExtLength)throw new V0(`Max length exceeded: ext length (${W}) > maxExtLength (${this.maxExtLength})`);const J=this.view.getInt8(this.pos+Q),V=this.decodeBinary(W,Q+1);return this.extensionCodec.decode(V,J,this.context)}lookU8(){return this.view.getUint8(this.pos)}lookU16(){return this.view.getUint16(this.pos)}lookU32(){return this.view.getUint32(this.pos)}readU8(){const W=this.view.getUint8(this.pos);return this.pos++,W}readI8(){const W=this.view.getInt8(this.pos);return this.pos++,W}readU16(){const W=this.view.getUint16(this.pos);return this.pos+=2,W}readI16(){const W=this.view.getInt16(this.pos);return this.pos+=2,W}readU32(){const W=this.view.getUint32(this.pos);return this.pos+=4,W}readI32(){const W=this.view.getInt32(this.pos);return this.pos+=4,W}readU64(){const W=n6(this.view,this.pos);return this.pos+=8,W}readI64(){const W=o1(this.view,this.pos);return this.pos+=8,W}readU64AsBigInt(){const W=this.view.getBigUint64(this.pos);return this.pos+=8,W}readI64AsBigInt(){const W=this.view.getBigInt64(this.pos);return this.pos+=8,W}readF32(){const W=this.view.getFloat32(this.pos);return this.pos+=4,W}readF64(){const W=this.view.getFloat64(this.pos);return this.pos+=8,W}}function t1(W,Q){return new e1(Q).decode(W)}var Y1=function(W){let Q=W.length;while(--Q>=0)W[Q]=0},y8=function(W,Q,J,V,G){this.static_tree=W,this.extra_bits=Q,this.extra_base=J,this.elems=V,this.max_length=G,this.has_stree=W&&W.length},p8=function(W,Q){this.dyn_tree=W,this.max_code=0,this.stat_desc=Q},$0=function(W,Q,J,V,G){this.good_length=W,this.max_lazy=Q,this.nice_length=J,this.max_chain=V,this.func=G},J9=function(){this.strm=null,this.status=0,this.pending_buf=null,this.pending_buf_size=0,this.pending_out=0,this.pending=0,this.wrap=0,this.gzhead=null,this.gzindex=0,this.method=P8,this.last_flush=-1,this.w_size=0,this.w_bits=0,this.w_mask=0,this.window=null,this.window_size=0,this.prev=null,this.head=null,this.ins_h=0,this.hash_size=0,this.hash_bits=0,this.hash_mask=0,this.hash_shift=0,this.block_start=0,this.match_length=0,this.prev_match=0,this.match_available=0,this.strstart=0,this.match_start=0,this.lookahead=0,this.prev_length=0,this.max_chain_length=0,this.max_lazy_match=0,this.level=0,this.strategy=0,this.good_match=0,this.nice_match=0,this.dyn_ltree=new Uint16Array(lJ*2),this.dyn_dtree=new Uint16Array((2*cJ+1)*2),this.bl_tree=new Uint16Array((2*iJ+1)*2),T0(this.dyn_ltree),T0(this.dyn_dtree),T0(this.bl_tree),this.l_desc=null,this.d_desc=null,this.bl_desc=null,this.bl_count=new Uint16Array(rJ+1),this.heap=new Uint16Array(2*s8+1),T0(this.heap),this.heap_len=0,this.heap_max=0,this.depth=new Uint16Array(2*s8+1),T0(this.depth),this.sym_buf=0,this.lit_bufsize=0,this.sym_next=0,this.sym_end=0,this.opt_len=0,this.static_len=0,this.matches=0,this.insert=0,this.bi_buf=0,this.bi_valid=0},O9=function(){this.input=null,this.next_in=0,this.avail_in=0,this.total_in=0,this.output=null,this.next_out=0,this.avail_out=0,this.total_out=0,this.msg="",this.state=null,this.data_type=2,this.adler=0},h1=function(W){this.options=K8.assign({level:S9,method:T9,chunkSize:16384,windowBits:15,memLevel:8,strategy:v9},W||{});let Q=this.options;if(Q.raw&&Q.windowBits>0)Q.windowBits=-Q.windowBits;else if(Q.gzip&&Q.windowBits>0&&Q.windowBits<16)Q.windowBits+=16;this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new G7,this.strm.avail_out=0;let J=w1.deflateInit2(this.strm,Q.level,Q.method,Q.windowBits,Q.memLevel,Q.strategy);if(J!==q8)throw new Error(_0[J]);if(Q.header)w1.deflateSetHeader(this.strm,Q.header);if(Q.dictionary){let V;if(typeof Q.dictionary==="string")V=y1.string2buf(Q.dictionary);else if(X7.call(Q.dictionary)==="[object ArrayBuffer]")V=new Uint8Array(Q.dictionary);else V=Q.dictionary;if(J=w1.deflateSetDictionary(this.strm,V),J!==q8)throw new Error(_0[J]);this._dict_set=!0}},U6=function(W,Q){const J=new h1(Q);if(J.push(W,!0),J.err)throw J.msg||_0[J.err];return J.result},A9=function(W,Q){return Q=Q||{},Q.raw=!0,U6(W,Q)},g9=function(W,Q){return Q=Q||{},Q.gzip=!0,U6(W,Q)},QQ=function(){this.strm=null,this.mode=0,this.last=!1,this.wrap=0,this.havedict=!1,this.flags=0,this.dmax=0,this.check=0,this.total=0,this.head=null,this.wbits=0,this.wsize=0,this.whave=0,this.wnext=0,this.window=null,this.hold=0,this.bits=0,this.length=0,this.offset=0,this.extra=0,this.lencode=null,this.distcode=null,this.lenbits=0,this.distbits=0,this.ncode=0,this.nlen=0,this.ndist=0,this.have=0,this.next=null,this.lens=new Uint16Array(320),this.work=new Uint16Array(288),this.lendyn=null,this.distdyn=null,this.sane=0,this.back=0,this.was=0},BQ=function(){this.text=0,this.time=0,this.xflags=0,this.os=0,this.extra=null,this.extra_len=0,this.name="",this.comment="",this.hcrc=0,this.done=!1},u1=function(W){this.options=K8.assign({chunkSize:65536,windowBits:15,to:""},W||{});const Q=this.options;if(Q.raw&&Q.windowBits>=0&&Q.windowBits<16){if(Q.windowBits=-Q.windowBits,Q.windowBits===0)Q.windowBits=-15}if(Q.windowBits>=0&&Q.windowBits<16&&!(W&&W.windowBits))Q.windowBits+=32;if(Q.windowBits>15&&Q.windowBits<48){if((Q.windowBits&15)===0)Q.windowBits|=15}this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new G7,this.strm.avail_out=0;let J=I0.inflateInit2(this.strm,Q.windowBits);if(J!==p1)throw new Error(_0[J]);if(this.header=new MQ,I0.inflateGetHeader(this.strm,this.header),Q.dictionary){if(typeof Q.dictionary==="string")Q.dictionary=y1.string2buf(Q.dictionary);else if(j7.call(Q.dictionary)==="[object ArrayBuffer]")Q.dictionary=new Uint8Array(Q.dictionary);if(Q.raw){if(J=I0.inflateSetDictionary(this.strm,Q.dictionary),J!==p1)throw new Error(_0[J])}}},P6=function(W,Q){const J=new u1(Q);if(J.push(W),J.err)throw J.msg||_0[J.err];return J.result},DQ=function(W,Q){return Q=Q||{},Q.raw=!0,P6(W,Q)};/*! pako 2.1.0 https://github.com/nodeca/pako @license (MIT AND Zlib) */var WJ=0,f5=1,JJ=2,QJ=3,VJ=258,V6=29,f1=256,S1=f1+1+V6,V1=30,G6=19,b5=2*S1+1,h0=15,E8=16,GJ=7,X6=256,h5=16,u5=17,m5=18,n8=new Uint8Array([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0]),X8=new Uint8Array([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13]),XJ=new Uint8Array([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7]),_5=new Uint8Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),YJ=512,O0=new Array((S1+2)*2);Y1(O0);var x1=new Array(V1*2);Y1(x1);var v1=new Array(YJ);Y1(v1);var T1=new Array(VJ-QJ+1);Y1(T1);var Y6=new Array(V6);Y1(Y6);var Y8=new Array(V1);Y1(Y8);var d5,c5,i5,l5=(W)=>{return W<256?v1[W]:v1[256+(W>>>7)]},A1=(W,Q)=>{W.pending_buf[W.pending++]=Q&255,W.pending_buf[W.pending++]=Q>>>8&255},Y0=(W,Q,J)=>{if(W.bi_valid>E8-J)W.bi_buf|=Q<<W.bi_valid&65535,A1(W,W.bi_buf),W.bi_buf=Q>>E8-W.bi_valid,W.bi_valid+=J-E8;else W.bi_buf|=Q<<W.bi_valid&65535,W.bi_valid+=J},j0=(W,Q,J)=>{Y0(W,J[Q*2],J[Q*2+1])},r5=(W,Q)=>{let J=0;do J|=W&1,W>>>=1,J<<=1;while(--Q>0);return J>>>1},qJ=(W)=>{if(W.bi_valid===16)A1(W,W.bi_buf),W.bi_buf=0,W.bi_valid=0;else if(W.bi_valid>=8)W.pending_buf[W.pending++]=W.bi_buf&255,W.bi_buf>>=8,W.bi_valid-=8},UJ=(W,Q)=>{const{dyn_tree:J,max_code:V}=Q,G=Q.stat_desc.static_tree,X=Q.stat_desc.has_stree,q=Q.stat_desc.extra_bits,Y=Q.stat_desc.extra_base,F=Q.stat_desc.max_length;let U,P,H,K,z,C,v=0;for(K=0;K<=h0;K++)W.bl_count[K]=0;J[W.heap[W.heap_max]*2+1]=0;for(U=W.heap_max+1;U<b5;U++){if(P=W.heap[U],K=J[J[P*2+1]*2+1]+1,K>F)K=F,v++;if(J[P*2+1]=K,P>V)continue;if(W.bl_count[K]++,z=0,P>=Y)z=q[P-Y];if(C=J[P*2],W.opt_len+=C*(K+z),X)W.static_len+=C*(G[P*2+1]+z)}if(v===0)return;do{K=F-1;while(W.bl_count[K]===0)K--;W.bl_count[K]--,W.bl_count[K+1]+=2,W.bl_count[F]--,v-=2}while(v>0);for(K=F;K!==0;K--){P=W.bl_count[K];while(P!==0){if(H=W.heap[--U],H>V)continue;if(J[H*2+1]!==K)W.opt_len+=(K-J[H*2+1])*J[H*2],J[H*2+1]=K;P--}}},n5=(W,Q,J)=>{const V=new Array(h0+1);let G=0,X,q;for(X=1;X<=h0;X++)G=G+J[X-1]<<1,V[X]=G;for(q=0;q<=Q;q++){let Y=W[q*2+1];if(Y===0)continue;W[q*2]=r5(V[Y]++,Y)}},PJ=()=>{let W,Q,J,V,G;const X=new Array(h0+1);J=0;for(V=0;V<V6-1;V++){Y6[V]=J;for(W=0;W<1<<n8[V];W++)T1[J++]=V}T1[J-1]=V,G=0;for(V=0;V<16;V++){Y8[V]=G;for(W=0;W<1<<X8[V];W++)v1[G++]=V}G>>=7;for(;V<V1;V++){Y8[V]=G<<7;for(W=0;W<1<<X8[V]-7;W++)v1[256+G++]=V}for(Q=0;Q<=h0;Q++)X[Q]=0;W=0;while(W<=143)O0[W*2+1]=8,W++,X[8]++;while(W<=255)O0[W*2+1]=9,W++,X[9]++;while(W<=279)O0[W*2+1]=7,W++,X[7]++;while(W<=287)O0[W*2+1]=8,W++,X[8]++;n5(O0,S1+1,X);for(W=0;W<V1;W++)x1[W*2+1]=5,x1[W*2]=r5(W,5);d5=new y8(O0,n8,f1+1,S1,h0),c5=new y8(x1,X8,0,V1,h0),i5=new y8(new Array(0),XJ,0,G6,GJ)},o5=(W)=>{let Q;for(Q=0;Q<S1;Q++)W.dyn_ltree[Q*2]=0;for(Q=0;Q<V1;Q++)W.dyn_dtree[Q*2]=0;for(Q=0;Q<G6;Q++)W.bl_tree[Q*2]=0;W.dyn_ltree[X6*2]=1,W.opt_len=W.static_len=0,W.sym_next=W.matches=0},a5=(W)=>{if(W.bi_valid>8)A1(W,W.bi_buf);else if(W.bi_valid>0)W.pending_buf[W.pending++]=W.bi_buf;W.bi_buf=0,W.bi_valid=0},t6=(W,Q,J,V)=>{const G=Q*2,X=J*2;return W[G]<W[X]||W[G]===W[X]&&V[Q]<=V[J]},f8=(W,Q,J)=>{const V=W.heap[J];let G=J<<1;while(G<=W.heap_len){if(G<W.heap_len&&t6(Q,W.heap[G+1],W.heap[G],W.depth))G++;if(t6(Q,V,W.heap[G],W.depth))break;W.heap[J]=W.heap[G],J=G,G<<=1}W.heap[J]=V},W5=(W,Q,J)=>{let V,G,X=0,q,Y;if(W.sym_next!==0)do if(V=W.pending_buf[W.sym_buf+X++]&255,V+=(W.pending_buf[W.sym_buf+X++]&255)<<8,G=W.pending_buf[W.sym_buf+X++],V===0)j0(W,G,Q);else{if(q=T1[G],j0(W,q+f1+1,Q),Y=n8[q],Y!==0)G-=Y6[q],Y0(W,G,Y);if(V--,q=l5(V),j0(W,q,J),Y=X8[q],Y!==0)V-=Y8[q],Y0(W,V,Y)}while(X<W.sym_next);j0(W,X6,Q)},o8=(W,Q)=>{const J=Q.dyn_tree,V=Q.stat_desc.static_tree,G=Q.stat_desc.has_stree,X=Q.stat_desc.elems;let q,Y,F=-1,U;W.heap_len=0,W.heap_max=b5;for(q=0;q<X;q++)if(J[q*2]!==0)W.heap[++W.heap_len]=F=q,W.depth[q]=0;else J[q*2+1]=0;while(W.heap_len<2)if(U=W.heap[++W.heap_len]=F<2?++F:0,J[U*2]=1,W.depth[U]=0,W.opt_len--,G)W.static_len-=V[U*2+1];Q.max_code=F;for(q=W.heap_len>>1;q>=1;q--)f8(W,J,q);U=X;do q=W.heap[1],W.heap[1]=W.heap[W.heap_len--],f8(W,J,1),Y=W.heap[1],W.heap[--W.heap_max]=q,W.heap[--W.heap_max]=Y,J[U*2]=J[q*2]+J[Y*2],W.depth[U]=(W.depth[q]>=W.depth[Y]?W.depth[q]:W.depth[Y])+1,J[q*2+1]=J[Y*2+1]=U,W.heap[1]=U++,f8(W,J,1);while(W.heap_len>=2);W.heap[--W.heap_max]=W.heap[1],UJ(W,Q),n5(J,F,W.bl_count)},J5=(W,Q,J)=>{let V,G=-1,X,q=Q[1],Y=0,F=7,U=4;if(q===0)F=138,U=3;Q[(J+1)*2+1]=65535;for(V=0;V<=J;V++){if(X=q,q=Q[(V+1)*2+1],++Y<F&&X===q)continue;else if(Y<U)W.bl_tree[X*2]+=Y;else if(X!==0){if(X!==G)W.bl_tree[X*2]++;W.bl_tree[h5*2]++}else if(Y<=10)W.bl_tree[u5*2]++;else W.bl_tree[m5*2]++;if(Y=0,G=X,q===0)F=138,U=3;else if(X===q)F=6,U=3;else F=7,U=4}},Q5=(W,Q,J)=>{let V,G=-1,X,q=Q[1],Y=0,F=7,U=4;if(q===0)F=138,U=3;for(V=0;V<=J;V++){if(X=q,q=Q[(V+1)*2+1],++Y<F&&X===q)continue;else if(Y<U)do j0(W,X,W.bl_tree);while(--Y!==0);else if(X!==0){if(X!==G)j0(W,X,W.bl_tree),Y--;j0(W,h5,W.bl_tree),Y0(W,Y-3,2)}else if(Y<=10)j0(W,u5,W.bl_tree),Y0(W,Y-3,3);else j0(W,m5,W.bl_tree),Y0(W,Y-11,7);if(Y=0,G=X,q===0)F=138,U=3;else if(X===q)F=6,U=3;else F=7,U=4}},KJ=(W)=>{let Q;J5(W,W.dyn_ltree,W.l_desc.max_code),J5(W,W.dyn_dtree,W.d_desc.max_code),o8(W,W.bl_desc);for(Q=G6-1;Q>=3;Q--)if(W.bl_tree[_5[Q]*2+1]!==0)break;return W.opt_len+=3*(Q+1)+5+5+4,Q},FJ=(W,Q,J,V)=>{let G;Y0(W,Q-257,5),Y0(W,J-1,5),Y0(W,V-4,4);for(G=0;G<V;G++)Y0(W,W.bl_tree[_5[G]*2+1],3);Q5(W,W.dyn_ltree,Q-1),Q5(W,W.dyn_dtree,J-1)},zJ=(W)=>{let Q=4093624447,J;for(J=0;J<=31;J++,Q>>>=1)if(Q&1&&W.dyn_ltree[J*2]!==0)return 0;if(W.dyn_ltree[18]!==0||W.dyn_ltree[20]!==0||W.dyn_ltree[26]!==0)return 1;for(J=32;J<f1;J++)if(W.dyn_ltree[J*2]!==0)return 1;return 0},V5=!1,ZJ=(W)=>{if(!V5)PJ(),V5=!0;W.l_desc=new p8(W.dyn_ltree,d5),W.d_desc=new p8(W.dyn_dtree,c5),W.bl_desc=new p8(W.bl_tree,i5),W.bi_buf=0,W.bi_valid=0,o5(W)},s5=(W,Q,J,V)=>{if(Y0(W,(WJ<<1)+(V?1:0),3),a5(W),A1(W,J),A1(W,~J),J)W.pending_buf.set(W.window.subarray(Q,Q+J),W.pending);W.pending+=J},HJ=(W)=>{Y0(W,f5<<1,3),j0(W,X6,O0),qJ(W)},kJ=(W,Q,J,V)=>{let G,X,q=0;if(W.level>0){if(W.strm.data_type===2)W.strm.data_type=zJ(W);if(o8(W,W.l_desc),o8(W,W.d_desc),q=KJ(W),G=W.opt_len+3+7>>>3,X=W.static_len+3+7>>>3,X<=G)G=X}else G=X=J+5;if(J+4<=G&&Q!==-1)s5(W,Q,J,V);else if(W.strategy===4||X===G)Y0(W,(f5<<1)+(V?1:0),3),W5(W,O0,x1);else Y0(W,(JJ<<1)+(V?1:0),3),FJ(W,W.l_desc.max_code+1,W.d_desc.max_code+1,q+1),W5(W,W.dyn_ltree,W.dyn_dtree);if(o5(W),V)a5(W)},$J=(W,Q,J)=>{if(W.pending_buf[W.sym_buf+W.sym_next++]=Q,W.pending_buf[W.sym_buf+W.sym_next++]=Q>>8,W.pending_buf[W.sym_buf+W.sym_next++]=J,Q===0)W.dyn_ltree[J*2]++;else W.matches++,Q--,W.dyn_ltree[(T1[J]+f1+1)*2]++,W.dyn_dtree[l5(Q)*2]++;return W.sym_next===W.sym_end},jJ=ZJ,CJ=s5,BJ=kJ,MJ=$J,RJ=HJ,LJ={_tr_init:jJ,_tr_stored_block:CJ,_tr_flush_block:BJ,_tr_tally:MJ,_tr_align:RJ},OJ=(W,Q,J,V)=>{let G=W&65535|0,X=W>>>16&65535|0,q=0;while(J!==0){q=J>2000?2000:J,J-=q;do G=G+Q[V++]|0,X=X+G|0;while(--q);G%=65521,X%=65521}return G|X<<16|0},g1=OJ,IJ=()=>{let W,Q=[];for(var J=0;J<256;J++){W=J;for(var V=0;V<8;V++)W=W&1?3988292384^W>>>1:W>>>1;Q[J]=W}return Q},DJ=new Uint32Array(IJ()),xJ=(W,Q,J,V)=>{const G=DJ,X=V+J;W^=-1;for(let q=V;q<X;q++)W=W>>>8^G[(W^Q[q])&255];return W^-1},t=xJ,_0={2:"need dictionary",1:"stream end",0:"","-1":"file error","-2":"stream error","-3":"data error","-4":"insufficient memory","-5":"buffer error","-6":"incompatible version"},i0={Z_NO_FLUSH:0,Z_PARTIAL_FLUSH:1,Z_SYNC_FLUSH:2,Z_FULL_FLUSH:3,Z_FINISH:4,Z_BLOCK:5,Z_TREES:6,Z_OK:0,Z_STREAM_END:1,Z_NEED_DICT:2,Z_ERRNO:-1,Z_STREAM_ERROR:-2,Z_DATA_ERROR:-3,Z_MEM_ERROR:-4,Z_BUF_ERROR:-5,Z_NO_COMPRESSION:0,Z_BEST_SPEED:1,Z_BEST_COMPRESSION:9,Z_DEFAULT_COMPRESSION:-1,Z_FILTERED:1,Z_HUFFMAN_ONLY:2,Z_RLE:3,Z_FIXED:4,Z_DEFAULT_STRATEGY:0,Z_BINARY:0,Z_TEXT:1,Z_UNKNOWN:2,Z_DEFLATED:8},{_tr_init:wJ,_tr_stored_block:a8,_tr_flush_block:NJ,_tr_tally:g0,_tr_align:SJ}=LJ,{Z_NO_FLUSH:E0,Z_PARTIAL_FLUSH:vJ,Z_FULL_FLUSH:TJ,Z_FINISH:F0,Z_BLOCK:G5,Z_OK:J0,Z_STREAM_END:X5,Z_STREAM_ERROR:C0,Z_DATA_ERROR:AJ,Z_BUF_ERROR:b8,Z_DEFAULT_COMPRESSION:gJ,Z_FILTERED:EJ,Z_HUFFMAN_ONLY:W8,Z_RLE:yJ,Z_FIXED:pJ,Z_DEFAULT_STRATEGY:fJ,Z_UNKNOWN:bJ,Z_DEFLATED:P8}=i0,hJ=9,uJ=15,mJ=8,_J=29,dJ=256,s8=dJ+1+_J,cJ=30,iJ=19,lJ=2*s8+1,rJ=15,c=3,A0=258,B0=A0+c+1,nJ=32,G1=42,q6=57,e8=69,t8=73,W6=91,J6=103,u0=113,I1=666,G0=1,q1=2,d0=3,U1=4,oJ=3,m0=(W,Q)=>{return W.msg=_0[Q],Q},Y5=(W)=>{return W*2-(W>4?9:0)},T0=(W)=>{let Q=W.length;while(--Q>=0)W[Q]=0},aJ=(W)=>{let Q,J,V,G=W.w_size;Q=W.hash_size,V=Q;do J=W.head[--V],W.head[V]=J>=G?J-G:0;while(--Q);Q=G,V=Q;do J=W.prev[--V],W.prev[V]=J>=G?J-G:0;while(--Q)},sJ=(W,Q,J)=>(Q<<W.hash_shift^J)&W.hash_mask,y0=sJ,U0=(W)=>{const Q=W.state;let J=Q.pending;if(J>W.avail_out)J=W.avail_out;if(J===0)return;if(W.output.set(Q.pending_buf.subarray(Q.pending_out,Q.pending_out+J),W.next_out),W.next_out+=J,Q.pending_out+=J,W.total_out+=J,W.avail_out-=J,Q.pending-=J,Q.pending===0)Q.pending_out=0},P0=(W,Q)=>{NJ(W,W.block_start>=0?W.block_start:-1,W.strstart-W.block_start,Q),W.block_start=W.strstart,U0(W.strm)},l=(W,Q)=>{W.pending_buf[W.pending++]=Q},O1=(W,Q)=>{W.pending_buf[W.pending++]=Q>>>8&255,W.pending_buf[W.pending++]=Q&255},Q6=(W,Q,J,V)=>{let G=W.avail_in;if(G>V)G=V;if(G===0)return 0;if(W.avail_in-=G,Q.set(W.input.subarray(W.next_in,W.next_in+G),J),W.state.wrap===1)W.adler=g1(W.adler,Q,G,J);else if(W.state.wrap===2)W.adler=t(W.adler,Q,G,J);return W.next_in+=G,W.total_in+=G,G},e5=(W,Q)=>{let{max_chain_length:J,strstart:V}=W,G,X,q=W.prev_length,Y=W.nice_match;const F=W.strstart>W.w_size-B0?W.strstart-(W.w_size-B0):0,U=W.window,P=W.w_mask,H=W.prev,K=W.strstart+A0;let z=U[V+q-1],C=U[V+q];if(W.prev_length>=W.good_match)J>>=2;if(Y>W.lookahead)Y=W.lookahead;do{if(G=Q,U[G+q]!==C||U[G+q-1]!==z||U[G]!==U[V]||U[++G]!==U[V+1])continue;V+=2,G++;do;while(U[++V]===U[++G]&&U[++V]===U[++G]&&U[++V]===U[++G]&&U[++V]===U[++G]&&U[++V]===U[++G]&&U[++V]===U[++G]&&U[++V]===U[++G]&&U[++V]===U[++G]&&V<K);if(X=A0-(K-V),V=K-A0,X>q){if(W.match_start=Q,q=X,X>=Y)break;z=U[V+q-1],C=U[V+q]}}while((Q=H[Q&P])>F&&--J!==0);if(q<=W.lookahead)return q;return W.lookahead},X1=(W)=>{const Q=W.w_size;let J,V,G;do{if(V=W.window_size-W.lookahead-W.strstart,W.strstart>=Q+(Q-B0)){if(W.window.set(W.window.subarray(Q,Q+Q-V),0),W.match_start-=Q,W.strstart-=Q,W.block_start-=Q,W.insert>W.strstart)W.insert=W.strstart;aJ(W),V+=Q}if(W.strm.avail_in===0)break;if(J=Q6(W.strm,W.window,W.strstart+W.lookahead,V),W.lookahead+=J,W.lookahead+W.insert>=c){G=W.strstart-W.insert,W.ins_h=W.window[G],W.ins_h=y0(W,W.ins_h,W.window[G+1]);while(W.insert)if(W.ins_h=y0(W,W.ins_h,W.window[G+c-1]),W.prev[G&W.w_mask]=W.head[W.ins_h],W.head[W.ins_h]=G,G++,W.insert--,W.lookahead+W.insert<c)break}}while(W.lookahead<B0&&W.strm.avail_in!==0)},t5=(W,Q)=>{let J=W.pending_buf_size-5>W.w_size?W.w_size:W.pending_buf_size-5,V,G,X,q=0,Y=W.strm.avail_in;do{if(V=65535,X=W.bi_valid+42>>3,W.strm.avail_out<X)break;if(X=W.strm.avail_out-X,G=W.strstart-W.block_start,V>G+W.strm.avail_in)V=G+W.strm.avail_in;if(V>X)V=X;if(V<J&&(V===0&&Q!==F0||Q===E0||V!==G+W.strm.avail_in))break;if(q=Q===F0&&V===G+W.strm.avail_in?1:0,a8(W,0,0,q),W.pending_buf[W.pending-4]=V,W.pending_buf[W.pending-3]=V>>8,W.pending_buf[W.pending-2]=~V,W.pending_buf[W.pending-1]=~V>>8,U0(W.strm),G){if(G>V)G=V;W.strm.output.set(W.window.subarray(W.block_start,W.block_start+G),W.strm.next_out),W.strm.next_out+=G,W.strm.avail_out-=G,W.strm.total_out+=G,W.block_start+=G,V-=G}if(V)Q6(W.strm,W.strm.output,W.strm.next_out,V),W.strm.next_out+=V,W.strm.avail_out-=V,W.strm.total_out+=V}while(q===0);if(Y-=W.strm.avail_in,Y){if(Y>=W.w_size)W.matches=2,W.window.set(W.strm.input.subarray(W.strm.next_in-W.w_size,W.strm.next_in),0),W.strstart=W.w_size,W.insert=W.strstart;else{if(W.window_size-W.strstart<=Y){if(W.strstart-=W.w_size,W.window.set(W.window.subarray(W.w_size,W.w_size+W.strstart),0),W.matches<2)W.matches++;if(W.insert>W.strstart)W.insert=W.strstart}W.window.set(W.strm.input.subarray(W.strm.next_in-Y,W.strm.next_in),W.strstart),W.strstart+=Y,W.insert+=Y>W.w_size-W.insert?W.w_size-W.insert:Y}W.block_start=W.strstart}if(W.high_water<W.strstart)W.high_water=W.strstart;if(q)return U1;if(Q!==E0&&Q!==F0&&W.strm.avail_in===0&&W.strstart===W.block_start)return q1;if(X=W.window_size-W.strstart,W.strm.avail_in>X&&W.block_start>=W.w_size){if(W.block_start-=W.w_size,W.strstart-=W.w_size,W.window.set(W.window.subarray(W.w_size,W.w_size+W.strstart),0),W.matches<2)W.matches++;if(X+=W.w_size,W.insert>W.strstart)W.insert=W.strstart}if(X>W.strm.avail_in)X=W.strm.avail_in;if(X)Q6(W.strm,W.window,W.strstart,X),W.strstart+=X,W.insert+=X>W.w_size-W.insert?W.w_size-W.insert:X;if(W.high_water<W.strstart)W.high_water=W.strstart;if(X=W.bi_valid+42>>3,X=W.pending_buf_size-X>65535?65535:W.pending_buf_size-X,J=X>W.w_size?W.w_size:X,G=W.strstart-W.block_start,G>=J||(G||Q===F0)&&Q!==E0&&W.strm.avail_in===0&&G<=X)V=G>X?X:G,q=Q===F0&&W.strm.avail_in===0&&V===G?1:0,a8(W,W.block_start,V,q),W.block_start+=V,U0(W.strm);return q?d0:G0},h8=(W,Q)=>{let J,V;for(;;){if(W.lookahead<B0){if(X1(W),W.lookahead<B0&&Q===E0)return G0;if(W.lookahead===0)break}if(J=0,W.lookahead>=c)W.ins_h=y0(W,W.ins_h,W.window[W.strstart+c-1]),J=W.prev[W.strstart&W.w_mask]=W.head[W.ins_h],W.head[W.ins_h]=W.strstart;if(J!==0&&W.strstart-J<=W.w_size-B0)W.match_length=e5(W,J);if(W.match_length>=c)if(V=g0(W,W.strstart-W.match_start,W.match_length-c),W.lookahead-=W.match_length,W.match_length<=W.max_lazy_match&&W.lookahead>=c){W.match_length--;do W.strstart++,W.ins_h=y0(W,W.ins_h,W.window[W.strstart+c-1]),J=W.prev[W.strstart&W.w_mask]=W.head[W.ins_h],W.head[W.ins_h]=W.strstart;while(--W.match_length!==0);W.strstart++}else W.strstart+=W.match_length,W.match_length=0,W.ins_h=W.window[W.strstart],W.ins_h=y0(W,W.ins_h,W.window[W.strstart+1]);else V=g0(W,0,W.window[W.strstart]),W.lookahead--,W.strstart++;if(V){if(P0(W,!1),W.strm.avail_out===0)return G0}}if(W.insert=W.strstart<c-1?W.strstart:c-1,Q===F0){if(P0(W,!0),W.strm.avail_out===0)return d0;return U1}if(W.sym_next){if(P0(W,!1),W.strm.avail_out===0)return G0}return q1},J1=(W,Q)=>{let J,V,G;for(;;){if(W.lookahead<B0){if(X1(W),W.lookahead<B0&&Q===E0)return G0;if(W.lookahead===0)break}if(J=0,W.lookahead>=c)W.ins_h=y0(W,W.ins_h,W.window[W.strstart+c-1]),J=W.prev[W.strstart&W.w_mask]=W.head[W.ins_h],W.head[W.ins_h]=W.strstart;if(W.prev_length=W.match_length,W.prev_match=W.match_start,W.match_length=c-1,J!==0&&W.prev_length<W.max_lazy_match&&W.strstart-J<=W.w_size-B0){if(W.match_length=e5(W,J),W.match_length<=5&&(W.strategy===EJ||W.match_length===c&&W.strstart-W.match_start>4096))W.match_length=c-1}if(W.prev_length>=c&&W.match_length<=W.prev_length){G=W.strstart+W.lookahead-c,V=g0(W,W.strstart-1-W.prev_match,W.prev_length-c),W.lookahead-=W.prev_length-1,W.prev_length-=2;do if(++W.strstart<=G)W.ins_h=y0(W,W.ins_h,W.window[W.strstart+c-1]),J=W.prev[W.strstart&W.w_mask]=W.head[W.ins_h],W.head[W.ins_h]=W.strstart;while(--W.prev_length!==0);if(W.match_available=0,W.match_length=c-1,W.strstart++,V){if(P0(W,!1),W.strm.avail_out===0)return G0}}else if(W.match_available){if(V=g0(W,0,W.window[W.strstart-1]),V)P0(W,!1);if(W.strstart++,W.lookahead--,W.strm.avail_out===0)return G0}else W.match_available=1,W.strstart++,W.lookahead--}if(W.match_available)V=g0(W,0,W.window[W.strstart-1]),W.match_available=0;if(W.insert=W.strstart<c-1?W.strstart:c-1,Q===F0){if(P0(W,!0),W.strm.avail_out===0)return d0;return U1}if(W.sym_next){if(P0(W,!1),W.strm.avail_out===0)return G0}return q1},eJ=(W,Q)=>{let J,V,G,X;const q=W.window;for(;;){if(W.lookahead<=A0){if(X1(W),W.lookahead<=A0&&Q===E0)return G0;if(W.lookahead===0)break}if(W.match_length=0,W.lookahead>=c&&W.strstart>0){if(G=W.strstart-1,V=q[G],V===q[++G]&&V===q[++G]&&V===q[++G]){X=W.strstart+A0;do;while(V===q[++G]&&V===q[++G]&&V===q[++G]&&V===q[++G]&&V===q[++G]&&V===q[++G]&&V===q[++G]&&V===q[++G]&&G<X);if(W.match_length=A0-(X-G),W.match_length>W.lookahead)W.match_length=W.lookahead}}if(W.match_length>=c)J=g0(W,1,W.match_length-c),W.lookahead-=W.match_length,W.strstart+=W.match_length,W.match_length=0;else J=g0(W,0,W.window[W.strstart]),W.lookahead--,W.strstart++;if(J){if(P0(W,!1),W.strm.avail_out===0)return G0}}if(W.insert=0,Q===F0){if(P0(W,!0),W.strm.avail_out===0)return d0;return U1}if(W.sym_next){if(P0(W,!1),W.strm.avail_out===0)return G0}return q1},tJ=(W,Q)=>{let J;for(;;){if(W.lookahead===0){if(X1(W),W.lookahead===0){if(Q===E0)return G0;break}}if(W.match_length=0,J=g0(W,0,W.window[W.strstart]),W.lookahead--,W.strstart++,J){if(P0(W,!1),W.strm.avail_out===0)return G0}}if(W.insert=0,Q===F0){if(P0(W,!0),W.strm.avail_out===0)return d0;return U1}if(W.sym_next){if(P0(W,!1),W.strm.avail_out===0)return G0}return q1},D1=[new $0(0,0,0,0,t5),new $0(4,4,8,4,h8),new $0(4,5,16,8,h8),new $0(4,6,32,32,h8),new $0(4,4,16,16,J1),new $0(8,16,32,32,J1),new $0(8,16,128,128,J1),new $0(8,32,128,256,J1),new $0(32,128,258,1024,J1),new $0(32,258,258,4096,J1)],W9=(W)=>{W.window_size=2*W.w_size,T0(W.head),W.max_lazy_match=D1[W.level].max_lazy,W.good_match=D1[W.level].good_length,W.nice_match=D1[W.level].nice_length,W.max_chain_length=D1[W.level].max_chain,W.strstart=0,W.block_start=0,W.lookahead=0,W.insert=0,W.match_length=W.prev_length=c-1,W.match_available=0,W.ins_h=0},b1=(W)=>{if(!W)return 1;const Q=W.state;if(!Q||Q.strm!==W||Q.status!==G1&&Q.status!==q6&&Q.status!==e8&&Q.status!==t8&&Q.status!==W6&&Q.status!==J6&&Q.status!==u0&&Q.status!==I1)return 1;return 0},W7=(W)=>{if(b1(W))return m0(W,C0);W.total_in=W.total_out=0,W.data_type=bJ;const Q=W.state;if(Q.pending=0,Q.pending_out=0,Q.wrap<0)Q.wrap=-Q.wrap;return Q.status=Q.wrap===2?q6:Q.wrap?G1:u0,W.adler=Q.wrap===2?0:1,Q.last_flush=-2,wJ(Q),J0},J7=(W)=>{const Q=W7(W);if(Q===J0)W9(W.state);return Q},Q9=(W,Q)=>{if(b1(W)||W.state.wrap!==2)return C0;return W.state.gzhead=Q,J0},Q7=(W,Q,J,V,G,X)=>{if(!W)return C0;let q=1;if(Q===gJ)Q=6;if(V<0)q=0,V=-V;else if(V>15)q=2,V-=16;if(G<1||G>hJ||J!==P8||V<8||V>15||Q<0||Q>9||X<0||X>pJ||V===8&&q!==1)return m0(W,C0);if(V===8)V=9;const Y=new J9;return W.state=Y,Y.strm=W,Y.status=G1,Y.wrap=q,Y.gzhead=null,Y.w_bits=V,Y.w_size=1<<Y.w_bits,Y.w_mask=Y.w_size-1,Y.hash_bits=G+7,Y.hash_size=1<<Y.hash_bits,Y.hash_mask=Y.hash_size-1,Y.hash_shift=~~((Y.hash_bits+c-1)/c),Y.window=new Uint8Array(Y.w_size*2),Y.head=new Uint16Array(Y.hash_size),Y.prev=new Uint16Array(Y.w_size),Y.lit_bufsize=1<<G+6,Y.pending_buf_size=Y.lit_bufsize*4,Y.pending_buf=new Uint8Array(Y.pending_buf_size),Y.sym_buf=Y.lit_bufsize,Y.sym_end=(Y.lit_bufsize-1)*3,Y.level=Q,Y.strategy=X,Y.method=J,J7(W)},V9=(W,Q)=>{return Q7(W,Q,P8,uJ,mJ,fJ)},G9=(W,Q)=>{if(b1(W)||Q>G5||Q<0)return W?m0(W,C0):C0;const J=W.state;if(!W.output||W.avail_in!==0&&!W.input||J.status===I1&&Q!==F0)return m0(W,W.avail_out===0?b8:C0);const V=J.last_flush;if(J.last_flush=Q,J.pending!==0){if(U0(W),W.avail_out===0)return J.last_flush=-1,J0}else if(W.avail_in===0&&Y5(Q)<=Y5(V)&&Q!==F0)return m0(W,b8);if(J.status===I1&&W.avail_in!==0)return m0(W,b8);if(J.status===G1&&J.wrap===0)J.status=u0;if(J.status===G1){let G=P8+(J.w_bits-8<<4)<<8,X=-1;if(J.strategy>=W8||J.level<2)X=0;else if(J.level<6)X=1;else if(J.level===6)X=2;else X=3;if(G|=X<<6,J.strstart!==0)G|=nJ;if(G+=31-G%31,O1(J,G),J.strstart!==0)O1(J,W.adler>>>16),O1(J,W.adler&65535);if(W.adler=1,J.status=u0,U0(W),J.pending!==0)return J.last_flush=-1,J0}if(J.status===q6)if(W.adler=0,l(J,31),l(J,139),l(J,8),!J.gzhead){if(l(J,0),l(J,0),l(J,0),l(J,0),l(J,0),l(J,J.level===9?2:J.strategy>=W8||J.level<2?4:0),l(J,oJ),J.status=u0,U0(W),J.pending!==0)return J.last_flush=-1,J0}else{if(l(J,(J.gzhead.text?1:0)+(J.gzhead.hcrc?2:0)+(!J.gzhead.extra?0:4)+(!J.gzhead.name?0:8)+(!J.gzhead.comment?0:16)),l(J,J.gzhead.time&255),l(J,J.gzhead.time>>8&255),l(J,J.gzhead.time>>16&255),l(J,J.gzhead.time>>24&255),l(J,J.level===9?2:J.strategy>=W8||J.level<2?4:0),l(J,J.gzhead.os&255),J.gzhead.extra&&J.gzhead.extra.length)l(J,J.gzhead.extra.length&255),l(J,J.gzhead.extra.length>>8&255);if(J.gzhead.hcrc)W.adler=t(W.adler,J.pending_buf,J.pending,0);J.gzindex=0,J.status=e8}if(J.status===e8){if(J.gzhead.extra){let G=J.pending,X=(J.gzhead.extra.length&65535)-J.gzindex;while(J.pending+X>J.pending_buf_size){let Y=J.pending_buf_size-J.pending;if(J.pending_buf.set(J.gzhead.extra.subarray(J.gzindex,J.gzindex+Y),J.pending),J.pending=J.pending_buf_size,J.gzhead.hcrc&&J.pending>G)W.adler=t(W.adler,J.pending_buf,J.pending-G,G);if(J.gzindex+=Y,U0(W),J.pending!==0)return J.last_flush=-1,J0;G=0,X-=Y}let q=new Uint8Array(J.gzhead.extra);if(J.pending_buf.set(q.subarray(J.gzindex,J.gzindex+X),J.pending),J.pending+=X,J.gzhead.hcrc&&J.pending>G)W.adler=t(W.adler,J.pending_buf,J.pending-G,G);J.gzindex=0}J.status=t8}if(J.status===t8){if(J.gzhead.name){let G=J.pending,X;do{if(J.pending===J.pending_buf_size){if(J.gzhead.hcrc&&J.pending>G)W.adler=t(W.adler,J.pending_buf,J.pending-G,G);if(U0(W),J.pending!==0)return J.last_flush=-1,J0;G=0}if(J.gzindex<J.gzhead.name.length)X=J.gzhead.name.charCodeAt(J.gzindex++)&255;else X=0;l(J,X)}while(X!==0);if(J.gzhead.hcrc&&J.pending>G)W.adler=t(W.adler,J.pending_buf,J.pending-G,G);J.gzindex=0}J.status=W6}if(J.status===W6){if(J.gzhead.comment){let G=J.pending,X;do{if(J.pending===J.pending_buf_size){if(J.gzhead.hcrc&&J.pending>G)W.adler=t(W.adler,J.pending_buf,J.pending-G,G);if(U0(W),J.pending!==0)return J.last_flush=-1,J0;G=0}if(J.gzindex<J.gzhead.comment.length)X=J.gzhead.comment.charCodeAt(J.gzindex++)&255;else X=0;l(J,X)}while(X!==0);if(J.gzhead.hcrc&&J.pending>G)W.adler=t(W.adler,J.pending_buf,J.pending-G,G)}J.status=J6}if(J.status===J6){if(J.gzhead.hcrc){if(J.pending+2>J.pending_buf_size){if(U0(W),J.pending!==0)return J.last_flush=-1,J0}l(J,W.adler&255),l(J,W.adler>>8&255),W.adler=0}if(J.status=u0,U0(W),J.pending!==0)return J.last_flush=-1,J0}if(W.avail_in!==0||J.lookahead!==0||Q!==E0&&J.status!==I1){let G=J.level===0?t5(J,Q):J.strategy===W8?tJ(J,Q):J.strategy===yJ?eJ(J,Q):D1[J.level].func(J,Q);if(G===d0||G===U1)J.status=I1;if(G===G0||G===d0){if(W.avail_out===0)J.last_flush=-1;return J0}if(G===q1){if(Q===vJ)SJ(J);else if(Q!==G5){if(a8(J,0,0,!1),Q===TJ){if(T0(J.head),J.lookahead===0)J.strstart=0,J.block_start=0,J.insert=0}}if(U0(W),W.avail_out===0)return J.last_flush=-1,J0}}if(Q!==F0)return J0;if(J.wrap<=0)return X5;if(J.wrap===2)l(J,W.adler&255),l(J,W.adler>>8&255),l(J,W.adler>>16&255),l(J,W.adler>>24&255),l(J,W.total_in&255),l(J,W.total_in>>8&255),l(J,W.total_in>>16&255),l(J,W.total_in>>24&255);else O1(J,W.adler>>>16),O1(J,W.adler&65535);if(U0(W),J.wrap>0)J.wrap=-J.wrap;return J.pending!==0?J0:X5},X9=(W)=>{if(b1(W))return C0;const Q=W.state.status;return W.state=null,Q===u0?m0(W,AJ):J0},Y9=(W,Q)=>{let J=Q.length;if(b1(W))return C0;const V=W.state,G=V.wrap;if(G===2||G===1&&V.status!==G1||V.lookahead)return C0;if(G===1)W.adler=g1(W.adler,Q,J,0);if(V.wrap=0,J>=V.w_size){if(G===0)T0(V.head),V.strstart=0,V.block_start=0,V.insert=0;let F=new Uint8Array(V.w_size);F.set(Q.subarray(J-V.w_size,J),0),Q=F,J=V.w_size}const{avail_in:X,next_in:q,input:Y}=W;W.avail_in=J,W.next_in=0,W.input=Q,X1(V);while(V.lookahead>=c){let F=V.strstart,U=V.lookahead-(c-1);do V.ins_h=y0(V,V.ins_h,V.window[F+c-1]),V.prev[F&V.w_mask]=V.head[V.ins_h],V.head[V.ins_h]=F,F++;while(--U);V.strstart=F,V.lookahead=c-1,X1(V)}return V.strstart+=V.lookahead,V.block_start=V.strstart,V.insert=V.lookahead,V.lookahead=0,V.match_length=V.prev_length=c-1,V.match_available=0,W.next_in=q,W.input=Y,W.avail_in=X,V.wrap=G,J0},q9=V9,U9=Q7,P9=J7,K9=W7,F9=Q9,z9=G9,Z9=X9,H9=Y9,k9="pako deflate (from Nodeca project)",w1={deflateInit:q9,deflateInit2:U9,deflateReset:P9,deflateResetKeep:K9,deflateSetHeader:F9,deflate:z9,deflateEnd:Z9,deflateSetDictionary:H9,deflateInfo:k9},$9=(W,Q)=>{return Object.prototype.hasOwnProperty.call(W,Q)},j9=function(W){const Q=Array.prototype.slice.call(arguments,1);while(Q.length){const J=Q.shift();if(!J)continue;if(typeof J!=="object")throw new TypeError(J+"must be non-object");for(let V in J)if($9(J,V))W[V]=J[V]}return W},C9=(W)=>{let Q=0;for(let V=0,G=W.length;V<G;V++)Q+=W[V].length;const J=new Uint8Array(Q);for(let V=0,G=0,X=W.length;V<X;V++){let q=W[V];J.set(q,G),G+=q.length}return J},K8={assign:j9,flattenChunks:C9},V7=!0;try{String.fromCharCode.apply(null,new Uint8Array(1))}catch(W){V7=!1}var E1=new Uint8Array(256);for(let W=0;W<256;W++)E1[W]=W>=252?6:W>=248?5:W>=240?4:W>=224?3:W>=192?2:1;E1[254]=E1[254]=1;var B9=(W)=>{if(typeof TextEncoder==="function"&&TextEncoder.prototype.encode)return(new TextEncoder()).encode(W);let Q,J,V,G,X,q=W.length,Y=0;for(G=0;G<q;G++){if(J=W.charCodeAt(G),(J&64512)===55296&&G+1<q){if(V=W.charCodeAt(G+1),(V&64512)===56320)J=65536+(J-55296<<10)+(V-56320),G++}Y+=J<128?1:J<2048?2:J<65536?3:4}Q=new Uint8Array(Y);for(X=0,G=0;X<Y;G++){if(J=W.charCodeAt(G),(J&64512)===55296&&G+1<q){if(V=W.charCodeAt(G+1),(V&64512)===56320)J=65536+(J-55296<<10)+(V-56320),G++}if(J<128)Q[X++]=J;else if(J<2048)Q[X++]=192|J>>>6,Q[X++]=128|J&63;else if(J<65536)Q[X++]=224|J>>>12,Q[X++]=128|J>>>6&63,Q[X++]=128|J&63;else Q[X++]=240|J>>>18,Q[X++]=128|J>>>12&63,Q[X++]=128|J>>>6&63,Q[X++]=128|J&63}return Q},M9=(W,Q)=>{if(Q<65534){if(W.subarray&&V7)return String.fromCharCode.apply(null,W.length===Q?W:W.subarray(0,Q))}let J="";for(let V=0;V<Q;V++)J+=String.fromCharCode(W[V]);return J},R9=(W,Q)=>{const J=Q||W.length;if(typeof TextDecoder==="function"&&TextDecoder.prototype.decode)return(new TextDecoder()).decode(W.subarray(0,Q));let V,G;const X=new Array(J*2);for(G=0,V=0;V<J;){let q=W[V++];if(q<128){X[G++]=q;continue}let Y=E1[q];if(Y>4){X[G++]=65533,V+=Y-1;continue}q&=Y===2?31:Y===3?15:7;while(Y>1&&V<J)q=q<<6|W[V++]&63,Y--;if(Y>1){X[G++]=65533;continue}if(q<65536)X[G++]=q;else q-=65536,X[G++]=55296|q>>10&1023,X[G++]=56320|q&1023}return M9(X,G)},L9=(W,Q)=>{if(Q=Q||W.length,Q>W.length)Q=W.length;let J=Q-1;while(J>=0&&(W[J]&192)===128)J--;if(J<0)return Q;if(J===0)return Q;return J+E1[W[J]]>Q?J:Q},y1={string2buf:B9,buf2string:R9,utf8border:L9},G7=O9,X7=Object.prototype.toString,{Z_NO_FLUSH:I9,Z_SYNC_FLUSH:D9,Z_FULL_FLUSH:x9,Z_FINISH:w9,Z_OK:q8,Z_STREAM_END:N9,Z_DEFAULT_COMPRESSION:S9,Z_DEFAULT_STRATEGY:v9,Z_DEFLATED:T9}=i0;h1.prototype.push=function(W,Q){const J=this.strm,V=this.options.chunkSize;let G,X;if(this.ended)return!1;if(Q===~~Q)X=Q;else X=Q===!0?w9:I9;if(typeof W==="string")J.input=y1.string2buf(W);else if(X7.call(W)==="[object ArrayBuffer]")J.input=new Uint8Array(W);else J.input=W;J.next_in=0,J.avail_in=J.input.length;for(;;){if(J.avail_out===0)J.output=new Uint8Array(V),J.next_out=0,J.avail_out=V;if((X===D9||X===x9)&&J.avail_out<=6){this.onData(J.output.subarray(0,J.next_out)),J.avail_out=0;continue}if(G=w1.deflate(J,X),G===N9){if(J.next_out>0)this.onData(J.output.subarray(0,J.next_out));return G=w1.deflateEnd(this.strm),this.onEnd(G),this.ended=!0,G===q8}if(J.avail_out===0){this.onData(J.output);continue}if(X>0&&J.next_out>0){this.onData(J.output.subarray(0,J.next_out)),J.avail_out=0;continue}if(J.avail_in===0)break}return!0};h1.prototype.onData=function(W){this.chunks.push(W)};h1.prototype.onEnd=function(W){if(W===q8)this.result=K8.flattenChunks(this.chunks);this.chunks=[],this.err=W,this.msg=this.strm.msg};var E9=h1,y9=U6,p9=A9,f9=g9,b9=i0,h9={Deflate:E9,deflate:y9,deflateRaw:p9,gzip:f9,constants:b9},J8=16209,u9=16191,m9=function W(Q,J){let V,G,X,q,Y,F,U,P,H,K,z,C,v,E,f,b,h,T,_,d,S,D,g,Z;const k=Q.state;V=Q.next_in,g=Q.input,G=V+(Q.avail_in-5),X=Q.next_out,Z=Q.output,q=X-(J-Q.avail_out),Y=X+(Q.avail_out-257),F=k.dmax,U=k.wsize,P=k.whave,H=k.wnext,K=k.window,z=k.hold,C=k.bits,v=k.lencode,E=k.distcode,f=(1<<k.lenbits)-1,b=(1<<k.distbits)-1;W:do{if(C<15)z+=g[V++]<<C,C+=8,z+=g[V++]<<C,C+=8;h=v[z&f];J:for(;;){if(T=h>>>24,z>>>=T,C-=T,T=h>>>16&255,T===0)Z[X++]=h&65535;else if(T&16){if(_=h&65535,T&=15,T){if(C<T)z+=g[V++]<<C,C+=8;_+=z&(1<<T)-1,z>>>=T,C-=T}if(C<15)z+=g[V++]<<C,C+=8,z+=g[V++]<<C,C+=8;h=E[z&b];Q:for(;;){if(T=h>>>24,z>>>=T,C-=T,T=h>>>16&255,T&16){if(d=h&65535,T&=15,C<T){if(z+=g[V++]<<C,C+=8,C<T)z+=g[V++]<<C,C+=8}if(d+=z&(1<<T)-1,d>F){Q.msg="invalid distance too far back",k.mode=J8;break W}if(z>>>=T,C-=T,T=X-q,d>T){if(T=d-T,T>P){if(k.sane){Q.msg="invalid distance too far back",k.mode=J8;break W}}if(S=0,D=K,H===0){if(S+=U-T,T<_){_-=T;do Z[X++]=K[S++];while(--T);S=X-d,D=Z}}else if(H<T){if(S+=U+H-T,T-=H,T<_){_-=T;do Z[X++]=K[S++];while(--T);if(S=0,H<_){T=H,_-=T;do Z[X++]=K[S++];while(--T);S=X-d,D=Z}}}else if(S+=H-T,T<_){_-=T;do Z[X++]=K[S++];while(--T);S=X-d,D=Z}while(_>2)Z[X++]=D[S++],Z[X++]=D[S++],Z[X++]=D[S++],_-=3;if(_){if(Z[X++]=D[S++],_>1)Z[X++]=D[S++]}}else{S=X-d;do Z[X++]=Z[S++],Z[X++]=Z[S++],Z[X++]=Z[S++],_-=3;while(_>2);if(_){if(Z[X++]=Z[S++],_>1)Z[X++]=Z[S++]}}}else if((T&64)===0){h=E[(h&65535)+(z&(1<<T)-1)];continue Q}else{Q.msg="invalid distance code",k.mode=J8;break W}break}}else if((T&64)===0){h=v[(h&65535)+(z&(1<<T)-1)];continue J}else if(T&32){k.mode=u9;break W}else{Q.msg="invalid literal/length code",k.mode=J8;break W}break}}while(V<G&&X<Y);_=C>>3,V-=_,C-=_<<3,z&=(1<<C)-1,Q.next_in=V,Q.next_out=X,Q.avail_in=V<G?5+(G-V):5-(V-G),Q.avail_out=X<Y?257+(Y-X):257-(X-Y),k.hold=z,k.bits=C;return},Q1=15,q5=852,U5=592,P5=0,u8=1,K5=2,_9=new Uint16Array([3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,0,0]),d9=new Uint8Array([16,16,16,16,16,16,16,16,17,17,17,17,18,18,18,18,19,19,19,19,20,20,20,20,21,21,21,21,16,72,78]),c9=new Uint16Array([1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,0,0]),i9=new Uint8Array([16,16,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,64,64]),l9=(W,Q,J,V,G,X,q,Y)=>{const F=Y.bits;let U=0,P=0,H=0,K=0,z=0,C=0,v=0,E=0,f=0,b=0,h,T,_,d,S,D=null,g;const Z=new Uint16Array(Q1+1),k=new Uint16Array(Q1+1);let O=null,$,M,w;for(U=0;U<=Q1;U++)Z[U]=0;for(P=0;P<V;P++)Z[Q[J+P]]++;z=F;for(K=Q1;K>=1;K--)if(Z[K]!==0)break;if(z>K)z=K;if(K===0)return G[X++]=1<<24|64<<16|0,G[X++]=1<<24|64<<16|0,Y.bits=1,0;for(H=1;H<K;H++)if(Z[H]!==0)break;if(z<H)z=H;E=1;for(U=1;U<=Q1;U++)if(E<<=1,E-=Z[U],E<0)return-1;if(E>0&&(W===P5||K!==1))return-1;k[1]=0;for(U=1;U<Q1;U++)k[U+1]=k[U]+Z[U];for(P=0;P<V;P++)if(Q[J+P]!==0)q[k[Q[J+P]]++]=P;if(W===P5)D=O=q,g=20;else if(W===u8)D=_9,O=d9,g=257;else D=c9,O=i9,g=0;if(b=0,P=0,U=H,S=X,C=z,v=0,_=-1,f=1<<z,d=f-1,W===u8&&f>q5||W===K5&&f>U5)return 1;for(;;){if($=U-v,q[P]+1<g)M=0,w=q[P];else if(q[P]>=g)M=O[q[P]-g],w=D[q[P]-g];else M=96,w=0;h=1<<U-v,T=1<<C,H=T;do T-=h,G[S+(b>>v)+T]=$<<24|M<<16|w|0;while(T!==0);h=1<<U-1;while(b&h)h>>=1;if(h!==0)b&=h-1,b+=h;else b=0;if(P++,--Z[U]===0){if(U===K)break;U=Q[J+q[P]]}if(U>z&&(b&d)!==_){if(v===0)v=z;S+=H,C=U-v,E=1<<C;while(C+v<K){if(E-=Z[C+v],E<=0)break;C++,E<<=1}if(f+=1<<C,W===u8&&f>q5||W===K5&&f>U5)return 1;_=b&d,G[_]=z<<24|C<<16|S-X|0}}if(b!==0)G[S+b]=U-v<<24|64<<16|0;return Y.bits=z,0},N1=l9,r9=0,Y7=1,q7=2,{Z_FINISH:F5,Z_BLOCK:n9,Z_TREES:Q8,Z_OK:c0,Z_STREAM_END:o9,Z_NEED_DICT:a9,Z_STREAM_ERROR:z0,Z_DATA_ERROR:U7,Z_MEM_ERROR:P7,Z_BUF_ERROR:s9,Z_DEFLATED:z5}=i0,F8=16180,Z5=16181,H5=16182,k5=16183,$5=16184,j5=16185,C5=16186,B5=16187,M5=16188,R5=16189,U8=16190,L0=16191,m8=16192,L5=16193,_8=16194,O5=16195,I5=16196,D5=16197,x5=16198,V8=16199,G8=16200,w5=16201,N5=16202,S5=16203,v5=16204,T5=16205,d8=16206,A5=16207,g5=16208,n=16209,K7=16210,F7=16211,e9=852,t9=592,WQ=15,JQ=WQ,E5=(W)=>{return(W>>>24&255)+(W>>>8&65280)+((W&65280)<<8)+((W&255)<<24)},l0=(W)=>{if(!W)return 1;const Q=W.state;if(!Q||Q.strm!==W||Q.mode<F8||Q.mode>F7)return 1;return 0},z7=(W)=>{if(l0(W))return z0;const Q=W.state;if(W.total_in=W.total_out=Q.total=0,W.msg="",Q.wrap)W.adler=Q.wrap&1;return Q.mode=F8,Q.last=0,Q.havedict=0,Q.flags=-1,Q.dmax=32768,Q.head=null,Q.hold=0,Q.bits=0,Q.lencode=Q.lendyn=new Int32Array(e9),Q.distcode=Q.distdyn=new Int32Array(t9),Q.sane=1,Q.back=-1,c0},Z7=(W)=>{if(l0(W))return z0;const Q=W.state;return Q.wsize=0,Q.whave=0,Q.wnext=0,z7(W)},H7=(W,Q)=>{let J;if(l0(W))return z0;const V=W.state;if(Q<0)J=0,Q=-Q;else if(J=(Q>>4)+5,Q<48)Q&=15;if(Q&&(Q<8||Q>15))return z0;if(V.window!==null&&V.wbits!==Q)V.window=null;return V.wrap=J,V.wbits=Q,Z7(W)},k7=(W,Q)=>{if(!W)return z0;const J=new QQ;W.state=J,J.strm=W,J.window=null,J.mode=F8;const V=H7(W,Q);if(V!==c0)W.state=null;return V},VQ=(W)=>{return k7(W,JQ)},y5=!0,c8,i8,GQ=(W)=>{if(y5){c8=new Int32Array(512),i8=new Int32Array(32);let Q=0;while(Q<144)W.lens[Q++]=8;while(Q<256)W.lens[Q++]=9;while(Q<280)W.lens[Q++]=7;while(Q<288)W.lens[Q++]=8;N1(Y7,W.lens,0,288,c8,0,W.work,{bits:9}),Q=0;while(Q<32)W.lens[Q++]=5;N1(q7,W.lens,0,32,i8,0,W.work,{bits:5}),y5=!1}W.lencode=c8,W.lenbits=9,W.distcode=i8,W.distbits=5},$7=(W,Q,J,V)=>{let G;const X=W.state;if(X.window===null)X.wsize=1<<X.wbits,X.wnext=0,X.whave=0,X.window=new Uint8Array(X.wsize);if(V>=X.wsize)X.window.set(Q.subarray(J-X.wsize,J),0),X.wnext=0,X.whave=X.wsize;else{if(G=X.wsize-X.wnext,G>V)G=V;if(X.window.set(Q.subarray(J-V,J-V+G),X.wnext),V-=G,V)X.window.set(Q.subarray(J-V,J),0),X.wnext=V,X.whave=X.wsize;else{if(X.wnext+=G,X.wnext===X.wsize)X.wnext=0;if(X.whave<X.wsize)X.whave+=G}}return 0},XQ=(W,Q)=>{let J,V,G,X,q,Y,F,U,P,H,K,z,C,v,E=0,f,b,h,T,_,d,S,D;const g=new Uint8Array(4);let Z,k;const O=new Uint8Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]);if(l0(W)||!W.output||!W.input&&W.avail_in!==0)return z0;if(J=W.state,J.mode===L0)J.mode=m8;q=W.next_out,G=W.output,F=W.avail_out,X=W.next_in,V=W.input,Y=W.avail_in,U=J.hold,P=J.bits,H=Y,K=F,D=c0;W:for(;;)switch(J.mode){case F8:if(J.wrap===0){J.mode=m8;break}while(P<16){if(Y===0)break W;Y--,U+=V[X++]<<P,P+=8}if(J.wrap&2&&U===35615){if(J.wbits===0)J.wbits=15;J.check=0,g[0]=U&255,g[1]=U>>>8&255,J.check=t(J.check,g,2,0),U=0,P=0,J.mode=Z5;break}if(J.head)J.head.done=!1;if(!(J.wrap&1)||(((U&255)<<8)+(U>>8))%31){W.msg="incorrect header check",J.mode=n;break}if((U&15)!==z5){W.msg="unknown compression method",J.mode=n;break}if(U>>>=4,P-=4,S=(U&15)+8,J.wbits===0)J.wbits=S;if(S>15||S>J.wbits){W.msg="invalid window size",J.mode=n;break}J.dmax=1<<J.wbits,J.flags=0,W.adler=J.check=1,J.mode=U&512?R5:L0,U=0,P=0;break;case Z5:while(P<16){if(Y===0)break W;Y--,U+=V[X++]<<P,P+=8}if(J.flags=U,(J.flags&255)!==z5){W.msg="unknown compression method",J.mode=n;break}if(J.flags&57344){W.msg="unknown header flags set",J.mode=n;break}if(J.head)J.head.text=U>>8&1;if(J.flags&512&&J.wrap&4)g[0]=U&255,g[1]=U>>>8&255,J.check=t(J.check,g,2,0);U=0,P=0,J.mode=H5;case H5:while(P<32){if(Y===0)break W;Y--,U+=V[X++]<<P,P+=8}if(J.head)J.head.time=U;if(J.flags&512&&J.wrap&4)g[0]=U&255,g[1]=U>>>8&255,g[2]=U>>>16&255,g[3]=U>>>24&255,J.check=t(J.check,g,4,0);U=0,P=0,J.mode=k5;case k5:while(P<16){if(Y===0)break W;Y--,U+=V[X++]<<P,P+=8}if(J.head)J.head.xflags=U&255,J.head.os=U>>8;if(J.flags&512&&J.wrap&4)g[0]=U&255,g[1]=U>>>8&255,J.check=t(J.check,g,2,0);U=0,P=0,J.mode=$5;case $5:if(J.flags&1024){while(P<16){if(Y===0)break W;Y--,U+=V[X++]<<P,P+=8}if(J.length=U,J.head)J.head.extra_len=U;if(J.flags&512&&J.wrap&4)g[0]=U&255,g[1]=U>>>8&255,J.check=t(J.check,g,2,0);U=0,P=0}else if(J.head)J.head.extra=null;J.mode=j5;case j5:if(J.flags&1024){if(z=J.length,z>Y)z=Y;if(z){if(J.head){if(S=J.head.extra_len-J.length,!J.head.extra)J.head.extra=new Uint8Array(J.head.extra_len);J.head.extra.set(V.subarray(X,X+z),S)}if(J.flags&512&&J.wrap&4)J.check=t(J.check,V,z,X);Y-=z,X+=z,J.length-=z}if(J.length)break W}J.length=0,J.mode=C5;case C5:if(J.flags&2048){if(Y===0)break W;z=0;do if(S=V[X+z++],J.head&&S&&J.length<65536)J.head.name+=String.fromCharCode(S);while(S&&z<Y);if(J.flags&512&&J.wrap&4)J.check=t(J.check,V,z,X);if(Y-=z,X+=z,S)break W}else if(J.head)J.head.name=null;J.length=0,J.mode=B5;case B5:if(J.flags&4096){if(Y===0)break W;z=0;do if(S=V[X+z++],J.head&&S&&J.length<65536)J.head.comment+=String.fromCharCode(S);while(S&&z<Y);if(J.flags&512&&J.wrap&4)J.check=t(J.check,V,z,X);if(Y-=z,X+=z,S)break W}else if(J.head)J.head.comment=null;J.mode=M5;case M5:if(J.flags&512){while(P<16){if(Y===0)break W;Y--,U+=V[X++]<<P,P+=8}if(J.wrap&4&&U!==(J.check&65535)){W.msg="header crc mismatch",J.mode=n;break}U=0,P=0}if(J.head)J.head.hcrc=J.flags>>9&1,J.head.done=!0;W.adler=J.check=0,J.mode=L0;break;case R5:while(P<32){if(Y===0)break W;Y--,U+=V[X++]<<P,P+=8}W.adler=J.check=E5(U),U=0,P=0,J.mode=U8;case U8:if(J.havedict===0)return W.next_out=q,W.avail_out=F,W.next_in=X,W.avail_in=Y,J.hold=U,J.bits=P,a9;W.adler=J.check=1,J.mode=L0;case L0:if(Q===n9||Q===Q8)break W;case m8:if(J.last){U>>>=P&7,P-=P&7,J.mode=d8;break}while(P<3){if(Y===0)break W;Y--,U+=V[X++]<<P,P+=8}switch(J.last=U&1,U>>>=1,P-=1,U&3){case 0:J.mode=L5;break;case 1:if(GQ(J),J.mode=V8,Q===Q8){U>>>=2,P-=2;break W}break;case 2:J.mode=I5;break;case 3:W.msg="invalid block type",J.mode=n}U>>>=2,P-=2;break;case L5:U>>>=P&7,P-=P&7;while(P<32){if(Y===0)break W;Y--,U+=V[X++]<<P,P+=8}if((U&65535)!==(U>>>16^65535)){W.msg="invalid stored block lengths",J.mode=n;break}if(J.length=U&65535,U=0,P=0,J.mode=_8,Q===Q8)break W;case _8:J.mode=O5;case O5:if(z=J.length,z){if(z>Y)z=Y;if(z>F)z=F;if(z===0)break W;G.set(V.subarray(X,X+z),q),Y-=z,X+=z,F-=z,q+=z,J.length-=z;break}J.mode=L0;break;case I5:while(P<14){if(Y===0)break W;Y--,U+=V[X++]<<P,P+=8}if(J.nlen=(U&31)+257,U>>>=5,P-=5,J.ndist=(U&31)+1,U>>>=5,P-=5,J.ncode=(U&15)+4,U>>>=4,P-=4,J.nlen>286||J.ndist>30){W.msg="too many length or distance symbols",J.mode=n;break}J.have=0,J.mode=D5;case D5:while(J.have<J.ncode){while(P<3){if(Y===0)break W;Y--,U+=V[X++]<<P,P+=8}J.lens[O[J.have++]]=U&7,U>>>=3,P-=3}while(J.have<19)J.lens[O[J.have++]]=0;if(J.lencode=J.lendyn,J.lenbits=7,Z={bits:J.lenbits},D=N1(r9,J.lens,0,19,J.lencode,0,J.work,Z),J.lenbits=Z.bits,D){W.msg="invalid code lengths set",J.mode=n;break}J.have=0,J.mode=x5;case x5:while(J.have<J.nlen+J.ndist){for(;;){if(E=J.lencode[U&(1<<J.lenbits)-1],f=E>>>24,b=E>>>16&255,h=E&65535,f<=P)break;if(Y===0)break W;Y--,U+=V[X++]<<P,P+=8}if(h<16)U>>>=f,P-=f,J.lens[J.have++]=h;else{if(h===16){k=f+2;while(P<k){if(Y===0)break W;Y--,U+=V[X++]<<P,P+=8}if(U>>>=f,P-=f,J.have===0){W.msg="invalid bit length repeat",J.mode=n;break}S=J.lens[J.have-1],z=3+(U&3),U>>>=2,P-=2}else if(h===17){k=f+3;while(P<k){if(Y===0)break W;Y--,U+=V[X++]<<P,P+=8}U>>>=f,P-=f,S=0,z=3+(U&7),U>>>=3,P-=3}else{k=f+7;while(P<k){if(Y===0)break W;Y--,U+=V[X++]<<P,P+=8}U>>>=f,P-=f,S=0,z=11+(U&127),U>>>=7,P-=7}if(J.have+z>J.nlen+J.ndist){W.msg="invalid bit length repeat",J.mode=n;break}while(z--)J.lens[J.have++]=S}}if(J.mode===n)break;if(J.lens[256]===0){W.msg="invalid code -- missing end-of-block",J.mode=n;break}if(J.lenbits=9,Z={bits:J.lenbits},D=N1(Y7,J.lens,0,J.nlen,J.lencode,0,J.work,Z),J.lenbits=Z.bits,D){W.msg="invalid literal/lengths set",J.mode=n;break}if(J.distbits=6,J.distcode=J.distdyn,Z={bits:J.distbits},D=N1(q7,J.lens,J.nlen,J.ndist,J.distcode,0,J.work,Z),J.distbits=Z.bits,D){W.msg="invalid distances set",J.mode=n;break}if(J.mode=V8,Q===Q8)break W;case V8:J.mode=G8;case G8:if(Y>=6&&F>=258){if(W.next_out=q,W.avail_out=F,W.next_in=X,W.avail_in=Y,J.hold=U,J.bits=P,m9(W,K),q=W.next_out,G=W.output,F=W.avail_out,X=W.next_in,V=W.input,Y=W.avail_in,U=J.hold,P=J.bits,J.mode===L0)J.back=-1;break}J.back=0;for(;;){if(E=J.lencode[U&(1<<J.lenbits)-1],f=E>>>24,b=E>>>16&255,h=E&65535,f<=P)break;if(Y===0)break W;Y--,U+=V[X++]<<P,P+=8}if(b&&(b&240)===0){T=f,_=b,d=h;for(;;){if(E=J.lencode[d+((U&(1<<T+_)-1)>>T)],f=E>>>24,b=E>>>16&255,h=E&65535,T+f<=P)break;if(Y===0)break W;Y--,U+=V[X++]<<P,P+=8}U>>>=T,P-=T,J.back+=T}if(U>>>=f,P-=f,J.back+=f,J.length=h,b===0){J.mode=T5;break}if(b&32){J.back=-1,J.mode=L0;break}if(b&64){W.msg="invalid literal/length code",J.mode=n;break}J.extra=b&15,J.mode=w5;case w5:if(J.extra){k=J.extra;while(P<k){if(Y===0)break W;Y--,U+=V[X++]<<P,P+=8}J.length+=U&(1<<J.extra)-1,U>>>=J.extra,P-=J.extra,J.back+=J.extra}J.was=J.length,J.mode=N5;case N5:for(;;){if(E=J.distcode[U&(1<<J.distbits)-1],f=E>>>24,b=E>>>16&255,h=E&65535,f<=P)break;if(Y===0)break W;Y--,U+=V[X++]<<P,P+=8}if((b&240)===0){T=f,_=b,d=h;for(;;){if(E=J.distcode[d+((U&(1<<T+_)-1)>>T)],f=E>>>24,b=E>>>16&255,h=E&65535,T+f<=P)break;if(Y===0)break W;Y--,U+=V[X++]<<P,P+=8}U>>>=T,P-=T,J.back+=T}if(U>>>=f,P-=f,J.back+=f,b&64){W.msg="invalid distance code",J.mode=n;break}J.offset=h,J.extra=b&15,J.mode=S5;case S5:if(J.extra){k=J.extra;while(P<k){if(Y===0)break W;Y--,U+=V[X++]<<P,P+=8}J.offset+=U&(1<<J.extra)-1,U>>>=J.extra,P-=J.extra,J.back+=J.extra}if(J.offset>J.dmax){W.msg="invalid distance too far back",J.mode=n;break}J.mode=v5;case v5:if(F===0)break W;if(z=K-F,J.offset>z){if(z=J.offset-z,z>J.whave){if(J.sane){W.msg="invalid distance too far back",J.mode=n;break}}if(z>J.wnext)z-=J.wnext,C=J.wsize-z;else C=J.wnext-z;if(z>J.length)z=J.length;v=J.window}else v=G,C=q-J.offset,z=J.length;if(z>F)z=F;F-=z,J.length-=z;do G[q++]=v[C++];while(--z);if(J.length===0)J.mode=G8;break;case T5:if(F===0)break W;G[q++]=J.length,F--,J.mode=G8;break;case d8:if(J.wrap){while(P<32){if(Y===0)break W;Y--,U|=V[X++]<<P,P+=8}if(K-=F,W.total_out+=K,J.total+=K,J.wrap&4&&K)W.adler=J.check=J.flags?t(J.check,G,K,q-K):g1(J.check,G,K,q-K);if(K=F,J.wrap&4&&(J.flags?U:E5(U))!==J.check){W.msg="incorrect data check",J.mode=n;break}U=0,P=0}J.mode=A5;case A5:if(J.wrap&&J.flags){while(P<32){if(Y===0)break W;Y--,U+=V[X++]<<P,P+=8}if(J.wrap&4&&U!==(J.total&4294967295)){W.msg="incorrect length check",J.mode=n;break}U=0,P=0}J.mode=g5;case g5:D=o9;break W;case n:D=U7;break W;case K7:return P7;case F7:default:return z0}if(W.next_out=q,W.avail_out=F,W.next_in=X,W.avail_in=Y,J.hold=U,J.bits=P,J.wsize||K!==W.avail_out&&J.mode<n&&(J.mode<d8||Q!==F5)){if($7(W,W.output,W.next_out,K-W.avail_out));}if(H-=W.avail_in,K-=W.avail_out,W.total_in+=H,W.total_out+=K,J.total+=K,J.wrap&4&&K)W.adler=J.check=J.flags?t(J.check,G,K,W.next_out-K):g1(J.check,G,K,W.next_out-K);if(W.data_type=J.bits+(J.last?64:0)+(J.mode===L0?128:0)+(J.mode===V8||J.mode===_8?256:0),(H===0&&K===0||Q===F5)&&D===c0)D=s9;return D},YQ=(W)=>{if(l0(W))return z0;let Q=W.state;if(Q.window)Q.window=null;return W.state=null,c0},qQ=(W,Q)=>{if(l0(W))return z0;const J=W.state;if((J.wrap&2)===0)return z0;return J.head=Q,Q.done=!1,c0},UQ=(W,Q)=>{const J=Q.length;let V,G,X;if(l0(W))return z0;if(V=W.state,V.wrap!==0&&V.mode!==U8)return z0;if(V.mode===U8){if(G=1,G=g1(G,Q,J,0),G!==V.check)return U7}if(X=$7(W,Q,J,J),X)return V.mode=K7,P7;return V.havedict=1,c0},PQ=Z7,KQ=H7,FQ=z7,zQ=VQ,ZQ=k7,HQ=XQ,kQ=YQ,$Q=qQ,jQ=UQ,CQ="pako inflate (from Nodeca project)",I0={inflateReset:PQ,inflateReset2:KQ,inflateResetKeep:FQ,inflateInit:zQ,inflateInit2:ZQ,inflate:HQ,inflateEnd:kQ,inflateGetHeader:$Q,inflateSetDictionary:jQ,inflateInfo:CQ},MQ=BQ,j7=Object.prototype.toString,{Z_NO_FLUSH:RQ,Z_FINISH:LQ,Z_OK:p1,Z_STREAM_END:l8,Z_NEED_DICT:r8,Z_STREAM_ERROR:OQ,Z_DATA_ERROR:p5,Z_MEM_ERROR:IQ}=i0;u1.prototype.push=function(W,Q){const J=this.strm,V=this.options.chunkSize,G=this.options.dictionary;let X,q,Y;if(this.ended)return!1;if(Q===~~Q)q=Q;else q=Q===!0?LQ:RQ;if(j7.call(W)==="[object ArrayBuffer]")J.input=new Uint8Array(W);else J.input=W;J.next_in=0,J.avail_in=J.input.length;for(;;){if(J.avail_out===0)J.output=new Uint8Array(V),J.next_out=0,J.avail_out=V;if(X=I0.inflate(J,q),X===r8&&G){if(X=I0.inflateSetDictionary(J,G),X===p1)X=I0.inflate(J,q);else if(X===p5)X=r8}while(J.avail_in>0&&X===l8&&J.state.wrap>0&&W[J.next_in]!==0)I0.inflateReset(J),X=I0.inflate(J,q);switch(X){case OQ:case p5:case r8:case IQ:return this.onEnd(X),this.ended=!0,!1}if(Y=J.avail_out,J.next_out){if(J.avail_out===0||X===l8)if(this.options.to==="string"){let F=y1.utf8border(J.output,J.next_out),U=J.next_out-F,P=y1.buf2string(J.output,F);if(J.next_out=U,J.avail_out=V-U,U)J.output.set(J.output.subarray(F,F+U),0);this.onData(P)}else this.onData(J.output.length===J.next_out?J.output:J.output.subarray(0,J.next_out))}if(X===p1&&Y===0)continue;if(X===l8)return X=I0.inflateEnd(this.strm),this.onEnd(X),this.ended=!0,!0;if(J.avail_in===0)break}return!0};u1.prototype.onData=function(W){this.chunks.push(W)};u1.prototype.onEnd=function(W){if(W===p1)if(this.options.to==="string")this.result=this.chunks.join("");else this.result=K8.flattenChunks(this.chunks);this.chunks=[],this.err=W,this.msg=this.strm.msg};var xQ=u1,wQ=P6,NQ=DQ,SQ=P6,vQ=i0,TQ={Inflate:xQ,inflate:wQ,inflateRaw:NQ,ungzip:SQ,constants:vQ},{Deflate:AQ,deflate:gQ,deflateRaw:EQ,gzip:yQ}=h9,{Inflate:pQ,inflate:fQ,inflateRaw:bQ,ungzip:hQ}=TQ,uQ=AQ,mQ=gQ,_Q=EQ,dQ=yQ,cQ=pQ,iQ=fQ,lQ=bQ,rQ=hQ,nQ=i0,m1={Deflate:uQ,deflate:mQ,deflateRaw:_Q,gzip:dQ,Inflate:cQ,inflate:iQ,inflateRaw:lQ,ungzip:rQ,constants:nQ};var w8=function(W){return W instanceof Uint8Array||ArrayBuffer.isView(W)&&W.constructor.name==="Uint8Array"},B6=function(W){if(!Number.isSafeInteger(W)||W<0)throw Error("positive integer expected, got "+W)},e0=function(W,...Q){if(!w8(W))throw Error("Uint8Array expected");if(Q.length>0&&!Q.includes(W.length))throw Error("Uint8Array expected of length "+Q+", got length="+W.length)},u7=function(W){if(typeof W!="function"||typeof W.create!="function")throw Error("Hash should be wrapped by utils.createHasher");B6(W.outputLen),B6(W.blockLen)},C8=function(W,Q=!0){if(W.destroyed)throw Error("Hash instance has been destroyed");if(Q&&W.finished)throw Error("Hash#digest() has already been called")},B8=function(...W){for(let Q=0;Q<W.length;Q++)W[Q].fill(0)},K6=function(W){return new DataView(W.buffer,W.byteOffset,W.byteLength)},M0=function(W,Q){return W<<32-Q|W>>>Q},H1=function(W){if(e0(W),m7)return W.toHex();let Q="";for(let J=0;J<W.length;J++)Q+=oQ[W[J]];return Q},R7=function(W){return W>=C7&&W<=aQ?W-C7:W>=B7&&W<=sQ?W-(B7-10):W>=M7&&W<=eQ?W-(M7-10):void 0},M8=function(W){if(typeof W!="string")throw Error("hex string expected, got "+typeof W);if(m7)return Uint8Array.fromHex(W);const Q=W.length,J=Q/2;if(Q%2)throw Error("hex string expected, got unpadded hex of length "+Q);const V=new Uint8Array(J);for(let G=0,X=0;G<J;G++,X+=2){const q=R7(W.charCodeAt(X)),Y=R7(W.charCodeAt(X+1));if(q===void 0||Y===void 0){const F=W[X]+W[X+1];throw Error('hex string expected, got non-hex character "'+F+'" at index '+X)}V[G]=16*q+Y}return V},_7=function(W){if(typeof W!="string")throw Error("string expected");return new Uint8Array((new TextEncoder()).encode(W))},N6=function(W){return typeof W=="string"&&(W=_7(W)),e0(W),W},R0=function(...W){let Q=0;for(let V=0;V<W.length;V++){const G=W[V];e0(G),Q+=G.length}const J=new Uint8Array(Q);for(let V=0,G=0;V<W.length;V++){const X=W[V];J.set(X,G),G+=X.length}return J},tQ=function(W){const Q=(V)=>W().update(N6(V)).digest(),J=W();return Q.outputLen=J.outputLen,Q.blockLen=J.blockLen,Q.create=()=>W(),Q},R8=function(W=32){if(P1&&typeof P1.getRandomValues=="function")return P1.getRandomValues(new Uint8Array(W));if(P1&&typeof P1.randomBytes=="function")return Uint8Array.from(P1.randomBytes(W));throw Error("crypto.getRandomValues must be defined")},WV=function(W,Q,J){return W&Q^W&J^Q&J},L8=function(W,Q=""){if(typeof W!="boolean")throw Error((Q&&`"${Q}"`)+"expected boolean, got type="+typeof W);return W},r0=function(W,Q,J=""){const V=w8(W),G=W?.length,X=Q!==void 0;if(!V||X&&G!==Q)throw Error((J&&`"${J}" `)+"expected Uint8Array"+(X?" of length "+Q:"")+", got "+(V?"length="+G:"type="+typeof W));return W},z8=function(W){const Q=W.toString(16);return 1&Q.length?"0"+Q:Q},l7=function(W){if(typeof W!="string")throw Error("hex string expected, got "+typeof W);return W===""?T6:BigInt("0x"+W)},j1=function(W){return l7(H1(W))},r7=function(W){return e0(W),l7(H1(Uint8Array.from(W).reverse()))},N8=function(W,Q){return M8(W.toString(16).padStart(2*Q,"0"))},n7=function(W,Q){return N8(W,Q).reverse()},e=function(W,Q,J){let V;if(typeof Q=="string")try{V=M8(Q)}catch(X){throw Error(W+" must be hex string or Uint8Array, cause: "+X)}else{if(!w8(Q))throw Error(W+" must be hex string or Uint8Array");V=Uint8Array.from(Q)}const G=V.length;if(typeof J=="number"&&G!==J)throw Error(W+" of length "+J+" expected, got "+G);return V},L6=function(W,Q,J){return F6(W)&&F6(Q)&&F6(J)&&Q<=W&&W<J},o7=function(W){let Q;for(Q=0;W>T6;W>>=R6,Q+=1);return Q},A6=function(W,Q,J={}){if(!W||typeof W!="object")throw Error("expected valid options object");function V(G,X,q){const Y=W[G];if(q&&Y===void 0)return;const F=typeof Y;if(F!==X||Y===null)throw Error(`param "${G}" is invalid: expected ${X}, got ${F}`)}Object.entries(Q).forEach(([G,X])=>V(G,X,!1)),Object.entries(J).forEach(([G,X])=>V(G,X,!0))},L7=function(W){const Q=new WeakMap;return(J,...V)=>{const G=Q.get(J);if(G!==void 0)return G;const X=W(J,...V);return Q.set(J,X),X}},H0=function(W,Q){const J=W%Q;return J>=q0?J:Q+J},Z0=function(W,Q,J){let V=W;for(;Q-- >q0;)V*=V,V%=J;return V},I7=function(W,Q){if(W===q0)throw Error("invert: expected non-zero number");if(Q<=q0)throw Error("invert: expected positive modulus, got "+Q);let J=H0(W,Q),V=Q,G=q0,X=X0;for(;J!==q0;){const q=V%J,Y=G-X*(V/J);V=J,J=q,G=X,X=Y}if(V!==X0)throw Error("invert: does not exist");return H0(G,Q)},g6=function(W,Q,J){if(!W.eql(W.sqr(Q),J))throw Error("Cannot find square root")},WW=function(W,Q){const J=(W.ORDER+X0)/s7,V=W.pow(Q,J);return g6(W,V,Q),V},GV=function(W,Q){const J=(W.ORDER-e7)/t7,V=W.mul(Q,o0),G=W.pow(V,J),X=W.mul(Q,G),q=W.mul(W.mul(X,o0),G),Y=W.mul(X,W.sub(q,W.ONE));return g6(W,Y,Q),Y},D7=function(W){if(W<a7)throw Error("sqrt is not defined for small field");let Q=W-X0,J=0;for(;Q%o0===q0;)Q/=o0,J++;let V=o0;const G=r1(W);for(;x7(G,V)===1;)if(V++>1000)throw Error("Cannot find square root: probably non-prime P");if(J===1)return WW;let X=G.pow(V,Q);const q=(Q+X0)/o0;return function(Y,F){if(Y.is0(F))return F;if(x7(Y,F)!==1)throw Error("Cannot find square root");let U=J,P=Y.mul(Y.ONE,X),H=Y.pow(F,Q),K=Y.pow(F,q);for(;!Y.eql(H,Y.ONE);){if(Y.is0(H))return Y.ZERO;let z=1,C=Y.sqr(H);for(;!Y.eql(C,Y.ONE);)if(z++,C=Y.sqr(C),z===U)throw Error("Cannot find square root");const v=X0<<BigInt(U-z-1),E=Y.pow(P,v);U=z,P=Y.sqr(E),H=Y.mul(H,P),K=Y.mul(K,E)}return K}},XV=function(W){return W%s7===a7?WW:W%t7===e7?GV:W%O7===VV?function(Q){const J=r1(Q),V=D7(Q),G=V(J,J.neg(J.ONE)),X=V(J,G),q=V(J,J.neg(G)),Y=(Q+QV)/O7;return(F,U)=>{let P=F.pow(U,Y),H=F.mul(P,G);const K=F.mul(P,X),z=F.mul(P,q),C=F.eql(F.sqr(H),U),v=F.eql(F.sqr(K),U);P=F.cmov(P,H,C),H=F.cmov(z,K,v);const E=F.eql(F.sqr(H),U),f=F.cmov(P,H,E);return g6(F,f,U),f}}(W):D7(W)},JW=function(W,Q,J=!1){const V=Array(Q.length).fill(J?W.ZERO:void 0),G=Q.reduce((q,Y,F)=>W.is0(Y)?q:(V[F]=q,W.mul(q,Y)),W.ONE),X=W.inv(G);return Q.reduceRight((q,Y,F)=>W.is0(Y)?q:(V[F]=W.mul(q,V[F]),W.mul(q,Y)),X),V},x7=function(W,Q){const J=(W.ORDER-X0)/o0,V=W.pow(Q,J),G=W.eql(V,W.ONE),X=W.eql(V,W.ZERO),q=W.eql(V,W.neg(W.ONE));if(!G&&!X&&!q)throw Error("invalid Legendre symbol result");return G?1:X?0:-1},QW=function(W,Q){Q!==void 0&&B6(Q);const J=Q!==void 0?Q:W.toString(2).length;return{nBitLength:J,nByteLength:Math.ceil(J/8)}},r1=function(W,Q,J=!1,V={}){if(W<=q0)throw Error("invalid field: expected ORDER > 0, got "+W);let G,X,q,Y=!1;if(typeof Q=="object"&&Q!=null){if(V.sqrt||J)throw Error("cannot specify opts in two arguments");const K=Q;K.BITS&&(G=K.BITS),K.sqrt&&(X=K.sqrt),typeof K.isLE=="boolean"&&(J=K.isLE),typeof K.modFromBytes=="boolean"&&(Y=K.modFromBytes),q=K.allowedLengths}else typeof Q=="number"&&(G=Q),V.sqrt&&(X=V.sqrt);const{nBitLength:F,nByteLength:U}=QW(W,G);if(U>2048)throw Error("invalid field: expected ORDER of <= 2048 bytes");let P;const H=Object.freeze({ORDER:W,isLE:J,BITS:F,BYTES:U,MASK:l1(F),ZERO:q0,ONE:X0,allowedLengths:q,create(K){return H0(K,W)},isValid(K){if(typeof K!="bigint")throw Error("invalid field element: expected bigint, got "+typeof K);return q0<=K&&K<W},is0(K){return K===q0},isValidNot0(K){return!H.is0(K)&&H.isValid(K)},isOdd(K){return(K&X0)===X0},neg(K){return H0(-K,W)},eql(K,z){return K===z},sqr(K){return H0(K*K,W)},add(K,z){return H0(K+z,W)},sub(K,z){return H0(K-z,W)},mul(K,z){return H0(K*z,W)},pow(K,z){return function(C,v,E){if(E<q0)throw Error("invalid exponent, negatives unsupported");if(E===q0)return C.ONE;if(E===X0)return v;let f=C.ONE,b=v;for(;E>q0;)E&X0&&(f=C.mul(f,b)),b=C.sqr(b),E>>=X0;return f}(H,K,z)},div(K,z){return H0(K*I7(z,W),W)},sqrN(K){return K*K},addN(K,z){return K+z},subN(K,z){return K-z},mulN(K,z){return K*z},inv(K){return I7(K,W)},sqrt:X||((K)=>(P||(P=XV(W)),P(H,K))),toBytes(K){return J?n7(K,U):N8(K,U)},fromBytes(K,z=!0){if(q){if(!q.includes(K.length)||K.length>U)throw Error("Field.fromBytes: expected "+q+" bytes, got "+K.length);const v=new Uint8Array(U);v.set(K,J?0:v.length-K.length),K=v}if(K.length!==U)throw Error("Field.fromBytes: expected "+U+" bytes, got "+K.length);let C=J?r7(K):j1(K);if(Y&&(C=H0(C,W)),!z&&!H.isValid(C))throw Error("invalid field element: outside of range 0..ORDER");return C},invertBatch(K){return JW(H,K)},cmov(K,z,C){return C?z:K}});return Object.freeze(H)},VW=function(W){if(typeof W!="bigint")throw Error("field order must be bigint");const Q=W.toString(2).length;return Math.ceil(Q/8)},GW=function(W){const Q=VW(W);return Q+Math.ceil(Q/2)},XW=function(W,Q,J=!1){const V=W.length,G=VW(Q),X=GW(Q);if(V<16||V<X||V>1024)throw Error("expected "+X+"-1024 bytes of input, got "+V);const q=H0(J?r7(W):j1(W),Q-X0)+X0;return J?n7(q,G):N8(q,G)},O8=function(W,Q){const J=Q.negate();return W?J:Q},z6=function(W,Q){const J=JW(W.Fp,Q.map((V)=>V.Z));return Q.map((V,G)=>W.fromAffine(V.toAffine(J[G])))},YW=function(W,Q){if(!Number.isSafeInteger(W)||W<=0||W>Q)throw Error("invalid window size, expected [1.."+Q+"], got W="+W)},Z6=function(W,Q){YW(W,Q);const J=2**W;return{windows:Math.ceil(Q/W)+1,windowSize:2**(W-1),mask:l1(W),maxNumber:J,shiftBy:BigInt(W)}},w7=function(W,Q,J){const{windowSize:V,mask:G,maxNumber:X,shiftBy:q}=J;let Y=Number(W&G),F=W>>q;Y>V&&(Y-=X,F+=a0);const U=Q*V;return{nextN:F,offset:U+Math.abs(Y)-1,isZero:Y===0,isNeg:Y<0,isNegF:Q%2!=0,offsetF:U}},k6=function(W){return qW.get(W)||1},N7=function(W){if(W!==k1)throw Error("invalid wNAF")},qV=function(W,Q,J,V){(function(K,z){if(!Array.isArray(K))throw Error("array expected");K.forEach((C,v)=>{if(!(C instanceof z))throw Error("invalid point at index "+v)})})(J,W),function(K,z){if(!Array.isArray(K))throw Error("array of scalars expected");K.forEach((C,v)=>{if(!z.isValid(C))throw Error("invalid scalar at index "+v)})}(V,Q);const G=J.length,X=V.length;if(G!==X)throw Error("arrays of points and scalars must have equal length");const q=W.ZERO,Y=o7(BigInt(G));let F=1;Y>12?F=Y-3:Y>4?F=Y-2:Y>0&&(F=2);const U=l1(F),P=Array(Number(U)+1).fill(q);let H=q;for(let K=Math.floor((Q.BITS-1)/F)*F;K>=0;K-=F){P.fill(q);for(let C=0;C<X;C++){const v=V[C],E=Number(v>>BigInt(K)&U);P[E]=P[E].add(J[C])}let z=q;for(let C=P.length-1,v=q;C>0;C--)v=v.add(P[C]),z=z.add(v);if(H=H.add(z),K!==0)for(let C=0;C<F;C++)H=H.double()}return H},S7=function(W,Q,J){if(Q){if(Q.ORDER!==W)throw Error("Field.ORDER must match order: Fp == p, Fn == n");return function(V){A6(V,YV.reduce((G,X)=>(G[X]="function",G),{ORDER:"bigint",MASK:"bigint",BYTES:"number",BITS:"number"}))}(Q),Q}return r1(W,{isLE:J})},O6=function(W){if(!["compact","recovered","der"].includes(W))throw Error('Signature format must be "compact", "recovered", or "der"');return W},$6=function(W,Q){const J={};for(let V of Object.keys(Q))J[V]=W[V]===void 0?Q[V]:W[V];return L8(J.lowS,"lowS"),L8(J.prehash,"prehash"),J.format!==void 0&&O6(J.format),J},n0=function(W,Q){const{BYTES:J}=W;let V;if(typeof Q=="bigint")V=Q;else{let G=e("private key",Q);try{V=W.fromBytes(G)}catch(X){throw Error(`invalid private key: expected ui8a of size ${J}, got ${typeof Q}`)}}if(!W.isValidNot0(V))throw Error("invalid private key: out of range [1..N-1]");return V},PV=function(W,Q={}){const J=function(Z,k,O={},$){if($===void 0&&($=Z==="edwards"),!k||typeof k!="object")throw Error(`expected valid ${Z} CURVE object`);for(let A of["p","n","h"]){const B=k[A];if(!(typeof B=="bigint"&&B>k1))throw Error(`CURVE.${A} must be positive bigint`)}const M=S7(k.p,O.Fp,$),w=S7(k.n,O.Fn,$),x=["Gx","Gy","a","b"];for(let A of x)if(!M.isValid(k[A]))throw Error(`CURVE.${A} must be valid field element of CURVE.Fp`);return{CURVE:k=Object.freeze(Object.assign({},k)),Fp:M,Fn:w}}("weierstrass",W,Q),{Fp:V,Fn:G}=J;let X=J.CURVE;const{h:q,n:Y}=X;A6(Q,{},{allowInfinityPoint:"boolean",clearCofactor:"function",isTorsionFree:"function",fromBytes:"function",toBytes:"function",endo:"object",wrapPrivateKey:"boolean"});const{endo:F}=Q;if(F&&(!V.is0(X.a)||typeof F.beta!="bigint"||!Array.isArray(F.basises)))throw Error('invalid endo: expected "beta": bigint and "basises": array');const U=FW(V,G);function P(){if(!V.isOdd)throw Error("compression is not supported: Field does not have .isOdd()")}const H=Q.toBytes||function(Z,k,O){const{x:$,y:M}=k.toAffine(),w=V.toBytes($);if(L8(O,"isCompressed"),O)return P(),R0(KW(!V.isOdd(M)),w);return R0(Uint8Array.of(4),w,V.toBytes(M))},K=Q.fromBytes||function(Z){r0(Z,void 0,"Point");const{publicKey:k,publicKeyUncompressed:O}=U,$=Z.length,M=Z[0],w=Z.subarray(1);if($!==k||M!==2&&M!==3){if($===O&&M===4){const x=V.BYTES,A=V.fromBytes(w.subarray(0,x)),B=V.fromBytes(w.subarray(x,2*x));if(!C(A,B))throw Error("bad point: is not on curve");return{x:A,y:B}}throw Error(`bad point: got length ${$}, expected compressed=${k} or uncompressed=${O}`)}{const x=V.fromBytes(w);if(!V.isValid(x))throw Error("bad point: is not on curve, wrong x");const A=z(x);let B;try{B=V.sqrt(A)}catch(j){const L=j instanceof Error?": "+j.message:"";throw Error("bad point: is not on curve, sqrt error"+L)}return P(),!(1&~M)!==V.isOdd(B)&&(B=V.neg(B)),{x,y:B}}};function z(Z){const k=V.sqr(Z),O=V.mul(k,Z);return V.add(V.add(O,V.mul(Z,X.a)),X.b)}function C(Z,k){const O=V.sqr(k),$=z(Z);return V.eql(O,$)}if(!C(X.Gx,X.Gy))throw Error("bad curve params: generator point");const v=V.mul(V.pow(X.a,Z8),UV),E=V.mul(V.sqr(X.b),BigInt(27));if(V.is0(V.add(v,E)))throw Error("bad curve params: a or b");function f(Z,k,O=!1){if(!V.isValid(k)||O&&V.is0(k))throw Error("bad point coordinate "+Z);return k}function b(Z){if(!(Z instanceof S))throw Error("ProjectivePoint expected")}function h(Z){if(!F||!F.basises)throw Error("no endo");return function(k,O,$){const[[M,w],[x,A]]=O,B=v7(A*k,$),j=v7(-w*k,$);let L=k-B*M-j*x,R=-B*w-j*A;const I=L<w0,N=R<w0;I&&(L=-L),N&&(R=-R);const p=l1(Math.ceil(o7($)/2))+z1;if(L<w0||L>=p||R<w0||R>=p)throw Error("splitScalar (endomorphism): failed, k="+k);return{k1neg:I,k1:L,k2neg:N,k2:R}}(Z,F.basises,G.ORDER)}const T=L7((Z,k)=>{const{X:O,Y:$,Z:M}=Z;if(V.eql(M,V.ONE))return{x:O,y:$};const w=Z.is0();k==null&&(k=w?V.ONE:V.inv(M));const x=V.mul(O,k),A=V.mul($,k),B=V.mul(M,k);if(w)return{x:V.ZERO,y:V.ZERO};if(!V.eql(B,V.ONE))throw Error("invZ was invalid");return{x,y:A}}),_=L7((Z)=>{if(Z.is0()){if(Q.allowInfinityPoint&&!V.is0(Z.Y))return;throw Error("bad point: ZERO")}const{x:k,y:O}=Z.toAffine();if(!V.isValid(k)||!V.isValid(O))throw Error("bad point: x or y not field elements");if(!C(k,O))throw Error("bad point: equation left != right");if(!Z.isTorsionFree())throw Error("bad point: not in prime-order subgroup");return!0});function d(Z,k,O,$,M){return O=new S(V.mul(O.X,Z),O.Y,O.Z),k=O8($,k),O=O8(M,O),k.add(O)}class S{constructor(Z,k,O){this.X=f("x",Z),this.Y=f("y",k,!0),this.Z=f("z",O),Object.freeze(this)}static CURVE(){return X}static fromAffine(Z){const{x:k,y:O}=Z||{};if(!Z||!V.isValid(k)||!V.isValid(O))throw Error("invalid affine point");if(Z instanceof S)throw Error("projective point not allowed");return V.is0(k)&&V.is0(O)?S.ZERO:new S(k,O,V.ONE)}static fromBytes(Z){const k=S.fromAffine(K(r0(Z,void 0,"point")));return k.assertValidity(),k}static fromHex(Z){return S.fromBytes(e("pointHex",Z))}get x(){return this.toAffine().x}get y(){return this.toAffine().y}precompute(Z=8,k=!0){return g.createCache(this,Z),k||this.multiply(Z8),this}assertValidity(){_(this)}hasEvenY(){const{y:Z}=this.toAffine();if(!V.isOdd)throw Error("Field doesn't support isOdd");return!V.isOdd(Z)}equals(Z){b(Z);const{X:k,Y:O,Z:$}=this,{X:M,Y:w,Z:x}=Z,A=V.eql(V.mul(k,x),V.mul(M,$)),B=V.eql(V.mul(O,x),V.mul(w,$));return A&&B}negate(){return new S(this.X,V.neg(this.Y),this.Z)}double(){const{a:Z,b:k}=X,O=V.mul(k,Z8),{X:$,Y:M,Z:w}=this;let{ZERO:x,ZERO:A,ZERO:B}=V,j=V.mul($,$),L=V.mul(M,M),R=V.mul(w,w),I=V.mul($,M);return I=V.add(I,I),B=V.mul($,w),B=V.add(B,B),x=V.mul(Z,B),A=V.mul(O,R),A=V.add(x,A),x=V.sub(L,A),A=V.add(L,A),A=V.mul(x,A),x=V.mul(I,x),B=V.mul(O,B),R=V.mul(Z,R),I=V.sub(j,R),I=V.mul(Z,I),I=V.add(I,B),B=V.add(j,j),j=V.add(B,j),j=V.add(j,R),j=V.mul(j,I),A=V.add(A,j),R=V.mul(M,w),R=V.add(R,R),j=V.mul(R,I),x=V.sub(x,j),B=V.mul(R,L),B=V.add(B,B),B=V.add(B,B),new S(x,A,B)}add(Z){b(Z);const{X:k,Y:O,Z:$}=this,{X:M,Y:w,Z:x}=Z;let{ZERO:A,ZERO:B,ZERO:j}=V;const L=X.a,R=V.mul(X.b,Z8);let I=V.mul(k,M),N=V.mul(O,w),p=V.mul($,x),y=V.add(k,O),u=V.add(M,w);y=V.mul(y,u),u=V.add(I,N),y=V.sub(y,u),u=V.add(k,$);let m=V.add(M,x);return u=V.mul(u,m),m=V.add(I,p),u=V.sub(u,m),m=V.add(O,$),A=V.add(w,x),m=V.mul(m,A),A=V.add(N,p),m=V.sub(m,A),j=V.mul(L,u),A=V.mul(R,p),j=V.add(A,j),A=V.sub(N,j),j=V.add(N,j),B=V.mul(A,j),N=V.add(I,I),N=V.add(N,I),p=V.mul(L,p),u=V.mul(R,u),N=V.add(N,p),p=V.sub(I,p),p=V.mul(L,p),u=V.add(u,p),I=V.mul(N,u),B=V.add(B,I),I=V.mul(m,u),A=V.mul(y,A),A=V.sub(A,I),I=V.mul(y,N),j=V.mul(m,j),j=V.add(j,I),new S(A,B,j)}subtract(Z){return this.add(Z.negate())}is0(){return this.equals(S.ZERO)}multiply(Z){const{endo:k}=Q;if(!G.isValidNot0(Z))throw Error("invalid scalar: out of range");let O,$;const M=(w)=>g.cached(this,w,(x)=>z6(S,x));if(k){const{k1neg:w,k1:x,k2neg:A,k2:B}=h(Z),{p:j,f:L}=M(x),{p:R,f:I}=M(B);$=L.add(I),O=d(k.beta,j,R,w,A)}else{const{p:w,f:x}=M(Z);O=w,$=x}return z6(S,[O,$])[0]}multiplyUnsafe(Z){const{endo:k}=Q,O=this;if(!G.isValid(Z))throw Error("invalid scalar: out of range");if(Z===w0||O.is0())return S.ZERO;if(Z===z1)return O;if(g.hasCache(this))return this.multiply(Z);if(k){const{k1neg:$,k1:M,k2neg:w,k2:x}=h(Z),{p1:A,p2:B}=function(j,L,R,I){let N=L,p=j.ZERO,y=j.ZERO;for(;R>k1||I>k1;)R&a0&&(p=p.add(N)),I&a0&&(y=y.add(N)),N=N.double(),R>>=a0,I>>=a0;return{p1:p,p2:y}}(S,O,M,x);return d(k.beta,A,B,$,w)}return g.unsafe(O,Z)}multiplyAndAddUnsafe(Z,k,O){const $=this.multiplyUnsafe(k).add(Z.multiplyUnsafe(O));return $.is0()?void 0:$}toAffine(Z){return T(this,Z)}isTorsionFree(){const{isTorsionFree:Z}=Q;return q===z1||(Z?Z(S,this):g.unsafe(this,Y).is0())}clearCofactor(){const{clearCofactor:Z}=Q;return q===z1?this:Z?Z(S,this):this.multiplyUnsafe(q)}isSmallOrder(){return this.multiplyUnsafe(q).is0()}toBytes(Z=!0){return L8(Z,"isCompressed"),this.assertValidity(),H(S,this,Z)}toHex(Z=!0){return H1(this.toBytes(Z))}toString(){return`<Point ${this.is0()?"ZERO":this.toHex()}>`}get px(){return this.X}get py(){return this.X}get pz(){return this.Z}toRawBytes(Z=!0){return this.toBytes(Z)}_setWindowSize(Z){this.precompute(Z)}static normalizeZ(Z){return z6(S,Z)}static msm(Z,k){return qV(S,G,Z,k)}static fromPrivateKey(Z){return S.BASE.multiply(n0(G,Z))}}S.BASE=new S(X.Gx,X.Gy,V.ONE),S.ZERO=new S(V.ZERO,V.ONE,V.ZERO),S.Fp=V,S.Fn=G;const D=G.BITS,g=new UW(S,Q.endo?Math.ceil(D/2):D);return S.BASE.precompute(8),S},KW=function(W){return Uint8Array.of(W?2:3)},FW=function(W,Q){return{secretKey:Q.BYTES,publicKey:1+W.BYTES,publicKeyUncompressed:1+2*W.BYTES,publicKeyHasPrefix:!0,signature:2*Q.BYTES}},KV=function(W,Q,J={}){u7(Q),A6(J,{},{hmac:"function",lowS:"boolean",randomBytes:"function",bits2int:"function",bits2int_modN:"function"});const V=J.randomBytes||R8,G=J.hmac||((D,...g)=>i7(Q,D,R0(...g))),{Fp:X,Fn:q}=W,{ORDER:Y,BITS:F}=q,{keygen:U,getPublicKey:P,getSharedSecret:H,utils:K,lengths:z}=function(D,g={}){const{Fn:Z}=D,k=g.randomBytes||R8,O=Object.assign(FW(D.Fp,Z),{seed:GW(Z.ORDER)});function $(B){try{return!!n0(Z,B)}catch(j){return!1}}function M(B=k(O.seed)){return XW(r0(B,O.seed,"seed"),Z.ORDER)}function w(B,j=!0){return D.BASE.multiply(n0(Z,B)).toBytes(j)}function x(B){if(typeof B=="bigint")return!1;if(B instanceof D)return!0;const{secretKey:j,publicKey:L,publicKeyUncompressed:R}=O;if(Z.allowedLengths||j===L)return;const I=e("key",B).length;return I===L||I===R}return Object.freeze({getPublicKey:w,getSharedSecret(B,j,L=!0){if(x(B)===!0)throw Error("first arg must be private key");if(x(j)===!1)throw Error("second arg must be public key");const R=n0(Z,B);return D.fromHex(j).multiply(R).toBytes(L)},keygen(B){const j=M(B);return{secretKey:j,publicKey:w(j)}},Point:D,utils:{isValidSecretKey:$,isValidPublicKey(B,j){const{publicKey:L,publicKeyUncompressed:R}=O;try{const I=B.length;return!(j===!0&&I!==L||j===!1&&I!==R||!D.fromBytes(B))}catch(I){return!1}},randomSecretKey:M,isValidPrivateKey:$,randomPrivateKey:M,normPrivateKeyToScalar:(B)=>n0(Z,B),precompute(B=8,j=D.BASE){return j.precompute(B,!1)}},lengths:O})}(W,J),C={prehash:!1,lowS:typeof J.lowS=="boolean"&&J.lowS,format:void 0,extraEntropy:!1},v="compact";function E(D){return D>Y>>z1}function f(D,g){if(!q.isValidNot0(g))throw Error(`invalid signature ${D}: out of range 1..Point.Fn.ORDER`);return g}class b{constructor(D,g,Z){this.r=f("r",D),this.s=f("s",g),Z!=null&&(this.recovery=Z),Object.freeze(this)}static fromBytes(D,g=v){let Z;if(function(M,w){O6(w);const x=z.signature;r0(M,w==="compact"?x:w==="recovered"?x+1:void 0,w+" signature")}(D,g),g==="der"){const{r:M,s:w}=x0.toSig(r0(D));return new b(M,w)}g==="recovered"&&(Z=D[0],g="compact",D=D.subarray(1));const k=q.BYTES,O=D.subarray(0,k),$=D.subarray(k,2*k);return new b(q.fromBytes(O),q.fromBytes($),Z)}static fromHex(D,g){return this.fromBytes(M8(D),g)}addRecoveryBit(D){return new b(this.r,this.s,D)}recoverPublicKey(D){const g=X.ORDER,{r:Z,s:k,recovery:O}=this;if(O==null||![0,1,2,3].includes(O))throw Error("recovery id invalid");if(Y*PW<g&&O>1)throw Error("recovery id is ambiguous for h>1 curve");const $=O===2||O===3?Z+Y:Z;if(!X.isValid($))throw Error("recovery id 2 or 3 invalid");const M=X.toBytes($),w=W.fromBytes(R0(KW(!(1&O)),M)),x=q.inv($),A=T(e("msgHash",D)),B=q.create(-A*x),j=q.create(k*x),L=W.BASE.multiplyUnsafe(B).add(w.multiplyUnsafe(j));if(L.is0())throw Error("point at infinify");return L.assertValidity(),L}hasHighS(){return E(this.s)}toBytes(D=v){if(O6(D),D==="der")return M8(x0.hexFromSig(this));const g=q.toBytes(this.r),Z=q.toBytes(this.s);if(D==="recovered"){if(this.recovery==null)throw Error("recovery bit must be present");return R0(Uint8Array.of(this.recovery),g,Z)}return R0(g,Z)}toHex(D){return H1(this.toBytes(D))}assertValidity(){}static fromCompact(D){return b.fromBytes(e("sig",D),"compact")}static fromDER(D){return b.fromBytes(e("sig",D),"der")}normalizeS(){return this.hasHighS()?new b(this.r,q.neg(this.s),this.recovery):this}toDERRawBytes(){return this.toBytes("der")}toDERHex(){return H1(this.toBytes("der"))}toCompactRawBytes(){return this.toBytes("compact")}toCompactHex(){return H1(this.toBytes("compact"))}}const h=J.bits2int||function(D){if(D.length>8192)throw Error("input is too large");const g=j1(D),Z=8*D.length-F;return Z>0?g>>BigInt(Z):g},T=J.bits2int_modN||function(D){return q.create(h(D))},_=l1(F);function d(D){return function(g,Z,k,O){if(!L6(Z,k,O))throw Error("expected valid "+g+": "+k+" <= n < "+O+", got "+Z)}("num < 2^"+F,D,w0,_),q.toBytes(D)}function S(D,g){return r0(D,void 0,"message"),g?r0(Q(D),void 0,"prehashed message"):D}return Object.freeze({keygen:U,getPublicKey:P,getSharedSecret:H,utils:K,lengths:z,Point:W,sign(D,g,Z={}){D=e("message",D);const{seed:k,k2sig:O}=function($,M,w){if(["recovered","canonical"].some((p)=>(p in w)))throw Error("sign() legacy options not supported");const{lowS:x,prehash:A,extraEntropy:B}=$6(w,C);$=S($,A);const j=T($),L=n0(q,M),R=[d(L),d(j)];if(B!=null&&B!==!1){const p=B===!0?V(z.secretKey):B;R.push(e("extraEntropy",p))}const I=R0(...R),N=j;return{seed:I,k2sig(p){const y=h(p);if(!q.isValidNot0(y))return;const u=q.inv(y),m=W.BASE.multiply(y).toAffine(),a=q.create(m.x);if(a===w0)return;const o=q.create(u*q.create(N+a*L));if(o===w0)return;let W0=(m.x===a?0:2)|Number(m.y&z1),Q0=o;return x&&E(o)&&(Q0=q.neg(o),W0^=1),new b(a,Q0,W0)}}}(D,g,Z);return function($,M,w){if(typeof $!="number"||$<2)throw Error("hashLen must be a number");if(typeof M!="number"||M<2)throw Error("qByteLen must be a number");if(typeof w!="function")throw Error("hmacFn must be a function");const x=(y)=>new Uint8Array(y),A=(y)=>Uint8Array.of(y);let B=x($),j=x($),L=0;const R=()=>{B.fill(1),j.fill(0),L=0},I=(...y)=>w(j,B,...y),N=(y=x(0))=>{j=I(A(0),y),B=I(),y.length!==0&&(j=I(A(1),y),B=I())},p=()=>{if(L++>=1000)throw Error("drbg: tried 1000 values");let y=0;const u=[];for(;y<M;){B=I();const m=B.slice();u.push(m),y+=B.length}return R0(...u)};return(y,u)=>{let m;for(R(),N(y);!(m=u(p()));)N();return R(),m}}(Q.outputLen,q.BYTES,G)(k,O)},verify(D,g,Z,k={}){const{lowS:O,prehash:$,format:M}=$6(k,C);if(Z=e("publicKey",Z),g=S(e("message",g),$),("strict"in k))throw Error("options.strict was renamed to lowS");const w=M===void 0?function(x){let A;const B=typeof x=="string"||w8(x),j=!B&&x!==null&&typeof x=="object"&&typeof x.r=="bigint"&&typeof x.s=="bigint";if(!B&&!j)throw Error("invalid signature, expected Uint8Array, hex string or Signature instance");if(j)A=new b(x.r,x.s);else if(B){try{A=b.fromBytes(e("sig",x),"der")}catch(L){if(!(L instanceof x0.Err))throw L}if(!A)try{A=b.fromBytes(e("sig",x),"compact")}catch(L){return!1}}return A||!1}(D):b.fromBytes(e("sig",D),M);if(w===!1)return!1;try{const x=W.fromBytes(Z);if(O&&w.hasHighS())return!1;const{r:A,s:B}=w,j=T(g),L=q.inv(B),R=q.create(j*L),I=q.create(A*L),N=W.BASE.multiplyUnsafe(R).add(x.multiplyUnsafe(I));if(N.is0())return!1;return q.create(N.x)===A}catch(x){return!1}},recoverPublicKey(D,g,Z={}){const{prehash:k}=$6(Z,C);return g=S(g,k),b.fromBytes(D,"recovered").recoverPublicKey(g).toBytes()},Signature:b,hash:Q})},FV=function(W){const{CURVE:Q,curveOpts:J}=function(G){const X={a:G.a,b:G.b,p:G.Fp.ORDER,n:G.n,h:G.h,Gx:G.Gx,Gy:G.Gy},q=G.Fp;let Y=G.allowedPrivateKeyLengths?Array.from(new Set(G.allowedPrivateKeyLengths.map((F)=>Math.ceil(F/2)))):void 0;return{CURVE:X,curveOpts:{Fp:q,Fn:r1(X.n,{BITS:G.nBitLength,allowedLengths:Y,modFromBytes:G.wrapPrivateKey}),allowInfinityPoint:G.allowInfinityPoint,endo:G.endo,isTorsionFree:G.isTorsionFree,clearCofactor:G.clearCofactor,fromBytes:G.fromBytes,toBytes:G.toBytes}}}(W),V={hmac:W.hmac,randomBytes:W.randomBytes,lowS:W.lowS,bits2int:W.bits2int,bits2int_modN:W.bits2int_modN};return{CURVE:Q,curveOpts:J,hash:W.hash,ecdsaOpts:V}},zV=function(W){const{CURVE:Q,curveOpts:J,hash:V,ecdsaOpts:G}=FV(W);return function(X,q){const Y=q.Point;return Object.assign({},q,{ProjectivePoint:Y,CURVE:Object.assign({},X,QW(Y.Fn.ORDER,Y.Fn.BITS))})}(W,KV(PV(Q,J),V,G))},D8=function(W,...Q){let J=A7[W];if(J===void 0){const V=M6(_7(W));J=R0(V,V),A7[W]=J}return M6(R0(J,...Q))},D6=function(W){const{Fn:Q,BASE:J}=C1,V=n0(Q,W),G=J.multiply(V);return{scalar:y6(G.y)?V:Q.neg(V),bytes:E6(G)}},ZW=function(W){const Q=I8;if(!Q.isValidNot0(W))throw Error("invalid x: Fail if x \u2265 p");const J=Q.create(W*W),V=Q.create(J*W+BigInt(7));let G=Q.sqrt(V);y6(G)||(G=Q.neg(G));const X=C1.fromAffine({x:W,y:G});return X.assertValidity(),X},HW=function(...W){return C1.Fn.create(i1(D8("BIP0340/challenge",...W)))},g7=function(W){return D6(W).bytes},kV=function(W,Q,J=R8(32)){const{Fn:V}=C1,G=e("message",W),{bytes:X,scalar:q}=D6(Q),Y=e("auxRand",J,32),F=V.toBytes(q^i1(D8("BIP0340/aux",Y))),U=D8("BIP0340/nonce",F,X,G),{bytes:P,scalar:H}=D6(U),K=HW(P,X,G),z=new Uint8Array(64);if(z.set(P,0),z.set(V.toBytes(V.create(H+K*q)),32),!kW(z,G,X))throw Error("sign: Invalid signature produced");return z},kW=function(W,Q,J){const{Fn:V,BASE:G}=C1,X=e("signature",W,64),q=e("message",Q),Y=e("publicKey",J,32);try{const F=ZW(i1(Y)),U=i1(X.subarray(0,32));if(!L6(U,T7,$1.p))return!1;const P=i1(X.subarray(32,64));if(!L6(P,T7,$1.n))return!1;const H=HW(V.toBytes(U),E6(F),q),K=G.multiplyUnsafe(P).add(F.multiplyUnsafe(V.neg(H))),{x:z,y:C}=K.toAffine();return!(K.is0()||!y6(C)||z!==U)}catch(F){return!1}},P1=typeof globalThis=="object"&&("crypto"in globalThis)?globalThis.crypto:void 0,m7=(()=>typeof Uint8Array.from([]).toHex=="function"&&typeof Uint8Array.fromHex=="function")(),oQ=Array.from({length:256},(W,Q)=>Q.toString(16).padStart(2,"0")),C7=48,aQ=57,B7=65,sQ=70,M7=97,eQ=102;class S6{}class d7 extends S6{constructor(W,Q,J,V){super(),this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.blockLen=W,this.outputLen=Q,this.padOffset=J,this.isLE=V,this.buffer=new Uint8Array(W),this.view=K6(this.buffer)}update(W){C8(this),e0(W=N6(W));const{view:Q,buffer:J,blockLen:V}=this,G=W.length;for(let X=0;X<G;){const q=Math.min(V-this.pos,G-X);if(q!==V)J.set(W.subarray(X,X+q),this.pos),this.pos+=q,X+=q,this.pos===V&&(this.process(Q,0),this.pos=0);else{const Y=K6(W);for(;V<=G-X;X+=V)this.process(Y,X)}}return this.length+=W.length,this.roundClean(),this}digestInto(W){C8(this),function(P,H){e0(P);const K=H.outputLen;if(P.length<K)throw Error("digestInto() expects output buffer of length at least "+K)}(W,this),this.finished=!0;const{buffer:Q,view:J,blockLen:V,isLE:G}=this;let{pos:X}=this;Q[X++]=128,B8(this.buffer.subarray(X)),this.padOffset>V-X&&(this.process(J,0),X=0);for(let P=X;P<V;P++)Q[P]=0;(function(P,H,K,z){if(typeof P.setBigUint64=="function")return P.setBigUint64(H,K,z);const C=BigInt(32),v=BigInt(4294967295),E=Number(K>>C&v),f=Number(K&v),b=z?4:0,h=z?0:4;P.setUint32(H+b,E,z),P.setUint32(H+h,f,z)})(J,V-8,BigInt(8*this.length),G),this.process(J,0);const q=K6(W),Y=this.outputLen;if(Y%4)throw Error("_sha2: outputLen should be aligned to 32bit");const F=Y/4,U=this.get();if(F>U.length)throw Error("_sha2: outputLen bigger than state");for(let P=0;P<F;P++)q.setUint32(4*P,U[P],G)}digest(){const{buffer:W,outputLen:Q}=this;this.digestInto(W);const J=W.slice(0,Q);return this.destroy(),J}_cloneInto(W){W||(W=new this.constructor),W.set(...this.get());const{blockLen:Q,buffer:J,length:V,finished:G,destroyed:X,pos:q}=this;return W.destroyed=X,W.finished=G,W.length=V,W.pos=q,V%Q&&W.buffer.set(J),W}clone(){return this._cloneInto()}}var p0=Uint32Array.from([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),JV=Uint32Array.from([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),f0=new Uint32Array(64);class c7 extends d7{constructor(W=32){super(64,W,8,!1),this.A=0|p0[0],this.B=0|p0[1],this.C=0|p0[2],this.D=0|p0[3],this.E=0|p0[4],this.F=0|p0[5],this.G=0|p0[6],this.H=0|p0[7]}get(){const{A:W,B:Q,C:J,D:V,E:G,F:X,G:q,H:Y}=this;return[W,Q,J,V,G,X,q,Y]}set(W,Q,J,V,G,X,q,Y){this.A=0|W,this.B=0|Q,this.C=0|J,this.D=0|V,this.E=0|G,this.F=0|X,this.G=0|q,this.H=0|Y}process(W,Q){for(let H=0;H<16;H++,Q+=4)f0[H]=W.getUint32(Q,!1);for(let H=16;H<64;H++){const K=f0[H-15],z=f0[H-2],C=M0(K,7)^M0(K,18)^K>>>3,v=M0(z,17)^M0(z,19)^z>>>10;f0[H]=v+f0[H-7]+C+f0[H-16]|0}let{A:J,B:V,C:G,D:X,E:q,F:Y,G:F,H:U}=this;for(let H=0;H<64;H++){const K=U+(M0(q,6)^M0(q,11)^M0(q,25))+((P=q)&Y^~P&F)+JV[H]+f0[H]|0,z=(M0(J,2)^M0(J,13)^M0(J,22))+WV(J,V,G)|0;U=F,F=Y,Y=q,q=X+K|0,X=G,G=V,V=J,J=K+z|0}var P;J=J+this.A|0,V=V+this.B|0,G=G+this.C|0,X=X+this.D|0,q=q+this.E|0,Y=Y+this.F|0,F=F+this.G|0,U=U+this.H|0,this.set(J,V,G,X,q,Y,F,U)}roundClean(){B8(f0)}destroy(){this.set(0,0,0,0,0,0,0,0),B8(this.buffer)}}var M6=tQ(()=>new c7);class v6 extends S6{constructor(W,Q){super(),this.finished=!1,this.destroyed=!1,u7(W);const J=N6(Q);if(this.iHash=W.create(),typeof this.iHash.update!="function")throw Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const V=this.blockLen,G=new Uint8Array(V);G.set(J.length>V?W.create().update(J).digest():J);for(let X=0;X<G.length;X++)G[X]^=54;this.iHash.update(G),this.oHash=W.create();for(let X=0;X<G.length;X++)G[X]^=106;this.oHash.update(G),B8(G)}update(W){return C8(this),this.iHash.update(W),this}digestInto(W){C8(this),e0(W,this.outputLen),this.finished=!0,this.iHash.digestInto(W),this.oHash.update(W),this.oHash.digestInto(W),this.destroy()}digest(){const W=new Uint8Array(this.oHash.outputLen);return this.digestInto(W),W}_cloneInto(W){W||(W=Object.create(Object.getPrototypeOf(this),{}));const{oHash:Q,iHash:J,finished:V,destroyed:G,blockLen:X,outputLen:q}=this;return W.finished=V,W.destroyed=G,W.blockLen=X,W.outputLen=q,W.oHash=Q._cloneInto(W.oHash),W.iHash=J._cloneInto(W.iHash),W}clone(){return this._cloneInto()}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}var i7=(W,Q,J)=>new v6(W,Q).update(J).digest();i7.create=(W,Q)=>new v6(W,Q);var T6=BigInt(0),R6=BigInt(1),F6=(W)=>typeof W=="bigint"&&T6<=W,l1=(W)=>(R6<<BigInt(W))-R6,q0=BigInt(0),X0=BigInt(1),o0=BigInt(2),a7=BigInt(3),s7=BigInt(4),e7=BigInt(5),QV=BigInt(7),t7=BigInt(8),VV=BigInt(9),O7=BigInt(16),YV=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"],k1=BigInt(0),a0=BigInt(1),H6=new WeakMap,qW=new WeakMap;class UW{constructor(W,Q){this.BASE=W.BASE,this.ZERO=W.ZERO,this.Fn=W.Fn,this.bits=Q}_unsafeLadder(W,Q,J=this.ZERO){let V=W;for(;Q>k1;)Q&a0&&(J=J.add(V)),V=V.double(),Q>>=a0;return J}precomputeWindow(W,Q){const{windows:J,windowSize:V}=Z6(Q,this.bits),G=[];let X=W,q=X;for(let Y=0;Y<J;Y++){q=X,G.push(q);for(let F=1;F<V;F++)q=q.add(X),G.push(q);X=q.double()}return G}wNAF(W,Q,J){if(!this.Fn.isValid(J))throw Error("invalid scalar");let V=this.ZERO,G=this.BASE;const X=Z6(W,this.bits);for(let q=0;q<X.windows;q++){const{nextN:Y,offset:F,isZero:U,isNeg:P,isNegF:H,offsetF:K}=w7(J,q,X);J=Y,U?G=G.add(O8(H,Q[K])):V=V.add(O8(P,Q[F]))}return N7(J),{p:V,f:G}}wNAFUnsafe(W,Q,J,V=this.ZERO){const G=Z6(W,this.bits);for(let X=0;X<G.windows&&J!==k1;X++){const{nextN:q,offset:Y,isZero:F,isNeg:U}=w7(J,X,G);if(J=q,!F){const P=Q[Y];V=V.add(U?P.negate():P)}}return N7(J),V}getPrecomputes(W,Q,J){let V=H6.get(Q);return V||(V=this.precomputeWindow(Q,W),W!==1&&(typeof J=="function"&&(V=J(V)),H6.set(Q,V))),V}cached(W,Q,J){const V=k6(W);return this.wNAF(V,this.getPrecomputes(V,W,J),Q)}unsafe(W,Q,J,V){const G=k6(W);return G===1?this._unsafeLadder(W,Q,V):this.wNAFUnsafe(G,this.getPrecomputes(G,W,J),Q,V)}createCache(W,Q){YW(Q,this.bits),qW.set(W,Q),H6.delete(W)}hasCache(W){return k6(W)!==1}}var v7=(W,Q)=>(W+(W>=0?Q:-Q)/PW)/Q,x0={Err:class extends Error{constructor(W=""){super(W)}},_tlv:{encode(W,Q){const{Err:J}=x0;if(W<0||W>256)throw new J("tlv.encode: wrong tag");if(1&Q.length)throw new J("tlv.encode: unpadded data");const V=Q.length/2,G=z8(V);if(G.length/2&128)throw new J("tlv.encode: long form length too big");const X=V>127?z8(G.length/2|128):"";return z8(W)+X+G+Q},decode(W,Q){const{Err:J}=x0;let V=0;if(W<0||W>256)throw new J("tlv.encode: wrong tag");if(Q.length<2||Q[V++]!==W)throw new J("tlv.decode: wrong tlv");const G=Q[V++];let X=0;if(128&G){const Y=127&G;if(!Y)throw new J("tlv.decode(long): indefinite length not supported");if(Y>4)throw new J("tlv.decode(long): byte length is too big");const F=Q.subarray(V,V+Y);if(F.length!==Y)throw new J("tlv.decode: length bytes not complete");if(F[0]===0)throw new J("tlv.decode(long): zero leftmost byte");for(let U of F)X=X<<8|U;if(V+=Y,X<128)throw new J("tlv.decode(long): not minimal encoding")}else X=G;const q=Q.subarray(V,V+X);if(q.length!==X)throw new J("tlv.decode: wrong value length");return{v:q,l:Q.subarray(V+X)}}},_int:{encode(W){const{Err:Q}=x0;if(W<w0)throw new Q("integer: negative integers are not allowed");let J=z8(W);if(8&Number.parseInt(J[0],16)&&(J="00"+J),1&J.length)throw new Q("unexpected DER parsing assertion: unpadded hex");return J},decode(W){const{Err:Q}=x0;if(128&W[0])throw new Q("invalid signature integer: negative");if(W[0]===0&&!(128&W[1]))throw new Q("invalid signature integer: unnecessary leading zero");return j1(W)}},toSig(W){const{Err:Q,_int:J,_tlv:V}=x0,G=e("signature",W),{v:X,l:q}=V.decode(48,G);if(q.length)throw new Q("invalid signature: left bytes after parsing");const{v:Y,l:F}=V.decode(2,X),{v:U,l:P}=V.decode(2,F);if(P.length)throw new Q("invalid signature: left bytes after parsing");return{r:J.decode(Y),s:J.decode(U)}},hexFromSig(W){const{_tlv:Q,_int:J}=x0,V=Q.encode(2,J.encode(W.r))+Q.encode(2,J.encode(W.s));return Q.encode(48,V)}},w0=BigInt(0),z1=BigInt(1),PW=BigInt(2),Z8=BigInt(3),UV=BigInt(4),$1={p:BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),n:BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),h:BigInt(1),a:BigInt(0),b:BigInt(7),Gx:BigInt("0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),Gy:BigInt("0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8")},ZV={beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),basises:[[BigInt("0x3086d221a7d46bcde86c90e49284eb15"),-BigInt("0xe4437ed6010e88286f547fa90abfe4c3")],[BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),BigInt("0x3086d221a7d46bcde86c90e49284eb15")]]},HV=BigInt(0),T7=BigInt(1),I6=BigInt(2),I8=r1($1.p,{sqrt(W){const Q=$1.p,J=BigInt(3),V=BigInt(6),G=BigInt(11),X=BigInt(22),q=BigInt(23),Y=BigInt(44),F=BigInt(88),U=W*W*W%Q,P=U*U*W%Q,H=Z0(P,J,Q)*P%Q,K=Z0(H,J,Q)*P%Q,z=Z0(K,I6,Q)*U%Q,C=Z0(z,G,Q)*z%Q,v=Z0(C,X,Q)*C%Q,E=Z0(v,Y,Q)*v%Q,f=Z0(E,F,Q)*E%Q,b=Z0(f,Y,Q)*v%Q,h=Z0(b,J,Q)*P%Q,T=Z0(h,q,Q)*C%Q,_=Z0(T,V,Q)*U%Q,d=Z0(_,I6,Q);if(!I8.eql(I8.sqr(d),W))throw Error("Cannot find square root");return d}}),zW=function(W,Q){const J=(V)=>zV({...W,hash:V});return{...J(Q),create:J}}({...$1,Fp:I8,lowS:!0,endo:ZV},M6),A7={},E6=(W)=>W.toBytes(!0).slice(1),C1=(()=>zW.Point)(),y6=(W)=>W%I6===HV,i1=j1,p6=(()=>{const W=(Q=R8(48))=>XW(Q,$1.n);return zW.utils.randomSecretKey,{keygen(Q){const J=W(Q);return{secretKey:J,publicKey:g7(J)}},getPublicKey:g7,sign:kV,verify:kW,Point:C1,utils:{randomSecretKey:W,randomPrivateKey:W,taggedHash:D8,lift_x:ZW,pointToBytes:E6,numberToBytesBE:N8,bytesToNumberBE:j1,mod:H0},lengths:{secretKey:32,publicKey:32,publicKeyHasPrefix:!1,signature:64,seed:48}}})(),$V=new TextEncoder,jV=new TextDecoder,s0=(W)=>$V.encode(W),c1=(W)=>jV.decode(W),x6=(W)=>Array.from(W,(Q)=>Q.toString(16).padStart(2,"0")).join(""),N0=JSON.stringify,x8=JSON.parse,$W=(W,Q=Number.MAX_SAFE_INTEGER)=>W.split("").reduce((J,V)=>J+V.charCodeAt(0),0)%Q,f6="AES-GCM",CV={},H8=(W)=>CV[W]??=crypto.subtle.digest("SHA-1",s0(W)).then((Q)=>{const J=new Uint8Array(Q);let V="";for(let G of J)V+=G.toString(36);return V}),BV=async(W,Q)=>{const J=crypto.getRandomValues(new Uint8Array(12)),V=await W,G=await crypto.subtle.encrypt({name:f6,iv:J},V,s0(Q));return`${J.join(",")}\$${((X)=>{const q=new Uint8Array(X);let Y="";for(let F=0;F<q.length;F+=32768)Y+=String.fromCharCode(...q.subarray(F,F+32768));return btoa(Y)})(G)}`},MV=async(W,Q)=>{const[J,V]=Q.split("$");if(!J||!V)throw Error("Invalid encrypted payload format");const G=Uint8Array.from(J.split(","),Number),X=await W,q=await crypto.subtle.decrypt({name:f6,iv:G},X,(Y=V,Uint8Array.from(atob(Y),(F)=>F.charCodeAt(0)).buffer));var Y;return c1(q)},K0="GenosRTC",b6=(W,Q)=>Array.from({length:W},Q),RV="0123456789AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz",w6=(W)=>Array.from(crypto.getRandomValues(new Uint8Array(W)),(Q)=>RV[Q%62]).join(""),K1=w6(20),Z1=Promise.all.bind(Promise),LV=typeof window!="undefined",{entries:OV,fromEntries:jW}=Object,IV=()=>{},D0=(W)=>Error(`${K0}: ${W}`),k8=(...W)=>W.join("@"),E7="icegatheringstatechange",y7="offer",DV=[...b6(3,(W,Q)=>`stun:stun${Q||""}.l.google.com:19302`),"stun:stun.cloudflare.com:3478"].map((W)=>({urls:W})),j6=(W,{rtcConfig:Q,rtcPolyfill:J,turnConfig:V})=>{const G=new(J||RTCPeerConnection)({iceServers:[...DV,...V||[]],...Q}),X={};let q,Y=!1,F=!1;const U=(K)=>Object.assign(K,{binaryType:"arraybuffer",bufferedAmountLowThreshold:65535,onmessage(z){return X.data?.(z.data)},onopen(){return X.connect?.()},onclose(){return X.close?.()},onerror(z){return!z?.error?.message?.includes("User-Initiated Abort")&&X.error?.(z)}}),P=()=>Promise.race([new Promise((K)=>{const z=()=>{G.iceGatheringState==="complete"&&(G.removeEventListener(E7,z),K())};G.addEventListener(E7,z),z()}),new Promise((K)=>setTimeout(K,5000))]).then(()=>({type:G.localDescription.type,sdp:G.localDescription.sdp.replace(/a=ice-options:trickle\s\n/g,"")}));W?U(q=G.createDataChannel("data")):G.ondatachannel=({channel:K})=>U(q=K),G.onnegotiationneeded=async()=>{try{Y=!0,await G.setLocalDescription(),X.signal?.(await P())}catch(K){X.error?.(K)}finally{Y=!1}},G.onconnectionstatechange=()=>{["disconnected","failed","closed"].includes(G.connectionState)&&X.close?.()},G.ontrack=(K)=>{X.track?.(K.track,K.streams[0]),X.stream?.(K.streams[0])},G.onremovestream=(K)=>X.stream?.(K.stream),W&&!G.canTrickleIceCandidates&&G.onnegotiationneeded();const H=()=>G.getSenders();return{created:Date.now(),connection:G,get channel(){return q},get isDead(){return G.connectionState==="closed"},async signal(K){if(q?.readyState!=="open"||K.sdp?.includes("a=rtpmap"))try{if(K.type===y7){if(Y||G.signalingState!=="stable"&&!F){if(W)return;await Z1([G.setLocalDescription({type:"rollback"}),G.setRemoteDescription(K)])}else await G.setRemoteDescription(K);await G.setLocalDescription();const z=await P();return X.signal?.(z),z}if(K.type==="answer"){F=!0;try{await G.setRemoteDescription(K)}finally{F=!1}}}catch(z){X.error?.(z)}},sendData(K){return q.send(K)},destroy(){q?.close(),G.close(),Y=F=!1},setHandlers(K){return Object.assign(X,K)},offerPromise:W?new Promise((K)=>X.signal=(z)=>z.type===y7&&K(z)):Promise.resolve(),addStream(K){return K.getTracks().forEach((z)=>G.addTrack(z,K))},removeStream(K){return H().filter((z)=>K.getTracks().includes(z.track)).forEach((z)=>G.removeTrack(z))},addTrack(K,z){return G.addTrack(K,z)},removeTrack(K){const z=H().find((C)=>C.track===K);z&&G.removeTrack(z)},replaceTrack(K,z){return H().find((C)=>C.track===K)?.replaceTrack(z)}}},xV=Object.getPrototypeOf(Uint8Array),_1=16369,$8=255,C6="bufferedamountlow",F1=(W)=>"@_"+W,wV=(W,Q,J)=>{const V=new Map,G=new Map,X=new Map,q={},Y={},F={},U={},P=new Map,H=($,...M)=>P.get($)?.forEach((w)=>w(...M)),K=($,M)=>{const w=$?Array.isArray($)?$:[$]:V.keys();return Array.from(w,(x)=>{const A=V.get(x);return A?M(x,A):(console.warn(`${K0}: no peer with id ${x}`),null)}).filter(Boolean)},z=($)=>{V.has($)&&(V.delete($),delete q[$],delete Y[$],delete F[$],delete U[$],H("peer:leave",$),Q($))},C=($)=>new Promise((M,w)=>{let x=setTimeout(()=>{$.removeEventListener(C6,A),w(Error(K0+": bufferLow timeout"))},5000);function A(){clearTimeout(x),$.removeEventListener(C6,A),M()}$.addEventListener(C6,A)}),v=($)=>{if(X.has($))return X.get($);if(!$)throw D0("action type is required");const M=s0($);if(M.byteLength>12)throw D0(`"${$}" exceeds 12 bytes`);const w=new Uint8Array(12).map((L,R)=>M[R]||0);let x=0;const A=new Map([["message",new Set],["progress",new Set]]),B=async(L,R,I,N)=>{if(I&&typeof I!="object")throw D0("meta must be object");if(L===void 0)throw D0("data cannot be undefined");const p=L instanceof Blob,y=p||L instanceof ArrayBuffer||L instanceof xV,u=typeof L!="string";if(I&&!y)throw D0("meta only allowed with binary");const m=y?new Uint8Array(p?await L.arrayBuffer():L):s0(u?N0(L):L),a=I?s0(N0(I)):null,o=Math.ceil(m.byteLength/_1)+(I?1:0)||1;if(o>100)throw D0("Message too large, exceeds max chunks 100");const W0=b6(o,(Q0,i)=>{const r=i===o-1,s=I&&i===0,S0=s?a:m.subarray(I?(i-1)*_1:i*_1,I?i*_1:(i+1)*_1),k0=new Uint8Array(15+S0.byteLength);return k0.set(w),k0.set([x],12),k0.set([r|s<<1|y<<2|u<<3],13),k0.set([Math.round((i+1)/o*$8)],14),k0.set(S0,15),k0});return x=x+1&$8,Z1(K(R,async(Q0,i)=>{const{channel:r}=i;for(let s=0;s<o;s++){let S0=0;for(;r.bufferedAmount>r.bufferedAmountLowThreshold;){if(S0++>3)throw D0(`${K0}: send buffer full, max retries reached for peer ${Q0}`);try{await C(r)}catch(k0){console.warn(k0.message),await new Promise((SW)=>setTimeout(SW,200))}}if(!V.has(Q0))break;i.sendData(W0[s]),N?.(W0[s][14]/$8,Q0,I)}}))};G.set($,{listeners:A,send:B});const j={send:B,on(L,R){return A.get(L)?.add(R)},off(L,R){return A.get(L)?.delete(R)}};return X.set($,j),j},E=async()=>{try{await k(""),await new Promise(($)=>setTimeout($,99))}catch($){console.warn(K0+": error sending leave",$)}for(let[$,M]of V){try{M.destroy()}catch{}V.delete($)}J()},{send:f,on:b}=v(F1("ping")),{send:h,on:T}=v(F1("pong")),{send:_,on:d}=v(F1("signal")),{send:S,on:D}=v(F1("stream")),{send:g,on:Z}=v(F1("track")),{send:k,on:O}=v(F1("leave"));return W(($,M)=>{V.has(M)||(V.set(M,$),$.setHandlers({data(w){return((x,A)=>{try{const B=new Uint8Array(A),j=c1(B.subarray(0,12)).replace(/\0/g,"");if(!G.has(j))return console.warn(`${K0}: unregistered type (${j})`);const[L]=B.subarray(12,13),[R]=B.subarray(13,14),[I]=B.subarray(14,15),N=B.subarray(15),p=!!(1&R),y=!!(2&R),u=!!(4&R),m=!!(8&R),a=G.get(j),o=(q[x]||={})[j]||={};if(o[L]?.chunks?.length>100)return void console.warn(`${K0}: peer ${x} sent too many chunks for nonce ${L}, ignoring.`);const W0=o[L]||={chunks:[]};if(y)try{W0.meta=x8(c1(N))}catch{return void console.warn(`${K0}: failed to parse meta from peer ${x} for type ${j}`)}else W0.chunks.push(N);if(a.listeners.get("progress").forEach((r)=>{try{r(I/$8,x,W0.meta)}catch(s){console.error(s)}}),!p)return;const Q0=new Uint8Array(W0.chunks.reduce((r,s)=>r+s.byteLength,0));let i;if(W0.chunks.reduce((r,s)=>(Q0.set(s,r),r+s.byteLength),0),delete o[L],u)i=Q0;else if(m)try{i=x8(c1(Q0))}catch{return void console.warn(`${K0}: failed to parse JSON message data from peer ${x} for type ${j}`)}else i=c1(Q0);a.listeners.get("message").forEach((r)=>{try{r(i,x,W0.meta)}catch(s){console.error(s)}})}catch(B){console.error(`${K0}: error handling data from peer ${x}:`,B)}})(M,w)},stream(w){H("stream:add",w,M,F[M]),delete F[M]},track(w,x){H("track:add",w,x,M,U[M]),delete U[M]},signal(w){return _(w,M)},close(){return z(M)},error(w){console.error(`${K0}: peer error for ${M}`,w),z(M)}}),H("peer:join",M))}),b("message",($,M)=>h("",M)),T("message",($,M)=>{Y[M]?.(),delete Y[M]}),d("message",($,M)=>V.get(M)?.signal($)),D("message",($,M)=>F[M]=$),Z("message",($,M)=>U[M]=$),O("message",($,M)=>z(M)),LV&&addEventListener("beforeunload",E),{on($,M){P.has($)||P.set($,new Set),P.get($).add(M)},off($,M){return P.get($)?.delete(M)},channel:v,leave:E,async ping($){if(!$)throw D0("ping() requires target peer ID");const M=Date.now();return f("",$),await new Promise((w)=>Y[$]=w),Date.now()-M},getPeers(){return jW(Array.from(V,([$,M])=>[$,M.connection]))},addStream($,M,w){return K(M,async(x,A)=>{w&&await S(w,x),A.addStream($)})},removeStream($,M){return K(M,(w,x)=>x.removeStream($))},addTrack($,M,w,x){return K(w,async(A,B)=>{x&&await g(x,A),B.addTrack($,M)})},removeTrack($,M){return K(M,(w,x)=>x.removeTrack($))},replaceTrack($,M,w,x){return K(w,async(A,B)=>{x&&await g(x,A),B.replaceTrack($,M)})}}},j8={},CW={};if(typeof window!="undefined"){const W=()=>{console.info("\u26A1 [GenosRTC] Network event detected. Forcing reconnection\u2026"),Object.values(CW).forEach((Q)=>{Q.socket&&Q.socket.readyState!==WebSocket.OPEN&&Q.socket.readyState!==WebSocket.CONNECTING&&Q.forceReconnect()})};window.addEventListener("online",()=>{console.info("\u2705 Reconnected to the network."),W()}),window.addEventListener("offline",async()=>{console.info("\u274C Disconnected from the network.")}),document.addEventListener("visibilitychange",()=>{document.visibilityState==="visible"&&W()})}var NV=(W,Q,J,V)=>(W.relayUrls??(V?((G,X)=>{const q=[...G];let Y=q.length;const F=()=>{const U=1e4*Math.sin(X++);return U-Math.floor(U)};for(;Y;){const U=Math.floor(F()*Y--);[q[Y],q[U]]=[q[U],q[Y]]}return q})(Q,$W(W.appId)):Q)).slice(0,W.relayUrls?.length??W.relayRedundancy??J),BW={},MW="EVENT",RW=p6.utils.randomSecretKey(),SV=x6(p6.getPublicKey(RW)),h6={},d1={},vV={},LW=()=>Math.floor(Date.now()/1000),OW=(W)=>vV[W]??=$W(W,1e4)+20000,p7=async(W,Q)=>{const J={kind:OW(W),content:Q,pubkey:SV,created_at:LW(),tags:[["x",W]]},V=new Uint8Array(await crypto.subtle.digest("SHA-256",s0(N0([0,J.pubkey,J.created_at,J.kind,J.tags,J.content])))),G=p6.sign(V,RW);return N0([MW,{...J,id:x6(V),sig:x6(G)}])},f7=(W,Q)=>(h6[W]=Q,N0(["REQ",W,{kinds:[OW(Q)],since:LW(),"#x":[Q]}])),b7=(W)=>(delete h6[W],N0(["CLOSE",W])),u6=(({init:W,subscribe:Q,announce:J})=>{const V={};let G,X,q=!1;return(Y,F,U)=>{const{appId:P}=Y;if(V[P]?.[F])return V[P][F];if(!Y||!F||!P&&!Y.firebaseApp)throw D0(Y?F?"appId missing":"roomId required":"config required");let H=IV;if(!q){const Z=W(Y);X=b6(20,()=>j6(!0,Y)),G=Array.isArray(Z)?Z:[Z];const k=setInterval(()=>{X=X.filter((O)=>{const $=Date.now()-O.created<57333;return $||O.destroy(),$})},57333);V.offerCleanupTimer||=k,q=!0}const K={},z={},C=k8(K0,P,F),v=H8(C),E=H8(k8(C,K1)),f=(async(Z,k,O)=>{const $=await crypto.subtle.digest("SHA-256",s0(`${Z}:${k}:${O}`));return crypto.subtle.importKey("raw",$,{name:f6},!1,["encrypt","decrypt"])})(Y.password||"",P,F),b=(Z)=>async(k)=>({type:k.type,sdp:await Z(f,k.sdp)}),h=b(MV),T=b(BV),_=(Z,k)=>{z[k]!==Z&&(z[k]?.destroy(),z[k]=Z,H(Z,k),K[k]?.forEach((O)=>O!==Z&&O.destroy()),delete K[k])},d=(Z,k)=>{z[k]===Z&&delete z[k]},S=Z1(G.map(async(Z,k)=>{return Q(await Z,await v,await E,(O=k,async($,M,w)=>{const[x,A]=await Z1([v,E]);if($!==x&&$!==A)return;const{peerId:B,offer:j,answer:L}=typeof M=="string"?x8(M):M;if(B!==K1&&!z[B])if(j){if(K[B]?.[O]&&K1>B)return;const R=j6(!1,Y);R.setHandlers({connect(){return _(R,B)},close(){return d(R,B)}});try{const I=await h(j);if(R.isDead)return;const[N,p]=await Z1([H8(k8(C,B)),R.signal(I).then(T)]);w(N,N0({peerId:K1,answer:p}))}catch{U?.({error:"decryption failed (offer)",appId:P,peerId:B,roomId:F})}}else if(L){const R=K[B]?.[O];if(!R||R.isDead)return;R.setHandlers({connect(){return _(R,B)},close(){return d(R,B)}});try{R.signal(await h(L))}catch{U?.({error:"decryption failed (answer)",appId:P,peerId:B,roomId:F})}}else{if(K[B]?.[O])return;const R=X.pop()||j6(!0,Y),[I,{offer:N}]=await Z1([H8(k8(C,B)),R.offerPromise.then(T).then((p)=>({offer:p}))]);K[B]||=[],K[B][O]=R,R.setHandlers({connect(){return _(R,B)},close(){return d(R,B)}}),w(I,N0({peerId:K1,offer:N,peer:R}))}}));var O})),D=[];S.then((Z)=>{G.forEach((k,O)=>{const $=async()=>{const M=await J(await k,await v,await E);D[O]=setTimeout($,typeof M=="number"?M:5333)};$()}),V[P][F].onCleanup=()=>{delete V[P][F],D.forEach(clearTimeout),Z.forEach((k)=>k()),Object.keys(V).length===0&&(clearInterval(V.offerCleanupTimer),delete V.offerCleanupTimer)}}),V[P]||={};const g=wV((Z)=>H=Z,(Z)=>delete z[Z],()=>g.onCleanup?.());return V[P][F]=g}})({init(W){return NV(W,TV,5,!0).map((Q)=>{const J=((V,G)=>{const X={};let q=null;const Y=()=>{q&&(clearTimeout(q),q=null);const F=new WebSocket(V);F.onclose=()=>{j8[V]??=3333,q=setTimeout(Y,j8[V]),j8[V]*=2},F.onmessage=(U)=>G(U.data),X.socket=F,X.url=F.url,X.ready=new Promise((U)=>{F.onopen=()=>{j8[V]=3333,U(X)}}),X.send=(U)=>{F.readyState===1&&F.send(U)}};return X.forceReconnect=Y,Y(),CW[V]=X,X})(Q,(V)=>{const[G,X,q,Y]=x8(V);if(G===MW)d1[X]?.(h6[X],q.content);else{const F=`${K0}: relay failure from ${J.url} - `;G==="NOTICE"?console.warn(F+X):G!=="OK"||q||console.warn(F+Y)}});return BW[Q]=J,J.ready})},subscribe(W,Q,J,V){const G=w6(64),X=w6(64);return d1[G]=d1[X]=(q,Y)=>V(q,Y,async(F,U)=>W.send(await p7(F,U))),W.send(f7(G,Q)),W.send(f7(X,J)),()=>{W.send(b7(G)),W.send(b7(X)),delete d1[G],delete d1[X]}},async announce(W,Q){return W.send(await p7(Q,N0({peerId:K1})))}}),CG=(h7=BW,()=>jW(OV(h7).map(([W,Q])=>[W,Q.socket]))),h7,TV=["black.nostrcity.club","eu.purplerelay.com","ftp.halifax.rwth-aachen.de/nostr","nostr.cool110.xyz","nostr.data.haus","nostr.mom","nostr.oxtr.dev","nostr.sathoarder.com","nostr.vulpem.com","playground.nostrcheck.me/relay","relay.agorist.space","relay.binaryrobot.com","relay.fountain.fm","relay.mostro.network","relay.nostraddress.com","relay.nostrdice.com","relay.nostromo.social","relay.oldenburg.cool","relay.snort.social","relay.verified-nostr.com","sendit.nosflare.com","yabu.me/v2","relay.damus.io"].map((W)=>"wss://"+W);function IW(W,Q,J){let V=Q.timestamp;if(V?.physical>Date.now()+7200000)V={physical:Date.now()+7200000,logical:V.logical};if(!W?.timestamp)return{resolved:!0,value:Q.value,timestamp:V};if(J.compare(V,W.timestamp)<=0)return{resolved:!1};return{resolved:!0,value:Q.value,timestamp:V}}function DW(W,Q=50){const J=`gdb_oplog_${W}`;let V=[];function G(){try{const q=localStorage.getItem(J);V=q?JSON.parse(q):[]}catch(q){console.error("Failed to load oplog from localStorage:",q),V=[]}}function X(){try{localStorage.setItem(J,JSON.stringify(V))}catch(q){console.error("Failed to save oplog to localStorage:",q)}}return G(),{add(q){if(V.push(q),V.length>Q)V.shift();X()},getDelta(q,Y){if(!q)return[...V];return V.filter((F)=>Y(F.timestamp,q)>0)},getOldest(){return V[0]},clear(){V=[],localStorage.removeItem(J)}}}var AV=()=>{const W=new Map,Q=async()=>{try{const F=await navigator.storage.getDirectory(),P=await(await F.getFileHandle("~opfs-sync-test",{create:!0})).createSyncAccessHandle?.();return await P?.close(),await F.removeEntry("~opfs-sync-test"),!!P}catch{return!1}};let J="idb";const V=(async()=>{if(await Q())J="sync";else try{const F=await navigator.storage.getDirectory(),P=await(await F.getFileHandle("~opfs-async-test",{create:!0})).createWritable?.();if(await P?.close(),await F.removeEntry("~opfs-async-test"),P)J="async";else J="idb"}catch{J="idb"}})(),G=async(F,U)=>{if(!W.has(F))W.set(F,[]);const P=W.get(F),H=P[P.length-1]||Promise.resolve();let K;const z=new Promise((C)=>K=C);P.push(z);try{return await H,await U()}finally{if(P.shift(),K(),P.length===0)W.delete(F)}},X=(()=>{let F;const U=async()=>{if(!F)F=new Promise((P,H)=>{const K=indexedDB.open("opfs-fallback-db",1);K.onupgradeneeded=()=>K.result.createObjectStore("files"),K.onsuccess=()=>P(K.result),K.onerror=()=>H(K.error)});return F};return{getDB:U,get:async(P)=>{const H=await U();return new Promise((K,z)=>{const v=H.transaction("files","readonly").objectStore("files").get(P);v.onsuccess=()=>K(v.result||new Uint8Array),v.onerror=()=>z(v.error)})},set:async(P,H)=>{const K=await U();return new Promise((z,C)=>{const E=K.transaction("files","readwrite").objectStore("files").put(H,P);E.onsuccess=()=>z(),E.onerror=()=>C(E.error)})}}})(),q=async(F)=>{await V;try{if(J==="idb"){const z=await X.get(F);return{type:"loaded",name:F,data:z}}const P=await(await navigator.storage.getDirectory()).getFileHandle(F);if(J==="sync"){let z;try{z=await P.createSyncAccessHandle();const C=z.getSize(),v=new Uint8Array(C),E=z.read(v,{at:0});return{type:"loaded",name:F,data:v.slice(0,E)}}finally{z?.close()}}const H=await P.getFile(),K=new Uint8Array(await H.arrayBuffer());return{type:"loaded",name:F,data:K}}catch(U){const P=U.name==="NotFoundError"?"File not found":U.message||"Error reading file";return{type:"error",name:F,message:P}}},Y=async(F,U)=>{if(await V,!(U instanceof Uint8Array))return{type:"error",name:F,message:"Content must be a Uint8Array"};return G(F,async()=>{try{if(J==="idb")return await X.set(F,U),{type:"saved",name:F};const H=await(await navigator.storage.getDirectory()).getFileHandle(F,{create:!0});if(J==="sync"){let K;try{K=await H.createSyncAccessHandle(),K.truncate(0),K.write(U,{at:0}),K.flush()}finally{K?.close()}}else{let K;try{K=await H.createWritable(),await K.write(U)}finally{await K?.close()}}return{type:"saved",name:F}}catch(P){return{type:"error",name:F,message:P.message||"Error saving file"}}})};self.onmessage=async({data:F})=>{const{type:U,name:P,content:H}=F;await V;const K={load:()=>q(P),save:()=>Y(P,H)};try{const z=K[U],C=z?await z():{type:"error",message:`Unrecognized action type: ${U}`};self.postMessage(C)}catch(z){console.error("Worker unexpected error:",z),self.postMessage({type:"error",name:P,message:z.message||"Unexpected worker error"})}}},xW=AV;var B1={$eq:(W,Q)=>W===Q,$ne:(W,Q)=>W!==Q,$gt:(W,Q)=>W>Q,$gte:(W,Q)=>W>=Q,$lt:(W,Q)=>W<Q,$lte:(W,Q)=>W<=Q,$in:(W,Q)=>Array.isArray(Q)&&(Array.isArray(W)?W.some((J)=>Q.includes(J)):Q.includes(W)),$between:(W,[Q,J])=>W>=Q&&W<=J,$exists:(W,Q)=>Q?W!==void 0:W===void 0,$text:{global:(W,Q)=>{const J=(G)=>String(G).normalize("NFD").replace(/[\u0300-\u036f]/g,"").toLowerCase().replace(/[^\w\s]/g,""),V=J(Q);return Object.values(W).some((G)=>typeof G==="object"?null.fieldSearch(G,V):J(G).includes(V))},field:(W,Q)=>{const J=(G)=>String(G).normalize("NFD").replace(/[\u0300-\u036f]/g,"").toLowerCase().replace(/[^\w\s]/g,""),V=J(Q);return Array.isArray(W)?W.some((G)=>J(G).includes(V)):J(W).includes(V)}},$like:(W,Q)=>typeof W==="string"&&typeof Q==="string"&&new RegExp(`^${Q.replace(/%/g,".*").replace(/_/g,".")}\$`,"i").test(W),$regex:(W,Q)=>typeof W==="string"&&new RegExp(Q.$regex||Q,"i").test(W),$and:(W,Q,J)=>Q.every((V)=>J.createFilter(V,J.allNodes)(W)),$or:(W,Q,J)=>Q.some((V)=>J.createFilter(V,J.allNodes)(W)),$not:(W,Q,J)=>!J.createFilter(Q,J.allNodes)(W),$edge:(W,Q,J)=>{if(!W.edges?.length||typeof Q!=="object"||Q===null)return!1;const V=J.createFilter(Q,J.allNodes),G=[...W.edges],X=new Set(G).add(W.id),q=[];while(G.length){const Y=G.shift(),F=J.allNodes[Y];if(!F)continue;if(V(F))q.push(F);F.edges?.forEach((U)=>!X.has(U)&&X.add(U)&&G.push(U))}if(q.length)W._edgeResult=q;return q.length>0}},m6=(W,Q)=>Q.split(".").reduce((J,V)=>J&&typeof J==="object"&&(V in J)?J[V]:void 0,W),S8=(W,Q)=>{if(Object.keys(W).length===0)return()=>!0;return(J)=>Object.entries(W).every(([V,G])=>{if(V.startsWith("$"))return B1[V](J,G,{createFilter:S8,allNodes:Q});const X=m6(J.value,V);if(typeof G!=="object"||G===null)return B1.$eq(X,G);return Object.entries(G).every(([q,Y])=>{if(q==="$text")return B1.$text.field(X,Y);if(q==="$between"&&Y.every((F)=>F instanceof Date))return B1.$between(new Date(X),Y);return B1[q]?.(X,Y,{createFilter:S8,allNodes:Q})??!1})})},_6=(W,Q)=>{const{$edge:J,...V}=Q.query||{},G=S8(V,W),X=Object.values(W).filter(G);let Y=[...J?(()=>{const F=S8({$edge:J},W);X.forEach((P)=>F(P));const U=new Map;return X.forEach((P)=>{if(P._edgeResult)P._edgeResult.forEach((H)=>U.set(H.id,H)),delete P._edgeResult}),Array.from(U.values())})():X];if(Y=Y.map((F)=>({...F,edges:[...F.edges||[]],value:F.value&&typeof F.value==="object"?JSON.parse(JSON.stringify(F.value)):F.value})),Q.field){const F=Q.order==="asc"?1:-1;Y.sort((U,P)=>{const H=m6(U.value,Q.field),K=m6(P.value,Q.field);if(typeof H==="string"&&typeof K==="string")return H.localeCompare(K)*F;return((H??0)-(K??0))*F})}if(Q.$after){const F=Y.findIndex((U)=>U.id===Q.$after);Y=F>=0?Y.slice(F+1):[]}if(Q.$before){const F=Y.findIndex((U)=>U.id===Q.$before);Y=F>=0?Y.slice(0,F):[]}if(Q.$limit)Y=Y.slice(0,Q.$limit);return Y};function wW(){let W=Date.now(),Q=0;return{now(){const J=Date.now();return W=Math.max(W,J),Q++,{physical:W,logical:Q}},update(J){if(!J||typeof J.physical!=="number"||typeof J.logical!=="number"){console.warn("HybridClock.update received an invalid remote timestamp.",J);return}W=Math.max(W,J.physical),Q=Math.max(Q,J.logical)+1},compare(J,V){if(!J&&!V)return 0;if(!J)return-1;if(!V)return 1;if(J.physical>V.physical)return 1;if(J.physical<V.physical)return-1;if(J.logical>V.logical)return 1;if(J.logical<V.logical)return-1;return 0}}}var d6=function(W,Q){return W.length===Q.length&&W.every((J,V)=>J===Q[V])};async function gV(){if(console.info(navigator?.storage?.getDirectory?"\u2705 OPFS is enabled.":"\uD83D\uDEAB OPFS is not available."),navigator?.storage?.getDirectory)await navigator.storage.getDirectory()}var EV=function(){const W={nodes:{}};return{get nodes(){return W.nodes},set nodes(J){W.nodes=J||{}},upsert(J,V,G){const X=W.nodes[J];W.nodes[J]={id:J,value:V&&typeof V==="object"?JSON.parse(JSON.stringify(V)):V,edges:X?.edges?[...X.edges]:[],timestamp:G}},get(J){return W.nodes[J]||null},link(J,V,G){const X=W.nodes[J],q=W.nodes[V];if(X&&q&&!X.edges.includes(V))W.nodes[J]={...X,edges:[...X.edges,V],timestamp:G}},getAllNodes(){return Object.values(W.nodes)},serialize(){return m1.deflate(v0(W.nodes))},deserialize(J){W.nodes=t1(m1.inflate(new Uint8Array(J)))}}};async function NW(W,Q={}){const{password:J,sm:V=!1,ii:G=!1,rx:X=!1,ai:q=!1,geo:Y=!1,relayUrls:F=null,turnConfig:U=null}=Q,P=EV(),H=wW(),K=DW(W,20);let z=null,C=[],v=null,E=null,f=null,b=null;const h={};Object.defineProperties(h,{hybridClock:{get:()=>H},graph:{get:()=>P},syncChannel:{get:()=>E},ready:{get:()=>Promise.resolve(!0)}});async function T(j){const L=new URL(`./${j}.min.js`,import.meta.url).href,R=`https://cdn.jsdelivr.net/npm/genosdb@latest/dist/${j}.min.js`;try{const I=await import(L).catch(()=>{return console.warn(`\u26A0\uFE0F ${j} not found locally, loading from CDN...`),import(R)}),N=typeof I.init==="function"?I.init(h,I):null;if(N)Object.assign(h,N);return I}catch(I){throw console.error(`\u274C Initialization of ${j} failed:`,I),I}}function _(){const j=localStorage.getItem(`${W}_time`);z=j?JSON.parse(j):null}function d(j){z=j,localStorage.setItem(`${W}_time`,JSON.stringify(j))}function S(){try{const j=URL.createObjectURL(new Blob([`(${xW.toString()})()`],{type:"application/javascript"}));v=new Worker(j),URL.revokeObjectURL(j),v.addEventListener("message",({data:L})=>{console.info(`\uD83D\uDCBE ${L.name} ${L.type}`)}),console.info("\u2699\uFE0F Worker initialized successfully.")}catch({message:j}){console.error("\u274C Failed to initialize worker:",j)}}function D(){const j={...P.nodes};C.forEach((L)=>L(j))}async function g(){return crypto.randomUUID()}async function Z(j){const L=(new TextEncoder()).encode(j),R=await crypto.subtle.digest("SHA-256",L);return Array.from(new Uint8Array(R)).map((I)=>I.toString(16).padStart(2,"0")).join("")}async function k(){try{const L=await((R)=>new Promise((I,N)=>{const p=async({data:y})=>{if(y.type==="loaded"&&y.name===R)v.removeEventListener("message",p),I(new Uint8Array(y.data));else if(y.type==="error")v.removeEventListener("message",p),N(new Error(y.message||"Unknown error"))};v.addEventListener("message",p),v.postMessage({type:"load",name:R})}))(`${W}_graph.msgpack`).catch(()=>new Uint8Array);L.byteLength>0?P.deserialize(L):console.warn("\u26A0\uFE0F The file '_graph.msgpack' is empty or could not be loaded."),console.info(`\u2705 Graph loaded: [ ${P.getAllNodes().length} nodes ]`)}catch({message:j}){console.error("\u274C Error loading the graph:",j)}}async function O(){try{const j=P.serialize();return await((R,I)=>new Promise((N,p)=>{const y=({data:u})=>{if(u.type==="saved"&&u.name===R)v.removeEventListener("message",y),N();else if(u.type==="error")v.removeEventListener("message",y),p(new Error(u.message||"Save error"))};v.addEventListener("message",y),v.postMessage({type:"save",name:R,content:I})}))(`${W}_graph.msgpack`,j),f.postMessage("update"),!0}catch({message:j}){throw console.error("\u274C Save error:",j),new Error("Save failed")}}async function $(j){try{console.info("\uD83D\uDD04 Applying full graph from remote..."),P.nodes={...j.nodes},await O()}catch({message:L}){console.error(`\u274C Error applying the full graph: ${L}`)}}async function M(j){let L=!1,R=null;const I={upsert:(N)=>{const p=P.get(N.id),y=IW(p,N,H);if(y.resolved){if(P.upsert(N.id,y.value,y.timestamp),H.update(y.timestamp),K.add({type:"upsert",id:N.id,timestamp:y.timestamp}),L=!0,!R||H.compare(y.timestamp,R)>0)R=y.timestamp}},remove:(N)=>{const p=P.get(N.id);if(p&&H.compare(p.timestamp,N.timestamp)<0){if(delete P.nodes[N.id],H.update(N.timestamp),K.add({type:"remove",id:N.id,timestamp:N.timestamp}),L=!0,!R||H.compare(N.timestamp,R)>0)R=N.timestamp}},link:(N)=>{const p=P.get(N.sourceId),y=P.get(N.targetId);if(p&&y&&H.compare(p.timestamp,N.timestamp)<0){if(P.link(N.sourceId,N.targetId,N.timestamp),H.update(N.timestamp),K.add({type:"link",sourceId:N.sourceId,targetId:N.targetId,timestamp:N.timestamp}),L=!0,!R||H.compare(N.timestamp,R)>0)R=N.timestamp}},sync:async(N)=>{const p=N.timestamp;if(p===null){console.info("\uD83D\uDCEC [SYNC REQUEST] from new peer (no timestamp). Sending full graph."),await E.send([{type:"syncReceive",graph:P}]);return}console.info("\uD83D\uDCEC [SYNC REQUEST] since:",new Date(p.physical).toLocaleString());const y=K.getOldest();if(y&&H.compare(p,y.timestamp)<0){console.info("\uD83D\uDCA5 [FALLBACK TRIGGERED] Peer is too far behind. Sending FULL graph state."),await E.send([{type:"syncReceive",graph:P}]);return}const u=K.getDelta(p,H.compare);if(u.length>0){const m=u.map((o)=>{if(o.type==="upsert"){const W0=P.get(o.id);return{...o,value:W0?W0.value:null}}return o}),a=m1.deflate(v0(m));console.info(`\uD83D\uDE80 [DELTA SYNC SENDING] Found ${u.length} new operations to send.`),await E.send([{type:"deltaSync",operations:a}])}else console.info("\u2705 [ALREADY SYNCED] Peer is up-to-date. Nothing to send.")},deltaSync:(N)=>{console.info("\uD83D\uDEF0\uFE0F [DELTA SYNC RECEIVED] Applying delta from a peer.");let p=t1(m1.inflate(N.operations));for(let y of p)I[y.type]?.(y)},syncReceive:async(N)=>{if(console.info("\uD83D\uDCE6 [FULL SYNC RECEIVED] Overwriting local state with full graph from a peer."),N.graph&&N.graph.nodes){await $(N.graph),K.clear(),console.info("\uD83D\uDD12 Oplog has been cleared due to full sync."),L=!0;let p=null;for(let y in N.graph.nodes){const u=N.graph.nodes[y];if(u.timestamp&&(!p||H.compare(u.timestamp,p)>0))p=u.timestamp}if(p)console.info("\uD83D\uDCC8 [GLOBAL TIMESTAMP] Updated from full sync."),R=p,H.update(p)}else console.error("\u274C Full sync failed: received graph data is invalid.",N.graph)}};for(let N of j)if(I[N.type])await I[N.type](N);else console.warn(`\uD83E\uDD37\u200D\u2640\uFE0F [UNKNOWN MESSAGE TYPE] Received unhandled message type: "${N.type}"`);if(R){if(!z||H.compare(R,z)>0)console.info(`\uD83D\uDCC8 [GLOBAL TIMESTAMP] Advanced from ${z?.logical} to ${R.logical}.`),d(R)}if(L)console.info("\uD83D\uDCBE [STATE CHANGED] Saving state and emitting update."),await O(),D()}Object.assign(h,{async put(j,L){const R=H.now();d(R),L??=await g(),P.upsert(L,j,R),K.add({type:"upsert",id:L,timestamp:R}),await O();try{await E.send([{type:"upsert",id:L,value:j,timestamp:R}])}catch(I){console.warn("\u26A0\uFE0F P2P send (upsert) failed or delayed:",I?.message||I)}finally{D()}return L},async get(j,L=null){if(typeof j!=="string")return{result:null};const R=P.get(j);if(!R){if(L)L(null);return{result:null}}const I=(y)=>{if(!y)return null;const u=y.value!==null&&typeof y.value==="object"?{...y.value}:y.value;return{...y,value:u}};if(!L)return{result:I(R)};let N=R.timestamp;L(I(R));const p=(y)=>{const u=y[j];if(u){if(H.compare(u.timestamp,N)>0)N=u.timestamp,L(I(u))}else L(null),C.splice(C.indexOf(p),1)};return C.push(p),{result:I(R),unsubscribe:()=>{const y=C.indexOf(p);if(y>-1)C.splice(y,1)}}},async map(...j){let R={...{realtime:!1,query:{},field:null,order:"asc",$limit:null,$after:null,$before:null}},I=null,N=!1;j.forEach((m)=>typeof m==="function"?I=m:m&&typeof m==="object"&&(N||=("realtime"in m),Object.assign(R,m))),I&&!N&&(R.realtime=!0);let p=_6(P.nodes,R),y=null;const u=(m)=>{const a=m.filter((i)=>!p.some((r)=>r.id===i.id)),o=p.filter((i)=>!m.some((r)=>r.id===i.id)),W0=m.filter((i)=>{const r=p.find((k0)=>k0.id===i.id),s=[...i.edges||[]],S0=[...r?.edges||[]];return r&&(!d6(v0(i.value),v0(r.value))||!d6(s,S0))}),Q0=(i,r)=>{const s=r==="removed"?null:i.value,S0={id:i.id,value:s,edges:i.edges||[],timestamp:i.timestamp||null,action:r};I(S0)};a.forEach((i)=>Q0(i,"added")),o.forEach((i)=>Q0(i,"removed")),W0.forEach((i)=>Q0(i,"updated"))};if(I){if(p.forEach((m)=>{I({id:m.id,value:m.value,edges:m.edges,timestamp:m.timestamp,action:"initial"})}),R.realtime)y=(m)=>{const a=_6(m,R);if(a.length!==p.length)u(a),p=a;else if(!d6(v0(a),v0(p)))u(a),p=a},C.push(y)}return{results:p,...R.realtime&&I&&y&&{unsubscribe:()=>{const m=C.indexOf(y);m>-1&&C.splice(m,1)}}}},async remove(j){const L=H.now(),R=P.get(j);if(!R)return console.warn(`\u26A0\uFE0F Node with ID '${j}' not found.`);delete P.nodes[j],K.add({type:"remove",id:j,timestamp:L}),Object.values(P.nodes).forEach((I)=>I.edges=I.edges.filter((N)=>N!==j)),await O(),d(L);try{await E.send([{type:"remove",id:j,value:R.value,timestamp:L}])}catch(I){console.warn("\u26A0\uFE0F P2P send (remove) failed or delayed:",I?.message||I)}finally{D()}},async link(j,L){const R=H.now();if(!P.nodes[j]||!P.nodes[L]){console.warn(`\u26A0\uFE0F One or both nodes (${j}, ${L}) do not exist.`);return}P.link(j,L,R),K.add({type:"link",sourceId:j,targetId:L,timestamp:R}),await O(),d(R);try{await E.send([{type:"link",sourceId:j,targetId:L,timestamp:R}])}catch(I){console.warn("\u26A0\uFE0F P2P send (link) failed or delayed:",I?.message||I)}finally{D()}},async clear(){P.nodes={};try{await(await navigator.storage.getDirectory()).removeEntry(`${W}_graph.msgpack`)}catch({message:j}){console.warn(`\u26A0\uFE0F Error deleting _graph.msgpack: ${j}`)}D(),console.info("\u2705 All data has been deleted.")},async getAllNodes(){return P.getAllNodes()},getWorker(){return v}}),S(),_(),await gV(),await k();const w=[];if(V)w.push(T("sm"));if(q)w.push(T("AIQuery"));if(X)w.push(T("radixindex"));if(G)w.push(T("radixindex"));if(Y)w.push(T("geo"));await Promise.all(w);const x=`graph-sync-room-${W}`,A={appId:"1234",...J&&{password:J}};if(F)A.relayUrls=F;if(U)A.turnConfig=U;const B=u6(A,x);return E=B.channel("syncGraph"),b=u6(A,`app-sync-${W}`),h.room=b,B.on("peer:join",async(j)=>{console.info("\u26A1 New peer connected:",j),E.send([{type:"sync",timestamp:z}])}),B.on("peer:leave",(j)=>{console.info("\u26A1 Peer disconnected:",j)}),E.on("message",async(j)=>{if(V&&typeof V.verifyIncomingOperations==="function"){const{validatedOperations:L}=await V.verifyIncomingOperations(j);if(L&&L.length>0)await M(L)}else await M(j)}),f=new BroadcastChannel(`graphdb_sync_${W}`),f.onmessage=async(j)=>{if(j.data==="update")console.info("\uD83D\uDD04 Update received from another tab..."),await k(),_(),D()},console.info(`\u2705 GenosDB [ ${W} ] instance is ready.`),h}var pG=NW;class yV{constructor(){throw new Error("\u26A0\uFE0F WARNING: `new GDB()` is deprecated and will be removed. "+"Migrate to async factory function `const db = await gdb(...)`.\nMigration Guide: https://github.com/estebanrfp/gdb/wiki/Migration-Guide\nWiki: https://github.com/estebanrfp/gdb/wiki")}}export{pG as gdb,yV as GDB};
