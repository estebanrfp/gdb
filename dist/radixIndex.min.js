function _1(J){const W=J.length;let Q=0,V=0;while(V<W){let q=J.charCodeAt(V++);if((q&4294967168)===0){Q++;continue}else if((q&4294965248)===0)Q+=2;else{if(q>=55296&&q<=56319){if(V<W){const G=J.charCodeAt(V);if((G&64512)===56320)++V,q=((q&1023)<<10)+(G&1023)+65536}}if((q&4294901760)===0)Q+=3;else Q+=4}}return Q}function M6(J,W,Q){const V=J.length;let q=Q,G=0;while(G<V){let P=J.charCodeAt(G++);if((P&4294967168)===0){W[q++]=P;continue}else if((P&4294965248)===0)W[q++]=P>>6&31|192;else{if(P>=55296&&P<=56319){if(G<V){const U=J.charCodeAt(G);if((U&64512)===56320)++G,P=((P&1023)<<10)+(U&1023)+65536}}if((P&4294901760)===0)W[q++]=P>>12&15|224,W[q++]=P>>6&63|128;else W[q++]=P>>18&7|240,W[q++]=P>>12&63|128,W[q++]=P>>6&63|128}W[q++]=P&63|128}}function R6(J,W,Q){L6.encodeInto(J,W.subarray(Q))}function r1(J,W,Q){if(J.length>B6)R6(J,W,Q);else M6(J,W,Q)}function U1(J,W,Q){let V=W;const q=V+Q,G=[];let P="";while(V<q){const U=J[V++];if((U&128)===0)G.push(U);else if((U&224)===192){const K=J[V++]&63;G.push((U&31)<<6|K)}else if((U&240)===224){const K=J[V++]&63,X=J[V++]&63;G.push((U&31)<<12|K<<6|X)}else if((U&248)===240){const K=J[V++]&63,X=J[V++]&63,Y=J[V++]&63;let $=(U&7)<<18|K<<12|X<<6|Y;if($>65535)$-=65536,G.push($>>>10&1023|55296),$=56320|$&1023;G.push($)}else G.push(U);if(G.length>=w6)P+=String.fromCharCode(...G),G.length=0}if(G.length>0)P+=String.fromCharCode(...G);return P}function D6(J,W,Q){const V=J.subarray(W,W+Q);return O6.decode(V)}function n1(J,W,Q){if(Q>x6)return D6(J,W,Q);else return U1(J,W,Q)}var L6=new TextEncoder,B6=50,w6=4096,O6=new TextDecoder,x6=200;class P0{constructor(J,W){this.type=J,this.data=W}}class v extends Error{constructor(J){super(J);const W=Object.create(v.prototype);Object.setPrototypeOf(this,W),Object.defineProperty(this,"name",{configurable:!0,enumerable:!1,value:v.name})}}function o1(J,W,Q){const V=Q/4294967296,q=Q;J.setUint32(W,V),J.setUint32(W+4,q)}function c0(J,W,Q){const V=Math.floor(Q/4294967296),q=Q;J.setUint32(W,V),J.setUint32(W+4,q)}function u0(J,W){const Q=J.getInt32(W),V=J.getUint32(W+4);return Q*4294967296+V}function a1(J,W){const Q=J.getUint32(W),V=J.getUint32(W+4);return Q*4294967296+V}var Y0=4294967295;function v6({sec:J,nsec:W}){if(J>=0&&W>=0&&J<=S6)if(W===0&&J<=T6){const Q=new Uint8Array(4);return new DataView(Q.buffer).setUint32(0,J),Q}else{const Q=J/4294967296,V=J&4294967295,q=new Uint8Array(8),G=new DataView(q.buffer);return G.setUint32(0,W<<2|Q&3),G.setUint32(4,V),q}else{const Q=new Uint8Array(12),V=new DataView(Q.buffer);return V.setUint32(0,W),c0(V,4,J),Q}}function y6(J){const W=J.getTime(),Q=Math.floor(W/1000),V=(W-Q*1000)*1e6,q=Math.floor(V/1e9);return{sec:Q+q,nsec:V-q*1e9}}function E6(J){if(J instanceof Date){const W=y6(J);return v6(W)}else return null}function p6(J){const W=new DataView(J.buffer,J.byteOffset,J.byteLength);switch(J.byteLength){case 4:return{sec:W.getUint32(0),nsec:0};case 8:{const Q=W.getUint32(0),V=W.getUint32(4),q=(Q&3)*4294967296+V,G=Q>>>2;return{sec:q,nsec:G}}case 12:{const Q=u0(W,4),V=W.getUint32(0);return{sec:Q,nsec:V}}default:throw new v(`Unrecognized data size for timestamp (expected 4, 8, or 12): ${J.length}`)}}function h6(J){const W=p6(J);return new Date(W.sec*1000+W.nsec/1e6)}var A6=-1,T6=4294967295,S6=17179869183,e1={type:A6,encode:E6,decode:h6};class s{constructor(){this.builtInEncoders=[],this.builtInDecoders=[],this.encoders=[],this.decoders=[],this.register(e1)}register({type:J,encode:W,decode:Q}){if(J>=0)this.encoders[J]=W,this.decoders[J]=Q;else{const V=-1-J;this.builtInEncoders[V]=W,this.builtInDecoders[V]=Q}}tryToEncode(J,W){for(let Q=0;Q<this.builtInEncoders.length;Q++){const V=this.builtInEncoders[Q];if(V!=null){const q=V(J,W);if(q!=null){const G=-1-Q;return new P0(G,q)}}}for(let Q=0;Q<this.encoders.length;Q++){const V=this.encoders[Q];if(V!=null){const q=V(J,W);if(q!=null)return new P0(Q,q)}}if(J instanceof P0)return J;return null}decode(J,W,Q){const V=W<0?this.builtInDecoders[-1-W]:this.decoders[W];if(V)return V(J,W,Q);else return new P0(W,J)}}s.defaultCodec=new s;var f6=function(J){return J instanceof ArrayBuffer||typeof SharedArrayBuffer!=="undefined"&&J instanceof SharedArrayBuffer};function $0(J){if(J instanceof Uint8Array)return J;else if(ArrayBuffer.isView(J))return new Uint8Array(J.buffer,J.byteOffset,J.byteLength);else if(f6(J))return new Uint8Array(J);else return Uint8Array.from(J)}var t1=function(J,W,Q){if(W!==null&&W!==void 0){if(typeof W!=="object"&&typeof W!=="function")throw new TypeError("Object expected.");var V,q;if(Q){if(!Symbol.asyncDispose)throw new TypeError("Symbol.asyncDispose is not defined.");V=W[Symbol.asyncDispose]}if(V===void 0){if(!Symbol.dispose)throw new TypeError("Symbol.dispose is not defined.");if(V=W[Symbol.dispose],Q)q=V}if(typeof V!=="function")throw new TypeError("Object not disposable.");if(q)V=function(){try{q.call(this)}catch(G){return Promise.reject(G)}};J.stack.push({value:W,dispose:V,async:Q})}else if(Q)J.stack.push({async:!0});return W},s1=function(J){return function(W){function Q(P){W.error=W.hasError?new J(P,W.error,"An error was suppressed during disposal."):P,W.hasError=!0}var V,q=0;function G(){while(V=W.stack.pop())try{if(!V.async&&q===1)return q=0,W.stack.push(V),Promise.resolve().then(G);if(V.dispose){var P=V.dispose.call(V.value);if(V.async)return q|=2,Promise.resolve(P).then(G,function(U){return Q(U),G()})}else q|=1}catch(U){Q(U)}if(q===1)return W.hasError?Promise.reject(W.error):Promise.resolve();if(W.hasError)throw W.error}return G()}}(typeof SuppressedError==="function"?SuppressedError:function(J,W,Q){var V=new Error(Q);return V.name="SuppressedError",V.error=J,V.suppressed=W,V}),m6=100,b6=2048;class d0{constructor(J){this.entered=!1,this.extensionCodec=J?.extensionCodec??s.defaultCodec,this.context=J?.context,this.useBigInt64=J?.useBigInt64??!1,this.maxDepth=J?.maxDepth??m6,this.initialBufferSize=J?.initialBufferSize??b6,this.sortKeys=J?.sortKeys??!1,this.forceFloat32=J?.forceFloat32??!1,this.ignoreUndefined=J?.ignoreUndefined??!1,this.forceIntegerToFloat=J?.forceIntegerToFloat??!1,this.pos=0,this.view=new DataView(new ArrayBuffer(this.initialBufferSize)),this.bytes=new Uint8Array(this.view.buffer)}clone(){return new d0({extensionCodec:this.extensionCodec,context:this.context,useBigInt64:this.useBigInt64,maxDepth:this.maxDepth,initialBufferSize:this.initialBufferSize,sortKeys:this.sortKeys,forceFloat32:this.forceFloat32,ignoreUndefined:this.ignoreUndefined,forceIntegerToFloat:this.forceIntegerToFloat})}reinitializeState(){this.pos=0}enteringGuard(){return this.entered=!0,{[Symbol.dispose]:()=>{this.entered=!1}}}encodeSharedRef(J){const W={stack:[],error:void 0,hasError:!1};try{if(this.entered)return this.clone().encodeSharedRef(J);const Q=t1(W,this.enteringGuard(),!1);return this.reinitializeState(),this.doEncode(J,1),this.bytes.subarray(0,this.pos)}catch(Q){W.error=Q,W.hasError=!0}finally{s1(W)}}encode(J){const W={stack:[],error:void 0,hasError:!1};try{if(this.entered)return this.clone().encode(J);const Q=t1(W,this.enteringGuard(),!1);return this.reinitializeState(),this.doEncode(J,1),this.bytes.slice(0,this.pos)}catch(Q){W.error=Q,W.hasError=!0}finally{s1(W)}}doEncode(J,W){if(W>this.maxDepth)throw new Error(`Too deep objects in depth ${W}`);if(J==null)this.encodeNil();else if(typeof J==="boolean")this.encodeBoolean(J);else if(typeof J==="number")if(!this.forceIntegerToFloat)this.encodeNumber(J);else this.encodeNumberAsFloat(J);else if(typeof J==="string")this.encodeString(J);else if(this.useBigInt64&&typeof J==="bigint")this.encodeBigInt64(J);else this.encodeObject(J,W)}ensureBufferSizeToWrite(J){const W=this.pos+J;if(this.view.byteLength<W)this.resizeBuffer(W*2)}resizeBuffer(J){const W=new ArrayBuffer(J),Q=new Uint8Array(W),V=new DataView(W);Q.set(this.bytes),this.view=V,this.bytes=Q}encodeNil(){this.writeU8(192)}encodeBoolean(J){if(J===!1)this.writeU8(194);else this.writeU8(195)}encodeNumber(J){if(!this.forceIntegerToFloat&&Number.isSafeInteger(J))if(J>=0)if(J<128)this.writeU8(J);else if(J<256)this.writeU8(204),this.writeU8(J);else if(J<65536)this.writeU8(205),this.writeU16(J);else if(J<4294967296)this.writeU8(206),this.writeU32(J);else if(!this.useBigInt64)this.writeU8(207),this.writeU64(J);else this.encodeNumberAsFloat(J);else if(J>=-32)this.writeU8(224|J+32);else if(J>=-128)this.writeU8(208),this.writeI8(J);else if(J>=-32768)this.writeU8(209),this.writeI16(J);else if(J>=-2147483648)this.writeU8(210),this.writeI32(J);else if(!this.useBigInt64)this.writeU8(211),this.writeI64(J);else this.encodeNumberAsFloat(J);else this.encodeNumberAsFloat(J)}encodeNumberAsFloat(J){if(this.forceFloat32)this.writeU8(202),this.writeF32(J);else this.writeU8(203),this.writeF64(J)}encodeBigInt64(J){if(J>=BigInt(0))this.writeU8(207),this.writeBigUint64(J);else this.writeU8(211),this.writeBigInt64(J)}writeStringHeader(J){if(J<32)this.writeU8(160+J);else if(J<256)this.writeU8(217),this.writeU8(J);else if(J<65536)this.writeU8(218),this.writeU16(J);else if(J<4294967296)this.writeU8(219),this.writeU32(J);else throw new Error(`Too long string: ${J} bytes in UTF-8`)}encodeString(J){const Q=_1(J);this.ensureBufferSizeToWrite(5+Q),this.writeStringHeader(Q),r1(J,this.bytes,this.pos),this.pos+=Q}encodeObject(J,W){const Q=this.extensionCodec.tryToEncode(J,this.context);if(Q!=null)this.encodeExtension(Q);else if(Array.isArray(J))this.encodeArray(J,W);else if(ArrayBuffer.isView(J))this.encodeBinary(J);else if(typeof J==="object")this.encodeMap(J,W);else throw new Error(`Unrecognized object: ${Object.prototype.toString.apply(J)}`)}encodeBinary(J){const W=J.byteLength;if(W<256)this.writeU8(196),this.writeU8(W);else if(W<65536)this.writeU8(197),this.writeU16(W);else if(W<4294967296)this.writeU8(198),this.writeU32(W);else throw new Error(`Too large binary: ${W}`);const Q=$0(J);this.writeU8a(Q)}encodeArray(J,W){const Q=J.length;if(Q<16)this.writeU8(144+Q);else if(Q<65536)this.writeU8(220),this.writeU16(Q);else if(Q<4294967296)this.writeU8(221),this.writeU32(Q);else throw new Error(`Too large array: ${Q}`);for(let V of J)this.doEncode(V,W+1)}countWithoutUndefined(J,W){let Q=0;for(let V of W)if(J[V]!==void 0)Q++;return Q}encodeMap(J,W){const Q=Object.keys(J);if(this.sortKeys)Q.sort();const V=this.ignoreUndefined?this.countWithoutUndefined(J,Q):Q.length;if(V<16)this.writeU8(128+V);else if(V<65536)this.writeU8(222),this.writeU16(V);else if(V<4294967296)this.writeU8(223),this.writeU32(V);else throw new Error(`Too large map object: ${V}`);for(let q of Q){const G=J[q];if(!(this.ignoreUndefined&&G===void 0))this.encodeString(q),this.doEncode(G,W+1)}}encodeExtension(J){if(typeof J.data==="function"){const Q=J.data(this.pos+6),V=Q.length;if(V>=4294967296)throw new Error(`Too large extension object: ${V}`);this.writeU8(201),this.writeU32(V),this.writeI8(J.type),this.writeU8a(Q);return}const W=J.data.length;if(W===1)this.writeU8(212);else if(W===2)this.writeU8(213);else if(W===4)this.writeU8(214);else if(W===8)this.writeU8(215);else if(W===16)this.writeU8(216);else if(W<256)this.writeU8(199),this.writeU8(W);else if(W<65536)this.writeU8(200),this.writeU16(W);else if(W<4294967296)this.writeU8(201),this.writeU32(W);else throw new Error(`Too large extension object: ${W}`);this.writeI8(J.type),this.writeU8a(J.data)}writeU8(J){this.ensureBufferSizeToWrite(1),this.view.setUint8(this.pos,J),this.pos++}writeU8a(J){const W=J.length;this.ensureBufferSizeToWrite(W),this.bytes.set(J,this.pos),this.pos+=W}writeI8(J){this.ensureBufferSizeToWrite(1),this.view.setInt8(this.pos,J),this.pos++}writeU16(J){this.ensureBufferSizeToWrite(2),this.view.setUint16(this.pos,J),this.pos+=2}writeI16(J){this.ensureBufferSizeToWrite(2),this.view.setInt16(this.pos,J),this.pos+=2}writeU32(J){this.ensureBufferSizeToWrite(4),this.view.setUint32(this.pos,J),this.pos+=4}writeI32(J){this.ensureBufferSizeToWrite(4),this.view.setInt32(this.pos,J),this.pos+=4}writeF32(J){this.ensureBufferSizeToWrite(4),this.view.setFloat32(this.pos,J),this.pos+=4}writeF64(J){this.ensureBufferSizeToWrite(8),this.view.setFloat64(this.pos,J),this.pos+=8}writeU64(J){this.ensureBufferSizeToWrite(8),o1(this.view,this.pos,J),this.pos+=8}writeI64(J){this.ensureBufferSizeToWrite(8),c0(this.view,this.pos,J),this.pos+=8}writeBigUint64(J){this.ensureBufferSizeToWrite(8),this.view.setBigUint64(this.pos,J),this.pos+=8}writeBigInt64(J){this.ensureBufferSizeToWrite(8),this.view.setBigInt64(this.pos,J),this.pos+=8}}function X1(J,W){return new d0(W).encodeSharedRef(J)}function i0(J){return`${J<0?"-":""}0x${Math.abs(J).toString(16).padStart(2,"0")}`}var c6=16,u6=16;class P1{constructor(J=c6,W=u6){this.hit=0,this.miss=0,this.maxKeyLength=J,this.maxLengthPerKey=W,this.caches=[];for(let Q=0;Q<this.maxKeyLength;Q++)this.caches.push([])}canBeCached(J){return J>0&&J<=this.maxKeyLength}find(J,W,Q){const V=this.caches[Q-1];J:for(let q of V){const G=q.bytes;for(let P=0;P<Q;P++)if(G[P]!==J[W+P])continue J;return q.str}return null}store(J,W){const Q=this.caches[J.length-1],V={bytes:J,str:W};if(Q.length>=this.maxLengthPerKey)Q[Math.random()*Q.length|0]=V;else Q.push(V)}decode(J,W,Q){const V=this.find(J,W,Q);if(V!=null)return this.hit++,V;this.miss++;const q=U1(J,W,Q),G=Uint8Array.prototype.slice.call(J,W,W+Q);return this.store(G,q),q}}var l0=function(J,W,Q){if(W!==null&&W!==void 0){if(typeof W!=="object"&&typeof W!=="function")throw new TypeError("Object expected.");var V,q;if(Q){if(!Symbol.asyncDispose)throw new TypeError("Symbol.asyncDispose is not defined.");V=W[Symbol.asyncDispose]}if(V===void 0){if(!Symbol.dispose)throw new TypeError("Symbol.dispose is not defined.");if(V=W[Symbol.dispose],Q)q=V}if(typeof V!=="function")throw new TypeError("Object not disposable.");if(q)V=function(){try{q.call(this)}catch(G){return Promise.reject(G)}};J.stack.push({value:W,dispose:V,async:Q})}else if(Q)J.stack.push({async:!0});return W},_0=function(J){return function(W){function Q(P){W.error=W.hasError?new J(P,W.error,"An error was suppressed during disposal."):P,W.hasError=!0}var V,q=0;function G(){while(V=W.stack.pop())try{if(!V.async&&q===1)return q=0,W.stack.push(V),Promise.resolve().then(G);if(V.dispose){var P=V.dispose.call(V.value);if(V.async)return q|=2,Promise.resolve(P).then(G,function(U){return Q(U),G()})}else q|=1}catch(U){Q(U)}if(q===1)return W.hasError?Promise.reject(W.error):Promise.resolve();if(W.hasError)throw W.error}return G()}}(typeof SuppressedError==="function"?SuppressedError:function(J,W,Q){var V=new Error(Q);return V.name="SuppressedError",V.error=J,V.suppressed=W,V}),Y1="array",I0="map_key",Q8="map_value",d6=(J)=>{if(typeof J==="string"||typeof J==="number")return J;throw new v("The type of key must be string or number but "+typeof J)};class W8{constructor(){this.stack=[],this.stackHeadPosition=-1}get length(){return this.stackHeadPosition+1}top(){return this.stack[this.stackHeadPosition]}pushArrayState(J){const W=this.getUninitializedStateFromPool();W.type=Y1,W.position=0,W.size=J,W.array=new Array(J)}pushMapState(J){const W=this.getUninitializedStateFromPool();W.type=I0,W.readCount=0,W.size=J,W.map={}}getUninitializedStateFromPool(){if(this.stackHeadPosition++,this.stackHeadPosition===this.stack.length){const J={type:void 0,size:0,array:void 0,position:0,readCount:0,map:void 0,key:null};this.stack.push(J)}return this.stack[this.stackHeadPosition]}release(J){if(this.stack[this.stackHeadPosition]!==J)throw new Error("Invalid stack state. Released state is not on top of the stack.");if(J.type===Y1){const Q=J;Q.size=0,Q.array=void 0,Q.position=0,Q.type=void 0}if(J.type===I0||J.type===Q8){const Q=J;Q.size=0,Q.map=void 0,Q.readCount=0,Q.type=void 0}this.stackHeadPosition--}reset(){this.stack.length=0,this.stackHeadPosition=-1}}var g0=-1,F1=new DataView(new ArrayBuffer(0)),i6=new Uint8Array(F1.buffer);try{F1.getInt8(0)}catch(J){if(!(J instanceof RangeError))throw new Error("This module is not supported in the current JavaScript engine because DataView does not throw RangeError on out-of-bounds access")}var J8=new RangeError("Insufficient data"),l6=new P1;class r0{constructor(J){this.totalPos=0,this.pos=0,this.view=F1,this.bytes=i6,this.headByte=g0,this.stack=new W8,this.entered=!1,this.extensionCodec=J?.extensionCodec??s.defaultCodec,this.context=J?.context,this.useBigInt64=J?.useBigInt64??!1,this.rawStrings=J?.rawStrings??!1,this.maxStrLength=J?.maxStrLength??Y0,this.maxBinLength=J?.maxBinLength??Y0,this.maxArrayLength=J?.maxArrayLength??Y0,this.maxMapLength=J?.maxMapLength??Y0,this.maxExtLength=J?.maxExtLength??Y0,this.keyDecoder=J?.keyDecoder!==void 0?J.keyDecoder:l6,this.mapKeyConverter=J?.mapKeyConverter??d6}clone(){return new r0({extensionCodec:this.extensionCodec,context:this.context,useBigInt64:this.useBigInt64,rawStrings:this.rawStrings,maxStrLength:this.maxStrLength,maxBinLength:this.maxBinLength,maxArrayLength:this.maxArrayLength,maxMapLength:this.maxMapLength,maxExtLength:this.maxExtLength,keyDecoder:this.keyDecoder})}reinitializeState(){this.totalPos=0,this.headByte=g0,this.stack.reset()}setBuffer(J){const W=$0(J);this.bytes=W,this.view=new DataView(W.buffer,W.byteOffset,W.byteLength),this.pos=0}appendBuffer(J){if(this.headByte===g0&&!this.hasRemaining(1))this.setBuffer(J);else{const W=this.bytes.subarray(this.pos),Q=$0(J),V=new Uint8Array(W.length+Q.length);V.set(W),V.set(Q,W.length),this.setBuffer(V)}}hasRemaining(J){return this.view.byteLength-this.pos>=J}createExtraByteError(J){const{view:W,pos:Q}=this;return new RangeError(`Extra ${W.byteLength-Q} of ${W.byteLength} byte(s) found at buffer[${J}]`)}enteringGuard(){return this.entered=!0,{[Symbol.dispose]:()=>{this.entered=!1}}}decode(J){const W={stack:[],error:void 0,hasError:!1};try{if(this.entered)return this.clone().decode(J);const Q=l0(W,this.enteringGuard(),!1);this.reinitializeState(),this.setBuffer(J);const V=this.doDecodeSync();if(this.hasRemaining(1))throw this.createExtraByteError(this.pos);return V}catch(Q){W.error=Q,W.hasError=!0}finally{_0(W)}}*decodeMulti(J){const W={stack:[],error:void 0,hasError:!1};try{if(this.entered){yield*this.clone().decodeMulti(J);return}const Q=l0(W,this.enteringGuard(),!1);this.reinitializeState(),this.setBuffer(J);while(this.hasRemaining(1))yield this.doDecodeSync()}catch(Q){W.error=Q,W.hasError=!0}finally{_0(W)}}async decodeAsync(J){const W={stack:[],error:void 0,hasError:!1};try{if(this.entered)return this.clone().decodeAsync(J);const Q=l0(W,this.enteringGuard(),!1);let V=!1,q;for await(let K of J){if(V)throw this.entered=!1,this.createExtraByteError(this.totalPos);this.appendBuffer(K);try{q=this.doDecodeSync(),V=!0}catch(X){if(!(X instanceof RangeError))throw X}this.totalPos+=this.pos}if(V){if(this.hasRemaining(1))throw this.createExtraByteError(this.totalPos);return q}const{headByte:G,pos:P,totalPos:U}=this;throw new RangeError(`Insufficient data in parsing ${i0(G)} at ${U} (${P} in the current buffer)`)}catch(Q){W.error=Q,W.hasError=!0}finally{_0(W)}}decodeArrayStream(J){return this.decodeMultiAsync(J,!0)}decodeStream(J){return this.decodeMultiAsync(J,!1)}async*decodeMultiAsync(J,W){const Q={stack:[],error:void 0,hasError:!1};try{if(this.entered){yield*this.clone().decodeMultiAsync(J,W);return}const V=l0(Q,this.enteringGuard(),!1);let q=W,G=-1;for await(let P of J){if(W&&G===0)throw this.createExtraByteError(this.totalPos);if(this.appendBuffer(P),q)G=this.readArraySize(),q=!1,this.complete();try{while(!0)if(yield this.doDecodeSync(),--G===0)break}catch(U){if(!(U instanceof RangeError))throw U}this.totalPos+=this.pos}}catch(V){Q.error=V,Q.hasError=!0}finally{_0(Q)}}doDecodeSync(){J:while(!0){const J=this.readHeadByte();let W;if(J>=224)W=J-256;else if(J<192)if(J<128)W=J;else if(J<144){const V=J-128;if(V!==0){this.pushMapState(V),this.complete();continue J}else W={}}else if(J<160){const V=J-144;if(V!==0){this.pushArrayState(V),this.complete();continue J}else W=[]}else{const V=J-160;W=this.decodeString(V,0)}else if(J===192)W=null;else if(J===194)W=!1;else if(J===195)W=!0;else if(J===202)W=this.readF32();else if(J===203)W=this.readF64();else if(J===204)W=this.readU8();else if(J===205)W=this.readU16();else if(J===206)W=this.readU32();else if(J===207)if(this.useBigInt64)W=this.readU64AsBigInt();else W=this.readU64();else if(J===208)W=this.readI8();else if(J===209)W=this.readI16();else if(J===210)W=this.readI32();else if(J===211)if(this.useBigInt64)W=this.readI64AsBigInt();else W=this.readI64();else if(J===217){const V=this.lookU8();W=this.decodeString(V,1)}else if(J===218){const V=this.lookU16();W=this.decodeString(V,2)}else if(J===219){const V=this.lookU32();W=this.decodeString(V,4)}else if(J===220){const V=this.readU16();if(V!==0){this.pushArrayState(V),this.complete();continue J}else W=[]}else if(J===221){const V=this.readU32();if(V!==0){this.pushArrayState(V),this.complete();continue J}else W=[]}else if(J===222){const V=this.readU16();if(V!==0){this.pushMapState(V),this.complete();continue J}else W={}}else if(J===223){const V=this.readU32();if(V!==0){this.pushMapState(V),this.complete();continue J}else W={}}else if(J===196){const V=this.lookU8();W=this.decodeBinary(V,1)}else if(J===197){const V=this.lookU16();W=this.decodeBinary(V,2)}else if(J===198){const V=this.lookU32();W=this.decodeBinary(V,4)}else if(J===212)W=this.decodeExtension(1,0);else if(J===213)W=this.decodeExtension(2,0);else if(J===214)W=this.decodeExtension(4,0);else if(J===215)W=this.decodeExtension(8,0);else if(J===216)W=this.decodeExtension(16,0);else if(J===199){const V=this.lookU8();W=this.decodeExtension(V,1)}else if(J===200){const V=this.lookU16();W=this.decodeExtension(V,2)}else if(J===201){const V=this.lookU32();W=this.decodeExtension(V,4)}else throw new v(`Unrecognized type byte: ${i0(J)}`);this.complete();const Q=this.stack;while(Q.length>0){const V=Q.top();if(V.type===Y1)if(V.array[V.position]=W,V.position++,V.position===V.size)W=V.array,Q.release(V);else continue J;else if(V.type===I0){if(W==="__proto__")throw new v("The key __proto__ is not allowed");V.key=this.mapKeyConverter(W),V.type=Q8;continue J}else if(V.map[V.key]=W,V.readCount++,V.readCount===V.size)W=V.map,Q.release(V);else{V.key=null,V.type=I0;continue J}}return W}}readHeadByte(){if(this.headByte===g0)this.headByte=this.readU8();return this.headByte}complete(){this.headByte=g0}readArraySize(){const J=this.readHeadByte();switch(J){case 220:return this.readU16();case 221:return this.readU32();default:if(J<160)return J-144;else throw new v(`Unrecognized array type byte: ${i0(J)}`)}}pushMapState(J){if(J>this.maxMapLength)throw new v(`Max length exceeded: map length (${J}) > maxMapLengthLength (${this.maxMapLength})`);this.stack.pushMapState(J)}pushArrayState(J){if(J>this.maxArrayLength)throw new v(`Max length exceeded: array length (${J}) > maxArrayLength (${this.maxArrayLength})`);this.stack.pushArrayState(J)}decodeString(J,W){if(!this.rawStrings||this.stateIsMapKey())return this.decodeUtf8String(J,W);return this.decodeBinary(J,W)}decodeUtf8String(J,W){if(J>this.maxStrLength)throw new v(`Max length exceeded: UTF-8 byte length (${J}) > maxStrLength (${this.maxStrLength})`);if(this.bytes.byteLength<this.pos+W+J)throw J8;const Q=this.pos+W;let V;if(this.stateIsMapKey()&&this.keyDecoder?.canBeCached(J))V=this.keyDecoder.decode(this.bytes,Q,J);else V=n1(this.bytes,Q,J);return this.pos+=W+J,V}stateIsMapKey(){if(this.stack.length>0)return this.stack.top().type===I0;return!1}decodeBinary(J,W){if(J>this.maxBinLength)throw new v(`Max length exceeded: bin length (${J}) > maxBinLength (${this.maxBinLength})`);if(!this.hasRemaining(J+W))throw J8;const Q=this.pos+W,V=this.bytes.subarray(Q,Q+J);return this.pos+=W+J,V}decodeExtension(J,W){if(J>this.maxExtLength)throw new v(`Max length exceeded: ext length (${J}) > maxExtLength (${this.maxExtLength})`);const Q=this.view.getInt8(this.pos+W),V=this.decodeBinary(J,W+1);return this.extensionCodec.decode(V,Q,this.context)}lookU8(){return this.view.getUint8(this.pos)}lookU16(){return this.view.getUint16(this.pos)}lookU32(){return this.view.getUint32(this.pos)}readU8(){const J=this.view.getUint8(this.pos);return this.pos++,J}readI8(){const J=this.view.getInt8(this.pos);return this.pos++,J}readU16(){const J=this.view.getUint16(this.pos);return this.pos+=2,J}readI16(){const J=this.view.getInt16(this.pos);return this.pos+=2,J}readU32(){const J=this.view.getUint32(this.pos);return this.pos+=4,J}readI32(){const J=this.view.getInt32(this.pos);return this.pos+=4,J}readU64(){const J=a1(this.view,this.pos);return this.pos+=8,J}readI64(){const J=u0(this.view,this.pos);return this.pos+=8,J}readU64AsBigInt(){const J=this.view.getBigUint64(this.pos);return this.pos+=8,J}readI64AsBigInt(){const J=this.view.getBigInt64(this.pos);return this.pos+=8,J}readF32(){const J=this.view.getFloat32(this.pos);return this.pos+=4,J}readF64(){const J=this.view.getFloat64(this.pos);return this.pos+=8,J}}function K1(J,W){return new r0(W).decode(J)}var H0=function(J){let W=J.length;while(--W>=0)J[W]=0},k1=function(J,W,Q,V,q){this.static_tree=J,this.extra_bits=W,this.extra_base=Q,this.elems=V,this.max_length=q,this.has_stree=J&&J.length},Z1=function(J,W){this.dyn_tree=J,this.max_code=0,this.stat_desc=W},b=function(J,W,Q,V,q){this.good_length=J,this.max_lazy=W,this.nice_length=Q,this.max_chain=V,this.func=q},rJ=function(){this.strm=null,this.status=0,this.pending_buf=null,this.pending_buf_size=0,this.pending_out=0,this.pending=0,this.wrap=0,this.gzhead=null,this.gzindex=0,this.method=V1,this.last_flush=-1,this.w_size=0,this.w_bits=0,this.w_mask=0,this.window=null,this.window_size=0,this.prev=null,this.head=null,this.ins_h=0,this.hash_size=0,this.hash_bits=0,this.hash_mask=0,this.hash_shift=0,this.block_start=0,this.match_length=0,this.prev_match=0,this.match_available=0,this.strstart=0,this.match_start=0,this.lookahead=0,this.prev_length=0,this.max_chain_length=0,this.max_lazy_match=0,this.level=0,this.strategy=0,this.good_match=0,this.nice_match=0,this.dyn_ltree=new Uint16Array(fJ*2),this.dyn_dtree=new Uint16Array((2*pJ+1)*2),this.bl_tree=new Uint16Array((2*hJ+1)*2),r(this.dyn_ltree),r(this.dyn_dtree),r(this.bl_tree),this.l_desc=null,this.d_desc=null,this.bl_desc=null,this.bl_count=new Uint16Array(mJ+1),this.heap=new Uint16Array(2*D1+1),r(this.heap),this.heap_len=0,this.heap_max=0,this.depth=new Uint16Array(2*D1+1),r(this.depth),this.sym_buf=0,this.lit_bufsize=0,this.sym_next=0,this.sym_end=0,this.opt_len=0,this.static_len=0,this.matches=0,this.insert=0,this.bi_buf=0,this.bi_valid=0},HQ=function(){this.input=null,this.next_in=0,this.avail_in=0,this.total_in=0,this.output=null,this.next_out=0,this.avail_out=0,this.total_out=0,this.msg="",this.state=null,this.data_type=2,this.adler=0},h0=function(J){this.options=q1.assign({level:jQ,method:LQ,chunkSize:16384,windowBits:15,memLevel:8,strategy:MQ},J||{});let W=this.options;if(W.raw&&W.windowBits>0)W.windowBits=-W.windowBits;else if(W.gzip&&W.windowBits>0&&W.windowBits<16)W.windowBits+=16;this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new P6,this.strm.avail_out=0;let Q=R0.deflateInit2(this.strm,W.level,W.method,W.windowBits,W.memLevel,W.strategy);if(Q!==Q1)throw new Error(V0[Q]);if(W.header)R0.deflateSetHeader(this.strm,W.header);if(W.dictionary){let V;if(typeof W.dictionary==="string")V=v0.string2buf(W.dictionary);else if(Y6.call(W.dictionary)==="[object ArrayBuffer]")V=new Uint8Array(W.dictionary);else V=W.dictionary;if(Q=R0.deflateSetDictionary(this.strm,V),Q!==Q1)throw new Error(V0[Q]);this._dict_set=!0}},b1=function(J,W){const Q=new h0(W);if(Q.push(J,!0),Q.err)throw Q.msg||V0[Q.err];return Q.result},BQ=function(J,W){return W=W||{},W.raw=!0,b1(J,W)},RQ=function(J,W){return W=W||{},W.gzip=!0,b1(J,W)},nQ=function(){this.strm=null,this.mode=0,this.last=!1,this.wrap=0,this.havedict=!1,this.flags=0,this.dmax=0,this.check=0,this.total=0,this.head=null,this.wbits=0,this.wsize=0,this.whave=0,this.wnext=0,this.window=null,this.hold=0,this.bits=0,this.length=0,this.offset=0,this.extra=0,this.lencode=null,this.distcode=null,this.lenbits=0,this.distbits=0,this.ncode=0,this.nlen=0,this.ndist=0,this.have=0,this.next=null,this.lens=new Uint16Array(320),this.work=new Uint16Array(288),this.lendyn=null,this.distdyn=null,this.sane=0,this.back=0,this.was=0},K5=function(){this.text=0,this.time=0,this.xflags=0,this.os=0,this.extra=null,this.extra_len=0,this.name="",this.comment="",this.hcrc=0,this.done=!1},f0=function(J){this.options=q1.assign({chunkSize:65536,windowBits:15,to:""},J||{});const W=this.options;if(W.raw&&W.windowBits>=0&&W.windowBits<16){if(W.windowBits=-W.windowBits,W.windowBits===0)W.windowBits=-15}if(W.windowBits>=0&&W.windowBits<16&&!(J&&J.windowBits))W.windowBits+=32;if(W.windowBits>15&&W.windowBits<48){if((W.windowBits&15)===0)W.windowBits|=15}this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new P6,this.strm.avail_out=0;let Q=_.inflateInit2(this.strm,W.windowBits);if(Q!==y0)throw new Error(V0[Q]);if(this.header=new z5,_.inflateGetHeader(this.strm,this.header),W.dictionary){if(typeof W.dictionary==="string")W.dictionary=v0.string2buf(W.dictionary);else if(j6.call(W.dictionary)==="[object ArrayBuffer]")W.dictionary=new Uint8Array(W.dictionary);if(W.raw){if(Q=_.inflateSetDictionary(this.strm,W.dictionary),Q!==y0)throw new Error(V0[Q])}}},c1=function(J,W){const Q=new f0(W);if(Q.push(J),Q.err)throw Q.msg||V0[Q.err];return Q.result},N5=function(J,W){return W=W||{},W.raw=!0,c1(J,W)};/*! pako 2.1.0 https://github.com/nodeca/pako @license (MIT AND Zlib) */var _6=0,c8=1,r6=2,n6=3,o6=258,E1=29,E0=256,O0=E0+1+E1,z0=30,p1=19,u8=2*O0+1,J0=15,z1=16,a6=7,h1=256,d8=16,i8=17,l8=18,w1=new Uint8Array([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0]),s0=new Uint8Array([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13]),e6=new Uint8Array([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7]),_8=new Uint8Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),t6=512,l=new Array((O0+2)*2);H0(l);var B0=new Array(z0*2);H0(B0);var x0=new Array(t6);H0(x0);var D0=new Array(o6-n6+1);H0(D0);var f1=new Array(E1);H0(f1);var J1=new Array(z0);H0(J1);var r8,n8,o8,a8=(J)=>{return J<256?x0[J]:x0[256+(J>>>7)]},A0=(J,W)=>{J.pending_buf[J.pending++]=W&255,J.pending_buf[J.pending++]=W>>>8&255},E=(J,W,Q)=>{if(J.bi_valid>z1-Q)J.bi_buf|=W<<J.bi_valid&65535,A0(J,J.bi_buf),J.bi_buf=W>>z1-J.bi_valid,J.bi_valid+=Q-z1;else J.bi_buf|=W<<J.bi_valid&65535,J.bi_valid+=Q},c=(J,W,Q)=>{E(J,Q[W*2],Q[W*2+1])},e8=(J,W)=>{let Q=0;do Q|=J&1,J>>>=1,Q<<=1;while(--W>0);return Q>>>1},s6=(J)=>{if(J.bi_valid===16)A0(J,J.bi_buf),J.bi_buf=0,J.bi_valid=0;else if(J.bi_valid>=8)J.pending_buf[J.pending++]=J.bi_buf&255,J.bi_buf>>=8,J.bi_valid-=8},JJ=(J,W)=>{const{dyn_tree:Q,max_code:V}=W,q=W.stat_desc.static_tree,G=W.stat_desc.has_stree,P=W.stat_desc.extra_bits,U=W.stat_desc.extra_base,K=W.stat_desc.max_length;let X,Y,$,k,F,Z,D=0;for(k=0;k<=J0;k++)J.bl_count[k]=0;Q[J.heap[J.heap_max]*2+1]=0;for(X=J.heap_max+1;X<u8;X++){if(Y=J.heap[X],k=Q[Q[Y*2+1]*2+1]+1,k>K)k=K,D++;if(Q[Y*2+1]=k,Y>V)continue;if(J.bl_count[k]++,F=0,Y>=U)F=P[Y-U];if(Z=Q[Y*2],J.opt_len+=Z*(k+F),G)J.static_len+=Z*(q[Y*2+1]+F)}if(D===0)return;do{k=K-1;while(J.bl_count[k]===0)k--;J.bl_count[k]--,J.bl_count[k+1]+=2,J.bl_count[K]--,D-=2}while(D>0);for(k=K;k!==0;k--){Y=J.bl_count[k];while(Y!==0){if($=J.heap[--X],$>V)continue;if(Q[$*2+1]!==k)J.opt_len+=(k-Q[$*2+1])*Q[$*2],Q[$*2+1]=k;Y--}}},t8=(J,W,Q)=>{const V=new Array(J0+1);let q=0,G,P;for(G=1;G<=J0;G++)q=q+Q[G-1]<<1,V[G]=q;for(P=0;P<=W;P++){let U=J[P*2+1];if(U===0)continue;J[P*2]=e8(V[U]++,U)}},QJ=()=>{let J,W,Q,V,q;const G=new Array(J0+1);Q=0;for(V=0;V<E1-1;V++){f1[V]=Q;for(J=0;J<1<<w1[V];J++)D0[Q++]=V}D0[Q-1]=V,q=0;for(V=0;V<16;V++){J1[V]=q;for(J=0;J<1<<s0[V];J++)x0[q++]=V}q>>=7;for(;V<z0;V++){J1[V]=q<<7;for(J=0;J<1<<s0[V]-7;J++)x0[256+q++]=V}for(W=0;W<=J0;W++)G[W]=0;J=0;while(J<=143)l[J*2+1]=8,J++,G[8]++;while(J<=255)l[J*2+1]=9,J++,G[9]++;while(J<=279)l[J*2+1]=7,J++,G[7]++;while(J<=287)l[J*2+1]=8,J++,G[8]++;t8(l,O0+1,G);for(J=0;J<z0;J++)B0[J*2+1]=5,B0[J*2]=e8(J,5);r8=new k1(l,w1,E0+1,O0,J0),n8=new k1(B0,s0,0,z0,J0),o8=new k1(new Array(0),e6,0,p1,a6)},s8=(J)=>{let W;for(W=0;W<O0;W++)J.dyn_ltree[W*2]=0;for(W=0;W<z0;W++)J.dyn_dtree[W*2]=0;for(W=0;W<p1;W++)J.bl_tree[W*2]=0;J.dyn_ltree[h1*2]=1,J.opt_len=J.static_len=0,J.sym_next=J.matches=0},J6=(J)=>{if(J.bi_valid>8)A0(J,J.bi_buf);else if(J.bi_valid>0)J.pending_buf[J.pending++]=J.bi_buf;J.bi_buf=0,J.bi_valid=0},V8=(J,W,Q,V)=>{const q=W*2,G=Q*2;return J[q]<J[G]||J[q]===J[G]&&V[W]<=V[Q]},H1=(J,W,Q)=>{const V=J.heap[Q];let q=Q<<1;while(q<=J.heap_len){if(q<J.heap_len&&V8(W,J.heap[q+1],J.heap[q],J.depth))q++;if(V8(W,V,J.heap[q],J.depth))break;J.heap[Q]=J.heap[q],Q=q,q<<=1}J.heap[Q]=V},q8=(J,W,Q)=>{let V,q,G=0,P,U;if(J.sym_next!==0)do if(V=J.pending_buf[J.sym_buf+G++]&255,V+=(J.pending_buf[J.sym_buf+G++]&255)<<8,q=J.pending_buf[J.sym_buf+G++],V===0)c(J,q,W);else{if(P=D0[q],c(J,P+E0+1,W),U=w1[P],U!==0)q-=f1[P],E(J,q,U);if(V--,P=a8(V),c(J,P,Q),U=s0[P],U!==0)V-=J1[P],E(J,V,U)}while(G<J.sym_next);c(J,h1,W)},O1=(J,W)=>{const Q=W.dyn_tree,V=W.stat_desc.static_tree,q=W.stat_desc.has_stree,G=W.stat_desc.elems;let P,U,K=-1,X;J.heap_len=0,J.heap_max=u8;for(P=0;P<G;P++)if(Q[P*2]!==0)J.heap[++J.heap_len]=K=P,J.depth[P]=0;else Q[P*2+1]=0;while(J.heap_len<2)if(X=J.heap[++J.heap_len]=K<2?++K:0,Q[X*2]=1,J.depth[X]=0,J.opt_len--,q)J.static_len-=V[X*2+1];W.max_code=K;for(P=J.heap_len>>1;P>=1;P--)H1(J,Q,P);X=G;do P=J.heap[1],J.heap[1]=J.heap[J.heap_len--],H1(J,Q,1),U=J.heap[1],J.heap[--J.heap_max]=P,J.heap[--J.heap_max]=U,Q[X*2]=Q[P*2]+Q[U*2],J.depth[X]=(J.depth[P]>=J.depth[U]?J.depth[P]:J.depth[U])+1,Q[P*2+1]=Q[U*2+1]=X,J.heap[1]=X++,H1(J,Q,1);while(J.heap_len>=2);J.heap[--J.heap_max]=J.heap[1],JJ(J,W),t8(Q,K,J.bl_count)},G8=(J,W,Q)=>{let V,q=-1,G,P=W[1],U=0,K=7,X=4;if(P===0)K=138,X=3;W[(Q+1)*2+1]=65535;for(V=0;V<=Q;V++){if(G=P,P=W[(V+1)*2+1],++U<K&&G===P)continue;else if(U<X)J.bl_tree[G*2]+=U;else if(G!==0){if(G!==q)J.bl_tree[G*2]++;J.bl_tree[d8*2]++}else if(U<=10)J.bl_tree[i8*2]++;else J.bl_tree[l8*2]++;if(U=0,q=G,P===0)K=138,X=3;else if(G===P)K=6,X=3;else K=7,X=4}},U8=(J,W,Q)=>{let V,q=-1,G,P=W[1],U=0,K=7,X=4;if(P===0)K=138,X=3;for(V=0;V<=Q;V++){if(G=P,P=W[(V+1)*2+1],++U<K&&G===P)continue;else if(U<X)do c(J,G,J.bl_tree);while(--U!==0);else if(G!==0){if(G!==q)c(J,G,J.bl_tree),U--;c(J,d8,J.bl_tree),E(J,U-3,2)}else if(U<=10)c(J,i8,J.bl_tree),E(J,U-3,3);else c(J,l8,J.bl_tree),E(J,U-11,7);if(U=0,q=G,P===0)K=138,X=3;else if(G===P)K=6,X=3;else K=7,X=4}},WJ=(J)=>{let W;G8(J,J.dyn_ltree,J.l_desc.max_code),G8(J,J.dyn_dtree,J.d_desc.max_code),O1(J,J.bl_desc);for(W=p1-1;W>=3;W--)if(J.bl_tree[_8[W]*2+1]!==0)break;return J.opt_len+=3*(W+1)+5+5+4,W},VJ=(J,W,Q,V)=>{let q;E(J,W-257,5),E(J,Q-1,5),E(J,V-4,4);for(q=0;q<V;q++)E(J,J.bl_tree[_8[q]*2+1],3);U8(J,J.dyn_ltree,W-1),U8(J,J.dyn_dtree,Q-1)},qJ=(J)=>{let W=4093624447,Q;for(Q=0;Q<=31;Q++,W>>>=1)if(W&1&&J.dyn_ltree[Q*2]!==0)return 0;if(J.dyn_ltree[18]!==0||J.dyn_ltree[20]!==0||J.dyn_ltree[26]!==0)return 1;for(Q=32;Q<E0;Q++)if(J.dyn_ltree[Q*2]!==0)return 1;return 0},X8=!1,GJ=(J)=>{if(!X8)QJ(),X8=!0;J.l_desc=new Z1(J.dyn_ltree,r8),J.d_desc=new Z1(J.dyn_dtree,n8),J.bl_desc=new Z1(J.bl_tree,o8),J.bi_buf=0,J.bi_valid=0,s8(J)},Q6=(J,W,Q,V)=>{if(E(J,(_6<<1)+(V?1:0),3),J6(J),A0(J,Q),A0(J,~Q),Q)J.pending_buf.set(J.window.subarray(W,W+Q),J.pending);J.pending+=Q},UJ=(J)=>{E(J,c8<<1,3),c(J,h1,l),s6(J)},XJ=(J,W,Q,V)=>{let q,G,P=0;if(J.level>0){if(J.strm.data_type===2)J.strm.data_type=qJ(J);if(O1(J,J.l_desc),O1(J,J.d_desc),P=WJ(J),q=J.opt_len+3+7>>>3,G=J.static_len+3+7>>>3,G<=q)q=G}else q=G=Q+5;if(Q+4<=q&&W!==-1)Q6(J,W,Q,V);else if(J.strategy===4||G===q)E(J,(c8<<1)+(V?1:0),3),q8(J,l,B0);else E(J,(r6<<1)+(V?1:0),3),VJ(J,J.l_desc.max_code+1,J.d_desc.max_code+1,P+1),q8(J,J.dyn_ltree,J.dyn_dtree);if(s8(J),V)J6(J)},PJ=(J,W,Q)=>{if(J.pending_buf[J.sym_buf+J.sym_next++]=W,J.pending_buf[J.sym_buf+J.sym_next++]=W>>8,J.pending_buf[J.sym_buf+J.sym_next++]=Q,W===0)J.dyn_ltree[Q*2]++;else J.matches++,W--,J.dyn_ltree[(D0[Q]+E0+1)*2]++,J.dyn_dtree[a8(W)*2]++;return J.sym_next===J.sym_end},YJ=GJ,FJ=Q6,KJ=XJ,zJ=PJ,kJ=UJ,ZJ={_tr_init:YJ,_tr_stored_block:FJ,_tr_flush_block:KJ,_tr_tally:zJ,_tr_align:kJ},HJ=(J,W,Q,V)=>{let q=J&65535|0,G=J>>>16&65535|0,P=0;while(Q!==0){P=Q>2000?2000:Q,Q-=P;do q=q+W[V++]|0,G=G+q|0;while(--P);q%=65521,G%=65521}return q|G<<16|0},T0=HJ,CJ=()=>{let J,W=[];for(var Q=0;Q<256;Q++){J=Q;for(var V=0;V<8;V++)J=J&1?3988292384^J>>>1:J>>>1;W[Q]=J}return W},NJ=new Uint32Array(CJ()),$J=(J,W,Q,V)=>{const q=NJ,G=V+Q;J^=-1;for(let P=V;P<G;P++)J=J>>>8^q[(J^W[P])&255];return J^-1},T=$J,V0={2:"need dictionary",1:"stream end",0:"","-1":"file error","-2":"stream error","-3":"data error","-4":"insufficient memory","-5":"buffer error","-6":"incompatible version"},U0={Z_NO_FLUSH:0,Z_PARTIAL_FLUSH:1,Z_SYNC_FLUSH:2,Z_FULL_FLUSH:3,Z_FINISH:4,Z_BLOCK:5,Z_TREES:6,Z_OK:0,Z_STREAM_END:1,Z_NEED_DICT:2,Z_ERRNO:-1,Z_STREAM_ERROR:-2,Z_DATA_ERROR:-3,Z_MEM_ERROR:-4,Z_BUF_ERROR:-5,Z_NO_COMPRESSION:0,Z_BEST_SPEED:1,Z_BEST_COMPRESSION:9,Z_DEFAULT_COMPRESSION:-1,Z_FILTERED:1,Z_HUFFMAN_ONLY:2,Z_RLE:3,Z_FIXED:4,Z_DEFAULT_STRATEGY:0,Z_BINARY:0,Z_TEXT:1,Z_UNKNOWN:2,Z_DEFLATED:8},{_tr_init:gJ,_tr_stored_block:x1,_tr_flush_block:IJ,_tr_tally:o,_tr_align:jJ}=ZJ,{Z_NO_FLUSH:a,Z_PARTIAL_FLUSH:MJ,Z_FULL_FLUSH:LJ,Z_FINISH:f,Z_BLOCK:P8,Z_OK:S,Z_STREAM_END:Y8,Z_STREAM_ERROR:u,Z_DATA_ERROR:BJ,Z_BUF_ERROR:C1,Z_DEFAULT_COMPRESSION:RJ,Z_FILTERED:wJ,Z_HUFFMAN_ONLY:n0,Z_RLE:OJ,Z_FIXED:xJ,Z_DEFAULT_STRATEGY:DJ,Z_UNKNOWN:AJ,Z_DEFLATED:V1}=U0,TJ=9,SJ=15,vJ=8,yJ=29,EJ=256,D1=EJ+1+yJ,pJ=30,hJ=19,fJ=2*D1+1,mJ=15,j=3,n=258,d=n+j+1,bJ=32,k0=42,m1=57,A1=69,T1=73,S1=91,v1=103,Q0=113,M0=666,y=1,C0=2,q0=3,N0=4,cJ=3,W0=(J,W)=>{return J.msg=V0[W],W},F8=(J)=>{return J*2-(J>4?9:0)},r=(J)=>{let W=J.length;while(--W>=0)J[W]=0},uJ=(J)=>{let W,Q,V,q=J.w_size;W=J.hash_size,V=W;do Q=J.head[--V],J.head[V]=Q>=q?Q-q:0;while(--W);W=q,V=W;do Q=J.prev[--V],J.prev[V]=Q>=q?Q-q:0;while(--W)},dJ=(J,W,Q)=>(W<<J.hash_shift^Q)&J.hash_mask,e=dJ,p=(J)=>{const W=J.state;let Q=W.pending;if(Q>J.avail_out)Q=J.avail_out;if(Q===0)return;if(J.output.set(W.pending_buf.subarray(W.pending_out,W.pending_out+Q),J.next_out),J.next_out+=Q,W.pending_out+=Q,J.total_out+=Q,J.avail_out-=Q,W.pending-=Q,W.pending===0)W.pending_out=0},h=(J,W)=>{IJ(J,J.block_start>=0?J.block_start:-1,J.strstart-J.block_start,W),J.block_start=J.strstart,p(J.strm)},R=(J,W)=>{J.pending_buf[J.pending++]=W},j0=(J,W)=>{J.pending_buf[J.pending++]=W>>>8&255,J.pending_buf[J.pending++]=W&255},y1=(J,W,Q,V)=>{let q=J.avail_in;if(q>V)q=V;if(q===0)return 0;if(J.avail_in-=q,W.set(J.input.subarray(J.next_in,J.next_in+q),Q),J.state.wrap===1)J.adler=T0(J.adler,W,q,Q);else if(J.state.wrap===2)J.adler=T(J.adler,W,q,Q);return J.next_in+=q,J.total_in+=q,q},W6=(J,W)=>{let{max_chain_length:Q,strstart:V}=J,q,G,P=J.prev_length,U=J.nice_match;const K=J.strstart>J.w_size-d?J.strstart-(J.w_size-d):0,X=J.window,Y=J.w_mask,$=J.prev,k=J.strstart+n;let F=X[V+P-1],Z=X[V+P];if(J.prev_length>=J.good_match)Q>>=2;if(U>J.lookahead)U=J.lookahead;do{if(q=W,X[q+P]!==Z||X[q+P-1]!==F||X[q]!==X[V]||X[++q]!==X[V+1])continue;V+=2,q++;do;while(X[++V]===X[++q]&&X[++V]===X[++q]&&X[++V]===X[++q]&&X[++V]===X[++q]&&X[++V]===X[++q]&&X[++V]===X[++q]&&X[++V]===X[++q]&&X[++V]===X[++q]&&V<k);if(G=n-(k-V),V=k-n,G>P){if(J.match_start=W,P=G,G>=U)break;F=X[V+P-1],Z=X[V+P]}}while((W=$[W&Y])>K&&--Q!==0);if(P<=J.lookahead)return P;return J.lookahead},Z0=(J)=>{const W=J.w_size;let Q,V,q;do{if(V=J.window_size-J.lookahead-J.strstart,J.strstart>=W+(W-d)){if(J.window.set(J.window.subarray(W,W+W-V),0),J.match_start-=W,J.strstart-=W,J.block_start-=W,J.insert>J.strstart)J.insert=J.strstart;uJ(J),V+=W}if(J.strm.avail_in===0)break;if(Q=y1(J.strm,J.window,J.strstart+J.lookahead,V),J.lookahead+=Q,J.lookahead+J.insert>=j){q=J.strstart-J.insert,J.ins_h=J.window[q],J.ins_h=e(J,J.ins_h,J.window[q+1]);while(J.insert)if(J.ins_h=e(J,J.ins_h,J.window[q+j-1]),J.prev[q&J.w_mask]=J.head[J.ins_h],J.head[J.ins_h]=q,q++,J.insert--,J.lookahead+J.insert<j)break}}while(J.lookahead<d&&J.strm.avail_in!==0)},V6=(J,W)=>{let Q=J.pending_buf_size-5>J.w_size?J.w_size:J.pending_buf_size-5,V,q,G,P=0,U=J.strm.avail_in;do{if(V=65535,G=J.bi_valid+42>>3,J.strm.avail_out<G)break;if(G=J.strm.avail_out-G,q=J.strstart-J.block_start,V>q+J.strm.avail_in)V=q+J.strm.avail_in;if(V>G)V=G;if(V<Q&&(V===0&&W!==f||W===a||V!==q+J.strm.avail_in))break;if(P=W===f&&V===q+J.strm.avail_in?1:0,x1(J,0,0,P),J.pending_buf[J.pending-4]=V,J.pending_buf[J.pending-3]=V>>8,J.pending_buf[J.pending-2]=~V,J.pending_buf[J.pending-1]=~V>>8,p(J.strm),q){if(q>V)q=V;J.strm.output.set(J.window.subarray(J.block_start,J.block_start+q),J.strm.next_out),J.strm.next_out+=q,J.strm.avail_out-=q,J.strm.total_out+=q,J.block_start+=q,V-=q}if(V)y1(J.strm,J.strm.output,J.strm.next_out,V),J.strm.next_out+=V,J.strm.avail_out-=V,J.strm.total_out+=V}while(P===0);if(U-=J.strm.avail_in,U){if(U>=J.w_size)J.matches=2,J.window.set(J.strm.input.subarray(J.strm.next_in-J.w_size,J.strm.next_in),0),J.strstart=J.w_size,J.insert=J.strstart;else{if(J.window_size-J.strstart<=U){if(J.strstart-=J.w_size,J.window.set(J.window.subarray(J.w_size,J.w_size+J.strstart),0),J.matches<2)J.matches++;if(J.insert>J.strstart)J.insert=J.strstart}J.window.set(J.strm.input.subarray(J.strm.next_in-U,J.strm.next_in),J.strstart),J.strstart+=U,J.insert+=U>J.w_size-J.insert?J.w_size-J.insert:U}J.block_start=J.strstart}if(J.high_water<J.strstart)J.high_water=J.strstart;if(P)return N0;if(W!==a&&W!==f&&J.strm.avail_in===0&&J.strstart===J.block_start)return C0;if(G=J.window_size-J.strstart,J.strm.avail_in>G&&J.block_start>=J.w_size){if(J.block_start-=J.w_size,J.strstart-=J.w_size,J.window.set(J.window.subarray(J.w_size,J.w_size+J.strstart),0),J.matches<2)J.matches++;if(G+=J.w_size,J.insert>J.strstart)J.insert=J.strstart}if(G>J.strm.avail_in)G=J.strm.avail_in;if(G)y1(J.strm,J.window,J.strstart,G),J.strstart+=G,J.insert+=G>J.w_size-J.insert?J.w_size-J.insert:G;if(J.high_water<J.strstart)J.high_water=J.strstart;if(G=J.bi_valid+42>>3,G=J.pending_buf_size-G>65535?65535:J.pending_buf_size-G,Q=G>J.w_size?J.w_size:G,q=J.strstart-J.block_start,q>=Q||(q||W===f)&&W!==a&&J.strm.avail_in===0&&q<=G)V=q>G?G:q,P=W===f&&J.strm.avail_in===0&&V===q?1:0,x1(J,J.block_start,V,P),J.block_start+=V,p(J.strm);return P?q0:y},N1=(J,W)=>{let Q,V;for(;;){if(J.lookahead<d){if(Z0(J),J.lookahead<d&&W===a)return y;if(J.lookahead===0)break}if(Q=0,J.lookahead>=j)J.ins_h=e(J,J.ins_h,J.window[J.strstart+j-1]),Q=J.prev[J.strstart&J.w_mask]=J.head[J.ins_h],J.head[J.ins_h]=J.strstart;if(Q!==0&&J.strstart-Q<=J.w_size-d)J.match_length=W6(J,Q);if(J.match_length>=j)if(V=o(J,J.strstart-J.match_start,J.match_length-j),J.lookahead-=J.match_length,J.match_length<=J.max_lazy_match&&J.lookahead>=j){J.match_length--;do J.strstart++,J.ins_h=e(J,J.ins_h,J.window[J.strstart+j-1]),Q=J.prev[J.strstart&J.w_mask]=J.head[J.ins_h],J.head[J.ins_h]=J.strstart;while(--J.match_length!==0);J.strstart++}else J.strstart+=J.match_length,J.match_length=0,J.ins_h=J.window[J.strstart],J.ins_h=e(J,J.ins_h,J.window[J.strstart+1]);else V=o(J,0,J.window[J.strstart]),J.lookahead--,J.strstart++;if(V){if(h(J,!1),J.strm.avail_out===0)return y}}if(J.insert=J.strstart<j-1?J.strstart:j-1,W===f){if(h(J,!0),J.strm.avail_out===0)return q0;return N0}if(J.sym_next){if(h(J,!1),J.strm.avail_out===0)return y}return C0},F0=(J,W)=>{let Q,V,q;for(;;){if(J.lookahead<d){if(Z0(J),J.lookahead<d&&W===a)return y;if(J.lookahead===0)break}if(Q=0,J.lookahead>=j)J.ins_h=e(J,J.ins_h,J.window[J.strstart+j-1]),Q=J.prev[J.strstart&J.w_mask]=J.head[J.ins_h],J.head[J.ins_h]=J.strstart;if(J.prev_length=J.match_length,J.prev_match=J.match_start,J.match_length=j-1,Q!==0&&J.prev_length<J.max_lazy_match&&J.strstart-Q<=J.w_size-d){if(J.match_length=W6(J,Q),J.match_length<=5&&(J.strategy===wJ||J.match_length===j&&J.strstart-J.match_start>4096))J.match_length=j-1}if(J.prev_length>=j&&J.match_length<=J.prev_length){q=J.strstart+J.lookahead-j,V=o(J,J.strstart-1-J.prev_match,J.prev_length-j),J.lookahead-=J.prev_length-1,J.prev_length-=2;do if(++J.strstart<=q)J.ins_h=e(J,J.ins_h,J.window[J.strstart+j-1]),Q=J.prev[J.strstart&J.w_mask]=J.head[J.ins_h],J.head[J.ins_h]=J.strstart;while(--J.prev_length!==0);if(J.match_available=0,J.match_length=j-1,J.strstart++,V){if(h(J,!1),J.strm.avail_out===0)return y}}else if(J.match_available){if(V=o(J,0,J.window[J.strstart-1]),V)h(J,!1);if(J.strstart++,J.lookahead--,J.strm.avail_out===0)return y}else J.match_available=1,J.strstart++,J.lookahead--}if(J.match_available)V=o(J,0,J.window[J.strstart-1]),J.match_available=0;if(J.insert=J.strstart<j-1?J.strstart:j-1,W===f){if(h(J,!0),J.strm.avail_out===0)return q0;return N0}if(J.sym_next){if(h(J,!1),J.strm.avail_out===0)return y}return C0},iJ=(J,W)=>{let Q,V,q,G;const P=J.window;for(;;){if(J.lookahead<=n){if(Z0(J),J.lookahead<=n&&W===a)return y;if(J.lookahead===0)break}if(J.match_length=0,J.lookahead>=j&&J.strstart>0){if(q=J.strstart-1,V=P[q],V===P[++q]&&V===P[++q]&&V===P[++q]){G=J.strstart+n;do;while(V===P[++q]&&V===P[++q]&&V===P[++q]&&V===P[++q]&&V===P[++q]&&V===P[++q]&&V===P[++q]&&V===P[++q]&&q<G);if(J.match_length=n-(G-q),J.match_length>J.lookahead)J.match_length=J.lookahead}}if(J.match_length>=j)Q=o(J,1,J.match_length-j),J.lookahead-=J.match_length,J.strstart+=J.match_length,J.match_length=0;else Q=o(J,0,J.window[J.strstart]),J.lookahead--,J.strstart++;if(Q){if(h(J,!1),J.strm.avail_out===0)return y}}if(J.insert=0,W===f){if(h(J,!0),J.strm.avail_out===0)return q0;return N0}if(J.sym_next){if(h(J,!1),J.strm.avail_out===0)return y}return C0},lJ=(J,W)=>{let Q;for(;;){if(J.lookahead===0){if(Z0(J),J.lookahead===0){if(W===a)return y;break}}if(J.match_length=0,Q=o(J,0,J.window[J.strstart]),J.lookahead--,J.strstart++,Q){if(h(J,!1),J.strm.avail_out===0)return y}}if(J.insert=0,W===f){if(h(J,!0),J.strm.avail_out===0)return q0;return N0}if(J.sym_next){if(h(J,!1),J.strm.avail_out===0)return y}return C0},L0=[new b(0,0,0,0,V6),new b(4,4,8,4,N1),new b(4,5,16,8,N1),new b(4,6,32,32,N1),new b(4,4,16,16,F0),new b(8,16,32,32,F0),new b(8,16,128,128,F0),new b(8,32,128,256,F0),new b(32,128,258,1024,F0),new b(32,258,258,4096,F0)],_J=(J)=>{J.window_size=2*J.w_size,r(J.head),J.max_lazy_match=L0[J.level].max_lazy,J.good_match=L0[J.level].good_length,J.nice_match=L0[J.level].nice_length,J.max_chain_length=L0[J.level].max_chain,J.strstart=0,J.block_start=0,J.lookahead=0,J.insert=0,J.match_length=J.prev_length=j-1,J.match_available=0,J.ins_h=0},p0=(J)=>{if(!J)return 1;const W=J.state;if(!W||W.strm!==J||W.status!==k0&&W.status!==m1&&W.status!==A1&&W.status!==T1&&W.status!==S1&&W.status!==v1&&W.status!==Q0&&W.status!==M0)return 1;return 0},q6=(J)=>{if(p0(J))return W0(J,u);J.total_in=J.total_out=0,J.data_type=AJ;const W=J.state;if(W.pending=0,W.pending_out=0,W.wrap<0)W.wrap=-W.wrap;return W.status=W.wrap===2?m1:W.wrap?k0:Q0,J.adler=W.wrap===2?0:1,W.last_flush=-2,gJ(W),S},G6=(J)=>{const W=q6(J);if(W===S)_J(J.state);return W},nJ=(J,W)=>{if(p0(J)||J.state.wrap!==2)return u;return J.state.gzhead=W,S},U6=(J,W,Q,V,q,G)=>{if(!J)return u;let P=1;if(W===RJ)W=6;if(V<0)P=0,V=-V;else if(V>15)P=2,V-=16;if(q<1||q>TJ||Q!==V1||V<8||V>15||W<0||W>9||G<0||G>xJ||V===8&&P!==1)return W0(J,u);if(V===8)V=9;const U=new rJ;return J.state=U,U.strm=J,U.status=k0,U.wrap=P,U.gzhead=null,U.w_bits=V,U.w_size=1<<U.w_bits,U.w_mask=U.w_size-1,U.hash_bits=q+7,U.hash_size=1<<U.hash_bits,U.hash_mask=U.hash_size-1,U.hash_shift=~~((U.hash_bits+j-1)/j),U.window=new Uint8Array(U.w_size*2),U.head=new Uint16Array(U.hash_size),U.prev=new Uint16Array(U.w_size),U.lit_bufsize=1<<q+6,U.pending_buf_size=U.lit_bufsize*4,U.pending_buf=new Uint8Array(U.pending_buf_size),U.sym_buf=U.lit_bufsize,U.sym_end=(U.lit_bufsize-1)*3,U.level=W,U.strategy=G,U.method=Q,G6(J)},oJ=(J,W)=>{return U6(J,W,V1,SJ,vJ,DJ)},aJ=(J,W)=>{if(p0(J)||W>P8||W<0)return J?W0(J,u):u;const Q=J.state;if(!J.output||J.avail_in!==0&&!J.input||Q.status===M0&&W!==f)return W0(J,J.avail_out===0?C1:u);const V=Q.last_flush;if(Q.last_flush=W,Q.pending!==0){if(p(J),J.avail_out===0)return Q.last_flush=-1,S}else if(J.avail_in===0&&F8(W)<=F8(V)&&W!==f)return W0(J,C1);if(Q.status===M0&&J.avail_in!==0)return W0(J,C1);if(Q.status===k0&&Q.wrap===0)Q.status=Q0;if(Q.status===k0){let q=V1+(Q.w_bits-8<<4)<<8,G=-1;if(Q.strategy>=n0||Q.level<2)G=0;else if(Q.level<6)G=1;else if(Q.level===6)G=2;else G=3;if(q|=G<<6,Q.strstart!==0)q|=bJ;if(q+=31-q%31,j0(Q,q),Q.strstart!==0)j0(Q,J.adler>>>16),j0(Q,J.adler&65535);if(J.adler=1,Q.status=Q0,p(J),Q.pending!==0)return Q.last_flush=-1,S}if(Q.status===m1)if(J.adler=0,R(Q,31),R(Q,139),R(Q,8),!Q.gzhead){if(R(Q,0),R(Q,0),R(Q,0),R(Q,0),R(Q,0),R(Q,Q.level===9?2:Q.strategy>=n0||Q.level<2?4:0),R(Q,cJ),Q.status=Q0,p(J),Q.pending!==0)return Q.last_flush=-1,S}else{if(R(Q,(Q.gzhead.text?1:0)+(Q.gzhead.hcrc?2:0)+(!Q.gzhead.extra?0:4)+(!Q.gzhead.name?0:8)+(!Q.gzhead.comment?0:16)),R(Q,Q.gzhead.time&255),R(Q,Q.gzhead.time>>8&255),R(Q,Q.gzhead.time>>16&255),R(Q,Q.gzhead.time>>24&255),R(Q,Q.level===9?2:Q.strategy>=n0||Q.level<2?4:0),R(Q,Q.gzhead.os&255),Q.gzhead.extra&&Q.gzhead.extra.length)R(Q,Q.gzhead.extra.length&255),R(Q,Q.gzhead.extra.length>>8&255);if(Q.gzhead.hcrc)J.adler=T(J.adler,Q.pending_buf,Q.pending,0);Q.gzindex=0,Q.status=A1}if(Q.status===A1){if(Q.gzhead.extra){let q=Q.pending,G=(Q.gzhead.extra.length&65535)-Q.gzindex;while(Q.pending+G>Q.pending_buf_size){let U=Q.pending_buf_size-Q.pending;if(Q.pending_buf.set(Q.gzhead.extra.subarray(Q.gzindex,Q.gzindex+U),Q.pending),Q.pending=Q.pending_buf_size,Q.gzhead.hcrc&&Q.pending>q)J.adler=T(J.adler,Q.pending_buf,Q.pending-q,q);if(Q.gzindex+=U,p(J),Q.pending!==0)return Q.last_flush=-1,S;q=0,G-=U}let P=new Uint8Array(Q.gzhead.extra);if(Q.pending_buf.set(P.subarray(Q.gzindex,Q.gzindex+G),Q.pending),Q.pending+=G,Q.gzhead.hcrc&&Q.pending>q)J.adler=T(J.adler,Q.pending_buf,Q.pending-q,q);Q.gzindex=0}Q.status=T1}if(Q.status===T1){if(Q.gzhead.name){let q=Q.pending,G;do{if(Q.pending===Q.pending_buf_size){if(Q.gzhead.hcrc&&Q.pending>q)J.adler=T(J.adler,Q.pending_buf,Q.pending-q,q);if(p(J),Q.pending!==0)return Q.last_flush=-1,S;q=0}if(Q.gzindex<Q.gzhead.name.length)G=Q.gzhead.name.charCodeAt(Q.gzindex++)&255;else G=0;R(Q,G)}while(G!==0);if(Q.gzhead.hcrc&&Q.pending>q)J.adler=T(J.adler,Q.pending_buf,Q.pending-q,q);Q.gzindex=0}Q.status=S1}if(Q.status===S1){if(Q.gzhead.comment){let q=Q.pending,G;do{if(Q.pending===Q.pending_buf_size){if(Q.gzhead.hcrc&&Q.pending>q)J.adler=T(J.adler,Q.pending_buf,Q.pending-q,q);if(p(J),Q.pending!==0)return Q.last_flush=-1,S;q=0}if(Q.gzindex<Q.gzhead.comment.length)G=Q.gzhead.comment.charCodeAt(Q.gzindex++)&255;else G=0;R(Q,G)}while(G!==0);if(Q.gzhead.hcrc&&Q.pending>q)J.adler=T(J.adler,Q.pending_buf,Q.pending-q,q)}Q.status=v1}if(Q.status===v1){if(Q.gzhead.hcrc){if(Q.pending+2>Q.pending_buf_size){if(p(J),Q.pending!==0)return Q.last_flush=-1,S}R(Q,J.adler&255),R(Q,J.adler>>8&255),J.adler=0}if(Q.status=Q0,p(J),Q.pending!==0)return Q.last_flush=-1,S}if(J.avail_in!==0||Q.lookahead!==0||W!==a&&Q.status!==M0){let q=Q.level===0?V6(Q,W):Q.strategy===n0?lJ(Q,W):Q.strategy===OJ?iJ(Q,W):L0[Q.level].func(Q,W);if(q===q0||q===N0)Q.status=M0;if(q===y||q===q0){if(J.avail_out===0)Q.last_flush=-1;return S}if(q===C0){if(W===MJ)jJ(Q);else if(W!==P8){if(x1(Q,0,0,!1),W===LJ){if(r(Q.head),Q.lookahead===0)Q.strstart=0,Q.block_start=0,Q.insert=0}}if(p(J),J.avail_out===0)return Q.last_flush=-1,S}}if(W!==f)return S;if(Q.wrap<=0)return Y8;if(Q.wrap===2)R(Q,J.adler&255),R(Q,J.adler>>8&255),R(Q,J.adler>>16&255),R(Q,J.adler>>24&255),R(Q,J.total_in&255),R(Q,J.total_in>>8&255),R(Q,J.total_in>>16&255),R(Q,J.total_in>>24&255);else j0(Q,J.adler>>>16),j0(Q,J.adler&65535);if(p(J),Q.wrap>0)Q.wrap=-Q.wrap;return Q.pending!==0?S:Y8},eJ=(J)=>{if(p0(J))return u;const W=J.state.status;return J.state=null,W===Q0?W0(J,BJ):S},tJ=(J,W)=>{let Q=W.length;if(p0(J))return u;const V=J.state,q=V.wrap;if(q===2||q===1&&V.status!==k0||V.lookahead)return u;if(q===1)J.adler=T0(J.adler,W,Q,0);if(V.wrap=0,Q>=V.w_size){if(q===0)r(V.head),V.strstart=0,V.block_start=0,V.insert=0;let K=new Uint8Array(V.w_size);K.set(W.subarray(Q-V.w_size,Q),0),W=K,Q=V.w_size}const{avail_in:G,next_in:P,input:U}=J;J.avail_in=Q,J.next_in=0,J.input=W,Z0(V);while(V.lookahead>=j){let K=V.strstart,X=V.lookahead-(j-1);do V.ins_h=e(V,V.ins_h,V.window[K+j-1]),V.prev[K&V.w_mask]=V.head[V.ins_h],V.head[V.ins_h]=K,K++;while(--X);V.strstart=K,V.lookahead=j-1,Z0(V)}return V.strstart+=V.lookahead,V.block_start=V.strstart,V.insert=V.lookahead,V.lookahead=0,V.match_length=V.prev_length=j-1,V.match_available=0,J.next_in=P,J.input=U,J.avail_in=G,V.wrap=q,S},sJ=oJ,JQ=U6,QQ=G6,WQ=q6,VQ=nJ,qQ=aJ,GQ=eJ,UQ=tJ,XQ="pako deflate (from Nodeca project)",R0={deflateInit:sJ,deflateInit2:JQ,deflateReset:QQ,deflateResetKeep:WQ,deflateSetHeader:VQ,deflate:qQ,deflateEnd:GQ,deflateSetDictionary:UQ,deflateInfo:XQ},PQ=(J,W)=>{return Object.prototype.hasOwnProperty.call(J,W)},YQ=function(J){const W=Array.prototype.slice.call(arguments,1);while(W.length){const Q=W.shift();if(!Q)continue;if(typeof Q!=="object")throw new TypeError(Q+"must be non-object");for(let V in Q)if(PQ(Q,V))J[V]=Q[V]}return J},FQ=(J)=>{let W=0;for(let V=0,q=J.length;V<q;V++)W+=J[V].length;const Q=new Uint8Array(W);for(let V=0,q=0,G=J.length;V<G;V++){let P=J[V];Q.set(P,q),q+=P.length}return Q},q1={assign:YQ,flattenChunks:FQ},X6=!0;try{String.fromCharCode.apply(null,new Uint8Array(1))}catch(J){X6=!1}var S0=new Uint8Array(256);for(let J=0;J<256;J++)S0[J]=J>=252?6:J>=248?5:J>=240?4:J>=224?3:J>=192?2:1;S0[254]=S0[254]=1;var KQ=(J)=>{if(typeof TextEncoder==="function"&&TextEncoder.prototype.encode)return(new TextEncoder()).encode(J);let W,Q,V,q,G,P=J.length,U=0;for(q=0;q<P;q++){if(Q=J.charCodeAt(q),(Q&64512)===55296&&q+1<P){if(V=J.charCodeAt(q+1),(V&64512)===56320)Q=65536+(Q-55296<<10)+(V-56320),q++}U+=Q<128?1:Q<2048?2:Q<65536?3:4}W=new Uint8Array(U);for(G=0,q=0;G<U;q++){if(Q=J.charCodeAt(q),(Q&64512)===55296&&q+1<P){if(V=J.charCodeAt(q+1),(V&64512)===56320)Q=65536+(Q-55296<<10)+(V-56320),q++}if(Q<128)W[G++]=Q;else if(Q<2048)W[G++]=192|Q>>>6,W[G++]=128|Q&63;else if(Q<65536)W[G++]=224|Q>>>12,W[G++]=128|Q>>>6&63,W[G++]=128|Q&63;else W[G++]=240|Q>>>18,W[G++]=128|Q>>>12&63,W[G++]=128|Q>>>6&63,W[G++]=128|Q&63}return W},zQ=(J,W)=>{if(W<65534){if(J.subarray&&X6)return String.fromCharCode.apply(null,J.length===W?J:J.subarray(0,W))}let Q="";for(let V=0;V<W;V++)Q+=String.fromCharCode(J[V]);return Q},kQ=(J,W)=>{const Q=W||J.length;if(typeof TextDecoder==="function"&&TextDecoder.prototype.decode)return(new TextDecoder()).decode(J.subarray(0,W));let V,q;const G=new Array(Q*2);for(q=0,V=0;V<Q;){let P=J[V++];if(P<128){G[q++]=P;continue}let U=S0[P];if(U>4){G[q++]=65533,V+=U-1;continue}P&=U===2?31:U===3?15:7;while(U>1&&V<Q)P=P<<6|J[V++]&63,U--;if(U>1){G[q++]=65533;continue}if(P<65536)G[q++]=P;else P-=65536,G[q++]=55296|P>>10&1023,G[q++]=56320|P&1023}return zQ(G,q)},ZQ=(J,W)=>{if(W=W||J.length,W>J.length)W=J.length;let Q=W-1;while(Q>=0&&(J[Q]&192)===128)Q--;if(Q<0)return W;if(Q===0)return W;return Q+S0[J[Q]]>W?Q:W},v0={string2buf:KQ,buf2string:kQ,utf8border:ZQ},P6=HQ,Y6=Object.prototype.toString,{Z_NO_FLUSH:CQ,Z_SYNC_FLUSH:NQ,Z_FULL_FLUSH:$Q,Z_FINISH:gQ,Z_OK:Q1,Z_STREAM_END:IQ,Z_DEFAULT_COMPRESSION:jQ,Z_DEFAULT_STRATEGY:MQ,Z_DEFLATED:LQ}=U0;h0.prototype.push=function(J,W){const Q=this.strm,V=this.options.chunkSize;let q,G;if(this.ended)return!1;if(W===~~W)G=W;else G=W===!0?gQ:CQ;if(typeof J==="string")Q.input=v0.string2buf(J);else if(Y6.call(J)==="[object ArrayBuffer]")Q.input=new Uint8Array(J);else Q.input=J;Q.next_in=0,Q.avail_in=Q.input.length;for(;;){if(Q.avail_out===0)Q.output=new Uint8Array(V),Q.next_out=0,Q.avail_out=V;if((G===NQ||G===$Q)&&Q.avail_out<=6){this.onData(Q.output.subarray(0,Q.next_out)),Q.avail_out=0;continue}if(q=R0.deflate(Q,G),q===IQ){if(Q.next_out>0)this.onData(Q.output.subarray(0,Q.next_out));return q=R0.deflateEnd(this.strm),this.onEnd(q),this.ended=!0,q===Q1}if(Q.avail_out===0){this.onData(Q.output);continue}if(G>0&&Q.next_out>0){this.onData(Q.output.subarray(0,Q.next_out)),Q.avail_out=0;continue}if(Q.avail_in===0)break}return!0};h0.prototype.onData=function(J){this.chunks.push(J)};h0.prototype.onEnd=function(J){if(J===Q1)this.result=q1.flattenChunks(this.chunks);this.chunks=[],this.err=J,this.msg=this.strm.msg};var wQ=h0,OQ=b1,xQ=BQ,DQ=RQ,AQ=U0,TQ={Deflate:wQ,deflate:OQ,deflateRaw:xQ,gzip:DQ,constants:AQ},o0=16209,SQ=16191,vQ=function J(W,Q){let V,q,G,P,U,K,X,Y,$,k,F,Z,D,M,N,w,g,z,B,A,H,O,L,C;const I=W.state;V=W.next_in,L=W.input,q=V+(W.avail_in-5),G=W.next_out,C=W.output,P=G-(Q-W.avail_out),U=G+(W.avail_out-257),K=I.dmax,X=I.wsize,Y=I.whave,$=I.wnext,k=I.window,F=I.hold,Z=I.bits,D=I.lencode,M=I.distcode,N=(1<<I.lenbits)-1,w=(1<<I.distbits)-1;J:do{if(Z<15)F+=L[V++]<<Z,Z+=8,F+=L[V++]<<Z,Z+=8;g=D[F&N];Q:for(;;){if(z=g>>>24,F>>>=z,Z-=z,z=g>>>16&255,z===0)C[G++]=g&65535;else if(z&16){if(B=g&65535,z&=15,z){if(Z<z)F+=L[V++]<<Z,Z+=8;B+=F&(1<<z)-1,F>>>=z,Z-=z}if(Z<15)F+=L[V++]<<Z,Z+=8,F+=L[V++]<<Z,Z+=8;g=M[F&w];W:for(;;){if(z=g>>>24,F>>>=z,Z-=z,z=g>>>16&255,z&16){if(A=g&65535,z&=15,Z<z){if(F+=L[V++]<<Z,Z+=8,Z<z)F+=L[V++]<<Z,Z+=8}if(A+=F&(1<<z)-1,A>K){W.msg="invalid distance too far back",I.mode=o0;break J}if(F>>>=z,Z-=z,z=G-P,A>z){if(z=A-z,z>Y){if(I.sane){W.msg="invalid distance too far back",I.mode=o0;break J}}if(H=0,O=k,$===0){if(H+=X-z,z<B){B-=z;do C[G++]=k[H++];while(--z);H=G-A,O=C}}else if($<z){if(H+=X+$-z,z-=$,z<B){B-=z;do C[G++]=k[H++];while(--z);if(H=0,$<B){z=$,B-=z;do C[G++]=k[H++];while(--z);H=G-A,O=C}}}else if(H+=$-z,z<B){B-=z;do C[G++]=k[H++];while(--z);H=G-A,O=C}while(B>2)C[G++]=O[H++],C[G++]=O[H++],C[G++]=O[H++],B-=3;if(B){if(C[G++]=O[H++],B>1)C[G++]=O[H++]}}else{H=G-A;do C[G++]=C[H++],C[G++]=C[H++],C[G++]=C[H++],B-=3;while(B>2);if(B){if(C[G++]=C[H++],B>1)C[G++]=C[H++]}}}else if((z&64)===0){g=M[(g&65535)+(F&(1<<z)-1)];continue W}else{W.msg="invalid distance code",I.mode=o0;break J}break}}else if((z&64)===0){g=D[(g&65535)+(F&(1<<z)-1)];continue Q}else if(z&32){I.mode=SQ;break J}else{W.msg="invalid literal/length code",I.mode=o0;break J}break}}while(V<q&&G<U);B=Z>>3,V-=B,Z-=B<<3,F&=(1<<Z)-1,W.next_in=V,W.next_out=G,W.avail_in=V<q?5+(q-V):5-(V-q),W.avail_out=G<U?257+(U-G):257-(G-U),I.hold=F,I.bits=Z;return},K0=15,K8=852,z8=592,k8=0,$1=1,Z8=2,yQ=new Uint16Array([3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,0,0]),EQ=new Uint8Array([16,16,16,16,16,16,16,16,17,17,17,17,18,18,18,18,19,19,19,19,20,20,20,20,21,21,21,21,16,72,78]),pQ=new Uint16Array([1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,0,0]),hQ=new Uint8Array([16,16,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,64,64]),fQ=(J,W,Q,V,q,G,P,U)=>{const K=U.bits;let X=0,Y=0,$=0,k=0,F=0,Z=0,D=0,M=0,N=0,w=0,g,z,B,A,H,O=null,L;const C=new Uint16Array(K0+1),I=new Uint16Array(K0+1);let t=null,l1,m0,b0;for(X=0;X<=K0;X++)C[X]=0;for(Y=0;Y<V;Y++)C[W[Q+Y]]++;F=K;for(k=K0;k>=1;k--)if(C[k]!==0)break;if(F>k)F=k;if(k===0)return q[G++]=1<<24|64<<16|0,q[G++]=1<<24|64<<16|0,U.bits=1,0;for($=1;$<k;$++)if(C[$]!==0)break;if(F<$)F=$;M=1;for(X=1;X<=K0;X++)if(M<<=1,M-=C[X],M<0)return-1;if(M>0&&(J===k8||k!==1))return-1;I[1]=0;for(X=1;X<K0;X++)I[X+1]=I[X]+C[X];for(Y=0;Y<V;Y++)if(W[Q+Y]!==0)P[I[W[Q+Y]]++]=Y;if(J===k8)O=t=P,L=20;else if(J===$1)O=yQ,t=EQ,L=257;else O=pQ,t=hQ,L=0;if(w=0,Y=0,X=$,H=G,Z=F,D=0,B=-1,N=1<<F,A=N-1,J===$1&&N>K8||J===Z8&&N>z8)return 1;for(;;){if(l1=X-D,P[Y]+1<L)m0=0,b0=P[Y];else if(P[Y]>=L)m0=t[P[Y]-L],b0=O[P[Y]-L];else m0=96,b0=0;g=1<<X-D,z=1<<Z,$=z;do z-=g,q[H+(w>>D)+z]=l1<<24|m0<<16|b0|0;while(z!==0);g=1<<X-1;while(w&g)g>>=1;if(g!==0)w&=g-1,w+=g;else w=0;if(Y++,--C[X]===0){if(X===k)break;X=W[Q+P[Y]]}if(X>F&&(w&A)!==B){if(D===0)D=F;H+=$,Z=X-D,M=1<<Z;while(Z+D<k){if(M-=C[Z+D],M<=0)break;Z++,M<<=1}if(N+=1<<Z,J===$1&&N>K8||J===Z8&&N>z8)return 1;B=w&A,q[B]=F<<24|Z<<16|H-G|0}}if(w!==0)q[H+w]=X-D<<24|64<<16|0;return U.bits=F,0},w0=fQ,mQ=0,F6=1,K6=2,{Z_FINISH:H8,Z_BLOCK:bQ,Z_TREES:a0,Z_OK:G0,Z_STREAM_END:cQ,Z_NEED_DICT:uQ,Z_STREAM_ERROR:m,Z_DATA_ERROR:z6,Z_MEM_ERROR:k6,Z_BUF_ERROR:dQ,Z_DEFLATED:C8}=U0,G1=16180,N8=16181,$8=16182,g8=16183,I8=16184,j8=16185,M8=16186,L8=16187,B8=16188,R8=16189,W1=16190,i=16191,g1=16192,w8=16193,I1=16194,O8=16195,x8=16196,D8=16197,A8=16198,e0=16199,t0=16200,T8=16201,S8=16202,v8=16203,y8=16204,E8=16205,j1=16206,p8=16207,h8=16208,x=16209,Z6=16210,H6=16211,iQ=852,lQ=592,_Q=15,rQ=_Q,f8=(J)=>{return(J>>>24&255)+(J>>>8&65280)+((J&65280)<<8)+((J&255)<<24)},X0=(J)=>{if(!J)return 1;const W=J.state;if(!W||W.strm!==J||W.mode<G1||W.mode>H6)return 1;return 0},C6=(J)=>{if(X0(J))return m;const W=J.state;if(J.total_in=J.total_out=W.total=0,J.msg="",W.wrap)J.adler=W.wrap&1;return W.mode=G1,W.last=0,W.havedict=0,W.flags=-1,W.dmax=32768,W.head=null,W.hold=0,W.bits=0,W.lencode=W.lendyn=new Int32Array(iQ),W.distcode=W.distdyn=new Int32Array(lQ),W.sane=1,W.back=-1,G0},N6=(J)=>{if(X0(J))return m;const W=J.state;return W.wsize=0,W.whave=0,W.wnext=0,C6(J)},$6=(J,W)=>{let Q;if(X0(J))return m;const V=J.state;if(W<0)Q=0,W=-W;else if(Q=(W>>4)+5,W<48)W&=15;if(W&&(W<8||W>15))return m;if(V.window!==null&&V.wbits!==W)V.window=null;return V.wrap=Q,V.wbits=W,N6(J)},g6=(J,W)=>{if(!J)return m;const Q=new nQ;J.state=Q,Q.strm=J,Q.window=null,Q.mode=G1;const V=$6(J,W);if(V!==G0)J.state=null;return V},oQ=(J)=>{return g6(J,rQ)},m8=!0,M1,L1,aQ=(J)=>{if(m8){M1=new Int32Array(512),L1=new Int32Array(32);let W=0;while(W<144)J.lens[W++]=8;while(W<256)J.lens[W++]=9;while(W<280)J.lens[W++]=7;while(W<288)J.lens[W++]=8;w0(F6,J.lens,0,288,M1,0,J.work,{bits:9}),W=0;while(W<32)J.lens[W++]=5;w0(K6,J.lens,0,32,L1,0,J.work,{bits:5}),m8=!1}J.lencode=M1,J.lenbits=9,J.distcode=L1,J.distbits=5},I6=(J,W,Q,V)=>{let q;const G=J.state;if(G.window===null)G.wsize=1<<G.wbits,G.wnext=0,G.whave=0,G.window=new Uint8Array(G.wsize);if(V>=G.wsize)G.window.set(W.subarray(Q-G.wsize,Q),0),G.wnext=0,G.whave=G.wsize;else{if(q=G.wsize-G.wnext,q>V)q=V;if(G.window.set(W.subarray(Q-V,Q-V+q),G.wnext),V-=q,V)G.window.set(W.subarray(Q-V,Q),0),G.wnext=V,G.whave=G.wsize;else{if(G.wnext+=q,G.wnext===G.wsize)G.wnext=0;if(G.whave<G.wsize)G.whave+=q}}return 0},eQ=(J,W)=>{let Q,V,q,G,P,U,K,X,Y,$,k,F,Z,D,M=0,N,w,g,z,B,A,H,O;const L=new Uint8Array(4);let C,I;const t=new Uint8Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]);if(X0(J)||!J.output||!J.input&&J.avail_in!==0)return m;if(Q=J.state,Q.mode===i)Q.mode=g1;P=J.next_out,q=J.output,K=J.avail_out,G=J.next_in,V=J.input,U=J.avail_in,X=Q.hold,Y=Q.bits,$=U,k=K,O=G0;J:for(;;)switch(Q.mode){case G1:if(Q.wrap===0){Q.mode=g1;break}while(Y<16){if(U===0)break J;U--,X+=V[G++]<<Y,Y+=8}if(Q.wrap&2&&X===35615){if(Q.wbits===0)Q.wbits=15;Q.check=0,L[0]=X&255,L[1]=X>>>8&255,Q.check=T(Q.check,L,2,0),X=0,Y=0,Q.mode=N8;break}if(Q.head)Q.head.done=!1;if(!(Q.wrap&1)||(((X&255)<<8)+(X>>8))%31){J.msg="incorrect header check",Q.mode=x;break}if((X&15)!==C8){J.msg="unknown compression method",Q.mode=x;break}if(X>>>=4,Y-=4,H=(X&15)+8,Q.wbits===0)Q.wbits=H;if(H>15||H>Q.wbits){J.msg="invalid window size",Q.mode=x;break}Q.dmax=1<<Q.wbits,Q.flags=0,J.adler=Q.check=1,Q.mode=X&512?R8:i,X=0,Y=0;break;case N8:while(Y<16){if(U===0)break J;U--,X+=V[G++]<<Y,Y+=8}if(Q.flags=X,(Q.flags&255)!==C8){J.msg="unknown compression method",Q.mode=x;break}if(Q.flags&57344){J.msg="unknown header flags set",Q.mode=x;break}if(Q.head)Q.head.text=X>>8&1;if(Q.flags&512&&Q.wrap&4)L[0]=X&255,L[1]=X>>>8&255,Q.check=T(Q.check,L,2,0);X=0,Y=0,Q.mode=$8;case $8:while(Y<32){if(U===0)break J;U--,X+=V[G++]<<Y,Y+=8}if(Q.head)Q.head.time=X;if(Q.flags&512&&Q.wrap&4)L[0]=X&255,L[1]=X>>>8&255,L[2]=X>>>16&255,L[3]=X>>>24&255,Q.check=T(Q.check,L,4,0);X=0,Y=0,Q.mode=g8;case g8:while(Y<16){if(U===0)break J;U--,X+=V[G++]<<Y,Y+=8}if(Q.head)Q.head.xflags=X&255,Q.head.os=X>>8;if(Q.flags&512&&Q.wrap&4)L[0]=X&255,L[1]=X>>>8&255,Q.check=T(Q.check,L,2,0);X=0,Y=0,Q.mode=I8;case I8:if(Q.flags&1024){while(Y<16){if(U===0)break J;U--,X+=V[G++]<<Y,Y+=8}if(Q.length=X,Q.head)Q.head.extra_len=X;if(Q.flags&512&&Q.wrap&4)L[0]=X&255,L[1]=X>>>8&255,Q.check=T(Q.check,L,2,0);X=0,Y=0}else if(Q.head)Q.head.extra=null;Q.mode=j8;case j8:if(Q.flags&1024){if(F=Q.length,F>U)F=U;if(F){if(Q.head){if(H=Q.head.extra_len-Q.length,!Q.head.extra)Q.head.extra=new Uint8Array(Q.head.extra_len);Q.head.extra.set(V.subarray(G,G+F),H)}if(Q.flags&512&&Q.wrap&4)Q.check=T(Q.check,V,F,G);U-=F,G+=F,Q.length-=F}if(Q.length)break J}Q.length=0,Q.mode=M8;case M8:if(Q.flags&2048){if(U===0)break J;F=0;do if(H=V[G+F++],Q.head&&H&&Q.length<65536)Q.head.name+=String.fromCharCode(H);while(H&&F<U);if(Q.flags&512&&Q.wrap&4)Q.check=T(Q.check,V,F,G);if(U-=F,G+=F,H)break J}else if(Q.head)Q.head.name=null;Q.length=0,Q.mode=L8;case L8:if(Q.flags&4096){if(U===0)break J;F=0;do if(H=V[G+F++],Q.head&&H&&Q.length<65536)Q.head.comment+=String.fromCharCode(H);while(H&&F<U);if(Q.flags&512&&Q.wrap&4)Q.check=T(Q.check,V,F,G);if(U-=F,G+=F,H)break J}else if(Q.head)Q.head.comment=null;Q.mode=B8;case B8:if(Q.flags&512){while(Y<16){if(U===0)break J;U--,X+=V[G++]<<Y,Y+=8}if(Q.wrap&4&&X!==(Q.check&65535)){J.msg="header crc mismatch",Q.mode=x;break}X=0,Y=0}if(Q.head)Q.head.hcrc=Q.flags>>9&1,Q.head.done=!0;J.adler=Q.check=0,Q.mode=i;break;case R8:while(Y<32){if(U===0)break J;U--,X+=V[G++]<<Y,Y+=8}J.adler=Q.check=f8(X),X=0,Y=0,Q.mode=W1;case W1:if(Q.havedict===0)return J.next_out=P,J.avail_out=K,J.next_in=G,J.avail_in=U,Q.hold=X,Q.bits=Y,uQ;J.adler=Q.check=1,Q.mode=i;case i:if(W===bQ||W===a0)break J;case g1:if(Q.last){X>>>=Y&7,Y-=Y&7,Q.mode=j1;break}while(Y<3){if(U===0)break J;U--,X+=V[G++]<<Y,Y+=8}switch(Q.last=X&1,X>>>=1,Y-=1,X&3){case 0:Q.mode=w8;break;case 1:if(aQ(Q),Q.mode=e0,W===a0){X>>>=2,Y-=2;break J}break;case 2:Q.mode=x8;break;case 3:J.msg="invalid block type",Q.mode=x}X>>>=2,Y-=2;break;case w8:X>>>=Y&7,Y-=Y&7;while(Y<32){if(U===0)break J;U--,X+=V[G++]<<Y,Y+=8}if((X&65535)!==(X>>>16^65535)){J.msg="invalid stored block lengths",Q.mode=x;break}if(Q.length=X&65535,X=0,Y=0,Q.mode=I1,W===a0)break J;case I1:Q.mode=O8;case O8:if(F=Q.length,F){if(F>U)F=U;if(F>K)F=K;if(F===0)break J;q.set(V.subarray(G,G+F),P),U-=F,G+=F,K-=F,P+=F,Q.length-=F;break}Q.mode=i;break;case x8:while(Y<14){if(U===0)break J;U--,X+=V[G++]<<Y,Y+=8}if(Q.nlen=(X&31)+257,X>>>=5,Y-=5,Q.ndist=(X&31)+1,X>>>=5,Y-=5,Q.ncode=(X&15)+4,X>>>=4,Y-=4,Q.nlen>286||Q.ndist>30){J.msg="too many length or distance symbols",Q.mode=x;break}Q.have=0,Q.mode=D8;case D8:while(Q.have<Q.ncode){while(Y<3){if(U===0)break J;U--,X+=V[G++]<<Y,Y+=8}Q.lens[t[Q.have++]]=X&7,X>>>=3,Y-=3}while(Q.have<19)Q.lens[t[Q.have++]]=0;if(Q.lencode=Q.lendyn,Q.lenbits=7,C={bits:Q.lenbits},O=w0(mQ,Q.lens,0,19,Q.lencode,0,Q.work,C),Q.lenbits=C.bits,O){J.msg="invalid code lengths set",Q.mode=x;break}Q.have=0,Q.mode=A8;case A8:while(Q.have<Q.nlen+Q.ndist){for(;;){if(M=Q.lencode[X&(1<<Q.lenbits)-1],N=M>>>24,w=M>>>16&255,g=M&65535,N<=Y)break;if(U===0)break J;U--,X+=V[G++]<<Y,Y+=8}if(g<16)X>>>=N,Y-=N,Q.lens[Q.have++]=g;else{if(g===16){I=N+2;while(Y<I){if(U===0)break J;U--,X+=V[G++]<<Y,Y+=8}if(X>>>=N,Y-=N,Q.have===0){J.msg="invalid bit length repeat",Q.mode=x;break}H=Q.lens[Q.have-1],F=3+(X&3),X>>>=2,Y-=2}else if(g===17){I=N+3;while(Y<I){if(U===0)break J;U--,X+=V[G++]<<Y,Y+=8}X>>>=N,Y-=N,H=0,F=3+(X&7),X>>>=3,Y-=3}else{I=N+7;while(Y<I){if(U===0)break J;U--,X+=V[G++]<<Y,Y+=8}X>>>=N,Y-=N,H=0,F=11+(X&127),X>>>=7,Y-=7}if(Q.have+F>Q.nlen+Q.ndist){J.msg="invalid bit length repeat",Q.mode=x;break}while(F--)Q.lens[Q.have++]=H}}if(Q.mode===x)break;if(Q.lens[256]===0){J.msg="invalid code -- missing end-of-block",Q.mode=x;break}if(Q.lenbits=9,C={bits:Q.lenbits},O=w0(F6,Q.lens,0,Q.nlen,Q.lencode,0,Q.work,C),Q.lenbits=C.bits,O){J.msg="invalid literal/lengths set",Q.mode=x;break}if(Q.distbits=6,Q.distcode=Q.distdyn,C={bits:Q.distbits},O=w0(K6,Q.lens,Q.nlen,Q.ndist,Q.distcode,0,Q.work,C),Q.distbits=C.bits,O){J.msg="invalid distances set",Q.mode=x;break}if(Q.mode=e0,W===a0)break J;case e0:Q.mode=t0;case t0:if(U>=6&&K>=258){if(J.next_out=P,J.avail_out=K,J.next_in=G,J.avail_in=U,Q.hold=X,Q.bits=Y,vQ(J,k),P=J.next_out,q=J.output,K=J.avail_out,G=J.next_in,V=J.input,U=J.avail_in,X=Q.hold,Y=Q.bits,Q.mode===i)Q.back=-1;break}Q.back=0;for(;;){if(M=Q.lencode[X&(1<<Q.lenbits)-1],N=M>>>24,w=M>>>16&255,g=M&65535,N<=Y)break;if(U===0)break J;U--,X+=V[G++]<<Y,Y+=8}if(w&&(w&240)===0){z=N,B=w,A=g;for(;;){if(M=Q.lencode[A+((X&(1<<z+B)-1)>>z)],N=M>>>24,w=M>>>16&255,g=M&65535,z+N<=Y)break;if(U===0)break J;U--,X+=V[G++]<<Y,Y+=8}X>>>=z,Y-=z,Q.back+=z}if(X>>>=N,Y-=N,Q.back+=N,Q.length=g,w===0){Q.mode=E8;break}if(w&32){Q.back=-1,Q.mode=i;break}if(w&64){J.msg="invalid literal/length code",Q.mode=x;break}Q.extra=w&15,Q.mode=T8;case T8:if(Q.extra){I=Q.extra;while(Y<I){if(U===0)break J;U--,X+=V[G++]<<Y,Y+=8}Q.length+=X&(1<<Q.extra)-1,X>>>=Q.extra,Y-=Q.extra,Q.back+=Q.extra}Q.was=Q.length,Q.mode=S8;case S8:for(;;){if(M=Q.distcode[X&(1<<Q.distbits)-1],N=M>>>24,w=M>>>16&255,g=M&65535,N<=Y)break;if(U===0)break J;U--,X+=V[G++]<<Y,Y+=8}if((w&240)===0){z=N,B=w,A=g;for(;;){if(M=Q.distcode[A+((X&(1<<z+B)-1)>>z)],N=M>>>24,w=M>>>16&255,g=M&65535,z+N<=Y)break;if(U===0)break J;U--,X+=V[G++]<<Y,Y+=8}X>>>=z,Y-=z,Q.back+=z}if(X>>>=N,Y-=N,Q.back+=N,w&64){J.msg="invalid distance code",Q.mode=x;break}Q.offset=g,Q.extra=w&15,Q.mode=v8;case v8:if(Q.extra){I=Q.extra;while(Y<I){if(U===0)break J;U--,X+=V[G++]<<Y,Y+=8}Q.offset+=X&(1<<Q.extra)-1,X>>>=Q.extra,Y-=Q.extra,Q.back+=Q.extra}if(Q.offset>Q.dmax){J.msg="invalid distance too far back",Q.mode=x;break}Q.mode=y8;case y8:if(K===0)break J;if(F=k-K,Q.offset>F){if(F=Q.offset-F,F>Q.whave){if(Q.sane){J.msg="invalid distance too far back",Q.mode=x;break}}if(F>Q.wnext)F-=Q.wnext,Z=Q.wsize-F;else Z=Q.wnext-F;if(F>Q.length)F=Q.length;D=Q.window}else D=q,Z=P-Q.offset,F=Q.length;if(F>K)F=K;K-=F,Q.length-=F;do q[P++]=D[Z++];while(--F);if(Q.length===0)Q.mode=t0;break;case E8:if(K===0)break J;q[P++]=Q.length,K--,Q.mode=t0;break;case j1:if(Q.wrap){while(Y<32){if(U===0)break J;U--,X|=V[G++]<<Y,Y+=8}if(k-=K,J.total_out+=k,Q.total+=k,Q.wrap&4&&k)J.adler=Q.check=Q.flags?T(Q.check,q,k,P-k):T0(Q.check,q,k,P-k);if(k=K,Q.wrap&4&&(Q.flags?X:f8(X))!==Q.check){J.msg="incorrect data check",Q.mode=x;break}X=0,Y=0}Q.mode=p8;case p8:if(Q.wrap&&Q.flags){while(Y<32){if(U===0)break J;U--,X+=V[G++]<<Y,Y+=8}if(Q.wrap&4&&X!==(Q.total&4294967295)){J.msg="incorrect length check",Q.mode=x;break}X=0,Y=0}Q.mode=h8;case h8:O=cQ;break J;case x:O=z6;break J;case Z6:return k6;case H6:default:return m}if(J.next_out=P,J.avail_out=K,J.next_in=G,J.avail_in=U,Q.hold=X,Q.bits=Y,Q.wsize||k!==J.avail_out&&Q.mode<x&&(Q.mode<j1||W!==H8)){if(I6(J,J.output,J.next_out,k-J.avail_out));}if($-=J.avail_in,k-=J.avail_out,J.total_in+=$,J.total_out+=k,Q.total+=k,Q.wrap&4&&k)J.adler=Q.check=Q.flags?T(Q.check,q,k,J.next_out-k):T0(Q.check,q,k,J.next_out-k);if(J.data_type=Q.bits+(Q.last?64:0)+(Q.mode===i?128:0)+(Q.mode===e0||Q.mode===I1?256:0),($===0&&k===0||W===H8)&&O===G0)O=dQ;return O},tQ=(J)=>{if(X0(J))return m;let W=J.state;if(W.window)W.window=null;return J.state=null,G0},sQ=(J,W)=>{if(X0(J))return m;const Q=J.state;if((Q.wrap&2)===0)return m;return Q.head=W,W.done=!1,G0},J5=(J,W)=>{const Q=W.length;let V,q,G;if(X0(J))return m;if(V=J.state,V.wrap!==0&&V.mode!==W1)return m;if(V.mode===W1){if(q=1,q=T0(q,W,Q,0),q!==V.check)return z6}if(G=I6(J,W,Q,Q),G)return V.mode=Z6,k6;return V.havedict=1,G0},Q5=N6,W5=$6,V5=C6,q5=oQ,G5=g6,U5=eQ,X5=tQ,P5=sQ,Y5=J5,F5="pako inflate (from Nodeca project)",_={inflateReset:Q5,inflateReset2:W5,inflateResetKeep:V5,inflateInit:q5,inflateInit2:G5,inflate:U5,inflateEnd:X5,inflateGetHeader:P5,inflateSetDictionary:Y5,inflateInfo:F5},z5=K5,j6=Object.prototype.toString,{Z_NO_FLUSH:k5,Z_FINISH:Z5,Z_OK:y0,Z_STREAM_END:B1,Z_NEED_DICT:R1,Z_STREAM_ERROR:H5,Z_DATA_ERROR:b8,Z_MEM_ERROR:C5}=U0;f0.prototype.push=function(J,W){const Q=this.strm,V=this.options.chunkSize,q=this.options.dictionary;let G,P,U;if(this.ended)return!1;if(W===~~W)P=W;else P=W===!0?Z5:k5;if(j6.call(J)==="[object ArrayBuffer]")Q.input=new Uint8Array(J);else Q.input=J;Q.next_in=0,Q.avail_in=Q.input.length;for(;;){if(Q.avail_out===0)Q.output=new Uint8Array(V),Q.next_out=0,Q.avail_out=V;if(G=_.inflate(Q,P),G===R1&&q){if(G=_.inflateSetDictionary(Q,q),G===y0)G=_.inflate(Q,P);else if(G===b8)G=R1}while(Q.avail_in>0&&G===B1&&Q.state.wrap>0&&J[Q.next_in]!==0)_.inflateReset(Q),G=_.inflate(Q,P);switch(G){case H5:case b8:case R1:case C5:return this.onEnd(G),this.ended=!0,!1}if(U=Q.avail_out,Q.next_out){if(Q.avail_out===0||G===B1)if(this.options.to==="string"){let K=v0.utf8border(Q.output,Q.next_out),X=Q.next_out-K,Y=v0.buf2string(Q.output,K);if(Q.next_out=X,Q.avail_out=V-X,X)Q.output.set(Q.output.subarray(K,K+X),0);this.onData(Y)}else this.onData(Q.output.length===Q.next_out?Q.output:Q.output.subarray(0,Q.next_out))}if(G===y0&&U===0)continue;if(G===B1)return G=_.inflateEnd(this.strm),this.onEnd(G),this.ended=!0,!0;if(Q.avail_in===0)break}return!0};f0.prototype.onData=function(J){this.chunks.push(J)};f0.prototype.onEnd=function(J){if(J===y0)if(this.options.to==="string")this.result=this.chunks.join("");else this.result=q1.flattenChunks(this.chunks);this.chunks=[],this.err=J,this.msg=this.strm.msg};var $5=f0,g5=c1,I5=N5,j5=c1,M5=U0,L5={Inflate:$5,inflate:g5,inflateRaw:I5,ungzip:j5,constants:M5},{Deflate:B5,deflate:R5,deflateRaw:w5,gzip:O5}=TQ,{Inflate:x5,inflate:D5,inflateRaw:A5,ungzip:T5}=L5,S5=B5,v5=R5,y5=w5,E5=O5,p5=x5,h5=D5,f5=A5,m5=T5,b5=U0,u1={Deflate:S5,deflate:v5,deflateRaw:y5,gzip:E5,Inflate:p5,inflate:h5,inflateRaw:f5,ungzip:m5,constants:b5};class d1{constructor(J={}){this.index={},this.maxSize=J.maxSize||1048576,this.fragmentedIndexes={}}insert(J,W){if(this.extractPrefixes(W).forEach((V)=>{if(!this.index[V])this.index[V]=[];if(!this.index[V].includes(J))this.index[V].push(J)}),JSON.stringify(this.index).length>this.maxSize)this.splitIndex()}remove(J,W){this.extractPrefixes(W).forEach((V)=>{if(this.index[V]){if(this.index[V]=this.index[V].filter((q)=>q!==J),this.index[V].length===0)delete this.index[V]}})}extractPrefixes(J){const W=[];if(typeof J==="string")for(let Q=1;Q<=J.length;Q++)W.push(J.substring(0,Q));else if(typeof J==="number")W.push(String(J));else if(typeof J==="object"&&J!==null)Object.keys(J).forEach((Q)=>{W.push(Q.toString());const V=J[Q];if(typeof V==="string"||typeof V==="number")W.push(`${Q}:${V}`)});return W}splitIndex(){const J=Object.keys(this.index),W=Math.ceil(J.length/2),Q={},V={};J.slice(0,W).forEach((q)=>{Q[q]=this.index[q]}),J.slice(W).forEach((q)=>{V[q]=this.index[q]}),this.fragmentedIndexes.fragment1=Q,this.fragmentedIndexes.fragment2=V,this.index={}}mergeFragments(){console.log("\u26A1 Merging fragments of the Radix index...");for(let J of Object.values(this.fragmentedIndexes))Object.assign(this.index,J);this.fragmentedIndexes={},console.log("\u26A1 Fragments merged. Radix index reconstructed:",this.index)}searchByPrefix(J){return this.index[J]||[]}searchAllByPrefix(J){return Object.keys(this.index).filter((Q)=>Q.startsWith(J)).flatMap((Q)=>this.index[Q])}serialize(){const J={index:this.index,fragmentedIndexes:this.fragmentedIndexes};return u1.deflate(X1(J))}deserialize(J){const W=u1.inflate(new Uint8Array(J)),Q=K1(W);this.index=Q.index||{},this.fragmentedIndexes=Q.fragmentedIndexes||{},console.log("\u26A1 Radix index deserialized:",{index:this.index,fragmentedIndexes:this.fragmentedIndexes})}validateIndex(){if(JSON.stringify(this.index).length>1048576)throw console.error("\u26A1 The Radix index exceeds the maximum allowed size."),new Error("Index too large");if(!this.index||typeof this.index!=="object")console.error("\u26A1 Corrupted Radix index. It will be cleared."),this.index={};console.log("\u26A1 Validation of the Radix index completed without errors.")}}function OW(J){const W=new i1(J),Q=J.put;J.put=async function(G,P){return P=await Q.call(this,G,P),await W.updateIndex(P,G,"insert"),P};const V=J.remove;J.remove=async function(G){const P=this.graph.get(G);if(await V.call(this,G),P)await W.updateIndex(G,P.value,"remove")};const q=J.map;return J.map=async function(...G){const P=await q.call(this,...G),U=G.find((K)=>typeof K==="object");if(U?.query?.id?.$startsWith){const K=U.query.id.$startsWith;console.log(`\u26A1 Performing prefix search in the Radix index: ${K}`);const X=W.searchByPrefix(K);return console.log(`\u26A1 IDs found for prefix '${K}':`,X),P.filter((Y)=>X.includes(Y.id))}return P},J.searchByPrefix=async function(G){return W.searchByPrefix(G).map((U)=>this.graph.get(U))},J}class i1{constructor(J){this.graphDB=J,this.worker=J.worker,this.radix=new d1({maxSize:1048576}),this.indexFileName="graph_radix_index.json",console.log(`\u26A1 Initializing Radix index for the database: ${this.indexFileName}`),this.ready=this.loadIndexFromOPFS().then(()=>this.rebuildIndexFromGraph())}async loadIndexFromOPFS(){try{const J=await new Promise((W,Q)=>{const V=(q)=>{if(q.data.type==="loaded"&&q.data.name===this.indexFileName)this.worker.removeEventListener("message",V),W(new Uint8Array(q.data.data));else if(q.data.type==="error")this.worker.removeEventListener("message",V),Q(new Error(q.data.message||"Error loading the Radix index"))};this.worker.addEventListener("message",V),console.log(`\u26A1 Requesting load of the Radix index from OPFS: ${this.indexFileName}`),this.worker.postMessage({type:"load",name:this.indexFileName})});if(J.byteLength>0)this.radix.deserialize(J),console.log("\u26A1 Radix index loaded successfully from OPFS.");else console.warn("\u26A1 The Radix index file is empty or could not be loaded.")}catch(J){console.warn("\u26A1 Could not load the Radix index:",J.message)}}async rebuildIndexFromGraph(){try{console.log("\u26A1 Starting reconstruction of the Radix index from the graph..."),this.radix.validateIndex(),(await this.graphDB.getAllNodes()).forEach((W)=>{console.log(`\u26A1 Inserting node into Radix index: ID=${W.id}, Value=`,W.value),this.radix.insert(W.id,W.value)}),console.log("\u26A1 Radix index reconstructed successfully.")}catch(J){console.error("\u26A1 Error reconstructing the Radix index:",J.message)}}async saveIndexToOPFS(){try{const J=this.radix.serialize();await new Promise((W,Q)=>{const V=(q)=>{if(q.data.type==="saved"&&q.data.name===this.indexFileName)this.worker.removeEventListener("message",V),W();else if(q.data.type==="error")this.worker.removeEventListener("message",V),Q(new Error(q.data.message||"Error saving the Radix index"))};this.worker.addEventListener("message",V),console.log(`\u26A1 Saving Radix index to OPFS: ${this.indexFileName}`),this.worker.postMessage({type:"save",name:this.indexFileName,content:J})}),console.log("\u26A1 Radix index saved successfully to OPFS.")}catch(J){console.error("\u26A1 Error saving the Radix index:",J.message)}}async updateIndex(J,W,Q="insert"){switch(console.log(`\u26A1 Updating Radix index: ID=${J}, Action=${Q}`),Q){case"insert":console.log(`\u26A1 Inserting node into Radix index: ID=${J}, Value=`,W),this.radix.insert(J,W);break;case"remove":console.log(`\u26A1 Removing node from Radix index: ID=${J}, Value=`,W),this.radix.remove(J,W);break;default:console.warn("\u26A1 Unsupported action in the Radix index.")}await this.saveIndexToOPFS()}searchByPrefix(J){console.log(`\u26A1 Searching in the Radix index with prefix: ${J}`);const W=this.radix.searchAllByPrefix(J);return console.log(`\u26A1 Results found for prefix '${J}':`,W),W}}export{OW as withRadixIndex,i1 as default};
