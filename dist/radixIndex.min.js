function i1(J){const W=J.length;let Q=0,V=0;while(V<W){let q=J.charCodeAt(V++);if((q&4294967168)===0){Q++;continue}else if((q&4294965248)===0)Q+=2;else{if(q>=55296&&q<=56319){if(V<W){const G=J.charCodeAt(V);if((G&64512)===56320)++V,q=((q&1023)<<10)+(G&1023)+65536}}if((q&4294901760)===0)Q+=3;else Q+=4}}return Q}function $6(J,W,Q){const V=J.length;let q=Q,G=0;while(G<V){let U=J.charCodeAt(G++);if((U&4294967168)===0){W[q++]=U;continue}else if((U&4294965248)===0)W[q++]=U>>6&31|192;else{if(U>=55296&&U<=56319){if(G<V){const P=J.charCodeAt(G);if((P&64512)===56320)++G,U=((U&1023)<<10)+(P&1023)+65536}}if((U&4294901760)===0)W[q++]=U>>12&15|224,W[q++]=U>>6&63|128;else W[q++]=U>>18&7|240,W[q++]=U>>12&63|128,W[q++]=U>>6&63|128}W[q++]=U&63|128}}function j6(J,W,Q){g6.encodeInto(J,W.subarray(Q))}function l1(J,W,Q){if(J.length>I6)j6(J,W,Q);else $6(J,W,Q)}function q1(J,W,Q){let V=W;const q=V+Q,G=[];let U="";while(V<q){const P=J[V++];if((P&128)===0)G.push(P);else if((P&224)===192){const K=J[V++]&63;G.push((P&31)<<6|K)}else if((P&240)===224){const K=J[V++]&63,X=J[V++]&63;G.push((P&31)<<12|K<<6|X)}else if((P&248)===240){const K=J[V++]&63,X=J[V++]&63,Y=J[V++]&63;let $=(P&7)<<18|K<<12|X<<6|Y;if($>65535)$-=65536,G.push($>>>10&1023|55296),$=56320|$&1023;G.push($)}else G.push(P);if(G.length>=R6)U+=String.fromCharCode(...G),G.length=0}if(G.length>0)U+=String.fromCharCode(...G);return U}function L6(J,W,Q){const V=J.subarray(W,W+Q);return M6.decode(V)}function _1(J,W,Q){if(Q>B6)return L6(J,W,Q);else return q1(J,W,Q)}var g6=new TextEncoder,I6=50,R6=4096,M6=new TextDecoder,B6=200;class U0{constructor(J,W){this.type=J,this.data=W}}class S extends Error{constructor(J){super(J);const W=Object.create(S.prototype);Object.setPrototypeOf(this,W),Object.defineProperty(this,"name",{configurable:!0,enumerable:!1,value:S.name})}}function n1(J,W,Q){const V=Q/4294967296,q=Q;J.setUint32(W,V),J.setUint32(W+4,q)}function u0(J,W,Q){const V=Math.floor(Q/4294967296),q=Q;J.setUint32(W,V),J.setUint32(W+4,q)}function c0(J,W){const Q=J.getInt32(W),V=J.getUint32(W+4);return Q*4294967296+V}function r1(J,W){const Q=J.getUint32(W),V=J.getUint32(W+4);return Q*4294967296+V}var Y0=4294967295;function D6({sec:J,nsec:W}){if(J>=0&&W>=0&&J<=x6)if(W===0&&J<=O6){const Q=new Uint8Array(4);return new DataView(Q.buffer).setUint32(0,J),Q}else{const Q=J/4294967296,V=J&4294967295,q=new Uint8Array(8),G=new DataView(q.buffer);return G.setUint32(0,W<<2|Q&3),G.setUint32(4,V),q}else{const Q=new Uint8Array(12),V=new DataView(Q.buffer);return V.setUint32(0,W),u0(V,4,J),Q}}function A6(J){const W=J.getTime(),Q=Math.floor(W/1000),V=(W-Q*1000)*1e6,q=Math.floor(V/1e9);return{sec:Q+q,nsec:V-q*1e9}}function T6(J){if(J instanceof Date){const W=A6(J);return D6(W)}else return null}function v6(J){const W=new DataView(J.buffer,J.byteOffset,J.byteLength);switch(J.byteLength){case 4:return{sec:W.getUint32(0),nsec:0};case 8:{const Q=W.getUint32(0),V=W.getUint32(4),q=(Q&3)*4294967296+V,G=Q>>>2;return{sec:q,nsec:G}}case 12:{const Q=c0(W,4),V=W.getUint32(0);return{sec:Q,nsec:V}}default:throw new S(`Unrecognized data size for timestamp (expected 4, 8, or 12): ${J.length}`)}}function S6(J){const W=v6(J);return new Date(W.sec*1000+W.nsec/1e6)}var w6=-1,O6=4294967295,x6=17179869183,o1={type:w6,encode:T6,decode:S6};class s{constructor(){this.builtInEncoders=[],this.builtInDecoders=[],this.encoders=[],this.decoders=[],this.register(o1)}register({type:J,encode:W,decode:Q}){if(J>=0)this.encoders[J]=W,this.decoders[J]=Q;else{const V=-1-J;this.builtInEncoders[V]=W,this.builtInDecoders[V]=Q}}tryToEncode(J,W){for(let Q=0;Q<this.builtInEncoders.length;Q++){const V=this.builtInEncoders[Q];if(V!=null){const q=V(J,W);if(q!=null){const G=-1-Q;return new U0(G,q)}}}for(let Q=0;Q<this.encoders.length;Q++){const V=this.encoders[Q];if(V!=null){const q=V(J,W);if(q!=null)return new U0(Q,q)}}if(J instanceof U0)return J;return null}decode(J,W,Q){const V=W<0?this.builtInDecoders[-1-W]:this.decoders[W];if(V)return V(J,W,Q);else return new U0(W,J)}}s.defaultCodec=new s;var y6=function(J){return J instanceof ArrayBuffer||typeof SharedArrayBuffer!=="undefined"&&J instanceof SharedArrayBuffer};function $0(J){if(J instanceof Uint8Array)return J;else if(ArrayBuffer.isView(J))return new Uint8Array(J.buffer,J.byteOffset,J.byteLength);else if(y6(J))return new Uint8Array(J);else return Uint8Array.from(J)}var E6=100,p6=2048;class d0{constructor(J){this.entered=!1,this.extensionCodec=J?.extensionCodec??s.defaultCodec,this.context=J?.context,this.useBigInt64=J?.useBigInt64??!1,this.maxDepth=J?.maxDepth??E6,this.initialBufferSize=J?.initialBufferSize??p6,this.sortKeys=J?.sortKeys??!1,this.forceFloat32=J?.forceFloat32??!1,this.ignoreUndefined=J?.ignoreUndefined??!1,this.forceIntegerToFloat=J?.forceIntegerToFloat??!1,this.pos=0,this.view=new DataView(new ArrayBuffer(this.initialBufferSize)),this.bytes=new Uint8Array(this.view.buffer)}clone(){return new d0({extensionCodec:this.extensionCodec,context:this.context,useBigInt64:this.useBigInt64,maxDepth:this.maxDepth,initialBufferSize:this.initialBufferSize,sortKeys:this.sortKeys,forceFloat32:this.forceFloat32,ignoreUndefined:this.ignoreUndefined,forceIntegerToFloat:this.forceIntegerToFloat})}reinitializeState(){this.pos=0}encodeSharedRef(J){if(this.entered)return this.clone().encodeSharedRef(J);try{return this.entered=!0,this.reinitializeState(),this.doEncode(J,1),this.bytes.subarray(0,this.pos)}finally{this.entered=!1}}encode(J){if(this.entered)return this.clone().encode(J);try{return this.entered=!0,this.reinitializeState(),this.doEncode(J,1),this.bytes.slice(0,this.pos)}finally{this.entered=!1}}doEncode(J,W){if(W>this.maxDepth)throw new Error(`Too deep objects in depth ${W}`);if(J==null)this.encodeNil();else if(typeof J==="boolean")this.encodeBoolean(J);else if(typeof J==="number")if(!this.forceIntegerToFloat)this.encodeNumber(J);else this.encodeNumberAsFloat(J);else if(typeof J==="string")this.encodeString(J);else if(this.useBigInt64&&typeof J==="bigint")this.encodeBigInt64(J);else this.encodeObject(J,W)}ensureBufferSizeToWrite(J){const W=this.pos+J;if(this.view.byteLength<W)this.resizeBuffer(W*2)}resizeBuffer(J){const W=new ArrayBuffer(J),Q=new Uint8Array(W),V=new DataView(W);Q.set(this.bytes),this.view=V,this.bytes=Q}encodeNil(){this.writeU8(192)}encodeBoolean(J){if(J===!1)this.writeU8(194);else this.writeU8(195)}encodeNumber(J){if(!this.forceIntegerToFloat&&Number.isSafeInteger(J))if(J>=0)if(J<128)this.writeU8(J);else if(J<256)this.writeU8(204),this.writeU8(J);else if(J<65536)this.writeU8(205),this.writeU16(J);else if(J<4294967296)this.writeU8(206),this.writeU32(J);else if(!this.useBigInt64)this.writeU8(207),this.writeU64(J);else this.encodeNumberAsFloat(J);else if(J>=-32)this.writeU8(224|J+32);else if(J>=-128)this.writeU8(208),this.writeI8(J);else if(J>=-32768)this.writeU8(209),this.writeI16(J);else if(J>=-2147483648)this.writeU8(210),this.writeI32(J);else if(!this.useBigInt64)this.writeU8(211),this.writeI64(J);else this.encodeNumberAsFloat(J);else this.encodeNumberAsFloat(J)}encodeNumberAsFloat(J){if(this.forceFloat32)this.writeU8(202),this.writeF32(J);else this.writeU8(203),this.writeF64(J)}encodeBigInt64(J){if(J>=BigInt(0))this.writeU8(207),this.writeBigUint64(J);else this.writeU8(211),this.writeBigInt64(J)}writeStringHeader(J){if(J<32)this.writeU8(160+J);else if(J<256)this.writeU8(217),this.writeU8(J);else if(J<65536)this.writeU8(218),this.writeU16(J);else if(J<4294967296)this.writeU8(219),this.writeU32(J);else throw new Error(`Too long string: ${J} bytes in UTF-8`)}encodeString(J){const Q=i1(J);this.ensureBufferSizeToWrite(5+Q),this.writeStringHeader(Q),l1(J,this.bytes,this.pos),this.pos+=Q}encodeObject(J,W){const Q=this.extensionCodec.tryToEncode(J,this.context);if(Q!=null)this.encodeExtension(Q);else if(Array.isArray(J))this.encodeArray(J,W);else if(ArrayBuffer.isView(J))this.encodeBinary(J);else if(typeof J==="object")this.encodeMap(J,W);else throw new Error(`Unrecognized object: ${Object.prototype.toString.apply(J)}`)}encodeBinary(J){const W=J.byteLength;if(W<256)this.writeU8(196),this.writeU8(W);else if(W<65536)this.writeU8(197),this.writeU16(W);else if(W<4294967296)this.writeU8(198),this.writeU32(W);else throw new Error(`Too large binary: ${W}`);const Q=$0(J);this.writeU8a(Q)}encodeArray(J,W){const Q=J.length;if(Q<16)this.writeU8(144+Q);else if(Q<65536)this.writeU8(220),this.writeU16(Q);else if(Q<4294967296)this.writeU8(221),this.writeU32(Q);else throw new Error(`Too large array: ${Q}`);for(let V of J)this.doEncode(V,W+1)}countWithoutUndefined(J,W){let Q=0;for(let V of W)if(J[V]!==void 0)Q++;return Q}encodeMap(J,W){const Q=Object.keys(J);if(this.sortKeys)Q.sort();const V=this.ignoreUndefined?this.countWithoutUndefined(J,Q):Q.length;if(V<16)this.writeU8(128+V);else if(V<65536)this.writeU8(222),this.writeU16(V);else if(V<4294967296)this.writeU8(223),this.writeU32(V);else throw new Error(`Too large map object: ${V}`);for(let q of Q){const G=J[q];if(!(this.ignoreUndefined&&G===void 0))this.encodeString(q),this.doEncode(G,W+1)}}encodeExtension(J){if(typeof J.data==="function"){const Q=J.data(this.pos+6),V=Q.length;if(V>=4294967296)throw new Error(`Too large extension object: ${V}`);this.writeU8(201),this.writeU32(V),this.writeI8(J.type),this.writeU8a(Q);return}const W=J.data.length;if(W===1)this.writeU8(212);else if(W===2)this.writeU8(213);else if(W===4)this.writeU8(214);else if(W===8)this.writeU8(215);else if(W===16)this.writeU8(216);else if(W<256)this.writeU8(199),this.writeU8(W);else if(W<65536)this.writeU8(200),this.writeU16(W);else if(W<4294967296)this.writeU8(201),this.writeU32(W);else throw new Error(`Too large extension object: ${W}`);this.writeI8(J.type),this.writeU8a(J.data)}writeU8(J){this.ensureBufferSizeToWrite(1),this.view.setUint8(this.pos,J),this.pos++}writeU8a(J){const W=J.length;this.ensureBufferSizeToWrite(W),this.bytes.set(J,this.pos),this.pos+=W}writeI8(J){this.ensureBufferSizeToWrite(1),this.view.setInt8(this.pos,J),this.pos++}writeU16(J){this.ensureBufferSizeToWrite(2),this.view.setUint16(this.pos,J),this.pos+=2}writeI16(J){this.ensureBufferSizeToWrite(2),this.view.setInt16(this.pos,J),this.pos+=2}writeU32(J){this.ensureBufferSizeToWrite(4),this.view.setUint32(this.pos,J),this.pos+=4}writeI32(J){this.ensureBufferSizeToWrite(4),this.view.setInt32(this.pos,J),this.pos+=4}writeF32(J){this.ensureBufferSizeToWrite(4),this.view.setFloat32(this.pos,J),this.pos+=4}writeF64(J){this.ensureBufferSizeToWrite(8),this.view.setFloat64(this.pos,J),this.pos+=8}writeU64(J){this.ensureBufferSizeToWrite(8),n1(this.view,this.pos,J),this.pos+=8}writeI64(J){this.ensureBufferSizeToWrite(8),u0(this.view,this.pos,J),this.pos+=8}writeBigUint64(J){this.ensureBufferSizeToWrite(8),this.view.setBigUint64(this.pos,J),this.pos+=8}writeBigInt64(J){this.ensureBufferSizeToWrite(8),this.view.setBigInt64(this.pos,J),this.pos+=8}}function G1(J,W){return new d0(W).encodeSharedRef(J)}function i0(J){return`${J<0?"-":""}0x${Math.abs(J).toString(16).padStart(2,"0")}`}var h6=16,f6=16;class X1{constructor(J=h6,W=f6){this.hit=0,this.miss=0,this.maxKeyLength=J,this.maxLengthPerKey=W,this.caches=[];for(let Q=0;Q<this.maxKeyLength;Q++)this.caches.push([])}canBeCached(J){return J>0&&J<=this.maxKeyLength}find(J,W,Q){const V=this.caches[Q-1];J:for(let q of V){const G=q.bytes;for(let U=0;U<Q;U++)if(G[U]!==J[W+U])continue J;return q.str}return null}store(J,W){const Q=this.caches[J.length-1],V={bytes:J,str:W};if(Q.length>=this.maxLengthPerKey)Q[Math.random()*Q.length|0]=V;else Q.push(V)}decode(J,W,Q){const V=this.find(J,W,Q);if(V!=null)return this.hit++,V;this.miss++;const q=q1(J,W,Q),G=Uint8Array.prototype.slice.call(J,W,W+Q);return this.store(G,q),q}}var P1="array",I0="map_key",e1="map_value",m6=(J)=>{if(typeof J==="string"||typeof J==="number")return J;throw new S("The type of key must be string or number but "+typeof J)};class t1{constructor(){this.stack=[],this.stackHeadPosition=-1}get length(){return this.stackHeadPosition+1}top(){return this.stack[this.stackHeadPosition]}pushArrayState(J){const W=this.getUninitializedStateFromPool();W.type=P1,W.position=0,W.size=J,W.array=new Array(J)}pushMapState(J){const W=this.getUninitializedStateFromPool();W.type=I0,W.readCount=0,W.size=J,W.map={}}getUninitializedStateFromPool(){if(this.stackHeadPosition++,this.stackHeadPosition===this.stack.length){const J={type:void 0,size:0,array:void 0,position:0,readCount:0,map:void 0,key:null};this.stack.push(J)}return this.stack[this.stackHeadPosition]}release(J){if(this.stack[this.stackHeadPosition]!==J)throw new Error("Invalid stack state. Released state is not on top of the stack.");if(J.type===P1){const Q=J;Q.size=0,Q.array=void 0,Q.position=0,Q.type=void 0}if(J.type===I0||J.type===e1){const Q=J;Q.size=0,Q.map=void 0,Q.readCount=0,Q.type=void 0}this.stackHeadPosition--}reset(){this.stack.length=0,this.stackHeadPosition=-1}}var g0=-1,U1=new DataView(new ArrayBuffer(0)),b6=new Uint8Array(U1.buffer);try{U1.getInt8(0)}catch(J){if(!(J instanceof RangeError))throw new Error("This module is not supported in the current JavaScript engine because DataView does not throw RangeError on out-of-bounds access")}var a1=new RangeError("Insufficient data"),u6=new X1;class l0{constructor(J){this.totalPos=0,this.pos=0,this.view=U1,this.bytes=b6,this.headByte=g0,this.stack=new t1,this.entered=!1,this.extensionCodec=J?.extensionCodec??s.defaultCodec,this.context=J?.context,this.useBigInt64=J?.useBigInt64??!1,this.rawStrings=J?.rawStrings??!1,this.maxStrLength=J?.maxStrLength??Y0,this.maxBinLength=J?.maxBinLength??Y0,this.maxArrayLength=J?.maxArrayLength??Y0,this.maxMapLength=J?.maxMapLength??Y0,this.maxExtLength=J?.maxExtLength??Y0,this.keyDecoder=J?.keyDecoder!==void 0?J.keyDecoder:u6,this.mapKeyConverter=J?.mapKeyConverter??m6}clone(){return new l0({extensionCodec:this.extensionCodec,context:this.context,useBigInt64:this.useBigInt64,rawStrings:this.rawStrings,maxStrLength:this.maxStrLength,maxBinLength:this.maxBinLength,maxArrayLength:this.maxArrayLength,maxMapLength:this.maxMapLength,maxExtLength:this.maxExtLength,keyDecoder:this.keyDecoder})}reinitializeState(){this.totalPos=0,this.headByte=g0,this.stack.reset()}setBuffer(J){const W=$0(J);this.bytes=W,this.view=new DataView(W.buffer,W.byteOffset,W.byteLength),this.pos=0}appendBuffer(J){if(this.headByte===g0&&!this.hasRemaining(1))this.setBuffer(J);else{const W=this.bytes.subarray(this.pos),Q=$0(J),V=new Uint8Array(W.length+Q.length);V.set(W),V.set(Q,W.length),this.setBuffer(V)}}hasRemaining(J){return this.view.byteLength-this.pos>=J}createExtraByteError(J){const{view:W,pos:Q}=this;return new RangeError(`Extra ${W.byteLength-Q} of ${W.byteLength} byte(s) found at buffer[${J}]`)}decode(J){if(this.entered)return this.clone().decode(J);try{this.entered=!0,this.reinitializeState(),this.setBuffer(J);const W=this.doDecodeSync();if(this.hasRemaining(1))throw this.createExtraByteError(this.pos);return W}finally{this.entered=!1}}*decodeMulti(J){if(this.entered){yield*this.clone().decodeMulti(J);return}try{this.entered=!0,this.reinitializeState(),this.setBuffer(J);while(this.hasRemaining(1))yield this.doDecodeSync()}finally{this.entered=!1}}async decodeAsync(J){if(this.entered)return this.clone().decodeAsync(J);try{this.entered=!0;let W=!1,Q;for await(let U of J){if(W)throw this.entered=!1,this.createExtraByteError(this.totalPos);this.appendBuffer(U);try{Q=this.doDecodeSync(),W=!0}catch(P){if(!(P instanceof RangeError))throw P}this.totalPos+=this.pos}if(W){if(this.hasRemaining(1))throw this.createExtraByteError(this.totalPos);return Q}const{headByte:V,pos:q,totalPos:G}=this;throw new RangeError(`Insufficient data in parsing ${i0(V)} at ${G} (${q} in the current buffer)`)}finally{this.entered=!1}}decodeArrayStream(J){return this.decodeMultiAsync(J,!0)}decodeStream(J){return this.decodeMultiAsync(J,!1)}async*decodeMultiAsync(J,W){if(this.entered){yield*this.clone().decodeMultiAsync(J,W);return}try{this.entered=!0;let Q=W,V=-1;for await(let q of J){if(W&&V===0)throw this.createExtraByteError(this.totalPos);if(this.appendBuffer(q),Q)V=this.readArraySize(),Q=!1,this.complete();try{while(!0)if(yield this.doDecodeSync(),--V===0)break}catch(G){if(!(G instanceof RangeError))throw G}this.totalPos+=this.pos}}finally{this.entered=!1}}doDecodeSync(){J:while(!0){const J=this.readHeadByte();let W;if(J>=224)W=J-256;else if(J<192)if(J<128)W=J;else if(J<144){const V=J-128;if(V!==0){this.pushMapState(V),this.complete();continue J}else W={}}else if(J<160){const V=J-144;if(V!==0){this.pushArrayState(V),this.complete();continue J}else W=[]}else{const V=J-160;W=this.decodeString(V,0)}else if(J===192)W=null;else if(J===194)W=!1;else if(J===195)W=!0;else if(J===202)W=this.readF32();else if(J===203)W=this.readF64();else if(J===204)W=this.readU8();else if(J===205)W=this.readU16();else if(J===206)W=this.readU32();else if(J===207)if(this.useBigInt64)W=this.readU64AsBigInt();else W=this.readU64();else if(J===208)W=this.readI8();else if(J===209)W=this.readI16();else if(J===210)W=this.readI32();else if(J===211)if(this.useBigInt64)W=this.readI64AsBigInt();else W=this.readI64();else if(J===217){const V=this.lookU8();W=this.decodeString(V,1)}else if(J===218){const V=this.lookU16();W=this.decodeString(V,2)}else if(J===219){const V=this.lookU32();W=this.decodeString(V,4)}else if(J===220){const V=this.readU16();if(V!==0){this.pushArrayState(V),this.complete();continue J}else W=[]}else if(J===221){const V=this.readU32();if(V!==0){this.pushArrayState(V),this.complete();continue J}else W=[]}else if(J===222){const V=this.readU16();if(V!==0){this.pushMapState(V),this.complete();continue J}else W={}}else if(J===223){const V=this.readU32();if(V!==0){this.pushMapState(V),this.complete();continue J}else W={}}else if(J===196){const V=this.lookU8();W=this.decodeBinary(V,1)}else if(J===197){const V=this.lookU16();W=this.decodeBinary(V,2)}else if(J===198){const V=this.lookU32();W=this.decodeBinary(V,4)}else if(J===212)W=this.decodeExtension(1,0);else if(J===213)W=this.decodeExtension(2,0);else if(J===214)W=this.decodeExtension(4,0);else if(J===215)W=this.decodeExtension(8,0);else if(J===216)W=this.decodeExtension(16,0);else if(J===199){const V=this.lookU8();W=this.decodeExtension(V,1)}else if(J===200){const V=this.lookU16();W=this.decodeExtension(V,2)}else if(J===201){const V=this.lookU32();W=this.decodeExtension(V,4)}else throw new S(`Unrecognized type byte: ${i0(J)}`);this.complete();const Q=this.stack;while(Q.length>0){const V=Q.top();if(V.type===P1)if(V.array[V.position]=W,V.position++,V.position===V.size)W=V.array,Q.release(V);else continue J;else if(V.type===I0){if(W==="__proto__")throw new S("The key __proto__ is not allowed");V.key=this.mapKeyConverter(W),V.type=e1;continue J}else if(V.map[V.key]=W,V.readCount++,V.readCount===V.size)W=V.map,Q.release(V);else{V.key=null,V.type=I0;continue J}}return W}}readHeadByte(){if(this.headByte===g0)this.headByte=this.readU8();return this.headByte}complete(){this.headByte=g0}readArraySize(){const J=this.readHeadByte();switch(J){case 220:return this.readU16();case 221:return this.readU32();default:if(J<160)return J-144;else throw new S(`Unrecognized array type byte: ${i0(J)}`)}}pushMapState(J){if(J>this.maxMapLength)throw new S(`Max length exceeded: map length (${J}) > maxMapLengthLength (${this.maxMapLength})`);this.stack.pushMapState(J)}pushArrayState(J){if(J>this.maxArrayLength)throw new S(`Max length exceeded: array length (${J}) > maxArrayLength (${this.maxArrayLength})`);this.stack.pushArrayState(J)}decodeString(J,W){if(!this.rawStrings||this.stateIsMapKey())return this.decodeUtf8String(J,W);return this.decodeBinary(J,W)}decodeUtf8String(J,W){if(J>this.maxStrLength)throw new S(`Max length exceeded: UTF-8 byte length (${J}) > maxStrLength (${this.maxStrLength})`);if(this.bytes.byteLength<this.pos+W+J)throw a1;const Q=this.pos+W;let V;if(this.stateIsMapKey()&&this.keyDecoder?.canBeCached(J))V=this.keyDecoder.decode(this.bytes,Q,J);else V=_1(this.bytes,Q,J);return this.pos+=W+J,V}stateIsMapKey(){if(this.stack.length>0)return this.stack.top().type===I0;return!1}decodeBinary(J,W){if(J>this.maxBinLength)throw new S(`Max length exceeded: bin length (${J}) > maxBinLength (${this.maxBinLength})`);if(!this.hasRemaining(J+W))throw a1;const Q=this.pos+W,V=this.bytes.subarray(Q,Q+J);return this.pos+=W+J,V}decodeExtension(J,W){if(J>this.maxExtLength)throw new S(`Max length exceeded: ext length (${J}) > maxExtLength (${this.maxExtLength})`);const Q=this.view.getInt8(this.pos+W),V=this.decodeBinary(J,W+1);return this.extensionCodec.decode(V,Q,this.context)}lookU8(){return this.view.getUint8(this.pos)}lookU16(){return this.view.getUint16(this.pos)}lookU32(){return this.view.getUint32(this.pos)}readU8(){const J=this.view.getUint8(this.pos);return this.pos++,J}readI8(){const J=this.view.getInt8(this.pos);return this.pos++,J}readU16(){const J=this.view.getUint16(this.pos);return this.pos+=2,J}readI16(){const J=this.view.getInt16(this.pos);return this.pos+=2,J}readU32(){const J=this.view.getUint32(this.pos);return this.pos+=4,J}readI32(){const J=this.view.getInt32(this.pos);return this.pos+=4,J}readU64(){const J=r1(this.view,this.pos);return this.pos+=8,J}readI64(){const J=c0(this.view,this.pos);return this.pos+=8,J}readU64AsBigInt(){const J=this.view.getBigUint64(this.pos);return this.pos+=8,J}readI64AsBigInt(){const J=this.view.getBigInt64(this.pos);return this.pos+=8,J}readF32(){const J=this.view.getFloat32(this.pos);return this.pos+=4,J}readF64(){const J=this.view.getFloat64(this.pos);return this.pos+=8,J}}function Y1(J,W){return new l0(W).decode(J)}var H0=function(J){let W=J.length;while(--W>=0)J[W]=0},K1=function(J,W,Q,V,q){this.static_tree=J,this.extra_bits=W,this.extra_base=Q,this.elems=V,this.max_length=q,this.has_stree=J&&J.length},z1=function(J,W){this.dyn_tree=J,this.max_code=0,this.stat_desc=W},b=function(J,W,Q,V,q){this.good_length=J,this.max_lazy=W,this.nice_length=Q,this.max_chain=V,this.func=q},d5=function(){this.strm=null,this.status=0,this.pending_buf=null,this.pending_buf_size=0,this.pending_out=0,this.pending=0,this.wrap=0,this.gzhead=null,this.gzindex=0,this.method=Q1,this.last_flush=-1,this.w_size=0,this.w_bits=0,this.w_mask=0,this.window=null,this.window_size=0,this.prev=null,this.head=null,this.ins_h=0,this.hash_size=0,this.hash_bits=0,this.hash_mask=0,this.hash_shift=0,this.block_start=0,this.match_length=0,this.prev_match=0,this.match_available=0,this.strstart=0,this.match_start=0,this.lookahead=0,this.prev_length=0,this.max_chain_length=0,this.max_lazy_match=0,this.level=0,this.strategy=0,this.good_match=0,this.nice_match=0,this.dyn_ltree=new Uint16Array(y5*2),this.dyn_dtree=new Uint16Array((2*v5+1)*2),this.bl_tree=new Uint16Array((2*S5+1)*2),n(this.dyn_ltree),n(this.dyn_dtree),n(this.bl_tree),this.l_desc=null,this.d_desc=null,this.bl_desc=null,this.bl_count=new Uint16Array(E5+1),this.heap=new Uint16Array(2*O1+1),n(this.heap),this.heap_len=0,this.heap_max=0,this.depth=new Uint16Array(2*O1+1),n(this.depth),this.sym_buf=0,this.lit_bufsize=0,this.sym_next=0,this.sym_end=0,this.opt_len=0,this.static_len=0,this.matches=0,this.insert=0,this.bi_buf=0,this.bi_valid=0},KJ=function(){this.input=null,this.next_in=0,this.avail_in=0,this.total_in=0,this.output=null,this.next_out=0,this.avail_out=0,this.total_out=0,this.msg="",this.state=null,this.data_type=2,this.adler=0},h0=function(J){this.options=W1.assign({level:NJ,method:gJ,chunkSize:16384,windowBits:15,memLevel:8,strategy:$J},J||{});let W=this.options;if(W.raw&&W.windowBits>0)W.windowBits=-W.windowBits;else if(W.gzip&&W.windowBits>0&&W.windowBits<16)W.windowBits+=16;this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new q6,this.strm.avail_out=0;let Q=L0.deflateInit2(this.strm,W.level,W.method,W.windowBits,W.memLevel,W.strategy);if(Q!==s0)throw new Error(V0[Q]);if(W.header)L0.deflateSetHeader(this.strm,W.header);if(W.dictionary){let V;if(typeof W.dictionary==="string")V=S0.string2buf(W.dictionary);else if(G6.call(W.dictionary)==="[object ArrayBuffer]")V=new Uint8Array(W.dictionary);else V=W.dictionary;if(Q=L0.deflateSetDictionary(this.strm,V),Q!==s0)throw new Error(V0[Q]);this._dict_set=!0}},f1=function(J,W){const Q=new h0(W);if(Q.push(J,!0),Q.err)throw Q.msg||V0[Q.err];return Q.result},IJ=function(J,W){return W=W||{},W.raw=!0,f1(J,W)},jJ=function(J,W){return W=W||{},W.gzip=!0,f1(J,W)},iJ=function(){this.strm=null,this.mode=0,this.last=!1,this.wrap=0,this.havedict=!1,this.flags=0,this.dmax=0,this.check=0,this.total=0,this.head=null,this.wbits=0,this.wsize=0,this.whave=0,this.wnext=0,this.window=null,this.hold=0,this.bits=0,this.length=0,this.offset=0,this.extra=0,this.lencode=null,this.distcode=null,this.lenbits=0,this.distbits=0,this.ncode=0,this.nlen=0,this.ndist=0,this.have=0,this.next=null,this.lens=new Uint16Array(320),this.work=new Uint16Array(288),this.lendyn=null,this.distdyn=null,this.sane=0,this.back=0,this.was=0},PQ=function(){this.text=0,this.time=0,this.xflags=0,this.os=0,this.extra=null,this.extra_len=0,this.name="",this.comment="",this.hcrc=0,this.done=!1},f0=function(J){this.options=W1.assign({chunkSize:65536,windowBits:15,to:""},J||{});const W=this.options;if(W.raw&&W.windowBits>=0&&W.windowBits<16){if(W.windowBits=-W.windowBits,W.windowBits===0)W.windowBits=-15}if(W.windowBits>=0&&W.windowBits<16&&!(J&&J.windowBits))W.windowBits+=32;if(W.windowBits>15&&W.windowBits<48){if((W.windowBits&15)===0)W.windowBits|=15}this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new q6,this.strm.avail_out=0;let Q=_.inflateInit2(this.strm,W.windowBits);if(Q!==y0)throw new Error(V0[Q]);if(this.header=new UQ,_.inflateGetHeader(this.strm,this.header),W.dictionary){if(typeof W.dictionary==="string")W.dictionary=S0.string2buf(W.dictionary);else if(N6.call(W.dictionary)==="[object ArrayBuffer]")W.dictionary=new Uint8Array(W.dictionary);if(W.raw){if(Q=_.inflateSetDictionary(this.strm,W.dictionary),Q!==y0)throw new Error(V0[Q])}}},m1=function(J,W){const Q=new f0(W);if(Q.push(J),Q.err)throw Q.msg||V0[Q.err];return Q.result},kQ=function(J,W){return W=W||{},W.raw=!0,m1(J,W)};/*! pako 2.1.0 https://github.com/nodeca/pako @license (MIT AND Zlib) */var c6=0,h8=1,d6=2,i6=3,l6=258,S1=29,E0=256,O0=E0+1+S1,z0=30,y1=19,f8=2*O0+1,J0=15,F1=16,_6=7,E1=256,m8=16,b8=17,u8=18,B1=new Uint8Array([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0]),e0=new Uint8Array([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13]),n6=new Uint8Array([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7]),c8=new Uint8Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),r6=512,l=new Array((O0+2)*2);H0(l);var B0=new Array(z0*2);H0(B0);var x0=new Array(r6);H0(x0);var D0=new Array(l6-i6+1);H0(D0);var p1=new Array(S1);H0(p1);var t0=new Array(z0);H0(t0);var d8,i8,l8,_8=(J)=>{return J<256?x0[J]:x0[256+(J>>>7)]},A0=(J,W)=>{J.pending_buf[J.pending++]=W&255,J.pending_buf[J.pending++]=W>>>8&255},E=(J,W,Q)=>{if(J.bi_valid>F1-Q)J.bi_buf|=W<<J.bi_valid&65535,A0(J,J.bi_buf),J.bi_buf=W>>F1-J.bi_valid,J.bi_valid+=Q-F1;else J.bi_buf|=W<<J.bi_valid&65535,J.bi_valid+=Q},u=(J,W,Q)=>{E(J,Q[W*2],Q[W*2+1])},n8=(J,W)=>{let Q=0;do Q|=J&1,J>>>=1,Q<<=1;while(--W>0);return Q>>>1},o6=(J)=>{if(J.bi_valid===16)A0(J,J.bi_buf),J.bi_buf=0,J.bi_valid=0;else if(J.bi_valid>=8)J.pending_buf[J.pending++]=J.bi_buf&255,J.bi_buf>>=8,J.bi_valid-=8},a6=(J,W)=>{const{dyn_tree:Q,max_code:V}=W,q=W.stat_desc.static_tree,G=W.stat_desc.has_stree,U=W.stat_desc.extra_bits,P=W.stat_desc.extra_base,K=W.stat_desc.max_length;let X,Y,$,k,F,Z,D=0;for(k=0;k<=J0;k++)J.bl_count[k]=0;Q[J.heap[J.heap_max]*2+1]=0;for(X=J.heap_max+1;X<f8;X++){if(Y=J.heap[X],k=Q[Q[Y*2+1]*2+1]+1,k>K)k=K,D++;if(Q[Y*2+1]=k,Y>V)continue;if(J.bl_count[k]++,F=0,Y>=P)F=U[Y-P];if(Z=Q[Y*2],J.opt_len+=Z*(k+F),G)J.static_len+=Z*(q[Y*2+1]+F)}if(D===0)return;do{k=K-1;while(J.bl_count[k]===0)k--;J.bl_count[k]--,J.bl_count[k+1]+=2,J.bl_count[K]--,D-=2}while(D>0);for(k=K;k!==0;k--){Y=J.bl_count[k];while(Y!==0){if($=J.heap[--X],$>V)continue;if(Q[$*2+1]!==k)J.opt_len+=(k-Q[$*2+1])*Q[$*2],Q[$*2+1]=k;Y--}}},r8=(J,W,Q)=>{const V=new Array(J0+1);let q=0,G,U;for(G=1;G<=J0;G++)q=q+Q[G-1]<<1,V[G]=q;for(U=0;U<=W;U++){let P=J[U*2+1];if(P===0)continue;J[U*2]=n8(V[P]++,P)}},e6=()=>{let J,W,Q,V,q;const G=new Array(J0+1);Q=0;for(V=0;V<S1-1;V++){p1[V]=Q;for(J=0;J<1<<B1[V];J++)D0[Q++]=V}D0[Q-1]=V,q=0;for(V=0;V<16;V++){t0[V]=q;for(J=0;J<1<<e0[V];J++)x0[q++]=V}q>>=7;for(;V<z0;V++){t0[V]=q<<7;for(J=0;J<1<<e0[V]-7;J++)x0[256+q++]=V}for(W=0;W<=J0;W++)G[W]=0;J=0;while(J<=143)l[J*2+1]=8,J++,G[8]++;while(J<=255)l[J*2+1]=9,J++,G[9]++;while(J<=279)l[J*2+1]=7,J++,G[7]++;while(J<=287)l[J*2+1]=8,J++,G[8]++;r8(l,O0+1,G);for(J=0;J<z0;J++)B0[J*2+1]=5,B0[J*2]=n8(J,5);d8=new K1(l,B1,E0+1,O0,J0),i8=new K1(B0,e0,0,z0,J0),l8=new K1(new Array(0),n6,0,y1,_6)},o8=(J)=>{let W;for(W=0;W<O0;W++)J.dyn_ltree[W*2]=0;for(W=0;W<z0;W++)J.dyn_dtree[W*2]=0;for(W=0;W<y1;W++)J.bl_tree[W*2]=0;J.dyn_ltree[E1*2]=1,J.opt_len=J.static_len=0,J.sym_next=J.matches=0},a8=(J)=>{if(J.bi_valid>8)A0(J,J.bi_buf);else if(J.bi_valid>0)J.pending_buf[J.pending++]=J.bi_buf;J.bi_buf=0,J.bi_valid=0},s1=(J,W,Q,V)=>{const q=W*2,G=Q*2;return J[q]<J[G]||J[q]===J[G]&&V[W]<=V[Q]},k1=(J,W,Q)=>{const V=J.heap[Q];let q=Q<<1;while(q<=J.heap_len){if(q<J.heap_len&&s1(W,J.heap[q+1],J.heap[q],J.depth))q++;if(s1(W,V,J.heap[q],J.depth))break;J.heap[Q]=J.heap[q],Q=q,q<<=1}J.heap[Q]=V},J8=(J,W,Q)=>{let V,q,G=0,U,P;if(J.sym_next!==0)do if(V=J.pending_buf[J.sym_buf+G++]&255,V+=(J.pending_buf[J.sym_buf+G++]&255)<<8,q=J.pending_buf[J.sym_buf+G++],V===0)u(J,q,W);else{if(U=D0[q],u(J,U+E0+1,W),P=B1[U],P!==0)q-=p1[U],E(J,q,P);if(V--,U=_8(V),u(J,U,Q),P=e0[U],P!==0)V-=t0[U],E(J,V,P)}while(G<J.sym_next);u(J,E1,W)},L1=(J,W)=>{const Q=W.dyn_tree,V=W.stat_desc.static_tree,q=W.stat_desc.has_stree,G=W.stat_desc.elems;let U,P,K=-1,X;J.heap_len=0,J.heap_max=f8;for(U=0;U<G;U++)if(Q[U*2]!==0)J.heap[++J.heap_len]=K=U,J.depth[U]=0;else Q[U*2+1]=0;while(J.heap_len<2)if(X=J.heap[++J.heap_len]=K<2?++K:0,Q[X*2]=1,J.depth[X]=0,J.opt_len--,q)J.static_len-=V[X*2+1];W.max_code=K;for(U=J.heap_len>>1;U>=1;U--)k1(J,Q,U);X=G;do U=J.heap[1],J.heap[1]=J.heap[J.heap_len--],k1(J,Q,1),P=J.heap[1],J.heap[--J.heap_max]=U,J.heap[--J.heap_max]=P,Q[X*2]=Q[U*2]+Q[P*2],J.depth[X]=(J.depth[U]>=J.depth[P]?J.depth[U]:J.depth[P])+1,Q[U*2+1]=Q[P*2+1]=X,J.heap[1]=X++,k1(J,Q,1);while(J.heap_len>=2);J.heap[--J.heap_max]=J.heap[1],a6(J,W),r8(Q,K,J.bl_count)},Q8=(J,W,Q)=>{let V,q=-1,G,U=W[1],P=0,K=7,X=4;if(U===0)K=138,X=3;W[(Q+1)*2+1]=65535;for(V=0;V<=Q;V++){if(G=U,U=W[(V+1)*2+1],++P<K&&G===U)continue;else if(P<X)J.bl_tree[G*2]+=P;else if(G!==0){if(G!==q)J.bl_tree[G*2]++;J.bl_tree[m8*2]++}else if(P<=10)J.bl_tree[b8*2]++;else J.bl_tree[u8*2]++;if(P=0,q=G,U===0)K=138,X=3;else if(G===U)K=6,X=3;else K=7,X=4}},W8=(J,W,Q)=>{let V,q=-1,G,U=W[1],P=0,K=7,X=4;if(U===0)K=138,X=3;for(V=0;V<=Q;V++){if(G=U,U=W[(V+1)*2+1],++P<K&&G===U)continue;else if(P<X)do u(J,G,J.bl_tree);while(--P!==0);else if(G!==0){if(G!==q)u(J,G,J.bl_tree),P--;u(J,m8,J.bl_tree),E(J,P-3,2)}else if(P<=10)u(J,b8,J.bl_tree),E(J,P-3,3);else u(J,u8,J.bl_tree),E(J,P-11,7);if(P=0,q=G,U===0)K=138,X=3;else if(G===U)K=6,X=3;else K=7,X=4}},t6=(J)=>{let W;Q8(J,J.dyn_ltree,J.l_desc.max_code),Q8(J,J.dyn_dtree,J.d_desc.max_code),L1(J,J.bl_desc);for(W=y1-1;W>=3;W--)if(J.bl_tree[c8[W]*2+1]!==0)break;return J.opt_len+=3*(W+1)+5+5+4,W},s6=(J,W,Q,V)=>{let q;E(J,W-257,5),E(J,Q-1,5),E(J,V-4,4);for(q=0;q<V;q++)E(J,J.bl_tree[c8[q]*2+1],3);W8(J,J.dyn_ltree,W-1),W8(J,J.dyn_dtree,Q-1)},J5=(J)=>{let W=4093624447,Q;for(Q=0;Q<=31;Q++,W>>>=1)if(W&1&&J.dyn_ltree[Q*2]!==0)return 0;if(J.dyn_ltree[18]!==0||J.dyn_ltree[20]!==0||J.dyn_ltree[26]!==0)return 1;for(Q=32;Q<E0;Q++)if(J.dyn_ltree[Q*2]!==0)return 1;return 0},V8=!1,Q5=(J)=>{if(!V8)e6(),V8=!0;J.l_desc=new z1(J.dyn_ltree,d8),J.d_desc=new z1(J.dyn_dtree,i8),J.bl_desc=new z1(J.bl_tree,l8),J.bi_buf=0,J.bi_valid=0,o8(J)},e8=(J,W,Q,V)=>{if(E(J,(c6<<1)+(V?1:0),3),a8(J),A0(J,Q),A0(J,~Q),Q)J.pending_buf.set(J.window.subarray(W,W+Q),J.pending);J.pending+=Q},W5=(J)=>{E(J,h8<<1,3),u(J,E1,l),o6(J)},V5=(J,W,Q,V)=>{let q,G,U=0;if(J.level>0){if(J.strm.data_type===2)J.strm.data_type=J5(J);if(L1(J,J.l_desc),L1(J,J.d_desc),U=t6(J),q=J.opt_len+3+7>>>3,G=J.static_len+3+7>>>3,G<=q)q=G}else q=G=Q+5;if(Q+4<=q&&W!==-1)e8(J,W,Q,V);else if(J.strategy===4||G===q)E(J,(h8<<1)+(V?1:0),3),J8(J,l,B0);else E(J,(d6<<1)+(V?1:0),3),s6(J,J.l_desc.max_code+1,J.d_desc.max_code+1,U+1),J8(J,J.dyn_ltree,J.dyn_dtree);if(o8(J),V)a8(J)},q5=(J,W,Q)=>{if(J.pending_buf[J.sym_buf+J.sym_next++]=W,J.pending_buf[J.sym_buf+J.sym_next++]=W>>8,J.pending_buf[J.sym_buf+J.sym_next++]=Q,W===0)J.dyn_ltree[Q*2]++;else J.matches++,W--,J.dyn_ltree[(D0[Q]+E0+1)*2]++,J.dyn_dtree[_8(W)*2]++;return J.sym_next===J.sym_end},G5=Q5,X5=e8,P5=V5,U5=q5,Y5=W5,F5={_tr_init:G5,_tr_stored_block:X5,_tr_flush_block:P5,_tr_tally:U5,_tr_align:Y5},K5=(J,W,Q,V)=>{let q=J&65535|0,G=J>>>16&65535|0,U=0;while(Q!==0){U=Q>2000?2000:Q,Q-=U;do q=q+W[V++]|0,G=G+q|0;while(--U);q%=65521,G%=65521}return q|G<<16|0},T0=K5,z5=()=>{let J,W=[];for(var Q=0;Q<256;Q++){J=Q;for(var V=0;V<8;V++)J=J&1?3988292384^J>>>1:J>>>1;W[Q]=J}return W},k5=new Uint32Array(z5()),Z5=(J,W,Q,V)=>{const q=k5,G=V+Q;J^=-1;for(let U=V;U<G;U++)J=J>>>8^q[(J^W[U])&255];return J^-1},T=Z5,V0={2:"need dictionary",1:"stream end",0:"","-1":"file error","-2":"stream error","-3":"data error","-4":"insufficient memory","-5":"buffer error","-6":"incompatible version"},X0={Z_NO_FLUSH:0,Z_PARTIAL_FLUSH:1,Z_SYNC_FLUSH:2,Z_FULL_FLUSH:3,Z_FINISH:4,Z_BLOCK:5,Z_TREES:6,Z_OK:0,Z_STREAM_END:1,Z_NEED_DICT:2,Z_ERRNO:-1,Z_STREAM_ERROR:-2,Z_DATA_ERROR:-3,Z_MEM_ERROR:-4,Z_BUF_ERROR:-5,Z_NO_COMPRESSION:0,Z_BEST_SPEED:1,Z_BEST_COMPRESSION:9,Z_DEFAULT_COMPRESSION:-1,Z_FILTERED:1,Z_HUFFMAN_ONLY:2,Z_RLE:3,Z_FIXED:4,Z_DEFAULT_STRATEGY:0,Z_BINARY:0,Z_TEXT:1,Z_UNKNOWN:2,Z_DEFLATED:8},{_tr_init:H5,_tr_stored_block:w1,_tr_flush_block:C5,_tr_tally:o,_tr_align:N5}=F5,{Z_NO_FLUSH:a,Z_PARTIAL_FLUSH:$5,Z_FULL_FLUSH:g5,Z_FINISH:f,Z_BLOCK:q8,Z_OK:v,Z_STREAM_END:G8,Z_STREAM_ERROR:c,Z_DATA_ERROR:I5,Z_BUF_ERROR:Z1,Z_DEFAULT_COMPRESSION:j5,Z_FILTERED:R5,Z_HUFFMAN_ONLY:_0,Z_RLE:M5,Z_FIXED:B5,Z_DEFAULT_STRATEGY:L5,Z_UNKNOWN:w5,Z_DEFLATED:Q1}=X0,O5=9,x5=15,D5=8,A5=29,T5=256,O1=T5+1+A5,v5=30,S5=19,y5=2*O1+1,E5=15,j=3,r=258,d=r+j+1,p5=32,k0=42,h1=57,x1=69,D1=73,A1=91,T1=103,Q0=113,R0=666,y=1,C0=2,q0=3,N0=4,h5=3,W0=(J,W)=>{return J.msg=V0[W],W},X8=(J)=>{return J*2-(J>4?9:0)},n=(J)=>{let W=J.length;while(--W>=0)J[W]=0},f5=(J)=>{let W,Q,V,q=J.w_size;W=J.hash_size,V=W;do Q=J.head[--V],J.head[V]=Q>=q?Q-q:0;while(--W);W=q,V=W;do Q=J.prev[--V],J.prev[V]=Q>=q?Q-q:0;while(--W)},m5=(J,W,Q)=>(W<<J.hash_shift^Q)&J.hash_mask,e=m5,p=(J)=>{const W=J.state;let Q=W.pending;if(Q>J.avail_out)Q=J.avail_out;if(Q===0)return;if(J.output.set(W.pending_buf.subarray(W.pending_out,W.pending_out+Q),J.next_out),J.next_out+=Q,W.pending_out+=Q,J.total_out+=Q,J.avail_out-=Q,W.pending-=Q,W.pending===0)W.pending_out=0},h=(J,W)=>{C5(J,J.block_start>=0?J.block_start:-1,J.strstart-J.block_start,W),J.block_start=J.strstart,p(J.strm)},L=(J,W)=>{J.pending_buf[J.pending++]=W},j0=(J,W)=>{J.pending_buf[J.pending++]=W>>>8&255,J.pending_buf[J.pending++]=W&255},v1=(J,W,Q,V)=>{let q=J.avail_in;if(q>V)q=V;if(q===0)return 0;if(J.avail_in-=q,W.set(J.input.subarray(J.next_in,J.next_in+q),Q),J.state.wrap===1)J.adler=T0(J.adler,W,q,Q);else if(J.state.wrap===2)J.adler=T(J.adler,W,q,Q);return J.next_in+=q,J.total_in+=q,q},t8=(J,W)=>{let{max_chain_length:Q,strstart:V}=J,q,G,U=J.prev_length,P=J.nice_match;const K=J.strstart>J.w_size-d?J.strstart-(J.w_size-d):0,X=J.window,Y=J.w_mask,$=J.prev,k=J.strstart+r;let F=X[V+U-1],Z=X[V+U];if(J.prev_length>=J.good_match)Q>>=2;if(P>J.lookahead)P=J.lookahead;do{if(q=W,X[q+U]!==Z||X[q+U-1]!==F||X[q]!==X[V]||X[++q]!==X[V+1])continue;V+=2,q++;do;while(X[++V]===X[++q]&&X[++V]===X[++q]&&X[++V]===X[++q]&&X[++V]===X[++q]&&X[++V]===X[++q]&&X[++V]===X[++q]&&X[++V]===X[++q]&&X[++V]===X[++q]&&V<k);if(G=r-(k-V),V=k-r,G>U){if(J.match_start=W,U=G,G>=P)break;F=X[V+U-1],Z=X[V+U]}}while((W=$[W&Y])>K&&--Q!==0);if(U<=J.lookahead)return U;return J.lookahead},Z0=(J)=>{const W=J.w_size;let Q,V,q;do{if(V=J.window_size-J.lookahead-J.strstart,J.strstart>=W+(W-d)){if(J.window.set(J.window.subarray(W,W+W-V),0),J.match_start-=W,J.strstart-=W,J.block_start-=W,J.insert>J.strstart)J.insert=J.strstart;f5(J),V+=W}if(J.strm.avail_in===0)break;if(Q=v1(J.strm,J.window,J.strstart+J.lookahead,V),J.lookahead+=Q,J.lookahead+J.insert>=j){q=J.strstart-J.insert,J.ins_h=J.window[q],J.ins_h=e(J,J.ins_h,J.window[q+1]);while(J.insert)if(J.ins_h=e(J,J.ins_h,J.window[q+j-1]),J.prev[q&J.w_mask]=J.head[J.ins_h],J.head[J.ins_h]=q,q++,J.insert--,J.lookahead+J.insert<j)break}}while(J.lookahead<d&&J.strm.avail_in!==0)},s8=(J,W)=>{let Q=J.pending_buf_size-5>J.w_size?J.w_size:J.pending_buf_size-5,V,q,G,U=0,P=J.strm.avail_in;do{if(V=65535,G=J.bi_valid+42>>3,J.strm.avail_out<G)break;if(G=J.strm.avail_out-G,q=J.strstart-J.block_start,V>q+J.strm.avail_in)V=q+J.strm.avail_in;if(V>G)V=G;if(V<Q&&(V===0&&W!==f||W===a||V!==q+J.strm.avail_in))break;if(U=W===f&&V===q+J.strm.avail_in?1:0,w1(J,0,0,U),J.pending_buf[J.pending-4]=V,J.pending_buf[J.pending-3]=V>>8,J.pending_buf[J.pending-2]=~V,J.pending_buf[J.pending-1]=~V>>8,p(J.strm),q){if(q>V)q=V;J.strm.output.set(J.window.subarray(J.block_start,J.block_start+q),J.strm.next_out),J.strm.next_out+=q,J.strm.avail_out-=q,J.strm.total_out+=q,J.block_start+=q,V-=q}if(V)v1(J.strm,J.strm.output,J.strm.next_out,V),J.strm.next_out+=V,J.strm.avail_out-=V,J.strm.total_out+=V}while(U===0);if(P-=J.strm.avail_in,P){if(P>=J.w_size)J.matches=2,J.window.set(J.strm.input.subarray(J.strm.next_in-J.w_size,J.strm.next_in),0),J.strstart=J.w_size,J.insert=J.strstart;else{if(J.window_size-J.strstart<=P){if(J.strstart-=J.w_size,J.window.set(J.window.subarray(J.w_size,J.w_size+J.strstart),0),J.matches<2)J.matches++;if(J.insert>J.strstart)J.insert=J.strstart}J.window.set(J.strm.input.subarray(J.strm.next_in-P,J.strm.next_in),J.strstart),J.strstart+=P,J.insert+=P>J.w_size-J.insert?J.w_size-J.insert:P}J.block_start=J.strstart}if(J.high_water<J.strstart)J.high_water=J.strstart;if(U)return N0;if(W!==a&&W!==f&&J.strm.avail_in===0&&J.strstart===J.block_start)return C0;if(G=J.window_size-J.strstart,J.strm.avail_in>G&&J.block_start>=J.w_size){if(J.block_start-=J.w_size,J.strstart-=J.w_size,J.window.set(J.window.subarray(J.w_size,J.w_size+J.strstart),0),J.matches<2)J.matches++;if(G+=J.w_size,J.insert>J.strstart)J.insert=J.strstart}if(G>J.strm.avail_in)G=J.strm.avail_in;if(G)v1(J.strm,J.window,J.strstart,G),J.strstart+=G,J.insert+=G>J.w_size-J.insert?J.w_size-J.insert:G;if(J.high_water<J.strstart)J.high_water=J.strstart;if(G=J.bi_valid+42>>3,G=J.pending_buf_size-G>65535?65535:J.pending_buf_size-G,Q=G>J.w_size?J.w_size:G,q=J.strstart-J.block_start,q>=Q||(q||W===f)&&W!==a&&J.strm.avail_in===0&&q<=G)V=q>G?G:q,U=W===f&&J.strm.avail_in===0&&V===q?1:0,w1(J,J.block_start,V,U),J.block_start+=V,p(J.strm);return U?q0:y},H1=(J,W)=>{let Q,V;for(;;){if(J.lookahead<d){if(Z0(J),J.lookahead<d&&W===a)return y;if(J.lookahead===0)break}if(Q=0,J.lookahead>=j)J.ins_h=e(J,J.ins_h,J.window[J.strstart+j-1]),Q=J.prev[J.strstart&J.w_mask]=J.head[J.ins_h],J.head[J.ins_h]=J.strstart;if(Q!==0&&J.strstart-Q<=J.w_size-d)J.match_length=t8(J,Q);if(J.match_length>=j)if(V=o(J,J.strstart-J.match_start,J.match_length-j),J.lookahead-=J.match_length,J.match_length<=J.max_lazy_match&&J.lookahead>=j){J.match_length--;do J.strstart++,J.ins_h=e(J,J.ins_h,J.window[J.strstart+j-1]),Q=J.prev[J.strstart&J.w_mask]=J.head[J.ins_h],J.head[J.ins_h]=J.strstart;while(--J.match_length!==0);J.strstart++}else J.strstart+=J.match_length,J.match_length=0,J.ins_h=J.window[J.strstart],J.ins_h=e(J,J.ins_h,J.window[J.strstart+1]);else V=o(J,0,J.window[J.strstart]),J.lookahead--,J.strstart++;if(V){if(h(J,!1),J.strm.avail_out===0)return y}}if(J.insert=J.strstart<j-1?J.strstart:j-1,W===f){if(h(J,!0),J.strm.avail_out===0)return q0;return N0}if(J.sym_next){if(h(J,!1),J.strm.avail_out===0)return y}return C0},F0=(J,W)=>{let Q,V,q;for(;;){if(J.lookahead<d){if(Z0(J),J.lookahead<d&&W===a)return y;if(J.lookahead===0)break}if(Q=0,J.lookahead>=j)J.ins_h=e(J,J.ins_h,J.window[J.strstart+j-1]),Q=J.prev[J.strstart&J.w_mask]=J.head[J.ins_h],J.head[J.ins_h]=J.strstart;if(J.prev_length=J.match_length,J.prev_match=J.match_start,J.match_length=j-1,Q!==0&&J.prev_length<J.max_lazy_match&&J.strstart-Q<=J.w_size-d){if(J.match_length=t8(J,Q),J.match_length<=5&&(J.strategy===R5||J.match_length===j&&J.strstart-J.match_start>4096))J.match_length=j-1}if(J.prev_length>=j&&J.match_length<=J.prev_length){q=J.strstart+J.lookahead-j,V=o(J,J.strstart-1-J.prev_match,J.prev_length-j),J.lookahead-=J.prev_length-1,J.prev_length-=2;do if(++J.strstart<=q)J.ins_h=e(J,J.ins_h,J.window[J.strstart+j-1]),Q=J.prev[J.strstart&J.w_mask]=J.head[J.ins_h],J.head[J.ins_h]=J.strstart;while(--J.prev_length!==0);if(J.match_available=0,J.match_length=j-1,J.strstart++,V){if(h(J,!1),J.strm.avail_out===0)return y}}else if(J.match_available){if(V=o(J,0,J.window[J.strstart-1]),V)h(J,!1);if(J.strstart++,J.lookahead--,J.strm.avail_out===0)return y}else J.match_available=1,J.strstart++,J.lookahead--}if(J.match_available)V=o(J,0,J.window[J.strstart-1]),J.match_available=0;if(J.insert=J.strstart<j-1?J.strstart:j-1,W===f){if(h(J,!0),J.strm.avail_out===0)return q0;return N0}if(J.sym_next){if(h(J,!1),J.strm.avail_out===0)return y}return C0},b5=(J,W)=>{let Q,V,q,G;const U=J.window;for(;;){if(J.lookahead<=r){if(Z0(J),J.lookahead<=r&&W===a)return y;if(J.lookahead===0)break}if(J.match_length=0,J.lookahead>=j&&J.strstart>0){if(q=J.strstart-1,V=U[q],V===U[++q]&&V===U[++q]&&V===U[++q]){G=J.strstart+r;do;while(V===U[++q]&&V===U[++q]&&V===U[++q]&&V===U[++q]&&V===U[++q]&&V===U[++q]&&V===U[++q]&&V===U[++q]&&q<G);if(J.match_length=r-(G-q),J.match_length>J.lookahead)J.match_length=J.lookahead}}if(J.match_length>=j)Q=o(J,1,J.match_length-j),J.lookahead-=J.match_length,J.strstart+=J.match_length,J.match_length=0;else Q=o(J,0,J.window[J.strstart]),J.lookahead--,J.strstart++;if(Q){if(h(J,!1),J.strm.avail_out===0)return y}}if(J.insert=0,W===f){if(h(J,!0),J.strm.avail_out===0)return q0;return N0}if(J.sym_next){if(h(J,!1),J.strm.avail_out===0)return y}return C0},u5=(J,W)=>{let Q;for(;;){if(J.lookahead===0){if(Z0(J),J.lookahead===0){if(W===a)return y;break}}if(J.match_length=0,Q=o(J,0,J.window[J.strstart]),J.lookahead--,J.strstart++,Q){if(h(J,!1),J.strm.avail_out===0)return y}}if(J.insert=0,W===f){if(h(J,!0),J.strm.avail_out===0)return q0;return N0}if(J.sym_next){if(h(J,!1),J.strm.avail_out===0)return y}return C0},M0=[new b(0,0,0,0,s8),new b(4,4,8,4,H1),new b(4,5,16,8,H1),new b(4,6,32,32,H1),new b(4,4,16,16,F0),new b(8,16,32,32,F0),new b(8,16,128,128,F0),new b(8,32,128,256,F0),new b(32,128,258,1024,F0),new b(32,258,258,4096,F0)],c5=(J)=>{J.window_size=2*J.w_size,n(J.head),J.max_lazy_match=M0[J.level].max_lazy,J.good_match=M0[J.level].good_length,J.nice_match=M0[J.level].nice_length,J.max_chain_length=M0[J.level].max_chain,J.strstart=0,J.block_start=0,J.lookahead=0,J.insert=0,J.match_length=J.prev_length=j-1,J.match_available=0,J.ins_h=0},p0=(J)=>{if(!J)return 1;const W=J.state;if(!W||W.strm!==J||W.status!==k0&&W.status!==h1&&W.status!==x1&&W.status!==D1&&W.status!==A1&&W.status!==T1&&W.status!==Q0&&W.status!==R0)return 1;return 0},J6=(J)=>{if(p0(J))return W0(J,c);J.total_in=J.total_out=0,J.data_type=w5;const W=J.state;if(W.pending=0,W.pending_out=0,W.wrap<0)W.wrap=-W.wrap;return W.status=W.wrap===2?h1:W.wrap?k0:Q0,J.adler=W.wrap===2?0:1,W.last_flush=-2,H5(W),v},Q6=(J)=>{const W=J6(J);if(W===v)c5(J.state);return W},i5=(J,W)=>{if(p0(J)||J.state.wrap!==2)return c;return J.state.gzhead=W,v},W6=(J,W,Q,V,q,G)=>{if(!J)return c;let U=1;if(W===j5)W=6;if(V<0)U=0,V=-V;else if(V>15)U=2,V-=16;if(q<1||q>O5||Q!==Q1||V<8||V>15||W<0||W>9||G<0||G>B5||V===8&&U!==1)return W0(J,c);if(V===8)V=9;const P=new d5;return J.state=P,P.strm=J,P.status=k0,P.wrap=U,P.gzhead=null,P.w_bits=V,P.w_size=1<<P.w_bits,P.w_mask=P.w_size-1,P.hash_bits=q+7,P.hash_size=1<<P.hash_bits,P.hash_mask=P.hash_size-1,P.hash_shift=~~((P.hash_bits+j-1)/j),P.window=new Uint8Array(P.w_size*2),P.head=new Uint16Array(P.hash_size),P.prev=new Uint16Array(P.w_size),P.lit_bufsize=1<<q+6,P.pending_buf_size=P.lit_bufsize*4,P.pending_buf=new Uint8Array(P.pending_buf_size),P.sym_buf=P.lit_bufsize,P.sym_end=(P.lit_bufsize-1)*3,P.level=W,P.strategy=G,P.method=Q,Q6(J)},l5=(J,W)=>{return W6(J,W,Q1,x5,D5,L5)},_5=(J,W)=>{if(p0(J)||W>q8||W<0)return J?W0(J,c):c;const Q=J.state;if(!J.output||J.avail_in!==0&&!J.input||Q.status===R0&&W!==f)return W0(J,J.avail_out===0?Z1:c);const V=Q.last_flush;if(Q.last_flush=W,Q.pending!==0){if(p(J),J.avail_out===0)return Q.last_flush=-1,v}else if(J.avail_in===0&&X8(W)<=X8(V)&&W!==f)return W0(J,Z1);if(Q.status===R0&&J.avail_in!==0)return W0(J,Z1);if(Q.status===k0&&Q.wrap===0)Q.status=Q0;if(Q.status===k0){let q=Q1+(Q.w_bits-8<<4)<<8,G=-1;if(Q.strategy>=_0||Q.level<2)G=0;else if(Q.level<6)G=1;else if(Q.level===6)G=2;else G=3;if(q|=G<<6,Q.strstart!==0)q|=p5;if(q+=31-q%31,j0(Q,q),Q.strstart!==0)j0(Q,J.adler>>>16),j0(Q,J.adler&65535);if(J.adler=1,Q.status=Q0,p(J),Q.pending!==0)return Q.last_flush=-1,v}if(Q.status===h1)if(J.adler=0,L(Q,31),L(Q,139),L(Q,8),!Q.gzhead){if(L(Q,0),L(Q,0),L(Q,0),L(Q,0),L(Q,0),L(Q,Q.level===9?2:Q.strategy>=_0||Q.level<2?4:0),L(Q,h5),Q.status=Q0,p(J),Q.pending!==0)return Q.last_flush=-1,v}else{if(L(Q,(Q.gzhead.text?1:0)+(Q.gzhead.hcrc?2:0)+(!Q.gzhead.extra?0:4)+(!Q.gzhead.name?0:8)+(!Q.gzhead.comment?0:16)),L(Q,Q.gzhead.time&255),L(Q,Q.gzhead.time>>8&255),L(Q,Q.gzhead.time>>16&255),L(Q,Q.gzhead.time>>24&255),L(Q,Q.level===9?2:Q.strategy>=_0||Q.level<2?4:0),L(Q,Q.gzhead.os&255),Q.gzhead.extra&&Q.gzhead.extra.length)L(Q,Q.gzhead.extra.length&255),L(Q,Q.gzhead.extra.length>>8&255);if(Q.gzhead.hcrc)J.adler=T(J.adler,Q.pending_buf,Q.pending,0);Q.gzindex=0,Q.status=x1}if(Q.status===x1){if(Q.gzhead.extra){let q=Q.pending,G=(Q.gzhead.extra.length&65535)-Q.gzindex;while(Q.pending+G>Q.pending_buf_size){let P=Q.pending_buf_size-Q.pending;if(Q.pending_buf.set(Q.gzhead.extra.subarray(Q.gzindex,Q.gzindex+P),Q.pending),Q.pending=Q.pending_buf_size,Q.gzhead.hcrc&&Q.pending>q)J.adler=T(J.adler,Q.pending_buf,Q.pending-q,q);if(Q.gzindex+=P,p(J),Q.pending!==0)return Q.last_flush=-1,v;q=0,G-=P}let U=new Uint8Array(Q.gzhead.extra);if(Q.pending_buf.set(U.subarray(Q.gzindex,Q.gzindex+G),Q.pending),Q.pending+=G,Q.gzhead.hcrc&&Q.pending>q)J.adler=T(J.adler,Q.pending_buf,Q.pending-q,q);Q.gzindex=0}Q.status=D1}if(Q.status===D1){if(Q.gzhead.name){let q=Q.pending,G;do{if(Q.pending===Q.pending_buf_size){if(Q.gzhead.hcrc&&Q.pending>q)J.adler=T(J.adler,Q.pending_buf,Q.pending-q,q);if(p(J),Q.pending!==0)return Q.last_flush=-1,v;q=0}if(Q.gzindex<Q.gzhead.name.length)G=Q.gzhead.name.charCodeAt(Q.gzindex++)&255;else G=0;L(Q,G)}while(G!==0);if(Q.gzhead.hcrc&&Q.pending>q)J.adler=T(J.adler,Q.pending_buf,Q.pending-q,q);Q.gzindex=0}Q.status=A1}if(Q.status===A1){if(Q.gzhead.comment){let q=Q.pending,G;do{if(Q.pending===Q.pending_buf_size){if(Q.gzhead.hcrc&&Q.pending>q)J.adler=T(J.adler,Q.pending_buf,Q.pending-q,q);if(p(J),Q.pending!==0)return Q.last_flush=-1,v;q=0}if(Q.gzindex<Q.gzhead.comment.length)G=Q.gzhead.comment.charCodeAt(Q.gzindex++)&255;else G=0;L(Q,G)}while(G!==0);if(Q.gzhead.hcrc&&Q.pending>q)J.adler=T(J.adler,Q.pending_buf,Q.pending-q,q)}Q.status=T1}if(Q.status===T1){if(Q.gzhead.hcrc){if(Q.pending+2>Q.pending_buf_size){if(p(J),Q.pending!==0)return Q.last_flush=-1,v}L(Q,J.adler&255),L(Q,J.adler>>8&255),J.adler=0}if(Q.status=Q0,p(J),Q.pending!==0)return Q.last_flush=-1,v}if(J.avail_in!==0||Q.lookahead!==0||W!==a&&Q.status!==R0){let q=Q.level===0?s8(Q,W):Q.strategy===_0?u5(Q,W):Q.strategy===M5?b5(Q,W):M0[Q.level].func(Q,W);if(q===q0||q===N0)Q.status=R0;if(q===y||q===q0){if(J.avail_out===0)Q.last_flush=-1;return v}if(q===C0){if(W===$5)N5(Q);else if(W!==q8){if(w1(Q,0,0,!1),W===g5){if(n(Q.head),Q.lookahead===0)Q.strstart=0,Q.block_start=0,Q.insert=0}}if(p(J),J.avail_out===0)return Q.last_flush=-1,v}}if(W!==f)return v;if(Q.wrap<=0)return G8;if(Q.wrap===2)L(Q,J.adler&255),L(Q,J.adler>>8&255),L(Q,J.adler>>16&255),L(Q,J.adler>>24&255),L(Q,J.total_in&255),L(Q,J.total_in>>8&255),L(Q,J.total_in>>16&255),L(Q,J.total_in>>24&255);else j0(Q,J.adler>>>16),j0(Q,J.adler&65535);if(p(J),Q.wrap>0)Q.wrap=-Q.wrap;return Q.pending!==0?v:G8},n5=(J)=>{if(p0(J))return c;const W=J.state.status;return J.state=null,W===Q0?W0(J,I5):v},r5=(J,W)=>{let Q=W.length;if(p0(J))return c;const V=J.state,q=V.wrap;if(q===2||q===1&&V.status!==k0||V.lookahead)return c;if(q===1)J.adler=T0(J.adler,W,Q,0);if(V.wrap=0,Q>=V.w_size){if(q===0)n(V.head),V.strstart=0,V.block_start=0,V.insert=0;let K=new Uint8Array(V.w_size);K.set(W.subarray(Q-V.w_size,Q),0),W=K,Q=V.w_size}const{avail_in:G,next_in:U,input:P}=J;J.avail_in=Q,J.next_in=0,J.input=W,Z0(V);while(V.lookahead>=j){let K=V.strstart,X=V.lookahead-(j-1);do V.ins_h=e(V,V.ins_h,V.window[K+j-1]),V.prev[K&V.w_mask]=V.head[V.ins_h],V.head[V.ins_h]=K,K++;while(--X);V.strstart=K,V.lookahead=j-1,Z0(V)}return V.strstart+=V.lookahead,V.block_start=V.strstart,V.insert=V.lookahead,V.lookahead=0,V.match_length=V.prev_length=j-1,V.match_available=0,J.next_in=U,J.input=P,J.avail_in=G,V.wrap=q,v},o5=l5,a5=W6,e5=Q6,t5=J6,s5=i5,JJ=_5,QJ=n5,WJ=r5,VJ="pako deflate (from Nodeca project)",L0={deflateInit:o5,deflateInit2:a5,deflateReset:e5,deflateResetKeep:t5,deflateSetHeader:s5,deflate:JJ,deflateEnd:QJ,deflateSetDictionary:WJ,deflateInfo:VJ},qJ=(J,W)=>{return Object.prototype.hasOwnProperty.call(J,W)},GJ=function(J){const W=Array.prototype.slice.call(arguments,1);while(W.length){const Q=W.shift();if(!Q)continue;if(typeof Q!=="object")throw new TypeError(Q+"must be non-object");for(let V in Q)if(qJ(Q,V))J[V]=Q[V]}return J},XJ=(J)=>{let W=0;for(let V=0,q=J.length;V<q;V++)W+=J[V].length;const Q=new Uint8Array(W);for(let V=0,q=0,G=J.length;V<G;V++){let U=J[V];Q.set(U,q),q+=U.length}return Q},W1={assign:GJ,flattenChunks:XJ},V6=!0;try{String.fromCharCode.apply(null,new Uint8Array(1))}catch(J){V6=!1}var v0=new Uint8Array(256);for(let J=0;J<256;J++)v0[J]=J>=252?6:J>=248?5:J>=240?4:J>=224?3:J>=192?2:1;v0[254]=v0[254]=1;var PJ=(J)=>{if(typeof TextEncoder==="function"&&TextEncoder.prototype.encode)return(new TextEncoder()).encode(J);let W,Q,V,q,G,U=J.length,P=0;for(q=0;q<U;q++){if(Q=J.charCodeAt(q),(Q&64512)===55296&&q+1<U){if(V=J.charCodeAt(q+1),(V&64512)===56320)Q=65536+(Q-55296<<10)+(V-56320),q++}P+=Q<128?1:Q<2048?2:Q<65536?3:4}W=new Uint8Array(P);for(G=0,q=0;G<P;q++){if(Q=J.charCodeAt(q),(Q&64512)===55296&&q+1<U){if(V=J.charCodeAt(q+1),(V&64512)===56320)Q=65536+(Q-55296<<10)+(V-56320),q++}if(Q<128)W[G++]=Q;else if(Q<2048)W[G++]=192|Q>>>6,W[G++]=128|Q&63;else if(Q<65536)W[G++]=224|Q>>>12,W[G++]=128|Q>>>6&63,W[G++]=128|Q&63;else W[G++]=240|Q>>>18,W[G++]=128|Q>>>12&63,W[G++]=128|Q>>>6&63,W[G++]=128|Q&63}return W},UJ=(J,W)=>{if(W<65534){if(J.subarray&&V6)return String.fromCharCode.apply(null,J.length===W?J:J.subarray(0,W))}let Q="";for(let V=0;V<W;V++)Q+=String.fromCharCode(J[V]);return Q},YJ=(J,W)=>{const Q=W||J.length;if(typeof TextDecoder==="function"&&TextDecoder.prototype.decode)return(new TextDecoder()).decode(J.subarray(0,W));let V,q;const G=new Array(Q*2);for(q=0,V=0;V<Q;){let U=J[V++];if(U<128){G[q++]=U;continue}let P=v0[U];if(P>4){G[q++]=65533,V+=P-1;continue}U&=P===2?31:P===3?15:7;while(P>1&&V<Q)U=U<<6|J[V++]&63,P--;if(P>1){G[q++]=65533;continue}if(U<65536)G[q++]=U;else U-=65536,G[q++]=55296|U>>10&1023,G[q++]=56320|U&1023}return UJ(G,q)},FJ=(J,W)=>{if(W=W||J.length,W>J.length)W=J.length;let Q=W-1;while(Q>=0&&(J[Q]&192)===128)Q--;if(Q<0)return W;if(Q===0)return W;return Q+v0[J[Q]]>W?Q:W},S0={string2buf:PJ,buf2string:YJ,utf8border:FJ},q6=KJ,G6=Object.prototype.toString,{Z_NO_FLUSH:zJ,Z_SYNC_FLUSH:kJ,Z_FULL_FLUSH:ZJ,Z_FINISH:HJ,Z_OK:s0,Z_STREAM_END:CJ,Z_DEFAULT_COMPRESSION:NJ,Z_DEFAULT_STRATEGY:$J,Z_DEFLATED:gJ}=X0;h0.prototype.push=function(J,W){const Q=this.strm,V=this.options.chunkSize;let q,G;if(this.ended)return!1;if(W===~~W)G=W;else G=W===!0?HJ:zJ;if(typeof J==="string")Q.input=S0.string2buf(J);else if(G6.call(J)==="[object ArrayBuffer]")Q.input=new Uint8Array(J);else Q.input=J;Q.next_in=0,Q.avail_in=Q.input.length;for(;;){if(Q.avail_out===0)Q.output=new Uint8Array(V),Q.next_out=0,Q.avail_out=V;if((G===kJ||G===ZJ)&&Q.avail_out<=6){this.onData(Q.output.subarray(0,Q.next_out)),Q.avail_out=0;continue}if(q=L0.deflate(Q,G),q===CJ){if(Q.next_out>0)this.onData(Q.output.subarray(0,Q.next_out));return q=L0.deflateEnd(this.strm),this.onEnd(q),this.ended=!0,q===s0}if(Q.avail_out===0){this.onData(Q.output);continue}if(G>0&&Q.next_out>0){this.onData(Q.output.subarray(0,Q.next_out)),Q.avail_out=0;continue}if(Q.avail_in===0)break}return!0};h0.prototype.onData=function(J){this.chunks.push(J)};h0.prototype.onEnd=function(J){if(J===s0)this.result=W1.flattenChunks(this.chunks);this.chunks=[],this.err=J,this.msg=this.strm.msg};var RJ=h0,MJ=f1,BJ=IJ,LJ=jJ,wJ=X0,OJ={Deflate:RJ,deflate:MJ,deflateRaw:BJ,gzip:LJ,constants:wJ},n0=16209,xJ=16191,DJ=function J(W,Q){let V,q,G,U,P,K,X,Y,$,k,F,Z,D,R,N,w,g,z,B,A,H,O,M,C;const I=W.state;V=W.next_in,M=W.input,q=V+(W.avail_in-5),G=W.next_out,C=W.output,U=G-(Q-W.avail_out),P=G+(W.avail_out-257),K=I.dmax,X=I.wsize,Y=I.whave,$=I.wnext,k=I.window,F=I.hold,Z=I.bits,D=I.lencode,R=I.distcode,N=(1<<I.lenbits)-1,w=(1<<I.distbits)-1;J:do{if(Z<15)F+=M[V++]<<Z,Z+=8,F+=M[V++]<<Z,Z+=8;g=D[F&N];Q:for(;;){if(z=g>>>24,F>>>=z,Z-=z,z=g>>>16&255,z===0)C[G++]=g&65535;else if(z&16){if(B=g&65535,z&=15,z){if(Z<z)F+=M[V++]<<Z,Z+=8;B+=F&(1<<z)-1,F>>>=z,Z-=z}if(Z<15)F+=M[V++]<<Z,Z+=8,F+=M[V++]<<Z,Z+=8;g=R[F&w];W:for(;;){if(z=g>>>24,F>>>=z,Z-=z,z=g>>>16&255,z&16){if(A=g&65535,z&=15,Z<z){if(F+=M[V++]<<Z,Z+=8,Z<z)F+=M[V++]<<Z,Z+=8}if(A+=F&(1<<z)-1,A>K){W.msg="invalid distance too far back",I.mode=n0;break J}if(F>>>=z,Z-=z,z=G-U,A>z){if(z=A-z,z>Y){if(I.sane){W.msg="invalid distance too far back",I.mode=n0;break J}}if(H=0,O=k,$===0){if(H+=X-z,z<B){B-=z;do C[G++]=k[H++];while(--z);H=G-A,O=C}}else if($<z){if(H+=X+$-z,z-=$,z<B){B-=z;do C[G++]=k[H++];while(--z);if(H=0,$<B){z=$,B-=z;do C[G++]=k[H++];while(--z);H=G-A,O=C}}}else if(H+=$-z,z<B){B-=z;do C[G++]=k[H++];while(--z);H=G-A,O=C}while(B>2)C[G++]=O[H++],C[G++]=O[H++],C[G++]=O[H++],B-=3;if(B){if(C[G++]=O[H++],B>1)C[G++]=O[H++]}}else{H=G-A;do C[G++]=C[H++],C[G++]=C[H++],C[G++]=C[H++],B-=3;while(B>2);if(B){if(C[G++]=C[H++],B>1)C[G++]=C[H++]}}}else if((z&64)===0){g=R[(g&65535)+(F&(1<<z)-1)];continue W}else{W.msg="invalid distance code",I.mode=n0;break J}break}}else if((z&64)===0){g=D[(g&65535)+(F&(1<<z)-1)];continue Q}else if(z&32){I.mode=xJ;break J}else{W.msg="invalid literal/length code",I.mode=n0;break J}break}}while(V<q&&G<P);B=Z>>3,V-=B,Z-=B<<3,F&=(1<<Z)-1,W.next_in=V,W.next_out=G,W.avail_in=V<q?5+(q-V):5-(V-q),W.avail_out=G<P?257+(P-G):257-(G-P),I.hold=F,I.bits=Z;return},K0=15,P8=852,U8=592,Y8=0,C1=1,F8=2,AJ=new Uint16Array([3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,0,0]),TJ=new Uint8Array([16,16,16,16,16,16,16,16,17,17,17,17,18,18,18,18,19,19,19,19,20,20,20,20,21,21,21,21,16,72,78]),vJ=new Uint16Array([1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,0,0]),SJ=new Uint8Array([16,16,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,64,64]),yJ=(J,W,Q,V,q,G,U,P)=>{const K=P.bits;let X=0,Y=0,$=0,k=0,F=0,Z=0,D=0,R=0,N=0,w=0,g,z,B,A,H,O=null,M;const C=new Uint16Array(K0+1),I=new Uint16Array(K0+1);let t=null,d1,m0,b0;for(X=0;X<=K0;X++)C[X]=0;for(Y=0;Y<V;Y++)C[W[Q+Y]]++;F=K;for(k=K0;k>=1;k--)if(C[k]!==0)break;if(F>k)F=k;if(k===0)return q[G++]=1<<24|64<<16|0,q[G++]=1<<24|64<<16|0,P.bits=1,0;for($=1;$<k;$++)if(C[$]!==0)break;if(F<$)F=$;R=1;for(X=1;X<=K0;X++)if(R<<=1,R-=C[X],R<0)return-1;if(R>0&&(J===Y8||k!==1))return-1;I[1]=0;for(X=1;X<K0;X++)I[X+1]=I[X]+C[X];for(Y=0;Y<V;Y++)if(W[Q+Y]!==0)U[I[W[Q+Y]]++]=Y;if(J===Y8)O=t=U,M=20;else if(J===C1)O=AJ,t=TJ,M=257;else O=vJ,t=SJ,M=0;if(w=0,Y=0,X=$,H=G,Z=F,D=0,B=-1,N=1<<F,A=N-1,J===C1&&N>P8||J===F8&&N>U8)return 1;for(;;){if(d1=X-D,U[Y]+1<M)m0=0,b0=U[Y];else if(U[Y]>=M)m0=t[U[Y]-M],b0=O[U[Y]-M];else m0=96,b0=0;g=1<<X-D,z=1<<Z,$=z;do z-=g,q[H+(w>>D)+z]=d1<<24|m0<<16|b0|0;while(z!==0);g=1<<X-1;while(w&g)g>>=1;if(g!==0)w&=g-1,w+=g;else w=0;if(Y++,--C[X]===0){if(X===k)break;X=W[Q+U[Y]]}if(X>F&&(w&A)!==B){if(D===0)D=F;H+=$,Z=X-D,R=1<<Z;while(Z+D<k){if(R-=C[Z+D],R<=0)break;Z++,R<<=1}if(N+=1<<Z,J===C1&&N>P8||J===F8&&N>U8)return 1;B=w&A,q[B]=F<<24|Z<<16|H-G|0}}if(w!==0)q[H+w]=X-D<<24|64<<16|0;return P.bits=F,0},w0=yJ,EJ=0,X6=1,P6=2,{Z_FINISH:K8,Z_BLOCK:pJ,Z_TREES:r0,Z_OK:G0,Z_STREAM_END:hJ,Z_NEED_DICT:fJ,Z_STREAM_ERROR:m,Z_DATA_ERROR:U6,Z_MEM_ERROR:Y6,Z_BUF_ERROR:mJ,Z_DEFLATED:z8}=X0,V1=16180,k8=16181,Z8=16182,H8=16183,C8=16184,N8=16185,$8=16186,g8=16187,I8=16188,j8=16189,J1=16190,i=16191,N1=16192,R8=16193,$1=16194,M8=16195,B8=16196,L8=16197,w8=16198,o0=16199,a0=16200,O8=16201,x8=16202,D8=16203,A8=16204,T8=16205,g1=16206,v8=16207,S8=16208,x=16209,F6=16210,K6=16211,bJ=852,uJ=592,cJ=15,dJ=cJ,y8=(J)=>{return(J>>>24&255)+(J>>>8&65280)+((J&65280)<<8)+((J&255)<<24)},P0=(J)=>{if(!J)return 1;const W=J.state;if(!W||W.strm!==J||W.mode<V1||W.mode>K6)return 1;return 0},z6=(J)=>{if(P0(J))return m;const W=J.state;if(J.total_in=J.total_out=W.total=0,J.msg="",W.wrap)J.adler=W.wrap&1;return W.mode=V1,W.last=0,W.havedict=0,W.flags=-1,W.dmax=32768,W.head=null,W.hold=0,W.bits=0,W.lencode=W.lendyn=new Int32Array(bJ),W.distcode=W.distdyn=new Int32Array(uJ),W.sane=1,W.back=-1,G0},k6=(J)=>{if(P0(J))return m;const W=J.state;return W.wsize=0,W.whave=0,W.wnext=0,z6(J)},Z6=(J,W)=>{let Q;if(P0(J))return m;const V=J.state;if(W<0)Q=0,W=-W;else if(Q=(W>>4)+5,W<48)W&=15;if(W&&(W<8||W>15))return m;if(V.window!==null&&V.wbits!==W)V.window=null;return V.wrap=Q,V.wbits=W,k6(J)},H6=(J,W)=>{if(!J)return m;const Q=new iJ;J.state=Q,Q.strm=J,Q.window=null,Q.mode=V1;const V=Z6(J,W);if(V!==G0)J.state=null;return V},lJ=(J)=>{return H6(J,dJ)},E8=!0,I1,j1,_J=(J)=>{if(E8){I1=new Int32Array(512),j1=new Int32Array(32);let W=0;while(W<144)J.lens[W++]=8;while(W<256)J.lens[W++]=9;while(W<280)J.lens[W++]=7;while(W<288)J.lens[W++]=8;w0(X6,J.lens,0,288,I1,0,J.work,{bits:9}),W=0;while(W<32)J.lens[W++]=5;w0(P6,J.lens,0,32,j1,0,J.work,{bits:5}),E8=!1}J.lencode=I1,J.lenbits=9,J.distcode=j1,J.distbits=5},C6=(J,W,Q,V)=>{let q;const G=J.state;if(G.window===null)G.wsize=1<<G.wbits,G.wnext=0,G.whave=0,G.window=new Uint8Array(G.wsize);if(V>=G.wsize)G.window.set(W.subarray(Q-G.wsize,Q),0),G.wnext=0,G.whave=G.wsize;else{if(q=G.wsize-G.wnext,q>V)q=V;if(G.window.set(W.subarray(Q-V,Q-V+q),G.wnext),V-=q,V)G.window.set(W.subarray(Q-V,Q),0),G.wnext=V,G.whave=G.wsize;else{if(G.wnext+=q,G.wnext===G.wsize)G.wnext=0;if(G.whave<G.wsize)G.whave+=q}}return 0},nJ=(J,W)=>{let Q,V,q,G,U,P,K,X,Y,$,k,F,Z,D,R=0,N,w,g,z,B,A,H,O;const M=new Uint8Array(4);let C,I;const t=new Uint8Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]);if(P0(J)||!J.output||!J.input&&J.avail_in!==0)return m;if(Q=J.state,Q.mode===i)Q.mode=N1;U=J.next_out,q=J.output,K=J.avail_out,G=J.next_in,V=J.input,P=J.avail_in,X=Q.hold,Y=Q.bits,$=P,k=K,O=G0;J:for(;;)switch(Q.mode){case V1:if(Q.wrap===0){Q.mode=N1;break}while(Y<16){if(P===0)break J;P--,X+=V[G++]<<Y,Y+=8}if(Q.wrap&2&&X===35615){if(Q.wbits===0)Q.wbits=15;Q.check=0,M[0]=X&255,M[1]=X>>>8&255,Q.check=T(Q.check,M,2,0),X=0,Y=0,Q.mode=k8;break}if(Q.head)Q.head.done=!1;if(!(Q.wrap&1)||(((X&255)<<8)+(X>>8))%31){J.msg="incorrect header check",Q.mode=x;break}if((X&15)!==z8){J.msg="unknown compression method",Q.mode=x;break}if(X>>>=4,Y-=4,H=(X&15)+8,Q.wbits===0)Q.wbits=H;if(H>15||H>Q.wbits){J.msg="invalid window size",Q.mode=x;break}Q.dmax=1<<Q.wbits,Q.flags=0,J.adler=Q.check=1,Q.mode=X&512?j8:i,X=0,Y=0;break;case k8:while(Y<16){if(P===0)break J;P--,X+=V[G++]<<Y,Y+=8}if(Q.flags=X,(Q.flags&255)!==z8){J.msg="unknown compression method",Q.mode=x;break}if(Q.flags&57344){J.msg="unknown header flags set",Q.mode=x;break}if(Q.head)Q.head.text=X>>8&1;if(Q.flags&512&&Q.wrap&4)M[0]=X&255,M[1]=X>>>8&255,Q.check=T(Q.check,M,2,0);X=0,Y=0,Q.mode=Z8;case Z8:while(Y<32){if(P===0)break J;P--,X+=V[G++]<<Y,Y+=8}if(Q.head)Q.head.time=X;if(Q.flags&512&&Q.wrap&4)M[0]=X&255,M[1]=X>>>8&255,M[2]=X>>>16&255,M[3]=X>>>24&255,Q.check=T(Q.check,M,4,0);X=0,Y=0,Q.mode=H8;case H8:while(Y<16){if(P===0)break J;P--,X+=V[G++]<<Y,Y+=8}if(Q.head)Q.head.xflags=X&255,Q.head.os=X>>8;if(Q.flags&512&&Q.wrap&4)M[0]=X&255,M[1]=X>>>8&255,Q.check=T(Q.check,M,2,0);X=0,Y=0,Q.mode=C8;case C8:if(Q.flags&1024){while(Y<16){if(P===0)break J;P--,X+=V[G++]<<Y,Y+=8}if(Q.length=X,Q.head)Q.head.extra_len=X;if(Q.flags&512&&Q.wrap&4)M[0]=X&255,M[1]=X>>>8&255,Q.check=T(Q.check,M,2,0);X=0,Y=0}else if(Q.head)Q.head.extra=null;Q.mode=N8;case N8:if(Q.flags&1024){if(F=Q.length,F>P)F=P;if(F){if(Q.head){if(H=Q.head.extra_len-Q.length,!Q.head.extra)Q.head.extra=new Uint8Array(Q.head.extra_len);Q.head.extra.set(V.subarray(G,G+F),H)}if(Q.flags&512&&Q.wrap&4)Q.check=T(Q.check,V,F,G);P-=F,G+=F,Q.length-=F}if(Q.length)break J}Q.length=0,Q.mode=$8;case $8:if(Q.flags&2048){if(P===0)break J;F=0;do if(H=V[G+F++],Q.head&&H&&Q.length<65536)Q.head.name+=String.fromCharCode(H);while(H&&F<P);if(Q.flags&512&&Q.wrap&4)Q.check=T(Q.check,V,F,G);if(P-=F,G+=F,H)break J}else if(Q.head)Q.head.name=null;Q.length=0,Q.mode=g8;case g8:if(Q.flags&4096){if(P===0)break J;F=0;do if(H=V[G+F++],Q.head&&H&&Q.length<65536)Q.head.comment+=String.fromCharCode(H);while(H&&F<P);if(Q.flags&512&&Q.wrap&4)Q.check=T(Q.check,V,F,G);if(P-=F,G+=F,H)break J}else if(Q.head)Q.head.comment=null;Q.mode=I8;case I8:if(Q.flags&512){while(Y<16){if(P===0)break J;P--,X+=V[G++]<<Y,Y+=8}if(Q.wrap&4&&X!==(Q.check&65535)){J.msg="header crc mismatch",Q.mode=x;break}X=0,Y=0}if(Q.head)Q.head.hcrc=Q.flags>>9&1,Q.head.done=!0;J.adler=Q.check=0,Q.mode=i;break;case j8:while(Y<32){if(P===0)break J;P--,X+=V[G++]<<Y,Y+=8}J.adler=Q.check=y8(X),X=0,Y=0,Q.mode=J1;case J1:if(Q.havedict===0)return J.next_out=U,J.avail_out=K,J.next_in=G,J.avail_in=P,Q.hold=X,Q.bits=Y,fJ;J.adler=Q.check=1,Q.mode=i;case i:if(W===pJ||W===r0)break J;case N1:if(Q.last){X>>>=Y&7,Y-=Y&7,Q.mode=g1;break}while(Y<3){if(P===0)break J;P--,X+=V[G++]<<Y,Y+=8}switch(Q.last=X&1,X>>>=1,Y-=1,X&3){case 0:Q.mode=R8;break;case 1:if(_J(Q),Q.mode=o0,W===r0){X>>>=2,Y-=2;break J}break;case 2:Q.mode=B8;break;case 3:J.msg="invalid block type",Q.mode=x}X>>>=2,Y-=2;break;case R8:X>>>=Y&7,Y-=Y&7;while(Y<32){if(P===0)break J;P--,X+=V[G++]<<Y,Y+=8}if((X&65535)!==(X>>>16^65535)){J.msg="invalid stored block lengths",Q.mode=x;break}if(Q.length=X&65535,X=0,Y=0,Q.mode=$1,W===r0)break J;case $1:Q.mode=M8;case M8:if(F=Q.length,F){if(F>P)F=P;if(F>K)F=K;if(F===0)break J;q.set(V.subarray(G,G+F),U),P-=F,G+=F,K-=F,U+=F,Q.length-=F;break}Q.mode=i;break;case B8:while(Y<14){if(P===0)break J;P--,X+=V[G++]<<Y,Y+=8}if(Q.nlen=(X&31)+257,X>>>=5,Y-=5,Q.ndist=(X&31)+1,X>>>=5,Y-=5,Q.ncode=(X&15)+4,X>>>=4,Y-=4,Q.nlen>286||Q.ndist>30){J.msg="too many length or distance symbols",Q.mode=x;break}Q.have=0,Q.mode=L8;case L8:while(Q.have<Q.ncode){while(Y<3){if(P===0)break J;P--,X+=V[G++]<<Y,Y+=8}Q.lens[t[Q.have++]]=X&7,X>>>=3,Y-=3}while(Q.have<19)Q.lens[t[Q.have++]]=0;if(Q.lencode=Q.lendyn,Q.lenbits=7,C={bits:Q.lenbits},O=w0(EJ,Q.lens,0,19,Q.lencode,0,Q.work,C),Q.lenbits=C.bits,O){J.msg="invalid code lengths set",Q.mode=x;break}Q.have=0,Q.mode=w8;case w8:while(Q.have<Q.nlen+Q.ndist){for(;;){if(R=Q.lencode[X&(1<<Q.lenbits)-1],N=R>>>24,w=R>>>16&255,g=R&65535,N<=Y)break;if(P===0)break J;P--,X+=V[G++]<<Y,Y+=8}if(g<16)X>>>=N,Y-=N,Q.lens[Q.have++]=g;else{if(g===16){I=N+2;while(Y<I){if(P===0)break J;P--,X+=V[G++]<<Y,Y+=8}if(X>>>=N,Y-=N,Q.have===0){J.msg="invalid bit length repeat",Q.mode=x;break}H=Q.lens[Q.have-1],F=3+(X&3),X>>>=2,Y-=2}else if(g===17){I=N+3;while(Y<I){if(P===0)break J;P--,X+=V[G++]<<Y,Y+=8}X>>>=N,Y-=N,H=0,F=3+(X&7),X>>>=3,Y-=3}else{I=N+7;while(Y<I){if(P===0)break J;P--,X+=V[G++]<<Y,Y+=8}X>>>=N,Y-=N,H=0,F=11+(X&127),X>>>=7,Y-=7}if(Q.have+F>Q.nlen+Q.ndist){J.msg="invalid bit length repeat",Q.mode=x;break}while(F--)Q.lens[Q.have++]=H}}if(Q.mode===x)break;if(Q.lens[256]===0){J.msg="invalid code -- missing end-of-block",Q.mode=x;break}if(Q.lenbits=9,C={bits:Q.lenbits},O=w0(X6,Q.lens,0,Q.nlen,Q.lencode,0,Q.work,C),Q.lenbits=C.bits,O){J.msg="invalid literal/lengths set",Q.mode=x;break}if(Q.distbits=6,Q.distcode=Q.distdyn,C={bits:Q.distbits},O=w0(P6,Q.lens,Q.nlen,Q.ndist,Q.distcode,0,Q.work,C),Q.distbits=C.bits,O){J.msg="invalid distances set",Q.mode=x;break}if(Q.mode=o0,W===r0)break J;case o0:Q.mode=a0;case a0:if(P>=6&&K>=258){if(J.next_out=U,J.avail_out=K,J.next_in=G,J.avail_in=P,Q.hold=X,Q.bits=Y,DJ(J,k),U=J.next_out,q=J.output,K=J.avail_out,G=J.next_in,V=J.input,P=J.avail_in,X=Q.hold,Y=Q.bits,Q.mode===i)Q.back=-1;break}Q.back=0;for(;;){if(R=Q.lencode[X&(1<<Q.lenbits)-1],N=R>>>24,w=R>>>16&255,g=R&65535,N<=Y)break;if(P===0)break J;P--,X+=V[G++]<<Y,Y+=8}if(w&&(w&240)===0){z=N,B=w,A=g;for(;;){if(R=Q.lencode[A+((X&(1<<z+B)-1)>>z)],N=R>>>24,w=R>>>16&255,g=R&65535,z+N<=Y)break;if(P===0)break J;P--,X+=V[G++]<<Y,Y+=8}X>>>=z,Y-=z,Q.back+=z}if(X>>>=N,Y-=N,Q.back+=N,Q.length=g,w===0){Q.mode=T8;break}if(w&32){Q.back=-1,Q.mode=i;break}if(w&64){J.msg="invalid literal/length code",Q.mode=x;break}Q.extra=w&15,Q.mode=O8;case O8:if(Q.extra){I=Q.extra;while(Y<I){if(P===0)break J;P--,X+=V[G++]<<Y,Y+=8}Q.length+=X&(1<<Q.extra)-1,X>>>=Q.extra,Y-=Q.extra,Q.back+=Q.extra}Q.was=Q.length,Q.mode=x8;case x8:for(;;){if(R=Q.distcode[X&(1<<Q.distbits)-1],N=R>>>24,w=R>>>16&255,g=R&65535,N<=Y)break;if(P===0)break J;P--,X+=V[G++]<<Y,Y+=8}if((w&240)===0){z=N,B=w,A=g;for(;;){if(R=Q.distcode[A+((X&(1<<z+B)-1)>>z)],N=R>>>24,w=R>>>16&255,g=R&65535,z+N<=Y)break;if(P===0)break J;P--,X+=V[G++]<<Y,Y+=8}X>>>=z,Y-=z,Q.back+=z}if(X>>>=N,Y-=N,Q.back+=N,w&64){J.msg="invalid distance code",Q.mode=x;break}Q.offset=g,Q.extra=w&15,Q.mode=D8;case D8:if(Q.extra){I=Q.extra;while(Y<I){if(P===0)break J;P--,X+=V[G++]<<Y,Y+=8}Q.offset+=X&(1<<Q.extra)-1,X>>>=Q.extra,Y-=Q.extra,Q.back+=Q.extra}if(Q.offset>Q.dmax){J.msg="invalid distance too far back",Q.mode=x;break}Q.mode=A8;case A8:if(K===0)break J;if(F=k-K,Q.offset>F){if(F=Q.offset-F,F>Q.whave){if(Q.sane){J.msg="invalid distance too far back",Q.mode=x;break}}if(F>Q.wnext)F-=Q.wnext,Z=Q.wsize-F;else Z=Q.wnext-F;if(F>Q.length)F=Q.length;D=Q.window}else D=q,Z=U-Q.offset,F=Q.length;if(F>K)F=K;K-=F,Q.length-=F;do q[U++]=D[Z++];while(--F);if(Q.length===0)Q.mode=a0;break;case T8:if(K===0)break J;q[U++]=Q.length,K--,Q.mode=a0;break;case g1:if(Q.wrap){while(Y<32){if(P===0)break J;P--,X|=V[G++]<<Y,Y+=8}if(k-=K,J.total_out+=k,Q.total+=k,Q.wrap&4&&k)J.adler=Q.check=Q.flags?T(Q.check,q,k,U-k):T0(Q.check,q,k,U-k);if(k=K,Q.wrap&4&&(Q.flags?X:y8(X))!==Q.check){J.msg="incorrect data check",Q.mode=x;break}X=0,Y=0}Q.mode=v8;case v8:if(Q.wrap&&Q.flags){while(Y<32){if(P===0)break J;P--,X+=V[G++]<<Y,Y+=8}if(Q.wrap&4&&X!==(Q.total&4294967295)){J.msg="incorrect length check",Q.mode=x;break}X=0,Y=0}Q.mode=S8;case S8:O=hJ;break J;case x:O=U6;break J;case F6:return Y6;case K6:default:return m}if(J.next_out=U,J.avail_out=K,J.next_in=G,J.avail_in=P,Q.hold=X,Q.bits=Y,Q.wsize||k!==J.avail_out&&Q.mode<x&&(Q.mode<g1||W!==K8)){if(C6(J,J.output,J.next_out,k-J.avail_out));}if($-=J.avail_in,k-=J.avail_out,J.total_in+=$,J.total_out+=k,Q.total+=k,Q.wrap&4&&k)J.adler=Q.check=Q.flags?T(Q.check,q,k,J.next_out-k):T0(Q.check,q,k,J.next_out-k);if(J.data_type=Q.bits+(Q.last?64:0)+(Q.mode===i?128:0)+(Q.mode===o0||Q.mode===$1?256:0),($===0&&k===0||W===K8)&&O===G0)O=mJ;return O},rJ=(J)=>{if(P0(J))return m;let W=J.state;if(W.window)W.window=null;return J.state=null,G0},oJ=(J,W)=>{if(P0(J))return m;const Q=J.state;if((Q.wrap&2)===0)return m;return Q.head=W,W.done=!1,G0},aJ=(J,W)=>{const Q=W.length;let V,q,G;if(P0(J))return m;if(V=J.state,V.wrap!==0&&V.mode!==J1)return m;if(V.mode===J1){if(q=1,q=T0(q,W,Q,0),q!==V.check)return U6}if(G=C6(J,W,Q,Q),G)return V.mode=F6,Y6;return V.havedict=1,G0},eJ=k6,tJ=Z6,sJ=z6,JQ=lJ,QQ=H6,WQ=nJ,VQ=rJ,qQ=oJ,GQ=aJ,XQ="pako inflate (from Nodeca project)",_={inflateReset:eJ,inflateReset2:tJ,inflateResetKeep:sJ,inflateInit:JQ,inflateInit2:QQ,inflate:WQ,inflateEnd:VQ,inflateGetHeader:qQ,inflateSetDictionary:GQ,inflateInfo:XQ},UQ=PQ,N6=Object.prototype.toString,{Z_NO_FLUSH:YQ,Z_FINISH:FQ,Z_OK:y0,Z_STREAM_END:R1,Z_NEED_DICT:M1,Z_STREAM_ERROR:KQ,Z_DATA_ERROR:p8,Z_MEM_ERROR:zQ}=X0;f0.prototype.push=function(J,W){const Q=this.strm,V=this.options.chunkSize,q=this.options.dictionary;let G,U,P;if(this.ended)return!1;if(W===~~W)U=W;else U=W===!0?FQ:YQ;if(N6.call(J)==="[object ArrayBuffer]")Q.input=new Uint8Array(J);else Q.input=J;Q.next_in=0,Q.avail_in=Q.input.length;for(;;){if(Q.avail_out===0)Q.output=new Uint8Array(V),Q.next_out=0,Q.avail_out=V;if(G=_.inflate(Q,U),G===M1&&q){if(G=_.inflateSetDictionary(Q,q),G===y0)G=_.inflate(Q,U);else if(G===p8)G=M1}while(Q.avail_in>0&&G===R1&&Q.state.wrap>0&&J[Q.next_in]!==0)_.inflateReset(Q),G=_.inflate(Q,U);switch(G){case KQ:case p8:case M1:case zQ:return this.onEnd(G),this.ended=!0,!1}if(P=Q.avail_out,Q.next_out){if(Q.avail_out===0||G===R1)if(this.options.to==="string"){let K=S0.utf8border(Q.output,Q.next_out),X=Q.next_out-K,Y=S0.buf2string(Q.output,K);if(Q.next_out=X,Q.avail_out=V-X,X)Q.output.set(Q.output.subarray(K,K+X),0);this.onData(Y)}else this.onData(Q.output.length===Q.next_out?Q.output:Q.output.subarray(0,Q.next_out))}if(G===y0&&P===0)continue;if(G===R1)return G=_.inflateEnd(this.strm),this.onEnd(G),this.ended=!0,!0;if(Q.avail_in===0)break}return!0};f0.prototype.onData=function(J){this.chunks.push(J)};f0.prototype.onEnd=function(J){if(J===y0)if(this.options.to==="string")this.result=this.chunks.join("");else this.result=W1.flattenChunks(this.chunks);this.chunks=[],this.err=J,this.msg=this.strm.msg};var ZQ=f0,HQ=m1,CQ=kQ,NQ=m1,$Q=X0,gQ={Inflate:ZQ,inflate:HQ,inflateRaw:CQ,ungzip:NQ,constants:$Q},{Deflate:IQ,deflate:jQ,deflateRaw:RQ,gzip:MQ}=OJ,{Inflate:BQ,inflate:LQ,inflateRaw:wQ,ungzip:OQ}=gQ,xQ=IQ,DQ=jQ,AQ=RQ,TQ=MQ,vQ=BQ,SQ=LQ,yQ=wQ,EQ=OQ,pQ=X0,b1={Deflate:xQ,deflate:DQ,deflateRaw:AQ,gzip:TQ,Inflate:vQ,inflate:SQ,inflateRaw:yQ,ungzip:EQ,constants:pQ};class u1{constructor(J={}){this.index={},this.maxSize=J.maxSize||1048576,this.fragmentedIndexes={}}insert(J,W){if(this.extractPrefixes(W).forEach((V)=>{if(!this.index[V])this.index[V]=[];if(!this.index[V].includes(J))this.index[V].push(J)}),JSON.stringify(this.index).length>this.maxSize)this.splitIndex()}remove(J,W){this.extractPrefixes(W).forEach((V)=>{if(this.index[V]){if(this.index[V]=this.index[V].filter((q)=>q!==J),this.index[V].length===0)delete this.index[V]}})}extractPrefixes(J){const W=[];if(typeof J==="string")for(let Q=1;Q<=J.length;Q++)W.push(J.substring(0,Q));else if(typeof J==="number")W.push(String(J));else if(typeof J==="object"&&J!==null)Object.keys(J).forEach((Q)=>{W.push(Q.toString());const V=J[Q];if(typeof V==="string"||typeof V==="number")W.push(`${Q}:${V}`)});return W}splitIndex(){const J=Object.keys(this.index),W=Math.ceil(J.length/2),Q={},V={};J.slice(0,W).forEach((q)=>{Q[q]=this.index[q]}),J.slice(W).forEach((q)=>{V[q]=this.index[q]}),this.fragmentedIndexes.fragment1=Q,this.fragmentedIndexes.fragment2=V,this.index={}}mergeFragments(){console.log("\u26A1 Merging fragments of the Radix index...");for(let J of Object.values(this.fragmentedIndexes))Object.assign(this.index,J);this.fragmentedIndexes={},console.log("\u26A1 Fragments merged. Radix index reconstructed:",this.index)}searchByPrefix(J){return this.index[J]||[]}searchAllByPrefix(J){return Object.keys(this.index).filter((Q)=>Q.startsWith(J)).flatMap((Q)=>this.index[Q])}serialize(){const J={index:this.index,fragmentedIndexes:this.fragmentedIndexes};return b1.deflate(G1(J))}deserialize(J){const W=b1.inflate(new Uint8Array(J)),Q=Y1(W);this.index=Q.index||{},this.fragmentedIndexes=Q.fragmentedIndexes||{},console.log("\u26A1 Radix index deserialized:",{index:this.index,fragmentedIndexes:this.fragmentedIndexes})}validateIndex(){if(JSON.stringify(this.index).length>1048576)throw console.error("\u26A1 The Radix index exceeds the maximum allowed size."),new Error("Index too large");if(!this.index||typeof this.index!=="object")console.error("\u26A1 Corrupted Radix index. It will be cleared."),this.index={};console.log("\u26A1 Validation of the Radix index completed without errors.")}}function MW(J){const W=new c1(J),Q=J.put;J.put=async function(G,U){return U=await Q.call(this,G,U),await W.updateIndex(U,G,"insert"),U};const V=J.remove;J.remove=async function(G){const U=this.graph.get(G);if(await V.call(this,G),U)await W.updateIndex(G,U.value,"remove")};const q=J.map;return J.map=async function(...G){const U=await q.call(this,...G),P=G.find((K)=>typeof K==="object");if(P?.query?.id?.$startsWith){const K=P.query.id.$startsWith;console.log(`\u26A1 Performing prefix search in the Radix index: ${K}`);const X=W.searchByPrefix(K);return console.log(`\u26A1 IDs found for prefix '${K}':`,X),U.filter((Y)=>X.includes(Y.id))}return U},J.searchByPrefix=async function(G){return W.searchByPrefix(G).map((P)=>this.graph.get(P))},J}class c1{constructor(J){this.graphDB=J,this.worker=J.worker,this.radix=new u1({maxSize:1048576}),this.indexFileName="graph_radix_index.json",console.log(`\u26A1 Initializing Radix index for the database: ${this.indexFileName}`),this.ready=this.loadIndexFromOPFS().then(()=>this.rebuildIndexFromGraph())}async loadIndexFromOPFS(){try{const J=await new Promise((W,Q)=>{const V=(q)=>{if(q.data.type==="loaded"&&q.data.name===this.indexFileName)this.worker.removeEventListener("message",V),W(new Uint8Array(q.data.data));else if(q.data.type==="error")this.worker.removeEventListener("message",V),Q(new Error(q.data.message||"Error loading the Radix index"))};this.worker.addEventListener("message",V),console.log(`\u26A1 Requesting load of the Radix index from OPFS: ${this.indexFileName}`),this.worker.postMessage({type:"load",name:this.indexFileName})});if(J.byteLength>0)this.radix.deserialize(J),console.log("\u26A1 Radix index loaded successfully from OPFS.");else console.warn("\u26A1 The Radix index file is empty or could not be loaded.")}catch(J){console.warn("\u26A1 Could not load the Radix index:",J.message)}}async rebuildIndexFromGraph(){try{console.log("\u26A1 Starting reconstruction of the Radix index from the graph..."),this.radix.validateIndex(),(await this.graphDB.getAllNodes()).forEach((W)=>{console.log(`\u26A1 Inserting node into Radix index: ID=${W.id}, Value=`,W.value),this.radix.insert(W.id,W.value)}),console.log("\u26A1 Radix index reconstructed successfully.")}catch(J){console.error("\u26A1 Error reconstructing the Radix index:",J.message)}}async saveIndexToOPFS(){try{const J=this.radix.serialize();await new Promise((W,Q)=>{const V=(q)=>{if(q.data.type==="saved"&&q.data.name===this.indexFileName)this.worker.removeEventListener("message",V),W();else if(q.data.type==="error")this.worker.removeEventListener("message",V),Q(new Error(q.data.message||"Error saving the Radix index"))};this.worker.addEventListener("message",V),console.log(`\u26A1 Saving Radix index to OPFS: ${this.indexFileName}`),this.worker.postMessage({type:"save",name:this.indexFileName,content:J})}),console.log("\u26A1 Radix index saved successfully to OPFS.")}catch(J){console.error("\u26A1 Error saving the Radix index:",J.message)}}async updateIndex(J,W,Q="insert"){switch(console.log(`\u26A1 Updating Radix index: ID=${J}, Action=${Q}`),Q){case"insert":console.log(`\u26A1 Inserting node into Radix index: ID=${J}, Value=`,W),this.radix.insert(J,W);break;case"remove":console.log(`\u26A1 Removing node from Radix index: ID=${J}, Value=`,W),this.radix.remove(J,W);break;default:console.warn("\u26A1 Unsupported action in the Radix index.")}await this.saveIndexToOPFS()}searchByPrefix(J){console.log(`\u26A1 Searching in the Radix index with prefix: ${J}`);const W=this.radix.searchAllByPrefix(J);return console.log(`\u26A1 Results found for prefix '${J}':`,W),W}}export{MW as withRadixIndex,c1 as default};
