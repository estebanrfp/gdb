function j0(J){const Z=J.map;return J.map=async function(...j){let H={},_=null;j.forEach((G)=>{if(typeof G==="object")H={...H,...G};if(typeof G==="function")_=G});let A=!1;if(H.prompt)try{const G=await H0(H.prompt);if(console.log("Query generated from local DSL:",G),H={...H,...G},G.__nlqReturnDeepest)A=!0;delete H.prompt}catch(G){console.error("Error parsing prompt:",G.message),H.query={}}const L=A&&_?(G)=>{try{const T=w(G);_&&_(T)}catch{_&&_(G)}}:_,Q=await Z.call(this,H,L);if(A&&Q&&Array.isArray(Q.results))Q.results=w(Q.results);return Q},J}async function H0(J){return J0(J)}var J0=function(J){const Z=i(String(J||""));let j=x(Z);const H={query:{}},_=H.query,A=$0(j);if(A.length){H.$_ors=[];for(let Y of A)H.$_ors.push(Y.left,Y.right),j=W(j,Y.span)}const F=M0(j);if(F)_.type=F.type,H.type=F.type,j=W(j,F.span);if(!_.type){const Y=F0(j);if(Y)_.type=Y.type,H.type=Y.type,j=W(j,Y.span)}const L=Q0(j);if(L&&L.edge){if(_.$edge=L.edge,L.span)j=W(j,L.span)}if(L&&L.edge&&/\bthen\s+finds?\s+(?:that\s+[A-Za-z]+s?\s+)?descendant\s+(?:named|called|with\s+name)\b/i.test(Z))H.__nlqReturnDeepest=!0;const Q=p(j);for(let Y of Q){if(Y.mode==="in"){const K=Y.values??[Y.value];_[Y.field]={..._[Y.field]||{},$in:K}}else _[Y.field]={..._[Y.field]||{},$contains:Y.value};j=W(j,Y.span)}const G=u(j);for(let Y of G)_[Y.field]={..._[Y.field]||{},$regex:`^${Y.value}`},j=W(j,Y.span);const T=c(j);for(let Y of T)_[Y.field]={..._[Y.field]||{},$regex:`${Y.value}\$`},j=W(j,Y.span);const U=d(j);for(let Y of U)_[Y.field]={..._[Y.field]||{},$like:Y.value},j=W(j,Y.span);const B=X0(j);if(B){const Y=B.value,K=[{name:{$regex:Y}},{role:{$regex:Y}},{level:{$regex:Y}},{country:{$regex:Y}},{title:{$regex:Y}},{body:{$regex:Y}},{tags:{$in:[Y]}}];H.query.$or=[...H.query.$or||[],...K],j=W(j,B.span)}else if(Y0(j))H.query.__nlq_no_match="__NLQ_NO_MATCH__";const f=l(j);for(let Y of f)_[Y.field]={..._[Y.field]||{},$exists:!0},j=W(j,Y.span);const $=L0(j);if($.after)H.$after=$.after;if($.before)H.$before=$.before;for(let Y of $.spans)j=W(j,Y);const M=m(j);for(let Y of M)_[Y.field]=Y.value,j=W(j,Y.span);const C=a(j);for(let Y of C)_[Y.field]={..._[Y.field]||{},$between:[Y.min,Y.max]},j=W(j,Y.span);const P=Z0(j);for(let Y of P){if(Y.op==="eq")_[Y.field]=Y.value;else _[Y.field]={..._[Y.field]||{},[Y.op]:Y.value};j=W(j,Y.span)}const v=r(j);for(let Y of v){if(Y.op==="eq")_[Y.field]=Y.value;else _[Y.field]={..._[Y.field]||{},[Y.op]:Y.value};j=W(j,Y.span)}const V=n(j);for(let Y of V)_[Y.field]={..._[Y.field]||{},$not:{$eq:Y.value}},j=W(j,Y.span);const R=o(j);for(let Y of R){if(Y.kind==="in")_.id={..._.id||{},$in:Y.values};else if(Y.kind==="eq")_.id=Y.value;j=W(j,Y.span)}const q=s(j);for(let Y of q)_[Y.field]={..._[Y.field]||{},$in:Y.values},j=W(j,Y.span);const h=_0(j);if(h)H.order=h.order,H.field=h.field;const X=U0(j);if(X!=null)H.$limit=X;if(H.order&&!H.field){const Y=Object.keys(_)[0];if(Y)H.field=Y}if(H.$_ors&&H.$_ors.length)H.query.$or=[...H.query.$or||[],...H.$_ors],delete H.$_ors;return H.query=A0(H.query),H},i=function(J){return J.replace(/\s+/g," ").trim()},W=function(J,Z){if(!Z)return J;return i(`${J.slice(0,Z.start)} ${J.slice(Z.end)}`)},x=function(J){const Z=/^(?:searches\s+for|search\s+for|searches|search|finds?|gets?|lists?|returns?|shows?|filters?)\s+/i;return J.replace(Z,"")},p=function(J){const Z=[],j=[{re:/\bwhose\s+([a-z][\w\.]*)\s+(includes|including|has)\s+((?:"[^\"]+"|[A-Za-z0-9_\-]+)(?:\s*,\s*(?:"[^\"]+"|[A-Za-z0-9_\-]+))*)/ig,mode:"in",list:!0},{re:/\b([a-z][\w\.]*)\s+(includes|including|has)\s+((?:"[^\"]+"|[A-Za-z0-9_\-]+)(?:\s*,\s*(?:"[^\"]+"|[A-Za-z0-9_\-]+))*)/ig,mode:"in",list:!0},{re:/\bwhose\s+([a-z][\w\.]*)\s+(?:contains|containing)\s+(?:the\s+(?:word|phrase|number|value|text|string|token|term|email|url|date|time|datetime)s?\s*:?\s*)?"([^\"]+)"/ig,mode:"contains"},{re:/\bwhose\s+([a-z][\w\.]*)\s+(?:contains|containing)\s+(?:the\s+(?:word|phrase|number|value|text|string|token|term|email|url|date|time|datetime)s?\s*:?\s*)?([A-Za-z0-9_\-]+)/ig,mode:"contains"},{re:/\b([a-z][\w\.]*)\s+(?:contains|containing)\s+(?:the\s+(?:word|phrase|number|value|text|string|token|term|email|url|date|time|datetime)s?\s*:?\s*)?"([^\"]+)"/ig,mode:"contains"},{re:/\b([a-z][\w\.]*)\s+(?:contains|containing)\s+(?:the\s+(?:word|phrase|number|value|text|string|token|term|email|url|date|time|datetime)s?\s*:?\s*)?([A-Za-z0-9_\-]+)/ig,mode:"contains"}];for(let{re:H,mode:_,list:A}of j){let F;while((F=H.exec(J))!==null){const L=F[1];if(_==="in"&&A){const G=F[3].split(/\s*,\s*/).map((T)=>T.replace(/^"|"$/g,""));Z.push({field:L,mode:"in",values:G,span:{start:F.index,end:F.index+F[0].length}})}else if(_==="contains"){const Q=F[2];Z.push({field:L,mode:"contains",value:Q,span:{start:F.index,end:F.index+F[0].length}})}}}return Z},u=function(J){const Z=[],j=/\b(?:whose\s+)?([a-z][\w\.]*)\s+starts\s+with\s+"([^\"]+)"/ig;let H;while((H=j.exec(J))!==null)Z.push({field:H[1],value:H[2],span:{start:H.index,end:H.index+H[0].length}});const _=/\b(?:whose\s+)?([a-z][\w\.]*)\s+starts\s+with\s+([A-Za-z0-9_\-]+)/ig;while((H=_.exec(J))!==null)Z.push({field:H[1],value:H[2],span:{start:H.index,end:H.index+H[0].length}});return Z},c=function(J){const Z=[],j=/\b(?:whose\s+)?([a-z][\w\.]*)\s+ends\s+with\s+"([^\"]+)"/ig;let H;while((H=j.exec(J))!==null)Z.push({field:H[1],value:H[2],span:{start:H.index,end:H.index+H[0].length}});const _=/\b(?:whose\s+)?([a-z][\w\.]*)\s+ends\s+with\s+([A-Za-z0-9_\-]+)/ig;while((H=_.exec(J))!==null)Z.push({field:H[1],value:H[2],span:{start:H.index,end:H.index+H[0].length}});return Z},d=function(J){const Z=[];let j;const H=/\b(?:whose\s+)?([a-z][\w\.]*)\s+like\s+"([^\"]+)"/ig;while((j=H.exec(J))!==null)Z.push({field:j[1],value:j[2],span:{start:j.index,end:j.index+j[0].length}});const _=/\b(?:whose\s+)?([a-z][\w\.]*)\s+like\s+([A-Za-z0-9_%\-\.\*]+)/ig;while((j=_.exec(J))!==null)Z.push({field:j[1],value:j[2],span:{start:j.index,end:j.index+j[0].length}});return Z},X0=function(J){const j=/\b(?:full[-\s]?text\s+search|text\s+search)\s+(?:"([^\"]+)"|([A-Za-z0-9_\-]+))/i.exec(J);if(j)return{value:j[1]||j[2],span:{start:j.index,end:j.index+j[0].length}};return null},Y0=function(J){return/\b(?:full[-\s]?text\s+search|text\s+search|full[-\s]?text)\b/i.test(J)},n=function(J){const Z=[];let j;const H=/\b([a-z][\w\.]*)\s*(?:!=|is\s+not|not\s+equals)\s+"([^\"]+)"\b/ig;while((j=H.exec(J))!==null)Z.push({field:j[1],value:j[2],span:{start:j.index,end:j.index+j[0].length}});const _=/\b([a-z][\w\.]*)\s*(?:!=|is\s+not|not\s+equals)\s+([A-Za-z0-9_\-\.]+)\b/ig;while((j=_.exec(J))!==null)Z.push({field:j[1],value:b(j[2]),span:{start:j.index,end:j.index+j[0].length}});return Z},s=function(J){const Z=[];let j;const H=/\b([a-z][\w\.]*)\s+is\s+([A-Za-z0-9_\-]+)\s+or\s+([A-Za-z0-9_\-]+)(?:\s+or\s+([A-Za-z0-9_\-]+))*/ig;while((j=H.exec(J))!==null){const A=j[1],F=j[0].replace(new RegExp(`^${j[1]}\\s+is\\s+`,"i"),"").split(/\s+or\s+/i).map((L)=>L.trim().replace(/[,\.]$/,""));Z.push({field:A,values:F,span:{start:j.index,end:j.index+j[0].length}})}const _=/\b([a-z][\w\.]*)\s+in\s+((?:"[^\"]+"|[A-Za-z0-9_\-]+)(?:\s*,\s*(?:"[^\"]+"|[A-Za-z0-9_\-]+))*)/ig;while((j=_.exec(J))!==null){const A=j[1],L=j[2].split(/\s*,\s*/).map((Q)=>Q.replace(/^"|"$/g,""));Z.push({field:A,values:L,span:{start:j.index,end:j.index+j[0].length}})}return Z},l=function(J){const Z=[];let j;const H=/\b(?:has|with|having)\s+([a-z][\w\.]*)\b(?!\s+(?:"[^"]+"|[A-Za-z0-9_\-.]+)\b)/ig;while((j=H.exec(J))!==null)Z.push({field:j[1],span:{start:j.index,end:j.index+j[0].length}});const _=/\b(?:has|with|having)\s+([a-z][\w\.]*)\s+exists\b/ig;while((j=_.exec(J))!==null)Z.push({field:j[1],span:{start:j.index,end:j.index+j[0].length}});const A=/\bwhose\s+([a-z][\w\.]*)\s+exists\b/ig;while((j=A.exec(J))!==null)Z.push({field:j[1],span:{start:j.index,end:j.index+j[0].length}});const F=/\b([a-z][\w\.]*)\s+exists\b/ig;while((j=F.exec(J))!==null)Z.push({field:j[1],span:{start:j.index,end:j.index+j[0].length}});return Z},m=function(J){const Z=[];let j;const H=/\bwith\s+([a-z][\w\.]*)\s+("[^"]+"|[A-Za-z0-9_\-.]+)\b/ig;while((j=H.exec(J))!==null){const _=j[1],A=D(j[2]);Z.push({field:_,value:A,span:{start:j.index,end:j.index+j[0].length}})}return Z},a=function(J){const Z=[],j=/\b([a-z][\w\.]*)\s+between\s+(?:"([^"]+)"|([0-9]{4}-[0-9]{2}-[0-9]{2}[T\d:._+\-Z]*))\s*(?:and|,|to)\s*(?:"([^"]+)"|([0-9]{4}-[0-9]{2}-[0-9]{2}[T\d:._+\-Z]*))\b/ig;let H;const _=[];while((H=j.exec(J))!==null){const F={start:H.index,end:H.index+H[0].length};Z.push({field:H[1],min:H[2]||H[3],max:H[4]||H[5],span:F}),_.push(F)}const A=/\b([a-z][\w\.]*)\s+between\s+(-?\d+(?:\.\d+)?)\s*(?:and|,|to)\s*(-?\d+(?:\.\d+)?)\b/ig;while((H=A.exec(J))!==null){const F={start:H.index,end:H.index+H[0].length};if(_.some((Q)=>!(F.end<=Q.start||F.start>=Q.end)))continue;Z.push({field:H[1],min:b(H[2]),max:b(H[3]),span:F})}return Z},o=function(J){const Z=[],j=/\bids?\b\s+((?:-?\d+(?:\.\d+)?\s*,\s*)+-?\d+(?:\.\d+)?)\b/ig;let H;while((H=j.exec(J))!==null){const F=H[1].split(/\s*,\s*/).map(b);Z.push({kind:"in",values:F,span:{start:H.index,end:H.index+H[0].length}})}const _=/\bids?\b\s+(-?\d+(?:\.\d+)?)\b/ig;while((H=_.exec(J))!==null){const A={start:H.index,end:H.index+H[0].length};if(!Z.some((L)=>!(A.end<=L.span.start||A.start>=L.span.end)))Z.push({kind:"eq",value:b(H[1]),span:A})}return Z},r=function(J){const Z=[];let j;const H=/\b([a-z][\w\.]*)\s*(?:>=|at\s+least)\s*(-?\d+(?:\.\d+)?)\b/ig;while((j=H.exec(J))!==null)Z.push({field:j[1],op:"$gte",value:b(j[2]),span:{start:j.index,end:j.index+j[0].length}});const _=/\b([a-z][\w\.]*)\s*(?:<=|at\s+most)\s*(-?\d+(?:\.\d+)?)\b/ig;while((j=_.exec(J))!==null)Z.push({field:j[1],op:"$lte",value:b(j[2]),span:{start:j.index,end:j.index+j[0].length}});const A=/\b([a-z][\w\.]*)\s*(?:>|greater\s+than|more\s+than)\s*(-?\d+(?:\.\d+)?)\b/ig;while((j=A.exec(J))!==null)Z.push({field:j[1],op:"$gt",value:b(j[2]),span:{start:j.index,end:j.index+j[0].length}});const F=/\b([a-z][\w\.]*)\s*(?:<|less\s+than|fewer\s+than)\s*(-?\d+(?:\.\d+)?)\b/ig;while((j=F.exec(J))!==null)Z.push({field:j[1],op:"$lt",value:b(j[2]),span:{start:j.index,end:j.index+j[0].length}});const L=/\b([a-z][\w\.]*)\s*(?:=|equals|is)(?!\s+not)\s*"([^"]+)"\b/ig;while((j=L.exec(J))!==null)Z.push({field:j[1],op:"eq",value:j[2],span:{start:j.index,end:j.index+j[0].length}});const Q=/\b([a-z][\w\.]*)\s*(?:=|equals|is)(?!\s+not)\s*([a-z0-9_\-\.]+)\b/ig;while((j=Q.exec(J))!==null)Z.push({field:j[1],op:"eq",value:b(j[2]),span:{start:j.index,end:j.index+j[0].length}});return Z},Z0=function(J){const Z=[];let j;const H=/\b([a-z][\w\.]*)\s+(on\s+or\s+after|on\s+or\s+before|after|before|on)\s+(?:"([^"]+)"|([0-9]{4}-[0-9]{2}-[0-9]{2}[T\d:._+\-Z]*))\b/ig;while((j=H.exec(J))!==null){const _=j[1],A=j[2].toLowerCase().replace(/\s+/g," "),F=j[3]||j[4];let L="$gt";if(A==="before")L="$lt";else if(A==="on")L="eq";else if(A==="on or after")L="$gte";else if(A==="on or before")L="$lte";Z.push({field:_,op:L,value:F,span:{start:j.index,end:j.index+j[0].length}})}return Z},_0=function(J){const Z=[{re:/\b(?:order|sort|sorted)\s+by\s+([a-z][\w\.]*)\s*(asc|ascending|desc|descending)?\b/i,groups:{field:1,dir:2}},{re:/\b(?:order|sort|sorted)\s+(asc|ascending|desc|descending)\s+by\s+([a-z][\w\.]*)\b/i,groups:{dir:1,field:2}}];for(let j of Z){const H=J.match(j.re);if(H){const _=(H[j.groups.dir]||"asc").toLowerCase(),A=/desc|descending/.test(_)?"desc":"asc";return{field:H[j.groups.field],order:A}}}return null},U0=function(J){const Z=J.match(/\blimit\s+(\d+)\b/i);return Z?Number(Z[1]):null},b=function(J){const Z=Number(J);return Number.isFinite(Z)?Z:J},w=function(J){if(!Array.isArray(J))return J;const Z=[],j=(H)=>{const _=Array.isArray(H?._edgeResult)?H._edgeResult:null;if(_&&_.length)for(let A of _)j(A);else Z.push(H)};for(let H of J)j(H);return Z},$0=function(J){const Z=[];let j;const H=/\b([a-z][\w\.]*)\s*(=|is|equals)\s*("[^"]+"|[A-Za-z0-9_\-.]+)\s+or\s+\1\s*(=|is|equals)\s*("[^"]+"|[A-Za-z0-9_\-.]+)\b/ig;while((j=H.exec(J))!==null){const F={[j[1]]:D(j[3])},L={[j[1]]:D(j[5])};Z.push({left:F,right:L,span:{start:j.index,end:j.index+j[0].length}})}const _=/\b([a-z][\w\.]*)\s+(?:contains|containing)\s+("[^"]+"|[A-Za-z0-9_\-.]+)\s+or\s+\1\s+(?:contains|containing)\s+("[^"]+"|[A-Za-z0-9_\-.]+)\b/ig;while((j=_.exec(J))!==null){const F={[j[1]]:{$contains:D(j[2])}},L={[j[1]]:{$contains:D(j[3])}};Z.push({left:F,right:L,span:{start:j.index,end:j.index+j[0].length}})}const A=/\b([a-z][\w\.]*)\s+starts\s+with\s+("[^"]+"|[A-Za-z0-9_\-]+)\s+or\s+\1\s+starts\s+with\s+("[^"]+"|[A-Za-z0-9_\-]+)\b/ig;while((j=A.exec(J))!==null){const F=String(D(j[2])),L=String(D(j[3])),Q={[j[1]]:{$regex:`^${F}`}},G={[j[1]]:{$regex:`^${L}`}};Z.push({left:Q,right:G,span:{start:j.index,end:j.index+j[0].length}})}return Z},D=function(J){if(!J)return J;const Z=J.replace(/^"|"$/g,"");return b(Z)},A0=function(J){if(!J||typeof J!=="object")return J;const{$edge:Z,...j}=J,H=Z?e(Z):void 0,_=Object.keys(j);if(_.length>1){const A={};if(H)A.$edge=H;return A.$and=_.map((F)=>({[F]:j[F]})),A}return{...j,...Z?{$edge:H}:{}}},e=function(J){if(!J||typeof J!=="object")return J;const{$edge:Z,...j}=J,H=Object.keys(j),_=Z?e(Z):void 0;if(H.length>1){const A={};if(_)A.$edge=_;return A.$and=H.map((F)=>({[F]:j[F]})),A}return{...j,..._?{$edge:_}:{}}},M0=function(J){const j=/\bonly\s+([A-Z][a-zA-Z]+)s?\b/ig.exec(J);if(!j)return null;return{type:O(j[1]),span:{start:j.index,end:j.index+j[0].length}}},F0=function(J){const j=/\b(?:a|an)\s+([A-Z][a-zA-Z]+)s?\b/ig.exec(J);if(!j)return null;return{type:O(j[1]),span:{start:j.index,end:j.index+j[0].length}}},Q0=function(J){const Z=J.split(/\bthen\b/ig).map((L)=>L.trim()).filter(Boolean);let j=null,H=null,_=null,A=null;for(let L of Z){const Q=x(L),G=H?.type?"type":H?.role?"role":null,T=G?String(H[G]).toLowerCase():null;let U=Q.match(/\bdescendant[s]?\s+of\s+type\s+([A-Za-z][A-Za-z]+)s?\b/i),B=null,f="role",$=null,M=null,C=!1,P=Q.match(/\b(?:that|this|those|their|its)\s+([A-Za-z][A-Za-z]+)\s*'s\s+descendant[s]?\b/i);if(!P)P=Q.match(/\b(?:that|this|those|their|its)\s+([A-Za-z][A-Za-z]+)s?\s+descendant[s]?\b/i);if(P){const X=O(P[1]).toLowerCase();if(T&&X===T)C=!0,$=P.index,M=P.index+P[0].length}if(U)B=O(U[1]),$=U.index,M=U.index+U[0].length,f="type";else if(U=!C&&Q.match(/\b(?:that|this|those|their|its|a|an)?\s*([A-Za-z][A-Za-z]+)s?(?:'s)?\s+descendant[s]?\b/i),U)B=O(U[1]),$=U.index,M=U.index+U[0].length;else if(U=!C&&Q.match(/\bdescendant[s]?\s+(?:of\s+)?(?!named\b|called\b|with\b)([A-Za-z][A-Za-z]+)s?\b/i),U)B=O(U[1]),$=U.index,M=U.index+U[0].length;else if(U=Q.match(/\bchild(?:ren)?\s+of\s+type\s+([A-Za-z][A-Za-z]+)s?\b/i),U)B=O(U[1]),$=U.index,M=U.index+U[0].length,f="type";else if(U=Q.match(/\bchild(?:ren)?\s+(?:of\s+)?([A-Za-z][A-Za-z]+)s?\b/i),U)B=O(U[1]),$=U.index,M=U.index+U[0].length;else if(U=Q.match(/\b(?:that|this|those|their|its)?\s*([A-Za-z][A-Za-z]+)s?(?:'s)?\s+child(?:ren)?\b/i),U)B=O(U[1]),$=U.index,M=U.index+U[0].length;else if(U=Q.match(/\bgrandchild(?:ren)?\s+of\s+type\s+([A-Za-z][A-Za-z]+)s?\b/i),U)B=O(U[1]),$=U.index,M=U.index+U[0].length,f="type";else if(U=Q.match(/\bgrandchild(?:ren)?\s+(?:of\s+)?([A-Za-z][A-Za-z]+)s?\b/i),U)B=O(U[1]),$=U.index,M=U.index+U[0].length;else if(U=Q.match(/\b(?:that|this|those|their|its)?\s*([A-Za-z][A-Za-z]+)s?(?:'s)?\s+grandchild(?:ren)?\b/i),U)B=O(U[1]),$=U.index,M=U.index+U[0].length;const v=/\b(descendant|child|children|grandchild|grandchildren)\b/i.test(Q);let V=null;if(B)V={[f]:B};else if(v)V={};else continue;const R=Q.match(/\b(?:named|called)\s+"([^"]+)"|\b(?:named|called)\s+([A-Za-z0-9_\-]+)\b|\bwith\s+name\s+"([^"]+)"|\bwith\s+name\s+([A-Za-z0-9_\-]+)\b/i);if(R){const X=R[1]||R[2]||R[3]||R[4];V.name=X;const Y=R.index,K=R[0].length;if($===null||Y<$)$=Y;const N=Y+K;if(M===null||N>M)M=N}for(let X of p(Q)){if(X.mode==="in"){const Y=X.values??[X.value];V[X.field]={...V[X.field]||{},$in:Y}}else V[X.field]={...V[X.field]||{},$contains:X.value};$=$==null?X.span.start:Math.min($,X.span.start),M=M==null?X.span.end:Math.max(M,X.span.end)}for(let X of u(Q))V[X.field]={...V[X.field]||{},$regex:`^${X.value}`},$=$==null?X.span.start:Math.min($,X.span.start),M=M==null?X.span.end:Math.max(M,X.span.end);for(let X of c(Q))V[X.field]={...V[X.field]||{},$regex:`${X.value}\$`},$=$==null?X.span.start:Math.min($,X.span.start),M=M==null?X.span.end:Math.max(M,X.span.end);for(let X of a(Q))V[X.field]={...V[X.field]||{},$between:[X.min,X.max]},$=$==null?X.span.start:Math.min($,X.span.start),M=M==null?X.span.end:Math.max(M,X.span.end);for(let X of r(Q)){if(X.op==="eq")V[X.field]=X.value;else V[X.field]={...V[X.field]||{},[X.op]:X.value};$=$==null?X.span.start:Math.min($,X.span.start),M=M==null?X.span.end:Math.max(M,X.span.end)}for(let X of n(Q))V[X.field]={...V[X.field]||{},$not:{$eq:X.value}},$=$==null?X.span.start:Math.min($,X.span.start),M=M==null?X.span.end:Math.max(M,X.span.end);for(let X of s(Q))V[X.field]={...V[X.field]||{},$in:X.values},$=$==null?X.span.start:Math.min($,X.span.start),M=M==null?X.span.end:Math.max(M,X.span.end);const q=l(Q);for(let X of q)V[X.field]={...V[X.field]||{},$exists:!0},$=$==null?X.span.start:Math.min($,X.span.start),M=M==null?X.span.end:Math.max(M,X.span.end);let h=Q.replace(/\b(?:has|with|having)\s+[a-z][\w\.]*\s+exists\b/ig," ").replace(/\bwhose\s+[a-z][\w\.]*\s+exists\b/ig," ").replace(/\b([a-z][\w\.]*)\s+exists\b/ig," ").replace(/\b(?:whose\s+)?([a-z][\w\.]*)\s+starts\s+with\s+(?:"[^\"]+"|[A-Za-z0-9_\-]+)/ig," ");for(let X of d(Q))V[X.field]={...V[X.field]||{},$like:X.value},$=$==null?X.span.start:Math.min($,X.span.start),M=M==null?X.span.end:Math.max(M,X.span.end);for(let X of m(h))V[X.field]=X.value,$=$==null?X.span.start:Math.min($,X.span.start),M=M==null?X.span.end:Math.max(M,X.span.end);for(let X of o(Q)){if(X.kind==="in")V.id={...V.id||{},$in:X.values};else if(X.kind==="eq")V.id=X.value;$=$==null?X.span.start:Math.min($,X.span.start),M=M==null?X.span.end:Math.max(M,X.span.end)}if(!V||Object.keys(V).length===0)continue;if(!j)j=V,H=V,_=_??J.indexOf(Q)+($??0),A=J.indexOf(Q)+(M??0);else{const X=H.type?"type":H.role?"role":null,Y=X?String(H[X]).toLowerCase():null,K=V.type?"type":V.role?"role":null,N=K?String(V[K]).toLowerCase():null;if(!H.$edge||typeof H.$edge!=="object")H.$edge={};const z=H.$edge,E=z.type?"type":z.role?"role":null,V0=E?String(z[E]).toLowerCase():null,g=(y)=>{const S={};for(let[I,t]of Object.entries(V)){if(I==="$edge")continue;if(y&&(I==="type"||I==="role"))continue;S[I]=t}return S};if(N&&Y&&N===Y)Object.assign(z,g(!0));else if(N){for(let y of["type","role"])delete z[y];Object.assign(z,g(!1))}else Object.assign(z,g(!1));H=H.$edge;const k=J.indexOf(Q);if(_===null)_=k+($??0);A=k+(M??0)}}if(!j)return null;const F=_!=null&&A!=null?{start:_,end:A}:void 0;return{edge:j,span:F}},O=function(J){if(!J)return J;if(/ies$/i.test(J))return J.replace(/ies$/i,"y");if(/ses$/i.test(J))return J.replace(/es$/i,"e");if(/s$/i.test(J))return J.replace(/s$/i,"");return J},L0=function(J){const Z={after:null,before:null,spans:[]},j=[{kind:"after",re:/\b(?:start(?:ing)?\s+)?after\s+(?:id\s+)?(?:"([^"]+)"|([A-Za-z0-9_\-]+))(?=\s|$)/ig},{kind:"before",re:/\b(?:before|until)\s+(?:id\s+)?(?:"([^"]+)"|([A-Za-z0-9_\-]+))(?=\s|$)/ig}];for(let H of j){let _;while((_=H.re.exec(J))!==null){const A=_[1]||_[2];if(H.kind==="after"&&!Z.after)Z.after=A;if(H.kind==="before"&&!Z.before)Z.before=A;Z.spans.push({start:_.index,end:_.index+_[0].length})}}return Z},G0=(J)=>{return console.log("\uD83E\uDDE0 NLQ module loaded (local DSL)."),j0(J)};export{j0 as withModule,G0 as init};
