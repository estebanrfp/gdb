function e(H){const X=H.map;return H.map=async function(...Z){let A={},Y=null;Z.forEach((W)=>{if(typeof W==="object")A={...A,...W};if(typeof W==="function")Y=W});let F=!1;if(A.prompt)try{const W=await t(A.prompt);if(console.log("Query generated from local DSL:",W),A={...A,...W},W.__nlqReturnDeepest)F=!0;delete A.prompt}catch(W){console.error("Error parsing prompt:",W.message),A.query={}}const V=F&&Y?(W)=>{try{const f=k(W);Y&&Y(f)}catch{Y&&Y(W)}}:Y,M=await X.call(this,A,V);if(F&&M&&Array.isArray(M.results))M.results=k(M.results);return M},H}async function t(H){return ZZ(H)}var ZZ=function(H){const X=w(String(H||""));let Z=S(X);const A={query:{}},Y=A.query,F=HZ(Z);if(F.length){A.$_ors=[];for(let j of F)A.$_ors.push(j.left,j.right),Z=B(Z,j.span)}const Q=XZ(Z);if(Q)Y.type=Q.type,A.type=Q.type,Z=B(Z,Q.span);if(!Y.type){const j=YZ(Z);if(j)Y.type=j.type,A.type=j.type,Z=B(Z,j.span)}const V=_Z(Z);if(V&&V.edge){if(Y.$edge=V.edge,V.span)Z=B(Z,V.span)}if(V&&V.edge&&/\bthen\s+finds?\s+(?:that\s+[A-Za-z]+s?\s+)?descendant\s+(?:named|called|with\s+name)\b/i.test(X))A.__nlqReturnDeepest=!0;const M=x(Z);for(let j of M){if(j.mode==="in"){const R=j.values??[j.value];Y[j.field]={...Y[j.field]||{},$in:R}}else Y[j.field]={...Y[j.field]||{},$contains:j.value};Z=B(Z,j.span)}const W=i(Z);for(let j of W)Y[j.field]={...Y[j.field]||{},$regex:`^${j.value}`},Z=B(Z,j.span);const f=c(Z);for(let j of f)Y[j.field]={...Y[j.field]||{},$exists:!0},Z=B(Z,j.span);const _=d(Z);for(let j of _)Y[j.field]=j.value,Z=B(Z,j.span);const G=n(Z);for(let j of G)Y[j.field]={...Y[j.field]||{},$between:[j.min,j.max]},Z=B(Z,j.span);const K=m(Z);for(let j of K){if(j.op==="eq")Y[j.field]=j.value;else Y[j.field]={...Y[j.field]||{},[j.op]:j.value};Z=B(Z,j.span)}const U=p(Z);for(let j of U)Y[j.field]={...Y[j.field]||{},$not:{$eq:j.value}},Z=B(Z,j.span);const $=s(Z);for(let j of $){if(j.kind==="in")Y.id={...Y.id||{},$in:j.values};else if(j.kind==="eq")Y.id=j.value;Z=B(Z,j.span)}const P=u(Z);for(let j of P)Y[j.field]={...Y[j.field]||{},$in:j.values},Z=B(Z,j.span);const L=AZ(Z);if(L)A.order=L.order,A.field=L.field;const b=jZ(Z);if(b!=null)A.$limit=b;if(A.order&&!A.field){const j=Object.keys(Y)[0];if(j)A.field=j}if(A.$_ors&&A.$_ors.length)A.query.$or=[...A.query.$or||[],...A.$_ors],delete A.$_ors;return A.query=JZ(A.query),A},w=function(H){return H.replace(/\s+/g," ").trim()},B=function(H,X){if(!X)return H;return w(`${H.slice(0,X.start)} ${H.slice(X.end)}`)},S=function(H){const X=/^(?:searches\s+for|search\s+for|searches|search|finds?|gets?|lists?|returns?|shows?|filters?)\s+/i;return H.replace(X,"")},x=function(H){const X=[],Z=[{re:/\bwhose\s+([a-z][\w\.]*)\s+(includes|including|has)\s+((?:"[^\"]+"|[A-Za-z0-9_\-]+)(?:\s*,\s*(?:"[^\"]+"|[A-Za-z0-9_\-]+))*)/ig,mode:"in",list:!0},{re:/\b([a-z][\w\.]*)\s+(includes|including|has)\s+((?:"[^\"]+"|[A-Za-z0-9_\-]+)(?:\s*,\s*(?:"[^\"]+"|[A-Za-z0-9_\-]+))*)/ig,mode:"in",list:!0},{re:/\bwhose\s+([a-z][\w\.]*)\s+(?:contains|containing)\s+(?:the\s+(?:word|phrase|number|value|text|string|token|term|email|url|date|time|datetime)s?\s*:?\s*)?"([^\"]+)"/ig,mode:"contains"},{re:/\bwhose\s+([a-z][\w\.]*)\s+(?:contains|containing)\s+(?:the\s+(?:word|phrase|number|value|text|string|token|term|email|url|date|time|datetime)s?\s*:?\s*)?([A-Za-z0-9_\-]+)/ig,mode:"contains"},{re:/\b([a-z][\w\.]*)\s+(?:contains|containing)\s+(?:the\s+(?:word|phrase|number|value|text|string|token|term|email|url|date|time|datetime)s?\s*:?\s*)?"([^\"]+)"/ig,mode:"contains"},{re:/\b([a-z][\w\.]*)\s+(?:contains|containing)\s+(?:the\s+(?:word|phrase|number|value|text|string|token|term|email|url|date|time|datetime)s?\s*:?\s*)?([A-Za-z0-9_\-]+)/ig,mode:"contains"}];for(let{re:A,mode:Y,list:F}of Z){let Q;while((Q=A.exec(H))!==null){const V=Q[1];if(Y==="in"&&F){const W=Q[3].split(/\s*,\s*/).map((f)=>f.replace(/^"|"$/g,""));X.push({field:V,mode:"in",values:W,span:{start:Q.index,end:Q.index+Q[0].length}})}else if(Y==="contains"){const M=Q[2];X.push({field:V,mode:"contains",value:M,span:{start:Q.index,end:Q.index+Q[0].length}})}}}return X},i=function(H){const X=[],Z=/\b(?:whose\s+)?([a-z][\w\.]*)\s+starts\s+with\s+"([^\"]+)"/ig;let A;while((A=Z.exec(H))!==null)X.push({field:A[1],value:A[2],span:{start:A.index,end:A.index+A[0].length}});const Y=/\b(?:whose\s+)?([a-z][\w\.]*)\s+starts\s+with\s+([A-Za-z0-9_\-]+)/ig;while((A=Y.exec(H))!==null)X.push({field:A[1],value:A[2],span:{start:A.index,end:A.index+A[0].length}});return X},p=function(H){const X=[];let Z;const A=/\b([a-z][\w\.]*)\s*(?:!=|is\s+not|not\s+equals)\s+"([^\"]+)"\b/ig;while((Z=A.exec(H))!==null)X.push({field:Z[1],value:Z[2],span:{start:Z.index,end:Z.index+Z[0].length}});const Y=/\b([a-z][\w\.]*)\s*(?:!=|is\s+not|not\s+equals)\s+([A-Za-z0-9_\-\.]+)\b/ig;while((Z=Y.exec(H))!==null)X.push({field:Z[1],value:D(Z[2]),span:{start:Z.index,end:Z.index+Z[0].length}});return X},u=function(H){const X=[];let Z;const A=/\b([a-z][\w\.]*)\s+is\s+([A-Za-z0-9_\-]+)\s+or\s+([A-Za-z0-9_\-]+)(?:\s+or\s+([A-Za-z0-9_\-]+))*/ig;while((Z=A.exec(H))!==null){const F=Z[1],Q=Z[0].replace(new RegExp(`^${Z[1]}\\s+is\\s+`,"i"),"").split(/\s+or\s+/i).map((V)=>V.trim().replace(/[,\.]$/,""));X.push({field:F,values:Q,span:{start:Z.index,end:Z.index+Z[0].length}})}const Y=/\b([a-z][\w\.]*)\s+in\s+((?:"[^\"]+"|[A-Za-z0-9_\-]+)(?:\s*,\s*(?:"[^\"]+"|[A-Za-z0-9_\-]+))*)/ig;while((Z=Y.exec(H))!==null){const F=Z[1],V=Z[2].split(/\s*,\s*/).map((M)=>M.replace(/^"|"$/g,""));X.push({field:F,values:V,span:{start:Z.index,end:Z.index+Z[0].length}})}return X},c=function(H){const X=[];let Z;const A=/\b(?:has|with|having)\s+([a-z][\w\.]*)\b(?!\s+(?:"[^"]+"|[A-Za-z0-9_\-.]+)\b)/ig;while((Z=A.exec(H))!==null)X.push({field:Z[1],span:{start:Z.index,end:Z.index+Z[0].length}});const Y=/\b(?:has|with|having)\s+([a-z][\w\.]*)\s+exists\b/ig;while((Z=Y.exec(H))!==null)X.push({field:Z[1],span:{start:Z.index,end:Z.index+Z[0].length}});const F=/\bwhose\s+([a-z][\w\.]*)\s+exists\b/ig;while((Z=F.exec(H))!==null)X.push({field:Z[1],span:{start:Z.index,end:Z.index+Z[0].length}});const Q=/\b([a-z][\w\.]*)\s+exists\b/ig;while((Z=Q.exec(H))!==null)X.push({field:Z[1],span:{start:Z.index,end:Z.index+Z[0].length}});return X},d=function(H){const X=[];let Z;const A=/\bwith\s+([a-z][\w\.]*)\s+("[^"]+"|[A-Za-z0-9_\-.]+)\b/ig;while((Z=A.exec(H))!==null){const Y=Z[1],F=q(Z[2]);X.push({field:Y,value:F,span:{start:Z.index,end:Z.index+Z[0].length}})}return X},n=function(H){const X=[],Z=/\b([a-z][\w\.]*)\s+between\s+(-?\d+(?:\.\d+)?)\s*(?:and|,|to)\s*(-?\d+(?:\.\d+)?)\b/ig;let A;while((A=Z.exec(H))!==null)X.push({field:A[1],min:D(A[2]),max:D(A[3]),span:{start:A.index,end:A.index+A[0].length}});return X},s=function(H){const X=[],Z=/\bids?\b\s+((?:-?\d+(?:\.\d+)?\s*,\s*)+-?\d+(?:\.\d+)?)\b/ig;let A;while((A=Z.exec(H))!==null){const Q=A[1].split(/\s*,\s*/).map(D);X.push({kind:"in",values:Q,span:{start:A.index,end:A.index+A[0].length}})}const Y=/\bids?\b\s+(-?\d+(?:\.\d+)?)\b/ig;while((A=Y.exec(H))!==null){const F={start:A.index,end:A.index+A[0].length};if(!X.some((V)=>!(F.end<=V.span.start||F.start>=V.span.end)))X.push({kind:"eq",value:D(A[1]),span:F})}return X},m=function(H){const X=[];let Z;const A=/\b([a-z][\w\.]*)\s*(?:>=|at\s+least)\s*(-?\d+(?:\.\d+)?)\b/ig;while((Z=A.exec(H))!==null)X.push({field:Z[1],op:"$gte",value:D(Z[2]),span:{start:Z.index,end:Z.index+Z[0].length}});const Y=/\b([a-z][\w\.]*)\s*(?:<=|at\s+most)\s*(-?\d+(?:\.\d+)?)\b/ig;while((Z=Y.exec(H))!==null)X.push({field:Z[1],op:"$lte",value:D(Z[2]),span:{start:Z.index,end:Z.index+Z[0].length}});const F=/\b([a-z][\w\.]*)\s*(?:>|greater\s+than|more\s+than)\s*(-?\d+(?:\.\d+)?)\b/ig;while((Z=F.exec(H))!==null)X.push({field:Z[1],op:"$gt",value:D(Z[2]),span:{start:Z.index,end:Z.index+Z[0].length}});const Q=/\b([a-z][\w\.]*)\s*(?:<|less\s+than|fewer\s+than)\s*(-?\d+(?:\.\d+)?)\b/ig;while((Z=Q.exec(H))!==null)X.push({field:Z[1],op:"$lt",value:D(Z[2]),span:{start:Z.index,end:Z.index+Z[0].length}});const V=/\b([a-z][\w\.]*)\s*(?:=|equals|is)(?!\s+not)\s*"([^"]+)"\b/ig;while((Z=V.exec(H))!==null)X.push({field:Z[1],op:"eq",value:Z[2],span:{start:Z.index,end:Z.index+Z[0].length}});const M=/\b([a-z][\w\.]*)\s*(?:=|equals|is)(?!\s+not)\s*([a-z0-9_\-\.]+)\b/ig;while((Z=M.exec(H))!==null)X.push({field:Z[1],op:"eq",value:D(Z[2]),span:{start:Z.index,end:Z.index+Z[0].length}});return X},AZ=function(H){const X=[{re:/\b(?:order|sort|sorted)\s+by\s+([a-z][\w\.]*)\s*(asc|ascending|desc|descending)?\b/i,groups:{field:1,dir:2}},{re:/\b(?:order|sort|sorted)\s+(asc|ascending|desc|descending)\s+by\s+([a-z][\w\.]*)\b/i,groups:{dir:1,field:2}}];for(let Z of X){const A=H.match(Z.re);if(A){const Y=(A[Z.groups.dir]||"asc").toLowerCase(),F=/desc|descending/.test(Y)?"desc":"asc";return{field:A[Z.groups.field],order:F}}}return null},jZ=function(H){const X=H.match(/\blimit\s+(\d+)\b/i);return X?Number(X[1]):null},D=function(H){const X=Number(H);return Number.isFinite(X)?X:H},k=function(H){if(!Array.isArray(H))return H;const X=[],Z=(A)=>{const Y=Array.isArray(A?._edgeResult)?A._edgeResult:null;if(Y&&Y.length)for(let F of Y)Z(F);else X.push(A)};for(let A of H)Z(A);return X},HZ=function(H){const X=[],Z=/\b([a-z][\w\.]*)\s*(=|is|equals)\s*("[^"]+"|[A-Za-z0-9_\-.]+)\s+or\s+([a-z][\w\.]*)\s*(=|is|equals)\s*("[^"]+"|[A-Za-z0-9_\-.]+)\b/ig;let A;while((A=Z.exec(H))!==null){const Y={[A[1]]:q(A[3])},F={[A[4]]:q(A[6])};X.push({left:Y,right:F,span:{start:A.index,end:A.index+A[0].length}})}return X},q=function(H){if(!H)return H;const X=H.replace(/^"|"$/g,"");return D(X)},JZ=function(H){if(!H||typeof H!=="object")return H;const{$edge:X,...Z}=H,A=X?l(X):void 0,Y=Object.keys(Z);if(Y.length>1){const F={};if(A)F.$edge=A;return F.$and=Y.map((Q)=>({[Q]:Z[Q]})),F}return{...Z,...X?{$edge:A}:{}}},l=function(H){if(!H||typeof H!=="object")return H;const{$edge:X,...Z}=H,A=Object.keys(Z),Y=X?l(X):void 0;if(A.length>1){const F={};if(Y)F.$edge=Y;return F.$and=A.map((Q)=>({[Q]:Z[Q]})),F}return{...Z,...Y?{$edge:Y}:{}}},XZ=function(H){const Z=/\bonly\s+([A-Z][a-zA-Z]+)s?\b/ig.exec(H);if(!Z)return null;return{type:O(Z[1]),span:{start:Z.index,end:Z.index+Z[0].length}}},YZ=function(H){const Z=/\b(?:a|an)\s+([A-Z][a-zA-Z]+)s?\b/ig.exec(H);if(!Z)return null;return{type:O(Z[1]),span:{start:Z.index,end:Z.index+Z[0].length}}},_Z=function(H){const X=H.split(/\bthen\b/ig).map((V)=>V.trim()).filter(Boolean);let Z=null,A=null,Y=null,F=null;for(let V of X){const M=S(V),W=A?.type?"type":A?.role?"role":null,f=W?String(A[W]).toLowerCase():null;let _=M.match(/\bdescendant[s]?\s+of\s+type\s+([A-Za-z][A-Za-z]+)s?\b/i),G=null,K="role",U=null,$=null,P=!1,L=M.match(/\b(?:that|this|those|their|its)\s+([A-Za-z][A-Za-z]+)\s*'s\s+descendant[s]?\b/i);if(!L)L=M.match(/\b(?:that|this|those|their|its)\s+([A-Za-z][A-Za-z]+)s?\s+descendant[s]?\b/i);if(L){const J=O(L[1]).toLowerCase();if(f&&J===f)P=!0,U=L.index,$=L.index+L[0].length}if(_)G=O(_[1]),U=_.index,$=_.index+_[0].length,K="type";else if(_=!P&&M.match(/\b(?:that|this|those|their|its|a|an)?\s*([A-Za-z][A-Za-z]+)s?(?:'s)?\s+descendant[s]?\b/i),_)G=O(_[1]),U=_.index,$=_.index+_[0].length;else if(_=!P&&M.match(/\bdescendant[s]?\s+(?:of\s+)?(?!named\b|called\b|with\b)([A-Za-z][A-Za-z]+)s?\b/i),_)G=O(_[1]),U=_.index,$=_.index+_[0].length;else if(_=M.match(/\bchild(?:ren)?\s+of\s+type\s+([A-Za-z][A-Za-z]+)s?\b/i),_)G=O(_[1]),U=_.index,$=_.index+_[0].length,K="type";else if(_=M.match(/\bchild(?:ren)?\s+(?:of\s+)?([A-Za-z][A-Za-z]+)s?\b/i),_)G=O(_[1]),U=_.index,$=_.index+_[0].length;else if(_=M.match(/\b(?:that|this|those|their|its)?\s*([A-Za-z][A-Za-z]+)s?(?:'s)?\s+child(?:ren)?\b/i),_)G=O(_[1]),U=_.index,$=_.index+_[0].length;else if(_=M.match(/\bgrandchild(?:ren)?\s+of\s+type\s+([A-Za-z][A-Za-z]+)s?\b/i),_)G=O(_[1]),U=_.index,$=_.index+_[0].length,K="type";else if(_=M.match(/\bgrandchild(?:ren)?\s+(?:of\s+)?([A-Za-z][A-Za-z]+)s?\b/i),_)G=O(_[1]),U=_.index,$=_.index+_[0].length;else if(_=M.match(/\b(?:that|this|those|their|its)?\s*([A-Za-z][A-Za-z]+)s?(?:'s)?\s+grandchild(?:ren)?\b/i),_)G=O(_[1]),U=_.index,$=_.index+_[0].length;const b=/\b(descendant|child|children|grandchild|grandchildren)\b/i.test(M);let j=null;if(G)j={[K]:G};else if(b)j={};else continue;const R=M.match(/\b(?:named|called)\s+"([^"]+)"|\b(?:named|called)\s+([A-Za-z0-9_\-]+)\b|\bwith\s+name\s+"([^"]+)"|\bwith\s+name\s+([A-Za-z0-9_\-]+)\b/i);if(R){const J=R[1]||R[2]||R[3]||R[4];j.name=J;const z=R.index,N=R[0].length;if(U===null||z<U)U=z;const T=z+N;if($===null||T>$)$=T}for(let J of x(M)){if(J.mode==="in"){const z=J.values??[J.value];j[J.field]={...j[J.field]||{},$in:z}}else j[J.field]={...j[J.field]||{},$contains:J.value};U=U==null?J.span.start:Math.min(U,J.span.start),$=$==null?J.span.end:Math.max($,J.span.end)}for(let J of i(M))j[J.field]={...j[J.field]||{},$regex:`^${J.value}`},U=U==null?J.span.start:Math.min(U,J.span.start),$=$==null?J.span.end:Math.max($,J.span.end);for(let J of n(M))j[J.field]={...j[J.field]||{},$between:[J.min,J.max]},U=U==null?J.span.start:Math.min(U,J.span.start),$=$==null?J.span.end:Math.max($,J.span.end);for(let J of m(M)){if(J.op==="eq")j[J.field]=J.value;else j[J.field]={...j[J.field]||{},[J.op]:J.value};U=U==null?J.span.start:Math.min(U,J.span.start),$=$==null?J.span.end:Math.max($,J.span.end)}for(let J of p(M))j[J.field]={...j[J.field]||{},$not:{$eq:J.value}},U=U==null?J.span.start:Math.min(U,J.span.start),$=$==null?J.span.end:Math.max($,J.span.end);for(let J of u(M))j[J.field]={...j[J.field]||{},$in:J.values},U=U==null?J.span.start:Math.min(U,J.span.start),$=$==null?J.span.end:Math.max($,J.span.end);const a=c(M);for(let J of a)j[J.field]={...j[J.field]||{},$exists:!0},U=U==null?J.span.start:Math.min(U,J.span.start),$=$==null?J.span.end:Math.max($,J.span.end);let o=M.replace(/\b(?:has|with|having)\s+[a-z][\w\.]*\s+exists\b/ig," ").replace(/\bwhose\s+[a-z][\w\.]*\s+exists\b/ig," ").replace(/\b([a-z][\w\.]*)\s+exists\b/ig," ").replace(/\b(?:whose\s+)?([a-z][\w\.]*)\s+starts\s+with\s+(?:"[^\"]+"|[A-Za-z0-9_\-]+)/ig," ");for(let J of d(o))j[J.field]=J.value,U=U==null?J.span.start:Math.min(U,J.span.start),$=$==null?J.span.end:Math.max($,J.span.end);for(let J of s(M)){if(J.kind==="in")j.id={...j.id||{},$in:J.values};else if(J.kind==="eq")j.id=J.value;U=U==null?J.span.start:Math.min(U,J.span.start),$=$==null?J.span.end:Math.max($,J.span.end)}if(!j||Object.keys(j).length===0)continue;if(!Z)Z=j,A=j,Y=Y??H.indexOf(M)+(U??0),F=H.indexOf(M)+($??0);else{const J=A.type?"type":A.role?"role":null,z=J?String(A[J]).toLowerCase():null,N=j.type?"type":j.role?"role":null,T=N?String(j[N]).toLowerCase():null;if(!A.$edge||typeof A.$edge!=="object")A.$edge={};const C=A.$edge,g=C.type?"type":C.role?"role":null,UZ=g?String(C[g]).toLowerCase():null,I=(v)=>{const E={};for(let[h,r]of Object.entries(j)){if(h==="$edge")continue;if(v&&(h==="type"||h==="role"))continue;E[h]=r}return E};if(T&&z&&T===z)Object.assign(C,I(!0));else if(T){for(let v of["type","role"])delete C[v];Object.assign(C,I(!1))}else Object.assign(C,I(!1));A=A.$edge;const y=H.indexOf(M);if(Y===null)Y=y+(U??0);F=y+($??0)}}if(!Z)return null;const Q=Y!=null&&F!=null?{start:Y,end:F}:void 0;return{edge:Z,span:Q}},O=function(H){if(!H)return H;if(/ies$/i.test(H))return H.replace(/ies$/i,"y");if(/ses$/i.test(H))return H.replace(/es$/i,"e");if(/s$/i.test(H))return H.replace(/s$/i,"");return H},$Z=(H)=>{return console.log("\uD83E\uDDE0 NLQ module loaded (local DSL)."),e(H)};export{e as withModule,$Z as init};
