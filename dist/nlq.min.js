function I(f){const j=f.map;return f.map=async function(...A){let $={},H=null;if(A.forEach((Y)=>{if(typeof Y==="object")$={...$,...Y};if(typeof Y==="function")H=Y}),$.prompt)try{const Y=await y($.prompt);console.log("Query generated from local DSL:",Y),$={...$,...Y},delete $.prompt}catch(Y){console.error("Error parsing prompt:",Y.message),$.query={}}return j.call(this,$,H)},f}async function y(f){return v(f)}var v=function(f){const j=P(String(f||""));let A=g(j);const $={query:{}},H=$.query,Y=k(A);if(Y)H.type=Y.type,A=M(A,Y.span);if(!H.type){const h=E(A);if(h)H.type=h.type,A=M(A,h.span)}const V=w(A);if(V&&V.edge){if(H.$edge=V.edge,V.span)A=M(A,V.span)}const U=D(A);for(let h of U){if(h.mode==="in"){const R=h.values??[h.value];H[h.field]={...H[h.field]||{},$in:R}}else H[h.field]={...H[h.field]||{},$contains:h.value};A=M(A,h.span)}const X=z(A);for(let h of X)H[h.field]={...H[h.field]||{},$regex:`^${h.value}`},A=M(A,h.span);const W=L(A);for(let h of W)H[h.field]={...H[h.field]||{},$between:[h.min,h.max]},A=M(A,h.span);const J=O(A);for(let h of J){if(h.op==="eq")H[h.field]=h.value;else H[h.field]={...H[h.field]||{},[h.op]:h.value};A=M(A,h.span)}const K=B(A);for(let h of K)H[h.field]={...H[h.field]||{},$not:{$eq:h.value}},A=M(A,h.span);const _=T(A);for(let h of _){if(h.kind==="in")H.id={...H.id||{},$in:h.values};else if(h.kind==="eq")H.id=h.value;A=M(A,h.span)}const Q=C(A);for(let h of Q)H[h.field]={...H[h.field]||{},$in:h.values},A=M(A,h.span);const Z=N(A);for(let h of Z)H[h.field]={...H[h.field]||{},$exists:!0},A=M(A,h.span);const b=q(A);if(b)$.order=b.order,$.field=b.field;if($.order&&!$.field){const h=Object.keys(H)[0];if(h)$.field=h}return $},P=function(f){return f.replace(/\s+/g," ").trim()},M=function(f,j){if(!j)return f;return P(`${f.slice(0,j.start)} ${f.slice(j.end)}`)},g=function(f){const j=/^(?:searches\s+for|search\s+for|searches|search|finds?|gets?|lists?|returns?|shows?|filters?)\s+/i;return f.replace(j,"")},D=function(f){const j=[],A=[{re:/\bwhose\s+([a-z][\w\.]*)\s+(includes|including|has)\s+((?:"[^\"]+"|[A-Za-z0-9_\-]+)(?:\s*,\s*(?:"[^\"]+"|[A-Za-z0-9_\-]+))*)/ig,mode:"in",list:!0},{re:/\b([a-z][\w\.]*)\s+(includes|including|has)\s+((?:"[^\"]+"|[A-Za-z0-9_\-]+)(?:\s*,\s*(?:"[^\"]+"|[A-Za-z0-9_\-]+))*)/ig,mode:"in",list:!0},{re:/\bwhose\s+([a-z][\w\.]*)\s+(?:contains|containing)\s+(?:the\s+(?:word|phrase|number|value|text|string|token|term|email|url|date|time|datetime)s?\s*:?\s*)?"([^\"]+)"/ig,mode:"contains"},{re:/\bwhose\s+([a-z][\w\.]*)\s+(?:contains|containing)\s+(?:the\s+(?:word|phrase|number|value|text|string|token|term|email|url|date|time|datetime)s?\s*:?\s*)?([A-Za-z0-9_\-]+)/ig,mode:"contains"},{re:/\b([a-z][\w\.]*)\s+(?:contains|containing)\s+(?:the\s+(?:word|phrase|number|value|text|string|token|term|email|url|date|time|datetime)s?\s*:?\s*)?"([^\"]+)"/ig,mode:"contains"},{re:/\b([a-z][\w\.]*)\s+(?:contains|containing)\s+(?:the\s+(?:word|phrase|number|value|text|string|token|term|email|url|date|time|datetime)s?\s*:?\s*)?([A-Za-z0-9_\-]+)/ig,mode:"contains"}];for(let{re:$,mode:H,list:Y}of A){let V;while((V=$.exec(f))!==null){const U=V[1];if(H==="in"&&Y){const W=V[3].split(/\s*,\s*/).map((J)=>J.replace(/^"|"$/g,""));j.push({field:U,mode:"in",values:W,span:{start:V.index,end:V.index+V[0].length}})}else if(H==="contains"){const X=V[2];j.push({field:U,mode:"contains",value:X,span:{start:V.index,end:V.index+V[0].length}})}}}return j},z=function(f){const j=[],A=/\b(?:whose\s+)?([a-z][\w\.]*)\s+starts\s+with\s+"([^\"]+)"/ig;let $;while(($=A.exec(f))!==null)j.push({field:$[1],value:$[2],span:{start:$.index,end:$.index+$[0].length}});const H=/\b(?:whose\s+)?([a-z][\w\.]*)\s+starts\s+with\s+([A-Za-z0-9_\-]+)/ig;while(($=H.exec(f))!==null)j.push({field:$[1],value:$[2],span:{start:$.index,end:$.index+$[0].length}});return j},B=function(f){const j=[];let A;const $=/\b([a-z][\w\.]*)\s*(?:!=|is\s+not|not\s+equals)\s+"([^\"]+)"\b/ig;while((A=$.exec(f))!==null)j.push({field:A[1],value:A[2],span:{start:A.index,end:A.index+A[0].length}});const H=/\b([a-z][\w\.]*)\s*(?:!=|is\s+not|not\s+equals)\s+([A-Za-z0-9_\-\.]+)\b/ig;while((A=H.exec(f))!==null)j.push({field:A[1],value:F(A[2]),span:{start:A.index,end:A.index+A[0].length}});return j},C=function(f){const j=[];let A;const $=/\b([a-z][\w\.]*)\s+is\s+([A-Za-z0-9_\-]+)\s+or\s+([A-Za-z0-9_\-]+)(?:\s+or\s+([A-Za-z0-9_\-]+))*/ig;while((A=$.exec(f))!==null){const Y=A[1],V=A[0].replace(new RegExp(`^${A[1]}\\s+is\\s+`,"i"),"").split(/\s+or\s+/i).map((U)=>U.trim().replace(/[,\.]$/,""));j.push({field:Y,values:V,span:{start:A.index,end:A.index+A[0].length}})}const H=/\b([a-z][\w\.]*)\s+in\s+((?:"[^\"]+"|[A-Za-z0-9_\-]+)(?:\s*,\s*(?:"[^\"]+"|[A-Za-z0-9_\-]+))*)/ig;while((A=H.exec(f))!==null){const Y=A[1],U=A[2].split(/\s*,\s*/).map((X)=>X.replace(/^"|"$/g,""));j.push({field:Y,values:U,span:{start:A.index,end:A.index+A[0].length}})}return j},N=function(f){const j=[];let A;const $=/\b(?:has|with|having)\s+([a-z][\w\.]*)\b/ig;while((A=$.exec(f))!==null)j.push({field:A[1],span:{start:A.index,end:A.index+A[0].length}});const H=/\bwhose\s+([a-z][\w\.]*)\s+exists\b/ig;while((A=H.exec(f))!==null)j.push({field:A[1],span:{start:A.index,end:A.index+A[0].length}});return j},L=function(f){const j=[],A=/\b([a-z][\w\.]*)\s+between\s+(-?\d+(?:\.\d+)?)\s*(?:and|,|to)\s*(-?\d+(?:\.\d+)?)\b/ig;let $;while(($=A.exec(f))!==null)j.push({field:$[1],min:F($[2]),max:F($[3]),span:{start:$.index,end:$.index+$[0].length}});return j},T=function(f){const j=[],A=/\bids?\b\s+((?:-?\d+(?:\.\d+)?\s*,\s*)+-?\d+(?:\.\d+)?)\b/ig;let $;while(($=A.exec(f))!==null){const V=$[1].split(/\s*,\s*/).map(F);j.push({kind:"in",values:V,span:{start:$.index,end:$.index+$[0].length}})}const H=/\bids?\b\s+(-?\d+(?:\.\d+)?)\b/ig;while(($=H.exec(f))!==null){const Y={start:$.index,end:$.index+$[0].length};if(!j.some((U)=>!(Y.end<=U.span.start||Y.start>=U.span.end)))j.push({kind:"eq",value:F($[1]),span:Y})}return j},O=function(f){const j=[];let A;const $=/\b([a-z][\w\.]*)\s*(?:>=|at\s+least)\s*(-?\d+(?:\.\d+)?)\b/ig;while((A=$.exec(f))!==null)j.push({field:A[1],op:"$gte",value:F(A[2]),span:{start:A.index,end:A.index+A[0].length}});const H=/\b([a-z][\w\.]*)\s*(?:<=|at\s+most)\s*(-?\d+(?:\.\d+)?)\b/ig;while((A=H.exec(f))!==null)j.push({field:A[1],op:"$lte",value:F(A[2]),span:{start:A.index,end:A.index+A[0].length}});const Y=/\b([a-z][\w\.]*)\s*(?:>|greater\s+than|more\s+than)\s*(-?\d+(?:\.\d+)?)\b/ig;while((A=Y.exec(f))!==null)j.push({field:A[1],op:"$gt",value:F(A[2]),span:{start:A.index,end:A.index+A[0].length}});const V=/\b([a-z][\w\.]*)\s*(?:<|less\s+than|fewer\s+than)\s*(-?\d+(?:\.\d+)?)\b/ig;while((A=V.exec(f))!==null)j.push({field:A[1],op:"$lt",value:F(A[2]),span:{start:A.index,end:A.index+A[0].length}});const U=/\b([a-z][\w\.]*)\s*(?:=|equals|is)(?!\s+not)\s*"([^"]+)"\b/ig;while((A=U.exec(f))!==null)j.push({field:A[1],op:"eq",value:A[2],span:{start:A.index,end:A.index+A[0].length}});const X=/\b([a-z][\w\.]*)\s*(?:=|equals|is)(?!\s+not)\s*([a-z0-9_\-\.]+)\b/ig;while((A=X.exec(f))!==null)j.push({field:A[1],op:"eq",value:F(A[2]),span:{start:A.index,end:A.index+A[0].length}});return j},q=function(f){const j=/\b(?:order|sort|sorted)\s+by\s+([a-z][\w\.]*)\s*(asc|ascending|desc|descending)?\b/i,A=f.match(j);if(!A)return null;const $=(A[2]||"asc").toLowerCase(),H=/desc|descending/.test($)?"desc":"asc";return{field:A[1],order:H}},F=function(f){const j=Number(f);return Number.isFinite(j)?j:f},k=function(f){const A=/\bonly\s+([A-Z][a-zA-Z]+)s?\b/ig.exec(f);if(!A)return null;return{type:G(A[1]),span:{start:A.index,end:A.index+A[0].length}}},E=function(f){const A=/\b(?:a|an)\s+([A-Z][a-zA-Z]+)s?\b/ig.exec(f);if(!A)return null;return{type:G(A[1]),span:{start:A.index,end:A.index+A[0].length}}},w=function(f){const j=f.split(/\bthen\b/ig).map((U)=>U.trim()).filter(Boolean);let A=null,$=null,H=null,Y=null;for(let U of j){let X=U.match(/\bdescendant[s]?\s+(?:of\s+(?:type\s+)?)?([A-Za-z][A-Za-z]+)s?\b/i),W=null,J=null,K=null;if(X)W=G(X[1]),J=X.index,K=X.index+X[0].length;else if(X=U.match(/\b(?:that|this|those|their|its)?\s*([A-Za-z][A-Za-z]+)s?(?:'s)?\s+descendant[s]?\b/i),X)W=G(X[1]),J=X.index,K=X.index+X[0].length;else if(X=U.match(/\bchild(?:ren)?\s+(?:of\s+(?:type\s+)?)?([A-Za-z][A-Za-z]+)s?\b/i),X)W=G(X[1]),J=X.index,K=X.index+X[0].length;else if(X=U.match(/\b(?:that|this|those|their|its)?\s*([A-Za-z][A-Za-z]+)s?(?:'s)?\s+child(?:ren)?\b/i),X)W=G(X[1]),J=X.index,K=X.index+X[0].length;if(!W)continue;const _={role:W},Q=U.match(/\b(?:named|called)\s+"([^"]+)"|\b(?:named|called)\s+([A-Za-z0-9_\- ]+)\b|\bwith\s+name\s+"([^"]+)"|\bwith\s+name\s+([A-Za-z0-9_\- ]+)\b/i);if(Q){const Z=Q[1]||Q[2]||Q[3]||Q[4];_.$edge={name:Z};const b=Q.index,h=Q[0].length;if(J===null||b<J)J=b;const R=b+h;if(K===null||R>K)K=R}for(let Z of D(U)){if(Z.mode==="in"){const b=Z.values??[Z.value];_[Z.field]={..._[Z.field]||{},$in:b}}else _[Z.field]={..._[Z.field]||{},$contains:Z.value};J=J==null?Z.span.start:Math.min(J,Z.span.start),K=K==null?Z.span.end:Math.max(K,Z.span.end)}for(let Z of z(U))_[Z.field]={..._[Z.field]||{},$regex:`^${Z.value}`},J=J==null?Z.span.start:Math.min(J,Z.span.start),K=K==null?Z.span.end:Math.max(K,Z.span.end);for(let Z of L(U))_[Z.field]={..._[Z.field]||{},$between:[Z.min,Z.max]},J=J==null?Z.span.start:Math.min(J,Z.span.start),K=K==null?Z.span.end:Math.max(K,Z.span.end);for(let Z of O(U)){if(Z.op==="eq")_[Z.field]=Z.value;else _[Z.field]={..._[Z.field]||{},[Z.op]:Z.value};J=J==null?Z.span.start:Math.min(J,Z.span.start),K=K==null?Z.span.end:Math.max(K,Z.span.end)}for(let Z of B(U))_[Z.field]={..._[Z.field]||{},$not:{$eq:Z.value}},J=J==null?Z.span.start:Math.min(J,Z.span.start),K=K==null?Z.span.end:Math.max(K,Z.span.end);for(let Z of C(U))_[Z.field]={..._[Z.field]||{},$in:Z.values},J=J==null?Z.span.start:Math.min(J,Z.span.start),K=K==null?Z.span.end:Math.max(K,Z.span.end);for(let Z of N(U))_[Z.field]={..._[Z.field]||{},$exists:!0},J=J==null?Z.span.start:Math.min(J,Z.span.start),K=K==null?Z.span.end:Math.max(K,Z.span.end);for(let Z of T(U)){if(Z.kind==="in")_.id={..._.id||{},$in:Z.values};else if(Z.kind==="eq")_.id=Z.value;J=J==null?Z.span.start:Math.min(J,Z.span.start),K=K==null?Z.span.end:Math.max(K,Z.span.end)}if(!A)A=_,$=_,H=H??f.indexOf(U)+(J??0),Y=f.indexOf(U)+(K??0);else{if(!$.$edge)$.$edge={};if(_.role&&$.role&&String(_.role).toLowerCase()===String($.role).toLowerCase()){const b={..._.$edge||{}};for(let[h,R]of Object.entries(_))if(h!=="role"&&h!=="$edge")b[h]=R;$.$edge={...$.$edge||{},...b}}else $.$edge={...$.$edge||{},..._};$=$.$edge;const Z=f.indexOf(U);if(H===null)H=Z+(J??0);Y=Z+(K??0)}}if(!A)return null;const V=H!=null&&Y!=null?{start:H,end:Y}:void 0;return{edge:A,span:V}},G=function(f){if(!f)return f;if(/ies$/i.test(f))return f.replace(/ies$/i,"y");if(/ses$/i.test(f))return f.replace(/es$/i,"e");if(/s$/i.test(f))return f.replace(/s$/i,"");return f},S=(f)=>{return console.log("\uD83E\uDDE0 AI: AIQuery module loaded (local DSL)."),I(f)};export{I as withModule,S as init};
