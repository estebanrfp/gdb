function o(X){const H=X.map;return X.map=async function(..._){let Z={},J=null;_.forEach((V)=>{if(typeof V==="object")Z={...Z,...V};if(typeof V==="function")J=V});let M=!1;if(Z.prompt)try{const V=await r(Z.prompt);if(console.log("Query generated from local DSL:",V),Z={...Z,...V},V.__nlqReturnDeepest)M=!0;delete Z.prompt}catch(V){console.error("Error parsing prompt:",V.message),Z.query={}}const W=M&&J?(V)=>{try{const K=k(V);J&&J(K)}catch{J&&J(V)}}:J,F=await H.call(this,Z,W);if(M&&F&&Array.isArray(F.results))F.results=k(F.results);return F},X}async function r(X){return e(X)}var e=function(X){const H=w(String(X||""));let _=S(H);const Z={query:{}},J=Z.query,M=Z_(_);if(M.length){Z.$_ors=[];for(let j of M)Z.$_ors.push(j.left,j.right),_=B(_,j.span)}const Q=X_(_);if(Q)J.type=Q.type,Z.type=Q.type,_=B(_,Q.span);if(!J.type){const j=Y_(_);if(j)J.type=j.type,Z.type=j.type,_=B(_,j.span)}const W=H_(_);if(W&&W.edge){if(J.$edge=W.edge,W.span)_=B(_,W.span)}if(W&&W.edge&&/\bthen\s+finds?\s+(?:that\s+[A-Za-z]+s?\s+)?descendant\s+(?:named|called|with\s+name)\b/i.test(H))Z.__nlqReturnDeepest=!0;const F=x(_);for(let j of F){if(j.mode==="in"){const h=j.values??[j.value];J[j.field]={...J[j.field]||{},$in:h}}else J[j.field]={...J[j.field]||{},$contains:j.value};_=B(_,j.span)}const V=d(_);for(let j of V)J[j.field]=j.value,_=B(_,j.span);const K=p(_);for(let j of K)J[j.field]={...J[j.field]||{},$regex:`^${j.value}`},_=B(_,j.span);const A=n(_);for(let j of A)J[j.field]={...J[j.field]||{},$between:[j.min,j.max]},_=B(_,j.span);const G=m(_);for(let j of G){if(j.op==="eq")J[j.field]=j.value;else J[j.field]={...J[j.field]||{},[j.op]:j.value};_=B(_,j.span)}const O=i(_);for(let j of O)J[j.field]={...J[j.field]||{},$not:{$eq:j.value}},_=B(_,j.span);const U=s(_);for(let j of U){if(j.kind==="in")J.id={...J.id||{},$in:j.values};else if(j.kind==="eq")J.id=j.value;_=B(_,j.span)}const $=u(_);for(let j of $)J[j.field]={...J[j.field]||{},$in:j.values},_=B(_,j.span);const C=c(_);for(let j of C)J[j.field]={...J[j.field]||{},$exists:!0},_=B(_,j.span);const L=t(_);if(L)Z.order=L.order,Z.field=L.field;const b=__(_);if(b!=null)Z.$limit=b;if(Z.order&&!Z.field){const j=Object.keys(J)[0];if(j)Z.field=j}if(Z.$_ors&&Z.$_ors.length)Z.query.$or=[...Z.query.$or||[],...Z.$_ors],delete Z.$_ors;return Z.query=j_(Z.query),Z},w=function(X){return X.replace(/\s+/g," ").trim()},B=function(X,H){if(!H)return X;return w(`${X.slice(0,H.start)} ${X.slice(H.end)}`)},S=function(X){const H=/^(?:searches\s+for|search\s+for|searches|search|finds?|gets?|lists?|returns?|shows?|filters?)\s+/i;return X.replace(H,"")},x=function(X){const H=[],_=[{re:/\bwhose\s+([a-z][\w\.]*)\s+(includes|including|has)\s+((?:"[^\"]+"|[A-Za-z0-9_\-]+)(?:\s*,\s*(?:"[^\"]+"|[A-Za-z0-9_\-]+))*)/ig,mode:"in",list:!0},{re:/\b([a-z][\w\.]*)\s+(includes|including|has)\s+((?:"[^\"]+"|[A-Za-z0-9_\-]+)(?:\s*,\s*(?:"[^\"]+"|[A-Za-z0-9_\-]+))*)/ig,mode:"in",list:!0},{re:/\bwhose\s+([a-z][\w\.]*)\s+(?:contains|containing)\s+(?:the\s+(?:word|phrase|number|value|text|string|token|term|email|url|date|time|datetime)s?\s*:?\s*)?"([^\"]+)"/ig,mode:"contains"},{re:/\bwhose\s+([a-z][\w\.]*)\s+(?:contains|containing)\s+(?:the\s+(?:word|phrase|number|value|text|string|token|term|email|url|date|time|datetime)s?\s*:?\s*)?([A-Za-z0-9_\-]+)/ig,mode:"contains"},{re:/\b([a-z][\w\.]*)\s+(?:contains|containing)\s+(?:the\s+(?:word|phrase|number|value|text|string|token|term|email|url|date|time|datetime)s?\s*:?\s*)?"([^\"]+)"/ig,mode:"contains"},{re:/\b([a-z][\w\.]*)\s+(?:contains|containing)\s+(?:the\s+(?:word|phrase|number|value|text|string|token|term|email|url|date|time|datetime)s?\s*:?\s*)?([A-Za-z0-9_\-]+)/ig,mode:"contains"}];for(let{re:Z,mode:J,list:M}of _){let Q;while((Q=Z.exec(X))!==null){const W=Q[1];if(J==="in"&&M){const V=Q[3].split(/\s*,\s*/).map((K)=>K.replace(/^"|"$/g,""));H.push({field:W,mode:"in",values:V,span:{start:Q.index,end:Q.index+Q[0].length}})}else if(J==="contains"){const F=Q[2];H.push({field:W,mode:"contains",value:F,span:{start:Q.index,end:Q.index+Q[0].length}})}}}return H},p=function(X){const H=[],_=/\b(?:whose\s+)?([a-z][\w\.]*)\s+starts\s+with\s+"([^\"]+)"/ig;let Z;while((Z=_.exec(X))!==null)H.push({field:Z[1],value:Z[2],span:{start:Z.index,end:Z.index+Z[0].length}});const J=/\b(?:whose\s+)?([a-z][\w\.]*)\s+starts\s+with\s+([A-Za-z0-9_\-]+)/ig;while((Z=J.exec(X))!==null)H.push({field:Z[1],value:Z[2],span:{start:Z.index,end:Z.index+Z[0].length}});return H},i=function(X){const H=[];let _;const Z=/\b([a-z][\w\.]*)\s*(?:!=|is\s+not|not\s+equals)\s+"([^\"]+)"\b/ig;while((_=Z.exec(X))!==null)H.push({field:_[1],value:_[2],span:{start:_.index,end:_.index+_[0].length}});const J=/\b([a-z][\w\.]*)\s*(?:!=|is\s+not|not\s+equals)\s+([A-Za-z0-9_\-\.]+)\b/ig;while((_=J.exec(X))!==null)H.push({field:_[1],value:R(_[2]),span:{start:_.index,end:_.index+_[0].length}});return H},u=function(X){const H=[];let _;const Z=/\b([a-z][\w\.]*)\s+is\s+([A-Za-z0-9_\-]+)\s+or\s+([A-Za-z0-9_\-]+)(?:\s+or\s+([A-Za-z0-9_\-]+))*/ig;while((_=Z.exec(X))!==null){const M=_[1],Q=_[0].replace(new RegExp(`^${_[1]}\\s+is\\s+`,"i"),"").split(/\s+or\s+/i).map((W)=>W.trim().replace(/[,\.]$/,""));H.push({field:M,values:Q,span:{start:_.index,end:_.index+_[0].length}})}const J=/\b([a-z][\w\.]*)\s+in\s+((?:"[^\"]+"|[A-Za-z0-9_\-]+)(?:\s*,\s*(?:"[^\"]+"|[A-Za-z0-9_\-]+))*)/ig;while((_=J.exec(X))!==null){const M=_[1],W=_[2].split(/\s*,\s*/).map((F)=>F.replace(/^"|"$/g,""));H.push({field:M,values:W,span:{start:_.index,end:_.index+_[0].length}})}return H},c=function(X){const H=[];let _;const Z=/\b(?:has|with|having)\s+([a-z][\w\.]*)\b(?!\s+(?:"[^"]+"|[A-Za-z0-9_\-.]+)\b)/ig;while((_=Z.exec(X))!==null)H.push({field:_[1],span:{start:_.index,end:_.index+_[0].length}});const J=/\bwhose\s+([a-z][\w\.]*)\s+exists\b/ig;while((_=J.exec(X))!==null)H.push({field:_[1],span:{start:_.index,end:_.index+_[0].length}});return H},d=function(X){const H=[];let _;const Z=/\bwith\s+([a-z][\w\.]*)\s+("[^"]+"|[A-Za-z0-9_\-.]+)\b/ig;while((_=Z.exec(X))!==null){const J=_[1],M=q(_[2]);H.push({field:J,value:M,span:{start:_.index,end:_.index+_[0].length}})}return H},n=function(X){const H=[],_=/\b([a-z][\w\.]*)\s+between\s+(-?\d+(?:\.\d+)?)\s*(?:and|,|to)\s*(-?\d+(?:\.\d+)?)\b/ig;let Z;while((Z=_.exec(X))!==null)H.push({field:Z[1],min:R(Z[2]),max:R(Z[3]),span:{start:Z.index,end:Z.index+Z[0].length}});return H},s=function(X){const H=[],_=/\bids?\b\s+((?:-?\d+(?:\.\d+)?\s*,\s*)+-?\d+(?:\.\d+)?)\b/ig;let Z;while((Z=_.exec(X))!==null){const Q=Z[1].split(/\s*,\s*/).map(R);H.push({kind:"in",values:Q,span:{start:Z.index,end:Z.index+Z[0].length}})}const J=/\bids?\b\s+(-?\d+(?:\.\d+)?)\b/ig;while((Z=J.exec(X))!==null){const M={start:Z.index,end:Z.index+Z[0].length};if(!H.some((W)=>!(M.end<=W.span.start||M.start>=W.span.end)))H.push({kind:"eq",value:R(Z[1]),span:M})}return H},m=function(X){const H=[];let _;const Z=/\b([a-z][\w\.]*)\s*(?:>=|at\s+least)\s*(-?\d+(?:\.\d+)?)\b/ig;while((_=Z.exec(X))!==null)H.push({field:_[1],op:"$gte",value:R(_[2]),span:{start:_.index,end:_.index+_[0].length}});const J=/\b([a-z][\w\.]*)\s*(?:<=|at\s+most)\s*(-?\d+(?:\.\d+)?)\b/ig;while((_=J.exec(X))!==null)H.push({field:_[1],op:"$lte",value:R(_[2]),span:{start:_.index,end:_.index+_[0].length}});const M=/\b([a-z][\w\.]*)\s*(?:>|greater\s+than|more\s+than)\s*(-?\d+(?:\.\d+)?)\b/ig;while((_=M.exec(X))!==null)H.push({field:_[1],op:"$gt",value:R(_[2]),span:{start:_.index,end:_.index+_[0].length}});const Q=/\b([a-z][\w\.]*)\s*(?:<|less\s+than|fewer\s+than)\s*(-?\d+(?:\.\d+)?)\b/ig;while((_=Q.exec(X))!==null)H.push({field:_[1],op:"$lt",value:R(_[2]),span:{start:_.index,end:_.index+_[0].length}});const W=/\b([a-z][\w\.]*)\s*(?:=|equals|is)(?!\s+not)\s*"([^"]+)"\b/ig;while((_=W.exec(X))!==null)H.push({field:_[1],op:"eq",value:_[2],span:{start:_.index,end:_.index+_[0].length}});const F=/\b([a-z][\w\.]*)\s*(?:=|equals|is)(?!\s+not)\s*([a-z0-9_\-\.]+)\b/ig;while((_=F.exec(X))!==null)H.push({field:_[1],op:"eq",value:R(_[2]),span:{start:_.index,end:_.index+_[0].length}});return H},t=function(X){const H=[{re:/\b(?:order|sort|sorted)\s+by\s+([a-z][\w\.]*)\s*(asc|ascending|desc|descending)?\b/i,groups:{field:1,dir:2}},{re:/\b(?:order|sort|sorted)\s+(asc|ascending|desc|descending)\s+by\s+([a-z][\w\.]*)\b/i,groups:{dir:1,field:2}}];for(let _ of H){const Z=X.match(_.re);if(Z){const J=(Z[_.groups.dir]||"asc").toLowerCase(),M=/desc|descending/.test(J)?"desc":"asc";return{field:Z[_.groups.field],order:M}}}return null},__=function(X){const H=X.match(/\blimit\s+(\d+)\b/i);return H?Number(H[1]):null},R=function(X){const H=Number(X);return Number.isFinite(H)?H:X},k=function(X){if(!Array.isArray(X))return X;const H=[],_=(Z)=>{const J=Array.isArray(Z?._edgeResult)?Z._edgeResult:null;if(J&&J.length)for(let M of J)_(M);else H.push(Z)};for(let Z of X)_(Z);return H},Z_=function(X){const H=[],_=/\b([a-z][\w\.]*)\s*(=|is|equals)\s*("[^"]+"|[A-Za-z0-9_\-.]+)\s+or\s+([a-z][\w\.]*)\s*(=|is|equals)\s*("[^"]+"|[A-Za-z0-9_\-.]+)\b/ig;let Z;while((Z=_.exec(X))!==null){const J={[Z[1]]:q(Z[3])},M={[Z[4]]:q(Z[6])};H.push({left:J,right:M,span:{start:Z.index,end:Z.index+Z[0].length}})}return H},q=function(X){if(!X)return X;const H=X.replace(/^"|"$/g,"");return R(H)},j_=function(X){if(!X||typeof X!=="object")return X;const{$edge:H,..._}=X,Z=H?l(H):void 0,J=Object.keys(_);if(J.length>1){const M={};if(Z)M.$edge=Z;return M.$and=J.map((Q)=>({[Q]:_[Q]})),M}return{..._,...H?{$edge:Z}:{}}},l=function(X){if(!X||typeof X!=="object")return X;const{$edge:H,..._}=X,Z=Object.keys(_),J=H?l(H):void 0;if(Z.length>1){const M={};if(J)M.$edge=J;return M.$and=Z.map((Q)=>({[Q]:_[Q]})),M}return{..._,...J?{$edge:J}:{}}},X_=function(X){const _=/\bonly\s+([A-Z][a-zA-Z]+)s?\b/ig.exec(X);if(!_)return null;return{type:D(_[1]),span:{start:_.index,end:_.index+_[0].length}}},Y_=function(X){const _=/\b(?:a|an)\s+([A-Z][a-zA-Z]+)s?\b/ig.exec(X);if(!_)return null;return{type:D(_[1]),span:{start:_.index,end:_.index+_[0].length}}},H_=function(X){const H=X.split(/\bthen\b/ig).map((W)=>W.trim()).filter(Boolean);let _=null,Z=null,J=null,M=null;for(let W of H){const F=S(W),V=Z?.type?"type":Z?.role?"role":null,K=V?String(Z[V]).toLowerCase():null;let A=F.match(/\bdescendant[s]?\s+of\s+type\s+([A-Za-z][A-Za-z]+)s?\b/i),G=null,O="role",U=null,$=null,C=!1,L=F.match(/\b(?:that|this|those|their|its)\s+([A-Za-z][A-Za-z]+)\s*'s\s+descendant[s]?\b/i);if(!L)L=F.match(/\b(?:that|this|those|their|its)\s+([A-Za-z][A-Za-z]+)s?\s+descendant[s]?\b/i);if(L){const Y=D(L[1]).toLowerCase();if(K&&Y===K)C=!0,U=L.index,$=L.index+L[0].length}if(A)G=D(A[1]),U=A.index,$=A.index+A[0].length,O="type";else if(A=!C&&F.match(/\b(?:that|this|those|their|its|a|an)?\s*([A-Za-z][A-Za-z]+)s?(?:'s)?\s+descendant[s]?\b/i),A)G=D(A[1]),U=A.index,$=A.index+A[0].length;else if(A=!C&&F.match(/\bdescendant[s]?\s+(?:of\s+)?(?!named\b|called\b|with\b)([A-Za-z][A-Za-z]+)s?\b/i),A)G=D(A[1]),U=A.index,$=A.index+A[0].length;else if(A=F.match(/\bchild(?:ren)?\s+of\s+type\s+([A-Za-z][A-Za-z]+)s?\b/i),A)G=D(A[1]),U=A.index,$=A.index+A[0].length,O="type";else if(A=F.match(/\bchild(?:ren)?\s+(?:of\s+)?([A-Za-z][A-Za-z]+)s?\b/i),A)G=D(A[1]),U=A.index,$=A.index+A[0].length;else if(A=F.match(/\b(?:that|this|those|their|its)?\s*([A-Za-z][A-Za-z]+)s?(?:'s)?\s+child(?:ren)?\b/i),A)G=D(A[1]),U=A.index,$=A.index+A[0].length;else if(A=F.match(/\bgrandchild(?:ren)?\s+of\s+type\s+([A-Za-z][A-Za-z]+)s?\b/i),A)G=D(A[1]),U=A.index,$=A.index+A[0].length,O="type";else if(A=F.match(/\bgrandchild(?:ren)?\s+(?:of\s+)?([A-Za-z][A-Za-z]+)s?\b/i),A)G=D(A[1]),U=A.index,$=A.index+A[0].length;else if(A=F.match(/\b(?:that|this|those|their|its)?\s*([A-Za-z][A-Za-z]+)s?(?:'s)?\s+grandchild(?:ren)?\b/i),A)G=D(A[1]),U=A.index,$=A.index+A[0].length;const b=/\b(descendant|child|children|grandchild|grandchildren)\b/i.test(F);let j=null;if(G)j={[O]:G};else if(b)j={};else continue;const h=F.match(/\b(?:named|called)\s+"([^"]+)"|\b(?:named|called)\s+([A-Za-z0-9_\- ]+)\b|\bwith\s+name\s+"([^"]+)"|\bwith\s+name\s+([A-Za-z0-9_\- ]+)\b/i);if(h){const Y=h[1]||h[2]||h[3]||h[4];j.name=Y;const T=h.index,f=h[0].length;if(U===null||T<U)U=T;const P=T+f;if($===null||P>$)$=P}for(let Y of x(F)){if(Y.mode==="in"){const T=Y.values??[Y.value];j[Y.field]={...j[Y.field]||{},$in:T}}else j[Y.field]={...j[Y.field]||{},$contains:Y.value};U=U==null?Y.span.start:Math.min(U,Y.span.start),$=$==null?Y.span.end:Math.max($,Y.span.end)}for(let Y of d(F))j[Y.field]=Y.value,U=U==null?Y.span.start:Math.min(U,Y.span.start),$=$==null?Y.span.end:Math.max($,Y.span.end);for(let Y of p(F))j[Y.field]={...j[Y.field]||{},$regex:`^${Y.value}`},U=U==null?Y.span.start:Math.min(U,Y.span.start),$=$==null?Y.span.end:Math.max($,Y.span.end);for(let Y of n(F))j[Y.field]={...j[Y.field]||{},$between:[Y.min,Y.max]},U=U==null?Y.span.start:Math.min(U,Y.span.start),$=$==null?Y.span.end:Math.max($,Y.span.end);for(let Y of m(F)){if(Y.op==="eq")j[Y.field]=Y.value;else j[Y.field]={...j[Y.field]||{},[Y.op]:Y.value};U=U==null?Y.span.start:Math.min(U,Y.span.start),$=$==null?Y.span.end:Math.max($,Y.span.end)}for(let Y of i(F))j[Y.field]={...j[Y.field]||{},$not:{$eq:Y.value}},U=U==null?Y.span.start:Math.min(U,Y.span.start),$=$==null?Y.span.end:Math.max($,Y.span.end);for(let Y of u(F))j[Y.field]={...j[Y.field]||{},$in:Y.values},U=U==null?Y.span.start:Math.min(U,Y.span.start),$=$==null?Y.span.end:Math.max($,Y.span.end);for(let Y of c(F))j[Y.field]={...j[Y.field]||{},$exists:!0},U=U==null?Y.span.start:Math.min(U,Y.span.start),$=$==null?Y.span.end:Math.max($,Y.span.end);for(let Y of s(F)){if(Y.kind==="in")j.id={...j.id||{},$in:Y.values};else if(Y.kind==="eq")j.id=Y.value;U=U==null?Y.span.start:Math.min(U,Y.span.start),$=$==null?Y.span.end:Math.max($,Y.span.end)}if(!j||Object.keys(j).length===0)continue;if(!_)_=j,Z=j,J=J??X.indexOf(F)+(U??0),M=X.indexOf(F)+($??0);else{const Y=Z.type?"type":Z.role?"role":null,T=Y?String(Z[Y]).toLowerCase():null,f=j.type?"type":j.role?"role":null,P=f?String(j[f]).toLowerCase():null;if(!Z.$edge||typeof Z.$edge!=="object")Z.$edge={};const z=Z.$edge,y=z.type?"type":z.role?"role":null,J_=y?String(z[y]).toLowerCase():null,I=(v)=>{const E={};for(let[N,a]of Object.entries(j)){if(N==="$edge")continue;if(v&&(N==="type"||N==="role"))continue;E[N]=a}return E};if(P&&T&&P===T)Object.assign(z,I(!0));else if(P){for(let v of["type","role"])delete z[v];Object.assign(z,I(!1))}else Object.assign(z,I(!1));Z=Z.$edge;const g=X.indexOf(F);if(J===null)J=g+(U??0);M=g+($??0)}}if(!_)return null;const Q=J!=null&&M!=null?{start:J,end:M}:void 0;return{edge:_,span:Q}},D=function(X){if(!X)return X;if(/ies$/i.test(X))return X.replace(/ies$/i,"y");if(/ses$/i.test(X))return X.replace(/es$/i,"e");if(/s$/i.test(X))return X.replace(/s$/i,"");return X},A_=(X)=>{return console.log("\uD83E\uDDE0 AI: AIQuery module loaded (local DSL)."),o(X)};export{o as withModule,A_ as init};
