function o(j){const J=j.map;return j.map=async function(...Z){let _={},X=null;Z.forEach((V)=>{if(typeof V==="object")_={..._,...V};if(typeof V==="function")X=V});let M=!1;if(_.prompt)try{const V=await r(_.prompt);if(console.log("Query generated from local DSL:",V),_={..._,...V},V.__nlqReturnDeepest)M=!0;delete _.prompt}catch(V){console.error("Error parsing prompt:",V.message),_.query={}}const W=M&&X?(V)=>{try{const T=k(V);X&&X(T)}catch{X&&X(V)}}:X,F=await J.call(this,_,W);if(M&&F&&Array.isArray(F.results))F.results=k(F.results);return F},j}async function r(j){return e(j)}var e=function(j){const J=w(String(j||""));let Z=S(J);const _={query:{}},X=_.query,M=_0(Z);if(M.length){_.$_ors=[];for(let A of M)_.$_ors.push(A.left,A.right),Z=B(Z,A.span)}const Q=j0(Z);if(Q)X.type=Q.type,_.type=Q.type,Z=B(Z,Q.span);if(!X.type){const A=H0(Z);if(A)X.type=A.type,_.type=A.type,Z=B(Z,A.span)}const W=J0(Z);if(W&&W.edge){if(X.$edge=W.edge,W.span)Z=B(Z,W.span)}if(W&&W.edge&&/\bthen\s+finds?\s+(?:that\s+[A-Za-z]+s?\s+)?descendant\s+(?:named|called|with\s+name)\b/i.test(J))_.__nlqReturnDeepest=!0;const F=x(Z);for(let A of F){if(A.mode==="in"){const D=A.values??[A.value];X[A.field]={...X[A.field]||{},$in:D}}else X[A.field]={...X[A.field]||{},$contains:A.value};Z=B(Z,A.span)}const V=n(Z);for(let A of V)X[A.field]=A.value,Z=B(Z,A.span);const T=p(Z);for(let A of T)X[A.field]={...X[A.field]||{},$regex:`^${A.value}`},Z=B(Z,A.span);const Y=d(Z);for(let A of Y)X[A.field]={...X[A.field]||{},$between:[A.min,A.max]},Z=B(Z,A.span);const G=m(Z);for(let A of G){if(A.op==="eq")X[A.field]=A.value;else X[A.field]={...X[A.field]||{},[A.op]:A.value};Z=B(Z,A.span)}const P=i(Z);for(let A of P)X[A.field]={...X[A.field]||{},$not:{$eq:A.value}},Z=B(Z,A.span);const U=s(Z);for(let A of U){if(A.kind==="in")X.id={...X.id||{},$in:A.values};else if(A.kind==="eq")X.id=A.value;Z=B(Z,A.span)}const $=u(Z);for(let A of $)X[A.field]={...X[A.field]||{},$in:A.values},Z=B(Z,A.span);const z=c(Z);for(let A of z)X[A.field]={...X[A.field]||{},$exists:!0},Z=B(Z,A.span);const O=t(Z);if(O)_.order=O.order,_.field=O.field;const C=Z0(Z);if(C!=null)_.$limit=C;if(_.order&&!_.field){const A=Object.keys(X)[0];if(A)_.field=A}if(_.$_ors&&_.$_ors.length)_.query.$or=[..._.query.$or||[],..._.$_ors],delete _.$_ors;return _.query=A0(_.query),_},w=function(j){return j.replace(/\s+/g," ").trim()},B=function(j,J){if(!J)return j;return w(`${j.slice(0,J.start)} ${j.slice(J.end)}`)},S=function(j){const J=/^(?:searches\s+for|search\s+for|searches|search|finds?|gets?|lists?|returns?|shows?|filters?)\s+/i;return j.replace(J,"")},x=function(j){const J=[],Z=[{re:/\bwhose\s+([a-z][\w\.]*)\s+(includes|including|has)\s+((?:"[^\"]+"|[A-Za-z0-9_\-]+)(?:\s*,\s*(?:"[^\"]+"|[A-Za-z0-9_\-]+))*)/ig,mode:"in",list:!0},{re:/\b([a-z][\w\.]*)\s+(includes|including|has)\s+((?:"[^\"]+"|[A-Za-z0-9_\-]+)(?:\s*,\s*(?:"[^\"]+"|[A-Za-z0-9_\-]+))*)/ig,mode:"in",list:!0},{re:/\bwhose\s+([a-z][\w\.]*)\s+(?:contains|containing)\s+(?:the\s+(?:word|phrase|number|value|text|string|token|term|email|url|date|time|datetime)s?\s*:?\s*)?"([^\"]+)"/ig,mode:"contains"},{re:/\bwhose\s+([a-z][\w\.]*)\s+(?:contains|containing)\s+(?:the\s+(?:word|phrase|number|value|text|string|token|term|email|url|date|time|datetime)s?\s*:?\s*)?([A-Za-z0-9_\-]+)/ig,mode:"contains"},{re:/\b([a-z][\w\.]*)\s+(?:contains|containing)\s+(?:the\s+(?:word|phrase|number|value|text|string|token|term|email|url|date|time|datetime)s?\s*:?\s*)?"([^\"]+)"/ig,mode:"contains"},{re:/\b([a-z][\w\.]*)\s+(?:contains|containing)\s+(?:the\s+(?:word|phrase|number|value|text|string|token|term|email|url|date|time|datetime)s?\s*:?\s*)?([A-Za-z0-9_\-]+)/ig,mode:"contains"}];for(let{re:_,mode:X,list:M}of Z){let Q;while((Q=_.exec(j))!==null){const W=Q[1];if(X==="in"&&M){const V=Q[3].split(/\s*,\s*/).map((T)=>T.replace(/^"|"$/g,""));J.push({field:W,mode:"in",values:V,span:{start:Q.index,end:Q.index+Q[0].length}})}else if(X==="contains"){const F=Q[2];J.push({field:W,mode:"contains",value:F,span:{start:Q.index,end:Q.index+Q[0].length}})}}}return J},p=function(j){const J=[],Z=/\b(?:whose\s+)?([a-z][\w\.]*)\s+starts\s+with\s+"([^\"]+)"/ig;let _;while((_=Z.exec(j))!==null)J.push({field:_[1],value:_[2],span:{start:_.index,end:_.index+_[0].length}});const X=/\b(?:whose\s+)?([a-z][\w\.]*)\s+starts\s+with\s+([A-Za-z0-9_\-]+)/ig;while((_=X.exec(j))!==null)J.push({field:_[1],value:_[2],span:{start:_.index,end:_.index+_[0].length}});return J},i=function(j){const J=[];let Z;const _=/\b([a-z][\w\.]*)\s*(?:!=|is\s+not|not\s+equals)\s+"([^\"]+)"\b/ig;while((Z=_.exec(j))!==null)J.push({field:Z[1],value:Z[2],span:{start:Z.index,end:Z.index+Z[0].length}});const X=/\b([a-z][\w\.]*)\s*(?:!=|is\s+not|not\s+equals)\s+([A-Za-z0-9_\-\.]+)\b/ig;while((Z=X.exec(j))!==null)J.push({field:Z[1],value:R(Z[2]),span:{start:Z.index,end:Z.index+Z[0].length}});return J},u=function(j){const J=[];let Z;const _=/\b([a-z][\w\.]*)\s+is\s+([A-Za-z0-9_\-]+)\s+or\s+([A-Za-z0-9_\-]+)(?:\s+or\s+([A-Za-z0-9_\-]+))*/ig;while((Z=_.exec(j))!==null){const M=Z[1],Q=Z[0].replace(new RegExp(`^${Z[1]}\\s+is\\s+`,"i"),"").split(/\s+or\s+/i).map((W)=>W.trim().replace(/[,\.]$/,""));J.push({field:M,values:Q,span:{start:Z.index,end:Z.index+Z[0].length}})}const X=/\b([a-z][\w\.]*)\s+in\s+((?:"[^\"]+"|[A-Za-z0-9_\-]+)(?:\s*,\s*(?:"[^\"]+"|[A-Za-z0-9_\-]+))*)/ig;while((Z=X.exec(j))!==null){const M=Z[1],W=Z[2].split(/\s*,\s*/).map((F)=>F.replace(/^"|"$/g,""));J.push({field:M,values:W,span:{start:Z.index,end:Z.index+Z[0].length}})}return J},c=function(j){const J=[];let Z;const _=/\b(?:has|with|having)\s+([a-z][\w\.]*)\b(?!\s+(?:"[^"]+"|[A-Za-z0-9_\-.]+)\b)/ig;while((Z=_.exec(j))!==null)J.push({field:Z[1],span:{start:Z.index,end:Z.index+Z[0].length}});const X=/\bwhose\s+([a-z][\w\.]*)\s+exists\b/ig;while((Z=X.exec(j))!==null)J.push({field:Z[1],span:{start:Z.index,end:Z.index+Z[0].length}});return J},n=function(j){const J=[];let Z;const _=/\bwith\s+([a-z][\w\.]*)\s+("[^"]+"|[A-Za-z0-9_\-.]+)\b/ig;while((Z=_.exec(j))!==null){const X=Z[1],M=q(Z[2]);J.push({field:X,value:M,span:{start:Z.index,end:Z.index+Z[0].length}})}return J},d=function(j){const J=[],Z=/\b([a-z][\w\.]*)\s+between\s+(-?\d+(?:\.\d+)?)\s*(?:and|,|to)\s*(-?\d+(?:\.\d+)?)\b/ig;let _;while((_=Z.exec(j))!==null)J.push({field:_[1],min:R(_[2]),max:R(_[3]),span:{start:_.index,end:_.index+_[0].length}});return J},s=function(j){const J=[],Z=/\bids?\b\s+((?:-?\d+(?:\.\d+)?\s*,\s*)+-?\d+(?:\.\d+)?)\b/ig;let _;while((_=Z.exec(j))!==null){const Q=_[1].split(/\s*,\s*/).map(R);J.push({kind:"in",values:Q,span:{start:_.index,end:_.index+_[0].length}})}const X=/\bids?\b\s+(-?\d+(?:\.\d+)?)\b/ig;while((_=X.exec(j))!==null){const M={start:_.index,end:_.index+_[0].length};if(!J.some((W)=>!(M.end<=W.span.start||M.start>=W.span.end)))J.push({kind:"eq",value:R(_[1]),span:M})}return J},m=function(j){const J=[];let Z;const _=/\b([a-z][\w\.]*)\s*(?:>=|at\s+least)\s*(-?\d+(?:\.\d+)?)\b/ig;while((Z=_.exec(j))!==null)J.push({field:Z[1],op:"$gte",value:R(Z[2]),span:{start:Z.index,end:Z.index+Z[0].length}});const X=/\b([a-z][\w\.]*)\s*(?:<=|at\s+most)\s*(-?\d+(?:\.\d+)?)\b/ig;while((Z=X.exec(j))!==null)J.push({field:Z[1],op:"$lte",value:R(Z[2]),span:{start:Z.index,end:Z.index+Z[0].length}});const M=/\b([a-z][\w\.]*)\s*(?:>|greater\s+than|more\s+than)\s*(-?\d+(?:\.\d+)?)\b/ig;while((Z=M.exec(j))!==null)J.push({field:Z[1],op:"$gt",value:R(Z[2]),span:{start:Z.index,end:Z.index+Z[0].length}});const Q=/\b([a-z][\w\.]*)\s*(?:<|less\s+than|fewer\s+than)\s*(-?\d+(?:\.\d+)?)\b/ig;while((Z=Q.exec(j))!==null)J.push({field:Z[1],op:"$lt",value:R(Z[2]),span:{start:Z.index,end:Z.index+Z[0].length}});const W=/\b([a-z][\w\.]*)\s*(?:=|equals|is)(?!\s+not)\s*"([^"]+)"\b/ig;while((Z=W.exec(j))!==null)J.push({field:Z[1],op:"eq",value:Z[2],span:{start:Z.index,end:Z.index+Z[0].length}});const F=/\b([a-z][\w\.]*)\s*(?:=|equals|is)(?!\s+not)\s*([a-z0-9_\-\.]+)\b/ig;while((Z=F.exec(j))!==null)J.push({field:Z[1],op:"eq",value:R(Z[2]),span:{start:Z.index,end:Z.index+Z[0].length}});return J},t=function(j){const J=[{re:/\b(?:order|sort|sorted)\s+by\s+([a-z][\w\.]*)\s*(asc|ascending|desc|descending)?\b/i,groups:{field:1,dir:2}},{re:/\b(?:order|sort|sorted)\s+(asc|ascending|desc|descending)\s+by\s+([a-z][\w\.]*)\b/i,groups:{dir:1,field:2}}];for(let Z of J){const _=j.match(Z.re);if(_){const X=(_[Z.groups.dir]||"asc").toLowerCase(),M=/desc|descending/.test(X)?"desc":"asc";return{field:_[Z.groups.field],order:M}}}return null},Z0=function(j){const J=j.match(/\blimit\s+(\d+)\b/i);return J?Number(J[1]):null},R=function(j){const J=Number(j);return Number.isFinite(J)?J:j},k=function(j){if(!Array.isArray(j))return j;const J=[],Z=(_)=>{const X=Array.isArray(_?._edgeResult)?_._edgeResult:null;if(X&&X.length)for(let M of X)Z(M);else J.push(_)};for(let _ of j)Z(_);return J},_0=function(j){const J=[],Z=/\b([a-z][\w\.]*)\s*(=|is|equals)\s*("[^"]+"|[A-Za-z0-9_\-.]+)\s+or\s+([a-z][\w\.]*)\s*(=|is|equals)\s*("[^"]+"|[A-Za-z0-9_\-.]+)\b/ig;let _;while((_=Z.exec(j))!==null){const X={[_[1]]:q(_[3])},M={[_[4]]:q(_[6])};J.push({left:X,right:M,span:{start:_.index,end:_.index+_[0].length}})}return J},q=function(j){if(!j)return j;const J=j.replace(/^"|"$/g,"");return R(J)},A0=function(j){if(!j||typeof j!=="object")return j;const{$edge:J,...Z}=j,_=J?l(J):void 0,X=Object.keys(Z);if(X.length>1){const M={};if(_)M.$edge=_;return M.$and=X.map((Q)=>({[Q]:Z[Q]})),M}return{...Z,...J?{$edge:_}:{}}},l=function(j){if(!j||typeof j!=="object")return j;const{$edge:J,...Z}=j,_=Object.keys(Z),X=J?l(J):void 0;if(_.length>1){const M={};if(X)M.$edge=X;return M.$and=_.map((Q)=>({[Q]:Z[Q]})),M}return{...Z,...X?{$edge:X}:{}}},j0=function(j){const Z=/\bonly\s+([A-Z][a-zA-Z]+)s?\b/ig.exec(j);if(!Z)return null;return{type:L(Z[1]),span:{start:Z.index,end:Z.index+Z[0].length}}},H0=function(j){const Z=/\b(?:a|an)\s+([A-Z][a-zA-Z]+)s?\b/ig.exec(j);if(!Z)return null;return{type:L(Z[1]),span:{start:Z.index,end:Z.index+Z[0].length}}},J0=function(j){const J=j.split(/\bthen\b/ig).map((W)=>W.trim()).filter(Boolean);let Z=null,_=null,X=null,M=null;for(let W of J){const F=S(W),V=_?.type?"type":_?.role?"role":null,T=V?String(_[V]).toLowerCase():null;let Y=F.match(/\bdescendant[s]?\s+of\s+type\s+([A-Za-z][A-Za-z]+)s?\b/i),G=null,P="role",U=null,$=null,z=!1,O=F.match(/\b(?:that|this|those|their|its)\s+([A-Za-z][A-Za-z]+)\s*'s\s+descendant[s]?\b/i);if(!O)O=F.match(/\b(?:that|this|those|their|its)\s+([A-Za-z][A-Za-z]+)s?\s+descendant[s]?\b/i);if(O){const H=L(O[1]).toLowerCase();if(T&&H===T)z=!0,U=O.index,$=O.index+O[0].length}if(Y)G=L(Y[1]),U=Y.index,$=Y.index+Y[0].length,P="type";else if(Y=!z&&F.match(/\b(?:that|this|those|their|its|a|an)?\s*([A-Za-z][A-Za-z]+)s?(?:'s)?\s+descendant[s]?\b/i),Y)G=L(Y[1]),U=Y.index,$=Y.index+Y[0].length;else if(Y=!z&&F.match(/\bdescendant[s]?\s+(?:of\s+)?(?!named\b|called\b|with\b)([A-Za-z][A-Za-z]+)s?\b/i),Y)G=L(Y[1]),U=Y.index,$=Y.index+Y[0].length;else if(Y=F.match(/\bchild(?:ren)?\s+of\s+type\s+([A-Za-z][A-Za-z]+)s?\b/i),Y)G=L(Y[1]),U=Y.index,$=Y.index+Y[0].length,P="type";else if(Y=F.match(/\bchild(?:ren)?\s+(?:of\s+)?([A-Za-z][A-Za-z]+)s?\b/i),Y)G=L(Y[1]),U=Y.index,$=Y.index+Y[0].length;else if(Y=F.match(/\b(?:that|this|those|their|its)?\s*([A-Za-z][A-Za-z]+)s?(?:'s)?\s+child(?:ren)?\b/i),Y)G=L(Y[1]),U=Y.index,$=Y.index+Y[0].length;else if(Y=F.match(/\bgrandchild(?:ren)?\s+of\s+type\s+([A-Za-z][A-Za-z]+)s?\b/i),Y)G=L(Y[1]),U=Y.index,$=Y.index+Y[0].length,P="type";else if(Y=F.match(/\bgrandchild(?:ren)?\s+(?:of\s+)?([A-Za-z][A-Za-z]+)s?\b/i),Y)G=L(Y[1]),U=Y.index,$=Y.index+Y[0].length;else if(Y=F.match(/\b(?:that|this|those|their|its)?\s*([A-Za-z][A-Za-z]+)s?(?:'s)?\s+grandchild(?:ren)?\b/i),Y)G=L(Y[1]),U=Y.index,$=Y.index+Y[0].length;const C=/\b(descendant|child|children|grandchild|grandchildren)\b/i.test(F);let A=null;if(G)A={[P]:G};else if(C)A={};else continue;const D=F.match(/\b(?:named|called)\s+"([^"]+)"|\b(?:named|called)\s+([A-Za-z0-9_\- ]+)\b|\bwith\s+name\s+"([^"]+)"|\bwith\s+name\s+([A-Za-z0-9_\- ]+)\b/i);if(D){const H=D[1]||D[2]||D[3]||D[4];A.name=H;const b=D.index,h=D[0].length;if(U===null||b<U)U=b;const f=b+h;if($===null||f>$)$=f}for(let H of x(F)){if(H.mode==="in"){const b=H.values??[H.value];A[H.field]={...A[H.field]||{},$in:b}}else A[H.field]={...A[H.field]||{},$contains:H.value};U=U==null?H.span.start:Math.min(U,H.span.start),$=$==null?H.span.end:Math.max($,H.span.end)}for(let H of n(F))A[H.field]=H.value,U=U==null?H.span.start:Math.min(U,H.span.start),$=$==null?H.span.end:Math.max($,H.span.end);for(let H of p(F))A[H.field]={...A[H.field]||{},$regex:`^${H.value}`},U=U==null?H.span.start:Math.min(U,H.span.start),$=$==null?H.span.end:Math.max($,H.span.end);for(let H of d(F))A[H.field]={...A[H.field]||{},$between:[H.min,H.max]},U=U==null?H.span.start:Math.min(U,H.span.start),$=$==null?H.span.end:Math.max($,H.span.end);for(let H of m(F)){if(H.op==="eq")A[H.field]=H.value;else A[H.field]={...A[H.field]||{},[H.op]:H.value};U=U==null?H.span.start:Math.min(U,H.span.start),$=$==null?H.span.end:Math.max($,H.span.end)}for(let H of i(F))A[H.field]={...A[H.field]||{},$not:{$eq:H.value}},U=U==null?H.span.start:Math.min(U,H.span.start),$=$==null?H.span.end:Math.max($,H.span.end);for(let H of u(F))A[H.field]={...A[H.field]||{},$in:H.values},U=U==null?H.span.start:Math.min(U,H.span.start),$=$==null?H.span.end:Math.max($,H.span.end);for(let H of c(F))A[H.field]={...A[H.field]||{},$exists:!0},U=U==null?H.span.start:Math.min(U,H.span.start),$=$==null?H.span.end:Math.max($,H.span.end);for(let H of s(F)){if(H.kind==="in")A.id={...A.id||{},$in:H.values};else if(H.kind==="eq")A.id=H.value;U=U==null?H.span.start:Math.min(U,H.span.start),$=$==null?H.span.end:Math.max($,H.span.end)}if(!A||Object.keys(A).length===0)continue;if(!Z)Z=A,_=A,X=X??j.indexOf(F)+(U??0),M=j.indexOf(F)+($??0);else{const H=_.type?"type":_.role?"role":null,b=H?String(_[H]).toLowerCase():null,h=A.type?"type":A.role?"role":null,f=h?String(A[h]).toLowerCase():null;if(!_.$edge||typeof _.$edge!=="object")_.$edge={};const K=_.$edge,E=K.type?"type":K.role?"role":null,X0=E?String(K[E]).toLowerCase():null,I=(v)=>{const g={};for(let[N,a]of Object.entries(A)){if(N==="$edge")continue;if(v&&(N==="type"||N==="role"))continue;g[N]=a}return g};if(f&&b&&f===b)Object.assign(K,I(!0));else if(f){for(let v of["type","role"])delete K[v];Object.assign(K,I(!1))}else Object.assign(K,I(!1));_=_.$edge;const y=j.indexOf(F);if(X===null)X=y+(U??0);M=y+($??0)}}if(!Z)return null;const Q=X!=null&&M!=null?{start:X,end:M}:void 0;return{edge:Z,span:Q}},L=function(j){if(!j)return j;if(/ies$/i.test(j))return j.replace(/ies$/i,"y");if(/ses$/i.test(j))return j.replace(/es$/i,"e");if(/s$/i.test(j))return j.replace(/s$/i,"");return j},Y0=(j)=>{return console.log("\uD83E\uDDE0 NLQ module loaded (local DSL)."),o(j)};export{o as withModule,Y0 as init};
