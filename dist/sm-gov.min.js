async function C(){console.log("\uD83D\uDCDC GOVERNANCE: Checking rules...");for(let m of B)try{const{results:f}=await h.map({query:m.if});if(f.length===0)continue;for(let T of f){const q=T.id.split(":")[1];if(!m.offsetTimestamp||T.timestamp.physical<=Date.now()-m.offsetTimestamp)await D(m.then,q)}}catch(f){console.error("\u274C GOVERNANCE ERROR: Failed to process rule.",{rule:m,error:f.message})}}async function D(m,f){if(m.assignRole){const T=m.assignRole,q=`user:${f}`,{result:z}=await h.get(q);if(!z)return;const F=z.value.role;if(F==="superadmin")return;if(F!==T)console.log(`\uD83D\uDCDC GOVERNANCE: Promoting ${f.slice(0,10)}... from '${F}' to '${T}'.`),await h.sm.executeWithPermission("assignRole"),await h.sm.assignRole(f,T)}}var H=function(){console.log("\u2705 GOVERNANCE ENGINE: Activated. Starting periodic checks."),j=setInterval(C,4000),k=!0},J=function(){if(!k)return;clearInterval(j),j=null,k=!1,console.log("\uD83D\uDED1 GOVERNANCE ENGINE: Deactivated. Pausing checks.")};function K(m,f={}){if(!m||!f.governanceRules)return console.error("\u274C GOVERNANCE: Initialization failed: gdb instance and rules are required.");h=m,B=f.governanceRules,m.sm.setGovernanceStateChangeCallback(async(T)=>{if(T.isActive&&T.activeAddress&&f.superAdmins.includes(T.activeAddress))await h.sm.executeWithPermission("assignRole"),H();else J()})}var h=null,B=[],j=null,k=!1;export{K as start};
