async function D(){for(let m of z)try{const{results:f}=await q.map({query:m.if});if(f.length===0)continue;for(let h of f){const P=h.id.split(":")[1];if(!m.offsetTimestamp||h.timestamp.physical<=Date.now()-m.offsetTimestamp)await F(m.then,P)}}catch(f){console.error("\u274C GOVERNANCE ERROR: Failed to process rule.",{rule:m,error:f.message})}}async function F(m,f){if(m.assignRole){const h=m.assignRole,P=`user:${f}`,{result:B}=await q.get(P),k=B.value.role;if(k==="superadmin")return;if(k!==h)await q.sm.executeWithPermission("assignRole"),await q.sm.assignRole(f,h)}}var G=function(){console.log("\u2705 GOVERNANCE ENGINE: Activated. Starting periodic checks."),V=setInterval(D,4000),j=!0},H=function(){if(!j)return;clearInterval(V),V=null,j=!1,console.log("\uD83D\uDED1 GOVERNANCE ENGINE: Deactivated. Pausing checks.")};function J(m,f={}){if(!m||!f.governanceRules)return console.error("\u274C GOVERNANCE: Initialization failed: gdb instance and rules are required.");q=m,z=f.governanceRules,m.sm.setGovernanceStateChangeCallback(async(h)=>{if(h.isActive&&h.activeAddress&&f.superAdmins.includes(h.activeAddress))await q.sm.executeWithPermission("assignRole"),G();else H()})}var q=null,z=[],V=null,j=!1;export{J as start};
