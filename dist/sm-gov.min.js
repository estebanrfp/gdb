async function q(){console.log("\uD83D\uDD04 GOVERNANCE: Checking rules...");for(let m of z)try{const{results:f}=await O.map({query:m.if});if(f.length===0)continue;for(let M of f){const S=M.id.split(":")[1];if(!S){console.warn(`\uD83D\uDCDC Governance: Could not derive user address from trigger node ID: ${M.id}`);continue}await B(m.then,S)}}catch(f){console.error("\u274C GOVERNANCE ERROR: Failed to process rule.",{rule:m,error:f.message})}}async function B(m,f){if(m.assignRole){const M=m.assignRole,S=`user:${f}`,{result:k}=await O.get(S);if(!k)return;const T=k.value.role;if(T==="superadmin")return;if(T!==M)console.log(`\uD83D\uDE80 GOVERNANCE ACTION: Promoting ${f.slice(0,10)}... from '${T}' to '${M}'.`),await O.sm.executeWithPermission("assignRole"),await O.sm.assignRole(f,M)}}var D=function(){console.log("\u2705 GOVERNANCE ENGINE: Activated. Starting periodic checks."),q(),h=setInterval(q,4000),j=!0},F=function(){if(!j)return;clearInterval(h),h=null,j=!1,console.log("\uD83D\uDED1 GOVERNANCE ENGINE: Deactivated. Pausing checks.")};function H(m,f={}){if(!m||!f.governanceRules)return console.error("\u274C GOVERNANCE: Initialization failed: gdb instance and rules are required.");O=m,z=f.governanceRules,m.sm.setGovernanceStateChangeCallback(async(M)=>{if(M.isActive&&M.activeAddress&&f.superAdmins.includes(M.activeAddress))await O.sm.executeWithPermission("assignRole"),D();else F()})}var O=null,z=[],h=null,j=!1;export{H as start};
